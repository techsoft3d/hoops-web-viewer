function Up(n, t) {
  for (var e = 0; e < t.length; e++) {
    const i = t[e];
    if (typeof i != "string" && !Array.isArray(i)) {
      for (const s in i)
        if (s !== "default" && !(s in n)) {
          const r = Object.getOwnPropertyDescriptor(i, s);
          r && Object.defineProperty(n, s, r.get ? r : {
            enumerable: !0,
            get: () => i[s]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
const Qp = "¹", tu = "²", eu = "³", ic = "⁻", qp = "Ω";
var le = /* @__PURE__ */ ((n) => (n[n.unitUnknown = 0] = "unitUnknown", n[n.unitLength = 1] = "unitLength", n[n.unitMass = 2] = "unitMass", n[n.unitTime = 3] = "unitTime", n[n.unitElectricCurrent = 4] = "unitElectricCurrent", n[n.unitThermoTemperature = 5] = "unitThermoTemperature", n[n.unitSubstanceAmount = 6] = "unitSubstanceAmount", n[n.unitLuminosityIntensity = 7] = "unitLuminosityIntensity", n[n.unitPlaneAngle = 8] = "unitPlaneAngle", n[n.unitSolidAngle = 9] = "unitSolidAngle", n[n.unitFrequency = 10] = "unitFrequency", n[n.unitForce = 11] = "unitForce", n[n.unitPressure = 12] = "unitPressure", n[n.unitEnergy = 13] = "unitEnergy", n[n.unitPower = 14] = "unitPower", n[n.unitElectricCharge = 15] = "unitElectricCharge", n[n.unitElectromotiveForce = 16] = "unitElectromotiveForce", n[n.unitCapacitance = 17] = "unitCapacitance", n[n.unitElectricResistance = 18] = "unitElectricResistance", n[n.unitElectricConductance = 19] = "unitElectricConductance", n[n.unitMagneticFlux = 20] = "unitMagneticFlux", n[n.unitMagneticFluxDensity = 21] = "unitMagneticFluxDensity", n[n.unitInductance = 22] = "unitInductance", n[n.unitLuminousFlux = 23] = "unitLuminousFlux", n[n.unitIlluminance = 24] = "unitIlluminance", n[n.unitActivityRadionuclide = 25] = "unitActivityRadionuclide", n[n.unitKerma = 26] = "unitKerma", n[n.unitDoseEquivalent = 27] = "unitDoseEquivalent", n[n.unitCatalyticActivity = 28] = "unitCatalyticActivity", n))(le || {});
function Du(n) {
  return n !== null && typeof n == "object" && "x" in n && typeof n.x == "number" && "y" in n && typeof n.y == "number";
}
function zu(n) {
  return n !== null && typeof n == "object" && "z" in n && typeof n.z == "number" && Du(n);
}
function E0(n) {
  return n !== null && typeof n == "object" && "w" in n && typeof n.w == "number" && zu(n);
}
class d {
  /**
   * Creates a new point object.
   * @param x X value
   * @param y Y value
   * @param z Z value
   */
  constructor(t, e, i) {
    this.x = t, this.y = e, this.z = i;
  }
  /**
   * Sets this point equal to another point.
   * @param point The point to assign.
   * @returns This point object.
   */
  assign(t) {
    return this.x = t.x, this.y = t.y, this.z = t.z, this;
  }
  /**
   * Sets the values of this point.
   * @param x X value to set.
   * @param y Y value to set.
   * @param z Z value to set.
   * @returns This point object.
   */
  set(t, e, i) {
    return this.x = t, this.y = e, this.z = i, this;
  }
  /**
   * Sets an array from this point.
   * @param arr Array to assign.
   */
  toArray(t = [0, 0, 0]) {
    return t[0] = this.x, t[1] = this.y, t[2] = this.z, t;
  }
  /**
   * Sets this point from an array.
   * @param arr Array to assign from.
   * @returns This point object.
   */
  fromArray(t) {
    return this.x = t[0], this.y = t[1], this.z = t[2], this;
  }
  /**
   * Adds another point to this point.
   * @param point Point to add.
   * @returns This point object.
   */
  add(t) {
    return this.x += t.x, this.y += t.y, this.z += t.z, this;
  }
  /**
   * Subtracts another point from this point.
   * @param point Point to subtract.
   * @returns This point object.
   */
  subtract(t) {
    return this.x -= t.x, this.y -= t.y, this.z -= t.z, this;
  }
  /**
   * Creates a copy of this point.
   * @returns Copy of this point object.
   */
  copy() {
    return new d(this.x, this.y, this.z);
  }
  /**
   * Creates a new [[Point3]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t) {
    if (zu(t))
      return new d(t.x, t.y, t.z);
    throw new TypeError("Point3.fromJson: data does not satisfy type IPoint3 constraints");
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return {
      x: this.x,
      y: this.y,
      z: this.z
    };
  }
  /**
   * Strictly compares this point with another.
   * @param other Point to compare with.
   * @returns True if the values of this point equal those of the other.
   */
  equals(t) {
    return this.x === t.x && this.y === t.y && this.z === t.z;
  }
  /**
   * Compares this point with another using a tolerance.
   * @param other Point to compare with.
   * @param tolerance Tolerance to be used in the comparison.
   * @returns True if the values of this point equal those of the other.
   */
  equalsWithTolerance(t, e) {
    return Math.abs(this.x - t.x) < e && Math.abs(this.y - t.y) < e && Math.abs(this.z - t.z) < e;
  }
  /**
   * Returns a boolean value indicating if this vector lies on a major axis.
   */
  isAxis() {
    return Math.abs(this.x) === 1 && this.y === 0 && this.z === 0 || this.x === 0 && Math.abs(this.y) === 1 && this.z === 0 || this.x === 0 && this.y === 0 && Math.abs(this.z) === 1;
  }
  /**
   * Returns the length of this vector.
   * @returns Vector length.
   */
  length() {
    return Math.sqrt(this.squaredLength());
  }
  /**
   * Returns the squared length of this vector.
   * @returns Vector squared length.
   */
  squaredLength() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  /**
   * Scale the point by constant value.
   * @param k Constant value to scale by.
   * @returns Point object.
   */
  scale(t) {
    return this.x *= t, this.y *= t, this.z *= t, this;
  }
  /**
   * Normalizes the vector.
   * @returns This object.
   */
  normalize() {
    const t = this.length();
    return t === 0 ? this : this.scale(1 / t);
  }
  /**
   * Negates the point.
   * @returns This object.
   */
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  /**
   * Creates a new Point initialized to (0,0,0).
   * @returns New point with all elements set to 0.
   */
  static zero() {
    return new d(0, 0, 0);
  }
  /**
   * Adds two points.
   * @param p1 First point.
   * @param p2 Second point.
   * @returns Sum of p1 and p2.
   */
  static add(t, e) {
    return new d(t.x + e.x, t.y + e.y, t.z + e.z);
  }
  /**
   * Subtract two points.
   * @param p1 First point.
   * @param p2 Second point.
   * @returns Difference of p1 and p2.
   */
  static subtract(t, e) {
    return new d(t.x - e.x, t.y - e.y, t.z - e.z);
  }
  /**
   * Calculate dot product.
   * @param p1 First point.
   * @param p2 Second point.
   * @returns Dot product of p1 and p2.
   */
  static dot(t, e) {
    return t.x * e.x + t.y * e.y + t.z * e.z;
  }
  /**
   * Calculate cross product.
   * @param p1 First point.
   * @param p2 Second point.
   * @returns Cross product of p1 and p2.
   */
  static cross(t, e) {
    return new d(
      t.y * e.z - t.z * e.y,
      t.z * e.x - t.x * e.z,
      t.x * e.y - t.y * e.x
    );
  }
  /**
   * Calculate distance between two points
   * @param p1 First point
   * @param p2 Second point
   * @returns Distance between p1 and p2
   */
  static distance(t, e) {
    return d.subtract(e, t).length();
  }
  /**
   * Scale a point by a constant factor
   * @param p1 Point to scale
   * @param k Constant value to scale byS
   * @returns Copy of p scaled by a constant factor
   */
  static scale(t, e) {
    return t.copy().scale(e);
  }
  /**
   * Creates a point from an array of numbers
   * @param Array to assign from
   * @returns new point set from array elements
   */
  static createFromArray(t) {
    return new d(t[0], t[1], t[2]);
  }
}
class jn {
  constructor(t, e, i, s) {
    this.x = t, this.y = e, this.z = i, this.w = s;
  }
  scale(t) {
    return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this;
  }
  set(t, e, i, s) {
    this.x = t, this.y = e, this.z = i, this.w = s;
  }
  assign(t) {
    this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w;
  }
  static zero() {
    return new jn(0, 0, 0, 0);
  }
  /**
   * Strictly compares this point with another.
   * @param other Point to compare with.
   * @returns True if the values of this point equal those of the other.
   */
  equals(t) {
    return this.x === t.x && this.y === t.y && this.z === t.z;
  }
  /**
   * Compares this point with another using a tolerance.
   * @param other Point to compare with.
   * @param tolerance Tolerance to be used in the comparison.
   * @returns True if the values of this point equal those of the other.
   */
  equalsWithTolerance(t, e) {
    return Math.abs(this.x - t.x) < e && Math.abs(this.y - t.y) < e && Math.abs(this.z - t.z) < e;
  }
}
let Q = class Sn {
  /**
   * Creates a new matrix set to the identity matrix.
   */
  constructor() {
    this.loadIdentity();
  }
  /**
   * Sets the matrix to the identity matrix.
   * @returns This matrix object.
   */
  loadIdentity() {
    return this.m = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], this;
  }
  isIdentity() {
    const t = this.m;
    return t[0] === 1 && t[1] === 0 && t[2] === 0 && t[3] === 0 && t[4] === 0 && t[5] === 1 && t[6] === 0 && t[7] === 0 && t[8] === 0 && t[9] === 0 && t[10] === 1 && t[11] === 0 && t[12] === 0 && t[13] === 0 && t[14] === 0 && t[15] === 1;
  }
  /**
   * Strictly compares this matrix with another.
   * @param other Matrix to compare with.
   * @returns True if the values of this matrix equal those of the other.
   */
  equals(t) {
    for (let e = 0; e < 16; ++e) {
      const i = this.m[e], s = t.m[e];
      if (i !== s)
        return !1;
    }
    return !0;
  }
  /**
   * Compares this matrix with another using a tolerance.
   * @param other Matrix to compare with.
   * @param tolerance Tolerance to be used in the comparison.
   * @returns True if the values of this matrix equal those of the other.
   */
  equalsWithTolerance(t, e) {
    e = Math.abs(e);
    for (let i = 0; i < 16; ++i)
      if (Math.abs(this.m[i] - t.m[i]) > e)
        return !1;
    return !0;
  }
  /**
   * Sets the scale components of this matrix.
   * @param x X scale value.
   * @param y Y scale value.
   * @param z Z scale value.
   * @returns This matrix object.
   */
  setScaleComponent(t, e, i) {
    return this.m[0] = t, this.m[5] = e, this.m[10] = i, this;
  }
  /**
   * Sets the translation components of this matrix.
   * @param x X translation value.
   * @param y Y translation value.
   * @param z Z translation value.
   * @returns This matrix object.
   */
  setTranslationComponent(t, e, i) {
    return this.m[12] = t, this.m[13] = e, this.m[14] = i, this;
  }
  /**
   * Creates a copy of this matrix.
   * @returns Copy of this matrix.
   */
  copy() {
    const t = new Sn();
    return t.m = this.m.slice(), t;
  }
  /**
   * Sets the value of this matrix to another.
   * @param matrix the matrix whose values will be set.
   * @returns This matrix object.
   */
  assign(t) {
    for (let e = 0; e < t.m.length; e++)
      this.m[e] = t.m[e];
    return this;
  }
  /**
   * Multiply the matrix by given scalar.
   * @param scalar Scalar to multiply the matrix with.
   * @return This matrix object.
   */
  multiplyByScalar(t) {
    for (let e = 0; e < 16; e++)
      this.m[e] *= t;
    return this;
  }
  /**
   * Transforms a point according to this matrix. The source and destination points are allowed to be the same object.
   * @param point The point to be transformed.
   * @param result A Point3 which can hold the result of the transformation.
   * @returns A new point if result is undefined, result otherwise.
   */
  transform(t, e) {
    return e = e ?? d.zero(), e.set(
      t.x * this.m[0] + t.y * this.m[4] + t.z * this.m[8] + this.m[12],
      t.x * this.m[1] + t.y * this.m[5] + t.z * this.m[9] + this.m[13],
      t.x * this.m[2] + t.y * this.m[6] + t.z * this.m[10] + this.m[14]
    ), e;
  }
  /**
   * Transforms a point according to this matrix. The source and destination points are allowed to be the same object.
   * @param point The point to be transformed.
   * @param result A Point3 which can hold the result of the transformation.
   * @returns A new point if result is undefined, result otherwise.
   */
  transform4(t, e) {
    return e = e ?? jn.zero(), e.set(
      t.x * this.m[0] + t.y * this.m[4] + t.z * this.m[8] + this.m[12] * t.w,
      t.x * this.m[1] + t.y * this.m[5] + t.z * this.m[9] + this.m[13] * t.w,
      t.x * this.m[2] + t.y * this.m[6] + t.z * this.m[10] + this.m[14] * t.w,
      t.x * this.m[3] + t.y * this.m[7] + t.z * this.m[11] + this.m[15] * t.w
    ), e;
  }
  /**
   * Transforms an array of points according to this matrix.
   * @param inPoints an array of points to be transformed.
   * @param outPoints an array that will be populated with transformed points. Note that the results will be pushed onto the end of the array.
   */
  transformArray(t, e) {
    for (let i = 0; i < t.length; i++) {
      const s = t[i], r = new d(
        s.x * this.m[0] + s.y * this.m[4] + s.z * this.m[8] + this.m[12],
        s.x * this.m[1] + s.y * this.m[5] + s.z * this.m[9] + this.m[13],
        s.x * this.m[2] + s.y * this.m[6] + s.z * this.m[10] + this.m[14]
      );
      e[i] = r;
    }
  }
  transformBox(t) {
    if (t.isDegenerate())
      return ni.invalid();
    const e = t.getCorners();
    for (const s of e)
      this.transform(s, s);
    const i = new ni(e[0], e[0]);
    for (let s = 1; s < e.length; ++s) {
      const r = e[s];
      i.addPoint(r);
    }
    return i;
  }
  /**
   * Sets this matrix equal to its transpose.
   * @returns This matrix object.
   */
  // prettier-ignore
  transpose() {
    let t;
    return t = this.m[1], this.m[1] = this.m[4], this.m[4] = t, t = this.m[2], this.m[2] = this.m[8], this.m[8] = t, t = this.m[3], this.m[3] = this.m[12], this.m[12] = t, t = this.m[6], this.m[6] = this.m[9], this.m[9] = t, t = this.m[7], this.m[7] = this.m[13], this.m[13] = t, t = this.m[11], this.m[11] = this.m[14], this.m[14] = t, this;
  }
  /**
   * Creates a matrix from an array of numbers.
   * @param arr 16 element array of numbers.
   * @returns New matrix with elements set to the values of the array parameter. Array elements will be in column-major order.
   */
  static createFromArray(t) {
    const e = new Sn();
    return e.m = t.slice(), e;
  }
  /**
   * Creates a rotation matrix from an arbitrary axis.
   * @param axis Axis to rotate about.
   * @param degrees Amount of degrees to rotate about the provided axis.
   * @returns Rotation matrix which represents the rotation about the supplied axis.
   */
  static createFromOffAxisRotation(t, e) {
    const i = e * (Math.PI / 180), s = Math.sin(i), r = Math.cos(i), o = new Sn(), a = t.copy().normalize(), l = 1 - r, c = l * a.x * a.y, h = l * a.x * a.z, u = l * a.y * a.z;
    return o.m[0] = l * a.x * a.x + r, o.m[1] = s * a.z + c, o.m[2] = h - s * a.y, o.m[3] = 0, o.m[4] = c - s * a.z, o.m[5] = l * a.y * a.y + r, o.m[6] = s * a.x + u, o.m[7] = 0, o.m[8] = s * a.y + h, o.m[9] = u - s * a.x, o.m[10] = l * a.z * a.z + r, o.m[11] = 0, o.m[12] = 0, o.m[13] = 0, o.m[14] = 0, o.m[15] = 1, o;
  }
  /**
   * Creates a matrix from three [[Point3]]s, which will be used as the
   * columns of the matrix.
   *
   * @param xAxis The first column.
   * @param yAxis The second column.
   * @param zAxis The third column.
   */
  static createFromBasis(t, e, i) {
    const s = new Sn();
    return s.m[0] = t.x, s.m[1] = t.y, s.m[2] = t.z, s.m[4] = e.x, s.m[5] = e.y, s.m[6] = e.z, s.m[8] = i.x, s.m[9] = i.y, s.m[10] = i.z, s;
  }
  /**
   * Multiplies two matrices.
   *
   * (p' = ABp <=> p' = multiply(B, A).transform(p))
   *
   * @param m1 The first matrix.
   * @param m2 The second matrix.
   * @returns Matrix which is the result of the multiplication.
   */
  static multiply(t, e) {
    const i = new Sn();
    return i.m[0] = t.m[0] * e.m[0] + t.m[1] * e.m[4] + t.m[2] * e.m[8] + t.m[3] * e.m[12], i.m[1] = t.m[0] * e.m[1] + t.m[1] * e.m[5] + t.m[2] * e.m[9] + t.m[3] * e.m[13], i.m[2] = t.m[0] * e.m[2] + t.m[1] * e.m[6] + t.m[2] * e.m[10] + t.m[3] * e.m[14], i.m[3] = t.m[0] * e.m[3] + t.m[1] * e.m[7] + t.m[2] * e.m[11] + t.m[3] * e.m[15], i.m[4] = t.m[4] * e.m[0] + t.m[5] * e.m[4] + t.m[6] * e.m[8] + t.m[7] * e.m[12], i.m[5] = t.m[4] * e.m[1] + t.m[5] * e.m[5] + t.m[6] * e.m[9] + t.m[7] * e.m[13], i.m[6] = t.m[4] * e.m[2] + t.m[5] * e.m[6] + t.m[6] * e.m[10] + t.m[7] * e.m[14], i.m[7] = t.m[4] * e.m[3] + t.m[5] * e.m[7] + t.m[6] * e.m[11] + t.m[7] * e.m[15], i.m[8] = t.m[8] * e.m[0] + t.m[9] * e.m[4] + t.m[10] * e.m[8] + t.m[11] * e.m[12], i.m[9] = t.m[8] * e.m[1] + t.m[9] * e.m[5] + t.m[10] * e.m[9] + t.m[11] * e.m[13], i.m[10] = t.m[8] * e.m[2] + t.m[9] * e.m[6] + t.m[10] * e.m[10] + t.m[11] * e.m[14], i.m[11] = t.m[8] * e.m[3] + t.m[9] * e.m[7] + t.m[10] * e.m[11] + t.m[11] * e.m[15], i.m[12] = t.m[12] * e.m[0] + t.m[13] * e.m[4] + t.m[14] * e.m[8] + t.m[15] * e.m[12], i.m[13] = t.m[12] * e.m[1] + t.m[13] * e.m[5] + t.m[14] * e.m[9] + t.m[15] * e.m[13], i.m[14] = t.m[12] * e.m[2] + t.m[13] * e.m[6] + t.m[14] * e.m[10] + t.m[15] * e.m[14], i.m[15] = t.m[12] * e.m[3] + t.m[13] * e.m[7] + t.m[14] * e.m[11] + t.m[15] * e.m[15], i;
  }
  /**
   * Computes the determinant and inverse of a matrix, if possible.
   * @returns An array containing the inverse (or null if not invertible) followed by the determinant
   */
  inverseAndDeterminant() {
    const t = this.m[4] * this.m[9] - this.m[5] * this.m[8], e = this.m[4] * this.m[10] - this.m[6] * this.m[8], i = this.m[4] * this.m[11] - this.m[7] * this.m[8], s = this.m[4] * this.m[13] - this.m[5] * this.m[12], r = this.m[4] * this.m[14] - this.m[6] * this.m[12], o = this.m[4] * this.m[15] - this.m[7] * this.m[12], a = this.m[5] * this.m[10] - this.m[6] * this.m[9], l = this.m[5] * this.m[11] - this.m[7] * this.m[9], c = this.m[5] * this.m[14] - this.m[6] * this.m[13], h = this.m[5] * this.m[15] - this.m[7] * this.m[13], u = this.m[6] * this.m[11] - this.m[7] * this.m[10], p = this.m[6] * this.m[15] - this.m[7] * this.m[14], m = this.m[8] * this.m[13] - this.m[9] * this.m[12], g = this.m[8] * this.m[14] - this.m[10] * this.m[12], _ = this.m[8] * this.m[15] - this.m[11] * this.m[12], y = this.m[9] * this.m[14] - this.m[10] * this.m[13], b = this.m[9] * this.m[15] - this.m[11] * this.m[13], w = this.m[10] * this.m[15] - this.m[11] * this.m[14], v = new Sn();
    v.m[0] = this.m[5] * w - this.m[6] * b + this.m[7] * y, v.m[1] = this.m[2] * b - this.m[3] * y - this.m[1] * w, v.m[2] = this.m[1] * p - this.m[2] * h + this.m[3] * c, v.m[3] = this.m[2] * l - this.m[3] * a - this.m[1] * u, v.m[4] = this.m[6] * _ - this.m[7] * g - this.m[4] * w, v.m[5] = this.m[0] * w - this.m[2] * _ + this.m[3] * g, v.m[6] = this.m[2] * o - this.m[3] * r - this.m[0] * p, v.m[7] = this.m[0] * u - this.m[2] * i + this.m[3] * e, v.m[8] = this.m[4] * b - this.m[5] * _ + this.m[7] * m, v.m[9] = this.m[1] * _ - this.m[3] * m - this.m[0] * b, v.m[10] = this.m[0] * h - this.m[1] * o + this.m[3] * s, v.m[11] = this.m[1] * i - this.m[3] * t - this.m[0] * l, v.m[12] = this.m[5] * g - this.m[6] * m - this.m[4] * y, v.m[13] = this.m[0] * y - this.m[1] * g + this.m[2] * m, v.m[14] = this.m[1] * r - this.m[2] * s - this.m[0] * c, v.m[15] = this.m[0] * a - this.m[1] * e + this.m[2] * t;
    const C = v.m[0], k = -v.m[4], Y = v.m[8], P = -v.m[12], L = this.m[0] * C - this.m[1] * k + this.m[2] * Y - this.m[3] * P;
    if (L === 0)
      return [null, 0];
    const R = 1 / L;
    return v.multiplyByScalar(R), [v, L];
  }
  /**
   * Computes the inverse of a matrix if possible.
   * @param matrix Matrix whose inverse will be computed.
   * @returns Matrix set to the inverse of the supplied matrix.
   */
  static inverse(t) {
    return t.inverseAndDeterminant()[0];
  }
  /**
   * Computes the determinant of the upper-left 3x3 subsection of this matrix.
   */
  upperLeft3x3Determinant() {
    return this.m[0] * (this.m[5] * this.m[10] - this.m[9] * this.m[6]) - this.m[4] * (this.m[1] * this.m[10] - this.m[9] * this.m[2]) + this.m[8] * (this.m[1] * this.m[6] - this.m[5] * this.m[2]);
  }
  /**
   * @returns the version of this matrix suitable for applying to normals,
   * i.e. the inverse transpose of the upper-left 3x3 submatrix.
   */
  normalMatrix() {
    const t = this.copy().setTranslationComponent(0, 0, 0).inverseAndDeterminant()[0];
    return t ? t.transpose() : null;
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this.m.slice();
  }
  /**
   * Creates a new [[Matrix]] from an object given by [[toJson]].
   * @param An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t) {
    return Sn.createFromArray(t);
  }
  /** @hidden */
  static toMatrix12(t) {
    return [t[0], t[1], t[2], t[4], t[5], t[6], t[8], t[9], t[10], t[12], t[13], t[14]];
  }
  /**
   * Returns the matrix for a clockwise rotation around the X-axis.
   * @param degrees The degrees of the rotation.
   * @returns The rotation matrix.
   */
  static xAxisRotation(t) {
    const e = new Sn(), i = cs(t), s = Math.cos(i), r = Math.sin(i);
    return e.m[5] = s, e.m[6] = -r, e.m[9] = r, e.m[10] = s, e;
  }
  /**
   * Returns the matrix for a clockwise rotation around the Y-axis.
   * @param degrees The degrees of the rotation.
   * @returns The rotation matrix.
   */
  static yAxisRotation(t) {
    const e = new Sn(), i = cs(t), s = Math.cos(i), r = Math.sin(i);
    return e.m[0] = s, e.m[2] = r, e.m[8] = -r, e.m[10] = s, e;
  }
  /**
   * Returns the matrix for a clockwise rotation around the Z-axis.
   * @param degrees The degrees of the rotation.
   * @returns The rotation matrix.
   */
  static zAxisRotation(t) {
    const e = new Sn(), i = cs(t), s = Math.cos(i), r = Math.sin(i);
    return e.m[0] = s, e.m[1] = -r, e.m[4] = r, e.m[5] = s, e;
  }
}, je = class ao {
  constructor() {
    this.normal = d.zero(), this.d = 0;
  }
  setFromPointAndNormal(t, e) {
    return this.normal.assign(e), this.d = -d.dot(e, t), this;
  }
  /**
   * Update the plane to pass through the three points
   */
  setFromPoints(t, e, i) {
    this.normal = d.cross(d.subtract(e, t), d.subtract(i, t)).normalize(), this.d = -d.dot(t, this.normal);
  }
  setFromCoefficients(t, e, i, s) {
    this.normal.set(t, e, i), this.d = s;
  }
  getCoefficients() {
    const t = this.normal;
    return [t.x, t.y, t.z, this.d];
  }
  distanceToPoint(t) {
    return d.dot(this.normal, t) + this.d;
  }
  rayIntersection(t) {
    const e = d.zero();
    return this.intersectsRay(t, e) ? e : null;
  }
  intersectsRay(t, e) {
    const i = this.distanceToPoint(t.origin);
    if (Math.abs(i) <= 1e-6)
      return e && e.assign(t.origin), !0;
    const s = d.dot(this.normal, t.direction);
    if (Math.abs(s) <= 1e-6)
      return !1;
    const r = -i / s;
    if (r < 0)
      return !1;
    if (e) {
      const o = t.direction.copy().scale(r);
      e.set(t.origin.x + o.x, t.origin.y + o.y, t.origin.z + o.z);
    }
    return !0;
  }
  /**
   * Returns true if the point is on the side of the plane that the plane's normal is directed. Returns false otherwise.
   * @param p The point to test.
   */
  determineSide(t) {
    return this.normal.x * t.x + this.normal.y * t.y + this.normal.z * t.z + this.d > 0;
  }
  /**
   * Creates a copy of this plane
   * @returns a copy of this plane object
   */
  copy() {
    const t = new ao();
    return t.normal.assign(this.normal), t.d = this.d, t;
  }
  /**
   * Sets this plane equal to another plane
   * @param plane the plane to assign
   */
  assign(t) {
    this.normal.assign(t.normal), this.d = t.d;
  }
  /**
   * Returns true if the normal and d value are the same.
   * @param plane
   */
  equals(t) {
    return this.normal.equals(t.normal) && this.d === t.d;
  }
  static createFromPointAndNormal(t, e) {
    return new ao().setFromPointAndNormal(t, e);
  }
  static createFromPoints(t, e, i) {
    const s = new ao();
    return s.setFromPoints(t, e, i), s;
  }
  static createFromCoefficients(t, e, i, s) {
    const r = new ao();
    return r.setFromCoefficients(t, e, i, s), r;
  }
};
class E {
  /**
   * Creates a new point
   * @param {number} x value to set for x
   * @param {number} y value to set for y
   */
  constructor(t, e) {
    this.x = t, this.y = e;
  }
  /**
   * Sets this point equal to another point
   * @param {Point2} pt the point whose values will be used to set this object
   * @returns {Point2} the point object
   */
  assign(t) {
    return this.x = t.x, this.y = t.y, this;
  }
  /**
   * Adds a point to this one
   * @param {Point2} pt the point whose values will be added
   * @returns {Point2} the point object
   */
  add(t) {
    return this.x += t.x, this.y += t.y, this;
  }
  /**
   * Subtracts a point from this one
   * @param {Point2} pt the point whose values will be subtracted
   * @returns {Point2} the point object
   */
  subtract(t) {
    return this.x -= t.x, this.y -= t.y, this;
  }
  /**
   * Scales the point by a constant value
   * @param {number} k the value to scale by
   * @returns {Point2} the point object
   */
  scale(t) {
    return this.x *= t, this.y *= t, this;
  }
  /**
   * Compares this point with another point
   * @param {Point2} pt the point to compare with
   * @returns {Boolean} True if the values of this point equal the other. False otherwise.
   */
  equals(t) {
    return this.x === t.x && this.y === t.y;
  }
  /**
   * Sets the values of this point
   * @param {number} x value to set for x
   * @param {number} y value to set for y
   * @returns {Point2} the point object
   */
  set(t, e) {
    return this.x = t, this.y = e, this;
  }
  /**
   * Creates a copy of this point
   * @returns {Point} Copy of this point
   */
  copy() {
    return new E(this.x, this.y);
  }
  /**
   * Returns the length of this point
   * @returns {number} the point length
   */
  length() {
    return Math.sqrt(this.squaredLength());
  }
  /**
   * Returns the squared length of this vector.
   * @returns Vector squared length.
   */
  squaredLength() {
    return this.x * this.x + this.y * this.y;
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return {
      x: this.x,
      y: this.y
    };
  }
  /**
   * Creates a new [[Point2]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t) {
    if (Du(t))
      return new E(t.x, t.y);
    throw new TypeError("Point2.fromJson: data does not satisfy type IPoint2 constraints");
  }
  /**
   * Subtracts a point from another
   * @param {Point2} pt1 initial point
   * @param {Point2} pt2 the point to subtract
   * @returns {Point2} new point set to pt1 - pt2
   */
  static subtract(t, e) {
    return new E(t.x - e.x, t.y - e.y);
  }
  /**
   * Adds two points
   * @param {Point2} pt1 initial point
   * @param {Point2} pt2 the point to add
   * @returns {Point2} new point set to pt1 + pt2
   */
  static add(t, e) {
    return new E(t.x + e.x, t.y + e.y);
  }
  /**
   * Scale a point by a constant factor
   * @param {Point2} pt Point to be scaled
   * @param {number} k Amount to scale by
   * @returns {Point2} The scaled point
   */
  static scale(t, e) {
    return new E(t.x * e, t.y * e);
  }
  /**
   * Calculate distance between two points
   * @param {Point2} p1 first point
   * @param {Point2} p2 second point
   * @returns {number} the distance between p1 and p2
   */
  static distance(t, e) {
    return E.subtract(e, t).length();
  }
  /**
   * Creates a point initialized to (0,0)
   * @returns {Point} The new point
   */
  static zero() {
    return new E(0, 0);
  }
  static fromPoint3(t) {
    return new E(t.x, t.y);
  }
}
function $p(n) {
  const t = Math.abs(n.x), e = Math.abs(n.y), i = Math.abs(n.z);
  return t <= e && t <= i ? new d(1, 0, 0) : e <= t && e <= i ? new d(0, 1, 0) : new d(0, 0, 1);
}
function Bu(n, t) {
  const e = $p(n), i = d.cross(e, n);
  return t ? (t.assign(i), t) : i;
}
function Ju(n, t, e, i) {
  const s = e.normal.x * (t.x - n.x) + e.normal.y * (t.y - n.y) + e.normal.z * (t.z - n.z);
  if (Math.abs(s) < 1e-5)
    return !1;
  const r = -(e.d + e.normal.x * n.x + e.normal.y * n.y + e.normal.z * n.z) / s;
  return i.x = n.x + r * (t.x - n.x), i.y = n.y + r * (t.y - n.y), i.z = n.z + r * (t.z - n.z), !(r < 0 || r > 1);
}
function ss(n, t, e, i) {
  const s = d.subtract(e, t), r = s.squaredLength();
  let o = 0;
  r > 0 && (o = ((n.x - t.x) * (e.x - t.x) + (n.y - t.y) * (e.y - t.y) + (n.z - t.z) * (e.z - t.z)) / r), s.set(s.x * o, s.y * o, s.z * o), i.set(t.x + s.x, t.y + s.y, t.z + s.z);
  let a = new d(0, 0, 0);
  return a = d.subtract(n, i), a.length();
}
function tg(n) {
  return Math.abs(n - 25.4 / 72) < 0.01 ? "points" : Math.abs(n - 25.4) < 0.01 ? "inch" : Math.abs(n - 1) < 0.01 ? "mm" : Math.abs(n - 10) < 0.01 ? "cm" : Math.abs(n - 25.4 / 6) < 0.01 ? "picas" : Math.abs(n - 12 * 25.4) < 0.01 ? "ft" : Math.abs(n - 3 * 12 * 25.4) < 0.01 ? "yd" : Math.abs(n - 1e3) < 0.01 ? "m" : Math.abs(n - 1e6) < 0.01 ? "km" : Math.abs(n - 1760 * 3 * 12 * 25.4) < 0.01 ? "mi" : (console.log(`warning: unit multiplier doesn't map to known type: unit=${n}`), "");
}
function Eo(n, t) {
  const e = tg(t);
  let i = "";
  for (let s = 2; s < 9 && (i = n.toFixed(s), parseFloat(i) === 0); s++)
    ;
  return parseFloat(i) === 0 && (i = "0"), i + e;
}
function cs(n) {
  return n * (Math.PI / 180);
}
function Vl(n) {
  return n * (180 / Math.PI);
}
function lo(n, t, e) {
  const i = n.copy().normalize(), s = cs(t), r = Math.cos(s), o = Math.sin(s), a = 1 - r, l = a * i.x * i.y, c = a * i.x * i.z, h = a * i.y * i.z;
  return e === void 0 && (e = new Q()), e.m[0] = a * i.x * i.x + r, e.m[1] = o * i.z + l, e.m[2] = c - o * i.y, e.m[3] = 0, e.m[4] = l - o * i.z, e.m[5] = a * i.y * i.y + r, e.m[6] = o * i.x + h, e.m[7] = 0, e.m[8] = o * i.y + c, e.m[9] = h - o * i.x, e.m[10] = a * i.z * i.z + r, e.m[11] = 0, e.m[12] = 0, e.m[13] = 0, e.m[14] = 0, e.m[15] = 1, e;
}
function eg(n, t, e, i, s, r) {
  const o = d.cross(n.normal, e.normal), a = Math.abs(o.x), l = Math.abs(o.y), c = Math.abs(o.z);
  if (a + l + c < 1e-7) {
    const g = d.subtract(i, t);
    return d.dot(n.normal, g) === 0 ? 1 : 0;
  }
  let h;
  a > l ? a > c ? h = 1 : h = 3 : l > c ? h = 2 : h = 3;
  const u = d.zero(), p = -d.dot(n.normal, t), m = -d.dot(e.normal, i);
  switch (h) {
    case 1:
      u.x = 0, u.y = (m * n.normal.z - p * e.normal.z) / o.x, u.z = (p * e.normal.y - m * n.normal.y) / o.x;
      break;
    case 2:
      u.x = (p * e.normal.z - m * n.normal.z) / o.y, u.y = 0, u.z = (m * n.normal.x - p * e.normal.x) / o.y;
      break;
    case 3:
      u.x = (m * n.normal.y - p * e.normal.y) / o.z, u.y = (p * e.normal.x - m * n.normal.x) / o.z, u.z = 0;
  }
  return s.assign(u), r.set(u.x + o.x, u.y + o.y, u.z + o.z), 2;
}
function ig(n, t, e) {
  const i = new je();
  return i.normal.x = (t.y - n.y) * (e.z - n.z) - (t.z - n.z) * (e.y - n.y), i.normal.y = (t.z - n.z) * (e.x - n.x) - (t.x - n.x) * (e.z - n.z), i.normal.z = (t.x - n.x) * (e.y - n.y) - (t.y - n.y) * (e.x - n.x), i.normal.normalize(), i.d = -i.normal.x * n.x - i.normal.y * n.y - i.normal.z * n.z, i;
}
function Ts(n, t, e, i, s, r) {
  const o = ig(e, i, s);
  return Ju(n, t, o, r);
}
function Yn(n, t) {
  const e = n.copy().normalize(), i = t.copy().normalize(), r = d.cross(e, i).length(), o = d.dot(e, i), a = Math.atan2(r, o);
  return Vl(a);
}
function ng(n, t, e, i, s) {
  const r = 2 * Math.PI / i;
  for (let h = 0; h < i; h++) {
    const p = e * Math.cos(r * h), m = e * Math.sin(r * h);
    n[h] = new d(0, p, m);
  }
  n[i] = n[0].copy();
  const o = Bu(s);
  o.normalize();
  const a = d.cross(o, s);
  a.normalize();
  const l = new Q(), c = l.m;
  c[0] = s.x, c[1] = s.y, c[2] = s.z, c[3] = 0, c[4] = o.x, c[5] = o.y, c[6] = o.z, c[7] = 0, c[8] = a.x, c[9] = a.y, c[10] = a.z, c[11] = 0, c[12] = 0, c[13] = 0, c[14] = 0, c[15] = 1, l.transformArray(n, n);
  for (let h = 0; h <= i; h++)
    n[h].set(
      n[h].x + t.x,
      n[h].y + t.y,
      n[h].z + t.z
    );
}
function sg(n, t, e, i, s, r) {
  const o = n, a = t, l = e, c = i;
  let h = 0, u = 0;
  const p = d.subtract(a, o), m = d.subtract(c, l), g = d.dot(p, o), _ = d.dot(p, m), y = d.dot(p, p), b = d.dot(p, l), w = d.dot(m, m), v = d.dot(m, l), C = d.dot(m, o), k = d.dot(p, c), Y = d.dot(m, a), P = y * w - _ * _;
  if (P === 0) {
    let D, J, G, X;
    y !== 0 ? (D = (b - g) / y, D < 0 ? D = 0 : D > 1 && (D = 1), G = (k - g) / y, G < 0 ? G = 0 : G > 1 && (G = 1)) : (D = 0, G = 0), w !== 0 ? (J = (C - v) / w, J < 0 ? J = 0 : J > 1 && (J = 1), X = (Y - v) / w, X < 0 ? X = 0 : X > 1 && (X = 1)) : (J = 0, X = 0), h = (D + G) / 2, u = (J + X) / 2;
  } else {
    const D = _ * C - _ * v - w * g + w * b, J = y * C - y * v + _ * b - _ * g, G = D / P, X = J / P, Z = (b - g) / y, W = (C - v) / w, st = (k - g) / y, j = (Y - v) / w;
    0 <= G && G <= 1 && 0 <= X && X <= 1 ? (h = G, u = X) : G < 0 && 0 <= X && X <= 1 ? (h = G, u = W) : 1 < G && 0 <= X && X <= 1 ? (h = G, u = j) : 0 <= G && G <= 1 && X < 0 ? (h = Z, u = X) : 0 <= G && G <= 1 && 1 < X ? (h = st, u = X) : G < 0 && X < 0 ? (h = Z, u = W) : G < 0 && 1 < X ? (h = st, u = W) : 1 < G && X < 0 ? (h = Z, u = j) : 1 < G && 1 < X && (h = st, u = j), h < 0 ? h = 0 : h > 1 && (h = 1), u < 0 ? u = 0 : u > 1 && (u = 1);
  }
  return s.x = h * p.x + o.x, s.y = h * p.y + o.y, s.z = h * p.z + o.z, r.x = u * m.x + l.x, r.y = u * m.y + l.y, r.z = u * m.z + l.z, d.subtract(r, s).length();
}
function ju(n, t, e, i) {
  const r = d.zero(), o = d.zero(), a = d.zero(), l = d.zero(), c = d.zero();
  if (a.x = n.x - e.x, a.y = n.y - e.y, a.z = n.z - e.z, l.x = i.x - e.x, l.y = i.y - e.y, l.z = i.z - e.z, Math.abs(l.x) < 1e-12 && Math.abs(l.y) < 1e-12 && Math.abs(l.z) < 1e-12 || (c.x = t.x - n.x, c.y = t.y - n.y, c.z = t.z - n.z, Math.abs(c.x) < 1e-12 && Math.abs(c.y) < 1e-12 && Math.abs(c.z) < 1e-12))
    return null;
  const h = a.x * l.x + a.y * l.y + a.z * l.z, u = l.x * c.x + l.y * c.y + l.z * c.z, p = a.x * c.x + a.y * c.y + a.z * c.z, m = l.x * l.x + l.y * l.y + l.z * l.z, _ = (c.x * c.x + c.y * c.y + c.z * c.z) * m - u * u;
  if (Math.abs(_) < 1e-12)
    return null;
  const b = (h * u - p * m) / _, w = (h + u * b) / m;
  return r.x = n.x + b * c.x, r.y = n.y + b * c.y, r.z = n.z + b * c.z, o.x = e.x + w * l.x, o.y = e.y + w * l.y, o.z = e.z + w * l.z, r;
}
function Hu(n, t, e) {
  const i = d.subtract(t, n), s = d.subtract(e, n), o = d.dot(s, i) / i.squaredLength();
  return Math.max(0, Math.min(1, o));
}
function rg(n, t, e) {
  const i = Hu(n, t, e), s = d.subtract(t, n).scale(i);
  return d.add(n, s);
}
function og(n, t, e, i) {
  const s = Hu(n, t, e);
  if (s < 0 || s > 1)
    return !1;
  const r = d.subtract(t, n).scale(s), o = d.add(n, r);
  return d.subtract(o, e).squaredLength() <= i * i;
}
function ag(n, t, e) {
  const i = E.subtract(e, t), s = i.length();
  let r = (n.x - t.x) * (e.x - t.x) + (n.y - t.y) * (e.y - t.y);
  return r /= s * s, i.scale(r), E.add(t, i);
}
function co(n, t, e, i) {
  const s = ag(n, t, e);
  if (E.distance(n, s) <= i) {
    const o = Math.min(t.x, e.x), a = Math.max(t.x, e.x), l = Math.min(t.y, e.y), c = Math.max(t.y, e.y);
    return !(s.x < o || s.x > a || s.y < l || s.y > c);
  } else
    return !1;
}
function Uu(n, t, e, i = 0) {
  return !(n.x + i < t.x || n.x > t.x + e.x + i || n.y + i < t.y || n.y > t.y + e.y + i);
}
function yc(n, t, e, i, s) {
  const r = [], o = d.zero(), a = new Q(), l = t / s;
  for (let c = 0, h = 0; c <= s; ++c, h += l)
    lo(n, h, a), a.transform(i, o), r.push(d.add(e, o));
  return r;
}
function lg(n) {
  const t = n.sort((s, r) => s.exponent < r.exponent ? 1 : -1);
  let e = "";
  const i = ".";
  for (let s = 0; s < t.length; s++) {
    switch (t[s].basicUnit) {
      case le.unitLength:
        e += fe(t[s].factor, "m");
        break;
      case le.unitMass:
        e += cg(t[s].factor, "g");
        break;
      case le.unitTime:
        e += fe(t[s].factor, "s");
        break;
      case le.unitElectricCurrent:
        e += fe(t[s].factor, "A");
        break;
      case le.unitThermoTemperature:
        e += fe(t[s].factor, "K");
        break;
      case le.unitSubstanceAmount:
        e += fe(t[s].factor, "mol");
        break;
      case le.unitLuminosityIntensity:
        e += fe(t[s].factor, "cd");
        break;
      case le.unitPlaneAngle:
        e += fe(t[s].factor, "rad");
        break;
      case le.unitSolidAngle:
        e += fe(t[s].factor, "sr");
        break;
      case le.unitFrequency:
        e += fe(t[s].factor, "Hz");
        break;
      case le.unitForce:
        e += fe(t[s].factor, "N");
        break;
      case le.unitPressure:
        e += fe(t[s].factor, "Pa");
        break;
      case le.unitEnergy:
        e += fe(t[s].factor, "J");
        break;
      case le.unitPower:
        e += fe(t[s].factor, "W");
        break;
      case le.unitElectricCharge:
        e += fe(t[s].factor, "C");
        break;
      case le.unitElectromotiveForce:
        e += fe(t[s].factor, "V");
        break;
      case le.unitCapacitance:
        e += fe(t[s].factor, "F");
        break;
      case le.unitElectricResistance:
        e += fe(t[s].factor, qp);
        break;
      case le.unitElectricConductance:
        e += fe(t[s].factor, "S");
        break;
      case le.unitMagneticFlux:
        e += fe(t[s].factor, "Wb");
        break;
      case le.unitMagneticFluxDensity:
        e += fe(t[s].factor, "T");
        break;
      case le.unitInductance:
        e += fe(t[s].factor, "H");
        break;
      case le.unitLuminousFlux:
        e += fe(t[s].factor, "lm");
        break;
      case le.unitIlluminance:
        e += fe(t[s].factor, "lx");
        break;
      case le.unitActivityRadionuclide:
        e += fe(t[s].factor, "Bq");
        break;
      case le.unitKerma:
        e += fe(t[s].factor, "Gy");
        break;
      case le.unitDoseEquivalent:
        e += fe(t[s].factor, "Sv");
        break;
      case le.unitCatalyticActivity:
        e += fe(t[s].factor, "kat");
        break;
    }
    switch (t[s].exponent) {
      case 2:
        e += tu;
        break;
      case 3:
        e += eu;
        break;
      case -1:
        e += ic, e += Qp;
        break;
      case -2:
        e += ic, e += tu;
        break;
      case -3:
        e += ic, e += eu;
        break;
    }
    s + 1 < t.length && (e += i);
  }
  return e;
}
function fe(n, t) {
  let e = "";
  switch (n) {
    case 0.3048:
      e = "ft";
      break;
    case 0.0254:
      e = "inch";
      break;
    case 1e-3:
      e = `m${t}`;
      break;
    case 0.01:
      e = `c${t}`;
      break;
    case 0.1:
      e = `d${t}`;
      break;
    case 1:
      e = t;
      break;
    case 10:
      e = `da${t}`;
      break;
    case 100:
      e = `h${t}`;
      break;
    case 1e3:
      e = `k${t}`;
      break;
    case 60:
      e = "min";
      break;
    case 3600:
      e = "h";
      break;
    case 86400:
      e = "d";
      break;
    case 274.15:
      e = "°C";
      break;
    case 255.927778:
      e = "°F";
      break;
    case 0.555556:
      e = "°R";
      break;
  }
  return e;
}
function cg(n, t) {
  let e = "";
  switch (n) {
    case 1e-6:
      e = `m${t}`;
      break;
    case 1e-5:
      e = `d${t}`;
      break;
    case 1e-4:
      e = `c${t}`;
      break;
    case 1e-3:
      e = t;
      break;
    case 0.01:
      e = `da${t}`;
      break;
    case 0.1:
      e = `h${t}`;
      break;
    case 1:
      e = `k${t}`;
      break;
    case 100:
      e = "q";
      break;
    case 1e3:
      e = "t";
      break;
  }
  return e;
}
const Nn = class {
  constructor(n, t, e, i) {
    this.x = n, this.y = t, this.z = e, this.w = i;
  }
  set(n, t, e, i) {
    this.x = n, this.y = t, this.z = e, this.w = i;
  }
  assign(n) {
    this.x = n.x, this.y = n.y, this.z = n.z, this.w = n.w;
  }
  copy() {
    return new Nn(this.x, this.y, this.z, this.w);
  }
  equals(n) {
    return this.x === n.x && this.y === n.y && this.z === n.z && this.w === n.w;
  }
  equalsWithTolerance(n, t) {
    return this.x - n.x < t && this.x - n.x > -t && this.y - n.y < t && this.y - n.y > -t && this.z - n.z < t && this.z - n.z > -t && this.w - n.w < t && this.w - n.w > -t;
  }
  fromArray(n) {
    return this.x = n[0], this.y = n[1], this.z = n[2], this.w = n[3], this;
  }
  toArray(n) {
    return n[0] = this.x, n[1] = this.y, n[2] = this.z, n[3] = this.w, this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  magnitudeSquared() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  magnitude() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  normalize() {
    const n = this.magnitude();
    return n === 0 ? this : (this.x = this.x / n, this.y = this.y / n, this.z = this.z / n, this.w = this.w / n, this);
  }
  static add(n, t) {
    return new Nn(n.x + t.x, n.y + t.y, n.z + t.z, n.w + t.w);
  }
  static subtract(n, t) {
    return new Nn(n.x - t.x, n.y - t.y, n.z - t.z, n.w - t.w);
  }
  static identity() {
    return new Nn(0, 0, 0, 1);
  }
  static toMatrix(n) {
    let t = n.x * n.x + n.y * n.y + n.z * n.z + n.w * n.w;
    t = 2 / t;
    const e = n.x * t, i = n.y * t, s = n.z * t, r = n.w * e, o = n.w * i, a = n.w * s, l = n.x * e, c = n.x * i, h = n.x * s, u = n.y * i, p = n.y * s, m = n.z * s, g = new Q();
    return g.m[0] = 1 - (u + m), g.m[1] = c + a, g.m[2] = h - o, g.m[3] = 0, g.m[4] = c - a, g.m[5] = 1 - (l + m), g.m[6] = p + r, g.m[7] = 0, g.m[8] = h + o, g.m[9] = p - r, g.m[10] = 1 - (l + u), g.m[11] = 0, g.m[12] = 0, g.m[13] = 0, g.m[14] = 0, g.m[15] = 1, g;
  }
  static createFromMatrix(n) {
    const r = [], o = n.m[0] + n.m[5] + n.m[10];
    if (o > 0) {
      let a = Math.sqrt(o + 1);
      r[3] = 0.5 * a, a = 0.5 / a, r[0] = a * (n.m[6] - n.m[9]), r[1] = a * (n.m[8] - n.m[2]), r[2] = a * (n.m[1] - n.m[4]);
    } else {
      let a = 0;
      n.m[4 * 1 + 1] > n.m[4 * 0 + 0] && (a = 1), n.m[4 * 2 + 2] > n.m[4 * a + a] && (a = 2);
      const l = [1, 2, 0], c = l[a], h = l[c];
      let u = Math.sqrt(n.m[4 * a + a] - (n.m[4 * c + c] + n.m[4 * h + h]) + 1);
      r[a] = 0.5 * u, u = 0.5 / u, r[3] = u * (n.m[4 * c + h] - n.m[4 * h + c]), r[c] = u * (n.m[4 * a + c] + n.m[4 * c + a]), r[h] = u * (n.m[4 * a + h] + n.m[4 * h + a]);
    }
    return Nn.identity().fromArray(r);
  }
  static interpolate(n, t, e) {
    const a = [], l = [], c = [];
    n.toArray(a), t.toArray(l);
    let h, u;
    const p = a[0] * l[0] + a[1] * l[1] + a[2] * l[2] + a[3] * l[3];
    if (1 + p > Nn._epsilon) {
      if (1 - p > Nn._epsilon) {
        const m = Nn._arccos(p), _ = 1 / Math.sin(m);
        h = _ * Math.sin((1 - e) * m), u = _ * Math.sin(e * m);
      } else
        h = 1 - e, u = e;
      for (let m = 0; m < 4; ++m)
        c[m] = h * a[m] + u * l[m];
    } else {
      c[0] = -a[1], c[1] = a[0], c[2] = -a[3], c[3] = a[2], h = Math.sin(0.5 * Math.PI * (1 - e)), u = Math.sin(0.5 * Math.PI * e);
      for (let m = 0; m < 3; ++m)
        c[m] = h * a[m] + u * c[m];
    }
    return Nn.identity().fromArray(c);
  }
  static _arccos(n) {
    return n < -1 ? Math.PI : n > 1 ? 0 : Math.acos(n);
  }
};
let Ti = Nn;
Ti._epsilon = 1e-5;
class Vn {
  constructor(t, e) {
    this.origin = d.zero(), this.direction = new d(0, 0, 1), t && this.origin.assign(t), e && this.direction.assign(e);
  }
  /**
   * Creates a copy of this ray
   * @returns {Ray} a copy of this ray object
   */
  copy() {
    return new Vn(this.origin, this.direction);
  }
  /**
   * Sets this ray equal to another ray
   * @param {Ray} ray the ray to assign
   */
  assign(t) {
    return this.origin.assign(t.origin), this.direction.assign(t.direction), this;
  }
  /**
   * Flips the ray's direction.
   */
  negate() {
    return this.direction.negate(), this;
  }
}
class ni {
  /**
   * Creates a new box.
   * @param min The minimum extent of the box. Defaults to the origin.
   * @param max The maximum extent of the box. Defaults to the origin.
   */
  constructor(t = d.zero(), e = d.zero()) {
    this.min = t.copy(), this.max = e.copy();
  }
  /**
   * Creates a copy of the box.
   * @returns A copy of this box.
   */
  copy() {
    return new ni(this.min, this.max);
  }
  /**
   * Strictly compares this box with another box.
   * @param box Box to compare with.
   * @returns True if the values of this box equals the other. False otherwise.
   */
  equals(t) {
    return this.min.equals(t.min) && this.max.equals(t.max);
  }
  /**
   * Gets the center point for the box.
   * @returns The center point of this box.
   */
  center() {
    const t = d.add(this.min, this.max);
    return t.scale(0.5), t;
  }
  /**
   * Gets the extents of the box.
   * @returns A point with members set to extent values for each corresponding axis.
   */
  extents() {
    return d.subtract(this.max, this.min);
  }
  /**
   * Expands the extents of the box so that it will contain another box.
   * @param box The box to add.
   */
  addBox(t) {
    t.isDegenerate() || (this.addPoint(t.min), this.addPoint(t.max));
  }
  /**
   * Expands the extents of the box so that it will contain a particular point.
   * @param point The point to add.
   */
  addPoint(t) {
    t.x < this.min.x && (this.min.x = t.x), t.y < this.min.y && (this.min.y = t.y), t.z < this.min.z && (this.min.z = t.z), t.x > this.max.x && (this.max.x = t.x), t.y > this.max.y && (this.max.y = t.y), t.z > this.max.z && (this.max.z = t.z);
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      min: this.min.toJson(),
      max: this.max.toJson()
    };
  }
  /**
   * Creates a new [[Box]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t) {
    const e = t, i = d.fromJson(e.min), s = d.fromJson(e.max);
    return new ni(i, s);
  }
  /**
   * Gets all eight corner points for the box.
   * @returns The corner points of this box.
   */
  getCorners() {
    const t = [];
    return t[0] = this.min.copy(), t[1] = this.min.copy(), t[2] = this.min.copy(), t[1].x = this.max.x, t[2].y = this.max.y, t[3] = t[2].copy(), t[3].x = this.max.x, t[4] = t[0].copy(), t[5] = t[1].copy(), t[6] = t[2].copy(), t[7] = t[3].copy(), t[4].z = this.max.z, t[5].z = this.max.z, t[6].z = this.max.z, t[7].z = this.max.z, t;
  }
  /**
   * Creates and returns an invalid bounding box.
   * @returns an invalid bounding box.
   */
  static invalid() {
    return new ni(
      new d(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY),
      new d(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY)
    );
  }
  /**
   * Returns whether or not the box is degenerate.
   * @returns whether or not the box is degenerate.
   */
  isDegenerate() {
    return this.min.x > this.max.x || this.min.y > this.max.y || this.min.z > this.max.z;
  }
}
function hg(n) {
  return n !== null && typeof n == "object" && "r" in n && typeof n.r == "number" && "g" in n && typeof n.g == "number" && "b" in n && typeof n.b == "number";
}
class it {
  /**
   * Creates a new color object. Values are specified in the 0-255 range.
   * @param r red color component
   * @param g green color component
   * @param b blue color component
   */
  constructor(t, e, i) {
    this.r = t, this.g = e, this.b = i;
  }
  /**
   * Sets this color equal to another color
   * @param color the point whose values will be used to set this color
   * @returns the color object
   */
  assign(t) {
    return this.set(t.r, t.g, t.b), this;
  }
  /**
   * Creates a copy of this color
   * @returns Copy of this color
   */
  copy() {
    return new it(this.r, this.g, this.b);
  }
  /**
   * Compares this color with another color
   * @param color the color to compare with
   * @returns True if the values of this color equal the other. False otherwise.
   */
  equals(t) {
    return this.r === t.r && this.g === t.g && this.b === t.b;
  }
  /**
   * Sets the color object. Values are specified in the 0-255 range.
   * @param r red color component
   * @param g green color component
   * @param b blue color component
   */
  set(t, e, i) {
    this.r = t, this.g = e, this.b = i;
  }
  /**
   * Sets the color object from floating point values. Values are specified in the 0.0-1.0 range.
   * @param r red color component
   * @param g green color component
   * @param b blue color component
   */
  setFromFloat(t, e, i) {
    this.r = Math.round(255 * t), this.g = Math.round(255 * e), this.b = Math.round(255 * i);
  }
  /**
   * Sets this color from an array of normalized floating point values
   * @param the array to assign from
   */
  fromFloatArray(t) {
    return this.setFromFloat(t[0], t[1], t[2]);
  }
  /**
   * Gets an array of floating point values representing this color. Values are clamped in the 0.0 - 1.0 range.
   * @returns array of floating point values for this color.
   */
  getFloatArray() {
    return [this.r / 255, this.g / 255, this.b / 255];
  }
  /**
   * Populates an array with floating point values for this color. Values are clamped in the 0.0 - 1.0 range.
   * @param arr array whose first three elements will be populated with the r,g, and b values of this color respectively.
   */
  toFloatArray(t = [0, 0, 0]) {
    return t[0] = this.r / 255, t[1] = this.g / 255, t[2] = this.b / 255, t;
  }
  /**
   * Creates a new [[Color]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t) {
    if (hg(t))
      return new it(t.r, t.g, t.b);
    throw new TypeError("Color.fromJson: data does not satisfy type IColor constraints");
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return {
      r: this.r,
      g: this.g,
      b: this.b
    };
  }
  /**
   * Creates a color object from floating point values. Values are specified in the 0.0-1.0 range.
   * @param r red color component
   * @param g green color component
   * @param b blue color component
   * @returns new color object
   */
  static createFromFloat(t, e, i) {
    const s = it.black();
    return s.setFromFloat(t, e, i), s;
  }
  /**
   * Creates a color object from an array of floating point values.
   * Values are specified in the 0.0-1.0 range.
   */
  static createFromFloatArray(t) {
    const e = it.black();
    return e.fromFloatArray(t), e;
  }
  /**
   * Creates a new color object initialized to red.
   * @returns new color object
   */
  static red() {
    return new it(255, 0, 0);
  }
  /**
   * Creates a new color object initialized to green.
   * @returns new color object
   */
  static green() {
    return new it(0, 255, 0);
  }
  /**
   * Creates a new color object initialized to blue.
   * @returns new color object
   */
  static blue() {
    return new it(0, 0, 255);
  }
  /**
   * Creates a new color object initialized to yellow.
   * @returns new color object
   */
  static yellow() {
    return new it(255, 255, 0);
  }
  /**
   * Creates a new color object initialized to white.
   * @returns new color object
   */
  static white() {
    return new it(255, 255, 255);
  }
  /**
   * Creates a new color object initialized to black.
   * @returns new color object
   */
  static black() {
    return new it(0, 0, 0);
  }
}
var rn = /* @__PURE__ */ ((n) => (n[n.Scalar = 1] = "Scalar", n[n.Vec3 = 3] = "Vec3", n[n.Quat = 4] = "Quat", n))(rn || {});
class da {
  /**
   * Creates a new buffer for storing keyframe data.
   * @param keyType The type of keyframes that will be stored in the buffer.
   */
  constructor(t) {
    this.keyType = t, this.times = [], this.values = [], this.tangents = [], this._hasTangents = null, this.keyOffset = t;
  }
  _validateKey(t) {
    if (this.keyType !== t)
      throw new Error(
        `Cannot add keyframe of type: ${rn[t]} to buffer of type: ${rn[this.keyType]}`
      );
  }
  _validateTangents(t) {
    if (this._hasTangents === null)
      this._hasTangents = t;
    else if (this._hasTangents !== t)
      throw new Error(
        `Cannot add keyframe with${t ? "" : "out"} tangents to buffer with${t ? "out" : ""} tangents`
      );
  }
  _findIndexFromTime(t) {
    for (let e = 0; e < this.times.length; e++)
      if (this.times[e] >= t)
        return e;
    return this.times.length;
  }
  /** Returns the index of the keyframe at the specified time. */
  getKeyframeIndex(t) {
    return this.times.indexOf(t);
  }
  /** Deletes a keyframe at the specified index. */
  deleteKeyframe(t) {
    this.times.splice(t, 1), this.tangents.splice(t * this.keyOffset * 2, this.keyOffset * 2), this.values.splice(t * this.keyOffset, this.keyOffset);
  }
  /**
   * Inserts a Scalar keyframe with the specified time. The type of this buffer should be [[KeyType.Scalar]]
   * @returns Index at which keyframe was inserted
   */
  insertScalarKeyframe(t, e, i, s) {
    this._validateKey(
      1
      /* Scalar */
    );
    const r = this._findIndexFromTime(t);
    return this.times.splice(r, 0, t), this.values.splice(r, 0, e), i !== void 0 && s !== void 0 ? (this._validateTangents(!0), this.tangents.splice(r * 2, 0, i, s)) : this._validateTangents(!1), r;
  }
  /** Updates a Scalar keyframe at the specified index. The type of this buffer should be [[KeyType.Scalar]] */
  updateScalarKeyframe(t, e, i, s, r) {
    this.values[t] = i, this.times[t] = e, s !== void 0 && r !== void 0 && (this.tangents[t * 2] = s, this.tangents[t * 2 + 1] = r);
  }
  /**
   * Inserts a Vec3 keyframe with the specified time. The type of this buffer should be [[KeyType.Vec3]]
   * @returns Index at which keyframe was inserted
   */
  insertVec3Keyframe(t, e, i, s, r, o, a, l, c, h) {
    this._validateKey(
      3
      /* Vec3 */
    );
    const u = this._findIndexFromTime(t);
    return this.times.splice(u, 0, t), this.values.splice(u * this.keyOffset, 0, e, i, s), r !== void 0 && o !== void 0 && a !== void 0 && l !== void 0 && c !== void 0 && h !== void 0 ? (this._validateTangents(!0), this.tangents.splice(
      u * this.keyOffset * 2,
      0,
      r,
      o,
      a,
      l,
      c,
      h
    )) : this._validateTangents(!1), u;
  }
  /** Updates a Vec3 keyframe at the specified index. The type of this buffer should be [[KeyType.Vec3]] */
  updateVec3Keyframe(t, e, i, s, r, o, a, l, c, h, u) {
    return this.times[t] = e, this.values[t * this.keyOffset] = i, this.values[t * this.keyOffset + 1] = s, this.values[t * this.keyOffset + 2] = r, o !== void 0 && a !== void 0 && l !== void 0 && c !== void 0 && h !== void 0 && u !== void 0 ? (this._validateTangents(!0), this.tangents.splice(
      t * this.keyOffset * 2,
      0,
      o,
      a,
      l,
      c,
      h,
      u
    ), this.tangents[t * this.keyOffset * 2] = o, this.tangents[t * this.keyOffset * 2 + 1] = a, this.tangents[t * this.keyOffset * 2 + 2] = l, this.tangents[t * this.keyOffset * 2 + 3] = c, this.tangents[t * this.keyOffset * 2 + 4] = h, this.tangents[t * this.keyOffset * 2 + 5] = u) : this._validateTangents(!1), t;
  }
  /**
   * Inserts a Quat keyframe with the specified time. The type of this buffer should be [[KeyType.Quat]]
   * @returns Index at which keyframe was inserted
   */
  insertQuatKeyframe(t, e, i, s, r, o, a, l, c, h, u, p, m) {
    this._validateKey(
      4
      /* Quat */
    );
    const g = this._findIndexFromTime(t);
    this.times.splice(g, 0, t), this.values.splice(g * this.keyOffset, 0, e, i, s, r), o !== void 0 && a !== void 0 && l !== void 0 && c !== void 0 && h !== void 0 && u !== void 0 && p !== void 0 && m !== void 0 ? (this._validateTangents(!0), this.tangents.splice(
      g * this.keyOffset * 2,
      0,
      o,
      a,
      l,
      c,
      h,
      u,
      p,
      m
    )) : this._validateTangents(!1);
  }
  /** Updates a Quat keyframe at the specified index. The type of this buffer should be [[KeyType.Quat]] */
  updateQuatKeyframe(t, e, i, s, r, o, a, l, c, h, u, p, m, g) {
    this.times[t] = e, this.values[t * this.keyOffset] = i, this.values[t * this.keyOffset + 1] = s, this.values[t * this.keyOffset + 2] = r, this.values[t * this.keyOffset + 3] = o, a !== void 0 && l !== void 0 && c !== void 0 && h !== void 0 && u !== void 0 && p !== void 0 && m !== void 0 && g !== void 0 ? (this._validateTangents(!0), this.tangents.splice(
      t * this.keyOffset * 2,
      0,
      a,
      l,
      c,
      u,
      p,
      m
    ), this.tangents[t * this.keyOffset * 2] = a, this.tangents[t * this.keyOffset * 2 + 1] = l, this.tangents[t * this.keyOffset * 2 + 2] = c, this.tangents[t * this.keyOffset * 2 + 3] = g, this.tangents[t * this.keyOffset * 2 + 4] = u, this.tangents[t * this.keyOffset * 2 + 5] = p, this.tangents[t * this.keyOffset * 2 + 6] = m, this.tangents[t * this.keyOffset * 2 + 7] = g) : this._validateTangents(!1);
  }
  /** @hidden */
  _export() {
    const t = {};
    return this.tangents.length !== 0 && (t.tangents = this.tangents.slice()), {
      keyType: rn[this.keyType],
      times: this.times.slice(),
      values: this.values.slice(),
      ...t
    };
  }
  /** @hidden */
  static _import(t) {
    const e = new da(rn[t.keyType]);
    return e.times = t.times.slice(), e.values = t.values.slice(), t.tangents !== void 0 && (e.tangents = t.tangents.slice()), e;
  }
}
var di = /* @__PURE__ */ ((n) => (n[n.None = 0] = "None", n[n.Transform = 1] = "Transform", n[n.Opacity = 2] = "Opacity", n[n.Visibility = 4] = "Visibility", n[n.Color = 8] = "Color", n))(di || {});
class Qu {
  constructor(t) {
    this.nodeId = t, this.translate = d.zero(), this.rotation = Ti.identity(), this.scale = new d(1, 1, 1), this.color = new d(1, 1, 1), this.pivotPoint = null, this.opacity = 1, this.visibility = 1, this.matrix = new Q(), this.flags = 0;
  }
  updateMatrix() {
    this.pivotPoint ? this._updateMatrixWithOrigin() : this._updateMatrix();
  }
  // http://glmatrix.net/docs/mat4.js.html#line1354
  _updateMatrixWithOrigin() {
    const t = this.rotation.x, e = this.rotation.y, i = this.rotation.z, s = this.rotation.w, r = t + t, o = e + e, a = i + i, l = t * r, c = t * o, h = t * a, u = e * o, p = e * a, m = i * a, g = s * r, _ = s * o, y = s * a, b = this.scale.x, w = this.scale.y, v = this.scale.z, C = this.pivotPoint.x, k = this.pivotPoint.y, Y = this.pivotPoint.z, P = (1 - (u + m)) * b, L = (c + y) * b, R = (h - _) * b, D = (c - y) * w, J = (1 - (l + m)) * w, G = (p + g) * w, X = (h + _) * v, Z = (p - g) * v, W = (1 - (l + u)) * v;
    this.matrix.m[0] = P, this.matrix.m[1] = L, this.matrix.m[2] = R, this.matrix.m[3] = 0, this.matrix.m[4] = D, this.matrix.m[5] = J, this.matrix.m[6] = G, this.matrix.m[7] = 0, this.matrix.m[8] = X, this.matrix.m[9] = Z, this.matrix.m[10] = W, this.matrix.m[11] = 0, this.matrix.m[12] = this.translate.x + C - (P * C + D * k + X * Y), this.matrix.m[13] = this.translate.y + k - (L * C + J * k + Z * Y), this.matrix.m[14] = this.translate.z + Y - (R * C + G * k + W * Y), this.matrix.m[15] = 1;
  }
  // http://glmatrix.net/docs/mat4.js.html#line1291
  _updateMatrix() {
    const t = this.rotation.x, e = this.rotation.y, i = this.rotation.z, s = this.rotation.w, r = t + t, o = e + e, a = i + i, l = t * r, c = t * o, h = t * a, u = e * o, p = e * a, m = i * a, g = s * r, _ = s * o, y = s * a, b = this.scale.x, w = this.scale.y, v = this.scale.z;
    this.matrix.m[0] = (1 - (u + m)) * b, this.matrix.m[1] = (c + y) * b, this.matrix.m[2] = (h - _) * b, this.matrix.m[3] = 0, this.matrix.m[4] = (c - y) * w, this.matrix.m[5] = (1 - (l + m)) * w, this.matrix.m[6] = (p + g) * w, this.matrix.m[7] = 0, this.matrix.m[8] = (h + _) * v, this.matrix.m[9] = (p - g) * v, this.matrix.m[10] = (1 - (l + u)) * v, this.matrix.m[11] = 0, this.matrix.m[12] = this.translate.x, this.matrix.m[13] = this.translate.y, this.matrix.m[14] = this.translate.z, this.matrix.m[15] = 1;
  }
}
class qu {
  constructor() {
    this.position = null, this.target = null, this.up = null, this.width = null, this.height = null;
  }
  /** Reset this object to its initial state. */
  clear() {
    this.position = null, this.target = null, this.up = null, this.width = null, this.height = null;
  }
  /**
   * Set the stored values on the supplied [[Camera]].
   * @returns True if the camera was modified.
   */
  apply(t) {
    let e = !1;
    return this.position !== null && (t.setPosition(this.position), e = !0), this.target !== null && (t.setTarget(this.target), e = !0), this.up !== null && (t.setUp(this.up), e = !0), this.width !== null && (t.setWidth(this.width), e = !0), this.height !== null && (t.setHeight(this.height), e = !0), e;
  }
}
class $u {
  constructor() {
    this.opacities = /* @__PURE__ */ new Map(), this.colors = /* @__PURE__ */ new Map(), this.matrixNodeIds = [], this.matrices = [], this.visibilityOn = [], this.visibilityOff = [];
  }
  /** Reset this object to its initial state. */
  clear() {
    this.opacities.clear(), this.colors.clear(), this.matrixNodeIds = [], this.matrices = [], this.visibilityOn = [], this.visibilityOff = [];
  }
  /** Set the stored values on the supplied [[WebViewer]]. */
  apply(t) {
    const e = t.model;
    this.opacities.size > 0 && e.setNodesOpacities(this.opacities), this.colors.size > 0 && e.setNodesColors(this.colors), this.matrixNodeIds.length > 0 && e._setNodesMatrices(this.matrixNodeIds, this.matrices), this.visibilityOn.length > 0 && e.setNodesVisibility(this.visibilityOn, !0), this.visibilityOff.length > 0 && e.setNodesVisibility(this.visibilityOff, !1);
  }
}
class dl {
  constructor() {
    this.node = new $u(), this.camera = new qu();
  }
  /** Reset this object to its initial state. */
  clear() {
    this.node.clear(), this.camera.clear();
  }
  /** Set the stored values on the supplied [[WebViewer]]. */
  apply(t) {
    this.node.apply(t);
    const e = t.view, i = e.getCamera();
    this.camera.apply(i) && e.setCamera(i);
  }
}
var ml = /* @__PURE__ */ ((n) => (n[n.Translation = 0] = "Translation", n[n.Rotation = 1] = "Rotation", n[n.Scale = 2] = "Scale", n[n.Opacity = 3] = "Opacity", n[n.Visibility = 4] = "Visibility", n[n.Color = 5] = "Color", n[n.ColorMap = 6] = "ColorMap", n))(ml || {});
class Ro {
  constructor(t, e, i, s) {
    switch (this.name = t, this.nodeId = e, this.property = i, this.sampler = s, this.property) {
      case 0:
      case 2:
      case 5:
        if (s.buffer.keyType !== rn.Vec3)
          throw new Error("Key type mismatch. Expected Vec3");
        break;
      case 1:
        if (s.buffer.keyType !== rn.Quat)
          throw new Error("Key type mismatch. Expected Quat");
        break;
      case 3:
      case 4:
      case 6:
        if (s.buffer.keyType !== rn.Scalar)
          throw new Error("Key type mismatch. Expected Scalar");
        break;
    }
  }
  /** @hidden */
  _getValue(t, e) {
    switch (this.property) {
      case 0:
        this.sampler.interpolateVec3(t, e.translate), e.flags |= di.Transform;
        break;
      case 1:
        this.sampler.interpolateQuat(t, e.rotation), e.flags |= di.Transform;
        break;
      case 2:
        this.sampler.interpolateVec3(t, e.scale), e.flags |= di.Transform;
        break;
      case 3:
        e.opacity = this.sampler.interpolateScalar(t), e.flags |= di.Opacity;
        break;
      case 4:
        e.visibility = this.sampler.interpolateScalar(t), e.flags |= di.Visibility;
        break;
      case 5:
        this.sampler.interpolateVec3(t, e.color), e.flags |= di.Color;
        break;
      case 6:
        {
          const i = this.sampler.interpolateScalar(t), s = this._getColorFromMap(i);
          s !== null && (e.color.set(s.r, s.g, s.b), e.flags |= di.Color);
        }
        break;
    }
  }
  _getColorFromMap(t) {
    const e = (s, r, o, a, l) => {
      const c = (s - r) / (o - r);
      return new it(
        (1 - c) * a.r + c * l.r,
        (1 - c) * a.g + c * l.g,
        (1 - c) * a.b + c * l.b
      );
    };
    if (this.colorMap === void 0)
      return null;
    t < 0 && (t = 0), t > 1 && (t = 1);
    let i = 0;
    for (; i < this.colorMap.length - 1; ) {
      const s = this.colorMap[i].position, r = this.colorMap[i].color, o = this.colorMap[i + 1].position, a = this.colorMap[i + 1].color;
      if (t <= s)
        return r;
      if (t <= o)
        return e(t, s, o, r, a);
      if (t >= o && i === this.colorMap.length - 2)
        return a;
      ++i;
    }
    return null;
  }
  /** @hidden */
  _gatherForExport(t) {
    this.colorMap !== void 0 && t.colorMaps.add(this.colorMap), t.samplers.add(this.sampler), this.sampler._gatherForExport(t);
  }
  /** @hidden */
  _export(t) {
    const e = {};
    return this.name !== "" && (e.name = this.name), this.colorMap !== void 0 && (e.colorMap = t.colorMaps.getIndex(this.colorMap)), {
      nodeId: this.nodeId,
      property: ml[this.property],
      sampler: t.samplers.getIndex(this.sampler),
      ...e
    };
  }
  /** @hidden */
  static _import(t, e) {
    const i = new Ro(
      e.name || "",
      e.nodeId,
      ml[e.property],
      t.samplers[e.sampler]
    );
    return e.colorMap !== void 0 && (i.colorMap = t.colorMaps[e.colorMap]), i;
  }
}
var Mn = /* @__PURE__ */ ((n) => (n[n.Position = 0] = "Position", n[n.Target = 1] = "Target", n[n.Up = 2] = "Up", n[n.Width = 3] = "Width", n[n.Height = 4] = "Height", n))(Mn || {});
class No {
  /**
   * Do not use directly.  Create via Animation class API.
   * @hidden
   * */
  constructor(t, e, i) {
    switch (this.name = t, this.property = e, this.sampler = i, this.property) {
      case 0:
      case 1:
      case 2:
        if (i.buffer.keyType !== rn.Vec3)
          throw new Error("Key type mismatch. Expected Vec3");
        break;
      case 3:
      case 4:
        if (i.buffer.keyType !== rn.Scalar)
          throw new Error("Key type mismatch. Expected Scalar");
        break;
    }
  }
  /** @hidden */
  _getValue(t, e) {
    switch (this.property) {
      case 0:
        e.position === null && (e.position = new d(0, 0, 0)), this.sampler.interpolateVec3(t, e.position);
        break;
      case 1:
        e.target === null && (e.target = new d(0, 0, -1)), this.sampler.interpolateVec3(t, e.target);
        break;
      case 2:
        e.up === null && (e.up = new d(0, 1, 0)), this.sampler.interpolateVec3(t, e.up);
        break;
      case 3:
        e.width = this.sampler.interpolateScalar(t);
        break;
      case 4:
        e.height = this.sampler.interpolateScalar(t);
    }
  }
  /** @hidden */
  _gatherForExport(t) {
    t.samplers.add(this.sampler), this.sampler._gatherForExport(t);
  }
  /** @hidden */
  _export(t) {
    const e = {};
    return this.name !== "" && (e.name = this.name), {
      property: Mn[this.property],
      sampler: t.samplers.getIndex(this.sampler),
      ...e
    };
  }
  /** @hidden */
  static _import(t, e) {
    return new No(
      e.name || "",
      Mn[e.property],
      t.samplers[e.sampler]
    );
  }
}
class Tl {
  /**
   * Creates a new, empty Animation
   * @param name friendly name for the animation
   */
  constructor(t) {
    this.name = t, this.nodeChannels = [], this.cameraChannels = [], this.pivotPoints = /* @__PURE__ */ new Map();
  }
  /**
   * Creates a new node animation channel.
   * @param name friendly name for the channel.
   * @param target id of node that will receive interpolated values.
   * @param property the node property that will be animated.
   * @param sampler sampler describing the buffer and interpolation type.
   */
  createNodeChannel(t, e, i, s) {
    const r = new Ro(t, e, i, s);
    return this._registerNodeChannel(r), r;
  }
  _registerNodeChannel(t) {
    this.nodeChannels.push(t);
  }
  /**
   * Creates a new camera animation channel.
   * @param name friendly name for the channel.
   * @param property the property that will be animated by this channel.
   * @param sampler sampler describing the buffer and interpolation type used.
   */
  createCameraChannel(t, e, i) {
    const s = new No(t, e, i);
    return this._registerCameraChannel(s), s;
  }
  _registerCameraChannel(t) {
    this.cameraChannels.push(t);
  }
  /**
   * Removes a channel from this animation.
   *
   * Call [[Player.reload]] on any players that are referencing this animation.
   */
  deleteChannel(t) {
    for (let e = 0; e < this.nodeChannels.length; e++)
      if (this.nodeChannels[e] === t) {
        this.nodeChannels.splice(e, 1);
        return;
      }
    for (let e = 0; e < this.cameraChannels.length; e++)
      if (this.cameraChannels[e] === t) {
        this.cameraChannels.splice(e, 1);
        return;
      }
  }
  /** @hidden */
  _gatherForExport(t) {
    for (const e of this.nodeChannels)
      e._gatherForExport(t);
    for (const e of this.cameraChannels)
      e._gatherForExport(t);
  }
  /** @hidden */
  _export(t) {
    const e = [], i = {};
    this.name !== "" && (i.name = this.name);
    const s = {}, r = (o) => {
      if (this[o].length === 0)
        return;
      const a = [];
      for (const l of this[o])
        a.push(l._export(t));
      s[o] = a;
    };
    return this.pivotPoints.forEach((o, a) => {
      e.push({ node: a, point: o });
    }), e.length !== 0 && (i.pivotPoints = e), r("nodeChannels"), r("cameraChannels"), {
      ...i,
      ...s
    };
  }
  /** @hidden */
  static _import(t, e) {
    const i = new Tl(e.name || "");
    if (e.nodeChannels !== void 0)
      for (const s of e.nodeChannels)
        i._registerNodeChannel(Ro._import(t, s));
    if (e.cameraChannels !== void 0)
      for (const s of e.cameraChannels)
        i._registerCameraChannel(No._import(t, s));
    if (e.pivotPoints !== void 0)
      for (const s of e.pivotPoints) {
        const r = d.fromJson(s.point);
        i.pivotPoints.set(s.node, r);
      }
    return i;
  }
}
var pl = /* @__PURE__ */ ((n) => (n[n.Constant = 0] = "Constant", n[n.Linear = 1] = "Linear", n[n.CubicSpline = 2] = "CubicSpline", n))(pl || {});
const wt = class {
  /**
   * Creates a new sampler for a [[KeyframeBuffer]]
   * @param buffer The buffer that will be sampled.
   * @param interpolationType The Type of interpolation that will be used
   */
  constructor(n, t) {
    this.buffer = n, this.interpolationType = t;
  }
  /**
   * Returns the index of the next keyframe for a given frame T.
   * Note that this assumes that all keyframes in the buffer
   * are arranged in ascending order by frame time.
   */
  _getNextKeyframeIndex(n) {
    for (let t = 0; t < this.buffer.times.length; t += 1)
      if (this.buffer.times[t] > n)
        return t;
    return this.buffer.times.length;
  }
  /** Computes an interpolated quaternion for the given frame. */
  interpolateQuat(n, t) {
    const e = this._getNextKeyframeIndex(n);
    if (e === 0) {
      this._setQuatFromKeyframeIndex(0, t);
      return;
    } else if (e === this.buffer.times.length) {
      this._setQuatFromKeyframeIndex(e - 1, t);
      return;
    }
    switch (this.interpolationType) {
      case 0:
        this._setQuatFromKeyframeIndex(e - 1, t);
        break;
      case 1:
        this.interpolateQuatSlerp(e - 1, e, n, t);
        break;
      case 2:
        this.interpolateQuatCubicSpline(e - 1, e, n, t);
        break;
    }
  }
  /** Computes an interpolated Vector 3 value for the given frame. */
  interpolateVec3(n, t) {
    const e = this._getNextKeyframeIndex(n);
    if (e === 0) {
      this._setVecFromKeyframeIndex(0, t);
      return;
    } else if (e === this.buffer.times.length) {
      this._setVecFromKeyframeIndex(e - 1, t);
      return;
    }
    switch (this.interpolationType) {
      case 0:
        this._setVecFromKeyframeIndex(e - 1, t);
        break;
      case 1:
        this.interpolateVec3Linear(e - 1, e, n, t);
        break;
      case 2:
        this.interpolateVec3CubicSpline(e - 1, e, n, t);
        break;
    }
  }
  /** Computes an interpolated scalar value for the given frame. */
  interpolateScalar(n) {
    const t = this._getNextKeyframeIndex(n);
    if (t === 0)
      return this.buffer.values[0];
    if (t === this.buffer.times.length)
      return this.buffer.values[t - 1];
    switch (this.interpolationType) {
      case 0:
        return this.buffer.values[t - 1];
      case 1:
        return this.interpolateScalarLinear(t - 1, t, n);
      case 2:
        return this.interpolateScalarCubicSpline(t - 1, t, n);
    }
  }
  /** Performs linear interpolation of two scalar values beginning at indices k0 and k1. */
  interpolateScalarLinear(n, t, e) {
    const i = this.buffer.times[t] - this.buffer.times[n], s = (e - this.buffer.times[n]) / i, r = this.buffer.values[n], o = this.buffer.values[t];
    return r + (o - r) * s;
  }
  /** Performs spherical linear interpolation on the quaternion values beginning at indices k0 and k1. */
  interpolateQuatSlerp(n, t, e, i) {
    const s = this.buffer.times[t] - this.buffer.times[n], r = (e - this.buffer.times[n]) / s;
    this._setQuatFromKeyframeIndex(n, wt.q0), this._setQuatFromKeyframeIndex(t, wt.q1), i.assign(Ti.interpolate(wt.q0, wt.q1, r));
  }
  static _interpVec3(n, t, e, i) {
    t.subtract(n), t.scale(e), t.add(n), i.assign(t);
  }
  /** Performs linear interpolation on the Vector3 values at keyframes beginning at indices k0 and k1 */
  interpolateVec3Linear(n, t, e, i) {
    const s = this.buffer.times[t] - this.buffer.times[n], r = (e - this.buffer.times[n]) / s;
    this._setVecFromKeyframeIndex(n, wt.v0), this._setVecFromKeyframeIndex(t, wt.v1), wt._interpVec3(wt.v0, wt.v1, r, i);
  }
  _interpCubicSpline(n, t, e, i, s) {
    const r = n ** 2, o = n ** 3;
    return (2 * o - 3 * r + 1) * t + (o - 2 * r + n) * i + (-2 * o + 3 * r) * e + (o - r) * s;
  }
  /** Performs Cubic Spline Interpolation on two scalar values beginning at indices k0 and k1 */
  interpolateScalarCubicSpline(n, t, e) {
    const i = this.buffer.times[t] - this.buffer.times[n], s = (e - this.buffer.times[n]) / i, r = this.buffer.values[n], o = this.buffer.values[t];
    let a = 0, l = 0;
    return this.buffer.tangents.length !== 0 && (a = this.buffer.tangents[n] * i, l = this.buffer.tangents[t] * i), this._interpCubicSpline(s, r, o, a, l);
  }
  /** Performs Cubic Spline Interpolation on the Vector3 values at keyframes beginning at indices k0 and k1 */
  interpolateVec3CubicSpline(n, t, e, i) {
    const s = this.buffer.times[t] - this.buffer.times[n], r = (e - this.buffer.times[n]) / s;
    this._setVecFromKeyframeIndex(n, wt.v0), this._setVecFromKeyframeIndex(t, wt.v1), this._setVecTanFromKeyframeIndex(n, wt.v2), this._setVecTanFromKeyframeIndex(t, wt.v3), wt.v2.scale(s), wt.v3.scale(s), i.set(
      this._interpCubicSpline(r, wt.v0.x, wt.v1.x, wt.v2.x, wt.v3.x),
      this._interpCubicSpline(r, wt.v0.y, wt.v1.y, wt.v2.y, wt.v3.y),
      this._interpCubicSpline(r, wt.v0.z, wt.v1.z, wt.v2.z, wt.v3.z)
    );
  }
  /** Performs Cubic Spline Interpolation on the Quaternion values beginning at indices k0 and k1 */
  interpolateQuatCubicSpline(n, t, e, i) {
    const s = this.buffer.times[t] - this.buffer.times[n], r = (e - this.buffer.times[n]) / s;
    this._setQuatFromKeyframeIndex(n, wt.q0), this._setQuatFromKeyframeIndex(t, wt.q1), this._setQuatTanFromKeyframeIndex(n, wt.q2), this._setQuatTanFromKeyframeIndex(t, wt.q3), wt.q4.set(
      wt.q2.x * s,
      wt.q2.y * s,
      wt.q2.z * s,
      wt.q2.w * s
    ), wt.q5.set(
      wt.q3.x * s,
      wt.q3.y * s,
      wt.q3.z * s,
      wt.q3.w * s
    ), i.set(
      this._interpCubicSpline(r, wt.q0.x, wt.q1.x, wt.q4.x, wt.q5.x),
      this._interpCubicSpline(r, wt.q0.y, wt.q1.y, wt.q4.y, wt.q5.y),
      this._interpCubicSpline(r, wt.q0.z, wt.q1.z, wt.q4.z, wt.q5.z),
      this._interpCubicSpline(r, wt.q0.w, wt.q1.w, wt.q4.w, wt.q5.w)
    ), i.normalize();
  }
  _setVecFromKeyframeIndex(n, t) {
    const e = n * 3;
    t.set(
      this.buffer.values[e],
      this.buffer.values[e + 1],
      this.buffer.values[e + 2]
    );
  }
  _setVecTanFromKeyframeIndex(n, t) {
    if (this.buffer.tangents.length === 0)
      t.set(0, 0, 0);
    else {
      const e = n * 3;
      t.set(
        this.buffer.tangents[e],
        this.buffer.tangents[e + 1],
        this.buffer.tangents[e + 2]
      );
    }
  }
  _setQuatFromKeyframeIndex(n, t) {
    const e = n * 4;
    t.set(
      this.buffer.values[e],
      this.buffer.values[e + 1],
      this.buffer.values[e + 2],
      this.buffer.values[e + 3]
    );
  }
  _setQuatTanFromKeyframeIndex(n, t) {
    if (this.buffer.tangents.length === 0)
      t.set(0, 0, 0, 1);
    else {
      const e = n * 4;
      t.set(
        this.buffer.tangents[e],
        this.buffer.tangents[e + 1],
        this.buffer.tangents[e + 2],
        this.buffer.tangents[e + 3]
      );
    }
  }
  /** @hidden */
  _gatherForExport(n) {
    n.buffers.add(this.buffer);
  }
  /** @hidden */
  _export(n) {
    return {
      buffer: n.buffers.getIndex(this.buffer),
      interpolationType: pl[this.interpolationType]
    };
  }
  /** @hidden */
  static _import(n, t) {
    return new wt(n.buffers[t.buffer], pl[t.interpolationType]);
  }
};
let ln = wt;
ln.q0 = Ti.identity();
ln.q1 = Ti.identity();
ln.q2 = Ti.identity();
ln.q3 = Ti.identity();
ln.q4 = Ti.identity();
ln.q5 = Ti.identity();
ln.v0 = d.zero();
ln.v1 = d.zero();
ln.v2 = d.zero();
ln.v3 = d.zero();
var Rr = /* @__PURE__ */ ((n) => (n[n.Unknown = 0] = "Unknown", n[n.Catia = 2] = "Catia", n[n.CatiaV5 = 3] = "CatiaV5", n[n.Cadds = 4] = "Cadds", n[n.Unigraphics = 5] = "Unigraphics", n[n.Parasolid = 6] = "Parasolid", n[n.Euclid = 7] = "Euclid", n[n.Iges = 9] = "Iges", n[n.Unisurf = 10] = "Unisurf", n[n.Vda = 11] = "Vda", n[n.Stl = 12] = "Stl", n[n.Wrl = 13] = "Wrl", n[n.Dxf = 14] = "Dxf", n[n.Acis = 15] = "Acis", n[n.ProE = 16] = "ProE", n[n.Step = 18] = "Step", n[n.Ideas = 19] = "Ideas", n[n.Jt = 20] = "Jt", n[n.Slw = 22] = "Slw", n[n.Cgr = 23] = "Cgr", n[n.Prc = 24] = "Prc", n[n.Xvl = 25] = "Xvl", n[n.Hpgl = 26] = "Hpgl", n[n.TopSolid = 27] = "TopSolid", n[n.OneSpaceDesigner = 28] = "OneSpaceDesigner", n[n._3dxml = 29] = "_3dxml", n[n.Inventor = 30] = "Inventor", n[n.PostScript = 31] = "PostScript", n[n.Pdp = 32] = "Pdp", n[n.U3d = 33] = "U3d", n[n.Ifc = 34] = "Ifc", n[n.Dwg = 35] = "Dwg", n[n.Dwf = 36] = "Dwf", n[n.Se = 37] = "Se", n[n.Obj = 38] = "Obj", n[n.Kmz = 39] = "Kmz", n[n.Dae = 40] = "Dae", n[n._3ds = 41] = "_3ds", n[n.Rhino = 43] = "Rhino", n[n.Xml = 44] = "Xml", n[n._3mf = 45] = "_3mf", n[n.Scs = 46] = "Scs", n[n._3dHtml = 47] = "_3dHtml", n[n.Hsf = 48] = "Hsf", n[n.Gltf = 49] = "Gltf", n[n.Revit = 50] = "Revit", n[n.Fbx = 51] = "Fbx", n))(Rr || {}), he = /* @__PURE__ */ ((n) => (n[n.IsLoaded = -2147483648] = "IsLoaded", n[n.InitiallyShown = 1073741824] = "InitiallyShown", n[n.InitiallyRemoved = 536870912] = "InitiallyRemoved", n[n.OutOfHierarchy = 268435456] = "OutOfHierarchy", n[n.IsAnnotationView = 134217728] = "IsAnnotationView", n[n.IsCameraSet = 67108864] = "IsCameraSet", n[n.IsPmiFilteringSet = 33554432] = "IsPmiFilteringSet", n[n.IsGeomFilteringSet = 16777216] = "IsGeomFilteringSet", n[n.IsCrossSectionSet = 8388608] = "IsCrossSectionSet", n[n.IsExplosionSet = 4194304] = "IsExplosionSet", n[n.IsCombineState = 2097152] = "IsCombineState", n[n.IsPerspective = 1048576] = "IsPerspective", n[n.IsShownSpecified = 524288] = "IsShownSpecified", n[n.IsShown = 262144] = "IsShown", n[n.BranchVisibilityHidden = 131072] = "BranchVisibilityHidden", n[n.BranchVisibilityShown = 65536] = "BranchVisibilityShown", n[n.BranchVisibilityDirty = 32768] = "BranchVisibilityDirty", n[n.PreventFromResetting = 16384] = "PreventFromResetting", n[n.HasDynamicFrame = 8192] = "HasDynamicFrame", n[n.IsMissing = 4096] = "IsMissing", n[n.IsExternalModelRoot = 2048] = "IsExternalModelRoot", n[n.Requested = 1024] = "Requested", n[n.ImplicitBody = 512] = "ImplicitBody", n[n.IsDefaultView = 256] = "IsDefaultView", n[n.Unused2 = 128] = "Unused2", n[n.Unused1 = 64] = "Unused1", n[n.NodeTypeDrawingSheet = 32] = "NodeTypeDrawingSheet", n[n.IsADefaultNodeType = 16] = "IsADefaultNodeType", n[n.NodeTypeDrawingView = 8] = "NodeTypeDrawingView", n[n.NodeTypeGroup = 4] = "NodeTypeGroup", n[n.NodeTypeProduct = 2] = "NodeTypeProduct", n[n.IsAConfigurationNode = 1] = "IsAConfigurationNode", n))(he || {}), zn = /* @__PURE__ */ ((n) => (n[
  n.OutOfHierarchy = 268435456
  /* OutOfHierarchy */
] = "OutOfHierarchy", n[
  n.PreventFromResetting = 16384
  /* PreventFromResetting */
] = "PreventFromResetting", n[
  n.Requested = 1024
  /* Requested */
] = "Requested", n[
  n.ImplicitBody = 512
  /* ImplicitBody */
] = "ImplicitBody", n))(zn || {}), bt = /* @__PURE__ */ ((n) => (n[n.None = 0] = "None", n[n.BodyInstance = 1] = "BodyInstance", n[n.PmiBody = 2] = "PmiBody", n[n.ViewFrame = 4] = "ViewFrame", n[n.All = 7] = "All", n))(bt || {}), li = /* @__PURE__ */ ((n) => (n[n.ProductOccurrence = 0] = "ProductOccurrence", n[n.AnyBody = 1] = "AnyBody", n[n.BodyInstance = 2] = "BodyInstance", n[n.CadView = 3] = "CadView", n))(li || {}), We = ((n) => (n[n.InitiallyShown = he.InitiallyShown] = "InitiallyShown", n[n.InitiallyRemoved = he.InitiallyRemoved] = "InitiallyRemoved", n[n.IsShownSpecified = he.IsShownSpecified] = "IsShownSpecified", n[n.IsShown = he.IsShown] = "IsShown", n[n.IsLoaded = he.IsLoaded] = "IsLoaded", n))(We || {}), bc = ((n) => (n[n.IsMissing = he.IsMissing] = "IsMissing", n))(bc || {}), we = ((n) => (n[n.IsAnnotationView = he.IsAnnotationView] = "IsAnnotationView", n[n.IsCameraSet = he.IsCameraSet] = "IsCameraSet", n[n.IsPmiFilteringSet = he.IsPmiFilteringSet] = "IsPmiFilteringSet", n[n.IsGeomFilteringSet = he.IsGeomFilteringSet] = "IsGeomFilteringSet", n[n.IsCrossSectionSet = he.IsCrossSectionSet] = "IsCrossSectionSet", n[n.IsExplosionSet = he.IsExplosionSet] = "IsExplosionSet", n[n.IsCombineState = he.IsCombineState] = "IsCombineState", n[n.IsPerspective = he.IsPerspective] = "IsPerspective", n[n.HasDynamicFrame = he.HasDynamicFrame] = "HasDynamicFrame", n[n.IsDefaultView = he.IsDefaultView] = "IsDefaultView", n))(we || {}), Ss = /* @__PURE__ */ ((n) => (n[n.Rgba32 = 0] = "Rgba32", n[n.Rgb24 = 1] = "Rgb24", n[n.Gray8 = 2] = "Gray8", n[n.GrayAlpha16 = 3] = "GrayAlpha16", n[n.Jpeg = 4] = "Jpeg", n[n.Png = 5] = "Png", n))(Ss || {}), ah = /* @__PURE__ */ ((n) => (n[n.Invalid = 4294967295] = "Invalid", n))(ah || {}), Hn = /* @__PURE__ */ ((n) => (n[n.Invalid = 4294967295] = "Invalid", n[n.Local = 0] = "Local", n))(Hn || {}), Pr = /* @__PURE__ */ ((n) => (n[n.Invalid = 4294967295] = "Invalid", n))(Pr || {}), El = /* @__PURE__ */ ((n) => (n[n.Invalid = 4294967295] = "Invalid", n))(El || {}), td = /* @__PURE__ */ ((n) => (n[n.Invalid = 4294967295] = "Invalid", n))(td || {}), ed = /* @__PURE__ */ ((n) => (n[n.Invalid = 4294967295] = "Invalid", n))(ed || {}), ve = /* @__PURE__ */ ((n) => (n[n.Invalid = 4294967295] = "Invalid", n[n.Local = 0] = "Local", n))(ve || {}), lh = /* @__PURE__ */ ((n) => (n[n.Invalid = 4294967295] = "Invalid", n))(lh || {}), id = /* @__PURE__ */ ((n) => (n[n.Invalid = 4294967295] = "Invalid", n))(id || {}), nd = /* @__PURE__ */ ((n) => (n[n.Invalid = 4294967295] = "Invalid", n))(nd || {}), Zo = /* @__PURE__ */ ((n) => (n[n.Invalid = 4294967295] = "Invalid", n))(Zo || {}), Ji = /* @__PURE__ */ ((n) => (n[n.Invalid = 4294967295] = "Invalid", n[n.Empty = 4294967294] = "Empty", n[n.Local = 0] = "Local", n))(Ji || {}), sd = /* @__PURE__ */ ((n) => (n[n.Invalid = 4294967295] = "Invalid", n))(sd || {}), rd = /* @__PURE__ */ ((n) => (n[n.World = 0] = "World", n[n.Camera = 1] = "Camera", n))(rd || {}), od = /* @__PURE__ */ ((n) => (n[n.Directional = 0] = "Directional", n))(od || {}), lr = /* @__PURE__ */ ((n) => (n[n.OfInitialEmptyModel = 0] = "OfInitialEmptyModel", n))(lr || {}), ch = /* @__PURE__ */ ((n) => (n[n.None = 0] = "None", n[n.SMAA = 1] = "SMAA", n))(ch || {}), Co = /* @__PURE__ */ ((n) => (n[n.Floor = 0] = "Floor", n[n.Wall = 1] = "Wall", n[n.Door = 2] = "Door", n))(Co || {}), ko = /* @__PURE__ */ ((n) => (n[n.Pixels = 0] = "Pixels", n[n.ProportionOfWidth = 1] = "ProportionOfWidth", n[n.ProportionOfHeight = 2] = "ProportionOfHeight", n))(ko || {}), ad = /* @__PURE__ */ ((n) => (n[n.Object = 0] = "Object", n[n.World = 1] = "World", n))(ad || {}), Dn = /* @__PURE__ */ ((n) => (n[n.Default = 0] = "Default", n[n.Highlight = 1] = "Highlight", n[n.HiddenLine = 2] = "HiddenLine", n[n.XRay = 3] = "XRay", n[n.Gooch = 4] = "Gooch", n[n.Toon = 5] = "Toon", n))(Dn || {}), ld = /* @__PURE__ */ ((n) => (n[n.FixedFramerate = 0] = "FixedFramerate", n[n.OcclusionCulling = 1] = "OcclusionCulling", n))(ld || {}), Je = /* @__PURE__ */ ((n) => (n[n.Faces = 0] = "Faces", n[n.Lines = 1] = "Lines", n[n.Points = 2] = "Points", n))(Je || {}), cd = /* @__PURE__ */ ((n) => (n[n.None = 0] = "None", n[n.Faces = 1] = "Faces", n[n.Lines = 2] = "Lines", n[n.Points = 4] = "Points", n[n.All = 7] = "All", n))(cd || {}), xs = /* @__PURE__ */ ((n) => (n[n.None = 0] = "None", n[n.Modulate = 1] = "Modulate", n[n.Desaturate = 2] = "Desaturate", n[n.Colorize = 3] = "Colorize", n))(xs || {}), hh = /* @__PURE__ */ ((n) => (n[n.Visible = 0] = "Visible", n[n.VisibleWithFullOutline = 1] = "VisibleWithFullOutline", n))(hh || {}), hd = /* @__PURE__ */ ((n) => (n[n.Object = 0] = "Object", n[n.World = 1] = "World", n[n.ProportionOfScreenWidth = 2] = "ProportionOfScreenWidth", n[n.ProportionOfScreenHeight = 3] = "ProportionOfScreenHeight", n))(hd || {}), ud = /* @__PURE__ */ ((n) => (n[n.Square = 0] = "Square", n[n.Disk = 1] = "Disk", n[n.Sphere = 2] = "Sphere", n))(ud || {}), dd = /* @__PURE__ */ ((n) => (n[n.ScreenPixels = 0] = "ScreenPixels", n[n.CSSPixels = 1] = "CSSPixels", n[n.World = 2] = "World", n[n.ProportionOfScreenWidth = 3] = "ProportionOfScreenWidth", n[n.ProportionOfScreenHeight = 4] = "ProportionOfScreenHeight", n[n.ProportionOfBoundingDiagonal = 5] = "ProportionOfBoundingDiagonal", n))(dd || {}), Lo = /* @__PURE__ */ ((n) => (n[n.Perspective = 0] = "Perspective", n[n.Orthographic = 1] = "Orthographic", n[n.Stretched = 2] = "Stretched", n))(Lo || {}), Oe = /* @__PURE__ */ ((n) => (n[n.Uninitialized = 0] = "Uninitialized", n[n.Network = 1] = "Network", n[n.Scs = 2] = "Scs", n))(Oe || {}), hs = /* @__PURE__ */ ((n) => (n[n.Hide = 0] = "Hide", n[n.Show = 1] = "Show", n[n.Initial = 2] = "Initial", n))(hs || {}), uh = /* @__PURE__ */ ((n) => (n[n.World = 0] = "World", n[n.ProportionOfBoundingHeight = 1] = "ProportionOfBoundingHeight", n))(uh || {}), md = /* @__PURE__ */ ((n) => (n[n.Low = 0] = "Low", n[n.Medium = 1] = "Medium", n[n.High = 2] = "High", n[n.Ultra = 3] = "Ultra", n))(md || {}), dh = /* @__PURE__ */ ((n) => (n[n.SessionNotStarted = 0] = "SessionNotStarted", n[n.Cancelled = 1] = "Cancelled", n[n.CorruptRpcMessage = 2] = "CorruptRpcMessage", n))(dh || {}), gl = /* @__PURE__ */ ((n) => (n[n.On = 0] = "On", n[n.Off = 1] = "Off", n))(gl || {}), fl = /* @__PURE__ */ ((n) => (n[n.On = 0] = "On", n[n.Off = 1] = "Off", n))(fl || {}), Mo = /* @__PURE__ */ ((n) => (n[n.None = 0] = "None", n[n.Decal = 1] = "Decal", n))(Mo || {}), _l = /* @__PURE__ */ ((n) => (n[n.UV = 0] = "UV", n))(_l || {}), yl = /* @__PURE__ */ ((n) => (n[n.Repeat = 0] = "Repeat", n[n.Clamp = 1] = "Clamp", n[n.Trim = 2] = "Trim", n))(yl || {}), pd = /* @__PURE__ */ ((n) => (n[n.Unsorted = 0] = "Unsorted", n[n.SingleLayer = 1] = "SingleLayer", n))(pd || {}), bl = /* @__PURE__ */ ((n) => (n[n.Selected = 0] = "Selected", n[n.Unselected = 1] = "Unselected", n))(bl || {}), ei = /* @__PURE__ */ ((n) => (n[n.None = 0] = "None", n[n.Floor = 1] = "Floor", n[n.Wall = 2] = "Wall", n[n.Door = 4] = "Door", n))(ei || {}), kn = /* @__PURE__ */ ((n) => (n[n.UpperLeftCorner = 0] = "UpperLeftCorner", n[n.LowerLeftCorner = 1] = "LowerLeftCorner", n[n.LowerRightCorner = 2] = "LowerRightCorner", n[n.UpperRightCorner = 3] = "UpperRightCorner", n[n.TopCenter = 4] = "TopCenter", n[n.LeftCenter = 5] = "LeftCenter", n[n.RightCenter = 6] = "RightCenter", n[n.BottomCenter = 7] = "BottomCenter", n[n.Center = 8] = "Center", n))(kn || {}), Gr = /* @__PURE__ */ ((n) => (n[n.Pixels = 0] = "Pixels", n[n.ProportionOfScreen = 1] = "ProportionOfScreen", n[n.MinimumProportionOfScreen = 2] = "MinimumProportionOfScreen", n[n.ProportionOfOtherDimension = 3] = "ProportionOfOtherDimension", n))(Gr || {});
const nn = 0;
function $s(n) {
  return n !== null && typeof n == "object" && "scFunction" in n && typeof n.scFunction == "string";
}
function gd(n) {
  const t = n.data;
  return t !== null && typeof t == "object" && "scStateFailure" in t ? t.scStateFailure : null;
}
var tr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Rl(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var fd = { exports: {} };
/*!
 * Bowser - a browser detector
 * https://github.com/ded/bowser
 * MIT License | (c) Dustin Diaz 2015
 */
(function(n) {
  (function(t, e, i) {
    n.exports ? n.exports = i() : t[e] = i();
  })(tr, "bowser", function() {
    var t = !0;
    function e(c) {
      function h(U) {
        var ht = c.match(U);
        return ht && ht.length > 1 && ht[1] || "";
      }
      function u(U) {
        var ht = c.match(U);
        return ht && ht.length > 1 && ht[2] || "";
      }
      var p = h(/(ipod|iphone|ipad)/i).toLowerCase(), m = /like android/i.test(c), g = !m && /android/i.test(c), _ = /nexus\s*[0-6]\s*/i.test(c), y = !_ && /nexus\s*[0-9]+/i.test(c), b = /CrOS/.test(c), w = /silk/i.test(c), v = /sailfish/i.test(c), C = /tizen/i.test(c), k = /(web|hpw)(o|0)s/i.test(c), Y = /windows phone/i.test(c), P = !Y && /windows/i.test(c), L = !p && !w && /macintosh/i.test(c), R = !g && !v && !C && !k && /linux/i.test(c), D = u(/edg([ea]|ios)\/(\d+(\.\d+)?)/i), J = h(/version\/(\d+(\.\d+)?)/i), G = /tablet/i.test(c) && !/tablet pc/i.test(c), X = !G && /[^-]mobi/i.test(c), Z = /xbox/i.test(c), W;
      /opera/i.test(c) ? W = {
        name: "Opera",
        opera: t,
        version: J || h(/(?:opera|opr|opios)[\s\/](\d+(\.\d+)?)/i)
      } : /opr\/|opios/i.test(c) ? W = {
        name: "Opera",
        opera: t,
        version: h(/(?:opr|opios)[\s\/](\d+(\.\d+)?)/i) || J
      } : /SamsungBrowser/i.test(c) ? W = {
        name: "Samsung Internet for Android",
        samsungBrowser: t,
        version: J || h(/(?:SamsungBrowser)[\s\/](\d+(\.\d+)?)/i)
      } : /Whale/i.test(c) ? W = {
        name: "NAVER Whale browser",
        whale: t,
        version: h(/(?:whale)[\s\/](\d+(?:\.\d+)+)/i)
      } : /MZBrowser/i.test(c) ? W = {
        name: "MZ Browser",
        mzbrowser: t,
        version: h(/(?:MZBrowser)[\s\/](\d+(?:\.\d+)+)/i)
      } : /coast/i.test(c) ? W = {
        name: "Opera Coast",
        coast: t,
        version: J || h(/(?:coast)[\s\/](\d+(\.\d+)?)/i)
      } : /focus/i.test(c) ? W = {
        name: "Focus",
        focus: t,
        version: h(/(?:focus)[\s\/](\d+(?:\.\d+)+)/i)
      } : /yabrowser/i.test(c) ? W = {
        name: "Yandex Browser",
        yandexbrowser: t,
        version: J || h(/(?:yabrowser)[\s\/](\d+(\.\d+)?)/i)
      } : /ucbrowser/i.test(c) ? W = {
        name: "UC Browser",
        ucbrowser: t,
        version: h(/(?:ucbrowser)[\s\/](\d+(?:\.\d+)+)/i)
      } : /mxios/i.test(c) ? W = {
        name: "Maxthon",
        maxthon: t,
        version: h(/(?:mxios)[\s\/](\d+(?:\.\d+)+)/i)
      } : /epiphany/i.test(c) ? W = {
        name: "Epiphany",
        epiphany: t,
        version: h(/(?:epiphany)[\s\/](\d+(?:\.\d+)+)/i)
      } : /puffin/i.test(c) ? W = {
        name: "Puffin",
        puffin: t,
        version: h(/(?:puffin)[\s\/](\d+(?:\.\d+)?)/i)
      } : /sleipnir/i.test(c) ? W = {
        name: "Sleipnir",
        sleipnir: t,
        version: h(/(?:sleipnir)[\s\/](\d+(?:\.\d+)+)/i)
      } : /k-meleon/i.test(c) ? W = {
        name: "K-Meleon",
        kMeleon: t,
        version: h(/(?:k-meleon)[\s\/](\d+(?:\.\d+)+)/i)
      } : Y ? (W = {
        name: "Windows Phone",
        osname: "Windows Phone",
        windowsphone: t
      }, D ? (W.msedge = t, W.version = D) : (W.msie = t, W.version = h(/iemobile\/(\d+(\.\d+)?)/i))) : /msie|trident/i.test(c) ? W = {
        name: "Internet Explorer",
        msie: t,
        version: h(/(?:msie |rv:)(\d+(\.\d+)?)/i)
      } : b ? W = {
        name: "Chrome",
        osname: "Chrome OS",
        chromeos: t,
        chromeBook: t,
        chrome: t,
        version: h(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
      } : /edg([ea]|ios)/i.test(c) ? W = {
        name: "Microsoft Edge",
        msedge: t,
        version: D
      } : /vivaldi/i.test(c) ? W = {
        name: "Vivaldi",
        vivaldi: t,
        version: h(/vivaldi\/(\d+(\.\d+)?)/i) || J
      } : v ? W = {
        name: "Sailfish",
        osname: "Sailfish OS",
        sailfish: t,
        version: h(/sailfish\s?browser\/(\d+(\.\d+)?)/i)
      } : /seamonkey\//i.test(c) ? W = {
        name: "SeaMonkey",
        seamonkey: t,
        version: h(/seamonkey\/(\d+(\.\d+)?)/i)
      } : /firefox|iceweasel|fxios/i.test(c) ? (W = {
        name: "Firefox",
        firefox: t,
        version: h(/(?:firefox|iceweasel|fxios)[ \/](\d+(\.\d+)?)/i)
      }, /\((mobile|tablet);[^\)]*rv:[\d\.]+\)/i.test(c) && (W.firefoxos = t, W.osname = "Firefox OS")) : w ? W = {
        name: "Amazon Silk",
        silk: t,
        version: h(/silk\/(\d+(\.\d+)?)/i)
      } : /phantom/i.test(c) ? W = {
        name: "PhantomJS",
        phantom: t,
        version: h(/phantomjs\/(\d+(\.\d+)?)/i)
      } : /slimerjs/i.test(c) ? W = {
        name: "SlimerJS",
        slimer: t,
        version: h(/slimerjs\/(\d+(\.\d+)?)/i)
      } : /blackberry|\bbb\d+/i.test(c) || /rim\stablet/i.test(c) ? W = {
        name: "BlackBerry",
        osname: "BlackBerry OS",
        blackberry: t,
        version: J || h(/blackberry[\d]+\/(\d+(\.\d+)?)/i)
      } : k ? (W = {
        name: "WebOS",
        osname: "WebOS",
        webos: t,
        version: J || h(/w(?:eb)?osbrowser\/(\d+(\.\d+)?)/i)
      }, /touchpad\//i.test(c) && (W.touchpad = t)) : /bada/i.test(c) ? W = {
        name: "Bada",
        osname: "Bada",
        bada: t,
        version: h(/dolfin\/(\d+(\.\d+)?)/i)
      } : C ? W = {
        name: "Tizen",
        osname: "Tizen",
        tizen: t,
        version: h(/(?:tizen\s?)?browser\/(\d+(\.\d+)?)/i) || J
      } : /qupzilla/i.test(c) ? W = {
        name: "QupZilla",
        qupzilla: t,
        version: h(/(?:qupzilla)[\s\/](\d+(?:\.\d+)+)/i) || J
      } : /chromium/i.test(c) ? W = {
        name: "Chromium",
        chromium: t,
        version: h(/(?:chromium)[\s\/](\d+(?:\.\d+)?)/i) || J
      } : /chrome|crios|crmo/i.test(c) ? W = {
        name: "Chrome",
        chrome: t,
        version: h(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
      } : g ? W = {
        name: "Android",
        version: J
      } : /safari|applewebkit/i.test(c) ? (W = {
        name: "Safari",
        safari: t
      }, J && (W.version = J)) : p ? (W = {
        name: p == "iphone" ? "iPhone" : p == "ipad" ? "iPad" : "iPod"
      }, J && (W.version = J)) : /googlebot/i.test(c) ? W = {
        name: "Googlebot",
        googlebot: t,
        version: h(/googlebot\/(\d+(\.\d+))/i) || J
      } : W = {
        name: h(/^(.*)\/(.*) /),
        version: u(/^(.*)\/(.*) /)
      }, !W.msedge && /(apple)?webkit/i.test(c) ? (/(apple)?webkit\/537\.36/i.test(c) ? (W.name = W.name || "Blink", W.blink = t) : (W.name = W.name || "Webkit", W.webkit = t), !W.version && J && (W.version = J)) : !W.opera && /gecko\//i.test(c) && (W.name = W.name || "Gecko", W.gecko = t, W.version = W.version || h(/gecko\/(\d+(\.\d+)?)/i)), !W.windowsphone && (g || W.silk) ? (W.android = t, W.osname = "Android") : !W.windowsphone && p ? (W[p] = t, W.ios = t, W.osname = "iOS") : L ? (W.mac = t, W.osname = "macOS") : Z ? (W.xbox = t, W.osname = "Xbox") : P ? (W.windows = t, W.osname = "Windows") : R && (W.linux = t, W.osname = "Linux");
      function st(U) {
        switch (U) {
          case "NT":
            return "NT";
          case "XP":
            return "XP";
          case "NT 5.0":
            return "2000";
          case "NT 5.1":
            return "XP";
          case "NT 5.2":
            return "2003";
          case "NT 6.0":
            return "Vista";
          case "NT 6.1":
            return "7";
          case "NT 6.2":
            return "8";
          case "NT 6.3":
            return "8.1";
          case "NT 10.0":
            return "10";
          default:
            return;
        }
      }
      var j = "";
      W.windows ? j = st(h(/Windows ((NT|XP)( \d\d?.\d)?)/i)) : W.windowsphone ? j = h(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i) : W.mac ? (j = h(/Mac OS X (\d+([_\.\s]\d+)*)/i), j = j.replace(/[_\s]/g, ".")) : p ? (j = h(/os (\d+([_\s]\d+)*) like mac os x/i), j = j.replace(/[_\s]/g, ".")) : g ? j = h(/android[ \/-](\d+(\.\d+)*)/i) : W.webos ? j = h(/(?:web|hpw)os\/(\d+(\.\d+)*)/i) : W.blackberry ? j = h(/rim\stablet\sos\s(\d+(\.\d+)*)/i) : W.bada ? j = h(/bada\/(\d+(\.\d+)*)/i) : W.tizen && (j = h(/tizen[\/\s](\d+(\.\d+)*)/i)), j && (W.osversion = j);
      var gt = !W.windows && j.split(".")[0];
      return G || y || p == "ipad" || g && (gt == 3 || gt >= 4 && !X) || W.silk ? W.tablet = t : (X || p == "iphone" || p == "ipod" || g || _ || W.blackberry || W.webos || W.bada) && (W.mobile = t), W.msedge || W.msie && W.version >= 10 || W.yandexbrowser && W.version >= 15 || W.vivaldi && W.version >= 1 || W.chrome && W.version >= 20 || W.samsungBrowser && W.version >= 4 || W.whale && o([W.version, "1.0"]) === 1 || W.mzbrowser && o([W.version, "6.0"]) === 1 || W.focus && o([W.version, "1.0"]) === 1 || W.firefox && W.version >= 20 || W.safari && W.version >= 6 || W.opera && W.version >= 10 || W.ios && W.osversion && W.osversion.split(".")[0] >= 6 || W.blackberry && W.version >= 10.1 || W.chromium && W.version >= 20 ? W.a = t : W.msie && W.version < 10 || W.chrome && W.version < 20 || W.firefox && W.version < 20 || W.safari && W.version < 6 || W.opera && W.version < 10 || W.ios && W.osversion && W.osversion.split(".")[0] < 6 || W.chromium && W.version < 20 ? W.c = t : W.x = t, W;
    }
    var i = e(typeof navigator < "u" && navigator.userAgent || "");
    i.test = function(c) {
      for (var h = 0; h < c.length; ++h) {
        var u = c[h];
        if (typeof u == "string" && u in i)
          return !0;
      }
      return !1;
    };
    function s(c) {
      return c.split(".").length;
    }
    function r(c, h) {
      var u = [], p;
      if (Array.prototype.map)
        return Array.prototype.map.call(c, h);
      for (p = 0; p < c.length; p++)
        u.push(h(c[p]));
      return u;
    }
    function o(c) {
      for (var h = Math.max(s(c[0]), s(c[1])), u = r(c, function(p) {
        var m = h - s(p);
        return p = p + new Array(m + 1).join(".0"), r(p.split("."), function(g) {
          return new Array(20 - g.length).join("0") + g;
        }).reverse();
      }); --h >= 0; ) {
        if (u[0][h] > u[1][h])
          return 1;
        if (u[0][h] === u[1][h]) {
          if (h === 0)
            return 0;
        } else
          return -1;
      }
    }
    function a(c, h, u) {
      var p = i;
      typeof h == "string" && (u = h, h = void 0), h === void 0 && (h = !1), u && (p = e(u));
      var m = "" + p.version;
      for (var g in c)
        if (c.hasOwnProperty(g) && p[g]) {
          if (typeof c[g] != "string")
            throw new Error("Browser version in the minVersion map should be a string: " + g + ": " + String(c));
          return o([m, c[g]]) < 0;
        }
      return h;
    }
    function l(c, h, u) {
      return !a(c, h, u);
    }
    return i.isUnsupportedBrowser = a, i.compareVersions = o, i.check = l, i._detect = e, i.detect = e, i;
  });
})(fd);
var _d = fd.exports;
const ug = /* @__PURE__ */ Rl(_d), dg = /* @__PURE__ */ Up({
  __proto__: null,
  default: ug
}, [_d]), mg = "data:application/javascript;base64,CnZhciBTY0VuZ2luZU1vZHVsZSA9ICgoKSA9PiB7CiAgdmFyIF9zY3JpcHREaXIgPSBpbXBvcnQubWV0YS51cmw7CiAgCiAgcmV0dXJuICgKZnVuY3Rpb24oU2NFbmdpbmVNb2R1bGUpIHsKICBTY0VuZ2luZU1vZHVsZSA9IFNjRW5naW5lTW9kdWxlIHx8IHt9OwoKCnZhciBnO2d8fChnPXR5cGVvZiBTY0VuZ2luZU1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBTY0VuZ2luZU1vZHVsZSA6IHt9KTt2YXIgYWEsZmE7Zy5yZWFkeT1uZXcgUHJvbWlzZShmdW5jdGlvbihhLGIpe2FhPWE7ZmE9Yn0pO2cuJCRzZXRSZWFkeT1mdW5jdGlvbigpe2cuZ2soKTtnLiQkb25SZWFkeS5hcHBseSh3aW5kb3csYXJndW1lbnRzKTtnLiQkb25SZWFkeT12b2lkIDA7Zy5vbkFib3J0PXZvaWQgMH07CmcuZ2s9ZnVuY3Rpb24oKXtmdW5jdGlvbiBhKEUpe2lmKCFFKXJldHVybiAwO3ZhciBBPWcuJCRlcy5hbGxvY2F0ZVVpbnQ4QnVmZmVyKDgqRS5sZW5ndGgpO2lmKEEpaGEuc2V0KEUsQT4+Myk7ZWxzZSB0aHJvdyBFcnJvcigiT3V0IG9mIG1lbW9yeS4iKTtyZXR1cm4gQX1mdW5jdGlvbiBiKEUpe2lmKCFFKXJldHVybiAwO3ZhciBBPWcuJCRlcy5hbGxvY2F0ZVVpbnQ4QnVmZmVyKDQqRS5sZW5ndGgpO2lmKEEpaC5zZXQoRSxBPj4yKTtlbHNlIHRocm93IEVycm9yKCJPdXQgb2YgbWVtb3J5LiIpO3JldHVybiBBfWZ1bmN0aW9uIGMoRSl7aWYoIUUpcmV0dXJuIDA7dmFyIEE9Zy4kJGVzLmFsbG9jYXRlVWludDhCdWZmZXIoRS5sZW5ndGgpO2lmKEEpdC5zZXQoRSxBKTtlbHNlIHRocm93IEVycm9yKCJPdXQgb2YgbWVtb3J5LiIpO3JldHVybiBBfWZ1bmN0aW9uIGQoRSl7Zy4kJGVzLmRlYWxsb2NhdGVVaW50OEJ1ZmZlcihFKX1mdW5jdGlvbiBlKEUpe3JldHVybiBmdW5jdGlvbigpe3JldHVybiBuKEUsCmFyZ3VtZW50cyl9fWZ1bmN0aW9uIGYoRSxBLFUpe2Z1bmN0aW9uIEsoeWEpe3JldHVybiBmdW5jdGlvbigpe0coKTtSJiZ5LmNhbGxSZWNvcmQucHVzaCh5YSsiICIrdyhhcmd1bWVudHMpKTtyZXR1cm4gbCh0aGlzLGdbRV1beWFdLGFyZ3VtZW50cyl9fWZ1bmN0aW9uIGphKCl7RygpO3RoaXMuJCRtZW1vcnk9bmV3IFVpbnQ4QXJyYXkoZ1tFXVsic2l6ZW9mXyIrQV0oKSk7bCh0aGlzLGdbRV1bVysiY3JlYXRlIl0sYXJndW1lbnRzKX12YXIgVz1BKyJfIjtqYS5wcm90b3R5cGU9eyQkc3RhY2tpZnk6ITB9O2phLmNvcHk9ZnVuY3Rpb24oeWEpe0coKTt2YXIgQWE9T2JqZWN0LmNyZWF0ZShqYS5wcm90b3R5cGUpO0FhLiQkbWVtb3J5PW5ldyBVaW50OEFycmF5KHQuc3ViYXJyYXkoeWEseWErZ1tFXVsic2l6ZW9mXyIrQV0oKSkpO3JldHVybiBBYX07amEuY2xvbmU9ZnVuY3Rpb24oeWEpe3ZhciBBYT1PYmplY3QuY3JlYXRlKGphLnByb3RvdHlwZSk7QWEuJCRtZW1vcnk9bmV3IFVpbnQ4QXJyYXkoeWEuJCRtZW1vcnkpOwpyZXR1cm4gQWF9O2phLmFzc2lnbj1mdW5jdGlvbih5YSxBYSl7eWEuJCRtZW1vcnkuc2V0KEFhLiQkbWVtb3J5KX07Zm9yKHZhciB0YT0wO3RhPFUubGVuZ3RoO3RhKyspamEucHJvdG90eXBlW1VbdGFdXT1LKFcrVVt0YV0pO3JldHVybiB5W0FdPWphfWZ1bmN0aW9uIGwoRSxBLFUpe1U9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoVSk7VS51bnNoaWZ0KEUpO3JldHVybiBuKEEsVSl9ZnVuY3Rpb24gbihFLEEpe2Zvcih2YXIgVT0hMSxLPTA7SzxBLmxlbmd0aDsrK0spaWYoQVtLXS4kJHN0YWNraWZ5KXtVPSEwO2JyZWFrfWlmKCFVKXJldHVybiBFLmFwcGx5KGcsQSk7VT1tYSgpO3RyeXt2YXIgamE9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoQSk7Zm9yKEs9MDtLPEEubGVuZ3RoO0srKylpZihBW0tdLiQkc3RhY2tpZnkpe3ZhciBXPW5hKEFbS10uJCRtZW1vcnkubGVuZ3RoKTt0LnNldChBW0tdLiQkbWVtb3J5LFcpO2phW0tdPVd9dmFyIHRhPUUuYXBwbHkoZyxqYSk7Zm9yKEs9CjA7SzxBLmxlbmd0aDtLKyspQVtLXS4kJHN0YWNraWZ5JiZBW0tdLiQkbWVtb3J5LnNldCh0LnN1YmFycmF5KGphW0tdLGphW0tdK0FbS10uJCRtZW1vcnkubGVuZ3RoKSl9ZmluYWxseXtzYShVKX1yZXR1cm4gdGF9ZnVuY3Rpb24gcShFKXt0aGlzLnZhbHVlPUV9ZnVuY3Rpb24gdigpe3kuc3VzcGVuZERyYXdpbmcoKTtnLmdpKCJ3ZWJnbF9jb250ZXh0X2xvc3QiKX1mdW5jdGlvbiB3KCl7cmV0dXJuIEpTT04uc3RyaW5naWZ5KGFyZ3VtZW50cyxDKX1mdW5jdGlvbiBDKEUsQSl7cmV0dXJuIG51bGwhPT1BJiYib2JqZWN0Ij09PXR5cGVvZiBBJiZBLiQkbWVtb3J5PyJzdGFja2lmaWVkIjpBfWZ1bmN0aW9uIEcoKXtpZih5IT09Zy4kJGZhY2FkZSl0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoIm1lbWJlciBjYWxsZWQgYWZ0ZXIgc2h1dGRvd24iKTt9dmFyIHA9IiQkY3MiO2cuJCRlcy5pbml0aWFsaXplTGlicmFyeSgpO3ZhciB5PWcuJCRmYWNhZGUsRj1nLktqP25ldyBnLktqOnZvaWQgMDsKZy5vaj1GO3kuaXNWYWxpZD1mdW5jdGlvbigpe3JldHVybiB5PT09Zy4kJGZhY2FkZX07dmFyIFI9ITE7eS5jYWxsUmVjb3JkPVtdO3kuc3RhcnRSZWNvcmRpbmc9ZnVuY3Rpb24oKXtSPSEwfTt5LnN0b3BSZWNvcmRpbmc9ZnVuY3Rpb24oKXtSPSExfTt5LmxvZ0NhbGxSZWNvcmQ9ZnVuY3Rpb24oKXtmb3IodmFyIEU9eS5jYWxsUmVjb3JkLEE9MDtBPEUubGVuZ3RoOysrQSljb25zb2xlLmxvZyhFW0FdKX07eS5zaHV0RG93bj1mdW5jdGlvbigpe0coKTtSJiZ5LmNhbGxSZWNvcmQucHVzaCgic2h1dERvd24iKTsiJCRjcyI9PT1wJiZnLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKCJ3ZWJnbGNvbnRleHRsb3N0Iix2KTtnLiQkZXMuc2h1dERvd25MaWJyYXJ5KCk7RiYmRi5UaygpO3kuY29udGFpbmVyLmlubmVySFRNTD0iIjtnLiQkZmFjYWRlPXZvaWQgMDtnLm9qPXZvaWQgMDtnLiQkYXZhaWxhYmxlPSEwO2cuJCR3cmFwcGVyLmlubmVySFRNTD0iIn07eS5CeU1lc2hJbnN0YW5jZT0KbmV3IHEoMCk7eS5CeUdyb3VwPW5ldyBxKDEpO3kuQnlFeHBhbmRlZEdyb3VwPW5ldyBxKDIpOyhmdW5jdGlvbigpe2Z1bmN0aW9uIEUobSxyKXtLKFtILlNjc10pO2lmKCFtKXRocm93IG5ldyBXKCJJbnZhbGlkQ29uZmlnIiwiSW52YWxpZCBsb2FkIGNvbmZpZ3VyYXRpb24iKTt2YXIgdSx4LHo9bmV3IFByb21pc2UoZnVuY3Rpb24oWCxiYSl7dT1YO3g9YmF9KTt1YT1ILlNjczt2YXIgTD1uZXcgWE1MSHR0cFJlcXVlc3Q7TC5vcGVuKCJHRVQiLHIpO0wucmVzcG9uc2VUeXBlPSJhcnJheWJ1ZmZlciI7TC5vbmxvYWQ9ZnVuY3Rpb24oKXt0cnl7QShtLG5ldyBVaW50OEFycmF5KHRoaXMucmVzcG9uc2UpKS50aGVuKGZ1bmN0aW9uKFgpe3UoWCl9LGZ1bmN0aW9uKFgpe3goWCl9KX1jYXRjaChYKXt9fTsiZnVuY3Rpb24iPT09dHlwZW9mIG0uWEhSb25wcm9ncmVzcyYmKEwub25wcm9ncmVzcz1tLlhIUm9ucHJvZ3Jlc3MpOyJmdW5jdGlvbiI9PT10eXBlb2YgbS5YSFJvbmVycm9yJiYoTC5vbmVycm9yPQptLlhIUm9uZXJyb3IpO2lmKCJmdW5jdGlvbiI9PT10eXBlb2YgbS5YSFJvbmxvYWRlbmQpe3ZhciBlYT1tLlhIUm9ubG9hZGVuZDtMLm9ubG9hZGVuZD1mdW5jdGlvbihYKXtlYShYLEwuc3RhdHVzLHIpfX1MLnNlbmQoKTtyZXR1cm4gen1mdW5jdGlvbiBBKG0scil7SyhbSC5TY3NdKTtpZighbSl0aHJvdyBuZXcgVygiSW52YWxpZENvbmZpZyIsIkludmFsaWQgbG9hZCBjb25maWd1cmF0aW9uIik7aWYoci5jb25zdHJ1Y3RvciE9PVVpbnQ4QXJyYXkpdGhyb3cgbmV3IFcoIkludmFsaWRDb25maWciLCInYnVmZmVyJyBtdXN0IGJlIGEgVWludDhBcnJheSIpO2lmKDA+PXIuYnl0ZUxlbmd0aCl0aHJvdyBuZXcgVygiRW1wdHlCdWZmZXIiLCInYnVmZmVyJyBoYXMgYSBsZW5ndGggb2YgMCIpO3ZhciB1PWcuJCRlcy5hbGxvY2F0ZVVpbnQ4QnVmZmVyKHIuYnl0ZUxlbmd0aCk7dC5zZXQocix1KTt0cnl7cmV0dXJuIFUobSx1LHIuYnl0ZUxlbmd0aCl9Y2F0Y2goeCl7dGhyb3cgZy4kJGVzLmRlYWxsb2NhdGVVaW50OEJ1ZmZlcih1KSwKeDt9fWZ1bmN0aW9uIFUobSxyLHUpe0soW0guU2NzXSk7dmFyIHg9bS5hdHRhY2hTY29wZSx6PW0uYXR0YWNoTWVhc3VyZW1lbnRVbml0LEw9bS5hdHRhY2hJbnZpc2libHksZWE9bS5yZXNvbHZlT25GdWxseUxvYWRlZCxYPW0uaW5jbHVzaW9uTWF0cml4O209bS5jYW5jZWxVbml0TWF0cml4O3ZhciBiYT0wO2lmKFgpe2lmKFguY29uc3RydWN0b3IhPT1BcnJheSYmWC5jb25zdHJ1Y3RvciE9PUZsb2F0NjRBcnJheSl0aHJvdyBuZXcgVHlwZUVycm9yKCInaW5jbHVzaW9uTWF0cml4JyBpcyBub3QgYW4gQXJyYXkgb3IgRmxvYXQ2NEFycmF5LiIpO2lmKDEyIT09WC5sZW5ndGgpdGhyb3cgbmV3IFR5cGVFcnJvcigiJ2luY2x1c2lvbk1hdHJpeCcgbmVlZHMgdG8gaGF2ZSBleGFjdGx5IDEyIGVsZW1lbnRzLiIpO2JhPWEoWCk7aWYoIWJhKXRocm93IEVycm9yKCJJbnRlcm5hbCBsb2dpYyBlcnJvci4iKTt9dWE9SC5TY3M7dmFyIEJhLHFhO1g9bmV3IFByb21pc2UoZnVuY3Rpb24odmEsCkNhKXtCYT12YTtxYT1mdW5jdGlvbihJYSl7dHJ5e2phKElhKSxDYShudWxsKX1jYXRjaChPYSl7Q2EoT2EpfX19KTt0cnl7Zy4kJGVzLmF0dGFjaFNjc0J1ZmZlcih4LHIsdSxiYSx6LEwsZWEsbSxCYSxxYSl9Y2F0Y2godmEpe3FhKHZhKX1maW5hbGx5e2QoYmEpfXJldHVybiBYfWZ1bmN0aW9uIEsobSl7aWYodWEhPT1ILlVuaW5pdGlhbGl6ZWQpe2lmKHZvaWQgMCE9PW0pZm9yKHZhciByPTA7cjxtLmxlbmd0aDsrK3IpaWYodWE9PT1tW3JdKXJldHVybjt0aHJvdyBuZXcgVygiQWxyZWFkeUNhbGxlZCIsImxvYWQoKSBhbHJlYWR5IGNhbGxlZCB3aXRoIGFuIGluY29tcGF0aWJsZSBzZXNzaW9uIHR5cGUiKTt9fWZ1bmN0aW9uIGphKG0pe3N3aXRjaChtKXtjYXNlIGcuTG9hZFJlc3VsdC5XZWJHTE1pc3Npbmc6dGhyb3cgbmV3IFcoIldlYkdMRXJyb3IiLCJXZWJHTCBpbml0aWFsaXphdGlvbiBmYWlsZWQiKTtjYXNlIGcuTG9hZFJlc3VsdC5TZXNzaW9uQWxyZWFkeVN0YXJ0ZWQ6dGhyb3cgbmV3IFcoIkFscmVhZHlDYWxsZWQiLAoibG9hZCgpIGFscmVhZHkgY2FsbGVkIik7fX1mdW5jdGlvbiBXKG0scil7dGhpcy5jb2RlPW07dGhpcy5tZXNzYWdlPXI7dGhpcy5zdGFjaz1FcnJvcigpLnN0YWNrfWZ1bmN0aW9uIHRhKG0pe3ZhciByPUpTT04ucGFyc2Uod2EobSwwKSk7aWYoInJwYyJpbiByKXtpZihtPXIucnBjLHI9bS5sZW5ndGgvMixyPT09TWF0aC5mbG9vcihyKSl7Zm9yKHZhciB1PW5ldyBVaW50OEFycmF5KHIpLHg9MDt4PHI7Kyt4KXVbeF09cGFyc2VJbnQobS5zdWJzdHIoeCt4LDIpLDE2KTttPXU7cj0obmV3IERhdGFWaWV3KG0uYnVmZmVyKSkuZ2V0VWludDMyKDAsITApO3U9bVs0XTttPW0uc3ViYXJyYXkoNSk7eD1jKG0pO2dbcF0ubm90aWZ5UnBjQ2xpZW50UmVzdWx0KHIsdSx4LG0ubGVuZ3RoKX19ZWxzZSBpZigiZXZlbnQiaW4gcilzd2l0Y2gobT1yLmV2ZW50LHI9ci5kYXRhLG0pe2Nhc2UgImNhbWVyYV9zZXQiOk5iPUFiKHIpO2cuZ2kobSk7YnJlYWs7ZGVmYXVsdDpBcnJheS5pc0FycmF5KHIpPwooci51bnNoaWZ0KG0pLGcuZ2kuYXBwbHkoZyxyKSk6Zy5naShtLHIpfX1mdW5jdGlvbiB5YShtKXt2YXIgcj1jKG0pO2cuJCRlcy5wYXJzZU1ldGFEYXRhKE9iLHIsbS5sZW5ndGgpfWZ1bmN0aW9uIEFhKG0pe209d2EobSwwKTtnLmdpKCJwb3N0X2RyYXdfanNvbiIsbSl9ZnVuY3Rpb24gQWIobSl7dmFyIHI9bmV3IERhO3IucmVzZXQuYXBwbHkocixtKTtyZXR1cm4gcn1mdW5jdGlvbiBQYihtKXtmdW5jdGlvbiByKGthLFlhLFAsZGEpe2lmKDA+ZGF8fGRhPj1ZYS5lbGVtZW50Q291bnQpdGhyb3cgbmV3IFJhbmdlRXJyb3IoImludmFsaWQgZWxlbWVudCBpbmRleCIpO3ZhciBwYT17dmVydGV4Q291bnQ6ZWFba2FdWzMqZGErMV0sYml0czplYVtrYV1bMypkYSsyXSxpdGVyYXRlOmZ1bmN0aW9uKEphKXtyZXR1cm4geChrYSxZYSxQLGRhLHRoaXMsSmEpfX07InVuZGVmaW5lZCIhPT10eXBlb2YgU3ltYm9sJiYidW5kZWZpbmVkIiE9PXR5cGVvZiBTeW1ib2wuaXRlcmF0b3ImJihwYVtTeW1ib2wuaXRlcmF0b3JdPQp1KTtyZXR1cm4gcGF9ZnVuY3Rpb24gdSgpe3JldHVybiB0aGlzLml0ZXJhdGUoITApfWZ1bmN0aW9uIHgoa2EsWWEsUCxkYSxwYSxKYSl7ZnVuY3Rpb24gcWIoKXt2YXIgcmE9e3Bvc2l0aW9uOnZvaWQgMCxub3JtYWw6dm9pZCAwLFVWOnZvaWQgMCxSR0JBOnZvaWQgMH07KytaYTtmb3IodmFyIGxhPTA7bGE8aGIubGVuZ3RoOysrbGEpaGJbbGFdKHJhKTtyZXR1cm4gcmF9aWYoIm51bWJlciI9PT10eXBlb2YgZGEpdmFyIEtjPVArZWFba2FdWzMqZGFdLExjPXBhLnZlcnRleENvdW50O2Vsc2UgS2M9UCxMYz1ZYS52ZXJ0ZXhDb3VudDt2YXIgd2Q9S2MrTGMsWmE9S2MsaGI9W107YmE/aGIucHVzaChmdW5jdGlvbihyYSl7dmFyIGxhPVt6W0thXSx6W0thKzFdLHpbS2ErMl1dO3JhLnBvc2l0aW9uPVtiYVswXSpsYVswXStiYVs0XSpsYVsxXStiYVs4XSpsYVsyXStiYVsxMl0sYmFbMV0qbGFbMF0rYmFbNV0qbGFbMV0rYmFbOV0qbGFbMl0rYmFbMTNdLGJhWzJdKmxhWzBdK2JhWzZdKmxhWzFdKwpiYVsxMF0qbGFbMl0rYmFbMTRdXX0pOmhiLnB1c2goZnVuY3Rpb24ocmEpe3JhLnBvc2l0aW9uPVt6W0thXSx6W0thKzFdLHpbS2ErMl1dfSk7WWEuaGFzTm9ybWFscyYmaGIucHVzaChmdW5jdGlvbihyYSl7dmFyIGxhPUthK0JhO3JhLm5vcm1hbD1beltsYV0seltsYSsxXSx6W2xhKzJdXX0pO1lhLmhhc1VWcyYmaGIucHVzaChmdW5jdGlvbihyYSl7dmFyIGxhPUthK3FhO3JhLlVWPVt6W2xhXSx6W2xhKzFdXX0pO2lmKFlhLmhhc1JHQkFzKXt2YXIgTWM9bmV3IFVpbnQ4QXJyYXkoei5idWZmZXIpO2hiLnB1c2goZnVuY3Rpb24ocmEpe3ZhciBsYT1LYSt2YTw8MjtyYS5SR0JBPVtNY1tsYV0sTWNbbGErMV0sTWNbbGErMl0sTWNbbGErM11dfSl9aWYoTCl7dmFyIEthPUxbWmFdKlg7aGIucHVzaChmdW5jdGlvbigpe0thPUxbWmFdKlh9KX1lbHNlIEthPVphKlgsaGIucHVzaChmdW5jdGlvbigpe0thKz1YfSk7cmV0dXJue2RvbmU6ZnVuY3Rpb24oKXtyZXR1cm4gWmE+PXdkfSxuZXh0OkphPwpmdW5jdGlvbigpe3JldHVybiBaYTx3ZD97dmFsdWU6cWIoKSxkb25lOiExfTp7ZG9uZTohMH19OmZ1bmN0aW9uKCl7aWYoWmE8d2QpcmV0dXJuIHFiKCl9LGdvVG86ZnVuY3Rpb24ocmEpezA+cmE/cmE9MDpyYT49TGMmJihyYT1MYyk7WmE9S2MrcmE7S2E9TD9MW1phXSpYOlphKlh9fX12YXIgej1tLnZlcnRpY2VzLEw9bS5pbmRpY2VzLGVhPW0uZWxlbWVudHMsWD1tLnN0cmlkZSxiYT1tLmR1cGxpY2F0ZU1hdHJpeCxCYT1tLm5vcm1hbE9mZnNldCxxYT1tLlVWT2Zmc2V0LHZhPW0uUkdCQTMyT2Zmc2V0LENhPW0uZmFjZVZlcnRleENvdW50LElhPUNhK20ubGluZVZlcnRleENvdW50LE9hPXtmYWNlczp7dmVydGV4Q291bnQ6bS5mYWNlVmVydGV4Q291bnQsaGFzTm9ybWFsczptLmZhY2VOb3JtYWxzPyEwOiExLGhhc1VWczptLmZhY2VVVnM/ITA6ITEsaGFzUkdCQXM6bS5mYWNlUkdCQTMycz8hMDohMSxlbGVtZW50Q291bnQ6ZWFbMF0/ZWFbMF0ubGVuZ3RoLzM6MCxpdGVyYXRlOmZ1bmN0aW9uKGthKXtyZXR1cm4geCgwLAp0aGlzLDAsdm9pZCAwLHZvaWQgMCxrYSl9LGVsZW1lbnQ6ZnVuY3Rpb24oa2Epe3JldHVybiByKDAsdGhpcywwLGthKX19LGxpbmVzOnt2ZXJ0ZXhDb3VudDptLmxpbmVWZXJ0ZXhDb3VudCxoYXNOb3JtYWxzOm0ubGluZU5vcm1hbHM/ITA6ITEsaGFzVVZzOm0ubGluZVVWcz8hMDohMSxoYXNSR0JBczptLmxpbmVSR0JBMzJzPyEwOiExLGVsZW1lbnRDb3VudDplYVsxXT9lYVsxXS5sZW5ndGgvMzowLGl0ZXJhdGU6ZnVuY3Rpb24oa2Epe3JldHVybiB4KDEsdGhpcyxDYSx2b2lkIDAsdm9pZCAwLGthKX0sZWxlbWVudDpmdW5jdGlvbihrYSl7cmV0dXJuIHIoMSx0aGlzLENhLGthKX19LHBvaW50czp7dmVydGV4Q291bnQ6bS5wb2ludFZlcnRleENvdW50LGhhc05vcm1hbHM6bS5wb2ludE5vcm1hbHM/ITA6ITEsaGFzVVZzOm0ucG9pbnRVVnM/ITA6ITEsaGFzUkdCQXM6bS5wb2ludFJHQkEzMnM/ITA6ITEsZWxlbWVudENvdW50OmVhWzJdP2VhWzJdLmxlbmd0aC8zOjAsaXRlcmF0ZTpmdW5jdGlvbihrYSl7cmV0dXJuIHgoMiwKdGhpcyxJYSx2b2lkIDAsdm9pZCAwLGthKX0sZWxlbWVudDpmdW5jdGlvbihrYSl7cmV0dXJuIHIoMix0aGlzLElhLGthKX19fTsidW5kZWZpbmVkIiE9PXR5cGVvZiBTeW1ib2wmJiJ1bmRlZmluZWQiIT09dHlwZW9mIFN5bWJvbC5pdGVyYXRvciYmKE9hLmZhY2VzW1N5bWJvbC5pdGVyYXRvcl09dSxPYS5saW5lc1tTeW1ib2wuaXRlcmF0b3JdPXUsT2EucG9pbnRzW1N5bWJvbC5pdGVyYXRvcl09dSk7bT1tLmZvcndhcmQ7Zm9yKGxldCBrYSBpbiBtKW0uaGFzT3duUHJvcGVydHkoa2EpJiYoT2Fba2FdPW1ba2FdKTtyZXR1cm4gT2F9ZnVuY3Rpb24gT2IobSxyLHUpe3ZhciB4PSRhW21dO3h8fCh4PSRhW21dPXt9KTt4W3JdPXU7Zy5naSgibWV0YV9kYXRhIixtLHIsdSl9ZnVuY3Rpb24gb2EobSxyKXtpZigiJCRjcyI9PT1wKXJldHVybiBaLmdldE1ldGFEYXRhKG0pO2FiKG0pO2Zvcih2YXIgdT1bXSx4PTA7eDxtLmxlbmd0aDt4Kz0yKXt2YXIgej1tW3hdLEw9bVt4KzFdLGVhPSRhW3pdOwp2b2lkIDA9PT0oZWE/ZWFbTF06dm9pZCAwKSYmdS5wdXNoKHosTCl9aWYoMD09PXUubGVuZ3RoKXtyPVtdO2Zvcih4PTA7eDxtLmxlbmd0aDt4Kz0yKXo9bVt4XSxMPW1beCsxXSxyLnB1c2goJGFbel1bTF0pO3JldHVybiBQcm9taXNlLnJlc29sdmUocil9cmV0dXJuIHI/KHg9bmV3IFMoImdldE1ldGFEYXRhIix1KSxQcm9taXNlLnJlamVjdCh4KSk6Wi5yZXF1ZXN0TWV0YURhdGEodSkudGhlbihmdW5jdGlvbigpe0coKTtyZXR1cm4gb2EobSwhMCl9KX1mdW5jdGlvbiBUYSgpeyIkJGNzIj09PXAmJmcuJCRlcy5kaXNjb25uZWN0TmV0d29yaygpfWZ1bmN0aW9uIGsobSxyLHUpe2lmKCJmdW5jdGlvbiI9PT10eXBlb2YgdSlpYihtLHIsdSk7ZWxzZXt1PXV8fDA7dmFyIHg9InN0cmluZyI9PT10eXBlb2YgbT9tKyJfIityOnIsejtnLiQkZXNbeF0/ej1nLiQkZXNbeF06ej1mdW5jdGlvbigpe3JldHVybiBnW3BdW3hdLmFwcGx5KGcsYXJndW1lbnRzKX07dmFyIEw9ejt1JjEmJihMPWZ1bmN0aW9uKFApe3JldHVybiAwPT0KUD9nLiQkY3NbeF0uYXBwbHkoZyxhcmd1bWVudHMpOnouYXBwbHkoZyxhcmd1bWVudHMpfSk7dmFyIGVhPUw7dSYyJiYoZWE9ZnVuY3Rpb24oUCl7Im51bWJlciI9PT10eXBlb2YgUCYmKFA9W1BdKTt2YXIgZGE9YihQKTtpZighZGEpdGhyb3cgbmV3IFR5cGVFcnJvcigiYGtleXMnIGlzIG5vdCBhbiBBcnJheSBvciBVaW50MzJBcnJheSIpO3ZhciBwYT1BcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsMSk7cGEudW5zaGlmdChkYSxQLmxlbmd0aCk7cmV0dXJuIEwuYXBwbHkoZyxwYSl9KTt2YXIgWD1lYTt1JjQmJihYPWZ1bmN0aW9uKFApe2FiKFApO3ZhciBkYT1iKFApO2lmKCFkYSl0aHJvdyBuZXcgVHlwZUVycm9yKCJgaWRzJyBpcyBub3QgYW4gQXJyYXkgb3IgVWludDMyQXJyYXkuIik7dmFyIHBhPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywxKTtwYS51bnNoaWZ0KGRhLFAubGVuZ3RoPj4xKTtyZXR1cm4gZWEuYXBwbHkoZyxwYSl9KTt2YXIgYmE9Clg7dSY4JiYoYmE9ZnVuY3Rpb24oUCl7ND09PVAubGVuZ3RoJiYibnVtYmVyIj09PXR5cGVvZiBQWzBdJiYoUD1bUF0pO3ZhciBkYT1QLHBhPWcuJCRlcy5hbGxvY2F0ZVVpbnQ4QnVmZmVyKDMyKmRhLmxlbmd0aCk7aWYocGEpZm9yKHZhciBKYT0wO0phPGRhLmxlbmd0aDsrK0phKXt2YXIgcWI9ZGFbSmFdO2lmKDQhPT1xYi5sZW5ndGgpdGhyb3cgRXJyb3IoIlBsYW5lcyBhcmUgZXhwZWN0ZWQgYmUgZXhhY3RseSA0IG51bWJlcnMuIik7aGEuc2V0KHFiLChwYT4+MykrNCpKYSl9ZGE9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpO2RhLnVuc2hpZnQocGEsUC5sZW5ndGgpO3JldHVybiBYLmFwcGx5KGcsZGEpfSk7dmFyIEJhPWJhO3UmMTYmJihCYT1mdW5jdGlvbihQKXszPT09UC5sZW5ndGgmJiJudW1iZXIiPT09dHlwZW9mIFBbMF0mJihQPVtQXSk7dmFyIGRhPVAscGE9Zy4kJGVzLmFsbG9jYXRlVWludDhCdWZmZXIoMjQqZGEubGVuZ3RoKTtpZihwYSlmb3IodmFyIEphPQowO0phPGRhLmxlbmd0aDsrK0phKXt2YXIgcWI9ZGFbSmFdO2lmKDMhPT1xYi5sZW5ndGgpdGhyb3cgRXJyb3IoIlBvaW50cyBhcmUgZXhwZWN0ZWQgYmUgZXhhY3RseSAzIGNvbXBvbmVudHMuIik7aGEuc2V0KHFiLChwYT4+MykrMypKYSl9ZGE9QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLDEpO2RhLnVuc2hpZnQocGEsUC5sZW5ndGgpO3JldHVybiBiYS5hcHBseShnLGRhKX0pO3ZhciBxYT1CYTt1JjMyJiYocWE9ZShiYSkpO3ZhciB2YT1xYTt1JjY0JiYodmE9ZnVuY3Rpb24oKXtjb25zb2xlLmxvZygiV0FSTklORzogVXNpbmcgZGVwcmVjYXRlZCBmdW5jdGlvbiBgIisoInN0cmluZyI9PT10eXBlb2YgbT9tKyIuIityOnIpKyInIik7cmV0dXJuIHFhLmFwcGx5KGcsYXJndW1lbnRzKX0pO3ZhciBDYT12YTt1JjEyOCYmKENhPWZ1bmN0aW9uKCl7dmFyIFA9YXJndW1lbnRzLGRhPVBbUC5sZW5ndGgtMV07ZGEuY29uc3RydWN0b3I9PT1xP1BbUC5sZW5ndGgtMV09CmRhLnZhbHVlOihQPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKFApLFAucHVzaCgwKSk7cmV0dXJuIHZhLmFwcGx5KGcsUCl9KTt2YXIgSWE9Q2E7dSYyNTYmJihJYT1mdW5jdGlvbigpe3ZhciBQPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKGRhLHBhKXtQLnB1c2goZGEpO1AucHVzaChZKHgscGEpKTtDYS5hcHBseShnLFApfSl9KTt2YXIgT2E9SWE7dSY1MTImJihPYT11JjI1Nj9mdW5jdGlvbigpe3JldHVybiBJYS5hcHBseShnLGFyZ3VtZW50cykudGhlbihmdW5jdGlvbihQKXtHKCk7cmV0dXJuIERhLmNvcHkoUCl9KX06ZnVuY3Rpb24oKXtyZXR1cm4gRGEuY29weShJYS5hcHBseShnLGFyZ3VtZW50cykpfSk7dmFyIGthPU9hO3UmMTAyNCYmKGthPXUmMjU2P2Z1bmN0aW9uKCl7cmV0dXJuIE9hLmFwcGx5KGcsYXJndW1lbnRzKS50aGVuKEJiKX06ZnVuY3Rpb24oKXtyZXR1cm4gQmIoT2EuYXBwbHkoZywKYXJndW1lbnRzKSl9KTt2YXIgWWE9a2E7dSYyMDQ4JiYoWWE9dSYyNTY/ZnVuY3Rpb24oKXtyZXR1cm4ga2EuYXBwbHkoZyxhcmd1bWVudHMpLnRoZW4oQ2IpfTpmdW5jdGlvbigpe3JldHVybiBDYihrYS5hcHBseShnLGFyZ3VtZW50cykpfSk7aWIobSxyLGZ1bmN0aW9uKCl7RygpO1ImJnkuY2FsbFJlY29yZC5wdXNoKHIrIiAiK3coYXJndW1lbnRzKSk7cmV0dXJuIFlhLmFwcGx5KGcsYXJndW1lbnRzKX0pfX1mdW5jdGlvbiBpYihtLHIsdSl7dmFyIHg9ImZ1bmN0aW9uIj09PXR5cGVvZiB1P2Z1bmN0aW9uKCl7RygpO1ImJnkuY2FsbFJlY29yZC5wdXNoKHIrIiAiK3coYXJndW1lbnRzKSk7cmV0dXJuIHUuYXBwbHkoZyxhcmd1bWVudHMpfTp1O251bGw9PT1tP3lbcl09eDoic3RyaW5nIj09PXR5cGVvZiBtP3lbbV1bcl09eDptW3JdPXh9ZnVuY3Rpb24gQ2IobSl7Zm9yKHZhciByPTA7cjxtLmxlbmd0aDsrK3IpMD5tW3JdWzBdJiYobVtyXT1udWxsKTtyZXR1cm4gbX1mdW5jdGlvbiBCYihtKXtmb3IodmFyIHI9CjA7cjxtLmxlbmd0aDsrK3IpMD5tW3JdJiYobVtyXT1udWxsKTtyZXR1cm4gbX1mdW5jdGlvbiBZKG0scil7cmV0dXJuIGZ1bmN0aW9uKHUpe3U9bmV3IFMobSx1KTtyKHUpfX1mdW5jdGlvbiBTKG0scil7dGhpcy5zY0Z1bmN0aW9uPW07dGhpcy5kYXRhPXJ9ZnVuY3Rpb24gYWIobSl7aWYoMCE9PShtLmxlbmd0aCYxKSl0aHJvdyBuZXcgVHlwZUVycm9yKCJgaWRzLmxlbmd0aCcgbXVzdCBiZSBkaXZpc2libGUgYnkgdHdvLiAoQW4gSWQgaXMgYSBwYWlyIG9mIGtleXMuKSIpO315LkNyZWF0ZUltYWdlRXJyb3I9Zy5DcmVhdGVJbWFnZUVycm9yO3kuQ3JlYXRlTWVzaEluc3RhbmNlRXJyb3JUeXBlPWcuQ3JlYXRlTWVzaEluc3RhbmNlRXJyb3JUeXBlO3kuQ3V0dGluZ1NlY3Rpb25FcnJvcj1nLkN1dHRpbmdTZWN0aW9uRXJyb3I7eS5NZXNoRGF0YUdldERhdGFFcnJvcj1nLk1lc2hEYXRhR2V0RGF0YUVycm9yO3kuTWVzaERhdGFSZXBsYWNlRXJyb3I9Zy5NZXNoRGF0YVJlcGxhY2VFcnJvcjsKeS5TZXRNYXRyaXhFcnJvclR5cGU9Zy5TZXRNYXRyaXhFcnJvclR5cGU7eS5TZXRUZXh0dXJlRXJyb3JUeXBlPWcuU2V0VGV4dHVyZUVycm9yVHlwZTt2YXIgRGE9ZigiJCRlcyIsIkNhbWVyYSIsInJlc2V0IHZpZXdNYXRyaXggcHJvamVjdGlvbk1hdHJpeCBmdWxsTWF0cml4IHByb2plY3Rpb24gc2V0UHJvamVjdGlvbiB1cFZlY3RvciBzZXRVcFZlY3RvciBwb3NpdGlvbiBzZXRQb3NpdGlvbiB0YXJnZXQgc2V0VGFyZ2V0IG5lYXJMaW1pdCBzZXROZWFyTGltaXQgZmllbGRXaWR0aCBmaWVsZEhlaWdodCBzZXRGaWVsZCBzZXRGaWVsZCBzZXRGaWVsZEJ5QW5nbGVzIHNldEZpZWxkQnlBbmdsZXMgZG9sbHkgcGFuIHJvbGwgem9vbSBvcmJpdCBheGlzT3JiaXQgcmVsYXRpdmVPcmJpdCB1bnByb2plY3QiLnNwbGl0KCIgIikpO1MucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2NGdW5jdGlvbisiOiAiK3RoaXMuZGF0YX07dmFyIFo9e30sJGE9e30sTmM9Cm5ldyBVaW50OEFycmF5KDApLE5iPW5ldyBEYTtrKG51bGwsImFkZEN1dHRpbmdTZWN0aW9uIiwyNjQpO2sobnVsbCwiYWRkTGlnaHQiLDI1Nik7ayhudWxsLCJhZHZhbmNlVm9sdW1lU2VsZWN0aW9uIiwyNTYpO2sobnVsbCwiYXR0YWNoTW9kZWxzIixmdW5jdGlvbihtLHIsdSx4KXtmb3IodmFyIHo9W10sTD1bXSxlYT0wO2VhPHIubGVuZ3RoOysrZWEpe3ZhciBYPXJbZWFdO2lmKDIhPT1YLmxlbmd0aCl0aHJvdyBuZXcgVHlwZUVycm9yKCJFeHBlY3RpbmcgW25hbWUsIG1hdHJpeF0gcGFpci4iKTt2YXIgYmE9WFswXTtpZigic3RyaW5nIiE9PXR5cGVvZiBiYSl0aHJvdyBuZXcgVHlwZUVycm9yKCJOYW1lIGlzIG5vdCBhIHN0cmluZy4iKTtYPVhbMV07aWYoWC5jb25zdHJ1Y3RvciE9PUFycmF5JiZYLmNvbnN0cnVjdG9yIT09RmxvYXQ2NEFycmF5KXRocm93IG5ldyBUeXBlRXJyb3IoIk1hdHJpeCBpcyBub3QgYW4gQXJyYXkgb3IgRmxvYXQ2NEFycmF5LiIpO2lmKDEyIT09WC5sZW5ndGgpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW5jbHVzaW9uIG1hdHJpeCBuZWVkcyB0byBoYXZlIGV4YWN0bHkgMTIgZWxlbWVudHMuIik7CmJhPXVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChiYSkpO2Zvcih2YXIgQmE9MDtCYTxiYS5sZW5ndGg7KytCYSl6LnB1c2goYmEuY2hhckNvZGVBdChCYSkpO3oucHVzaCgwKTtBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShMLFgpfXZhciBxYT0wLHZhPTA7cWE9Yyh6KTtpZighcWEpdGhyb3cgZChxYSksZCh2YSksRXJyb3IoIkludGVybmFsIGxvZ2ljIGVycm9yLiIpO3ZhPWEoTCk7aWYoIXZhKXRocm93IGQocWEpLGQodmEpLEVycm9yKCJJbnRlcm5hbCBsb2dpYyBlcnJvci4iKTtyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oQ2EsSWEpe2dbcF0uYXR0YWNoTW9kZWxzKHFhLHoubGVuZ3RoLHZhLEwubGVuZ3RoLG0sdSx4LENhLFkoImF0dGFjaE1vZGVscyIsSWEpKX0pfSk7ayhudWxsLCJhdHRhY2hTY3NNb2RlbEJ5S2V5IixmdW5jdGlvbihtLHIsdSx4LHope3ZhciBMPVtdO2lmKHIuY29uc3RydWN0b3IhPT1BcnJheSYmci5jb25zdHJ1Y3RvciE9PUZsb2F0NjRBcnJheSl0aHJvdyBuZXcgVHlwZUVycm9yKCJNYXRyaXggaXMgbm90IGFuIEFycmF5IG9yIEZsb2F0NjRBcnJheS4iKTsKaWYoMTIhPT1yLmxlbmd0aCl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbmNsdXNpb24gbWF0cml4IG5lZWRzIHRvIGhhdmUgZXhhY3RseSAxMiBlbGVtZW50cy4iKTtBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShMLHIpO3I9YShMKTtpZighcil0aHJvdyBkKHIpLEVycm9yKCJJbnRlcm5hbCBsb2dpYyBlcnJvci4iKTtyZXR1cm4gZy4kJGVzLmF0dGFjaFNjc01vZGVsQnlLZXkocixMLmxlbmd0aCxtLHUseCx6KX0pO2sobnVsbCwiYmVnaW5Db252ZXhQb2x5aGVkcm9uU2VsZWN0aW9uIiwyNjQpO2sobnVsbCwiYmVnaW5SYXlEcmlsbFNlbGVjdGlvbiIsMjU2KTtrKG51bGwsImJlZ2luU2NyZWVuQXJlYVNlbGVjdGlvbiIsMjU2KTtrKG51bGwsImJlZ2luU3BoZXJlU2VsZWN0aW9uIiwyNTYpO2sobnVsbCwiY2xlYXJMaWdodHMiKTtrKG51bGwsImNyZWF0ZUZsb29ycGxhbk1lc2giLDM4OCk7ayhudWxsLCJjdXR0aW5nU2VjdGlvbkxpbWl0cyIpO2sobnVsbCwiZGVtYW5kTWVzaEluc3RhbmNlcyIsCjEzMik7ayhudWxsLCJkZXRhY2hJbmNsdXNpb25zIiwyNTgpO2sobnVsbCwiZGlzYWJsZUNhcHBpbmciKTtrKG51bGwsImRpc2Nvbm5lY3ROZXR3b3JrIixUYSk7ayhudWxsLCJlbmFibGVDYXBwaW5nIik7ayhudWxsLCJlbmRDb21wYXJpc29uIik7ayhudWxsLCJlbmRWb2x1bWVTZWxlY3Rpb24iKTtrKG51bGwsImV4cGxvZGUiKTtrKG51bGwsImV4cG9ydFRvU3ZnIiwyNTYpO2sobnVsbCwiYmVnaW5FeHBvcnRUb1N2ZyIsMjU2KTtrKG51bGwsImFkdmFuY2VFeHBvcnRUb1N2ZyIsMjU2KTtrKG51bGwsImZsdXNoTWV0YURhdGFDYWNoZSIsZnVuY3Rpb24oKXsiJCRzcyI9PT1wJiYoJGE9e30pfSk7ayhudWxsLCJnZXRBbWJpZW50T2NjbHVzaW9uRW5hYmxlZCIsMjU2KTtrKG51bGwsImdldEFtYmllbnRPY2NsdXNpb25SYWRpdXMiLDI1Nik7ayhudWxsLCJnZXRCYWNrRmFjZXNWaXNpYmxlIiwyNTYpO2sobnVsbCwiZ2V0QmFja2dyb3VuZEdyYWRpZW50IiwyNTYpO2sobnVsbCwiZ2V0Q2FtZXJhIiwKZnVuY3Rpb24oKXtyZXR1cm4iJCRzcyI9PT1wP0RhLmNsb25lKE5iKTpaLmdldENhbWVyYSgpfSk7ayhudWxsLCJnZXRDYW1lcmFQcm9taXNlIiw3NjgpO2sobnVsbCwiZ2V0Q2FwcGVkSW5zdGFuY2VzIiwyNTYpO2sobnVsbCwiZ2V0Q3V0dGluZ1NlY3Rpb25zIiwyNTgpO2sobnVsbCwiZ2V0RGVmYXVsdERlcHRoUmFuZ2UiLDI1Nik7ayhudWxsLCJnZXRFbGVtZW50Q291bnQiLDI1Nik7ayhudWxsLCJnZXRFeWVEb21lTGlnaHRpbmdCbHVyRWRnZURpc3RhbmNlIiwyNTYpO2sobnVsbCwiZ2V0RXllRG9tZUxpZ2h0aW5nQmx1ckludGVydmFsIiwyNTYpO2sobnVsbCwiZ2V0RXllRG9tZUxpZ2h0aW5nQmx1clNhbXBsZXMiLDI1Nik7ayhudWxsLCJnZXRFeWVEb21lTGlnaHRpbmdFbmFibGVkIiwyNTYpO2sobnVsbCwiZ2V0RXllRG9tZUxpZ2h0aW5nT3BhY2l0eSIsMjU2KTtrKG51bGwsImdldEV5ZURvbWVMaWdodGluZ1NoYWRpbmdFZGdlRGlzdGFuY2UiLDI1Nik7ayhudWxsLCJnZXRGYWNlc1Zpc2libGUiLAoyNTYpO2sobnVsbCwiZ2V0RmFjZVdpbmRpbmdGbGlwcGVkIiwyNTYpO2sobnVsbCwiZ2V0RnJvbnRGYWNlc1Zpc2libGUiLDI1Nik7ayhudWxsLCJnZXRJbnRlcmFjdGl2ZURyYXdMaW1pdEluY3JlYXNlRW5hYmxlZCIsMjU2KTtrKG51bGwsImdldExpZ2h0S2V5cyIsMjU2KTtrKG51bGwsImdldExpZ2h0IiwyNTYpO2sobnVsbCwiZ2V0TGluZXNWaXNpYmxlIiwyNTYpO2sobnVsbCwiZ2V0TG9vc2VCb3VuZGluZyIsMjU2KTtrKG51bGwsImdldE1ldGFEYXRhIixvYSk7ayhudWxsLCJnZXRNaW5GcmFtZVJhdGUiLDI1Nik7ayhudWxsLCJnZXROZXR3b3JrVmVyc2lvbiIpO2sobnVsbCwiZ2V0UG9pbnRTaGFwZSIsMjU2KTtrKG51bGwsImdldFBvaW50U2l6ZSIsMjU2KTtrKG51bGwsImdldFBvaW50U2l6ZVVuaXQiLDI1Nik7ayhudWxsLCJnZXRQb2ludHNWaXNpYmxlIiwyNTYpO2sobnVsbCwiZ2V0U3RhdGlzdGljcyIsMjU2KTtrKG51bGwsImdldFN0cmVhbWVkQm91bmRpbmciLDI1Nik7CmsobnVsbCwiZ2V0U3RyZWFtVmVyc2lvbiIpO2sobnVsbCwiZ2V0VHJpYW5nbGVDb3VudCIsMjU2KTtrKG51bGwsIm1hcmtBbGxNZXNoSW5zdGFuY2VzSW50ZXJlc3RpbmciKTtrKG51bGwsIm1hcmtDYW1lcmFBc0VtcHR5Iik7ayhudWxsLCJtZXNoSW5zdGFuY2VLZXlJbmZvIiwyNTcpO2sobnVsbCwibWV0YURhdGFLZXlJbmZvIiwyNTcpO2sobnVsbCwibW9kZWxLZXlzRnJvbUluY2x1c2lvbktleXMiLDI1OCk7ayhudWxsLCJvblJlc2l6ZSIsZnVuY3Rpb24oKXt2YXIgbT15LmFsbG93SGlnaERwaT93aW5kb3cuZGV2aWNlUGl4ZWxSYXRpb3x8MToxLHI9eS5jb250YWluZXIsdT1yLmNsaWVudFdpZHRoLHg9ci5jbGllbnRIZWlnaHQ7cj11Km07bSo9eDtpZigiJCRzcyI9PT1wKUYuTGsocixtLHUseCk7ZWxzZXt2YXIgej1nLiQkZXMubWF4RnJhbWVCdWZmZXJTaXplKCk7aWYoMD49eilyPXUsbT14O2Vsc2V7aWYocj56fHxtPnopcj11LG09eDtpZihyPnp8fG0+eilyPm0/KG09bS9yKgp6LHI9eik6KHI9ci9tKnosbT16KX19Zy4kJGNzLnNldFNjcmVlbkRpbWVuc2lvbnMocixtLHUseCk7IiQkY3MiPT09cCYmKHU9Zy5jYW52YXMsdS53aWR0aD1yLHUuaGVpZ2h0PW0seS5xdWV1ZVJlZHJhdygpKX0pO2sobnVsbCwicGF1c2VDYXBwaW5nIik7ayhudWxsLCJwcmltYXJ5TW9kZWxLZXkiLDI1Nik7ayhudWxsLCJxdWV1ZVJlZHJhdyIpO2sobnVsbCwicmVnaXN0ZXJCaW1JbnN0YW5jZXMiLDQpO2sobnVsbCwicmVtb3ZlQWxsQ3V0dGluZ1NlY3Rpb25zIik7ayhudWxsLCJyZW1vdmVDdXR0aW5nU2VjdGlvbnMiLDI1OCk7ayhudWxsLCJyZW1vdmVMaWdodCIpO2sobnVsbCwicmVwbGFjZUN1dHRpbmdTZWN0aW9uIiwyNjQpO2sobnVsbCwicmVxdWVzdEdyb3VwcyIsMjYwKTtrKG51bGwsInJlcXVlc3RJbWFnZXMiLDI2MCk7ayhudWxsLCJyZXF1ZXN0TWVzaEluc3RhbmNlcyIsMjYwKTtrKG51bGwsInJlcXVlc3RNZXNoSW5zdGFuY2VzQnlHcm91cCIsMjYwKTtrKG51bGwsInJlc2V0RXhwbG9kZSIpOwprKG51bGwsInJlc2V0VG9FbXB0eSIsZnVuY3Rpb24obSxyKXt2YXIgdT1iKHIpO2lmKCF1KXRocm93IG5ldyBUeXBlRXJyb3IoImBtZXNoS2V5cycgaXMgbm90IGFuIEFycmF5IG9yIFVpbnQzMkFycmF5Iik7cmV0dXJuIFoucmVzZXRUb0VtcHR5KG0sdSxyLmxlbmd0aCl9KTtrKG51bGwsInJlc3VtZUNhcHBpbmciKTtrKG51bGwsInJlc3VtZURyYXdpbmciKTtrKG51bGwsInNjcmVlblNlbGVjdEJ5UmF5IiwyNTYpO2sobnVsbCwic2VydmVyU2lkZVJlbmRlcmluZyIsZnVuY3Rpb24oKXtyZXR1cm4iJCRzcyI9PT1wfSk7ayhudWxsLCJzZXRBbWJpZW50TGlnaHRDb2xvciIpO2sobnVsbCwic2V0QW1iaWVudE9jY2x1c2lvbkJpYXMiKTtrKG51bGwsInNldEFtYmllbnRPY2NsdXNpb25CbHVySW50ZXJ2YWwiKTtrKG51bGwsInNldEFtYmllbnRPY2NsdXNpb25CbHVyU2FtcGxlcyIpO2sobnVsbCwic2V0QW1iaWVudE9jY2x1c2lvbkNvbnRyYXN0Iik7ayhudWxsLCJzZXRBbWJpZW50T2NjbHVzaW9uRWRnZURpc3RhbmNlIik7CmsobnVsbCwic2V0QW1iaWVudE9jY2x1c2lvbkVuYWJsZWQiKTtrKG51bGwsInNldEFtYmllbnRPY2NsdXNpb25JbnRlbnNpdHkiKTtrKG51bGwsInNldEFtYmllbnRPY2NsdXNpb25Ob2lzZVNpemUiKTtrKG51bGwsInNldEFtYmllbnRPY2NsdXNpb25PcGFjaXR5Iik7ayhudWxsLCJzZXRBbWJpZW50T2NjbHVzaW9uUmFkaXVzIik7ayhudWxsLCJzZXRBbWJpZW50T2NjbHVzaW9uU2FtcGxlcyIpO2sobnVsbCwic2V0QW50aUFsaWFzaW5nTW9kZSIpO2sobnVsbCwic2V0QmFja0ZhY2VzVmlzaWJsZSIpO2sobnVsbCwic2V0QmFja2dyb3VuZENvbG9yIik7ayhudWxsLCJzZXRCYWNrZ3JvdW5kR3JhZGllbnQiKTtrKG51bGwsInNldEJsb29tQmx1ckludGVydmFsIik7ayhudWxsLCJzZXRCbG9vbUJsdXJTYW1wbGVzIik7ayhudWxsLCJzZXRCbG9vbUVuYWJsZWQiKTtrKG51bGwsInNldEJsb29tSW50ZW5zaXR5Iik7ayhudWxsLCJzZXRCbG9vbUludGVuc2l0eVNjYWxlIik7ayhudWxsLAoic2V0Qmxvb21MYXllckNvdW50Iik7ayhudWxsLCJzZXRCbG9vbVRocmVzaG9sZCIpO2sobnVsbCwic2V0Qmxvb21UaHJlc2hvbGRSYW1wV2lkdGgiKTtrKG51bGwsInNldEJvdW5kaW5nUHJldmlld1VuZGVyZHJhd0NvbG9yIik7ayhudWxsLCJzZXRCb3VuZGluZ1ByZXZpZXdUZXN0ZWRDb2xvciIpO2sobnVsbCwic2V0Qm91bmRpbmdQcmV2aWV3RWplY3RlZENvbG9yIik7ayhudWxsLCJzZXRCb3VuZGluZ1ByZXZpZXdDb2xvciIpO2sobnVsbCwic2V0Qm91bmRpbmdQcmV2aWV3VW5kZXJkcmF3IiwxNik7ayhudWxsLCJzZXRCb3VuZGluZ1ByZXZpZXdUZXN0ZWQiLDE2KTtrKG51bGwsInNldEJvdW5kaW5nUHJldmlld0VqZWN0ZWQiLDE2KTtrKG51bGwsInNldEJvdW5kaW5nRGVidWdMZXZlbCIpO2sobnVsbCwic2V0Q2FtZXJhIixmdW5jdGlvbihtKXtEYS5hc3NpZ24oTmIsbSk7Wi5zZXRDYW1lcmEobSl9KTtrKG51bGwsInNldENhcHBpbmdJZGxlSG9va0VuYWJsZWQiLDI1Nik7ayhudWxsLAoic2V0Q2x1bXBpbmdFbmFibGVkIik7ayhudWxsLCJzZXRDb21wYXJpc29uQ29sb3JzIik7ayhudWxsLCJzZXRDdXJyZW50VmlldyIpO2sobnVsbCwic2V0RGVmYXVsdERlcHRoUmFuZ2UiKTtrKG51bGwsInNldERlZmF1bHRHbG9zcyIpO2sobnVsbCwic2V0RGVmYXVsdE1pcnJvciIpO2sobnVsbCwic2V0RGVmYXVsdFNwZWN1bGFyTWl4Iik7ayhudWxsLCJzZXREZWZhdWx0U3BoZXJlTWFwIik7ayhudWxsLCJzZXREaXNwbGF5SW5jb21wbGV0ZUZyYW1lcyIpO2sobnVsbCwic2V0RHJhd0lkbGVEZWxheSIpO2sobnVsbCwic2V0RHJhd01vZGUiKTtrKG51bGwsInNldERyYXdTdHJhdGVneSIpO2sobnVsbCwic2V0RXllRG9tZUxpZ2h0aW5nQmx1ckVkZ2VEaXN0YW5jZSIpO2sobnVsbCwic2V0RXllRG9tZUxpZ2h0aW5nQmx1ckludGVydmFsIik7ayhudWxsLCJzZXRFeWVEb21lTGlnaHRpbmdCbHVyU2FtcGxlcyIpO2sobnVsbCwic2V0RXllRG9tZUxpZ2h0aW5nRW5hYmxlZCIpO2sobnVsbCwKInNldEV5ZURvbWVMaWdodGluZ09wYWNpdHkiKTtrKG51bGwsInNldEV5ZURvbWVMaWdodGluZ1NoYWRpbmdFZGdlRGlzdGFuY2UiKTtrKG51bGwsInNldEZhY2VzVmlzaWJsZSIpO2sobnVsbCwic2V0RmFjZVdpbmRpbmdGbGlwcGVkIik7ayhudWxsLCJzZXRGaXhlZERyYXdMaW1pdCIpO2sobnVsbCwic2V0RnJvbnRGYWNlc1Zpc2libGUiKTtrKG51bGwsInNldEdvb2NoQmFzZUNvbG9yUHJvbWluZW5jZSIpO2sobnVsbCwic2V0R29vY2hCbHVlIik7ayhudWxsLCJzZXRHb29jaEx1bWluYW5jZVNoaWZ0U3RyZW5ndGgiKTtrKG51bGwsInNldEdvb2NoWWVsbG93Iik7ayhudWxsLCJzZXRHcm91bmRQbGFuZSIpO2sobnVsbCwic2V0R3JvdW5kUGxhbmVXaXRoUG9zaXRpb24iKTtrKG51bGwsInNldEhhcmRFZGdlQ29sb3IiKTtrKG51bGwsInNldEhhcmRFZGdlT3BhY2l0eSIpO2sobnVsbCwic2V0SGFyZEVkZ2VzRW5hYmxlZCIpO2sobnVsbCwic2V0SGFyZEVkZ2VUaHJlc2hvbGQiKTtrKG51bGwsCiJzZXRIYXJkRWRnZVRocmVzaG9sZFJhbXBXaWR0aCIpO2sobnVsbCwic2V0SGlkZGVuTGluZUhpZGRlbkxpbmVDb2xvciIpO2sobnVsbCwic2V0SGlkZGVuTGluZUhpZ2hsaWdodGVkRWxlbWVudEZpbGxDb2xvciIpO2sobnVsbCwic2V0SGlkZGVuTGluZUhpZ2hsaWdodGVkRWxlbWVudE91dGxpbmVDb2xvciIpO2sobnVsbCwic2V0SGlkZGVuTGluZUhpZ2hsaWdodGVkSW5zdGFuY2VGaWxsQ29sb3IiKTtrKG51bGwsInNldEhpZGRlbkxpbmVIaWdobGlnaHRlZEluc3RhbmNlT3V0bGluZUNvbG9yIik7ayhudWxsLCJzZXRIaWRkZW5MaW5lVmlzaWJsZUxpbmVDb2xvciIpO2sobnVsbCwic2V0SGlnaGxpZ2h0Q29sb3JpemVDb21wcmVzc2lvbiIpO2sobnVsbCwic2V0SGlnaGxpZ2h0ZWRFbGVtZW50Q29sb3IiKTtrKG51bGwsInNldEhpZ2hsaWdodGVkRWxlbWVudEZpbHRlciIpO2sobnVsbCwic2V0SGlnaGxpZ2h0ZWRFbGVtZW50T3V0bGluZUNvbG9yIik7ayhudWxsLCJzZXRIaWdobGlnaHRlZEluc3RhbmNlQ29sb3IiKTsKayhudWxsLCJzZXRIaWdobGlnaHRlZEluc3RhbmNlRmlsdGVyIik7ayhudWxsLCJzZXRIaWdobGlnaHRlZEluc3RhbmNlT3V0bGluZUNvbG9yIik7ayhudWxsLCJzZXRIaWdobGlnaHRNb2RlIik7ayhudWxsLCJzZXRJbWFnZUJhc2VkTGlnaHRpbmdFbmFibGVkIik7ayhudWxsLCJzZXRJbWFnZUJhc2VkTGlnaHRpbmdFbnZpcm9ubWVudCIsZnVuY3Rpb24obSl7dmFyIHI9YyhtKTtpZighcil0aHJvdyBuZXcgVHlwZUVycm9yKCJgZGF0YScgaXMgbm90IGFuIEFycmF5IG9yIFVpbnQ4QXJyYXkiKTtyZXR1cm4gZ1twXS5zZXRJbWFnZUJhc2VkTGlnaHRpbmdFbnZpcm9ubWVudChyLG0ubGVuZ3RoKX0pO2sobnVsbCwic2V0SW1hZ2VCYXNlZExpZ2h0aW5nRW52aXJvbm1lbnRUb0RlZmF1bHQiKTtrKG51bGwsInNldEltYWdlQmFzZWRMaWdodGluZ0ludGVuc2l0eSIpO2sobnVsbCwic2V0SW1hZ2VCYXNlZExpZ2h0aW5nTWF0cml4Iik7ayhudWxsLCJzZXRJbnN0YW5jaW5nRW5hYmxlZCIpOwprKG51bGwsInNldEludGVyYWN0aXZlRHJhd0xpbWl0SW5jcmVhc2VFbmFibGVkIik7ayhudWxsLCJzZXRJbnRlcmFjdGl2ZURyYXdMaW1pdEluY3JlYXNlSW50ZXJ2YWwiKTtrKG51bGwsInNldExpZ2h0aW5nRW5hYmxlZCIpO2sobnVsbCwic2V0TGluZUppdHRlckVuYWJsZWQiKTtrKG51bGwsInNldExpbmVKaXR0ZXJGcmVxdWVuY3kiKTtrKG51bGwsInNldExpbmVKaXR0ZXJJbnN0YW5jZUNvdW50Iik7ayhudWxsLCJzZXRMaW5lSml0dGVyUmFkaXVzIik7ayhudWxsLCJzZXRMaW5lc1Zpc2libGUiKTtrKG51bGwsInNldE1lc2hMZXZlbCIpO2sobnVsbCwic2V0TWV0YWxsaWNSb3VnaG5lc3NNYXRlcmlhbE92ZXJyaWRlIik7ayhudWxsLCJzZXRNaW5EcmF3TGltaXQiKTtrKG51bGwsInNldE1pbkZyYW1lUmF0ZSIpO2sobnVsbCwic2V0TWluSW5jcmVtZW50YWxGcmFtZVJhdGUiKTtrKG51bGwsInNldE1pbkludGVyYWN0aXZlRnJhbWVSYXRlIik7ayhudWxsLCJzZXRQb2ludFNoYXBlIik7CmsobnVsbCwic2V0UG9pbnRTaXplIik7ayhudWxsLCJzZXRQb2ludHNWaXNpYmxlIik7ayhudWxsLCJzZXRQb2ludFZpc2liaWxpdHlUZXN0IiwxNik7ayhudWxsLCJzZXRQb3N0SW5wdXREZWxheSIpO2sobnVsbCwic2V0U2lsaG91ZXR0ZUNvbG9yIik7ayhudWxsLCJzZXRTaWxob3VldHRlRW5hYmxlZCIpO2sobnVsbCwic2V0U2lsaG91ZXR0ZU9wYWNpdHkiKTtrKG51bGwsInNldFNpbGhvdWV0dGVUaHJlc2hvbGQiKTtrKG51bGwsInNldFNpbGhvdWV0dGVUaHJlc2hvbGRSYW1wV2lkdGgiKTtrKG51bGwsInNldFNpbXBsZVJlZmxlY3Rpb25BdHRlbnVhdGlvbiIpO2sobnVsbCwic2V0U2ltcGxlUmVmbGVjdGlvbkJsdXJJbnRlcnZhbCIpO2sobnVsbCwic2V0U2ltcGxlUmVmbGVjdGlvbkJsdXJTYW1wbGVzIik7ayhudWxsLCJzZXRTaW1wbGVSZWZsZWN0aW9uRW5hYmxlZCIpO2sobnVsbCwic2V0U2ltcGxlUmVmbGVjdGlvbkZhZGVBbmdsZSIpO2sobnVsbCwic2V0U2ltcGxlUmVmbGVjdGlvbk9wYWNpdHkiKTsKayhudWxsLCJzZXRTaW1wbGVTaGFkb3dCbHVySW50ZXJ2YWwiKTtrKG51bGwsInNldFNpbXBsZVNoYWRvd0JsdXJTYW1wbGVzIik7ayhudWxsLCJzZXRTaW1wbGVTaGFkb3dDb2xvciIpO2sobnVsbCwic2V0U2ltcGxlU2hhZG93RW5hYmxlZCIpO2sobnVsbCwic2V0U2ltcGxlU2hhZG93SW50ZXJhY3RpdmVVcGRhdGVFbmFibGVkIik7ayhudWxsLCJzZXRTaW1wbGVTaGFkb3dPcGFjaXR5Iik7ayhudWxsLCJzZXRTaW1wbGVTaGFkb3dSZXNvbHV0aW9uIik7ayhudWxsLCJzZXRTbWFhUXVhbGl0eSIpO2sobnVsbCwic2V0U3NyUXVhbGl0eSIsZnVuY3Rpb24obSl7Ri5SayhtKX0pO2sobnVsbCwic2V0U3RyZWFtQ3V0b2ZmU2NhbGUiKTtrKG51bGwsInNldFN0cmVhbUlkbGVNYXJrZXIiLDI1Nik7ayhudWxsLCJzZXRUb29uQmFuZENvdW50Iik7ayhudWxsLCJzZXRUb29uU3BlY3VsYXJGYWN0b3IiKTtrKG51bGwsInNldFRyYW5zcGFyZW5jeU1vZGUiKTtrKG51bGwsInNldFVuaGlnaGxpZ2h0ZWRDb2xvciIpOwprKG51bGwsInNldFVuaGlnaGxpZ2h0ZWRGaWx0ZXIiKTtrKG51bGwsInNldFZpc2liaWxpdHlCeUF0dGFjaG1lbnQiKTtrKG51bGwsInNldFhSYXlNYXRlcmlhbCIpO2sobnVsbCwic2V0WFJheU9wYWNpdHkiKTtrKG51bGwsInNldFhSYXlUcmFuc3BhcmVuY3lNb2RlIik7ayhudWxsLCJzdGFydENvbXBhcmlzb24iLGZ1bmN0aW9uKG0scil7YWIobSk7YWIocik7dmFyIHU9YihtKTtpZighdSl0aHJvdyBuZXcgVHlwZUVycm9yKCJgaW5zdGFuY2VTZXQxJyBpcyBub3QgYW4gQXJyYXkgb3IgVWludDMyQXJyYXkuIik7dmFyIHg9YihyKTtpZigheCl0aHJvdyBuZXcgVHlwZUVycm9yKCJgaW5zdGFuY2VTZXQyJyBpcyBub3QgYW4gQXJyYXkgb3IgVWludDMyQXJyYXkuIik7cmV0dXJuIGdbcF0uc3RhcnRDb21wYXJpc29uKHUsbS5sZW5ndGg+PjEseCxyLmxlbmd0aD4+MSl9KTtrKG51bGwsInN0YXJ0RXhwbG9kZSIsNCk7ayhudWxsLCJzdXNwZW5kRHJhd2luZyIpO2sobnVsbCwidGVzdFBvaW50VmlzaWJpbGl0eSIsCjI3Mik7ayhudWxsLCJ0aHJvdHRsZUxvYWQiKTtrKG51bGwsInRyaWFuZ3VsYXRlUG9seWdvbiIsZnVuY3Rpb24obSxyKXtpZigzPm0ubGVuZ3RoKXRocm93IG5ldyBUeXBlRXJyb3IoIidwb2x5Z29uUG9pbnRzJyBkb2VzIG5vdCBkZXNjcmliZSBhIHBvbHlnb24uIik7dmFyIHU7aWYobSlpZih1PWcuJCRlcy5hbGxvY2F0ZVVpbnQ4QnVmZmVyKDQqbS5sZW5ndGgpKUIuc2V0KG0sdT4+Mik7ZWxzZSB0aHJvdyBFcnJvcigiT3V0IG9mIG1lbW9yeS4iKTtlbHNlIHU9MDtpZighdSl0aHJvdyBFcnJvcigiSW50ZXJuYWwgbG9naWMgZXJyb3IuIik7cmV0dXJuIGcuJCRlcy50cmlhbmd1bGF0ZVBvbHlnb24odSxtLmxlbmd0aCxyKX0pO2sobnVsbCwidHJ1bmNhdGVNZXRhRGF0YSIsZnVuY3Rpb24obSl7aWYoIiQkY3MiPT09cClyZXR1cm4gWi50cnVuY2F0ZU1ldGFEYXRhKG0pO2Zvcih2YXIgcj0wO3I8bS5sZW5ndGg7cis9Mil7dmFyIHU9bVtyKzFdLHg9JGFbbVtyXV07eCYmKHhbdV09TmMpfX0pOwprKG51bGwsInVuc2V0QWxsQ29sb3JzIik7ayhudWxsLCJ1bnNldEFsbEhpZ2hsaWdodGVkIik7ayhudWxsLCJ1bnNldEFsbE9wYWNpdHkiKTtrKG51bGwsInVuc2V0QWxsWFJheSIpO2sobnVsbCwidW5zZXRDdXJyZW50VmlldyIpO2sobnVsbCwidW5zZXRYUmF5TWF0ZXJpYWwiKTtrKG51bGwsInVwZGF0ZUxpZ2h0Iik7ayhudWxsLCJ3YWl0Rm9ySW1hZ2VEZWNvZGluZyIsMjU2KTtrKG51bGwsIndvcmxkU2VsZWN0QnlSYXkiLDI1Nik7ayhudWxsLCJfbG9zZVdlYkdsQ29udGV4dCIsZnVuY3Rpb24oKXt2YXIgbT1nLlJpLmdldEV4dGVuc2lvbigiV0VCR0xfbG9zZV9jb250ZXh0Iik7cmV0dXJuIG51bGwhPT1tPyhtLmxvc2VDb250ZXh0KCksITApOiExfSk7ayhaLCJnZXRDYW1lcmEiLDUxMik7ayhaLCJnZXRNZXRhRGF0YSIsMjYwKTtrKFosIk1lc2hEYXRhX2dldERhdGEiLDI1Nik7ayhaLCJNZXNoSW5zdGFuY2Vfc2V0TGluZVBhdHRlcm4iLDEzMik7ayhaLCJyZXF1ZXN0TWV0YURhdGEiLAoyNjApO2soWiwicmVzZXRUb0VtcHR5IiwyNTgpO2soWiwic2V0Q2FtZXJhIiwzMik7ayhaLCJ0cnVuY2F0ZU1ldGFEYXRhIiwyNjApO2sobnVsbCwiRGVidWdfbG9nIixmdW5jdGlvbihtKXttPXVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChtKSk7Zm9yKHZhciByPVtdLHU9MDt1PG0ubGVuZ3RoOysrdSlyLnB1c2gobS5jaGFyQ29kZUF0KHUpKTtyLnB1c2goMCk7dmFyIHg9YyhyKTtpZigheCl0aHJvdyBFcnJvcigiSW50ZXJuYWwgbG9naWMgZXJyb3IuIik7cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHosTCl7Z1twXS5kZWJ1Z19sb2coeCxyLmxlbmd0aCx6LEwpfSl9KTtrKG51bGwsIkRlYnVnX3N0YXRlRmFpbHVyZSIsMjU2KTtrKG51bGwsIkRlYnVnX3N5bmMiLDI1Nik7eS5JbWFnZT17fTtrKCJJbWFnZSIsImNyZWF0ZSIsZnVuY3Rpb24obSxyLHUseCx6LEwsZWEsWCxiYSxCYSl7dmFyIHFhPWMocik7aWYoIXFhKXRocm93IEVycm9yKCJJbnRlcm5hbCBsb2dpYyBlcnJvci4iKTsKdmFyIHZhPWMoZWEpO3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihDYSxJYSl7Z1twXS5JbWFnZV9jcmVhdGUocWEsci5sZW5ndGgsdmEsZWE/ZWEubGVuZ3RoOjAsbSx1LHg/eDowLHo/ejowLEw/TDowLFh8fCExLGJhP2JhOjAsQmE/QmE6MCxDYSxZKCJJbWFnZV9jcmVhdGUiLElhKSl9KX0pO2soIkltYWdlIiwiZGVzdHJveSIsMjYwKTt5Lk1hdHJpeD17fTtrKCJNYXRyaXgiLCJjcmVhdGUiLDI1Nik7aygiTWF0cml4IiwiZGVzdHJveSIsMjYwKTtrKCJNYXRyaXgiLCJnZXRFbGVtZW50cyIsMjYwKTtrKCJNYXRyaXgiLCJzZXRFbGVtZW50cyIsMjYwKTt5Lk1lc2hEYXRhPXt9O2soIk1lc2hEYXRhIiwiY3JlYXRlIixmdW5jdGlvbihtKXtyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocix1KXt2YXIgeD1tLl9tYXJzaGFsKCk7Z1twXS5NZXNoRGF0YV9jcmVhdGUoeC5iaXRzLHgudG90YWxGYWNlVmVydGljZXMseC50b3RhbExpbmVWZXJ0aWNlcyx4LnRvdGFsUG9pbnRWZXJ0aWNlcywKeC5mbG9hdERhdGFQdHIseC5mbG9hdERhdGFQdHJMZW4seC5mYWNlRWxlbWVudEluZm9zUHRyLGNhKm0uX2ZhY2VFbGVtZW50cy5sZW5ndGgseC5saW5lRWxlbWVudEluZm9zUHRyLGNhKm0uX2xpbmVFbGVtZW50cy5sZW5ndGgseC5wb2ludEVsZW1lbnRJbmZvc1B0cixjYSptLl9wb2ludEVsZW1lbnRzLmxlbmd0aCxyLFkoIk1lc2hEYXRhX2NyZWF0ZSIsdSkpfSl9KTtrKCJNZXNoRGF0YSIsImRlc3Ryb3kiLDI2MCk7aygiTWVzaERhdGEiLCJnZXREYXRhIixmdW5jdGlvbihtKXtyZXR1cm4gWi5NZXNoRGF0YV9nZXREYXRhKG0pLnRoZW4oUGIpfSk7aygiTWVzaERhdGEiLCJsaW5lRWxlbWVudFNlZ21lbnRzIiwyNTYpO2soIk1lc2hEYXRhIiwibGluZXNUb0luY2lkZW50RmFjZXMiLDI1OCk7aygiTWVzaERhdGEiLCJyZXBsYWNlIixmdW5jdGlvbihtLHIpe3JldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbih1LHgpe3ZhciB6PXIuX21hcnNoYWwoKTtnW3BdLk1lc2hEYXRhX3JlcGxhY2UobVswXSwKbVsxXSx6LmJpdHMsei50b3RhbEZhY2VWZXJ0aWNlcyx6LnRvdGFsTGluZVZlcnRpY2VzLHoudG90YWxQb2ludFZlcnRpY2VzLHouZmxvYXREYXRhUHRyLHouZmxvYXREYXRhUHRyTGVuLHouZmFjZUVsZW1lbnRJbmZvc1B0cixjYSpyLl9mYWNlRWxlbWVudHMubGVuZ3RoLHoubGluZUVsZW1lbnRJbmZvc1B0cixjYSpyLl9saW5lRWxlbWVudHMubGVuZ3RoLHoucG9pbnRFbGVtZW50SW5mb3NQdHIsY2Eqci5fcG9pbnRFbGVtZW50cy5sZW5ndGgsdSxZKCJNZXNoRGF0YV9yZXBsYWNlIix4KSl9KX0pO3kuTWVzaEluc3RhbmNlPXt9O2soIk1lc2hJbnN0YW5jZSIsImNsZWFyQWxsRWxlbWVudEhpZ2hsaWdodCIsMTMyKTtrKCJNZXNoSW5zdGFuY2UiLCJjbGVhckFsbEVsZW1lbnRWaXNpYmxlIiwxMzIpO2soIk1lc2hJbnN0YW5jZSIsImNsZWFyQWxsRWxlbWVudFhSYXkiLDEzMik7aygiTWVzaEluc3RhbmNlIiwiY2xlYXJFbGVtZW50Q29sb3JzIiwxMzIpO2soIk1lc2hJbnN0YW5jZSIsCiJjbGVhckVsZW1lbnRIaWdobGlnaHQiLDEzMik7aygiTWVzaEluc3RhbmNlIiwiY2xlYXJFbGVtZW50VmlzaWJsZSIsMTMyKTtrKCJNZXNoSW5zdGFuY2UiLCJjbGVhckVsZW1lbnRYUmF5IiwxMzIpO2soIk1lc2hJbnN0YW5jZSIsImNvbXB1dGVNaW5pbWFsQm9keUJvZHlEaXN0YW5jZSIsMjU2KTtrKCJNZXNoSW5zdGFuY2UiLCJjb21wdXRlTWluaW1hbEZhY2VGYWNlRGlzdGFuY2UiLDI1Nik7aygiTWVzaEluc3RhbmNlIiwiY29tcHV0ZU1pbmltYWxGYWNlTGluZURpc3RhbmNlIiwyNTYpO2soIk1lc2hJbnN0YW5jZSIsImNvbXB1dGVNaW5pbWFsRmFjZVJheURpc3RhbmNlIiwyNTYpO2soIk1lc2hJbnN0YW5jZSIsImNyZWF0ZSIsMjU2KTtrKCJNZXNoSW5zdGFuY2UiLCJkZXN0cm95IiwzODgpO2soIk1lc2hJbnN0YW5jZSIsImRpc2NhcmRBbm9ueW1vdXNNYXRyaXgiLDM4OCk7aygiTWVzaEluc3RhbmNlIiwiZ2V0QWx3YXlzRHJhdyIsMzg4KTtrKCJNZXNoSW5zdGFuY2UiLCJnZXRDYXBwaW5nTWVzaERhdGEiLAozODgpO2soIk1lc2hJbnN0YW5jZSIsImdldENvbG9yIiwyNDM2KTtrKCJNZXNoSW5zdGFuY2UiLCJnZXRDdWxsaW5nVmVjdG9yIiwzODgpO2soIk1lc2hJbnN0YW5jZSIsImdldERvTm90Q3V0IiwzODgpO2soIk1lc2hJbnN0YW5jZSIsImdldERvTm90RXhwbG9kZSIsMzg4KTtrKCJNZXNoSW5zdGFuY2UiLCJnZXREb05vdExpZ2h0IiwzODgpO2soIk1lc2hJbnN0YW5jZSIsImdldERvTm90T3V0bGluZUhpZ2hsaWdodCIsMzg4KTtrKCJNZXNoSW5zdGFuY2UiLCJnZXREb05vdFNlbGVjdCIsMzg4KTtrKCJNZXNoSW5zdGFuY2UiLCJnZXREb05vdFVzZVZlcnRleENvbG9ycyIsMzg4KTtrKCJNZXNoSW5zdGFuY2UiLCJnZXREcmF3bldvcmxkU3BhY2VCb3VuZGluZyIsMjYwKTtrKCJNZXNoSW5zdGFuY2UiLCJnZXRFZmZlY3RpdmVDb2xvciIsMzg4KTtrKCJNZXNoSW5zdGFuY2UiLCJnZXRFZmZlY3RpdmVFbGVtZW50Q29sb3IiLDM4OCk7aygiTWVzaEluc3RhbmNlIiwiZ2V0RWZmZWN0aXZlT3BhY2l0eSIsCjM4OCk7aygiTWVzaEluc3RhbmNlIiwiZ2V0RWxlbWVudENvbG9yIiwyNDM2KTtrKCJNZXNoSW5zdGFuY2UiLCJnZXRFbGVtZW50SGlnaGxpZ2h0ZWQiLDM4OCk7aygiTWVzaEluc3RhbmNlIiwiZ2V0RWxlbWVudFZpc2libGUiLDM4OCk7aygiTWVzaEluc3RhbmNlIiwiZ2V0RWxlbWVudFhSYXkiLDM4OCk7aygiTWVzaEluc3RhbmNlIiwiZ2V0RXhjbHVkZUJvdW5kaW5nIiwzODgpO2soIk1lc2hJbnN0YW5jZSIsImdldEZhY2VFbGVtZW50Qm91bmRpbmciLDI1OCk7aygiTWVzaEluc3RhbmNlIiwiZ2V0RmFjZXNWaXNpYmxlIiwzODgpO2soIk1lc2hJbnN0YW5jZSIsImdldEhpZ2hsaWdodGVkIiwzODgpO2soIk1lc2hJbnN0YW5jZSIsImdldExheWVyQ291bnQiKTtrKCJNZXNoSW5zdGFuY2UiLCJnZXRMaW5lRWxlbWVudEJvdW5kaW5nIiwyNTgpO2soIk1lc2hJbnN0YW5jZSIsImdldExpbmVzVmlzaWJsZSIsMzg4KTtrKCJNZXNoSW5zdGFuY2UiLCJnZXRNYXRyaXgiLDM4OCk7aygiTWVzaEluc3RhbmNlIiwKImdldE1lc2hEYXRhIiwzODgpO2soIk1lc2hJbnN0YW5jZSIsImdldE1ldGFsbGljUm91Z2huZXNzIiwzODgpO2soIk1lc2hJbnN0YW5jZSIsImdldE9iamVjdFNwYWNlQm91bmRpbmciLDM4OCk7aygiTWVzaEluc3RhbmNlIiwiZ2V0T3BhY2l0eSIsMTQxMik7aygiTWVzaEluc3RhbmNlIiwiZ2V0T3ZlcnJpZGVTY2VuZVZpc2liaWxpdHkiLDM4OCk7aygiTWVzaEluc3RhbmNlIiwiZ2V0UG9pbnRFbGVtZW50Qm91bmRpbmciLDI1OCk7aygiTWVzaEluc3RhbmNlIiwiZ2V0UG9pbnRzVmlzaWJsZSIsMzg4KTtrKCJNZXNoSW5zdGFuY2UiLCJnZXRTY3JlZW5PcmllbnRlZCIsMzg4KTtrKCJNZXNoSW5zdGFuY2UiLCJnZXRTdXBwcmVzc0NhbWVyYVNjYWxlIiwzODgpO2soIk1lc2hJbnN0YW5jZSIsImdldFdvcmxkU3BhY2VCb3VuZGluZyIsMjYwKTtrKCJNZXNoSW5zdGFuY2UiLCJoYXNEZXB0aFJhbmdlIiwzODgpO2soIk1lc2hJbnN0YW5jZSIsImhhc1RyYW5zcGFyZW5jeSIsMzg4KTtrKCJNZXNoSW5zdGFuY2UiLAoibGluZXNUb0luY2lkZW50RmFjZXMiLDI1OCk7aygiTWVzaEluc3RhbmNlIiwibWF0cml4UHJlTXVsdGlwbHkiLDM4OCk7aygiTWVzaEluc3RhbmNlIiwicmVpZnlBbm9ueW1vdXNNYXRyaXgiLDM4OCk7aygiTWVzaEluc3RhbmNlIiwic2V0QWx3YXlzRHJhdyIsMTMyKTtrKCJNZXNoSW5zdGFuY2UiLCJzZXRBbWJpZW50Q29sb3IiLDEzMik7aygiTWVzaEluc3RhbmNlIiwic2V0QW1iaWVudE1peCIsMTMyKTtrKCJNZXNoSW5zdGFuY2UiLCJzZXRBbm9ueW1vdXNNYXRyaXgiLDM4OCk7aygiTWVzaEluc3RhbmNlIiwic2V0QW5vbnltb3VzTWF0cmljZXMiLGZ1bmN0aW9uKG0scil7dmFyIHU9MCx4PTA7aWYobS5jb25zdHJ1Y3RvciE9PUFycmF5JiZtLmNvbnN0cnVjdG9yIT09VWludDMyQXJyYXkpdGhyb3cgbmV3IFR5cGVFcnJvcigiSW5jcyBCdWZmZXIgaXMgbm90IGFuIEFycmF5IG9yIFVpbnQzMkFycmF5LiIpO2lmKHIuY29uc3RydWN0b3IhPT1BcnJheSYmci5jb25zdHJ1Y3RvciE9PQpGbG9hdDY0QXJyYXkpdGhyb3cgbmV3IFR5cGVFcnJvcigiTWF0cmljZXMgQnVmZmVyIGlzIG5vdCBhbiBBcnJheSBvciBGbG9hdDY0QXJyYXkuIik7dT1iKG0pO2lmKCF1KXRocm93IGQodSksZCh4KSxFcnJvcigiSW50ZXJuYWwgbG9naWMgZXJyb3IuIik7eD1hKHIpO2lmKCF4KXRocm93IGQodSksZCh4KSxFcnJvcigiSW50ZXJuYWwgbG9naWMgZXJyb3IuIik7cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHosTCl7Z1twXS5NZXNoSW5zdGFuY2Vfc2V0QW5vbnltb3VzTWF0cmljZXModSxtLmxlbmd0aD4+MSx4LHIubGVuZ3RoLHosWSgiTWVzaEluc3RhbmNlX3NldEFub255bW91c01hdHJpY2VzIixMKSwwKX0pfSk7aygiTWVzaEluc3RhbmNlIiwic2V0Q29sb3IiLDEzMik7aygiTWVzaEluc3RhbmNlIiwic2V0Q3VsbGluZ1ZlY3RvciIsMTMyKTtrKCJNZXNoSW5zdGFuY2UiLCJzZXREZXB0aFJhbmdlIiwxMzIpO2soIk1lc2hJbnN0YW5jZSIsInNldERvTm90Q3V0IiwxMzIpO2soIk1lc2hJbnN0YW5jZSIsCiJzZXREb05vdEV4cGxvZGUiLDEzMik7aygiTWVzaEluc3RhbmNlIiwic2V0RG9Ob3RMaWdodCIsMTMyKTtrKCJNZXNoSW5zdGFuY2UiLCJzZXREb05vdE91dGxpbmVIaWdobGlnaHQiLDEzMik7aygiTWVzaEluc3RhbmNlIiwic2V0RG9Ob3RTZWxlY3QiLDEzMik7aygiTWVzaEluc3RhbmNlIiwic2V0RG9Ob3RSZXNldCIsMTMyKTtrKCJNZXNoSW5zdGFuY2UiLCJzZXREb05vdFVzZVZlcnRleENvbG9ycyIsMTMyKTtrKCJNZXNoSW5zdGFuY2UiLCJzZXREb05vdFhSYXkiLDEzMik7aygiTWVzaEluc3RhbmNlIiwic2V0RWxlbWVudENvbG9yIiwxMzIpO2soIk1lc2hJbnN0YW5jZSIsInNldEVsZW1lbnRIaWdobGlnaHRlZCIsMTMyKTtrKCJNZXNoSW5zdGFuY2UiLCJzZXRFbGVtZW50VmlzaWJsZSIsMTMyKTtrKCJNZXNoSW5zdGFuY2UiLCJzZXRFbGVtZW50WFJheSIsMTMyKTtrKCJNZXNoSW5zdGFuY2UiLCJzZXRFeGNsdWRlQm91bmRpbmciLDEzMik7aygiTWVzaEluc3RhbmNlIiwic2V0RmFjZXNWaXNpYmxlIiwKMTMyKTtrKCJNZXNoSW5zdGFuY2UiLCJzZXRIaWdobGlnaHRlZCIsMTMyKTtrKCJNZXNoSW5zdGFuY2UiLCJzZXRMaW5lUGF0dGVybiIsZnVuY3Rpb24obSxyLHUseCl7dmFyIHo9YyhyKTtpZigheil0aHJvdyBuZXcgVHlwZUVycm9yKCJgcGF0dGVybicgaXMgbm90IGFuIEFycmF5IG9yIFVpbnQ4QXJyYXkiKTtyZXR1cm4gWi5NZXNoSW5zdGFuY2Vfc2V0TGluZVBhdHRlcm4obSx6LHIubGVuZ3RoLHUseCl9KTtrKCJNZXNoSW5zdGFuY2UiLCJzZXRMaW5lc1Zpc2libGUiLDEzMik7aygiTWVzaEluc3RhbmNlIiwic2V0TWF0cml4IiwzODgpO2soIk1lc2hJbnN0YW5jZSIsInNldE1lc2hMZXZlbCIsMTMyKTtrKCJNZXNoSW5zdGFuY2UiLCJzZXRNZXRhbGxpY1JvdWdobmVzcyIsMTMyKTtrKCJNZXNoSW5zdGFuY2UiLCJ1bnNldE1ldGFsbGljUm91Z2huZXNzIiwxMzIpO2soIk1lc2hJbnN0YW5jZSIsInNldE9wYWNpdHkiLDEzMik7aygiTWVzaEluc3RhbmNlIiwic2V0T3ZlcmxheUluZGV4IiwKMTMyKTtrKCJNZXNoSW5zdGFuY2UiLCJzZXRPdmVycmlkZVNjZW5lVmlzaWJpbGl0eSIsMTMyKTtrKCJNZXNoSW5zdGFuY2UiLCJzZXRQb2ludHNWaXNpYmxlIiwxMzIpO2soIk1lc2hJbnN0YW5jZSIsInNldFNjcmVlbk9yaWVudGVkIiwxMzIpO2soIk1lc2hJbnN0YW5jZSIsInNldFNjcmVlblNwYWNlIiwxMzIpO2soIk1lc2hJbnN0YW5jZSIsInNldFNjcmVlblNwYWNlU3RyZXRjaGVkIiwxMzIpO2soIk1lc2hJbnN0YW5jZSIsInNldFN0cmVhbUN1dG9mZlNjYWxlIiwxMzIpO2soIk1lc2hJbnN0YW5jZSIsInNldFN1cHByZXNzQ2FtZXJhU2NhbGUiLDEzMik7aygiTWVzaEluc3RhbmNlIiwic2V0VGV4dHVyZSIsMzg4KTtrKCJNZXNoSW5zdGFuY2UiLCJzZXRWaXNpYmxlIiwxMzIpO2soIk1lc2hJbnN0YW5jZSIsInNldFhSYXkiLDEzMik7aygiTWVzaEluc3RhbmNlIiwic3luY2hyb25pemVWaXNpYmlsaXRpZXMiLDQpO2soIk1lc2hJbnN0YW5jZSIsInVuc2V0Q29sb3IiLDEzMik7CmsoIk1lc2hJbnN0YW5jZSIsInVuc2V0Q3VsbGluZ1ZlY3RvciIsMTMyKTtrKCJNZXNoSW5zdGFuY2UiLCJ1bnNldERlcHRoUmFuZ2UiLDEzMik7aygiTWVzaEluc3RhbmNlIiwidW5zZXRFbGVtZW50Q29sb3IiLDEzMik7aygiTWVzaEluc3RhbmNlIiwidW5zZXRMaW5lUGF0dGVybiIsMTMyKTtrKCJNZXNoSW5zdGFuY2UiLCJ1bnNldE1hdHJpeCIsMzg4KTtrKCJNZXNoSW5zdGFuY2UiLCJ1bnNldE9wYWNpdHkiLDEzMik7aygiTWVzaEluc3RhbmNlIiwidW5zZXRUZXh0dXJlIiwxMzIpO2soIk1lc2hJbnN0YW5jZSIsInNldEVtaXNzaXZlQ29sb3IiLDEzMik7aygiTWVzaEluc3RhbmNlIiwidW5zZXRFbWlzc2l2ZUNvbG9yIiwxMzIpO2soIk1lc2hJbnN0YW5jZSIsInNldFNwZWN1bGFyQ29sb3IiLDEzMik7aygiTWVzaEluc3RhbmNlIiwidW5zZXRTcGVjdWxhckNvbG9yIiwxMzIpO2soIk1lc2hJbnN0YW5jZSIsInNldFNwZWN1bGFySW50ZW5zaXR5IiwxMzIpO2soIk1lc2hJbnN0YW5jZSIsCiJ1bnNldFNwZWN1bGFySW50ZW5zaXR5IiwxMzIpO3kuT3ZlcmxheT17fTtrKCJPdmVybGF5IiwiZGVzdHJveSIpO2soIk92ZXJsYXkiLCJtYXhJbmRleCIpO2soIk92ZXJsYXkiLCJzZXRDYW1lcmEiLDMyKTtrKCJPdmVybGF5Iiwic2V0Vmlld3BvcnQiKTtrKCJPdmVybGF5Iiwic2V0VmlzaWJsZSIpO3ZhciBlYz17b3Blbl9tb2RlbF9mYWlsZWQ6VGEsc2Vzc2lvbl9zdGFydGVkOmZ1bmN0aW9uKCl7IiQkY3MiPT09cCYmKGcuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoIndlYmdsY29udGV4dGxvc3QiLHYsITEpLHkub25SZXNpemUoKSl9LHBvc3RfZHJhd19qc29uOmZ1bmN0aW9uKG0scil7dHJ5e3ZhciB1PUpTT04ucGFyc2Uocil9Y2F0Y2goeCl7Y29uc29sZS5hc3NlcnQoITEsIm1hbGZvcm1lZCBKU09OIGZyb20gcG9zdF9kcmF3Iix4KTtyZXR1cm59Zy5naSgicG9zdF9kcmF3Iix1LnN0YXRzLEFiKHUuY2FtZXJhKSx1LnZpc2libGVQb2ludHMpOyJoaWdoIj09PXUucXVhbGl0eSYmCihnLmdpKCJkcmF3X2NvbXBsZXRlIiksZy5naSgiZHJhd19pZGxlIikpfX0saWE9e3Nlc3Npb25fc3RhcnRlZDpmdW5jdGlvbigpeyIkJHNzIj09PXAmJih5LnJlc3VtZURyYXdpbmcoKSxnW3BdLkRlYnVnX25vdGlmeUxvZ2dlZFJwY0V4ZWN1dGlvbklzQWxsb3dlZCgpKX19LFE9e307Zy5naT1mdW5jdGlvbihtKXtpZihtIGluIGVjKXt2YXIgcj1lY1ttXTtyLmFwcGx5KHRoaXMsYXJndW1lbnRzKX12YXIgdT1RW21dO3RyeXtpZih2b2lkIDAhPT11KWZvcih2YXIgeD0wO3g8dS5sZW5ndGg7eCsrKXI9dVt4XSwiZnVuY3Rpb24iPT09dHlwZW9mIHImJnIuYXBwbHkodGhpcyxhcmd1bWVudHMpfWNhdGNoKHope2NvbnNvbGUubG9nKCJVbmhhbmRsZWQgZXhjZXB0aW9uIGluICIrbSsiIGV2ZW50IGhhbmRsZXI6IiksY29uc29sZS5sb2coeil9bSBpbiBpYSYmKHI9aWFbbV0sci5hcHBseSh0aGlzLGFyZ3VtZW50cykpfTt5LnNldEV2ZW50SGFuZGxlcj1mdW5jdGlvbihtLHIpe1EuaGFzT3duUHJvcGVydHkobSl8fAooUVttXT1bXSk7UVttXS5wdXNoKHIpfTt5LnVuc2V0RXZlbnRIYW5kbGVyPWZ1bmN0aW9uKG0scil7bT1RW21dO2lmKHZvaWQgMCE9PW0pZm9yKHZhciB1PTA7dTxtLmxlbmd0aDspbVt1XT09PXI/bS5zcGxpY2UodSwxKTorK3V9O1cucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoRXJyb3IucHJvdG90eXBlKTtXLnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj1XO3ZhciBIPXtVbmluaXRpYWxpemVkOjAsTmV0d29yazoxLFNjczoyfTt5LlNlc3Npb25UeXBlPUg7dmFyIHVhPUguVW5pbml0aWFsaXplZDt5LmxvYWQ9ZnVuY3Rpb24obSl7RygpO1ImJnkuY2FsbFJlY29yZC5wdXNoKCJsb2FkICIrdyhtKSk7aWYoIW0pdGhyb3cgbmV3IFcoIkludmFsaWRDb25maWciLCJJbnZhbGlkIGxvYWQgY29uZmlndXJhdGlvbiIpO3ZhciByPW0udXJpO2lmKDEhPT0hIXIrISFtLmJ1ZmZlcishIW0uZW1wdHkpdGhyb3cgbmV3IFcoIkludmFsaWRDb25maWciLCJNdXN0IHNwZWNpZnkgZXhhY3RseSBvbmUgb2YgJ3VyaScsICdidWZmZXInLCBvciAnZW1wdHknLiIpOwppZihyKXt7aWYoInN0cmluZyIhPT10eXBlb2Ygcil0aHJvdyBuZXcgVygiSW52YWxpZENvbmZpZyIsIid1cmknIG11c3QgYmUgYSBzdHJpbmciKTtjb25zdCBbZWEsWCxiYV09ci5zcGxpdCgiOi8vIik7aWYoWCl7aWYoYmEpdGhyb3cgbmV3IFcoIkludmFsaWRDb25maWciLCJJbnZhbGlkIFVSSSIpO3ZhciB1PWVhfWVsc2UgdT0iaHR0cCJ9aWYoIndzIj09PXV8fCJ3c3MiPT09dSl7SygpO2lmKCFtKXRocm93IG5ldyBXKCJJbnZhbGlkQ29uZmlnIiwiSW52YWxpZCBsb2FkIGNvbmZpZ3VyYXRpb24iKTttLm1vZGVsJiYic3RyaW5nIj09PXR5cGVvZiBtLm1vZGVsfHwobS5tb2RlbD0iIik7dT1tLnNlc3Npb25Ub2tlbjt2b2lkIDA9PT11JiYodT0iIik7aWYoInN0cmluZyIhPT10eXBlb2YgdSl0aHJvdyBuZXcgVygiSW52YWxpZENvbmZpZyIsIidzZXNzaW9uVG9rZW4nIG11c3QgYmUgYSBzdHJpbmciKTt2YXIgeD1tLmxpbWl0TWlCO3ZvaWQgMD09PXgmJih4PTApO2lmKCJudW1iZXIiIT09CnR5cGVvZiB4KXRocm93IG5ldyBXKCJJbnZhbGlkQ29uZmlnIiwiJ2xpbWl0TWlCJyBtdXN0IGJlIGEgbnVtYmVyIik7dmFyIHo9bS5tZXNoTGV2ZWw7dm9pZCAwPT09eiYmKHo9MCk7aWYoIm51bWJlciIhPT10eXBlb2Ygeil0aHJvdyBuZXcgVygiSW52YWxpZENvbmZpZyIsIidtZXNoTGV2ZWwnIG11c3QgYmUgYSBudW1iZXIiKTt2YXIgTD1tLnN0cmVhbUN1dG9mZlNjYWxlO3ZvaWQgMD09PUwmJihMPS0xKTtpZigibnVtYmVyIiE9PXR5cGVvZiBMKXRocm93IG5ldyBXKCJJbnZhbGlkQ29uZmlnIiwiJ3N0cmVhbUN1dG9mZlNjYWxlJyBtdXN0IGJlIGEgbnVtYmVyIik7aWYodWEhPT1ILlVuaW5pdGlhbGl6ZWQpdGhyb3cgbmV3IFcoIkFscmVhZHlDYWxsZWQiLCJsb2FkKCkgYWxyZWFkeSBjYWxsZWQgZm9yIGEgbm9uLXN0cmVhbWluZyBzZXNzaW9uIik7dWE9SC5OZXR3b3JrO20uc2VydmVyU2lkZVJlbmRlcmluZz8oZy5jYW52YXMuc3R5bGUuZGlzcGxheT0ibm9uZSIscD0iJCRzcyIsCkYudmooZy4kJHdyYXBwZXIpLHkub25SZXNpemUoKSxGLlBrKHRhKSxGLlFrKHlhKSxGLk9rKEFhKSxGLk5rKGcuZ2kpLEYuY29ubmVjdChtKSk6KHA9IiQkY3MiLGphKGcuJCRlcy5sb2FkTmV0d29yayhyLHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChtLm1vZGVsKSksdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KHUpKSwhIW0uc3RyZWFtQ3VsbGVkLCEhbS5zdHJlYW1NZXRhRGF0YU9uSWRsZSwhIW0uc3RyZWFtTm9MaW1pdCwhIW0uc3RyZWFtSW5zdGFuY2VzT25EZW1hbmQsISFtLnN0cmVhbUFnZ3Jlc3NpdmVDb21wcmVzc2lvbiwhIW0uc3RyZWFtTW9kZWxCb3VuZGluZ1ByZXZpZXdzLCEhbS5zdHJlYW1JbnN0YW5jZUJvdW5kaW5nUHJldmlld3MsISFtLnN0cmVhbU9ubHlJbnRlcmVzdGluZ0JvdW5kaW5nUHJldmlld3MsISFtLnN0cmVhbUVqZWN0ZWRCb3VuZGluZ1ByZXZpZXdzLHgseixMKSkpfWVsc2UiaHR0cCIhPT11JiYiaHR0cHMiIT09dXx8RShtLHIpfWVsc2UgbS5idWZmZXI/CkEobSxtLmJ1ZmZlcik6KG09ISFtLnN0cmVhbUluc3RhbmNlc09uRGVtYW5kLEsoW0guU2NzXSksdWE9SC5TY3MsbT1nLiQkZXMubG9hZEVtcHR5U2NzKG0pLGphKG0pKTtyZXR1cm4gdWF9O3kuYXR0YWNoU2NzQnVmZmVyPWZ1bmN0aW9uKG0scix1LHgseixMLGVhKXttPXthdHRhY2hTY29wZTptLGluY2x1c2lvbk1hdHJpeDp1LGF0dGFjaE1lYXN1cmVtZW50VW5pdDp4LGF0dGFjaEludmlzaWJseTp6LHJlc29sdmVPbkZ1bGx5TG9hZGVkOkwsY2FuY2VsVW5pdE1hdHJpeDplYX07cmV0dXJuIG51bGw9PT1yfHwwPT09ci5sZW5ndGg/VShtLDAsMCk6QShtLHIpfTt5LmZlZWRTY3NCdWZmZXI9ZnVuY3Rpb24obSxyKXtLKFtILlNjc10pO2lmKDA9PT1tKXRocm93IG5ldyBXKCJJbnZhbGlkQ29uZmlnIiwiJ2F0dGFjaFNjb3BlJyBzaG91bGQgbm90IGJlIDAiKTt2YXIgdT0wLHg9MDtpZihudWxsIT09cil7aWYoci5jb25zdHJ1Y3RvciE9PVVpbnQ4QXJyYXkpdGhyb3cgbmV3IFcoIkludmFsaWRDb25maWciLAoiJ2J1ZmZlcicgbXVzdCBiZSBhIFVpbnQ4QXJyYXkiKTtpZigwPj1yLmJ5dGVMZW5ndGgpdGhyb3cgbmV3IFcoIkVtcHR5QnVmZmVyIiwiJ2J1ZmZlcicgaGFzIGEgbGVuZ3RoIG9mIDAiKTt1PXIuYnl0ZUxlbmd0aDt4PWcuJCRlcy5hbGxvY2F0ZVVpbnQ4QnVmZmVyKHIuYnl0ZUxlbmd0aCk7dC5zZXQocix4KX1nLiQkZXMuZmVlZFNjc0J1ZmZlcihtLHgsdSl9fSkoKTt2YXIgY2E9MyxNPTQqY2E7eS5NZXNoRGF0YUJ1aWxkZXI9ZnVuY3Rpb24oKXt0aGlzLl9mYWNlRWxlbWVudHM9W107dGhpcy5fbGluZUVsZW1lbnRzPVtdO3RoaXMuX3BvaW50RWxlbWVudHM9W107dGhpcy5mb3JtYXRCaXRzPTB9O3kuTWVzaERhdGFCdWlsZGVyLkZvcm1hdEJpdHM9e0Nsb2Nrd2lzZVdpbmRpbmc6MSxDb3VudGVyQ2xvY2t3aXNlV2luZGluZzoyLFR3b1NpZGVkOjQsTWFuaWZvbGQ6NjU1MzZ9O3kuTWVzaERhdGFCdWlsZGVyLnByb3RvdHlwZT17Y29uc3RydWN0b3I6eS5NZXNoRGF0YUJ1aWxkZXIsCl9nZXRPcHRpb25hbDpmdW5jdGlvbihFLEEpe3JldHVybiB2b2lkIDA9PT1FP251bGw6RVtBXT9FW0FdOm51bGx9LF9vcHRpb25hbEd1YXJkOmZ1bmN0aW9uKEUsQSxVKXtpZihVKXtpZigoVT10aGlzW1VdWzBdKSYmIVVbRV0pdGhyb3cgRXJyb3IoIkNhbm5vdCBkZWZpbmUgIitBKyIgZm9yIHNvbWUgYnV0IG5vdCBhbGwgdmVydGljZXMuIik7fWVsc2UgdGhpcy5fb3B0aW9uYWxHdWFyZChFLEEsIl9mYWNlRWxlbWVudHMiKSx0aGlzLl9vcHRpb25hbEd1YXJkKEUsQSwiX2xpbmVFbGVtZW50cyIpLHRoaXMuX29wdGlvbmFsR3VhcmQoRSxBLCJfcG9pbnRFbGVtZW50cyIpfSxhZGRGYWNlOmZ1bmN0aW9uKEUsQSl7dmFyIFU9dGhpcy5fZmFjZUVsZW1lbnRzLEs9dGhpcy5fZ2V0T3B0aW9uYWwoQSwibm9ybWFscyIpLGphPXRoaXMuX2dldE9wdGlvbmFsKEEsInV2cyIpLFc9dGhpcy5fZ2V0T3B0aW9uYWwoQSwicmdiYTMycyIpO0E9dGhpcy5fZ2V0T3B0aW9uYWwoQSwiYml0cyIpfHwwOwppZigwIT09RS5sZW5ndGglOSl0aHJvdyBFcnJvcigiSWxsZWdhbCB0cmlhbmdsZXM6ICd2ZXJ0ZXhEYXRhLmxlbmd0aCcgbXVzdCBiZSBkaXZpc2libGUgYnkgOSAoaS5lLiAzIG51bWJlcnMgcGVyIHZlcnRleCBhbmQgMyB2ZXJ0aWNlcyBwZXIgdHJpYW5nbGUpLiIpO2lmKEspe2lmKEsubGVuZ3RoIT09RS5sZW5ndGgpdGhyb3cgRXJyb3IoIkNhbm5vdCBkZWZpbmUgbm9ybWFscyBmb3Igc29tZSBidXQgbm90IGFsbCB2ZXJ0aWNlcy4iKTt0aGlzLl9vcHRpb25hbEd1YXJkKCJub3JtYWxzIiwibm9ybWFscyIsIl9mYWNlRWxlbWVudHMiKX1pZihqYSl7aWYoMypqYS5sZW5ndGghPT0yKkUubGVuZ3RoKXRocm93IEVycm9yKCJDYW5ub3QgZGVmaW5lIFVWIHBhcmFtZXRlcnMgZm9yIHNvbWUgYnV0IG5vdCBhbGwgdmVydGljZXMuIik7dGhpcy5fb3B0aW9uYWxHdWFyZCgidXZzIiwiVVYgcGFyYW1ldGVycyIsIl9mYWNlRWxlbWVudHMiKX1pZihXKXtpZigzKlcubGVuZ3RoIT09NCpFLmxlbmd0aCl0aHJvdyBFcnJvcigiQ2Fubm90IGRlZmluZSBSR0JBMzJzIGZvciBzb21lIGJ1dCBub3QgYWxsIHZlcnRpY2VzLiIpOwp0aGlzLl9vcHRpb25hbEd1YXJkKCJyZ2JhMzJzIiwiUkdCQTMycyIpO2lmKDA9PSh0aGlzLmZvcm1hdEJpdHMmMzI3NjgpKWZvcih2YXIgdGE9Mzt0YTxXLmxlbmd0aDt0YSs9NClpZigyNTUhPVdbdGFdKXt0aGlzLmZvcm1hdEJpdHN8PTMyNzY4O2JyZWFrfX1VLnB1c2goe3ZlcnRleERhdGE6RSxub3JtYWxzOkssdXZzOmphLHJnYmEzMnM6VyxiaXRzOkF9KX0sYWRkUG9seWxpbmU6ZnVuY3Rpb24oRSxBKXt2YXIgVT10aGlzLl9saW5lRWxlbWVudHMsSz10aGlzLl9nZXRPcHRpb25hbChBLCJyZ2JhMzJzIik7QT10aGlzLl9nZXRPcHRpb25hbChBLCJiaXRzIil8fDA7aWYoMCE9PUUubGVuZ3RoJTMpdGhyb3cgRXJyb3IoInZlcnRleERhdGEgYXJyYXkgbXVzdCBiZSBkaXZpc2libGUgYnkgMyAoaS5lLiAzIG51bWJlcnMgcGVyIHZlcnRleCkuIik7aWYoNj5FLmxlbmd0aCYmMDxFLmxlbmd0aCl0aHJvdyBFcnJvcigiSWxsZWdhbCBwb2x5bGluZTogJzAgPCB2ZXJ0ZXhEYXRhLmxlbmd0aCA8IDYnLiIpOwppZihLKXtpZigzKksubGVuZ3RoIT09NCpFLmxlbmd0aCl0aHJvdyBFcnJvcigiQ2Fubm90IGRlZmluZSBSR0JBMzJzIGZvciBzb21lIGJ1dCBub3QgYWxsIHZlcnRpY2VzLiIpO3RoaXMuX29wdGlvbmFsR3VhcmQoInJnYmEzMnMiLCJSR0JBMzJzIil9VS5wdXNoKHt2ZXJ0ZXhEYXRhOkUscmdiYTMyczpLLGJpdHM6QX0pfSxhZGRQb2ludHM6ZnVuY3Rpb24oRSxBKXt2YXIgVT10aGlzLl9wb2ludEVsZW1lbnRzLEs9dGhpcy5fZ2V0T3B0aW9uYWwoQSwicmdiYTMycyIpO0E9dGhpcy5fZ2V0T3B0aW9uYWwoQSwiYml0cyIpfHwwO2lmKDAhPT1FLmxlbmd0aCUzKXRocm93IEVycm9yKCJ2ZXJ0ZXhEYXRhIGFycmF5IG11c3QgYmUgZGl2aXNpYmxlIGJ5IDMgKGkuZS4gMyBudW1iZXJzIHBlciB2ZXJ0ZXgpLiIpO2lmKEspe2lmKDMqSy5sZW5ndGghPT00KkUubGVuZ3RoKXRocm93IEVycm9yKCJDYW5ub3QgZGVmaW5lIFJHQkEzMnMgZm9yIHNvbWUgYnV0IG5vdCBhbGwgdmVydGljZXMuIik7CnRoaXMuX29wdGlvbmFsR3VhcmQoInJnYmEzMnMiLCJSR0JBMzJzIil9VS5wdXNoKHt2ZXJ0ZXhEYXRhOkUscmdiYTMyczpLLGJpdHM6QX0pfSxfbWFyc2hhbDpmdW5jdGlvbigpe3ZhciBFPXRoaXMuX2ZhY2VFbGVtZW50cyxBPXRoaXMuX2xpbmVFbGVtZW50cyxVPXRoaXMuX3BvaW50RWxlbWVudHMsSz0hMSxqYT0hMSxXPSExLHRhPSExLHlhPSExLEFhPSExLEFiPSExLFBiPSExLE9iPSExLG9hPUVbMF0sVGE9QVswXSxrPVVbMF07b2EmJihLPSEhb2Eubm9ybWFscyxqYT0hIW9hLnV2cyxXPSEhb2EucmdiYTMycyk7VGEmJih0YT0hIVRhLm5vcm1hbHMseWE9ISFUYS51dnMsQWE9ISFUYS5yZ2JhMzJzKTtrJiYoQWI9ISFrLm5vcm1hbHMsUGI9ISFrLnV2cyxPYj0hIWsucmdiYTMycyk7dmFyIGliPTM7b2E9dGhpcy5mb3JtYXRCaXRzO2lmKFRhPUt8fHRhfHxBYilpYis9MyxvYXw9NDA5NixLJiYob2F8PTgpLHRhJiYob2F8PTY0KSxBYiYmKG9hfD01MTIpO2lmKGs9amF8fHlhfHxQYilpYis9CjIsb2F8PTgxOTIsamEmJihvYXw9MTYpLHlhJiYob2F8PTEyOCksUGImJihvYXw9MTAyNCk7dmFyIENiPVd8fEFhfHxPYjtDYiYmKGliKz0xLG9hfD0xNjM4NCxXJiYob2F8PTMyKSxBYSYmKG9hfD0yNTYpLE9iJiYob2F8PTIwNDgpKTtmb3IodmFyIEJiPTAsWT0wO1k8RS5sZW5ndGg7KytZKXt2YXIgUz1FW1ldO0JiKz1TLnZlcnRleERhdGEubGVuZ3RofUJiLz0zO3ZhciBhYj0wLERhPTA7Zm9yKFk9MDtZPEEubGVuZ3RoOysrWSl7Uz1BW1ldO3ZhciBaPVMudmVydGV4RGF0YTtaLmxlbmd0aCYmKGFiKz1aLmxlbmd0aCwrK0RhKX1hYj0yKihhYi8zLURhKTtmb3IoWT1EYT0wO1k8VS5sZW5ndGg7KytZKVM9VVtZXSxEYSs9Uy52ZXJ0ZXhEYXRhLmxlbmd0aDtEYS89MztpYio9QmIrYWIrRGE7WT1nLiQkZXMuYWxsb2NhdGVVaW50OEJ1ZmZlcjt2YXIgJGE9WSg0KmliKSxOYz1FLmxlbmd0aD9ZKE0qRS5sZW5ndGgpOjAsTmI9QS5sZW5ndGg/WShNKkEubGVuZ3RoKTowLGVjPVUubGVuZ3RoPwpZKE0qVS5sZW5ndGgpOjAsaWE9dC5zdWJhcnJheSgkYSksUT1CLnN1YmFycmF5KCRhPj4yKSxIPTAsdWE9MDtmb3IoWT0wO1k8RS5sZW5ndGg7KytZKXtTPUVbWV07Wj1TLnZlcnRleERhdGE7dmFyIG09Uy5ub3JtYWxzLHI9Uy51dnMsdT1TLnJnYmEzMnMseD1aLmxlbmd0aC8zLHo9aC5zdWJhcnJheSgoTmM+PjIpK2NhKlkpO3pbMF09dWE7elsxXT14O3pbMl09Uy5iaXRzO3VhKz14O3ZhciBMPTA7Zm9yKHg9Uz0wO3g8Wi5sZW5ndGg7eCs9MylRW0hdPVpbeF0sUVtIKzFdPVpbeCsxXSxRW0grMl09Wlt4KzJdLEgrPTMsVGEmJihLPyhRW0hdPW1beF0sUVtIKzFdPW1beCsxXSxRW0grMl09bVt4KzJdKTooUVtIXT0wLFFbSCsxXT0wLFFbSCsyXT0wKSxIKz0zKSxrJiYoamE/KFFbSF09cltMXSxRW0grMV09cltMKzFdLEwrPTIpOihRW0hdPTAsUVtIKzFdPTApLEgrPTIpLENiJiYoej1IPDwyLFc/KGlhW3orK109dVtTKytdLGlhW3orK109dVtTKytdLGlhW3orK109dVtTKytdLGlhW3orK109CnVbUysrXSk6KGlhW3orK109MCxpYVt6KytdPTAsaWFbeisrXT0wLGlhW3orK109MCksKytIKX1mb3IoWT11YT0wO1k8QS5sZW5ndGg7KytZKWZvcihTPUFbWV0sWj1TLnZlcnRleERhdGEsbT1TLm5vcm1hbHMscj1TLnV2cyx1PVMucmdiYTMycyx4PVoubGVuZ3RoLzMsMDx4JiYoeD0yKngtMiksej1oLnN1YmFycmF5KChOYj4+MikrY2EqWSkselswXT11YSx6WzFdPXgselsyXT1TLmJpdHMsdWErPXgsUz00LHg9Mzt4PFoubGVuZ3RoO3grPTMpZm9yKFMtPTQsRT0tMzswPj1FO0UrPTMpSz14K0UsUVtIXT1aW0tdLFFbSCsxXT1aW0srMV0sUVtIKzJdPVpbSysyXSxIKz0zLFRhJiYodGE/KFFbSF09bVtLXSxRW0grMV09bVtLKzFdLFFbSCsyXT1tW0srMl0pOihRW0hdPTAsUVtIKzFdPTAsUVtIKzJdPTApLEgrPTMpLGsmJih5YT8oSz1LLzMqMixRW0hdPXJbS10sUVtIKzFdPXJbSysxXSk6KFFbSF09MCxRW0grMV09MCksSCs9MiksQ2ImJih6PUg8PDIsQWE/KGlhW3orK109dVtTKytdLAppYVt6KytdPXVbUysrXSxpYVt6KytdPXVbUysrXSxpYVt6KytdPXVbUysrXSk6KGlhW3orK109MCxpYVt6KytdPTAsaWFbeisrXT0wLGlhW3orK109MCksKytIKTtmb3IoWT11YT0wO1k8VS5sZW5ndGg7KytZKWZvcihTPVVbWV0sWj1TLnZlcnRleERhdGEsbT1TLm5vcm1hbHMscj1TLnV2cyx1PVMucmdiYTMycyx4PVoubGVuZ3RoLzMsej1oLnN1YmFycmF5KChlYz4+MikrY2EqWSkselswXT11YSx6WzFdPXgselsyXT1TLmJpdHMsdWErPXgseD1TPUw9MDt4PFoubGVuZ3RoO3grPTMpUVtIXT1aW3hdLFFbSCsxXT1aW3grMV0sUVtIKzJdPVpbeCsyXSxIKz0zLFRhJiYoQWI/KFFbSF09bVt4XSxRW0grMV09bVt4KzFdLFFbSCsyXT1tW3grMl0pOihRW0hdPTAsUVtIKzFdPTAsUVtIKzJdPTApLEgrPTMpLGsmJihQYj8oUVtIXT1yW0xdLFFbSCsxXT1yW0wrMV0sTCs9Mik6KFFbSF09MCxRW0grMV09MCksSCs9MiksQ2ImJih6PUg8PDIsT2I/KGlhW3orK109dVtTKytdLGlhW3orK109dVtTKytdLAppYVt6KytdPXVbUysrXSxpYVt6KytdPXVbUysrXSk6KGlhW3orK109MCxpYVt6KytdPTAsaWFbeisrXT0wLGlhW3orK109MCksKytIKTtyZXR1cm57dG90YWxGYWNlVmVydGljZXM6QmIsdG90YWxMaW5lVmVydGljZXM6YWIsdG90YWxQb2ludFZlcnRpY2VzOkRhLGZhY2VFbGVtZW50SW5mb3NQdHI6TmMsbGluZUVsZW1lbnRJbmZvc1B0cjpOYixwb2ludEVsZW1lbnRJbmZvc1B0cjplYyxmbG9hdERhdGFQdHI6JGEsZmxvYXREYXRhUHRyTGVuOmliLGJpdHM6b2F9fX19OwpnLktqPWZ1bmN0aW9uKCl7dmFyIGE9e1BqOm51bGwsWGk6bnVsbCxjb25uZWN0aW9uOm51bGwsZWo6bnVsbCxoajpudWxsLGJqOm51bGwsYWo6bnVsbCwkaToxMjgwLFppOjgwMCxnajoxMjgwLGZqOjgwMCxRaToxLGRrOntjb21tYW5kOiJTRVJWRVJfU0VUVElOR1MifSx2ajpmdW5jdGlvbihjKXt0aGlzLlBqPWM7Yi52aigpfSxUazpmdW5jdGlvbigpe3RoaXMuWGo9ITA7ZGVsZXRlIHRoaXMuZWo7ZGVsZXRlIHRoaXMuaGo7ZGVsZXRlIHRoaXMuYmo7ZGVsZXRlIHRoaXMuYWo7dGhpcy5jb25uZWN0aW9uJiZ0aGlzLmNvbm5lY3Rpb24uY2xvc2UoKX0sa2s6ZnVuY3Rpb24oYyl7YS5YaSE9PWMmJihhLlhpJiYoYS5YaS5zdHlsZS5kaXNwbGF5PSJub25lIiksYS5YaT1jLGEuWGkuc3R5bGUuZGlzcGxheT0iIil9LGNvbm5lY3RlZDpmdW5jdGlvbigpe3JldHVybiBhLmNvbm5lY3Rpb24mJmEuY29ubmVjdGlvbi5yZWFkeVN0YXRlPT09V2ViU29ja2V0Lk9QRU59LEVqOmZ1bmN0aW9uKCl7YS5jb25uZWN0ZWQoKSYmCmEuY29ubmVjdGlvbi5zZW5kKEpTT04uc3RyaW5naWZ5KHtjb21tYW5kOiJTRVJWRVJfU0lERV9DTElFTlRfSU5GTyIsd2lkdGg6YS4kaSphLlFpLGhlaWdodDphLlppKmEuUWksbGF5b3V0V2lkdGg6YS5naixsYXlvdXRIZWlnaHQ6YS5maixlbmNvZGluZzoianBlZyJ9KSl9LExrOmZ1bmN0aW9uKGMsZCxlLGYpezA+PWN8fDA+PWR8fDA+PWV8fDA+PWZ8fGEuJGk9PT1jJiZhLlppPT09ZCYmYS5naj09PWUmJmEuZmo9PT1mfHwoYS4kaT1jLGEuWmk9ZCxhLmdqPWUsYS5maj1mLGEuY29ubmVjdGVkKCkmJih2b2lkIDAhPT1hLkRqJiZ3aW5kb3cuY2xlYXJUaW1lb3V0KGEuRGopLGEuRGo9c2V0VGltZW91dChmdW5jdGlvbigpe2EuWGp8fChhLkRqPXZvaWQgMCxhLkVqKCkpfSw1MDApKSl9LEtrOmZ1bmN0aW9uKGMpe2EuY29ubmVjdGVkKCkmJmEuY29ubmVjdGlvbi5zZW5kKGMpfSxQazpmdW5jdGlvbihjKXthLmVqPWN9LFFrOmZ1bmN0aW9uKGMpe2EuaGo9Y30sT2s6ZnVuY3Rpb24oYyl7YS5iaj0KY30sTms6ZnVuY3Rpb24oYyl7YS5haj1jfSxGazpmdW5jdGlvbihjKXthLmJqJiZhLmJqKGMpfSxSazpmdW5jdGlvbihjKXt2YXIgZD17Y29tbWFuZDoiU0VSVkVSX1NFVFRJTkdTIn0sZTtmb3IoZSBpbiBjKWlmKGMuaGFzT3duUHJvcGVydHkoZSkpe2lmKCJzY2FsZUhpZ2giPT09ZSl7dmFyIGY9Y1tlXTtpZigibnVtYmVyIiE9PXR5cGVvZiBmKWNvbnRpbnVlO2Y9TWF0aC5taW4oMSxmKTswPj1mJiYoZj0xKTthLlFpIT09ZiYmKGEuUWk9ZixhLkVqKCkpfSJqcGVnUXVhbGl0eUhpZ2giIT09ZSYmImpwZWdRdWFsaXR5TG93IiE9PWUmJiJqcGVnQ2hyb21hU2FtcGxlc0hpZ2giIT09ZSYmImpwZWdDaHJvbWFTYW1wbGVzTG93IiE9PWUmJiJzY2FsZUxvdyIhPT1lfHwibnVtYmVyIiE9PXR5cGVvZiBjW2VdfHwoZFtlXT1hLmRrW2VdPWNbZV0pfWEuY29ubmVjdGVkKCkmJmEuY29ubmVjdGlvbi5zZW5kKEpTT04uc3RyaW5naWZ5KGQpKX0sY29ubmVjdDpmdW5jdGlvbihjKXt2YXIgZD1nLiQkZXMuZ2V0TmV0d29ya1ZlcnNpb24oKTsKYS5jb25uZWN0aW9uPW5ldyBXZWJTb2NrZXQoYy51cmksWyJiaW5hcnkiXSk7YS5jb25uZWN0aW9uLmJpbmFyeVR5cGU9ImFycmF5YnVmZmVyIjt2YXIgZT0hMTthLmNvbm5lY3Rpb24ub25jbG9zZT1mdW5jdGlvbigpe2cuZ2koIndlYnNvY2tldF9jb25uZWN0aW9uX2Nsb3NlZCIpfTthLmNvbm5lY3Rpb24ub25vcGVuPWZ1bmN0aW9uKCl7ZT0hMDthLmNvbm5lY3Rpb24uc2VuZChKU09OLnN0cmluZ2lmeSh7Y29tbWFuZDoiU0VSVkVSX1NJREVfUkVOREVSIix3aWR0aDphLiRpKmEuUWksaGVpZ2h0OmEuWmkqYS5RaSxsYXlvdXRXaWR0aDphLmdqLGxheW91dEhlaWdodDphLmZqLG1vZGVsOmMubW9kZWwsbmV0d29ya1ZlcnNpb246ZCxzdHJlYW1DdWxsZWQ6ISFjLnN0cmVhbUN1bGxlZCxzdHJlYW1LZXllZERhdGFPbklkbGU6ISFjLnN0cmVhbU1ldGFEYXRhT25JZGxlLHN0cmVhbU5vTGltaXQ6ISFjLnN0cmVhbU5vTGltaXQsc3RyZWFtSW5zdGFuY2VzT25EZW1hbmQ6ISFjLnN0cmVhbUluc3RhbmNlc09uRGVtYW5kLApzdHJlYW1Cb3VuZGluZ1ByZXZpZXdzOiEhYy5zdHJlYW1Cb3VuZGluZ1ByZXZpZXdzLHN0cmVhbU1vZGVsQm91bmRpbmdQcmV2aWV3czohIWMuc3RyZWFtTW9kZWxCb3VuZGluZ1ByZXZpZXdzLHN0cmVhbUluc3RhbmNlQm91bmRpbmdQcmV2aWV3czohIWMuc3RyZWFtSW5zdGFuY2VCb3VuZGluZ1ByZXZpZXdzLHN0cmVhbU9ubHlJbnRlcmVzdGluZ0JvdW5kaW5nUHJldmlld3M6ISFjLnN0cmVhbU9ubHlJbnRlcmVzdGluZ0JvdW5kaW5nUHJldmlld3Msc3RyZWFtRWplY3RlZEJvdW5kaW5nUHJldmlld3M6ISFjLnN0cmVhbUVqZWN0ZWRCb3VuZGluZ1ByZXZpZXdzLGxpbWl0TWlCOmMubGltaXRNaUIsbWVzaExldmVsOmMubWVzaExldmVsLHN0cmVhbUN1dG9mZlNjYWxlOmMuc3RyZWFtQ3V0b2ZmU2NhbGUsc2Vzc2lvblRva2VuOmMuc2Vzc2lvblRva2VufSkpO2EuRWooKTthLmNvbm5lY3Rpb24uc2VuZChKU09OLnN0cmluZ2lmeShhLmRrKSl9O2EuY29ubmVjdGlvbi5vbmVycm9yPWZ1bmN0aW9uKCl7YS5haiYmCmEuYWooZT8ic29ja2V0X2Vycm9yIjoic29ja2V0X29wZW5fZmFpbGVkIil9O2EuY29ubmVjdGlvbi5vbm1lc3NhZ2U9ZnVuY3Rpb24oZil7aWYoIWEuWGomJmYuZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKXt2YXIgbD1uZXcgVWludDhBcnJheShmLmRhdGEpO2Y9bFswXTtpZigxMjM9PT1mKWEuZWomJmEuZWoobCk7ZWxzZSBpZig2OD09PWYpYS5oaiYmYS5oaihsLnN1YmFycmF5KDEpKTtlbHNle2EuY29ubmVjdGlvbi5zZW5kKCd7ImNvbW1hbmQiOiJBQ0sifScpO3ZhciBuPVtsWzFdLGxbMl1dLHE9bFs0XTw8MjR8bFs1XTw8MTZ8bFs2XTw8OHxsWzddLHY9bmV3IFVpbnQ4QXJyYXkobC5zdWJhcnJheSg4LDgrcSkpO2w9bC5zdWJhcnJheSg4K3EpOzA9PT1mJiZiLnZrKGwsbix2KX19fX19LGI9e2NhbnZhczpudWxsLE5qOm51bGwsdmo6ZnVuY3Rpb24oKXt9LGNyZWF0ZUVsZW1lbnQ6ZnVuY3Rpb24oKXt0aGlzLmNhbnZhc3x8KHRoaXMuY2FudmFzPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImNhbnZhcyIpLAp0aGlzLmNhbnZhcy5zZXRBdHRyaWJ1dGUoInN0eWxlIiwiZGlzcGxheTogbm9uZTsgcG9zaXRpb246IGFic29sdXRlOyB0b3A6IDA7IGxlZnQ6IDA7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7IiksdGhpcy5Oaj10aGlzLmNhbnZhcy5nZXRDb250ZXh0KCIyZCIpLGEuUGouYXBwZW5kQ2hpbGQodGhpcy5jYW52YXMpKX0sZHJhd0ltYWdlOmZ1bmN0aW9uKGMsZCl7dmFyIGU9Yy53aWR0aC1kWzBdO2Q9Yy5oZWlnaHQtZFsxXTt0aGlzLmNhbnZhcy53aWR0aCE9PWUmJih0aGlzLmNhbnZhcy53aWR0aD1lKTt0aGlzLmNhbnZhcy5oZWlnaHQhPT1kJiYodGhpcy5jYW52YXMuaGVpZ2h0PWQpO3RoaXMuTmouZHJhd0ltYWdlKGMsMCwwKX0sbms6ZnVuY3Rpb24oYyxkLGUpe3ZhciBmPWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImltZyIpO3RoaXMuRGs9ZjtmLm9ubG9hZD1mdW5jdGlvbigpe2Y9PT1iLkRrJiYoYi5kcmF3SW1hZ2UoZixkKSxhLmtrKGIuY2FudmFzKSxhLkZrKGUpKTtVUkwucmV2b2tlT2JqZWN0VVJMKGMpfTsKZi5vbmVycm9yPWZ1bmN0aW9uKCl7VVJMLnJldm9rZU9iamVjdFVSTChjKX07Zi5zcmM9YztyZXR1cm4gZn0sdms6ZnVuY3Rpb24oYyxkLGUpezEyPj1jLmJ5dGVMZW5ndGh8fCh0aGlzLmNyZWF0ZUVsZW1lbnQoKSx0aGlzLm5rKFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW2NdLHt0eXBlOiJpbWFnZS9qcGVnIn0pKSxkLGUpKX19O3JldHVybiBhfTt2YXIgeGE9T2JqZWN0LmFzc2lnbih7fSxnKSx6YT0iLi90aGlzLnByb2dyYW0iLEVhPShhLGIpPT57dGhyb3cgYjt9LEZhPSJvYmplY3QiPT10eXBlb2Ygd2luZG93LEdhPSJmdW5jdGlvbiI9PXR5cGVvZiBpbXBvcnRTY3JpcHRzLEhhPSJvYmplY3QiPT10eXBlb2YgcHJvY2VzcyYmIm9iamVjdCI9PXR5cGVvZiBwcm9jZXNzLnZlcnNpb25zJiYic3RyaW5nIj09dHlwZW9mIHByb2Nlc3MudmVyc2lvbnMubm9kZSxMYT0iIixNYSxOYSxQYTsKaWYoSGEpe0xhPUdhP3JlcXVpcmUoInBhdGgiKS5kaXJuYW1lKExhKSsiLyI6X19kaXJuYW1lKyIvIjt2YXIgZnMsUWE7ImZ1bmN0aW9uIj09PXR5cGVvZiByZXF1aXJlJiYoZnM9cmVxdWlyZSgiZnMiKSxRYT1yZXF1aXJlKCJwYXRoIikpO01hPShhLGIpPT57YT1RYS5ub3JtYWxpemUoYSk7cmV0dXJuIGZzLnJlYWRGaWxlU3luYyhhLGI/dm9pZCAwOiJ1dGY4Iil9O1BhPWE9PnthPU1hKGEsITApO2EuYnVmZmVyfHwoYT1uZXcgVWludDhBcnJheShhKSk7cmV0dXJuIGF9O05hPShhLGIsYyk9PnthPVFhLm5vcm1hbGl6ZShhKTtmcy5yZWFkRmlsZShhLGZ1bmN0aW9uKGQsZSl7ZD9jKGQpOmIoZS5idWZmZXIpfSl9OzE8cHJvY2Vzcy5hcmd2Lmxlbmd0aCYmKHphPXByb2Nlc3MuYXJndlsxXS5yZXBsYWNlKC9cXC9nLCIvIikpO3Byb2Nlc3MuYXJndi5zbGljZSgyKTtwcm9jZXNzLm9uKCJ1bmNhdWdodEV4Y2VwdGlvbiIsZnVuY3Rpb24oYSl7aWYoIShhIGluc3RhbmNlb2YgUmEpKXRocm93IGE7Cn0pO3Byb2Nlc3Mub24oInVuaGFuZGxlZFJlamVjdGlvbiIsZnVuY3Rpb24oYSl7dGhyb3cgYTt9KTtFYT0oYSxiKT0+e2lmKG5vRXhpdFJ1bnRpbWUpdGhyb3cgcHJvY2Vzcy5leGl0Q29kZT1hLGI7YiBpbnN0YW5jZW9mIFJhfHxTYSgiZXhpdGluZyBkdWUgdG8gZXhjZXB0aW9uOiAiK2IpO3Byb2Nlc3MuZXhpdChhKX07Zy5pbnNwZWN0PWZ1bmN0aW9uKCl7cmV0dXJuIltFbXNjcmlwdGVuIE1vZHVsZSBvYmplY3RdIn19ZWxzZSBpZihGYXx8R2EpR2E/TGE9c2VsZi5sb2NhdGlvbi5ocmVmOiJ1bmRlZmluZWQiIT10eXBlb2YgZG9jdW1lbnQmJmRvY3VtZW50LmN1cnJlbnRTY3JpcHQmJihMYT1kb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyYyksX3NjcmlwdERpciYmKExhPV9zY3JpcHREaXIpLDAhPT1MYS5pbmRleE9mKCJibG9iOiIpP0xhPUxhLnN1YnN0cigwLExhLnJlcGxhY2UoL1s/I10uKi8sIiIpLmxhc3RJbmRleE9mKCIvIikrMSk6TGE9IiIsTWE9YT0+e3ZhciBiPW5ldyBYTUxIdHRwUmVxdWVzdDsKYi5vcGVuKCJHRVQiLGEsITEpO2Iuc2VuZChudWxsKTtyZXR1cm4gYi5yZXNwb25zZVRleHR9LEdhJiYoUGE9YT0+e3ZhciBiPW5ldyBYTUxIdHRwUmVxdWVzdDtiLm9wZW4oIkdFVCIsYSwhMSk7Yi5yZXNwb25zZVR5cGU9ImFycmF5YnVmZmVyIjtiLnNlbmQobnVsbCk7cmV0dXJuIG5ldyBVaW50OEFycmF5KGIucmVzcG9uc2UpfSksTmE9KGEsYixjKT0+e3ZhciBkPW5ldyBYTUxIdHRwUmVxdWVzdDtkLm9wZW4oIkdFVCIsYSwhMCk7ZC5yZXNwb25zZVR5cGU9ImFycmF5YnVmZmVyIjtkLm9ubG9hZD0oKT0+ezIwMD09ZC5zdGF0dXN8fDA9PWQuc3RhdHVzJiZkLnJlc3BvbnNlP2IoZC5yZXNwb25zZSk6YygpfTtkLm9uZXJyb3I9YztkLnNlbmQobnVsbCl9O3ZhciBVYT1nLnByaW50fHxjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpLFNhPWcucHJpbnRFcnJ8fGNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpO09iamVjdC5hc3NpZ24oZyx4YSk7eGE9bnVsbDsKZy50aGlzUHJvZ3JhbSYmKHphPWcudGhpc1Byb2dyYW0pO2cucXVpdCYmKEVhPWcucXVpdCk7dmFyIFZhO2cud2FzbUJpbmFyeSYmKFZhPWcud2FzbUJpbmFyeSk7dmFyIG5vRXhpdFJ1bnRpbWU9Zy5ub0V4aXRSdW50aW1lfHwhMDsib2JqZWN0IiE9dHlwZW9mIFdlYkFzc2VtYmx5JiZXYSgibm8gbmF0aXZlIHdhc20gc3VwcG9ydCBkZXRlY3RlZCIpO3ZhciBYYSxiYj0hMSxjYj0idW5kZWZpbmVkIiE9dHlwZW9mIFRleHREZWNvZGVyP25ldyBUZXh0RGVjb2RlcigidXRmOCIpOnZvaWQgMDsKZnVuY3Rpb24gd2EoYSxiLGMpe3ZhciBkPWIrYztmb3IoYz1iO2FbY10mJiEoYz49ZCk7KSsrYztpZigxNjxjLWImJmEuYnVmZmVyJiZjYilyZXR1cm4gY2IuZGVjb2RlKGEuc3ViYXJyYXkoYixjKSk7Zm9yKGQ9IiI7YjxjOyl7dmFyIGU9YVtiKytdO2lmKGUmMTI4KXt2YXIgZj1hW2IrK10mNjM7aWYoMTkyPT0oZSYyMjQpKWQrPVN0cmluZy5mcm9tQ2hhckNvZGUoKGUmMzEpPDw2fGYpO2Vsc2V7dmFyIGw9YVtiKytdJjYzO2U9MjI0PT0oZSYyNDApPyhlJjE1KTw8MTJ8Zjw8NnxsOihlJjcpPDwxOHxmPDwxMnxsPDw2fGFbYisrXSY2Mzs2NTUzNj5lP2QrPVN0cmluZy5mcm9tQ2hhckNvZGUoZSk6KGUtPTY1NTM2LGQrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8ZT4+MTAsNTYzMjB8ZSYxMDIzKSl9fWVsc2UgZCs9U3RyaW5nLmZyb21DaGFyQ29kZShlKX1yZXR1cm4gZH1mdW5jdGlvbiBkYihhLGIpe3JldHVybiBhP3dhKHQsYSxiKToiIn0KZnVuY3Rpb24gZWIoYSxiLGMsZCl7aWYoISgwPGQpKXJldHVybiAwO3ZhciBlPWM7ZD1jK2QtMTtmb3IodmFyIGY9MDtmPGEubGVuZ3RoOysrZil7dmFyIGw9YS5jaGFyQ29kZUF0KGYpO2lmKDU1Mjk2PD1sJiY1NzM0Mz49bCl7dmFyIG49YS5jaGFyQ29kZUF0KCsrZik7bD02NTUzNisoKGwmMTAyMyk8PDEwKXxuJjEwMjN9aWYoMTI3Pj1sKXtpZihjPj1kKWJyZWFrO2JbYysrXT1sfWVsc2V7aWYoMjA0Nz49bCl7aWYoYysxPj1kKWJyZWFrO2JbYysrXT0xOTJ8bD4+Nn1lbHNle2lmKDY1NTM1Pj1sKXtpZihjKzI+PWQpYnJlYWs7YltjKytdPTIyNHxsPj4xMn1lbHNle2lmKGMrMz49ZClicmVhaztiW2MrK109MjQwfGw+PjE4O2JbYysrXT0xMjh8bD4+MTImNjN9YltjKytdPTEyOHxsPj42JjYzfWJbYysrXT0xMjh8bCY2M319YltjXT0wO3JldHVybiBjLWV9CmZ1bmN0aW9uIGZiKGEpe2Zvcih2YXIgYj0wLGM9MDtjPGEubGVuZ3RoOysrYyl7dmFyIGQ9YS5jaGFyQ29kZUF0KGMpOzEyNz49ZD9iKys6MjA0Nz49ZD9iKz0yOjU1Mjk2PD1kJiY1NzM0Mz49ZD8oYis9NCwrK2MpOmIrPTN9cmV0dXJuIGJ9dmFyIGdiLGpiLHQsa2IsbGIsRCxoLEIsaGE7ZnVuY3Rpb24gbWIoKXt2YXIgYT1YYS5idWZmZXI7Z2I9YTtnLkhFQVA4PWpiPW5ldyBJbnQ4QXJyYXkoYSk7Zy5IRUFQMTY9a2I9bmV3IEludDE2QXJyYXkoYSk7Zy5IRUFQMzI9RD1uZXcgSW50MzJBcnJheShhKTtnLkhFQVBVOD10PW5ldyBVaW50OEFycmF5KGEpO2cuSEVBUFUxNj1sYj1uZXcgVWludDE2QXJyYXkoYSk7Zy5IRUFQVTMyPWg9bmV3IFVpbnQzMkFycmF5KGEpO2cuSEVBUEYzMj1CPW5ldyBGbG9hdDMyQXJyYXkoYSk7Zy5IRUFQRjY0PWhhPW5ldyBGbG9hdDY0QXJyYXkoYSl9dmFyIG5iLG9iPVtdLHBiPVtdLHJiPVtdLHNiPVtdOwpmdW5jdGlvbiB0Yigpe3ZhciBhPWcucHJlUnVuLnNoaWZ0KCk7b2IudW5zaGlmdChhKX12YXIgdWI9MCx2Yj1udWxsLHdiPW51bGw7ZnVuY3Rpb24geGIoKXt1YisrO2cubW9uaXRvclJ1bkRlcGVuZGVuY2llcyYmZy5tb25pdG9yUnVuRGVwZW5kZW5jaWVzKHViKX1mdW5jdGlvbiB5Yigpe3ViLS07Zy5tb25pdG9yUnVuRGVwZW5kZW5jaWVzJiZnLm1vbml0b3JSdW5EZXBlbmRlbmNpZXModWIpO2lmKDA9PXViJiYobnVsbCE9PXZiJiYoY2xlYXJJbnRlcnZhbCh2YiksdmI9bnVsbCksd2IpKXt2YXIgYT13Yjt3Yj1udWxsO2EoKX19ZnVuY3Rpb24gV2EoYSl7aWYoZy5vbkFib3J0KWcub25BYm9ydChhKTthPSJBYm9ydGVkKCIrYSsiKSI7U2EoYSk7YmI9ITA7YT1uZXcgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yKGErIi4gQnVpbGQgd2l0aCAtc0FTU0VSVElPTlMgZm9yIG1vcmUgaW5mby4iKTtmYShhKTt0aHJvdyBhO30KZnVuY3Rpb24gemIoKXtyZXR1cm4gRGIuc3RhcnRzV2l0aCgiZGF0YTphcHBsaWNhdGlvbi9vY3RldC1zdHJlYW07YmFzZTY0LCIpfXZhciBEYjtpZihnLmxvY2F0ZUZpbGUpe2lmKERiPSJlbmdpbmUuZXNtLndhc20iLCF6YigpKXt2YXIgRWI9RGI7RGI9Zy5sb2NhdGVGaWxlP2cubG9jYXRlRmlsZShFYixMYSk6TGErRWJ9fWVsc2UgRGI9KG5ldyBVUkwoImVuZ2luZS5lc20ud2FzbSIsaW1wb3J0Lm1ldGEudXJsKSkudG9TdHJpbmcoKTtmdW5jdGlvbiBGYigpe3ZhciBhPURiO3RyeXtpZihhPT1EYiYmVmEpcmV0dXJuIG5ldyBVaW50OEFycmF5KFZhKTtpZihQYSlyZXR1cm4gUGEoYSk7dGhyb3ciYm90aCBhc3luYyBhbmQgc3luYyBmZXRjaGluZyBvZiB0aGUgd2FzbSBmYWlsZWQiO31jYXRjaChiKXtXYShiKX19CmZ1bmN0aW9uIEdiKCl7aWYoIVZhJiYoRmF8fEdhKSl7aWYoImZ1bmN0aW9uIj09dHlwZW9mIGZldGNoJiYhRGIuc3RhcnRzV2l0aCgiZmlsZTovLyIpKXJldHVybiBmZXRjaChEYix7Y3JlZGVudGlhbHM6InNhbWUtb3JpZ2luIn0pLnRoZW4oZnVuY3Rpb24oYSl7aWYoIWEub2spdGhyb3ciZmFpbGVkIHRvIGxvYWQgd2FzbSBiaW5hcnkgZmlsZSBhdCAnIitEYisiJyI7cmV0dXJuIGEuYXJyYXlCdWZmZXIoKX0pLmNhdGNoKGZ1bmN0aW9uKCl7cmV0dXJuIEZiKCl9KTtpZihOYSlyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oYSxiKXtOYShEYixmdW5jdGlvbihjKXthKG5ldyBVaW50OEFycmF5KGMpKX0sYil9KX1yZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbihmdW5jdGlvbigpe3JldHVybiBGYigpfSl9CnZhciBIYixJYixKYj17NzI2Mzg0OigpPT57Y29uc29sZS5sb2coIlJQQyBwYXJzaW5nIGZhaWxlZCIpfSw3MjY0MjM6KGEsYik9PntnLiQkZmFjYWRlJiYoaGFbYT4+M109Zy4kJGZhY2FkZS5jb250YWluZXIuY2xpZW50V2lkdGgsaGFbYj4+M109Zy4kJGZhY2FkZS5jb250YWluZXIuY2xpZW50SGVpZ2h0KX0sNzI2NTg0OigpPT57dHJ5e3ZhciBhPXdpbmRvdy5ib3dzZXI7cmV0dXJuIGEmJmEud2luZG93cyYmKGEud2Via2l0fHxhLmJsaW5rfHxhLmdlY2tvKT8xOjB9Y2F0Y2goYil7cmV0dXJuIDF9fSw3MjY3NTc6KCk9Pnt0cnl7dmFyIGE9d2luZG93LmJvd3NlcjtpZighKGEmJmEud2luZG93cyYmKGEuY2hyb21lJiYwPD1hLmNvbXBhcmVWZXJzaW9ucyhbYS52ZXJzaW9uLCI1NSJdKSYmMD5hLmNvbXBhcmVWZXJzaW9ucyhbYS52ZXJzaW9uLCI1NyJdKXx8YS5maXJlZm94JiYwPD1hLmNvbXBhcmVWZXJzaW9ucyhbYS52ZXJzaW9uLCI1MSJdKSYmMD5hLmNvbXBhcmVWZXJzaW9ucyhbYS52ZXJzaW9uLAoiNTgiXSkpKSlyZXR1cm4gMH1jYXRjaChlKXtyZXR1cm4gMH10cnl7dmFyIGI9Zy5SaSxjPWIuZ2V0RXh0ZW5zaW9uKCJXRUJHTF9kZWJ1Z19yZW5kZXJlcl9pbmZvIik7aWYoYyl7dmFyIGQ9Yi5nZXRQYXJhbWV0ZXIoYy5VTk1BU0tFRF9SRU5ERVJFUl9XRUJHTCk7aWYoIShkJiYwPD1kLmluZGV4T2YoIkFOR0xFIikmJigwPD1kLmluZGV4T2YoIkFNRCIpfHwwPD1kLmluZGV4T2YoIlJhZGVvbiIpKSYmMDw9ZC5pbmRleE9mKCJEaXJlY3QzRDExIikpKXJldHVybiAwfX1jYXRjaChlKXt9cmV0dXJuIDF9fTtmdW5jdGlvbiBSYShhKXt0aGlzLm5hbWU9IkV4aXRTdGF0dXMiO3RoaXMubWVzc2FnZT0iUHJvZ3JhbSB0ZXJtaW5hdGVkIHdpdGggZXhpdCgiK2ErIikiO3RoaXMuc3RhdHVzPWF9ZnVuY3Rpb24gS2IoYSl7Zm9yKDswPGEubGVuZ3RoOylhLnNoaWZ0KCkoZyl9CnZhciBMYj1bXSxNYj1bXSxRYj0oYSxiKT0+e2Zvcih2YXIgYz0wLGQ9YS5sZW5ndGgtMTswPD1kO2QtLSl7dmFyIGU9YVtkXTsiLiI9PT1lP2Euc3BsaWNlKGQsMSk6Ii4uIj09PWU/KGEuc3BsaWNlKGQsMSksYysrKTpjJiYoYS5zcGxpY2UoZCwxKSxjLS0pfWlmKGIpZm9yKDtjO2MtLSlhLnVuc2hpZnQoIi4uIik7cmV0dXJuIGF9LFJiPWE9Pnt2YXIgYj0iLyI9PT1hLmNoYXJBdCgwKSxjPSIvIj09PWEuc3Vic3RyKC0xKTsoYT1RYihhLnNwbGl0KCIvIikuZmlsdGVyKGQ9PiEhZCksIWIpLmpvaW4oIi8iKSl8fGJ8fChhPSIuIik7YSYmYyYmKGErPSIvIik7cmV0dXJuKGI/Ii8iOiIiKSthfSxTYj1hPT57dmFyIGI9L14oXC8/fCkoW1xzXFNdKj8pKCg/OlwuezEsMn18W15cL10rP3wpKFwuW14uXC9dKnwpKSg/OltcL10qKSQvLmV4ZWMoYSkuc2xpY2UoMSk7YT1iWzBdO2I9YlsxXTtpZighYSYmIWIpcmV0dXJuIi4iO2ImJihiPWIuc3Vic3RyKDAsYi5sZW5ndGgtMSkpO3JldHVybiBhKwpifSxUYj1hPT57aWYoIi8iPT09YSlyZXR1cm4iLyI7YT1SYihhKTthPWEucmVwbGFjZSgvXC8kLywiIik7dmFyIGI9YS5sYXN0SW5kZXhPZigiLyIpO3JldHVybi0xPT09Yj9hOmEuc3Vic3RyKGIrMSl9O2Z1bmN0aW9uIFViKCl7aWYoIm9iamVjdCI9PXR5cGVvZiBjcnlwdG8mJiJmdW5jdGlvbiI9PXR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKXt2YXIgYT1uZXcgVWludDhBcnJheSgxKTtyZXR1cm4oKT0+e2NyeXB0by5nZXRSYW5kb21WYWx1ZXMoYSk7cmV0dXJuIGFbMF19fWlmKEhhKXRyeXt2YXIgYj1yZXF1aXJlKCJjcnlwdG8iKTtyZXR1cm4oKT0+Yi5yYW5kb21CeXRlcygxKVswXX1jYXRjaChjKXt9cmV0dXJuKCk9PldhKCJyYW5kb21EZXZpY2UiKX0KZnVuY3Rpb24gVmIoKXtmb3IodmFyIGE9IiIsYj0hMSxjPWFyZ3VtZW50cy5sZW5ndGgtMTstMTw9YyYmIWI7Yy0tKXtiPTA8PWM/YXJndW1lbnRzW2NdOiIvIjtpZigic3RyaW5nIiE9dHlwZW9mIGIpdGhyb3cgbmV3IFR5cGVFcnJvcigiQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MiKTtpZighYilyZXR1cm4iIjthPWIrIi8iK2E7Yj0iLyI9PT1iLmNoYXJBdCgwKX1hPVFiKGEuc3BsaXQoIi8iKS5maWx0ZXIoZD0+ISFkKSwhYikuam9pbigiLyIpO3JldHVybihiPyIvIjoiIikrYXx8Ii4ifWZ1bmN0aW9uIFdiKGEsYil7dmFyIGM9QXJyYXkoZmIoYSkrMSk7YT1lYihhLGMsMCxjLmxlbmd0aCk7YiYmKGMubGVuZ3RoPWEpO3JldHVybiBjfXZhciBYYj1bXTtmdW5jdGlvbiBZYihhLGIpe1hiW2FdPXtpbnB1dDpbXSxvdXRwdXQ6W10sUGk6Yn07WmIoYSwkYil9CnZhciAkYj17b3BlbjpmdW5jdGlvbihhKXt2YXIgYj1YYlthLm5vZGUucmRldl07aWYoIWIpdGhyb3cgbmV3IEkoNDMpO2EudHR5PWI7YS5zZWVrYWJsZT0hMX0sY2xvc2U6ZnVuY3Rpb24oYSl7YS50dHkuUGkuZnN5bmMoYS50dHkpfSxmc3luYzpmdW5jdGlvbihhKXthLnR0eS5QaS5mc3luYyhhLnR0eSl9LHJlYWQ6ZnVuY3Rpb24oYSxiLGMsZCl7aWYoIWEudHR5fHwhYS50dHkuUGkuV2opdGhyb3cgbmV3IEkoNjApO2Zvcih2YXIgZT0wLGY9MDtmPGQ7ZisrKXt0cnl7dmFyIGw9YS50dHkuUGkuV2ooYS50dHkpfWNhdGNoKG4pe3Rocm93IG5ldyBJKDI5KTt9aWYodm9pZCAwPT09bCYmMD09PWUpdGhyb3cgbmV3IEkoNik7aWYobnVsbD09PWx8fHZvaWQgMD09PWwpYnJlYWs7ZSsrO2JbYytmXT1sfWUmJihhLm5vZGUudGltZXN0YW1wPURhdGUubm93KCkpO3JldHVybiBlfSx3cml0ZTpmdW5jdGlvbihhLGIsYyxkKXtpZighYS50dHl8fCFhLnR0eS5QaS5Bail0aHJvdyBuZXcgSSg2MCk7CnRyeXtmb3IodmFyIGU9MDtlPGQ7ZSsrKWEudHR5LlBpLkFqKGEudHR5LGJbYytlXSl9Y2F0Y2goZil7dGhyb3cgbmV3IEkoMjkpO31kJiYoYS5ub2RlLnRpbWVzdGFtcD1EYXRlLm5vdygpKTtyZXR1cm4gZX19LGFjPXtXajpmdW5jdGlvbihhKXtpZighYS5pbnB1dC5sZW5ndGgpe3ZhciBiPW51bGw7aWYoSGEpe3ZhciBjPUJ1ZmZlci5hbGxvYygyNTYpLGQ9MDt0cnl7ZD1mcy5yZWFkU3luYyhwcm9jZXNzLnN0ZGluLmZkLGMsMCwyNTYsLTEpfWNhdGNoKGUpe2lmKGUudG9TdHJpbmcoKS5pbmNsdWRlcygiRU9GIikpZD0wO2Vsc2UgdGhyb3cgZTt9MDxkP2I9Yy5zbGljZSgwLGQpLnRvU3RyaW5nKCJ1dGYtOCIpOmI9bnVsbH1lbHNlInVuZGVmaW5lZCIhPXR5cGVvZiB3aW5kb3cmJiJmdW5jdGlvbiI9PXR5cGVvZiB3aW5kb3cucHJvbXB0PyhiPXdpbmRvdy5wcm9tcHQoIklucHV0OiAiKSxudWxsIT09YiYmKGIrPSJcbiIpKToiZnVuY3Rpb24iPT10eXBlb2YgcmVhZGxpbmUmJihiPQpyZWFkbGluZSgpLG51bGwhPT1iJiYoYis9IlxuIikpO2lmKCFiKXJldHVybiBudWxsO2EuaW5wdXQ9V2IoYiwhMCl9cmV0dXJuIGEuaW5wdXQuc2hpZnQoKX0sQWo6ZnVuY3Rpb24oYSxiKXtudWxsPT09Ynx8MTA9PT1iPyhVYSh3YShhLm91dHB1dCwwKSksYS5vdXRwdXQ9W10pOjAhPWImJmEub3V0cHV0LnB1c2goYil9LGZzeW5jOmZ1bmN0aW9uKGEpe2Eub3V0cHV0JiYwPGEub3V0cHV0Lmxlbmd0aCYmKFVhKHdhKGEub3V0cHV0LDApKSxhLm91dHB1dD1bXSl9fSxiYz17QWo6ZnVuY3Rpb24oYSxiKXtudWxsPT09Ynx8MTA9PT1iPyhTYSh3YShhLm91dHB1dCwwKSksYS5vdXRwdXQ9W10pOjAhPWImJmEub3V0cHV0LnB1c2goYil9LGZzeW5jOmZ1bmN0aW9uKGEpe2Eub3V0cHV0JiYwPGEub3V0cHV0Lmxlbmd0aCYmKFNhKHdhKGEub3V0cHV0LDApKSxhLm91dHB1dD1bXSl9fSxKPXt2aTpudWxsLEFpOmZ1bmN0aW9uKCl7cmV0dXJuIEouY3JlYXRlTm9kZShudWxsLCIvIiwxNjg5NSwKMCl9LGNyZWF0ZU5vZGU6ZnVuY3Rpb24oYSxiLGMsZCl7aWYoMjQ1NzY9PT0oYyY2MTQ0MCl8fDQwOTY9PT0oYyY2MTQ0MCkpdGhyb3cgbmV3IEkoNjMpO0oudml8fChKLnZpPXtkaXI6e25vZGU6e0VpOkouZWkuRWkscmk6Si5laS5yaSxsb29rdXA6Si5laS5sb29rdXAsaWo6Si5laS5paixyZW5hbWU6Si5laS5yZW5hbWUsdW5saW5rOkouZWkudW5saW5rLHJtZGlyOkouZWkucm1kaXIscmVhZGRpcjpKLmVpLnJlYWRkaXIsc3ltbGluazpKLmVpLnN5bWxpbmt9LHN0cmVhbTp7R2k6Si5maS5HaX19LGZpbGU6e25vZGU6e0VpOkouZWkuRWkscmk6Si5laS5yaX0sc3RyZWFtOntHaTpKLmZpLkdpLHJlYWQ6Si5maS5yZWFkLHdyaXRlOkouZmkud3JpdGUsTGo6Si5maS5Maix6ajpKLmZpLnpqLGFrOkouZmkuYWt9fSxsaW5rOntub2RlOntFaTpKLmVpLkVpLHJpOkouZWkucmkscmVhZGxpbms6Si5laS5yZWFkbGlua30sc3RyZWFtOnt9fSxPajp7bm9kZTp7RWk6Si5laS5FaSxyaTpKLmVpLnJpfSwKc3RyZWFtOmNjfX0pO2M9ZGMoYSxiLGMsZCk7MTYzODQ9PT0oYy5tb2RlJjYxNDQwKT8oYy5laT1KLnZpLmRpci5ub2RlLGMuZmk9Si52aS5kaXIuc3RyZWFtLGMuZGk9e30pOjMyNzY4PT09KGMubW9kZSY2MTQ0MCk/KGMuZWk9Si52aS5maWxlLm5vZGUsYy5maT1KLnZpLmZpbGUuc3RyZWFtLGMuaWk9MCxjLmRpPW51bGwpOjQwOTYwPT09KGMubW9kZSY2MTQ0MCk/KGMuZWk9Si52aS5saW5rLm5vZGUsYy5maT1KLnZpLmxpbmsuc3RyZWFtKTo4MTkyPT09KGMubW9kZSY2MTQ0MCkmJihjLmVpPUoudmkuT2oubm9kZSxjLmZpPUoudmkuT2ouc3RyZWFtKTtjLnRpbWVzdGFtcD1EYXRlLm5vdygpO2EmJihhLmRpW2JdPWMsYS50aW1lc3RhbXA9Yy50aW1lc3RhbXApO3JldHVybiBjfSxobDpmdW5jdGlvbihhKXtyZXR1cm4gYS5kaT9hLmRpLnN1YmFycmF5P2EuZGkuc3ViYXJyYXkoMCxhLmlpKTpuZXcgVWludDhBcnJheShhLmRpKTpuZXcgVWludDhBcnJheSgwKX0sVGo6ZnVuY3Rpb24oYSwKYil7dmFyIGM9YS5kaT9hLmRpLmxlbmd0aDowO2M+PWJ8fChiPU1hdGgubWF4KGIsYyooMTA0ODU3Nj5jPzI6MS4xMjUpPj4+MCksMCE9YyYmKGI9TWF0aC5tYXgoYiwyNTYpKSxjPWEuZGksYS5kaT1uZXcgVWludDhBcnJheShiKSwwPGEuaWkmJmEuZGkuc2V0KGMuc3ViYXJyYXkoMCxhLmlpKSwwKSl9LEprOmZ1bmN0aW9uKGEsYil7aWYoYS5paSE9YilpZigwPT1iKWEuZGk9bnVsbCxhLmlpPTA7ZWxzZXt2YXIgYz1hLmRpO2EuZGk9bmV3IFVpbnQ4QXJyYXkoYik7YyYmYS5kaS5zZXQoYy5zdWJhcnJheSgwLE1hdGgubWluKGIsYS5paSkpKTthLmlpPWJ9fSxlaTp7RWk6ZnVuY3Rpb24oYSl7dmFyIGI9e307Yi5kZXY9ODE5Mj09PShhLm1vZGUmNjE0NDApP2EuaWQ6MTtiLmlubz1hLmlkO2IubW9kZT1hLm1vZGU7Yi5ubGluaz0xO2IudWlkPTA7Yi5naWQ9MDtiLnJkZXY9YS5yZGV2OzE2Mzg0PT09KGEubW9kZSY2MTQ0MCk/Yi5zaXplPTQwOTY6MzI3Njg9PT0oYS5tb2RlJjYxNDQwKT8KYi5zaXplPWEuaWk6NDA5NjA9PT0oYS5tb2RlJjYxNDQwKT9iLnNpemU9YS5saW5rLmxlbmd0aDpiLnNpemU9MDtiLmF0aW1lPW5ldyBEYXRlKGEudGltZXN0YW1wKTtiLm10aW1lPW5ldyBEYXRlKGEudGltZXN0YW1wKTtiLmN0aW1lPW5ldyBEYXRlKGEudGltZXN0YW1wKTtiLmxrPTQwOTY7Yi5ibG9ja3M9TWF0aC5jZWlsKGIuc2l6ZS9iLmxrKTtyZXR1cm4gYn0scmk6ZnVuY3Rpb24oYSxiKXt2b2lkIDAhPT1iLm1vZGUmJihhLm1vZGU9Yi5tb2RlKTt2b2lkIDAhPT1iLnRpbWVzdGFtcCYmKGEudGltZXN0YW1wPWIudGltZXN0YW1wKTt2b2lkIDAhPT1iLnNpemUmJkouSmsoYSxiLnNpemUpfSxsb29rdXA6ZnVuY3Rpb24oKXt0aHJvdyBmY1s0NF07fSxpajpmdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4gSi5jcmVhdGVOb2RlKGEsYixjLGQpfSxyZW5hbWU6ZnVuY3Rpb24oYSxiLGMpe2lmKDE2Mzg0PT09KGEubW9kZSY2MTQ0MCkpe3RyeXt2YXIgZD1nYyhiLGMpfWNhdGNoKGYpe31pZihkKWZvcih2YXIgZSBpbiBkLmRpKXRocm93IG5ldyBJKDU1KTsKfWRlbGV0ZSBhLnBhcmVudC5kaVthLm5hbWVdO2EucGFyZW50LnRpbWVzdGFtcD1EYXRlLm5vdygpO2EubmFtZT1jO2IuZGlbY109YTtiLnRpbWVzdGFtcD1hLnBhcmVudC50aW1lc3RhbXA7YS5wYXJlbnQ9Yn0sdW5saW5rOmZ1bmN0aW9uKGEsYil7ZGVsZXRlIGEuZGlbYl07YS50aW1lc3RhbXA9RGF0ZS5ub3coKX0scm1kaXI6ZnVuY3Rpb24oYSxiKXt2YXIgYz1nYyhhLGIpLGQ7Zm9yKGQgaW4gYy5kaSl0aHJvdyBuZXcgSSg1NSk7ZGVsZXRlIGEuZGlbYl07YS50aW1lc3RhbXA9RGF0ZS5ub3coKX0scmVhZGRpcjpmdW5jdGlvbihhKXt2YXIgYj1bIi4iLCIuLiJdLGM7Zm9yKGMgaW4gYS5kaSlhLmRpLmhhc093blByb3BlcnR5KGMpJiZiLnB1c2goYyk7cmV0dXJuIGJ9LHN5bWxpbms6ZnVuY3Rpb24oYSxiLGMpe2E9Si5jcmVhdGVOb2RlKGEsYiw0MTQ3MSwwKTthLmxpbms9YztyZXR1cm4gYX0scmVhZGxpbms6ZnVuY3Rpb24oYSl7aWYoNDA5NjAhPT0oYS5tb2RlJjYxNDQwKSl0aHJvdyBuZXcgSSgyOCk7CnJldHVybiBhLmxpbmt9fSxmaTp7cmVhZDpmdW5jdGlvbihhLGIsYyxkLGUpe3ZhciBmPWEubm9kZS5kaTtpZihlPj1hLm5vZGUuaWkpcmV0dXJuIDA7YT1NYXRoLm1pbihhLm5vZGUuaWktZSxkKTtpZig4PGEmJmYuc3ViYXJyYXkpYi5zZXQoZi5zdWJhcnJheShlLGUrYSksYyk7ZWxzZSBmb3IoZD0wO2Q8YTtkKyspYltjK2RdPWZbZStkXTtyZXR1cm4gYX0sd3JpdGU6ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe2IuYnVmZmVyPT09amIuYnVmZmVyJiYoZj0hMSk7aWYoIWQpcmV0dXJuIDA7YT1hLm5vZGU7YS50aW1lc3RhbXA9RGF0ZS5ub3coKTtpZihiLnN1YmFycmF5JiYoIWEuZGl8fGEuZGkuc3ViYXJyYXkpKXtpZihmKXJldHVybiBhLmRpPWIuc3ViYXJyYXkoYyxjK2QpLGEuaWk9ZDtpZigwPT09YS5paSYmMD09PWUpcmV0dXJuIGEuZGk9Yi5zbGljZShjLGMrZCksYS5paT1kO2lmKGUrZDw9YS5paSlyZXR1cm4gYS5kaS5zZXQoYi5zdWJhcnJheShjLGMrZCksZSksZH1KLlRqKGEsZSsKZCk7aWYoYS5kaS5zdWJhcnJheSYmYi5zdWJhcnJheSlhLmRpLnNldChiLnN1YmFycmF5KGMsYytkKSxlKTtlbHNlIGZvcihmPTA7ZjxkO2YrKylhLmRpW2UrZl09YltjK2ZdO2EuaWk9TWF0aC5tYXgoYS5paSxlK2QpO3JldHVybiBkfSxHaTpmdW5jdGlvbihhLGIsYyl7MT09PWM/Yis9YS5wb3NpdGlvbjoyPT09YyYmMzI3Njg9PT0oYS5ub2RlLm1vZGUmNjE0NDApJiYoYis9YS5ub2RlLmlpKTtpZigwPmIpdGhyb3cgbmV3IEkoMjgpO3JldHVybiBifSxMajpmdW5jdGlvbihhLGIsYyl7Si5UaihhLm5vZGUsYitjKTthLm5vZGUuaWk9TWF0aC5tYXgoYS5ub2RlLmlpLGIrYyl9LHpqOmZ1bmN0aW9uKGEsYixjLGQsZSl7aWYoMzI3NjghPT0oYS5ub2RlLm1vZGUmNjE0NDApKXRocm93IG5ldyBJKDQzKTthPWEubm9kZS5kaTtpZihlJjJ8fGEuYnVmZmVyIT09Z2Ipe2lmKDA8Y3x8YytiPGEubGVuZ3RoKWEuc3ViYXJyYXk/YT1hLnN1YmFycmF5KGMsYytiKTphPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGEsCmMsYytiKTtjPSEwO1dhKCk7Yj12b2lkIDA7aWYoIWIpdGhyb3cgbmV3IEkoNDgpO2piLnNldChhLGIpfWVsc2UgYz0hMSxiPWEuYnl0ZU9mZnNldDtyZXR1cm57aGk6YiwkazpjfX0sYWs6ZnVuY3Rpb24oYSxiLGMsZCl7Si5maS53cml0ZShhLGIsMCxkLGMsITEpO3JldHVybiAwfX19O2Z1bmN0aW9uIGhjKGEsYixjKXt2YXIgZD0iYWwgIithO05hKGEsZT0+e2V8fFdhKCdMb2FkaW5nIGRhdGEgZmlsZSAiJythKyciIGZhaWxlZCAobm8gYXJyYXlCdWZmZXIpLicpO2IobmV3IFVpbnQ4QXJyYXkoZSkpO2QmJnliKGQpfSwoKT0+e2lmKGMpYygpO2Vsc2UgdGhyb3cnTG9hZGluZyBkYXRhIGZpbGUgIicrYSsnIiBmYWlsZWQuJzt9KTtkJiZ4YihkKX0KdmFyIGljPW51bGwsamM9e30sa2M9W10sbGM9MSxtYz1udWxsLG5jPSEwLEk9bnVsbCxmYz17fSxwYz0oYSxiPXt9KT0+e2E9VmIoIi8iLGEpO2lmKCFhKXJldHVybntwYXRoOiIiLG5vZGU6bnVsbH07Yj1PYmplY3QuYXNzaWduKHtWajohMCxCajowfSxiKTtpZig4PGIuQmopdGhyb3cgbmV3IEkoMzIpO2E9UWIoYS5zcGxpdCgiLyIpLmZpbHRlcihsPT4hIWwpLCExKTtmb3IodmFyIGM9aWMsZD0iLyIsZT0wO2U8YS5sZW5ndGg7ZSsrKXt2YXIgZj1lPT09YS5sZW5ndGgtMTtpZihmJiZiLnBhcmVudClicmVhaztjPWdjKGMsYVtlXSk7ZD1SYihkKyIvIithW2VdKTtjLlRpJiYoIWZ8fGYmJmIuVmopJiYoYz1jLlRpLnJvb3QpO2lmKCFmfHxiLnJqKWZvcihmPTA7NDA5NjA9PT0oYy5tb2RlJjYxNDQwKTspaWYoYz1vYyhkKSxkPVZiKFNiKGQpLGMpLGM9cGMoZCx7Qmo6Yi5CaisxfSkubm9kZSw0MDxmKyspdGhyb3cgbmV3IEkoMzIpO31yZXR1cm57cGF0aDpkLG5vZGU6Y319LHFjPWE9Pgp7Zm9yKHZhciBiOzspe2lmKGE9PT1hLnBhcmVudClyZXR1cm4gYT1hLkFpLiRqLGI/Ii8iIT09YVthLmxlbmd0aC0xXT9hKyIvIitiOmErYjphO2I9Yj9hLm5hbWUrIi8iK2I6YS5uYW1lO2E9YS5wYXJlbnR9fSxyYz0oYSxiKT0+e2Zvcih2YXIgYz0wLGQ9MDtkPGIubGVuZ3RoO2QrKyljPShjPDw1KS1jK2IuY2hhckNvZGVBdChkKXwwO3JldHVybihhK2M+Pj4wKSVtYy5sZW5ndGh9LGdjPShhLGIpPT57dmFyIGM7aWYoYz0oYz1zYyhhLCJ4IikpP2M6YS5laS5sb29rdXA/MDoyKXRocm93IG5ldyBJKGMsYSk7Zm9yKGM9bWNbcmMoYS5pZCxiKV07YztjPWMuT2kpe3ZhciBkPWMubmFtZTtpZihjLnBhcmVudC5pZD09PWEuaWQmJmQ9PT1iKXJldHVybiBjfXJldHVybiBhLmVpLmxvb2t1cChhLGIpfSxkYz0oYSxiLGMsZCk9PnthPW5ldyB0YyhhLGIsYyxkKTtiPXJjKGEucGFyZW50LmlkLGEubmFtZSk7YS5PaT1tY1tiXTtyZXR1cm4gbWNbYl09YX0sdWM9e3I6MCwicisiOjIsdzo1NzcsCiJ3KyI6NTc4LGE6MTA4OSwiYSsiOjEwOTB9LHZjPWE9Pnt2YXIgYj1bInIiLCJ3IiwicnciXVthJjNdO2EmNTEyJiYoYis9InciKTtyZXR1cm4gYn0sc2M9KGEsYik9PntpZihuYylyZXR1cm4gMDtpZighYi5pbmNsdWRlcygiciIpfHxhLm1vZGUmMjkyKXtpZihiLmluY2x1ZGVzKCJ3IikmJiEoYS5tb2RlJjE0Nil8fGIuaW5jbHVkZXMoIngiKSYmIShhLm1vZGUmNzMpKXJldHVybiAyfWVsc2UgcmV0dXJuIDI7cmV0dXJuIDB9LHdjPShhLGIpPT57dHJ5e3JldHVybiBnYyhhLGIpLDIwfWNhdGNoKGMpe31yZXR1cm4gc2MoYSwid3giKX0seGM9KGE9MCk9Pntmb3IoOzQwOTY+PWE7YSsrKWlmKCFrY1thXSlyZXR1cm4gYTt0aHJvdyBuZXcgSSgzMyk7fSx6Yz0oYSxiKT0+e3ljfHwoeWM9ZnVuY3Rpb24oKXt0aGlzLmxpPXt9fSx5Yy5wcm90b3R5cGU9e30sT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoeWMucHJvdG90eXBlLHtvYmplY3Q6e2dldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGV9LApzZXQ6ZnVuY3Rpb24oYyl7dGhpcy5ub2RlPWN9fSxmbGFnczp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGkuZmxhZ3N9LHNldDpmdW5jdGlvbihjKXt0aGlzLmxpLmZsYWdzPWN9fSxwb3NpdGlvbjp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGkucG9zaXRpb259LHNldDpmdW5jdGlvbihjKXt0aGlzLmxpLnBvc2l0aW9uPWN9fX0pKTthPU9iamVjdC5hc3NpZ24obmV3IHljLGEpO2I9eGMoYik7YS5mZD1iO3JldHVybiBrY1tiXT1hfSxjYz17b3BlbjphPT57YS5maT1qY1thLm5vZGUucmRldl0uZmk7YS5maS5vcGVuJiZhLmZpLm9wZW4oYSl9LEdpOigpPT57dGhyb3cgbmV3IEkoNzApO319LFpiPShhLGIpPT57amNbYV09e2ZpOmJ9fSxBYz0oYSxiKT0+e3ZhciBjPSIvIj09PWIsZD0hYjtpZihjJiZpYyl0aHJvdyBuZXcgSSgxMCk7aWYoIWMmJiFkKXt2YXIgZT1wYyhiLHtWajohMX0pO2I9ZS5wYXRoO2U9ZS5ub2RlO2lmKGUuVGkpdGhyb3cgbmV3IEkoMTApO2lmKDE2Mzg0IT09CihlLm1vZGUmNjE0NDApKXRocm93IG5ldyBJKDU0KTt9Yj17dHlwZTphLG5sOnt9LCRqOmIsRWs6W119O2E9YS5BaShiKTthLkFpPWI7Yi5yb290PWE7Yz9pYz1hOmUmJihlLlRpPWIsZS5BaSYmZS5BaS5Fay5wdXNoKGIpKX0sQmM9KGEsYixjKT0+e3ZhciBkPXBjKGEse3BhcmVudDohMH0pLm5vZGU7YT1UYihhKTtpZighYXx8Ii4iPT09YXx8Ii4uIj09PWEpdGhyb3cgbmV3IEkoMjgpO3ZhciBlPXdjKGQsYSk7aWYoZSl0aHJvdyBuZXcgSShlKTtpZighZC5laS5pail0aHJvdyBuZXcgSSg2Myk7cmV0dXJuIGQuZWkuaWooZCxhLGIsYyl9LENjPShhLGIsYyk9PnsidW5kZWZpbmVkIj09dHlwZW9mIGMmJihjPWIsYj00MzgpO3JldHVybiBCYyhhLGJ8ODE5MixjKX0sRGM9KGEsYik9PntpZighVmIoYSkpdGhyb3cgbmV3IEkoNDQpO3ZhciBjPXBjKGIse3BhcmVudDohMH0pLm5vZGU7aWYoIWMpdGhyb3cgbmV3IEkoNDQpO2I9VGIoYik7dmFyIGQ9d2MoYyxiKTtpZihkKXRocm93IG5ldyBJKGQpOwppZighYy5laS5zeW1saW5rKXRocm93IG5ldyBJKDYzKTtjLmVpLnN5bWxpbmsoYyxiLGEpfSxFYz1hPT57dmFyIGI9cGMoYSx7cGFyZW50OiEwfSkubm9kZTtpZighYil0aHJvdyBuZXcgSSg0NCk7dmFyIGM9VGIoYSk7YT1nYyhiLGMpO2E6e3RyeXt2YXIgZD1nYyhiLGMpfWNhdGNoKGYpe2Q9Zi5EaTticmVhayBhfXZhciBlPXNjKGIsInd4Iik7ZD1lP2U6MTYzODQ9PT0oZC5tb2RlJjYxNDQwKT8zMTowfWlmKGQpdGhyb3cgbmV3IEkoZCk7aWYoIWIuZWkudW5saW5rKXRocm93IG5ldyBJKDYzKTtpZihhLlRpKXRocm93IG5ldyBJKDEwKTtiLmVpLnVubGluayhiLGMpO2I9cmMoYS5wYXJlbnQuaWQsYS5uYW1lKTtpZihtY1tiXT09PWEpbWNbYl09YS5PaTtlbHNlIGZvcihiPW1jW2JdO2I7KXtpZihiLk9pPT09YSl7Yi5PaT1hLk9pO2JyZWFrfWI9Yi5PaX19LG9jPWE9PnthPXBjKGEpLm5vZGU7aWYoIWEpdGhyb3cgbmV3IEkoNDQpO2lmKCFhLmVpLnJlYWRsaW5rKXRocm93IG5ldyBJKDI4KTsKcmV0dXJuIFZiKHFjKGEucGFyZW50KSxhLmVpLnJlYWRsaW5rKGEpKX0sRmM9KGEsYik9PnthPSJzdHJpbmciPT10eXBlb2YgYT9wYyhhLHtyajohMH0pLm5vZGU6YTtpZighYS5laS5yaSl0aHJvdyBuZXcgSSg2Myk7YS5laS5yaShhLHttb2RlOmImNDA5NXxhLm1vZGUmLTQwOTYsdGltZXN0YW1wOkRhdGUubm93KCl9KX0sSGM9KGEsYixjKT0+e2lmKCIiPT09YSl0aHJvdyBuZXcgSSg0NCk7aWYoInN0cmluZyI9PXR5cGVvZiBiKXt2YXIgZD11Y1tiXTtpZigidW5kZWZpbmVkIj09dHlwZW9mIGQpdGhyb3cgRXJyb3IoIlVua25vd24gZmlsZSBvcGVuIG1vZGU6ICIrYik7Yj1kfWM9YiY2ND8oInVuZGVmaW5lZCI9PXR5cGVvZiBjPzQzODpjKSY0MDk1fDMyNzY4OjA7aWYoIm9iamVjdCI9PXR5cGVvZiBhKXZhciBlPWE7ZWxzZXthPVJiKGEpO3RyeXtlPXBjKGEse3JqOiEoYiYxMzEwNzIpfSkubm9kZX1jYXRjaChmKXt9fWQ9ITE7aWYoYiY2NClpZihlKXtpZihiJjEyOCl0aHJvdyBuZXcgSSgyMCk7Cn1lbHNlIGU9QmMoYSxjLDApLGQ9ITA7aWYoIWUpdGhyb3cgbmV3IEkoNDQpOzgxOTI9PT0oZS5tb2RlJjYxNDQwKSYmKGImPS01MTMpO2lmKGImNjU1MzYmJjE2Mzg0IT09KGUubW9kZSY2MTQ0MCkpdGhyb3cgbmV3IEkoNTQpO2lmKCFkJiYoYz1lPzQwOTYwPT09KGUubW9kZSY2MTQ0MCk/MzI6MTYzODQ9PT0oZS5tb2RlJjYxNDQwKSYmKCJyIiE9PXZjKGIpfHxiJjUxMik/MzE6c2MoZSx2YyhiKSk6NDQpKXRocm93IG5ldyBJKGMpO2lmKGImNTEyJiYhZCl7Yz1lO2M9InN0cmluZyI9PXR5cGVvZiBjP3BjKGMse3JqOiEwfSkubm9kZTpjO2lmKCFjLmVpLnJpKXRocm93IG5ldyBJKDYzKTtpZigxNjM4ND09PShjLm1vZGUmNjE0NDApKXRocm93IG5ldyBJKDMxKTtpZigzMjc2OCE9PShjLm1vZGUmNjE0NDApKXRocm93IG5ldyBJKDI4KTtpZihkPXNjKGMsInciKSl0aHJvdyBuZXcgSShkKTtjLmVpLnJpKGMse3NpemU6MCx0aW1lc3RhbXA6RGF0ZS5ub3coKX0pfWImPS0xMzE3MTM7ZT0KemMoe25vZGU6ZSxwYXRoOnFjKGUpLGZsYWdzOmIsc2Vla2FibGU6ITAscG9zaXRpb246MCxmaTplLmZpLFlrOltdLGVycm9yOiExfSk7ZS5maS5vcGVuJiZlLmZpLm9wZW4oZSk7IWcubG9nUmVhZEZpbGVzfHxiJjF8fChHY3x8KEdjPXt9KSxhIGluIEdjfHwoR2NbYV09MSkpO3JldHVybiBlfSxJYz1hPT57aWYobnVsbD09PWEuZmQpdGhyb3cgbmV3IEkoOCk7YS5zaiYmKGEuc2o9bnVsbCk7dHJ5e2EuZmkuY2xvc2UmJmEuZmkuY2xvc2UoYSl9Y2F0Y2goYil7dGhyb3cgYjt9ZmluYWxseXtrY1thLmZkXT1udWxsfWEuZmQ9bnVsbH0sSmM9KGEsYixjKT0+e2lmKG51bGw9PT1hLmZkKXRocm93IG5ldyBJKDgpO2lmKCFhLnNlZWthYmxlfHwhYS5maS5HaSl0aHJvdyBuZXcgSSg3MCk7aWYoMCE9YyYmMSE9YyYmMiE9Yyl0aHJvdyBuZXcgSSgyOCk7YS5wb3NpdGlvbj1hLmZpLkdpKGEsYixjKTthLllrPVtdfSxPYz0oYSxiLGMsZCxlLGYpPT57aWYoMD5kfHwwPmUpdGhyb3cgbmV3IEkoMjgpOwppZihudWxsPT09YS5mZCl0aHJvdyBuZXcgSSg4KTtpZigwPT09KGEuZmxhZ3MmMjA5NzE1NSkpdGhyb3cgbmV3IEkoOCk7aWYoMTYzODQ9PT0oYS5ub2RlLm1vZGUmNjE0NDApKXRocm93IG5ldyBJKDMxKTtpZighYS5maS53cml0ZSl0aHJvdyBuZXcgSSgyOCk7YS5zZWVrYWJsZSYmYS5mbGFncyYxMDI0JiZKYyhhLDAsMik7dmFyIGw9InVuZGVmaW5lZCIhPXR5cGVvZiBlO2lmKCFsKWU9YS5wb3NpdGlvbjtlbHNlIGlmKCFhLnNlZWthYmxlKXRocm93IG5ldyBJKDcwKTtiPWEuZmkud3JpdGUoYSxiLGMsZCxlLGYpO2x8fChhLnBvc2l0aW9uKz1iKTtyZXR1cm4gYn0sUGM9KCk9PntJfHwoST1mdW5jdGlvbihhLGIpe3RoaXMubm9kZT1iO3RoaXMuTWs9ZnVuY3Rpb24oYyl7dGhpcy5EaT1jfTt0aGlzLk1rKGEpO3RoaXMubWVzc2FnZT0iRlMgZXJyb3IifSxJLnByb3RvdHlwZT1FcnJvcigpLEkucHJvdG90eXBlLmNvbnN0cnVjdG9yPUksWzQ0XS5mb3JFYWNoKGE9PntmY1thXT1uZXcgSShhKTsKZmNbYV0uc3RhY2s9IjxnZW5lcmljIGVycm9yLCBubyBzdGFjaz4ifSkpfSxRYyxSYz0oYSxiKT0+e3ZhciBjPTA7YSYmKGN8PTM2NSk7YiYmKGN8PTE0Nik7cmV0dXJuIGN9LFNjPShhLGIpPT57YT0ic3RyaW5nIj09dHlwZW9mIGE/YTpxYyhhKTtmb3IoYj1iLnNwbGl0KCIvIikucmV2ZXJzZSgpO2IubGVuZ3RoOyl7dmFyIGM9Yi5wb3AoKTtpZihjKXt2YXIgZD1SYihhKyIvIitjKTt0cnl7QmMoZCwxNjg5NSwwKX1jYXRjaChlKXt9YT1kfX1yZXR1cm4gZH0sVGM9KGEsYixjLGQpPT57YT1SYigoInN0cmluZyI9PXR5cGVvZiBhP2E6cWMoYSkpKyIvIitiKTtjPVJjKGMsZCk7cmV0dXJuIEJjKGEsKHZvaWQgMCE9PWM/Yzo0MzgpJjQwOTV8MzI3NjgsMCl9LFVjPShhLGIsYyxkLGUsZik9Pnt2YXIgbD1iO2EmJihhPSJzdHJpbmciPT10eXBlb2YgYT9hOnFjKGEpLGw9Yj9SYihhKyIvIitiKTphKTthPVJjKGQsZSk7bD1CYyhsLCh2b2lkIDAhPT1hP2E6NDM4KSY0MDk1fDMyNzY4LDApOwppZihjKXtpZigic3RyaW5nIj09dHlwZW9mIGMpe2I9QXJyYXkoYy5sZW5ndGgpO2Q9MDtmb3IoZT1jLmxlbmd0aDtkPGU7KytkKWJbZF09Yy5jaGFyQ29kZUF0KGQpO2M9Yn1GYyhsLGF8MTQ2KTtiPUhjKGwsNTc3KTtPYyhiLGMsMCxjLmxlbmd0aCwwLGYpO0ljKGIpO0ZjKGwsYSl9cmV0dXJuIGx9LFZjPShhLGIsYyxkKT0+e2E9UmIoKCJzdHJpbmciPT10eXBlb2YgYT9hOnFjKGEpKSsiLyIrYik7Yj1SYyghIWMsISFkKTtWYy5aanx8KFZjLlpqPTY0KTt2YXIgZT1WYy5aaisrPDw4fDA7WmIoZSx7b3BlbjpmPT57Zi5zZWVrYWJsZT0hMX0sY2xvc2U6KCk9PntkJiZkLmJ1ZmZlciYmZC5idWZmZXIubGVuZ3RoJiZkKDEwKX0scmVhZDooZixsLG4scSk9Pntmb3IodmFyIHY9MCx3PTA7dzxxO3crKyl7dHJ5e3ZhciBDPWMoKX1jYXRjaChHKXt0aHJvdyBuZXcgSSgyOSk7fWlmKHZvaWQgMD09PUMmJjA9PT12KXRocm93IG5ldyBJKDYpO2lmKG51bGw9PT1DfHx2b2lkIDA9PT1DKWJyZWFrOwp2Kys7bFtuK3ddPUN9diYmKGYubm9kZS50aW1lc3RhbXA9RGF0ZS5ub3coKSk7cmV0dXJuIHZ9LHdyaXRlOihmLGwsbixxKT0+e2Zvcih2YXIgdj0wO3Y8cTt2KyspdHJ5e2QobFtuK3ZdKX1jYXRjaCh3KXt0aHJvdyBuZXcgSSgyOSk7fXEmJihmLm5vZGUudGltZXN0YW1wPURhdGUubm93KCkpO3JldHVybiB2fX0pO3JldHVybiBDYyhhLGIsZSl9LFdjPWE9PntpZighKGEuQWt8fGEuQmt8fGEubGlua3x8YS5kaSkpe2lmKCJ1bmRlZmluZWQiIT10eXBlb2YgWE1MSHR0cFJlcXVlc3QpdGhyb3cgRXJyb3IoIkxhenkgbG9hZGluZyBzaG91bGQgaGF2ZSBiZWVuIHBlcmZvcm1lZCAoY29udGVudHMgc2V0KSBpbiBjcmVhdGVMYXp5RmlsZSwgYnV0IGl0IHdhcyBub3QuIExhenkgbG9hZGluZyBvbmx5IHdvcmtzIGluIHdlYiB3b3JrZXJzLiBVc2UgLS1lbWJlZC1maWxlIG9yIC0tcHJlbG9hZC1maWxlIGluIGVtY2Mgb24gdGhlIG1haW4gdGhyZWFkLiIpO2lmKE1hKXRyeXthLmRpPVdiKE1hKGEudXJsKSwKITApLGEuaWk9YS5kaS5sZW5ndGh9Y2F0Y2goYil7dGhyb3cgbmV3IEkoMjkpO31lbHNlIHRocm93IEVycm9yKCJDYW5ub3QgbG9hZCB3aXRob3V0IHJlYWQoKSBvciBYTUxIdHRwUmVxdWVzdC4iKTt9fSxYYz0oYSxiLGMsZCxlKT0+e2Z1bmN0aW9uIGYoKXt0aGlzLnhqPSExO3RoaXMubGk9W119Zi5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKHcpe2lmKCEodz50aGlzLmxlbmd0aC0xfHwwPncpKXt2YXIgQz13JXRoaXMuY2h1bmtTaXplO3JldHVybiB0aGlzLk5pKHcvdGhpcy5jaHVua1NpemV8MClbQ119fTtmLnByb3RvdHlwZS5waz1mdW5jdGlvbih3KXt0aGlzLk5pPXd9O2YucHJvdG90eXBlLk1qPWZ1bmN0aW9uKCl7dmFyIHc9bmV3IFhNTEh0dHBSZXF1ZXN0O3cub3BlbigiSEVBRCIsYywhMSk7dy5zZW5kKG51bGwpO2lmKCEoMjAwPD13LnN0YXR1cyYmMzAwPncuc3RhdHVzfHwzMDQ9PT13LnN0YXR1cykpdGhyb3cgRXJyb3IoIkNvdWxkbid0IGxvYWQgIitjKyIuIFN0YXR1czogIisKdy5zdGF0dXMpO3ZhciBDPU51bWJlcih3LmdldFJlc3BvbnNlSGVhZGVyKCJDb250ZW50LWxlbmd0aCIpKSxHLHA9KEc9dy5nZXRSZXNwb25zZUhlYWRlcigiQWNjZXB0LVJhbmdlcyIpKSYmImJ5dGVzIj09PUc7dz0oRz13LmdldFJlc3BvbnNlSGVhZGVyKCJDb250ZW50LUVuY29kaW5nIikpJiYiZ3ppcCI9PT1HO3ZhciB5PTEwNDg1NzY7cHx8KHk9Qyk7dmFyIEY9dGhpcztGLnBrKFI9Pnt2YXIgY2E9Uip5LE09KFIrMSkqeS0xO009TWF0aC5taW4oTSxDLTEpO2lmKCJ1bmRlZmluZWQiPT10eXBlb2YgRi5saVtSXSl7dmFyIEU9Ri5saTtpZihjYT5NKXRocm93IEVycm9yKCJpbnZhbGlkIHJhbmdlICgiK2NhKyIsICIrTSsiKSBvciBubyBieXRlcyByZXF1ZXN0ZWQhIik7aWYoTT5DLTEpdGhyb3cgRXJyb3IoIm9ubHkgIitDKyIgYnl0ZXMgYXZhaWxhYmxlISBwcm9ncmFtbWVyIGVycm9yISIpO3ZhciBBPW5ldyBYTUxIdHRwUmVxdWVzdDtBLm9wZW4oIkdFVCIsYywhMSk7QyE9PXkmJgpBLnNldFJlcXVlc3RIZWFkZXIoIlJhbmdlIiwiYnl0ZXM9IitjYSsiLSIrTSk7QS5yZXNwb25zZVR5cGU9ImFycmF5YnVmZmVyIjtBLm92ZXJyaWRlTWltZVR5cGUmJkEub3ZlcnJpZGVNaW1lVHlwZSgidGV4dC9wbGFpbjsgY2hhcnNldD14LXVzZXItZGVmaW5lZCIpO0Euc2VuZChudWxsKTtpZighKDIwMDw9QS5zdGF0dXMmJjMwMD5BLnN0YXR1c3x8MzA0PT09QS5zdGF0dXMpKXRocm93IEVycm9yKCJDb3VsZG4ndCBsb2FkICIrYysiLiBTdGF0dXM6ICIrQS5zdGF0dXMpO2NhPXZvaWQgMCE9PUEucmVzcG9uc2U/bmV3IFVpbnQ4QXJyYXkoQS5yZXNwb25zZXx8W10pOldiKEEucmVzcG9uc2VUZXh0fHwiIiwhMCk7RVtSXT1jYX1pZigidW5kZWZpbmVkIj09dHlwZW9mIEYubGlbUl0pdGhyb3cgRXJyb3IoImRvWEhSIGZhaWxlZCEiKTtyZXR1cm4gRi5saVtSXX0pO2lmKHd8fCFDKXk9Qz0xLHk9Qz10aGlzLk5pKDApLmxlbmd0aCxVYSgiTGF6eUZpbGVzIG9uIGd6aXAgZm9yY2VzIGRvd25sb2FkIG9mIHRoZSB3aG9sZSBmaWxlIHdoZW4gbGVuZ3RoIGlzIGFjY2Vzc2VkIik7CnRoaXMuams9Qzt0aGlzLmlrPXk7dGhpcy54aj0hMH07aWYoInVuZGVmaW5lZCIhPXR5cGVvZiBYTUxIdHRwUmVxdWVzdCl7aWYoIUdhKXRocm93IkNhbm5vdCBkbyBzeW5jaHJvbm91cyBiaW5hcnkgWEhScyBvdXRzaWRlIHdlYndvcmtlcnMgaW4gbW9kZXJuIGJyb3dzZXJzLiBVc2UgLS1lbWJlZC1maWxlIG9yIC0tcHJlbG9hZC1maWxlIGluIGVtY2MiO3ZhciBsPW5ldyBmO09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGwse2xlbmd0aDp7Z2V0OmZ1bmN0aW9uKCl7dGhpcy54anx8dGhpcy5NaigpO3JldHVybiB0aGlzLmprfX0sY2h1bmtTaXplOntnZXQ6ZnVuY3Rpb24oKXt0aGlzLnhqfHx0aGlzLk1qKCk7cmV0dXJuIHRoaXMuaWt9fX0pO3ZhciBuPXZvaWQgMH1lbHNlIG49YyxsPXZvaWQgMDt2YXIgcT1UYyhhLGIsZCxlKTtsP3EuZGk9bDpuJiYocS5kaT1udWxsLHEudXJsPW4pO09iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHEse2lpOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaS5sZW5ndGh9fX0pOwp2YXIgdj17fTtPYmplY3Qua2V5cyhxLmZpKS5mb3JFYWNoKHc9Pnt2YXIgQz1xLmZpW3ddO3Zbd109ZnVuY3Rpb24oKXtXYyhxKTtyZXR1cm4gQy5hcHBseShudWxsLGFyZ3VtZW50cyl9fSk7di5yZWFkPSh3LEMsRyxwLHkpPT57V2MocSk7dz13Lm5vZGUuZGk7aWYoeT49dy5sZW5ndGgpQz0wO2Vsc2V7cD1NYXRoLm1pbih3Lmxlbmd0aC15LHApO2lmKHcuc2xpY2UpZm9yKHZhciBGPTA7RjxwO0YrKylDW0crRl09d1t5K0ZdO2Vsc2UgZm9yKEY9MDtGPHA7RisrKUNbRytGXT13LmdldCh5K0YpO0M9cH1yZXR1cm4gQ307di56aj0oKT0+e1djKHEpO1dhKCk7dGhyb3cgbmV3IEkoNDgpO307cS5maT12O3JldHVybiBxfSxaYz0oYSxiLGMsZCxlLGYsbCxuLHEsdik9PntmdW5jdGlvbiB3KHApe2Z1bmN0aW9uIHkoRil7diYmdigpO258fFVjKGEsYixGLGQsZSxxKTtmJiZmKCk7eWIoRyl9WWMocCxDLHksKCk9PntsJiZsKCk7eWIoRyl9KXx8eShwKX12YXIgQz1iP1ZiKFJiKGErIi8iK2IpKToKYSxHPSJjcCAiK0M7eGIoRyk7InN0cmluZyI9PXR5cGVvZiBjP2hjKGMscD0+dyhwKSxsKTp3KGMpfSwkYz17fSx5YyxHYyxhZD12b2lkIDA7ZnVuY3Rpb24gYmQoKXthZCs9NDtyZXR1cm4gRFthZC00Pj4yXX1mdW5jdGlvbiBjZChhKXthPWtjW2FdO2lmKCFhKXRocm93IG5ldyBJKDgpO3JldHVybiBhfXZhciBkZD17fTtmdW5jdGlvbiBlZChhKXtmb3IoO2EubGVuZ3RoOyl7dmFyIGI9YS5wb3AoKTthLnBvcCgpKGIpfX1mdW5jdGlvbiBmZChhKXtyZXR1cm4gdGhpcy5mcm9tV2lyZVR5cGUoRFthPj4yXSl9dmFyIGdkPXt9LGhkPXt9LGpkPXt9O2Z1bmN0aW9uIGtkKGEpe2lmKHZvaWQgMD09PWEpcmV0dXJuIl91bmtub3duIjthPWEucmVwbGFjZSgvW15hLXpBLVowLTlfXS9nLCIkIik7dmFyIGI9YS5jaGFyQ29kZUF0KDApO3JldHVybiA0ODw9YiYmNTc+PWI/Il8iK2E6YX0KZnVuY3Rpb24gbGQoYSxiKXthPWtkKGEpO3JldHVybihuZXcgRnVuY3Rpb24oImJvZHkiLCJyZXR1cm4gZnVuY3Rpb24gIithKycoKSB7XG4gICAgInVzZSBzdHJpY3QiOyAgICByZXR1cm4gYm9keS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufTtcbicpKShiKX1mdW5jdGlvbiBtZChhKXt2YXIgYj1FcnJvcixjPWxkKGEsZnVuY3Rpb24oZCl7dGhpcy5uYW1lPWE7dGhpcy5tZXNzYWdlPWQ7ZD1FcnJvcihkKS5zdGFjazt2b2lkIDAhPT1kJiYodGhpcy5zdGFjaz10aGlzLnRvU3RyaW5nKCkrIlxuIitkLnJlcGxhY2UoL15FcnJvcig6W15cbl0qKT9cbi8sIiIpKX0pO2MucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoYi5wcm90b3R5cGUpO2MucHJvdG90eXBlLmNvbnN0cnVjdG9yPWM7Yy5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24oKXtyZXR1cm4gdm9pZCAwPT09dGhpcy5tZXNzYWdlP3RoaXMubmFtZTp0aGlzLm5hbWUrIjogIit0aGlzLm1lc3NhZ2V9O3JldHVybiBjfQp2YXIgbmQ9dm9pZCAwO2Z1bmN0aW9uIG9kKGEpe3Rocm93IG5ldyBuZChhKTt9ZnVuY3Rpb24gcGQoYSxiLGMpe2Z1bmN0aW9uIGQobil7bj1jKG4pO24ubGVuZ3RoIT09YS5sZW5ndGgmJm9kKCJNaXNtYXRjaGVkIHR5cGUgY29udmVydGVyIGNvdW50Iik7Zm9yKHZhciBxPTA7cTxhLmxlbmd0aDsrK3EpcWQoYVtxXSxuW3FdKX1hLmZvckVhY2goZnVuY3Rpb24obil7amRbbl09Yn0pO3ZhciBlPUFycmF5KGIubGVuZ3RoKSxmPVtdLGw9MDtiLmZvckVhY2goKG4scSk9PntoZC5oYXNPd25Qcm9wZXJ0eShuKT9lW3FdPWhkW25dOihmLnB1c2gobiksZ2QuaGFzT3duUHJvcGVydHkobil8fChnZFtuXT1bXSksZ2Rbbl0ucHVzaCgoKT0+e2VbcV09aGRbbl07KytsO2w9PT1mLmxlbmd0aCYmZChlKX0pKX0pOzA9PT1mLmxlbmd0aCYmZChlKX12YXIgcmQ9e307CmZ1bmN0aW9uIHNkKGEpe3N3aXRjaChhKXtjYXNlIDE6cmV0dXJuIDA7Y2FzZSAyOnJldHVybiAxO2Nhc2UgNDpyZXR1cm4gMjtjYXNlIDg6cmV0dXJuIDM7ZGVmYXVsdDp0aHJvdyBuZXcgVHlwZUVycm9yKCJVbmtub3duIHR5cGUgc2l6ZTogIithKTt9fXZhciB0ZD12b2lkIDA7ZnVuY3Rpb24gdWQoYSl7Zm9yKHZhciBiPSIiO3RbYV07KWIrPXRkW3RbYSsrXV07cmV0dXJuIGJ9dmFyIHZkPXZvaWQgMDtmdW5jdGlvbiB4ZChhKXt0aHJvdyBuZXcgdmQoYSk7fQpmdW5jdGlvbiBxZChhLGIsYz17fSl7aWYoISgiYXJnUGFja0FkdmFuY2UiaW4gYikpdGhyb3cgbmV3IFR5cGVFcnJvcigicmVnaXN0ZXJUeXBlIHJlZ2lzdGVyZWRJbnN0YW5jZSByZXF1aXJlcyBhcmdQYWNrQWR2YW5jZSIpO3ZhciBkPWIubmFtZTthfHx4ZCgndHlwZSAiJytkKyciIG11c3QgaGF2ZSBhIHBvc2l0aXZlIGludGVnZXIgdHlwZWlkIHBvaW50ZXInKTtpZihoZC5oYXNPd25Qcm9wZXJ0eShhKSl7aWYoYy54aylyZXR1cm47eGQoIkNhbm5vdCByZWdpc3RlciB0eXBlICciK2QrIicgdHdpY2UiKX1oZFthXT1iO2RlbGV0ZSBqZFthXTtnZC5oYXNPd25Qcm9wZXJ0eShhKSYmKGI9Z2RbYV0sZGVsZXRlIGdkW2FdLGIuZm9yRWFjaChlPT5lKCkpKX1mdW5jdGlvbiB5ZChhKXt4ZChhLmNpLmtpLmppLm5hbWUrIiBpbnN0YW5jZSBhbHJlYWR5IGRlbGV0ZWQiKX12YXIgemQ9ITE7ZnVuY3Rpb24gQWQoKXt9CmZ1bmN0aW9uIEJkKGEpey0tYS5jb3VudC52YWx1ZTswPT09YS5jb3VudC52YWx1ZSYmKGEub2k/YS50aS5zaShhLm9pKTphLmtpLmppLnNpKGEuaGkpKX1mdW5jdGlvbiBDZChhLGIsYyl7aWYoYj09PWMpcmV0dXJuIGE7aWYodm9pZCAwPT09Yy51aSlyZXR1cm4gbnVsbDthPUNkKGEsYixjLnVpKTtyZXR1cm4gbnVsbD09PWE/bnVsbDpjLnFrKGEpfXZhciBEZD17fSxFZD1bXTtmdW5jdGlvbiBGZCgpe2Zvcig7RWQubGVuZ3RoOyl7dmFyIGE9RWQucG9wKCk7YS5jaS5NaT0hMTthWyJkZWxldGUiXSgpfX12YXIgR2Q9dm9pZCAwLEhkPXt9O2Z1bmN0aW9uIElkKGEsYil7Zm9yKHZvaWQgMD09PWImJnhkKCJwdHIgc2hvdWxkIG5vdCBiZSB1bmRlZmluZWQiKTthLnVpOyliPWEuV2koYiksYT1hLnVpO3JldHVybiBIZFtiXX0KZnVuY3Rpb24gSmQoYSxiKXtiLmtpJiZiLmhpfHxvZCgibWFrZUNsYXNzSGFuZGxlIHJlcXVpcmVzIHB0ciBhbmQgcHRyVHlwZSIpOyEhYi50aSE9PSEhYi5vaSYmb2QoIkJvdGggc21hcnRQdHJUeXBlIGFuZCBzbWFydFB0ciBtdXN0IGJlIHNwZWNpZmllZCIpO2IuY291bnQ9e3ZhbHVlOjF9O3JldHVybiBLZChPYmplY3QuY3JlYXRlKGEse2NpOnt2YWx1ZTpifX0pKX1mdW5jdGlvbiBLZChhKXtpZigidW5kZWZpbmVkIj09PXR5cGVvZiBGaW5hbGl6YXRpb25SZWdpc3RyeSlyZXR1cm4gS2Q9Yj0+YixhO3pkPW5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShiPT57QmQoYi5jaSl9KTtLZD1iPT57dmFyIGM9Yi5jaTtjLm9pJiZ6ZC5yZWdpc3RlcihiLHtjaTpjfSxiKTtyZXR1cm4gYn07QWQ9Yj0+e3pkLnVucmVnaXN0ZXIoYil9O3JldHVybiBLZChhKX1mdW5jdGlvbiBMZCgpe30KZnVuY3Rpb24gTWQoYSxiLGMpe2lmKHZvaWQgMD09PWFbYl0uQmkpe3ZhciBkPWFbYl07YVtiXT1mdW5jdGlvbigpe2FbYl0uQmkuaGFzT3duUHJvcGVydHkoYXJndW1lbnRzLmxlbmd0aCl8fHhkKCJGdW5jdGlvbiAnIitjKyInIGNhbGxlZCB3aXRoIGFuIGludmFsaWQgbnVtYmVyIG9mIGFyZ3VtZW50cyAoIithcmd1bWVudHMubGVuZ3RoKyIpIC0gZXhwZWN0cyBvbmUgb2YgKCIrYVtiXS5CaSsiKSEiKTtyZXR1cm4gYVtiXS5CaVthcmd1bWVudHMubGVuZ3RoXS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9O2FbYl0uQmk9W107YVtiXS5CaVtkLnBqXT1kfX0KZnVuY3Rpb24gTmQoYSxiKXtnLmhhc093blByb3BlcnR5KGEpPyh4ZCgiQ2Fubm90IHJlZ2lzdGVyIHB1YmxpYyBuYW1lICciK2ErIicgdHdpY2UiKSxNZChnLGEsYSksZy5oYXNPd25Qcm9wZXJ0eSh2b2lkIDApJiZ4ZCgiQ2Fubm90IHJlZ2lzdGVyIG11bHRpcGxlIG92ZXJsb2FkcyBvZiBhIGZ1bmN0aW9uIHdpdGggdGhlIHNhbWUgbnVtYmVyIG9mIGFyZ3VtZW50cyAodW5kZWZpbmVkKSEiKSxnW2FdLkJpW3ZvaWQgMF09Yik6Z1thXT1ifWZ1bmN0aW9uIE9kKGEsYixjLGQsZSxmLGwsbil7dGhpcy5uYW1lPWE7dGhpcy5jb25zdHJ1Y3Rvcj1iO3RoaXMuU2k9Yzt0aGlzLnNpPWQ7dGhpcy51aT1lO3RoaXMudGs9Zjt0aGlzLldpPWw7dGhpcy5xaz1ufQpmdW5jdGlvbiBQZChhLGIsYyl7Zm9yKDtiIT09YzspYi5XaXx8eGQoIkV4cGVjdGVkIG51bGwgb3IgaW5zdGFuY2Ugb2YgIitjLm5hbWUrIiwgZ290IGFuIGluc3RhbmNlIG9mICIrYi5uYW1lKSxhPWIuV2koYSksYj1iLnVpO3JldHVybiBhfWZ1bmN0aW9uIFFkKGEsYil7aWYobnVsbD09PWIpcmV0dXJuIHRoaXMud2omJnhkKCJudWxsIGlzIG5vdCBhIHZhbGlkICIrdGhpcy5uYW1lKSwwO2IuY2l8fHhkKCdDYW5ub3QgcGFzcyAiJytSZChiKSsnIiBhcyBhICcrdGhpcy5uYW1lKTtiLmNpLmhpfHx4ZCgiQ2Fubm90IHBhc3MgZGVsZXRlZCBvYmplY3QgYXMgYSBwb2ludGVyIG9mIHR5cGUgIit0aGlzLm5hbWUpO3JldHVybiBQZChiLmNpLmhpLGIuY2kua2kuamksdGhpcy5qaSl9CmZ1bmN0aW9uIFNkKGEsYil7aWYobnVsbD09PWIpe3RoaXMud2omJnhkKCJudWxsIGlzIG5vdCBhIHZhbGlkICIrdGhpcy5uYW1lKTtpZih0aGlzLmRqKXt2YXIgYz10aGlzLlZpKCk7bnVsbCE9PWEmJmEucHVzaCh0aGlzLnNpLGMpO3JldHVybiBjfXJldHVybiAwfWIuY2l8fHhkKCdDYW5ub3QgcGFzcyAiJytSZChiKSsnIiBhcyBhICcrdGhpcy5uYW1lKTtiLmNpLmhpfHx4ZCgiQ2Fubm90IHBhc3MgZGVsZXRlZCBvYmplY3QgYXMgYSBwb2ludGVyIG9mIHR5cGUgIit0aGlzLm5hbWUpOyF0aGlzLmNqJiZiLmNpLmtpLmNqJiZ4ZCgiQ2Fubm90IGNvbnZlcnQgYXJndW1lbnQgb2YgdHlwZSAiKyhiLmNpLnRpP2IuY2kudGkubmFtZTpiLmNpLmtpLm5hbWUpKyIgdG8gcGFyYW1ldGVyIHR5cGUgIit0aGlzLm5hbWUpO2M9UGQoYi5jaS5oaSxiLmNpLmtpLmppLHRoaXMuamkpO2lmKHRoaXMuZGopc3dpdGNoKHZvaWQgMD09PWIuY2kub2kmJnhkKCJQYXNzaW5nIHJhdyBwb2ludGVyIHRvIHNtYXJ0IHBvaW50ZXIgaXMgaWxsZWdhbCIpLAp0aGlzLlNrKXtjYXNlIDA6Yi5jaS50aT09PXRoaXM/Yz1iLmNpLm9pOnhkKCJDYW5ub3QgY29udmVydCBhcmd1bWVudCBvZiB0eXBlICIrKGIuY2kudGk/Yi5jaS50aS5uYW1lOmIuY2kua2kubmFtZSkrIiB0byBwYXJhbWV0ZXIgdHlwZSAiK3RoaXMubmFtZSk7YnJlYWs7Y2FzZSAxOmM9Yi5jaS5vaTticmVhaztjYXNlIDI6aWYoYi5jaS50aT09PXRoaXMpYz1iLmNpLm9pO2Vsc2V7dmFyIGQ9Yi5jbG9uZSgpO2M9dGhpcy5JayhjLFRkKGZ1bmN0aW9uKCl7ZFsiZGVsZXRlIl0oKX0pKTtudWxsIT09YSYmYS5wdXNoKHRoaXMuc2ksYyl9YnJlYWs7ZGVmYXVsdDp4ZCgiVW5zdXBwb3J0aW5nIHNoYXJpbmcgcG9saWN5Iil9cmV0dXJuIGN9CmZ1bmN0aW9uIFVkKGEsYil7aWYobnVsbD09PWIpcmV0dXJuIHRoaXMud2omJnhkKCJudWxsIGlzIG5vdCBhIHZhbGlkICIrdGhpcy5uYW1lKSwwO2IuY2l8fHhkKCdDYW5ub3QgcGFzcyAiJytSZChiKSsnIiBhcyBhICcrdGhpcy5uYW1lKTtiLmNpLmhpfHx4ZCgiQ2Fubm90IHBhc3MgZGVsZXRlZCBvYmplY3QgYXMgYSBwb2ludGVyIG9mIHR5cGUgIit0aGlzLm5hbWUpO2IuY2kua2kuY2omJnhkKCJDYW5ub3QgY29udmVydCBhcmd1bWVudCBvZiB0eXBlICIrYi5jaS5raS5uYW1lKyIgdG8gcGFyYW1ldGVyIHR5cGUgIit0aGlzLm5hbWUpO3JldHVybiBQZChiLmNpLmhpLGIuY2kua2kuamksdGhpcy5qaSl9CmZ1bmN0aW9uIFZkKGEsYixjLGQpe3RoaXMubmFtZT1hO3RoaXMuamk9Yjt0aGlzLndqPWM7dGhpcy5jaj1kO3RoaXMuZGo9ITE7dGhpcy5zaT10aGlzLklrPXRoaXMuVmk9dGhpcy5jaz10aGlzLlNrPXRoaXMuR2s9dm9pZCAwO3ZvaWQgMCE9PWIudWk/dGhpcy50b1dpcmVUeXBlPVNkOih0aGlzLnRvV2lyZVR5cGU9ZD9RZDpVZCx0aGlzLnBpPW51bGwpfWZ1bmN0aW9uIFdkKGEsYil7Zy5oYXNPd25Qcm9wZXJ0eShhKXx8b2QoIlJlcGxhY2luZyBub25leGlzdGFudCBwdWJsaWMgc3ltYm9sIik7Z1thXT1iO2dbYV0ucGo9dm9pZCAwfQpmdW5jdGlvbiBYZChhLGIpe3ZhciBjPVtdO3JldHVybiBmdW5jdGlvbigpe2MubGVuZ3RoPTA7T2JqZWN0LmFzc2lnbihjLGFyZ3VtZW50cyk7aWYoYS5pbmNsdWRlcygiaiIpKXt2YXIgZD1nWyJkeW5DYWxsXyIrYV07ZD1jJiZjLmxlbmd0aD9kLmFwcGx5KG51bGwsW2JdLmNvbmNhdChjKSk6ZC5jYWxsKG51bGwsYil9ZWxzZSBkPW5iLmdldChiKS5hcHBseShudWxsLGMpO3JldHVybiBkfX1mdW5jdGlvbiBZZChhLGIpe2E9dWQoYSk7dmFyIGM9YS5pbmNsdWRlcygiaiIpP1hkKGEsYik6bmIuZ2V0KGIpOyJmdW5jdGlvbiIhPXR5cGVvZiBjJiZ4ZCgidW5rbm93biBmdW5jdGlvbiBwb2ludGVyIHdpdGggc2lnbmF0dXJlICIrYSsiOiAiK2IpO3JldHVybiBjfXZhciBaZD12b2lkIDA7ZnVuY3Rpb24gJGQoYSl7YT1hZShhKTt2YXIgYj11ZChhKTtiZShhKTtyZXR1cm4gYn0KZnVuY3Rpb24gY2UoYSxiKXtmdW5jdGlvbiBjKGYpe2VbZl18fGhkW2ZdfHwoamRbZl0/amRbZl0uZm9yRWFjaChjKTooZC5wdXNoKGYpLGVbZl09ITApKX12YXIgZD1bXSxlPXt9O2IuZm9yRWFjaChjKTt0aHJvdyBuZXcgWmQoYSsiOiAiK2QubWFwKCRkKS5qb2luKFsiLCAiXSkpO31mdW5jdGlvbiBkZShhKXt2YXIgYj1GdW5jdGlvbjtpZighKGIgaW5zdGFuY2VvZiBGdW5jdGlvbikpdGhyb3cgbmV3IFR5cGVFcnJvcigibmV3XyBjYWxsZWQgd2l0aCBjb25zdHJ1Y3RvciB0eXBlICIrdHlwZW9mIGIrIiB3aGljaCBpcyBub3QgYSBmdW5jdGlvbiIpO3ZhciBjPWxkKGIubmFtZXx8InVua25vd25GdW5jdGlvbk5hbWUiLGZ1bmN0aW9uKCl7fSk7Yy5wcm90b3R5cGU9Yi5wcm90b3R5cGU7Yz1uZXcgYzthPWIuYXBwbHkoYyxhKTtyZXR1cm4gYSBpbnN0YW5jZW9mIE9iamVjdD9hOmN9CmZ1bmN0aW9uIGVlKGEsYil7Zm9yKHZhciBjPVtdLGQ9MDtkPGE7ZCsrKWMucHVzaChoW2IrNCpkPj4yXSk7cmV0dXJuIGN9dmFyIGZlPVtdLGdlPVt7fSx7dmFsdWU6dm9pZCAwfSx7dmFsdWU6bnVsbH0se3ZhbHVlOiEwfSx7dmFsdWU6ITF9XTtmdW5jdGlvbiBoZShhKXs0PGEmJjA9PT0tLWdlW2FdLkNqJiYoZ2VbYV09dm9pZCAwLGZlLnB1c2goYSkpfXZhciBpZT1hPT57YXx8eGQoIkNhbm5vdCB1c2UgZGVsZXRlZCB2YWwuIGhhbmRsZSA9ICIrYSk7cmV0dXJuIGdlW2FdLnZhbHVlfSxUZD1hPT57c3dpdGNoKGEpe2Nhc2Ugdm9pZCAwOnJldHVybiAxO2Nhc2UgbnVsbDpyZXR1cm4gMjtjYXNlICEwOnJldHVybiAzO2Nhc2UgITE6cmV0dXJuIDQ7ZGVmYXVsdDp2YXIgYj1mZS5sZW5ndGg/ZmUucG9wKCk6Z2UubGVuZ3RoO2dlW2JdPXtDajoxLHZhbHVlOmF9O3JldHVybiBifX07CmZ1bmN0aW9uIGplKGEsYixjKXtzd2l0Y2goYil7Y2FzZSAwOnJldHVybiBmdW5jdGlvbihkKXtyZXR1cm4gdGhpcy5mcm9tV2lyZVR5cGUoKGM/amI6dClbZF0pfTtjYXNlIDE6cmV0dXJuIGZ1bmN0aW9uKGQpe3JldHVybiB0aGlzLmZyb21XaXJlVHlwZSgoYz9rYjpsYilbZD4+MV0pfTtjYXNlIDI6cmV0dXJuIGZ1bmN0aW9uKGQpe3JldHVybiB0aGlzLmZyb21XaXJlVHlwZSgoYz9EOmgpW2Q+PjJdKX07ZGVmYXVsdDp0aHJvdyBuZXcgVHlwZUVycm9yKCJVbmtub3duIGludGVnZXIgdHlwZTogIithKTt9fWZ1bmN0aW9uIGtlKGEsYil7dmFyIGM9aGRbYV07dm9pZCAwPT09YyYmeGQoYisiIGhhcyB1bmtub3duIHR5cGUgIiskZChhKSk7cmV0dXJuIGN9ZnVuY3Rpb24gUmQoYSl7aWYobnVsbD09PWEpcmV0dXJuIm51bGwiO3ZhciBiPXR5cGVvZiBhO3JldHVybiJvYmplY3QiPT09Ynx8ImFycmF5Ij09PWJ8fCJmdW5jdGlvbiI9PT1iP2EudG9TdHJpbmcoKToiIithfQpmdW5jdGlvbiBsZShhLGIpe3N3aXRjaChiKXtjYXNlIDI6cmV0dXJuIGZ1bmN0aW9uKGMpe3JldHVybiB0aGlzLmZyb21XaXJlVHlwZShCW2M+PjJdKX07Y2FzZSAzOnJldHVybiBmdW5jdGlvbihjKXtyZXR1cm4gdGhpcy5mcm9tV2lyZVR5cGUoaGFbYz4+M10pfTtkZWZhdWx0OnRocm93IG5ldyBUeXBlRXJyb3IoIlVua25vd24gZmxvYXQgdHlwZTogIithKTt9fQpmdW5jdGlvbiBtZShhLGIsYyl7c3dpdGNoKGIpe2Nhc2UgMDpyZXR1cm4gYz9mdW5jdGlvbihkKXtyZXR1cm4gamJbZF19OmZ1bmN0aW9uKGQpe3JldHVybiB0W2RdfTtjYXNlIDE6cmV0dXJuIGM/ZnVuY3Rpb24oZCl7cmV0dXJuIGtiW2Q+PjFdfTpmdW5jdGlvbihkKXtyZXR1cm4gbGJbZD4+MV19O2Nhc2UgMjpyZXR1cm4gYz9mdW5jdGlvbihkKXtyZXR1cm4gRFtkPj4yXX06ZnVuY3Rpb24oZCl7cmV0dXJuIGhbZD4+Ml19O2RlZmF1bHQ6dGhyb3cgbmV3IFR5cGVFcnJvcigiVW5rbm93biBpbnRlZ2VyIHR5cGU6ICIrYSk7fX12YXIgbmU9InVuZGVmaW5lZCIhPXR5cGVvZiBUZXh0RGVjb2Rlcj9uZXcgVGV4dERlY29kZXIoInV0Zi0xNmxlIik6dm9pZCAwOwpmdW5jdGlvbiBvZShhLGIpe3ZhciBjPWE+PjE7Zm9yKHZhciBkPWMrYi8yOyEoYz49ZCkmJmxiW2NdOykrK2M7Yzw8PTE7aWYoMzI8Yy1hJiZuZSlyZXR1cm4gbmUuZGVjb2RlKHQuc3ViYXJyYXkoYSxjKSk7Yz0iIjtmb3IoZD0wOyEoZD49Yi8yKTsrK2Qpe3ZhciBlPWtiW2ErMipkPj4xXTtpZigwPT1lKWJyZWFrO2MrPVN0cmluZy5mcm9tQ2hhckNvZGUoZSl9cmV0dXJuIGN9ZnVuY3Rpb24gcGUoYSxiLGMpe3ZvaWQgMD09PWMmJihjPTIxNDc0ODM2NDcpO2lmKDI+YylyZXR1cm4gMDtjLT0yO3ZhciBkPWI7Yz1jPDIqYS5sZW5ndGg/Yy8yOmEubGVuZ3RoO2Zvcih2YXIgZT0wO2U8YzsrK2Upa2JbYj4+MV09YS5jaGFyQ29kZUF0KGUpLGIrPTI7a2JbYj4+MV09MDtyZXR1cm4gYi1kfWZ1bmN0aW9uIHFlKGEpe3JldHVybiAyKmEubGVuZ3RofQpmdW5jdGlvbiByZShhLGIpe2Zvcih2YXIgYz0wLGQ9IiI7IShjPj1iLzQpOyl7dmFyIGU9RFthKzQqYz4+Ml07aWYoMD09ZSlicmVhazsrK2M7NjU1MzY8PWU/KGUtPTY1NTM2LGQrPVN0cmluZy5mcm9tQ2hhckNvZGUoNTUyOTZ8ZT4+MTAsNTYzMjB8ZSYxMDIzKSk6ZCs9U3RyaW5nLmZyb21DaGFyQ29kZShlKX1yZXR1cm4gZH1mdW5jdGlvbiBzZShhLGIsYyl7dm9pZCAwPT09YyYmKGM9MjE0NzQ4MzY0Nyk7aWYoND5jKXJldHVybiAwO3ZhciBkPWI7Yz1kK2MtNDtmb3IodmFyIGU9MDtlPGEubGVuZ3RoOysrZSl7dmFyIGY9YS5jaGFyQ29kZUF0KGUpO2lmKDU1Mjk2PD1mJiY1NzM0Mz49Zil7dmFyIGw9YS5jaGFyQ29kZUF0KCsrZSk7Zj02NTUzNisoKGYmMTAyMyk8PDEwKXxsJjEwMjN9RFtiPj4yXT1mO2IrPTQ7aWYoYis0PmMpYnJlYWt9RFtiPj4yXT0wO3JldHVybiBiLWR9CmZ1bmN0aW9uIHRlKGEpe2Zvcih2YXIgYj0wLGM9MDtjPGEubGVuZ3RoOysrYyl7dmFyIGQ9YS5jaGFyQ29kZUF0KGMpOzU1Mjk2PD1kJiY1NzM0Mz49ZCYmKytjO2IrPTR9cmV0dXJuIGJ9ZnVuY3Rpb24gdWUoYSxiKXtmb3IodmFyIGM9QXJyYXkoYSksZD0wO2Q8YTsrK2QpY1tkXT1rZShoW2IrNCpkPj4yXSwicGFyYW1ldGVyICIrZCk7cmV0dXJuIGN9dmFyIHZlPXt9O2Z1bmN0aW9uIHdlKGEpe3ZhciBiPXZlW2FdO3JldHVybiB2b2lkIDA9PT1iP3VkKGEpOmJ9dmFyIHhlPVtdO2Z1bmN0aW9uIHllKCl7cmV0dXJuIm9iamVjdCI9PXR5cGVvZiBnbG9iYWxUaGlzP2dsb2JhbFRoaXM6RnVuY3Rpb24oInJldHVybiB0aGlzIikoKX1mdW5jdGlvbiB6ZShhKXt2YXIgYj14ZS5sZW5ndGg7eGUucHVzaChhKTtyZXR1cm4gYn12YXIgQWU9W107CmZ1bmN0aW9uIEJlKGEpe2Zvcih2YXIgYj0iIixjPTA7YzxhOysrYyliKz0oMCE9PWM/IiwgIjoiIikrImFyZyIrYzt2YXIgZD0icmV0dXJuIGZ1bmN0aW9uIGVtdmFsX2FsbG9jYXRvcl8iK2ErIihjb25zdHJ1Y3RvciwgYXJnVHlwZXMsIGFyZ3MpIHtcbiAgdmFyIEhFQVBVMzIgPSBnZXRNZW1vcnkoKTtcbiI7Zm9yKGM9MDtjPGE7KytjKWQrPSJ2YXIgYXJnVHlwZSIrYysiID0gcmVxdWlyZVJlZ2lzdGVyZWRUeXBlKEhFQVBVMzJbKChhcmdUeXBlcyk+PjIpXSwgJ3BhcmFtZXRlciAiK2MrIicpO1xudmFyIGFyZyIrYysiID0gYXJnVHlwZSIrYysiLnJlYWRWYWx1ZUZyb21Qb2ludGVyKGFyZ3MpO1xuYXJncyArPSBhcmdUeXBlIitjKyJbJ2FyZ1BhY2tBZHZhbmNlJ107XG5hcmdUeXBlcyArPSA0O1xuIjtyZXR1cm4obmV3IEZ1bmN0aW9uKCJyZXF1aXJlUmVnaXN0ZXJlZFR5cGUiLCJNb2R1bGUiLCJ2YWx1ZVRvSGFuZGxlIiwiZ2V0TWVtb3J5IixkKygidmFyIG9iaiA9IG5ldyBjb25zdHJ1Y3RvcigiKwpiKyIpO1xucmV0dXJuIHZhbHVlVG9IYW5kbGUob2JqKTtcbn1cbiIpKSkoa2UsZyxUZCwoKT0+aCl9dmFyIENlPXt9LERlPVtdOwpmdW5jdGlvbiBFZShhLGIpe0ZlPWE7R2U9YjtpZihIZSlpZihJZXx8KEllPSEwKSwwPT1hKUplPWZ1bmN0aW9uKCl7dmFyIGQ9TWF0aC5tYXgoMCxLZStiLUxlKCkpfDA7c2V0VGltZW91dChNZSxkKX07ZWxzZSBpZigxPT1hKUplPWZ1bmN0aW9uKCl7TmUoTWUpfTtlbHNlIGlmKDI9PWEpe2lmKCJ1bmRlZmluZWQiPT10eXBlb2Ygc2V0SW1tZWRpYXRlKXt2YXIgYz1bXTthZGRFdmVudExpc3RlbmVyKCJtZXNzYWdlIixkPT57aWYoInNldGltbWVkaWF0ZSI9PT1kLmRhdGF8fCJzZXRpbW1lZGlhdGUiPT09ZC5kYXRhLnRhcmdldClkLnN0b3BQcm9wYWdhdGlvbigpLGMuc2hpZnQoKSgpfSwhMCk7c2V0SW1tZWRpYXRlPWZ1bmN0aW9uKGQpe2MucHVzaChkKTtHYT8odm9pZCAwPT09Zy5zZXRJbW1lZGlhdGVzJiYoZy5zZXRJbW1lZGlhdGVzPVtdKSxnLnNldEltbWVkaWF0ZXMucHVzaChkKSxwb3N0TWVzc2FnZSh7dGFyZ2V0OiJzZXRpbW1lZGlhdGUifSkpOnBvc3RNZXNzYWdlKCJzZXRpbW1lZGlhdGUiLAoiKiIpfX1KZT1mdW5jdGlvbigpe3NldEltbWVkaWF0ZShNZSl9fX12YXIgTGU7TGU9SGE/KCk9Pnt2YXIgYT1wcm9jZXNzLmhydGltZSgpO3JldHVybiAxRTMqYVswXSthWzFdLzFFNn06KCk9PnBlcmZvcm1hbmNlLm5vdygpO2Z1bmN0aW9uIE9lKGEpe2lmKCFub0V4aXRSdW50aW1lKXtpZihnLm9uRXhpdClnLm9uRXhpdChhKTtiYj0hMH1FYShhLG5ldyBSYShhKSl9ZnVuY3Rpb24gUGUoYSl7YSBpbnN0YW5jZW9mIFJhfHwidW53aW5kIj09YXx8RWEoMSxhKX0KZnVuY3Rpb24gUWUoYSl7IUhlfHxXYSgiZW1zY3JpcHRlbl9zZXRfbWFpbl9sb29wOiB0aGVyZSBjYW4gb25seSBiZSBvbmUgbWFpbiBsb29wIGZ1bmN0aW9uIGF0IG9uY2U6IGNhbGwgZW1zY3JpcHRlbl9jYW5jZWxfbWFpbl9sb29wIHRvIGNhbmNlbCB0aGUgcHJldmlvdXMgb25lIGJlZm9yZSBzZXR0aW5nIGEgbmV3IG9uZSB3aXRoIGRpZmZlcmVudCBwYXJhbWV0ZXJzLiIpO0hlPWE7dmFyIGI9UmU7SWU9ITE7TWU9ZnVuY3Rpb24oKXtpZighYmIpaWYoMDxTZS5sZW5ndGgpe3ZhciBjPURhdGUubm93KCksZD1TZS5zaGlmdCgpO2QuZ2woZC5hbCk7aWYoVGUpe3ZhciBlPVRlLGY9MD09ZSUxP2UtMTpNYXRoLmZsb29yKGUpO1RlPWQuYmw/ZjooOCplKyhmKy41KSkvOX1VYSgnbWFpbiBsb29wIGJsb2NrZXIgIicrZC5uYW1lKyciIHRvb2sgJysoRGF0ZS5ub3coKS1jKSsiIG1zIik7Zy5zZXRTdGF0dXMmJihjPWcuc3RhdHVzTWVzc2FnZXx8IlBsZWFzZSB3YWl0Li4uIixkPVRlLGU9ClVlLmZsLGQ/ZDxlP2cuc2V0U3RhdHVzKGMrIiAoIisoZS1kKSsiLyIrZSsiKSIpOmcuc2V0U3RhdHVzKGMpOmcuc2V0U3RhdHVzKCIiKSk7YjxSZXx8c2V0VGltZW91dChNZSwwKX1lbHNlIGI8UmV8fChWZT1WZSsxfDAsMT09RmUmJjE8R2UmJjAhPVZlJUdlP0plKCk6KDA9PUZlJiYoS2U9TGUoKSksYmJ8fGcucHJlTWFpbkxvb3AmJiExPT09Zy5wcmVNYWluTG9vcCgpfHwoV2UoYSksZy5wb3N0TWFpbkxvb3AmJmcucG9zdE1haW5Mb29wKCkpLGI8UmV8fCgib2JqZWN0Ij09dHlwZW9mIFNETCYmU0RMLmF1ZGlvJiZTREwuYXVkaW8uSGsmJlNETC5hdWRpby5IaygpLEplKCkpKSl9fWZ1bmN0aW9uIFdlKGEpe2lmKCFiYil0cnl7YSgpfWNhdGNoKGIpe1BlKGIpfX1mdW5jdGlvbiBYZShhLGIpe3NldFRpbWVvdXQoZnVuY3Rpb24oKXtXZShhKX0sYil9ZnVuY3Rpb24gWWUoYSl7WmV8fChaZT17fSk7WmVbYV18fChaZVthXT0xLEhhJiYoYT0id2FybmluZzogIithKSxTYShhKSl9CnZhciBaZSxJZT0hMSxKZT1udWxsLFJlPTAsSGU9bnVsbCxGZT0wLEdlPTAsVmU9MCxTZT1bXSxVZT17fSxLZSxNZSxUZSwkZT0hMSxhZj0hMSxiZj1bXTsKZnVuY3Rpb24gY2YoKXtmdW5jdGlvbiBhKCl7YWY9ZG9jdW1lbnQucG9pbnRlckxvY2tFbGVtZW50PT09Zy5jYW52YXN8fGRvY3VtZW50Lm1velBvaW50ZXJMb2NrRWxlbWVudD09PWcuY2FudmFzfHxkb2N1bWVudC53ZWJraXRQb2ludGVyTG9ja0VsZW1lbnQ9PT1nLmNhbnZhc3x8ZG9jdW1lbnQubXNQb2ludGVyTG9ja0VsZW1lbnQ9PT1nLmNhbnZhc31nLnByZWxvYWRQbHVnaW5zfHwoZy5wcmVsb2FkUGx1Z2lucz1bXSk7aWYoIWRmKXtkZj0hMDt0cnl7ZWY9ITB9Y2F0Y2goYyl7ZWY9ITEsU2EoIndhcm5pbmc6IG5vIGJsb2IgY29uc3RydWN0b3IsIGNhbm5vdCBjcmVhdGUgYmxvYnMgd2l0aCBtaW1ldHlwZXMiKX1mZj0idW5kZWZpbmVkIiE9dHlwZW9mIE1vekJsb2JCdWlsZGVyP01vekJsb2JCdWlsZGVyOiJ1bmRlZmluZWQiIT10eXBlb2YgV2ViS2l0QmxvYkJ1aWxkZXI/V2ViS2l0QmxvYkJ1aWxkZXI6ZWY/bnVsbDpTYSgid2FybmluZzogbm8gQmxvYkJ1aWxkZXIiKTtnZj0idW5kZWZpbmVkIiE9CnR5cGVvZiB3aW5kb3c/d2luZG93LlVSTD93aW5kb3cuVVJMOndpbmRvdy53ZWJraXRVUkw6dm9pZCAwO2cuYmt8fCJ1bmRlZmluZWQiIT10eXBlb2YgZ2Z8fChTYSgid2FybmluZzogQnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IGNyZWF0aW5nIG9iamVjdCBVUkxzLiBCdWlsdC1pbiBicm93c2VyIGltYWdlIGRlY29kaW5nIHdpbGwgbm90IGJlIGF2YWlsYWJsZS4iKSxnLmJrPSEwKTtnLnByZWxvYWRQbHVnaW5zLnB1c2goe2NhbkhhbmRsZTpmdW5jdGlvbihjKXtyZXR1cm4hZy5iayYmL1wuKGpwZ3xqcGVnfHBuZ3xibXApJC9pLnRlc3QoYyl9LGhhbmRsZTpmdW5jdGlvbihjLGQsZSxmKXt2YXIgbD1udWxsO2lmKGVmKXRyeXtsPW5ldyBCbG9iKFtjXSx7dHlwZTpoZihkKX0pLGwuc2l6ZSE9PWMubGVuZ3RoJiYobD1uZXcgQmxvYihbKG5ldyBVaW50OEFycmF5KGMpKS5idWZmZXJdLHt0eXBlOmhmKGQpfSkpfWNhdGNoKHYpe1llKCJCbG9iIGNvbnN0cnVjdG9yIHByZXNlbnQgYnV0IGZhaWxzOiAiKwp2KyI7IGZhbGxpbmcgYmFjayB0byBibG9iIGJ1aWxkZXIiKX1sfHwobD1uZXcgZmYsbC5hcHBlbmQoKG5ldyBVaW50OEFycmF5KGMpKS5idWZmZXIpLGw9bC5nZXRCbG9iKCkpO3ZhciBuPWdmLmNyZWF0ZU9iamVjdFVSTChsKSxxPW5ldyBJbWFnZTtxLm9ubG9hZD0oKT0+e3EuY29tcGxldGV8fFdhKCJJbWFnZSAiK2QrIiBjb3VsZCBub3QgYmUgZGVjb2RlZCIpO3ZhciB2PWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoImNhbnZhcyIpO3Yud2lkdGg9cS53aWR0aDt2LmhlaWdodD1xLmhlaWdodDt2LmdldENvbnRleHQoIjJkIikuZHJhd0ltYWdlKHEsMCwwKTtnZi5yZXZva2VPYmplY3RVUkwobik7ZSYmZShjKX07cS5vbmVycm9yPSgpPT57VWEoIkltYWdlICIrbisiIGNvdWxkIG5vdCBiZSBkZWNvZGVkIik7ZiYmZigpfTtxLnNyYz1ufX0pO2cucHJlbG9hZFBsdWdpbnMucHVzaCh7Y2FuSGFuZGxlOmZ1bmN0aW9uKGMpe3JldHVybiFnLm1sJiZjLnN1YnN0cigtNClpbnsiLm9nZyI6MSwKIi53YXYiOjEsIi5tcDMiOjF9fSxoYW5kbGU6ZnVuY3Rpb24oYyxkLGUsZil7ZnVuY3Rpb24gbCgpe3F8fChxPSEwLGUmJmUoYykpfWZ1bmN0aW9uIG4oKXtxfHwocT0hMCxuZXcgQXVkaW8sZiYmZigpKX12YXIgcT0hMTtpZihlZil7dHJ5e3ZhciB2PW5ldyBCbG9iKFtjXSx7dHlwZTpoZihkKX0pfWNhdGNoKEMpe3JldHVybiBuKCl9dj1nZi5jcmVhdGVPYmplY3RVUkwodik7dmFyIHc9bmV3IEF1ZGlvO3cuYWRkRXZlbnRMaXN0ZW5lcigiY2FucGxheXRocm91Z2giLCgpPT5sKHcpLCExKTt3Lm9uZXJyb3I9ZnVuY3Rpb24oKXtpZighcSl7U2EoIndhcm5pbmc6IGJyb3dzZXIgY291bGQgbm90IGZ1bGx5IGRlY29kZSBhdWRpbyAiK2QrIiwgdHJ5aW5nIHNsb3dlciBiYXNlNjQgYXBwcm9hY2giKTtmb3IodmFyIEM9IiIsRz0wLHA9MCx5PTA7eTxjLmxlbmd0aDt5KyspZm9yKEc9Rzw8OHxjW3ldLHArPTg7Njw9cDspe3ZhciBGPUc+PnAtNiY2MztwLT02O0MrPSJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvIltGXX0yPT0KcD8oQys9IkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8iWyhHJjMpPDw0XSxDKz0iPT0iKTo0PT1wJiYoQys9IkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8iWyhHJjE1KTw8Ml0sQys9Ij0iKTt3LnNyYz0iZGF0YTphdWRpby94LSIrZC5zdWJzdHIoLTMpKyI7YmFzZTY0LCIrQztsKHcpfX07dy5zcmM9djtYZShmdW5jdGlvbigpe2wodyl9LDFFNCl9ZWxzZSByZXR1cm4gbigpfX0pO3ZhciBiPWcuY2FudmFzO2ImJihiLnJlcXVlc3RQb2ludGVyTG9jaz1iLnJlcXVlc3RQb2ludGVyTG9ja3x8Yi5tb3pSZXF1ZXN0UG9pbnRlckxvY2t8fGIud2Via2l0UmVxdWVzdFBvaW50ZXJMb2NrfHxiLm1zUmVxdWVzdFBvaW50ZXJMb2NrfHwoKCk9Pnt9KSxiLmV4aXRQb2ludGVyTG9jaz1kb2N1bWVudC5leGl0UG9pbnRlckxvY2t8fGRvY3VtZW50Lm1vekV4aXRQb2ludGVyTG9ja3x8CmRvY3VtZW50LndlYmtpdEV4aXRQb2ludGVyTG9ja3x8ZG9jdW1lbnQubXNFeGl0UG9pbnRlckxvY2t8fCgoKT0+e30pLGIuZXhpdFBvaW50ZXJMb2NrPWIuZXhpdFBvaW50ZXJMb2NrLmJpbmQoZG9jdW1lbnQpLGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoInBvaW50ZXJsb2NrY2hhbmdlIixhLCExKSxkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCJtb3pwb2ludGVybG9ja2NoYW5nZSIsYSwhMSksZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigid2Via2l0cG9pbnRlcmxvY2tjaGFuZ2UiLGEsITEpLGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoIm1zcG9pbnRlcmxvY2tjaGFuZ2UiLGEsITEpLGcuZWxlbWVudFBvaW50ZXJMb2NrJiZiLmFkZEV2ZW50TGlzdGVuZXIoImNsaWNrIixjPT57IWFmJiZnLmNhbnZhcy5yZXF1ZXN0UG9pbnRlckxvY2smJihnLmNhbnZhcy5yZXF1ZXN0UG9pbnRlckxvY2soKSxjLnByZXZlbnREZWZhdWx0KCkpfSwhMSkpfX0KZnVuY3Rpb24gWWMoYSxiLGMsZCl7Y2YoKTt2YXIgZT0hMTtnLnByZWxvYWRQbHVnaW5zLmZvckVhY2goZnVuY3Rpb24oZil7IWUmJmYuY2FuSGFuZGxlKGIpJiYoZi5oYW5kbGUoYSxiLGMsZCksZT0hMCl9KTtyZXR1cm4gZX0KZnVuY3Rpb24gamYoYSxiLGMsZCl7aWYoYiYmZy5SaSYmYT09Zy5jYW52YXMpcmV0dXJuIGcuUmk7dmFyIGU7aWYoYil7dmFyIGY9e2FudGlhbGlhczohMSxhbHBoYTohMSx5ajoidW5kZWZpbmVkIiE9dHlwZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQ/MjoxfTtpZihkKWZvcih2YXIgbCBpbiBkKWZbbF09ZFtsXTtpZigidW5kZWZpbmVkIiE9dHlwZW9mIGtmJiYoZT1sZihhLGYpKSl2YXIgbj1tZltlXS5MaX1lbHNlIG49YS5nZXRDb250ZXh0KCIyZCIpO2lmKCFuKXJldHVybiBudWxsO2MmJihifHwidW5kZWZpbmVkIj09dHlwZW9mIE58fFdhKCJjYW5ub3Qgc2V0IGluIG1vZHVsZSBpZiBHTGN0eCBpcyB1c2VkLCBidXQgd2UgYXJlIGEgbm9uLUdMIGNvbnRleHQgdGhhdCB3b3VsZCByZXBsYWNlIGl0IiksZy5SaT1uLGImJm5mKGUpLGcuc2w9YixiZi5mb3JFYWNoKGZ1bmN0aW9uKHEpe3EoKX0pLGNmKCkpO3JldHVybiBufXZhciBvZj0hMSxwZj12b2lkIDAscWY9dm9pZCAwOwpmdW5jdGlvbiByZihhLGIpe2Z1bmN0aW9uIGMoKXskZT0hMTt2YXIgZj1kLnBhcmVudE5vZGU7KGRvY3VtZW50LmZ1bGxzY3JlZW5FbGVtZW50fHxkb2N1bWVudC5tb3pGdWxsU2NyZWVuRWxlbWVudHx8ZG9jdW1lbnQubXNGdWxsc2NyZWVuRWxlbWVudHx8ZG9jdW1lbnQud2Via2l0RnVsbHNjcmVlbkVsZW1lbnR8fGRvY3VtZW50LndlYmtpdEN1cnJlbnRGdWxsU2NyZWVuRWxlbWVudCk9PT1mPyhkLmV4aXRGdWxsc2NyZWVuPXNmLHBmJiZkLnJlcXVlc3RQb2ludGVyTG9jaygpLCRlPSEwLHFmPygidW5kZWZpbmVkIiE9dHlwZW9mIFNETCYmKERbU0RMLnNjcmVlbj4+Ml09aFtTREwuc2NyZWVuPj4yXXw4Mzg4NjA4KSx0ZihnLmNhbnZhcyksdWYoKSk6dGYoZCkpOihmLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGQsZiksZi5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGYpLHFmPygidW5kZWZpbmVkIiE9dHlwZW9mIFNETCYmKERbU0RMLnNjcmVlbj4+Ml09aFtTREwuc2NyZWVuPj4yXSYKLTgzODg2MDkpLHRmKGcuY2FudmFzKSx1ZigpKTp0ZihkKSk7aWYoZy5vbkZ1bGxTY3JlZW4pZy5vbkZ1bGxTY3JlZW4oJGUpO2lmKGcub25GdWxsc2NyZWVuKWcub25GdWxsc2NyZWVuKCRlKX1wZj1hO3FmPWI7InVuZGVmaW5lZCI9PXR5cGVvZiBwZiYmKHBmPSEwKTsidW5kZWZpbmVkIj09dHlwZW9mIHFmJiYocWY9ITEpO3ZhciBkPWcuY2FudmFzO29mfHwob2Y9ITAsZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigiZnVsbHNjcmVlbmNoYW5nZSIsYywhMSksZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigibW96ZnVsbHNjcmVlbmNoYW5nZSIsYywhMSksZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigid2Via2l0ZnVsbHNjcmVlbmNoYW5nZSIsYywhMSksZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigiTVNGdWxsc2NyZWVuQ2hhbmdlIixjLCExKSk7dmFyIGU9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgiZGl2Iik7ZC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlLGQpO2UuYXBwZW5kQ2hpbGQoZCk7CmUucmVxdWVzdEZ1bGxzY3JlZW49ZS5yZXF1ZXN0RnVsbHNjcmVlbnx8ZS5tb3pSZXF1ZXN0RnVsbFNjcmVlbnx8ZS5tc1JlcXVlc3RGdWxsc2NyZWVufHwoZS53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbj8oKT0+ZS53ZWJraXRSZXF1ZXN0RnVsbHNjcmVlbihFbGVtZW50LkFMTE9XX0tFWUJPQVJEX0lOUFVUKTpudWxsKXx8KGUud2Via2l0UmVxdWVzdEZ1bGxTY3JlZW4/KCk9PmUud2Via2l0UmVxdWVzdEZ1bGxTY3JlZW4oRWxlbWVudC5BTExPV19LRVlCT0FSRF9JTlBVVCk6bnVsbCk7ZS5yZXF1ZXN0RnVsbHNjcmVlbigpfQpmdW5jdGlvbiBzZigpe2lmKCEkZSlyZXR1cm4hMTsoZG9jdW1lbnQuZXhpdEZ1bGxzY3JlZW58fGRvY3VtZW50LmNhbmNlbEZ1bGxTY3JlZW58fGRvY3VtZW50Lm1vekNhbmNlbEZ1bGxTY3JlZW58fGRvY3VtZW50Lm1zRXhpdEZ1bGxzY3JlZW58fGRvY3VtZW50LndlYmtpdENhbmNlbEZ1bGxTY3JlZW58fGZ1bmN0aW9uKCl7fSkuYXBwbHkoZG9jdW1lbnQsW10pO3JldHVybiEwfXZhciB2Zj0wO2Z1bmN0aW9uIE5lKGEpe2lmKCJmdW5jdGlvbiI9PXR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUpcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGEpO2Vsc2V7dmFyIGI9RGF0ZS5ub3coKTtpZigwPT09dmYpdmY9YisxRTMvNjA7ZWxzZSBmb3IoO2IrMj49dmY7KXZmKz0xRTMvNjA7c2V0VGltZW91dChhLE1hdGgubWF4KHZmLWIsMCkpfX1mdW5jdGlvbiB3ZihhKXtOZShmdW5jdGlvbigpe1dlKGEpfSl9CmZ1bmN0aW9uIGhmKGEpe3JldHVybntqcGc6ImltYWdlL2pwZWciLGpwZWc6ImltYWdlL2pwZWciLHBuZzoiaW1hZ2UvcG5nIixibXA6ImltYWdlL2JtcCIsb2dnOiJhdWRpby9vZ2ciLHdhdjoiYXVkaW8vd2F2IixtcDM6ImF1ZGlvL21wZWcifVthLnN1YnN0cihhLmxhc3RJbmRleE9mKCIuIikrMSldfXZhciB4Zj1bXTtmdW5jdGlvbiB1Zigpe3ZhciBhPWcuY2FudmFzO3hmLmZvckVhY2goZnVuY3Rpb24oYil7YihhLndpZHRoLGEuaGVpZ2h0KX0pfQpmdW5jdGlvbiB0ZihhLGIsYyl7YiYmYz8oYS5aaz1iLGEud2s9Yyk6KGI9YS5aayxjPWEud2spO3ZhciBkPWIsZT1jO2cuZm9yY2VkQXNwZWN0UmF0aW8mJjA8Zy5mb3JjZWRBc3BlY3RSYXRpbyYmKGQvZTxnLmZvcmNlZEFzcGVjdFJhdGlvP2Q9TWF0aC5yb3VuZChlKmcuZm9yY2VkQXNwZWN0UmF0aW8pOmU9TWF0aC5yb3VuZChkL2cuZm9yY2VkQXNwZWN0UmF0aW8pKTtpZigoZG9jdW1lbnQuZnVsbHNjcmVlbkVsZW1lbnR8fGRvY3VtZW50Lm1vekZ1bGxTY3JlZW5FbGVtZW50fHxkb2N1bWVudC5tc0Z1bGxzY3JlZW5FbGVtZW50fHxkb2N1bWVudC53ZWJraXRGdWxsc2NyZWVuRWxlbWVudHx8ZG9jdW1lbnQud2Via2l0Q3VycmVudEZ1bGxTY3JlZW5FbGVtZW50KT09PWEucGFyZW50Tm9kZSYmInVuZGVmaW5lZCIhPXR5cGVvZiBzY3JlZW4pe3ZhciBmPU1hdGgubWluKHNjcmVlbi53aWR0aC9kLHNjcmVlbi5oZWlnaHQvZSk7ZD1NYXRoLnJvdW5kKGQqZik7ZT1NYXRoLnJvdW5kKGUqCmYpfXFmPyhhLndpZHRoIT1kJiYoYS53aWR0aD1kKSxhLmhlaWdodCE9ZSYmKGEuaGVpZ2h0PWUpLCJ1bmRlZmluZWQiIT10eXBlb2YgYS5zdHlsZSYmKGEuc3R5bGUucmVtb3ZlUHJvcGVydHkoIndpZHRoIiksYS5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgiaGVpZ2h0IikpKTooYS53aWR0aCE9YiYmKGEud2lkdGg9YiksYS5oZWlnaHQhPWMmJihhLmhlaWdodD1jKSwidW5kZWZpbmVkIiE9dHlwZW9mIGEuc3R5bGUmJihkIT1ifHxlIT1jPyhhLnN0eWxlLnNldFByb3BlcnR5KCJ3aWR0aCIsZCsicHgiLCJpbXBvcnRhbnQiKSxhLnN0eWxlLnNldFByb3BlcnR5KCJoZWlnaHQiLGUrInB4IiwiaW1wb3J0YW50IikpOihhLnN0eWxlLnJlbW92ZVByb3BlcnR5KCJ3aWR0aCIpLGEuc3R5bGUucmVtb3ZlUHJvcGVydHkoImhlaWdodCIpKSkpfXZhciBkZixlZixmZixnZjsKZnVuY3Rpb24geWYoYSl7dmFyIGI9YS5nZXRFeHRlbnNpb24oIkFOR0xFX2luc3RhbmNlZF9hcnJheXMiKTtiJiYoYS52ZXJ0ZXhBdHRyaWJEaXZpc29yPWZ1bmN0aW9uKGMsZCl7Yi52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUoYyxkKX0sYS5kcmF3QXJyYXlzSW5zdGFuY2VkPWZ1bmN0aW9uKGMsZCxlLGYpe2IuZHJhd0FycmF5c0luc3RhbmNlZEFOR0xFKGMsZCxlLGYpfSxhLmRyYXdFbGVtZW50c0luc3RhbmNlZD1mdW5jdGlvbihjLGQsZSxmLGwpe2IuZHJhd0VsZW1lbnRzSW5zdGFuY2VkQU5HTEUoYyxkLGUsZixsKX0pfQpmdW5jdGlvbiB6ZihhKXt2YXIgYj1hLmdldEV4dGVuc2lvbigiT0VTX3ZlcnRleF9hcnJheV9vYmplY3QiKTtiJiYoYS5jcmVhdGVWZXJ0ZXhBcnJheT1mdW5jdGlvbigpe3JldHVybiBiLmNyZWF0ZVZlcnRleEFycmF5T0VTKCl9LGEuZGVsZXRlVmVydGV4QXJyYXk9ZnVuY3Rpb24oYyl7Yi5kZWxldGVWZXJ0ZXhBcnJheU9FUyhjKX0sYS5iaW5kVmVydGV4QXJyYXk9ZnVuY3Rpb24oYyl7Yi5iaW5kVmVydGV4QXJyYXlPRVMoYyl9LGEuaXNWZXJ0ZXhBcnJheT1mdW5jdGlvbihjKXtyZXR1cm4gYi5pc1ZlcnRleEFycmF5T0VTKGMpfSl9ZnVuY3Rpb24gQWYoYSl7dmFyIGI9YS5nZXRFeHRlbnNpb24oIldFQkdMX2RyYXdfYnVmZmVycyIpO2ImJihhLmRyYXdCdWZmZXJzPWZ1bmN0aW9uKGMsZCl7Yi5kcmF3QnVmZmVyc1dFQkdMKGMsZCl9KX0KdmFyIEJmPTEsQ2Y9W10sRGY9W10sRWY9W10sRmY9W10sR2Y9W10sSGY9W10sSWY9W10sbWY9W10sSmY9e30sS2Y9W10sTGY9W10sTWY9W10sTmY9W10sT2Y9e30sUGY9e30sUWY9NDtmdW5jdGlvbiBPKGEpe1JmfHwoUmY9YSl9ZnVuY3Rpb24gU2YoYSl7Zm9yKHZhciBiPUJmKyssYz1hLmxlbmd0aDtjPGI7YysrKWFbY109bnVsbDtyZXR1cm4gYn1mdW5jdGlvbiBUZihhLGIsYyl7Zm9yKHZhciBkPSIiLGU9MDtlPGE7KytlKXt2YXIgZj1jP0RbYys0KmU+PjJdOi0xO2QrPWRiKERbYis0KmU+PjJdLDA+Zj92b2lkIDA6Zil9cmV0dXJuIGR9CmZ1bmN0aW9uIGxmKGEsYil7YS5saXx8KGEubGk9YS5nZXRDb250ZXh0LGEuZ2V0Q29udGV4dD1mdW5jdGlvbihkLGUpe2U9YS5saShkLGUpO3JldHVybiJ3ZWJnbCI9PWQ9PWUgaW5zdGFuY2VvZiBXZWJHTFJlbmRlcmluZ0NvbnRleHQ/ZTpudWxsfSk7dmFyIGM9MTxiLnlqP2EuZ2V0Q29udGV4dCgid2ViZ2wyIixiKTphLmdldENvbnRleHQoIndlYmdsIixiKTtyZXR1cm4gYz9VZihjLGIpOjB9ZnVuY3Rpb24gVWYoYSxiKXt2YXIgYz1TZihtZiksZD17aWw6YyxhdHRyaWJ1dGVzOmIsdmVyc2lvbjpiLnlqLExpOmF9O2EuY2FudmFzJiYoYS5jYW52YXMuaGs9ZCk7bWZbY109ZDsoInVuZGVmaW5lZCI9PXR5cGVvZiBiLlNqfHxiLlNqKSYmVmYoZCk7cmV0dXJuIGN9ZnVuY3Rpb24gbmYoYSl7VD1tZlthXTtnLlJpPU49VCYmVC5MaTtyZXR1cm4hKGEmJiFOKX0KZnVuY3Rpb24gVmYoYSl7YXx8KGE9VCk7aWYoIWEueWspe2EueWs9ITA7dmFyIGI9YS5MaTt5ZihiKTt6ZihiKTtBZihiKTtiLmNsPWIuZ2V0RXh0ZW5zaW9uKCJXRUJHTF9kcmF3X2luc3RhbmNlZF9iYXNlX3ZlcnRleF9iYXNlX2luc3RhbmNlIik7Yi5qbD1iLmdldEV4dGVuc2lvbigiV0VCR0xfbXVsdGlfZHJhd19pbnN0YW5jZWRfYmFzZV92ZXJ0ZXhfYmFzZV9pbnN0YW5jZSIpOzI8PWEudmVyc2lvbiYmKGIubmk9Yi5nZXRFeHRlbnNpb24oIkVYVF9kaXNqb2ludF90aW1lcl9xdWVyeV93ZWJnbDIiKSk7aWYoMj5hLnZlcnNpb258fCFiLm5pKWIubmk9Yi5nZXRFeHRlbnNpb24oIkVYVF9kaXNqb2ludF90aW1lcl9xdWVyeSIpO2IubGw9Yi5nZXRFeHRlbnNpb24oIldFQkdMX211bHRpX2RyYXciKTsoYi5nZXRTdXBwb3J0ZWRFeHRlbnNpb25zKCl8fFtdKS5mb3JFYWNoKGZ1bmN0aW9uKGMpe2MuaW5jbHVkZXMoImxvc2VfY29udGV4dCIpfHxjLmluY2x1ZGVzKCJkZWJ1ZyIpfHxiLmdldEV4dGVuc2lvbihjKX0pfX0KdmFyIGtmPXt9LFJmLFQsV2Y9W107ZnVuY3Rpb24gWGYoYSxiLGMsZCl7Ti5kcmF3RWxlbWVudHMoYSxiLGMsZCl9ZnVuY3Rpb24gWWYoYSxiLGMsZCl7Zm9yKHZhciBlPTA7ZTxhO2UrKyl7dmFyIGY9TltjXSgpLGw9ZiYmU2YoZCk7Zj8oZi5uYW1lPWwsZFtsXT1mKTpPKDEyODIpO0RbYis0KmU+PjJdPWx9fWZ1bmN0aW9uIFpmKGEsYixjLGQsZSxmLGwsbil7Yj1EZltiXTtpZihhPU5bYV0oYixjKSlkPW4mJmViKGEubmFtZSx0LG4sZCksZSYmKERbZT4+Ml09ZCksZiYmKERbZj4+Ml09YS5zaXplKSxsJiYoRFtsPj4yXT1hLnR5cGUpfWZ1bmN0aW9uICRmKGEsYil7aFthPj4yXT1iO2hbYSs0Pj4yXT0oYi1oW2E+PjJdKS80Mjk0OTY3Mjk2fQpmdW5jdGlvbiBhZyhhLGIsYyl7aWYoYil7dmFyIGQ9dm9pZCAwO3N3aXRjaChhKXtjYXNlIDM2MzQ2OmQ9MTticmVhaztjYXNlIDM2MzQ0OjAhPWMmJjEhPWMmJk8oMTI4MCk7cmV0dXJuO2Nhc2UgMzQ4MTQ6Y2FzZSAzNjM0NTpkPTA7YnJlYWs7Y2FzZSAzNDQ2Njp2YXIgZT1OLmdldFBhcmFtZXRlcigzNDQ2Nyk7ZD1lP2UubGVuZ3RoOjA7YnJlYWs7Y2FzZSAzMzMwOTppZigyPlQudmVyc2lvbil7TygxMjgyKTtyZXR1cm59ZD0yKihOLmdldFN1cHBvcnRlZEV4dGVuc2lvbnMoKXx8W10pLmxlbmd0aDticmVhaztjYXNlIDMzMzA3OmNhc2UgMzMzMDg6aWYoMj5ULnZlcnNpb24pe08oMTI4MCk7cmV0dXJufWQ9MzMzMDc9PWE/MzowfWlmKHZvaWQgMD09PWQpc3dpdGNoKGU9Ti5nZXRQYXJhbWV0ZXIoYSksdHlwZW9mIGUpe2Nhc2UgIm51bWJlciI6ZD1lO2JyZWFrO2Nhc2UgImJvb2xlYW4iOmQ9ZT8xOjA7YnJlYWs7Y2FzZSAic3RyaW5nIjpPKDEyODApO3JldHVybjtjYXNlICJvYmplY3QiOmlmKG51bGw9PT0KZSlzd2l0Y2goYSl7Y2FzZSAzNDk2NDpjYXNlIDM1NzI1OmNhc2UgMzQ5NjU6Y2FzZSAzNjAwNjpjYXNlIDM2MDA3OmNhc2UgMzI4NzM6Y2FzZSAzNDIyOTpjYXNlIDM2NjYyOmNhc2UgMzY2NjM6Y2FzZSAzNTA1MzpjYXNlIDM1MDU1OmNhc2UgMzYwMTA6Y2FzZSAzNTA5NzpjYXNlIDM1ODY5OmNhc2UgMzI4NzQ6Y2FzZSAzNjM4OTpjYXNlIDM1OTgzOmNhc2UgMzUzNjg6Y2FzZSAzNDA2ODpkPTA7YnJlYWs7ZGVmYXVsdDpPKDEyODApO3JldHVybn1lbHNle2lmKGUgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXl8fGUgaW5zdGFuY2VvZiBVaW50MzJBcnJheXx8ZSBpbnN0YW5jZW9mIEludDMyQXJyYXl8fGUgaW5zdGFuY2VvZiBBcnJheSl7Zm9yKGE9MDthPGUubGVuZ3RoOysrYSlzd2l0Y2goYyl7Y2FzZSAwOkRbYis0KmE+PjJdPWVbYV07YnJlYWs7Y2FzZSAyOkJbYis0KmE+PjJdPWVbYV07YnJlYWs7Y2FzZSA0OmpiW2IrYT4+MF09ZVthXT8xOjB9cmV0dXJufXRyeXtkPWUubmFtZXwwfWNhdGNoKGYpe08oMTI4MCk7ClNhKCJHTF9JTlZBTElEX0VOVU0gaW4gZ2xHZXQiK2MrInY6IFVua25vd24gb2JqZWN0IHJldHVybmVkIGZyb20gV2ViR0wgZ2V0UGFyYW1ldGVyKCIrYSsiKSEgKGVycm9yOiAiK2YrIikiKTtyZXR1cm59fWJyZWFrO2RlZmF1bHQ6TygxMjgwKTtTYSgiR0xfSU5WQUxJRF9FTlVNIGluIGdsR2V0IitjKyJ2OiBOYXRpdmUgY29kZSBjYWxsaW5nIGdsR2V0IitjKyJ2KCIrYSsiKSBhbmQgaXQgcmV0dXJucyAiK2UrIiBvZiB0eXBlICIrdHlwZW9mIGUrIiEiKTtyZXR1cm59c3dpdGNoKGMpe2Nhc2UgMTokZihiLGQpO2JyZWFrO2Nhc2UgMDpEW2I+PjJdPWQ7YnJlYWs7Y2FzZSAyOkJbYj4+Ml09ZDticmVhaztjYXNlIDQ6amJbYj4+MF09ZD8xOjB9fWVsc2UgTygxMjgxKX0KZnVuY3Rpb24gYmcoYSxiLGMsZCl7aWYoYyl7Yj1OLmdldEluZGV4ZWRQYXJhbWV0ZXIoYSxiKTtzd2l0Y2godHlwZW9mIGIpe2Nhc2UgImJvb2xlYW4iOmE9Yj8xOjA7YnJlYWs7Y2FzZSAibnVtYmVyIjphPWI7YnJlYWs7Y2FzZSAib2JqZWN0IjppZihudWxsPT09Yilzd2l0Y2goYSl7Y2FzZSAzNTk4MzpjYXNlIDM1MzY4OmE9MDticmVhaztkZWZhdWx0Ok8oMTI4MCk7cmV0dXJufWVsc2UgaWYoYiBpbnN0YW5jZW9mIFdlYkdMQnVmZmVyKWE9Yi5uYW1lfDA7ZWxzZXtPKDEyODApO3JldHVybn1icmVhaztkZWZhdWx0Ok8oMTI4MCk7cmV0dXJufXN3aXRjaChkKXtjYXNlIDE6JGYoYyxhKTticmVhaztjYXNlIDA6RFtjPj4yXT1hO2JyZWFrO2Nhc2UgMjpCW2M+PjJdPWE7YnJlYWs7Y2FzZSA0OmpiW2M+PjBdPWE/MTowO2JyZWFrO2RlZmF1bHQ6dGhyb3ciaW50ZXJuYWwgZW1zY3JpcHRlbldlYkdMR2V0SW5kZXhlZCgpIGVycm9yLCBiYWQgdHlwZTogIitkO319ZWxzZSBPKDEyODEpfQpmdW5jdGlvbiBjZyhhKXt2YXIgYj1mYihhKSsxLGM9ZGcoYik7ZWIoYSx0LGMsYik7cmV0dXJuIGN9ZnVuY3Rpb24gZWcoYSl7cmV0dXJuIl0iPT1hLnNsaWNlKC0xKSYmYS5sYXN0SW5kZXhPZigiWyIpfWZ1bmN0aW9uIGZnKGEpe3ZhciBiPWEuS2ksYz1hLm5qLGQ7aWYoIWIpZm9yKGEuS2k9Yj17fSxhLmZrPXt9LGQ9MDtkPE4uZ2V0UHJvZ3JhbVBhcmFtZXRlcihhLDM1NzE4KTsrK2Qpe3ZhciBlPU4uZ2V0QWN0aXZlVW5pZm9ybShhLGQpO3ZhciBmPWUubmFtZTtlPWUuc2l6ZTt2YXIgbD1lZyhmKTtsPTA8bD9mLnNsaWNlKDAsbCk6Zjt2YXIgbj1hLm1qO2EubWorPWU7Y1tsXT1bZSxuXTtmb3IoZj0wO2Y8ZTsrK2YpYltuXT1mLGEuZmtbbisrXT1sfX0KZnVuY3Rpb24gVihhKXt2YXIgYj1OLlFqO2lmKGIpe3ZhciBjPWIuS2lbYV07Im51bWJlciI9PXR5cGVvZiBjJiYoYi5LaVthXT1jPU4uZ2V0VW5pZm9ybUxvY2F0aW9uKGIsYi5ma1thXSsoMDxjPyJbIitjKyJdIjoiIikpKTtyZXR1cm4gY31PKDEyODIpfWZ1bmN0aW9uIGdnKGEsYixjLGQpe2lmKGMpaWYoYT1EZlthXSxmZyhhKSxhPU4uZ2V0VW5pZm9ybShhLFYoYikpLCJudW1iZXIiPT10eXBlb2YgYXx8ImJvb2xlYW4iPT10eXBlb2YgYSlzd2l0Y2goZCl7Y2FzZSAwOkRbYz4+Ml09YTticmVhaztjYXNlIDI6QltjPj4yXT1hfWVsc2UgZm9yKGI9MDtiPGEubGVuZ3RoO2IrKylzd2l0Y2goZCl7Y2FzZSAwOkRbYys0KmI+PjJdPWFbYl07YnJlYWs7Y2FzZSAyOkJbYys0KmI+PjJdPWFbYl19ZWxzZSBPKDEyODEpfQpmdW5jdGlvbiBoZyhhLGIsYyxkKXtpZihjKWlmKGE9Ti5nZXRWZXJ0ZXhBdHRyaWIoYSxiKSwzNDk3NT09YilEW2M+PjJdPWEmJmEubmFtZTtlbHNlIGlmKCJudW1iZXIiPT10eXBlb2YgYXx8ImJvb2xlYW4iPT10eXBlb2YgYSlzd2l0Y2goZCl7Y2FzZSAwOkRbYz4+Ml09YTticmVhaztjYXNlIDI6QltjPj4yXT1hO2JyZWFrO2Nhc2UgNTpEW2M+PjJdPU1hdGguZnJvdW5kKGEpfWVsc2UgZm9yKGI9MDtiPGEubGVuZ3RoO2IrKylzd2l0Y2goZCl7Y2FzZSAwOkRbYys0KmI+PjJdPWFbYl07YnJlYWs7Y2FzZSAyOkJbYys0KmI+PjJdPWFbYl07YnJlYWs7Y2FzZSA1OkRbYys0KmI+PjJdPU1hdGguZnJvdW5kKGFbYl0pfWVsc2UgTygxMjgxKX1mdW5jdGlvbiBpZyhhKXthLT01MTIwO3JldHVybiAwPT1hP2piOjE9PWE/dDoyPT1hP2tiOjQ9PWE/RDo2PT1hP0I6NT09YXx8Mjg5MjI9PWF8fDI4NTIwPT1hfHwzMDc3OT09YXx8MzA3ODI9PWE/aDpsYn0KZnVuY3Rpb24gamcoYSl7cmV0dXJuIDMxLU1hdGguY2x6MzIoYS5CWVRFU19QRVJfRUxFTUVOVCl9ZnVuY3Rpb24ga2coYSxiLGMsZCxlKXthPWlnKGEpO3ZhciBmPWpnKGEpLGw9UWY7cmV0dXJuIGEuc3ViYXJyYXkoZT4+ZixlK2QqKGMqKHs1OjMsNjo0LDg6MiwyOTUwMjozLDI5NTA0OjQsMjY5MTc6MiwyNjkxODoyLDI5ODQ2OjMsMjk4NDc6NH1bYi02NDAyXXx8MSkqKDE8PGYpK2wtMSYtbCk+PmYpfXZhciBsZz1bXSxtZz1bXSxuZz1bXSxvZz17fSxwZz1bImRlZmF1bHQiLCJsb3ctcG93ZXIiLCJoaWdoLXBlcmZvcm1hbmNlIl0scWc9WzAsInVuZGVmaW5lZCIhPXR5cGVvZiBkb2N1bWVudD9kb2N1bWVudDowLCJ1bmRlZmluZWQiIT10eXBlb2Ygd2luZG93P3dpbmRvdzowXTsKZnVuY3Rpb24gcmcoYSl7dHJ5e2lmKCFhKXJldHVybiB3aW5kb3c7Im51bWJlciI9PXR5cGVvZiBhJiYoYT1xZ1thXXx8ZGIoYSkpO3JldHVybiIjd2luZG93Ij09PWE/d2luZG93OiIjZG9jdW1lbnQiPT09YT9kb2N1bWVudDoiI3NjcmVlbiI9PT1hP3NjcmVlbjoiI2NhbnZhcyI9PT1hP2cuY2FudmFzOiJzdHJpbmciPT10eXBlb2YgYT9kb2N1bWVudC5nZXRFbGVtZW50QnlJZChhKTphfWNhdGNoKGIpe3JldHVybiBudWxsfX12YXIgc2c9e307CmZ1bmN0aW9uIHRnKCl7aWYoIXVnKXt2YXIgYT17VVNFUjoid2ViX3VzZXIiLExPR05BTUU6IndlYl91c2VyIixQQVRIOiIvIixQV0Q6Ii8iLEhPTUU6Ii9ob21lL3dlYl91c2VyIixMQU5HOigib2JqZWN0Ij09dHlwZW9mIG5hdmlnYXRvciYmbmF2aWdhdG9yLmxhbmd1YWdlcyYmbmF2aWdhdG9yLmxhbmd1YWdlc1swXXx8IkMiKS5yZXBsYWNlKCItIiwiXyIpKyIuVVRGLTgiLF86emF8fCIuL3RoaXMucHJvZ3JhbSJ9LGI7Zm9yKGIgaW4gc2cpdm9pZCAwPT09c2dbYl0/ZGVsZXRlIGFbYl06YVtiXT1zZ1tiXTt2YXIgYz1bXTtmb3IoYiBpbiBhKWMucHVzaChiKyI9IithW2JdKTt1Zz1jfXJldHVybiB1Z312YXIgdWc7CmZ1bmN0aW9uIHZnKGEsYil7YT1uZXcgVWludDhBcnJheShhKTt2YXIgYz1hLmJ5dGVMZW5ndGg7Zy5Zais9YysyNDtpZigzMjc2ODA+PWMpe3ZhciBkPW1hKCk7dHJ5e3ZhciBlPW5hKGMpO3Quc3ViYXJyYXkoZSxlK2MpLnNldChhKTtiKGUsYyl9ZmluYWxseXtzYShkKX19ZWxzZXtlPWRnKGMpO3RyeXt0LnN1YmFycmF5KGUsZStjKS5zZXQoYSksYihlLGMpfWZpbmFsbHl7YmUoZSl9fX0KdmFyIHhnPXtjb25uZWN0OmZ1bmN0aW9uKGEsYixjKXtnLnFqPWI7Zy5qaj13Zygid2ViU29ja2V0SGFuZGxlck9uTWVzc2FnZSIsbnVsbCxbIm51bWJlciIsIm51bWJlciIsIm51bWJlciIsIm51bWJlciJdKTtnLkhpP2cuSGkrKzpnLkhpPTE7Zy5laz0hMTtpZighZy53b3JrZXIpe2E9bmV3IFdvcmtlcihVUkwuY3JlYXRlT2JqZWN0VVJMKG5ldyBCbG9iKFsndmFyIHNvY2tldDtzZWxmLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldmVudCkge1x0aWYgKGV2ZW50LmRhdGEuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyKSB7XHRcdHNvY2tldC5zZW5kIChldmVudC5kYXRhKTtcdH0gZWxzZSBpZiAoZXZlbnQuZGF0YVswXSA9PT0gImNvbm5lY3QiKSB7XHRcdHNvY2tldCA9IG5ldyBXZWJTb2NrZXQgKGV2ZW50LmRhdGFbMV0pO1x0XHRzb2NrZXQuYmluYXJ5VHlwZSA9ICJhcnJheWJ1ZmZlciI7XHRcdHZhciB0b2tlbiA9IGV2ZW50LmRhdGFbMl07XHRcdHNvY2tldC5vbmNsb3NlID0gZnVuY3Rpb24gKGV2ZW50KSB7XHRcdFx0c2VsZi5wb3N0TWVzc2FnZSAoWyJjbG9zZSIsIHRva2VuXSk7XHRcdH07XHRcdHNvY2tldC5vbmVycm9yID0gZnVuY3Rpb24gKGV2ZW50KSB7XHRcdFx0c2VsZi5wb3N0TWVzc2FnZSAoWyJlcnJvciIsIHRva2VuXSk7XHRcdH07XHRcdHNvY2tldC5vbm9wZW4gPSBmdW5jdGlvbiAoZXZlbnQpIHtcdFx0XHRzZWxmLnBvc3RNZXNzYWdlIChbIm9wZW4iLCB0b2tlbl0pO1x0XHR9O1x0XHRzb2NrZXQub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XHRcdFx0c2VsZi5wb3N0TWVzc2FnZSAoWyJkYXRhIiwgZXZlbnQuZGF0YSwgdG9rZW5dLCBbZXZlbnQuZGF0YV0pO1x0XHR9O1x0fSBlbHNlIGlmIChldmVudC5kYXRhWzBdID09PSAiY2xvc2UiKSB7XHRcdHNvY2tldC5jbG9zZSAoKTtcdH19J10se3R5cGU6ImFwcGxpY2F0aW9uL2phdmFzY3JpcHQifSkpKTsKZy53b3JrZXI9YTt2YXIgZD1mdW5jdGlvbihlLGYpe2cuamooZSxmLGcucWosMil9O2Eub25tZXNzYWdlPWZ1bmN0aW9uKGUpe2cuJCRmYWNhZGUmJigiZGF0YSI9PT1lLmRhdGFbMF0/ZS5kYXRhWzJdPT09Zy5IaSYmdmcoZS5kYXRhWzFdLGQpOiJvcGVuIj09PWUuZGF0YVswXT9lLmRhdGFbMV09PT1nLkhpJiYoZy5laz0hMCxnLmpqKDAsMCxnLnFqLDApKToiY2xvc2UiPT09ZS5kYXRhWzBdP2UuZGF0YVsxXT09PWcuSGkmJihnLmpqKDAsMCxnLnFqLDMpLGcuZ2koIndlYnNvY2tldF9jb25uZWN0aW9uX2Nsb3NlZCIpKToiZXJyb3IiPT09ZS5kYXRhWzBdJiZlLmRhdGFbMV09PT1nLkhpJiZnLmdpKGcuZWs/InNvY2tldF9lcnJvciI6InNvY2tldF9vcGVuX2ZhaWxlZCIpKX19Zy53b3JrZXIucG9zdE1lc3NhZ2UoWyJjb25uZWN0IixkYihjKSxnLkhpXSl9LEZqOmZ1bmN0aW9uKGEsYil7Zy53b3JrZXImJihhPShuZXcgVWludDhBcnJheSh0LnN1YmFycmF5KGEsYStiKSkpLmJ1ZmZlciwKZy53b3JrZXIucG9zdE1lc3NhZ2UoYSxbYV0pKX0sY2xvc2U6ZnVuY3Rpb24oKXtnLndvcmtlciYmZy53b3JrZXIucG9zdE1lc3NhZ2UoWyJjbG9zZSJdKTtnLmpqPWZ1bmN0aW9uKCl7fX19LHlnPXtjb25uZWN0OmZ1bmN0aW9uKGEsYixjKXtmdW5jdGlvbiBkKG4scSl7ZihuLHEsYiwyKX1hPWRiKGMpO3ZhciBlPW5ldyBXZWJTb2NrZXQoYSk7Zy5DaT1lO2UuYmluYXJ5VHlwZT0iYXJyYXlidWZmZXIiO3ZhciBmPXdnKCJ3ZWJTb2NrZXRIYW5kbGVyT25NZXNzYWdlIixudWxsLFsibnVtYmVyIiwibnVtYmVyIiwibnVtYmVyIiwibnVtYmVyIl0pLGw9ITE7ZS5vbmNsb3NlPWZ1bmN0aW9uKCl7Zy5DaT09PWUmJihmKDAsMCxiLDMpLGcuZ2koIndlYnNvY2tldF9jb25uZWN0aW9uX2Nsb3NlZCIpKX07ZS5vbmVycm9yPWZ1bmN0aW9uKCl7Zy5DaT09PWUmJmcuZ2kobD8ic29ja2V0X2Vycm9yIjoic29ja2V0X29wZW5fZmFpbGVkIil9O2Uub25vcGVuPWZ1bmN0aW9uKCl7Zy5DaT09PWUmJgoobD0hMCxmKDAsMCxiLDApKX07ZS5vbm1lc3NhZ2U9ZnVuY3Rpb24obil7Zy5DaT09PWUmJnZnKG4uZGF0YSxkKX19LEZqOmZ1bmN0aW9uKGEsYil7Zy5DaSYmZy5DaS5zZW5kKHQuc3ViYXJyYXkoYSxhK2IpKX0sY2xvc2U6ZnVuY3Rpb24oKXtnLkNpJiZnLkNpLmNsb3NlKCk7ZGVsZXRlIGcuQ2l9fTtmdW5jdGlvbiB6ZyhhKXtyZXR1cm4gMD09PWElNCYmKDAhPT1hJTEwMHx8MD09PWElNDAwKX12YXIgQWc9WzMxLDI5LDMxLDMwLDMxLDMwLDMxLDMxLDMwLDMxLDMwLDMxXSxCZz1bMzEsMjgsMzEsMzAsMzEsMzAsMzEsMzEsMzAsMzEsMzAsMzFdOwpmdW5jdGlvbiBDZyhhLGIsYyxkKXtmdW5jdGlvbiBlKHAseSxGKXtmb3IocD0ibnVtYmVyIj09dHlwZW9mIHA/cC50b1N0cmluZygpOnB8fCIiO3AubGVuZ3RoPHk7KXA9RlswXStwO3JldHVybiBwfWZ1bmN0aW9uIGYocCx5KXtyZXR1cm4gZShwLHksIjAiKX1mdW5jdGlvbiBsKHAseSl7ZnVuY3Rpb24gRihjYSl7cmV0dXJuIDA+Y2E/LTE6MDxjYT8xOjB9dmFyIFI7MD09PShSPUYocC5nZXRGdWxsWWVhcigpLXkuZ2V0RnVsbFllYXIoKSkpJiYwPT09KFI9RihwLmdldE1vbnRoKCkteS5nZXRNb250aCgpKSkmJihSPUYocC5nZXREYXRlKCkteS5nZXREYXRlKCkpKTtyZXR1cm4gUn1mdW5jdGlvbiBuKHApe3N3aXRjaChwLmdldERheSgpKXtjYXNlIDA6cmV0dXJuIG5ldyBEYXRlKHAuZ2V0RnVsbFllYXIoKS0xLDExLDI5KTtjYXNlIDE6cmV0dXJuIHA7Y2FzZSAyOnJldHVybiBuZXcgRGF0ZShwLmdldEZ1bGxZZWFyKCksMCwzKTtjYXNlIDM6cmV0dXJuIG5ldyBEYXRlKHAuZ2V0RnVsbFllYXIoKSwKMCwyKTtjYXNlIDQ6cmV0dXJuIG5ldyBEYXRlKHAuZ2V0RnVsbFllYXIoKSwwLDEpO2Nhc2UgNTpyZXR1cm4gbmV3IERhdGUocC5nZXRGdWxsWWVhcigpLTEsMTEsMzEpO2Nhc2UgNjpyZXR1cm4gbmV3IERhdGUocC5nZXRGdWxsWWVhcigpLTEsMTEsMzApfX1mdW5jdGlvbiBxKHApe3ZhciB5PXAuSWk7Zm9yKHA9bmV3IERhdGUoKG5ldyBEYXRlKHAuSmkrMTkwMCwwLDEpKS5nZXRUaW1lKCkpOzA8eTspe3ZhciBGPXAuZ2V0TW9udGgoKSxSPSh6ZyhwLmdldEZ1bGxZZWFyKCkpP0FnOkJnKVtGXTtpZih5PlItcC5nZXREYXRlKCkpeS09Ui1wLmdldERhdGUoKSsxLHAuc2V0RGF0ZSgxKSwxMT5GP3Auc2V0TW9udGgoRisxKToocC5zZXRNb250aCgwKSxwLnNldEZ1bGxZZWFyKHAuZ2V0RnVsbFllYXIoKSsxKSk7ZWxzZXtwLnNldERhdGUocC5nZXREYXRlKCkreSk7YnJlYWt9fUY9bmV3IERhdGUocC5nZXRGdWxsWWVhcigpKzEsMCw0KTt5PW4obmV3IERhdGUocC5nZXRGdWxsWWVhcigpLAowLDQpKTtGPW4oRik7cmV0dXJuIDA+PWwoeSxwKT8wPj1sKEYscCk/cC5nZXRGdWxsWWVhcigpKzE6cC5nZXRGdWxsWWVhcigpOnAuZ2V0RnVsbFllYXIoKS0xfXZhciB2PURbZCs0MD4+Ml07ZD17V2s6RFtkPj4yXSxWazpEW2QrND4+Ml0sa2o6RFtkKzg+PjJdLEpqOkRbZCsxMj4+Ml0sbGo6RFtkKzE2Pj4yXSxKaTpEW2QrMjA+PjJdLHdpOkRbZCsyND4+Ml0sSWk6RFtkKzI4Pj4yXSxxbDpEW2QrMzI+PjJdLFVrOkRbZCszNj4+Ml0sWGs6dj9kYih2KToiIn07Yz1kYihjKTt2PXsiJWMiOiIlYSAlYiAlZCAlSDolTTolUyAlWSIsIiVEIjoiJW0vJWQvJXkiLCIlRiI6IiVZLSVtLSVkIiwiJWgiOiIlYiIsIiVyIjoiJUk6JU06JVMgJXAiLCIlUiI6IiVIOiVNIiwiJVQiOiIlSDolTTolUyIsIiV4IjoiJW0vJWQvJXkiLCIlWCI6IiVIOiVNOiVTIiwiJUVjIjoiJWMiLCIlRUMiOiIlQyIsIiVFeCI6IiVtLyVkLyV5IiwiJUVYIjoiJUg6JU06JVMiLCIlRXkiOiIleSIsIiVFWSI6IiVZIiwKIiVPZCI6IiVkIiwiJU9lIjoiJWUiLCIlT0giOiIlSCIsIiVPSSI6IiVJIiwiJU9tIjoiJW0iLCIlT00iOiIlTSIsIiVPUyI6IiVTIiwiJU91IjoiJXUiLCIlT1UiOiIlVSIsIiVPViI6IiVWIiwiJU93IjoiJXciLCIlT1ciOiIlVyIsIiVPeSI6IiV5In07Zm9yKHZhciB3IGluIHYpYz1jLnJlcGxhY2UobmV3IFJlZ0V4cCh3LCJnIiksdlt3XSk7dmFyIEM9IlN1bmRheSBNb25kYXkgVHVlc2RheSBXZWRuZXNkYXkgVGh1cnNkYXkgRnJpZGF5IFNhdHVyZGF5Ii5zcGxpdCgiICIpLEc9IkphbnVhcnkgRmVicnVhcnkgTWFyY2ggQXByaWwgTWF5IEp1bmUgSnVseSBBdWd1c3QgU2VwdGVtYmVyIE9jdG9iZXIgTm92ZW1iZXIgRGVjZW1iZXIiLnNwbGl0KCIgIik7dj17IiVhIjpmdW5jdGlvbihwKXtyZXR1cm4gQ1twLndpXS5zdWJzdHJpbmcoMCwzKX0sIiVBIjpmdW5jdGlvbihwKXtyZXR1cm4gQ1twLndpXX0sIiViIjpmdW5jdGlvbihwKXtyZXR1cm4gR1twLmxqXS5zdWJzdHJpbmcoMCwzKX0sCiIlQiI6ZnVuY3Rpb24ocCl7cmV0dXJuIEdbcC5sal19LCIlQyI6ZnVuY3Rpb24ocCl7cmV0dXJuIGYoKHAuSmkrMTkwMCkvMTAwfDAsMil9LCIlZCI6ZnVuY3Rpb24ocCl7cmV0dXJuIGYocC5KaiwyKX0sIiVlIjpmdW5jdGlvbihwKXtyZXR1cm4gZShwLkpqLDIsIiAiKX0sIiVnIjpmdW5jdGlvbihwKXtyZXR1cm4gcShwKS50b1N0cmluZygpLnN1YnN0cmluZygyKX0sIiVHIjpmdW5jdGlvbihwKXtyZXR1cm4gcShwKX0sIiVIIjpmdW5jdGlvbihwKXtyZXR1cm4gZihwLmtqLDIpfSwiJUkiOmZ1bmN0aW9uKHApe3A9cC5rajswPT1wP3A9MTI6MTI8cCYmKHAtPTEyKTtyZXR1cm4gZihwLDIpfSwiJWoiOmZ1bmN0aW9uKHApe2Zvcih2YXIgeT0wLEY9MDtGPD1wLmxqLTE7eSs9KHpnKHAuSmkrMTkwMCk/QWc6QmcpW0YrK10pO3JldHVybiBmKHAuSmoreSwzKX0sIiVtIjpmdW5jdGlvbihwKXtyZXR1cm4gZihwLmxqKzEsMil9LCIlTSI6ZnVuY3Rpb24ocCl7cmV0dXJuIGYocC5WaywyKX0sCiIlbiI6ZnVuY3Rpb24oKXtyZXR1cm4iXG4ifSwiJXAiOmZ1bmN0aW9uKHApe3JldHVybiAwPD1wLmtqJiYxMj5wLmtqPyJBTSI6IlBNIn0sIiVTIjpmdW5jdGlvbihwKXtyZXR1cm4gZihwLldrLDIpfSwiJXQiOmZ1bmN0aW9uKCl7cmV0dXJuIlx0In0sIiV1IjpmdW5jdGlvbihwKXtyZXR1cm4gcC53aXx8N30sIiVVIjpmdW5jdGlvbihwKXtyZXR1cm4gZihNYXRoLmZsb29yKChwLklpKzctcC53aSkvNyksMil9LCIlViI6ZnVuY3Rpb24ocCl7dmFyIHk9TWF0aC5mbG9vcigocC5JaSs3LShwLndpKzYpJTcpLzcpOzI+PShwLndpKzM3MS1wLklpLTIpJTcmJnkrKztpZih5KTUzPT15JiYoRj0ocC53aSszNzEtcC5JaSklNyw0PT1GfHwzPT1GJiZ6ZyhwLkppKXx8KHk9MSkpO2Vsc2V7eT01Mjt2YXIgRj0ocC53aSs3LXAuSWktMSklNzsoND09Rnx8NT09RiYmemcocC5KaSU0MDAtMSkpJiZ5Kyt9cmV0dXJuIGYoeSwyKX0sIiV3IjpmdW5jdGlvbihwKXtyZXR1cm4gcC53aX0sIiVXIjpmdW5jdGlvbihwKXtyZXR1cm4gZihNYXRoLmZsb29yKChwLklpKwo3LShwLndpKzYpJTcpLzcpLDIpfSwiJXkiOmZ1bmN0aW9uKHApe3JldHVybihwLkppKzE5MDApLnRvU3RyaW5nKCkuc3Vic3RyaW5nKDIpfSwiJVkiOmZ1bmN0aW9uKHApe3JldHVybiBwLkppKzE5MDB9LCIleiI6ZnVuY3Rpb24ocCl7cD1wLlVrO3ZhciB5PTA8PXA7cD1NYXRoLmFicyhwKS82MDtyZXR1cm4oeT8iKyI6Ii0iKStTdHJpbmcoIjAwMDAiKyhwLzYwKjEwMCtwJTYwKSkuc2xpY2UoLTQpfSwiJVoiOmZ1bmN0aW9uKHApe3JldHVybiBwLlhrfSwiJSUiOmZ1bmN0aW9uKCl7cmV0dXJuIiUifX07Yz1jLnJlcGxhY2UoLyUlL2csIlx4MDBceDAwIik7Zm9yKHcgaW4gdiljLmluY2x1ZGVzKHcpJiYoYz1jLnJlcGxhY2UobmV3IFJlZ0V4cCh3LCJnIiksdlt3XShkKSkpO2M9Yy5yZXBsYWNlKC9cMFwwL2csIiUiKTt3PVdiKGMsITEpO2lmKHcubGVuZ3RoPmIpcmV0dXJuIDA7amIuc2V0KHcsYSk7cmV0dXJuIHcubGVuZ3RoLTF9CmZ1bmN0aW9uIERnKGEsYixjLGQpe3ZhciBlPXtzdHJpbmc6dj0+e3ZhciB3PTA7aWYobnVsbCE9PXYmJnZvaWQgMCE9PXYmJjAhPT12KXt2YXIgQz0odi5sZW5ndGg8PDIpKzE7dz1uYShDKTtlYih2LHQsdyxDKX1yZXR1cm4gd30sYXJyYXk6dj0+e3ZhciB3PW5hKHYubGVuZ3RoKTtqYi5zZXQodix3KTtyZXR1cm4gd319O2E9Z1siXyIrYV07dmFyIGY9W10sbD0wO2lmKGQpZm9yKHZhciBuPTA7bjxkLmxlbmd0aDtuKyspe3ZhciBxPWVbY1tuXV07cT8oMD09PWwmJihsPW1hKCkpLGZbbl09cShkW25dKSk6ZltuXT1kW25dfWM9YS5hcHBseShudWxsLGYpO3JldHVybiBjPWZ1bmN0aW9uKHYpezAhPT1sJiZzYShsKTtyZXR1cm4ic3RyaW5nIj09PWI/ZGIodik6ImJvb2xlYW4iPT09Yj8hIXY6dn0oYyl9CmZ1bmN0aW9uIHdnKGEsYixjLGQpe2M9Y3x8W107dmFyIGU9Yy5ldmVyeShmPT4ibnVtYmVyIj09PWZ8fCJib29sZWFuIj09PWYpO3JldHVybiJzdHJpbmciIT09YiYmZSYmIWQ/Z1siXyIrYV06ZnVuY3Rpb24oKXtyZXR1cm4gRGcoYSxiLGMsYXJndW1lbnRzLGQpfX1mdW5jdGlvbiB0YyhhLGIsYyxkKXthfHwoYT10aGlzKTt0aGlzLnBhcmVudD1hO3RoaXMuQWk9YS5BaTt0aGlzLlRpPW51bGw7dGhpcy5pZD1sYysrO3RoaXMubmFtZT1iO3RoaXMubW9kZT1jO3RoaXMuZWk9e307dGhpcy5maT17fTt0aGlzLnJkZXY9ZH0KT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGMucHJvdG90eXBlLHtyZWFkOntnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gMzY1PT09KHRoaXMubW9kZSYzNjUpfSxzZXQ6ZnVuY3Rpb24oYSl7YT90aGlzLm1vZGV8PTM2NTp0aGlzLm1vZGUmPS0zNjZ9fSx3cml0ZTp7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIDE0Nj09PSh0aGlzLm1vZGUmMTQ2KX0sc2V0OmZ1bmN0aW9uKGEpe2E/dGhpcy5tb2RlfD0xNDY6dGhpcy5tb2RlJj0tMTQ3fX0sQms6e2dldDpmdW5jdGlvbigpe3JldHVybiAxNjM4ND09PSh0aGlzLm1vZGUmNjE0NDApfX0sQWs6e2dldDpmdW5jdGlvbigpe3JldHVybiA4MTkyPT09KHRoaXMubW9kZSY2MTQ0MCl9fX0pO1BjKCk7bWM9QXJyYXkoNDA5Nik7QWMoSiwiLyIpO0JjKCIvdG1wIiwxNjg5NSwwKTtCYygiL2hvbWUiLDE2ODk1LDApO0JjKCIvaG9tZS93ZWJfdXNlciIsMTY4OTUsMCk7CigoKT0+e0JjKCIvZGV2IiwxNjg5NSwwKTtaYigyNTkse3JlYWQ6KCk9PjAsd3JpdGU6KGIsYyxkLGUpPT5lfSk7Q2MoIi9kZXYvbnVsbCIsMjU5KTtZYigxMjgwLGFjKTtZYigxNTM2LGJjKTtDYygiL2Rldi90dHkiLDEyODApO0NjKCIvZGV2L3R0eTEiLDE1MzYpO3ZhciBhPVViKCk7VmMoIi9kZXYiLCJyYW5kb20iLGEpO1ZjKCIvZGV2IiwidXJhbmRvbSIsYSk7QmMoIi9kZXYvc2htIiwxNjg5NSwwKTtCYygiL2Rldi9zaG0vdG1wIiwxNjg5NSwwKX0pKCk7CigoKT0+e0JjKCIvcHJvYyIsMTY4OTUsMCk7dmFyIGE9QmMoIi9wcm9jL3NlbGYiLDE2ODk1LDApO0JjKCIvcHJvYy9zZWxmL2ZkIiwxNjg5NSwwKTtBYyh7QWk6KCk9Pnt2YXIgYj1kYyhhLCJmZCIsMTY4OTUsNzMpO2IuZWk9e2xvb2t1cDooYyxkKT0+e3ZhciBlPWtjWytkXTtpZighZSl0aHJvdyBuZXcgSSg4KTtjPXtwYXJlbnQ6bnVsbCxBaTp7JGo6ImZha2UifSxlaTp7cmVhZGxpbms6KCk9PmUucGF0aH19O3JldHVybiBjLnBhcmVudD1jfX07cmV0dXJuIGJ9fSwiL3Byb2Mvc2VsZi9mZCIpfSkoKTtnLkZTX2NyZWF0ZVBhdGg9U2M7Zy5GU19jcmVhdGVEYXRhRmlsZT1VYztnLkZTX2NyZWF0ZVByZWxvYWRlZEZpbGU9WmM7Zy5GU191bmxpbms9RWM7Zy5GU19jcmVhdGVMYXp5RmlsZT1YYztnLkZTX2NyZWF0ZURldmljZT1WYztuZD1nLkludGVybmFsRXJyb3I9bWQoIkludGVybmFsRXJyb3IiKTtmb3IodmFyIEVnPUFycmF5KDI1NiksRmc9MDsyNTY+Rmc7KytGZylFZ1tGZ109U3RyaW5nLmZyb21DaGFyQ29kZShGZyk7CnRkPUVnO3ZkPWcuQmluZGluZ0Vycm9yPW1kKCJCaW5kaW5nRXJyb3IiKTtMZC5wcm90b3R5cGUuaXNBbGlhc09mPWZ1bmN0aW9uKGEpe2lmKCEodGhpcyBpbnN0YW5jZW9mIExkJiZhIGluc3RhbmNlb2YgTGQpKXJldHVybiExO3ZhciBiPXRoaXMuY2kua2kuamksYz10aGlzLmNpLmhpLGQ9YS5jaS5raS5qaTtmb3IoYT1hLmNpLmhpO2IudWk7KWM9Yi5XaShjKSxiPWIudWk7Zm9yKDtkLnVpOylhPWQuV2koYSksZD1kLnVpO3JldHVybiBiPT09ZCYmYz09PWF9OwpMZC5wcm90b3R5cGUuY2xvbmU9ZnVuY3Rpb24oKXt0aGlzLmNpLmhpfHx5ZCh0aGlzKTtpZih0aGlzLmNpLlVpKXJldHVybiB0aGlzLmNpLmNvdW50LnZhbHVlKz0xLHRoaXM7dmFyIGE9S2QsYj1PYmplY3QsYz1iLmNyZWF0ZSxkPU9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSxlPXRoaXMuY2k7YT1hKGMuY2FsbChiLGQse2NpOnt2YWx1ZTp7Y291bnQ6ZS5jb3VudCxNaTplLk1pLFVpOmUuVWksaGk6ZS5oaSxraTplLmtpLG9pOmUub2ksdGk6ZS50aX19fSkpO2EuY2kuY291bnQudmFsdWUrPTE7YS5jaS5NaT0hMTtyZXR1cm4gYX07TGQucHJvdG90eXBlWyJkZWxldGUiXT1mdW5jdGlvbigpe3RoaXMuY2kuaGl8fHlkKHRoaXMpO3RoaXMuY2kuTWkmJiF0aGlzLmNpLlVpJiZ4ZCgiT2JqZWN0IGFscmVhZHkgc2NoZWR1bGVkIGZvciBkZWxldGlvbiIpO0FkKHRoaXMpO0JkKHRoaXMuY2kpO3RoaXMuY2kuVWl8fCh0aGlzLmNpLm9pPXZvaWQgMCx0aGlzLmNpLmhpPXZvaWQgMCl9OwpMZC5wcm90b3R5cGUuaXNEZWxldGVkPWZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMuY2kuaGl9O0xkLnByb3RvdHlwZS5kZWxldGVMYXRlcj1mdW5jdGlvbigpe3RoaXMuY2kuaGl8fHlkKHRoaXMpO3RoaXMuY2kuTWkmJiF0aGlzLmNpLlVpJiZ4ZCgiT2JqZWN0IGFscmVhZHkgc2NoZWR1bGVkIGZvciBkZWxldGlvbiIpO0VkLnB1c2godGhpcyk7MT09PUVkLmxlbmd0aCYmR2QmJkdkKEZkKTt0aGlzLmNpLk1pPSEwO3JldHVybiB0aGlzfTtnLmdldEluaGVyaXRlZEluc3RhbmNlQ291bnQ9ZnVuY3Rpb24oKXtyZXR1cm4gT2JqZWN0LmtleXMoSGQpLmxlbmd0aH07Zy5nZXRMaXZlSW5oZXJpdGVkSW5zdGFuY2VzPWZ1bmN0aW9uKCl7dmFyIGE9W10sYjtmb3IoYiBpbiBIZClIZC5oYXNPd25Qcm9wZXJ0eShiKSYmYS5wdXNoKEhkW2JdKTtyZXR1cm4gYX07Zy5mbHVzaFBlbmRpbmdEZWxldGVzPUZkO2cuc2V0RGVsYXlGdW5jdGlvbj1mdW5jdGlvbihhKXtHZD1hO0VkLmxlbmd0aCYmR2QmJkdkKEZkKX07ClZkLnByb3RvdHlwZS51az1mdW5jdGlvbihhKXt0aGlzLmNrJiYoYT10aGlzLmNrKGEpKTtyZXR1cm4gYX07VmQucHJvdG90eXBlLlJqPWZ1bmN0aW9uKGEpe3RoaXMuc2kmJnRoaXMuc2koYSl9O1ZkLnByb3RvdHlwZS5hcmdQYWNrQWR2YW5jZT04O1ZkLnByb3RvdHlwZS5yZWFkVmFsdWVGcm9tUG9pbnRlcj1mZDtWZC5wcm90b3R5cGUuZGVsZXRlT2JqZWN0PWZ1bmN0aW9uKGEpe2lmKG51bGwhPT1hKWFbImRlbGV0ZSJdKCl9OwpWZC5wcm90b3R5cGUuZnJvbVdpcmVUeXBlPWZ1bmN0aW9uKGEpe2Z1bmN0aW9uIGIoKXtyZXR1cm4gdGhpcy5kaj9KZCh0aGlzLmppLlNpLHtraTp0aGlzLkdrLGhpOmMsdGk6dGhpcyxvaTphfSk6SmQodGhpcy5qaS5TaSx7a2k6dGhpcyxoaTphfSl9dmFyIGM9dGhpcy51ayhhKTtpZighYylyZXR1cm4gdGhpcy5SaihhKSxudWxsO3ZhciBkPUlkKHRoaXMuamksYyk7aWYodm9pZCAwIT09ZCl7aWYoMD09PWQuY2kuY291bnQudmFsdWUpcmV0dXJuIGQuY2kuaGk9YyxkLmNpLm9pPWEsZC5jbG9uZSgpO2Q9ZC5jbG9uZSgpO3RoaXMuUmooYSk7cmV0dXJuIGR9ZD10aGlzLmppLnRrKGMpO2Q9RGRbZF07aWYoIWQpcmV0dXJuIGIuY2FsbCh0aGlzKTtkPXRoaXMuY2o/ZC5tazpkLnBvaW50ZXJUeXBlO3ZhciBlPUNkKGMsdGhpcy5qaSxkLmppKTtyZXR1cm4gbnVsbD09PWU/Yi5jYWxsKHRoaXMpOnRoaXMuZGo/SmQoZC5qaS5TaSx7a2k6ZCxoaTplLHRpOnRoaXMsb2k6YX0pOkpkKGQuamkuU2ksCntraTpkLGhpOmV9KX07WmQ9Zy5VbmJvdW5kVHlwZUVycm9yPW1kKCJVbmJvdW5kVHlwZUVycm9yIik7Zy5jb3VudF9lbXZhbF9oYW5kbGVzPWZ1bmN0aW9uKCl7Zm9yKHZhciBhPTAsYj01O2I8Z2UubGVuZ3RoOysrYil2b2lkIDAhPT1nZVtiXSYmKythO3JldHVybiBhfTtnLmdldF9maXJzdF9lbXZhbD1mdW5jdGlvbigpe2Zvcih2YXIgYT01O2E8Z2UubGVuZ3RoOysrYSlpZih2b2lkIDAhPT1nZVthXSlyZXR1cm4gZ2VbYV07cmV0dXJuIG51bGx9O2cucmVxdWVzdEZ1bGxzY3JlZW49ZnVuY3Rpb24oYSxiKXtyZihhLGIpfTtnLnJlcXVlc3RBbmltYXRpb25GcmFtZT1mdW5jdGlvbihhKXtOZShhKX07Zy5zZXRDYW52YXNTaXplPWZ1bmN0aW9uKGEsYixjKXt0ZihnLmNhbnZhcyxhLGIpO2N8fHVmKCl9O2cucGF1c2VNYWluTG9vcD1mdW5jdGlvbigpe0plPW51bGw7UmUrK307CmcucmVzdW1lTWFpbkxvb3A9ZnVuY3Rpb24oKXtSZSsrO3ZhciBhPUZlLGI9R2UsYz1IZTtIZT1udWxsO1FlKGMpO0VlKGEsYik7SmUoKX07Zy5nZXRVc2VyTWVkaWE9ZnVuY3Rpb24oKXt3aW5kb3cuZ2V0VXNlck1lZGlhfHwod2luZG93LmdldFVzZXJNZWRpYT1uYXZpZ2F0b3IuZ2V0VXNlck1lZGlhfHxuYXZpZ2F0b3IubW96R2V0VXNlck1lZGlhKTt3aW5kb3cuZ2V0VXNlck1lZGlhKHZvaWQgMCl9O2cuY3JlYXRlQ29udGV4dD1mdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4gamYoYSxiLGMsZCl9O2Zvcih2YXIgTixHZz0wOzMyPkdnOysrR2cpV2YucHVzaChBcnJheShHZykpO3ZhciBIZz1uZXcgRmxvYXQzMkFycmF5KDI4OCk7Zm9yKEdnPTA7Mjg4PkdnOysrR2cpbGdbR2ddPUhnLnN1YmFycmF5KDAsR2crMSk7dmFyIElnPW5ldyBJbnQzMkFycmF5KDI4OCk7Zm9yKEdnPTA7Mjg4PkdnOysrR2cpbWdbR2ddPUlnLnN1YmFycmF5KDAsR2crMSk7CnZhciBLZz17S2E6ZnVuY3Rpb24oYSxiLGMpe0xiW2FdPXZvaWQgMDt0cnl7dmFyIGQ9W25ldyBGbG9hdDMyQXJyYXkoYiksbmV3IFVpbnQxNkFycmF5KGMpXX1jYXRjaChlKXtyZXR1cm4gMH1MYlthXT1kO3JldHVybiAxfSxKYTpmdW5jdGlvbihhLGIsYyxkLGUpe0xiW2FdPXZvaWQgMDtjPj49MjtlPj49MTt0cnl7dmFyIGY9W25ldyBGbG9hdDMyQXJyYXkoQi5zdWJhcnJheShjLGMrYikpLG5ldyBVaW50MTZBcnJheShsYi5zdWJhcnJheShlLGUrZCkpXX1jYXRjaChsKXtyZXR1cm4gMH1MYlthXT1mO3JldHVybiAxfSxMYTpmdW5jdGlvbihhKXtMYlthXT12b2lkIDB9LE5hOmZ1bmN0aW9uKCl7aWYoTWIubGVuZ3RoKXJldHVybiBNYi5wb3AoKTt2YXIgYT1MYi5sZW5ndGg7TGJbYV09dm9pZCAwO3JldHVybiBhfSxNYTpmdW5jdGlvbihhKXtMYlthXT12b2lkIDA7TWIucHVzaChhKX0sRGg6ZnVuY3Rpb24oYSxiKXtpZighYilyZXR1cm4gMDthPUxiW2FdO2lmKCFhKXJldHVybiAwOwphPWFbMV07cmV0dXJuIGEubGVuZ3RoPyhsYi5zZXQoYSxiPj4xKSwxKTowfSxFaDpmdW5jdGlvbihhLGIpe2lmKCFiKXJldHVybiAwO2E9TGJbYV07aWYoIWEpcmV0dXJuIDA7YT1hWzBdO3JldHVybiBhLmxlbmd0aD8oQi5zZXQoYSxiPj4yKSwxKTowfSxIYTpmdW5jdGlvbihhKXtyZXR1cm4oYT1MYlthXSk/YVsxXS5sZW5ndGg6MH0sQmg6ZnVuY3Rpb24oYSxiKXthPUxiW2FdO2lmKCFhKXJldHVybiAwO2E9YVsxXTtyZXR1cm4gYS5sZW5ndGg/KE4uYnVmZmVyU3ViRGF0YShOLkVMRU1FTlRfQVJSQVlfQlVGRkVSLGIsYSksMSk6MH0semg6ZnVuY3Rpb24oYSxiLGMsZCl7YT1MYlthXTtpZighYSlyZXR1cm4gMDthPWFbMV07dHJ5e3ZhciBlPW5ldyBVaW50OEFycmF5KGEuYnVmZmVyLGIsYyl9Y2F0Y2goZil7cmV0dXJuIDB9cmV0dXJuIGUubGVuZ3RoPyhOLmJ1ZmZlclN1YkRhdGEoTi5FTEVNRU5UX0FSUkFZX0JVRkZFUixkLGUpLDEpOjB9LENoOmZ1bmN0aW9uKGEsYil7YT1MYlthXTsKaWYoIWEpcmV0dXJuIDA7YT1hWzBdO3JldHVybiBhLmxlbmd0aD8oTi5idWZmZXJTdWJEYXRhKE4uQVJSQVlfQlVGRkVSLGIsYSksMSk6MH0sQWg6ZnVuY3Rpb24oYSxiLGMsZCl7YT1MYlthXTtpZighYSlyZXR1cm4gMDthPWFbMF07dHJ5e3ZhciBlPW5ldyBVaW50OEFycmF5KGEuYnVmZmVyLGIsYyl9Y2F0Y2goZil7cmV0dXJuIDB9cmV0dXJuIGUubGVuZ3RoPyhOLmJ1ZmZlclN1YkRhdGEoTi5BUlJBWV9CVUZGRVIsZCxlKSwxKTowfSxHYTpmdW5jdGlvbihhLGIsYyxkKXthPUxiW2FdO2lmKCFhKXJldHVybiAwO2E9YVswXTtyZXR1cm4gYS5sZW5ndGgmJmI8YS5sZW5ndGgmJmEubGVuZ3RoLWI+PWM/KGQ+Pj0yLGEuc2V0KEIuc3ViYXJyYXkoZCxkK2MpLGIpLDEpOjB9LElhOmZ1bmN0aW9uKGEpe3JldHVybihhPUxiW2FdKT9hWzBdLmxlbmd0aDowfSxFYjpmdW5jdGlvbihhLGIpezA+YSYmKGErPTQyOTQ5NjcyOTYpOzA+YiYmKGIrPTQyOTQ5NjcyOTYpO2cuZ2koImFubm91bmNlX21vZGVsIiwKYSxiKX0sWTpmdW5jdGlvbihhLGIsYyl7dmFyIGQ9Zy4kJGZhY2FkZTtpZihkKXt2YXIgZT1nLmNhbGxBZnRlck1hcCxmPSsrZS5pbmRleCxsPWZ1bmN0aW9uKG4pe2Q9PT1nLiQkZmFjYWRlJiZEZygiY2FsbEZ1bmNXcmFwcGVyIixudWxsLFsibnVtYmVyIiwibnVtYmVyIiwibnVtYmVyIl0sW2EsIW4sYl0pO2RlbGV0ZSBlLmluZGV4ZWRXcmFwcGVyc1tmXX07ZS5pbmRleGVkV3JhcHBlcnNbZl09bDswPD1jP1hlKGwsYyk6d2YobCl9fSxzZTpmdW5jdGlvbigpe2Zvcih2YXIgYT1nLmNhbGxBZnRlck1hcCxiPWEuaW5kZXhlZFdyYXBwZXJzLGM9T2JqZWN0LmtleXMoYiksZD0wO2Q8Yy5sZW5ndGg7KytkKWJbY1tkXV0oITApO2EuaW5kZXhlZFdyYXBwZXJzPXt9O2EuaW5kZXg9MH0sd2I6ZnVuY3Rpb24oYSxiKXtnLmdpKCJjYXBwaW5nX2lkbGUiLCEhYSxiKX0sb2I6ZnVuY3Rpb24oYSl7MD5hJiYoYSs9NDI5NDk2NzI5Nik7Zy5naSgiZGF0YV9hY2Nlc3NfYXR0YWNoZWQiLGEpfSxuYjpmdW5jdGlvbigpe2cuZ2koImZpcnN0X2luc3RhbmNlIil9LApYOmZ1bmN0aW9uKGEpe2cuZ2koZGIoYSkpfSxmYTpmdW5jdGlvbihhLGIpe2I9ZGIoYik7dHJ5e3ZhciBjPUpTT04ucGFyc2UoYil9Y2F0Y2goZCl7Yz1ifWcuZ2koZGIoYSksYyl9LHRiOmZ1bmN0aW9uKGEsYixjKXswPmEmJihhKz00Mjk0OTY3Mjk2KTswPmImJihiKz00Mjk0OTY3Mjk2KTswPmMmJihjKz00Mjk0OTY3Mjk2KTtnLmdpKCJpbmNsdXNpb24iLGEsYixjKX0sT2M6ZnVuY3Rpb24oYSxiLGMsZCl7Zy5naSgibWV0YV9kYXRhIixhLGIsZy5IRUFQVTguc3ViYXJyYXkoYyxjK2QpKX0sc2I6ZnVuY3Rpb24oYSxiKXswPmEmJihhKz00Mjk0OTY3Mjk2KTtiPWRiKGIpO2cuZ2koIm1pc3NpbmdfbW9kZWwiLGEsYil9LFBiOmZ1bmN0aW9uKGEpe2cuZ2koIm5ldHdvcmtfcmVjZWl2ZV9kYXRhIixhKX0sRGM6ZnVuY3Rpb24oYSl7Zy5naSgicG9zdF9kcmF3X2pzb24iLCJ7IitkYihhKSsifSIpfSxwYjpmdW5jdGlvbihhLGIpezA+YSYmKGErPTQyOTQ5NjcyOTYpOzA+YiYmKGIrPTQyOTQ5NjcyOTYpOwpnLmdpKCJwcmlvcml0eV9tZXRhX2RhdGFfc2VudCIsYSxiKX0scWI6ZnVuY3Rpb24oYSxiLGMsZCl7MD5hJiYoYSs9NDI5NDk2NzI5Nik7MD5iJiYoYis9NDI5NDk2NzI5Nik7MD5jJiYoYys9NDI5NDk2NzI5Nik7MD5kJiYoZCs9NDI5NDk2NzI5Nik7Zy5naSgicmVtYXBfaW5jbHVzaW9uIixhLGIsYyxkKX0scmI6ZnVuY3Rpb24oYSxiLGMpezA+YSYmKGErPTQyOTQ5NjcyOTYpOzA+YiYmKGIrPTQyOTQ5NjcyOTYpOzA+YyYmKGMrPTQyOTQ5NjcyOTYpO2cuZ2koInJlbWFwX21vZGVsIixhLGIsYyl9LGg6ZnVuY3Rpb24oYSxiKXtnLm9qJiYoYT1nLkhFQVA4LmJ1ZmZlci5zbGljZShhLGIpLGcub2ouS2soYSkpfSxpYzpmdW5jdGlvbigpe2cuZ2koInNlc3Npb25fc3RhcnRlZCIpfSxZZDpmdW5jdGlvbigpe2cuJCRzZXRSZWFkeSgpfSxsOmZ1bmN0aW9uKGEsYixjLGQpe1dhKCJBc3NlcnRpb24gZmFpbGVkOiAiK2RiKGEpKyIsIGF0OiAiK1tiP2RiKGIpOiJ1bmtub3duIGZpbGVuYW1lIiwKYyxkP2RiKGQpOiJ1bmtub3duIGZ1bmN0aW9uIl0pfSxyYTpmdW5jdGlvbihhLGIsYyl7YWQ9Yzt0cnl7dmFyIGQ9Y2QoYSk7c3dpdGNoKGIpe2Nhc2UgMDp2YXIgZT1iZCgpO3JldHVybiAwPmU/LTI4OnpjKGQsZSkuZmQ7Y2FzZSAxOmNhc2UgMjpyZXR1cm4gMDtjYXNlIDM6cmV0dXJuIGQuZmxhZ3M7Y2FzZSA0OnJldHVybiBlPWJkKCksZC5mbGFnc3w9ZSwwO2Nhc2UgNTpyZXR1cm4gZT1iZCgpLGtiW2UrMD4+MV09MiwwO2Nhc2UgNjpjYXNlIDc6cmV0dXJuIDA7Y2FzZSAxNjpjYXNlIDg6cmV0dXJuLTI4O2Nhc2UgOTpyZXR1cm4gRFtKZygpPj4yXT0yOCwtMTtkZWZhdWx0OnJldHVybi0yOH19Y2F0Y2goZil7aWYoInVuZGVmaW5lZCI9PXR5cGVvZiAkY3x8IShmIGluc3RhbmNlb2YgSSkpdGhyb3cgZjtyZXR1cm4tZi5EaX19LERiOmZ1bmN0aW9uKGEsYixjKXthZD1jO3RyeXt2YXIgZD1jZChhKTtzd2l0Y2goYil7Y2FzZSAyMTUwOTpjYXNlIDIxNTA1OnJldHVybiBkLnR0eT8wOgotNTk7Y2FzZSAyMTUxMDpjYXNlIDIxNTExOmNhc2UgMjE1MTI6Y2FzZSAyMTUwNjpjYXNlIDIxNTA3OmNhc2UgMjE1MDg6cmV0dXJuIGQudHR5PzA6LTU5O2Nhc2UgMjE1MTk6aWYoIWQudHR5KXJldHVybi01OTt2YXIgZT1iZCgpO3JldHVybiBEW2U+PjJdPTA7Y2FzZSAyMTUyMDpyZXR1cm4gZC50dHk/LTI4Oi01OTtjYXNlIDIxNTMxOmE9ZT1iZCgpO2lmKCFkLmZpLnprKXRocm93IG5ldyBJKDU5KTtyZXR1cm4gZC5maS56ayhkLGIsYSk7Y2FzZSAyMTUyMzpyZXR1cm4gZC50dHk/MDotNTk7Y2FzZSAyMTUyNDpyZXR1cm4gZC50dHk/MDotNTk7ZGVmYXVsdDpyZXR1cm4tMjh9fWNhdGNoKGYpe2lmKCJ1bmRlZmluZWQiPT10eXBlb2YgJGN8fCEoZiBpbnN0YW5jZW9mIEkpKXRocm93IGY7cmV0dXJuLWYuRGl9fSxGYjpmdW5jdGlvbihhLGIsYyxkKXthZD1kO3RyeXtiPWRiKGIpO3ZhciBlPWI7aWYoIi8iPT09ZS5jaGFyQXQoMCkpYj1lO2Vsc2V7dmFyIGY9LTEwMD09PWE/Ii8iOmNkKGEpLnBhdGg7CmlmKDA9PWUubGVuZ3RoKXRocm93IG5ldyBJKDQ0KTtiPVJiKGYrIi8iK2UpfXZhciBsPWQ/YmQoKTowO3JldHVybiBIYyhiLGMsbCkuZmR9Y2F0Y2gobil7aWYoInVuZGVmaW5lZCI9PXR5cGVvZiAkY3x8IShuIGluc3RhbmNlb2YgSSkpdGhyb3cgbjtyZXR1cm4tbi5EaX19LHc6ZnVuY3Rpb24oYSl7dmFyIGI9ZGRbYV07ZGVsZXRlIGRkW2FdO3ZhciBjPWIuZWxlbWVudHMsZD1jLmxlbmd0aCxlPWMubWFwKGZ1bmN0aW9uKG4pe3JldHVybiBuLnVqfSkuY29uY2F0KGMubWFwKGZ1bmN0aW9uKG4pe3JldHVybiBuLkhqfSkpLGY9Yi5WaSxsPWIuc2k7cGQoW2FdLGUsZnVuY3Rpb24obil7Yy5mb3JFYWNoKChxLHYpPT57dmFyIHc9blt2XSxDPXEuTmksRz1xLnRqLHA9blt2K2RdLHk9cS5HaixGPXEuSWo7cS5yZWFkPVI9PncuZnJvbVdpcmVUeXBlKEMoRyxSKSk7cS53cml0ZT0oUixjYSk9Pnt2YXIgTT1bXTt5KEYsUixwLnRvV2lyZVR5cGUoTSxjYSkpO2VkKE0pfX0pO3JldHVyblt7bmFtZTpiLm5hbWUsCmZyb21XaXJlVHlwZTpmdW5jdGlvbihxKXtmb3IodmFyIHY9QXJyYXkoZCksdz0wO3c8ZDsrK3cpdlt3XT1jW3ddLnJlYWQocSk7bChxKTtyZXR1cm4gdn0sdG9XaXJlVHlwZTpmdW5jdGlvbihxLHYpe2lmKGQhPT12Lmxlbmd0aCl0aHJvdyBuZXcgVHlwZUVycm9yKCJJbmNvcnJlY3QgbnVtYmVyIG9mIHR1cGxlIGVsZW1lbnRzIGZvciAiK2IubmFtZSsiOiBleHBlY3RlZD0iK2QrIiwgYWN0dWFsPSIrdi5sZW5ndGgpO2Zvcih2YXIgdz1mKCksQz0wO0M8ZDsrK0MpY1tDXS53cml0ZSh3LHZbQ10pO251bGwhPT1xJiZxLnB1c2gobCx3KTtyZXR1cm4gd30sYXJnUGFja0FkdmFuY2U6OCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpmZCxwaTpsfV19KX0sSjpmdW5jdGlvbihhKXt2YXIgYj1yZFthXTtkZWxldGUgcmRbYV07dmFyIGM9Yi5WaSxkPWIuc2ksZT1iLlVqLGY9ZS5tYXAobD0+bC51aikuY29uY2F0KGUubWFwKGw9PmwuSGopKTtwZChbYV0sZixsPT57dmFyIG49e307ZS5mb3JFYWNoKChxLAp2KT0+e3ZhciB3PWxbdl0sQz1xLk5pLEc9cS50aixwPWxbditlLmxlbmd0aF0seT1xLkdqLEY9cS5JajtuW3Euc2tdPXtyZWFkOlI9PncuZnJvbVdpcmVUeXBlKEMoRyxSKSksd3JpdGU6KFIsY2EpPT57dmFyIE09W107eShGLFIscC50b1dpcmVUeXBlKE0sY2EpKTtlZChNKX19fSk7cmV0dXJuW3tuYW1lOmIubmFtZSxmcm9tV2lyZVR5cGU6ZnVuY3Rpb24ocSl7dmFyIHY9e30sdztmb3IodyBpbiBuKXZbd109blt3XS5yZWFkKHEpO2QocSk7cmV0dXJuIHZ9LHRvV2lyZVR5cGU6ZnVuY3Rpb24ocSx2KXtmb3IodmFyIHcgaW4gbilpZighKHcgaW4gdikpdGhyb3cgbmV3IFR5cGVFcnJvcignTWlzc2luZyBmaWVsZDogICInK3crJyInKTt2YXIgQz1jKCk7Zm9yKHcgaW4gbiluW3ddLndyaXRlKEMsdlt3XSk7bnVsbCE9PXEmJnEucHVzaChkLEMpO3JldHVybiBDfSxhcmdQYWNrQWR2YW5jZTo4LHJlYWRWYWx1ZUZyb21Qb2ludGVyOmZkLHBpOmR9XX0pfSx2YjpmdW5jdGlvbigpe30sVGc6ZnVuY3Rpb24oYSwKYixjLGQsZSl7dmFyIGY9c2QoYyk7Yj11ZChiKTtxZChhLHtuYW1lOmIsZnJvbVdpcmVUeXBlOmZ1bmN0aW9uKGwpe3JldHVybiEhbH0sdG9XaXJlVHlwZTpmdW5jdGlvbihsLG4pe3JldHVybiBuP2Q6ZX0sYXJnUGFja0FkdmFuY2U6OCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpmdW5jdGlvbihsKXtpZigxPT09Yyl2YXIgbj1qYjtlbHNlIGlmKDI9PT1jKW49a2I7ZWxzZSBpZig0PT09YyluPUQ7ZWxzZSB0aHJvdyBuZXcgVHlwZUVycm9yKCJVbmtub3duIGJvb2xlYW4gdHlwZSBzaXplOiAiK2IpO3JldHVybiB0aGlzLmZyb21XaXJlVHlwZShuW2w+PmZdKX0scGk6bnVsbH0pfSxnYTpmdW5jdGlvbihhLGIsYyxkLGUsZixsLG4scSx2LHcsQyxHKXt3PXVkKHcpO2Y9WWQoZSxmKTtuJiYobj1ZZChsLG4pKTt2JiYodj1ZZChxLHYpKTtHPVlkKEMsRyk7dmFyIHA9a2Qodyk7TmQocCxmdW5jdGlvbigpe2NlKCJDYW5ub3QgY29uc3RydWN0ICIrdysiIGR1ZSB0byB1bmJvdW5kIHR5cGVzIixbZF0pfSk7CnBkKFthLGIsY10sZD9bZF06W10sZnVuY3Rpb24oeSl7eT15WzBdO2lmKGQpe3ZhciBGPXkuamk7dmFyIFI9Ri5TaX1lbHNlIFI9TGQucHJvdG90eXBlO3k9bGQocCxmdW5jdGlvbigpe2lmKE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKSE9PWNhKXRocm93IG5ldyB2ZCgiVXNlICduZXcnIHRvIGNvbnN0cnVjdCAiK3cpO2lmKHZvaWQgMD09PU0ubGkpdGhyb3cgbmV3IHZkKHcrIiBoYXMgbm8gYWNjZXNzaWJsZSBjb25zdHJ1Y3RvciIpO3ZhciBBPU0ubGlbYXJndW1lbnRzLmxlbmd0aF07aWYodm9pZCAwPT09QSl0aHJvdyBuZXcgdmQoIlRyaWVkIHRvIGludm9rZSBjdG9yIG9mICIrdysiIHdpdGggaW52YWxpZCBudW1iZXIgb2YgcGFyYW1ldGVycyAoIithcmd1bWVudHMubGVuZ3RoKyIpIC0gZXhwZWN0ZWQgKCIrT2JqZWN0LmtleXMoTS5saSkudG9TdHJpbmcoKSsiKSBwYXJhbWV0ZXJzIGluc3RlYWQhIik7cmV0dXJuIEEuYXBwbHkodGhpcyxhcmd1bWVudHMpfSk7dmFyIGNhPQpPYmplY3QuY3JlYXRlKFIse2NvbnN0cnVjdG9yOnt2YWx1ZTp5fX0pO3kucHJvdG90eXBlPWNhO3ZhciBNPW5ldyBPZCh3LHksY2EsRyxGLGYsbix2KTtGPW5ldyBWZCh3LE0sITAsITEpO1I9bmV3IFZkKHcrIioiLE0sITEsITEpO3ZhciBFPW5ldyBWZCh3KyIgY29uc3QqIixNLCExLCEwKTtEZFthXT17cG9pbnRlclR5cGU6UixtazpFfTtXZChwLHkpO3JldHVybltGLFIsRV19KX0sYjpmdW5jdGlvbihhLGIsYyxkLGUsZixsKXt2YXIgbj1lZShjLGQpO2I9dWQoYik7Zj1ZZChlLGYpO3BkKFtdLFthXSxmdW5jdGlvbihxKXtmdW5jdGlvbiB2KCl7Y2UoIkNhbm5vdCBjYWxsICIrdysiIGR1ZSB0byB1bmJvdW5kIHR5cGVzIixuKX1xPXFbMF07dmFyIHc9cS5uYW1lKyIuIitiO2Iuc3RhcnRzV2l0aCgiQEAiKSYmKGI9U3ltYm9sW2Iuc3Vic3RyaW5nKDIpXSk7dmFyIEM9cS5qaS5jb25zdHJ1Y3Rvcjt2b2lkIDA9PT1DW2JdPyh2LnBqPWMtMSxDW2JdPXYpOihNZChDLGIsdyksQ1tiXS5CaVtjLQoxXT12KTtwZChbXSxuLGZ1bmN0aW9uKEcpe0c9W0dbMF0sbnVsbF0uY29uY2F0KEcuc2xpY2UoMSkpO3ZhciBwPXcseT1mLEY9Ry5sZW5ndGg7Mj5GJiZ4ZCgiYXJnVHlwZXMgYXJyYXkgc2l6ZSBtaXNtYXRjaCEgTXVzdCBhdCBsZWFzdCBnZXQgcmV0dXJuIHZhbHVlIGFuZCAndGhpcycgdHlwZXMhIik7Zm9yKHZhciBSPW51bGwhPT1HWzFdJiYhMSxjYT0hMSxNPTE7TTxHLmxlbmd0aDsrK00paWYobnVsbCE9PUdbTV0mJnZvaWQgMD09PUdbTV0ucGkpe2NhPSEwO2JyZWFrfXZhciBFPSJ2b2lkIiE9PUdbMF0ubmFtZSxBPSIiLFU9IiI7Zm9yKE09MDtNPEYtMjsrK00pQSs9KDAhPT1NPyIsICI6IiIpKyJhcmciK00sVSs9KDAhPT1NPyIsICI6IiIpKyJhcmciK00rIldpcmVkIjtwPSJyZXR1cm4gZnVuY3Rpb24gIitrZChwKSsiKCIrQSsiKSB7XG5pZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gIisoRi0yKSsiKSB7XG50aHJvd0JpbmRpbmdFcnJvcignZnVuY3Rpb24gIitwKyIgY2FsbGVkIHdpdGggJyArIGFyZ3VtZW50cy5sZW5ndGggKyAnIGFyZ3VtZW50cywgZXhwZWN0ZWQgIisKKEYtMikrIiBhcmdzIScpO1xufVxuIjtjYSYmKHArPSJ2YXIgZGVzdHJ1Y3RvcnMgPSBbXTtcbiIpO3ZhciBLPWNhPyJkZXN0cnVjdG9ycyI6Im51bGwiO0E9InRocm93QmluZGluZ0Vycm9yIGludm9rZXIgZm4gcnVuRGVzdHJ1Y3RvcnMgcmV0VHlwZSBjbGFzc1BhcmFtIi5zcGxpdCgiICIpO3k9W3hkLHksbCxlZCxHWzBdLEdbMV1dO1ImJihwKz0idmFyIHRoaXNXaXJlZCA9IGNsYXNzUGFyYW0udG9XaXJlVHlwZSgiK0srIiwgdGhpcyk7XG4iKTtmb3IoTT0wO008Ri0yOysrTSlwKz0idmFyIGFyZyIrTSsiV2lyZWQgPSBhcmdUeXBlIitNKyIudG9XaXJlVHlwZSgiK0srIiwgYXJnIitNKyIpOyAvLyAiK0dbTSsyXS5uYW1lKyJcbiIsQS5wdXNoKCJhcmdUeXBlIitNKSx5LnB1c2goR1tNKzJdKTtSJiYoVT0idGhpc1dpcmVkIisoMDxVLmxlbmd0aD8iLCAiOiIiKStVKTtwKz0oRT8idmFyIHJ2ID0gIjoiIikrImludm9rZXIoZm4iKygwPFUubGVuZ3RoPyIsICI6IiIpK1UrIik7XG4iOwppZihjYSlwKz0icnVuRGVzdHJ1Y3RvcnMoZGVzdHJ1Y3RvcnMpO1xuIjtlbHNlIGZvcihNPVI/MToyO008Ry5sZW5ndGg7KytNKUY9MT09PU0/InRoaXNXaXJlZCI6ImFyZyIrKE0tMikrIldpcmVkIixudWxsIT09R1tNXS5waSYmKHArPUYrIl9kdG9yKCIrRisiKTsgLy8gIitHW01dLm5hbWUrIlxuIixBLnB1c2goRisiX2R0b3IiKSx5LnB1c2goR1tNXS5waSkpO0UmJihwKz0idmFyIHJldCA9IHJldFR5cGUuZnJvbVdpcmVUeXBlKHJ2KTtcbnJldHVybiByZXQ7XG4iKTtBLnB1c2gocCsifVxuIik7Rz1kZShBKS5hcHBseShudWxsLHkpO3ZvaWQgMD09PUNbYl0uQmk/KEcucGo9Yy0xLENbYl09Ryk6Q1tiXS5CaVtjLTFdPUc7cmV0dXJuW119KTtyZXR1cm5bXX0pfSxTZzpmdW5jdGlvbihhLGIpe2I9dWQoYik7cWQoYSx7bmFtZTpiLGZyb21XaXJlVHlwZTpmdW5jdGlvbihjKXt2YXIgZD1pZShjKTtoZShjKTtyZXR1cm4gZH0sdG9XaXJlVHlwZTpmdW5jdGlvbihjLGQpe3JldHVybiBUZChkKX0sCmFyZ1BhY2tBZHZhbmNlOjgscmVhZFZhbHVlRnJvbVBvaW50ZXI6ZmQscGk6bnVsbH0pfSxNOmZ1bmN0aW9uKGEsYixjLGQpe2Z1bmN0aW9uIGUoKXt9Yz1zZChjKTtiPXVkKGIpO2UudmFsdWVzPXt9O3FkKGEse25hbWU6Yixjb25zdHJ1Y3RvcjplLGZyb21XaXJlVHlwZTpmdW5jdGlvbihmKXtyZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci52YWx1ZXNbZl19LHRvV2lyZVR5cGU6ZnVuY3Rpb24oZixsKXtyZXR1cm4gbC52YWx1ZX0sYXJnUGFja0FkdmFuY2U6OCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpqZShiLGMsZCkscGk6bnVsbH0pO05kKGIsZSl9LHk6ZnVuY3Rpb24oYSxiLGMpe3ZhciBkPWtlKGEsImVudW0iKTtiPXVkKGIpO2E9ZC5jb25zdHJ1Y3RvcjtkPU9iamVjdC5jcmVhdGUoZC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUse3ZhbHVlOnt2YWx1ZTpjfSxjb25zdHJ1Y3Rvcjp7dmFsdWU6bGQoZC5uYW1lKyJfIitiLGZ1bmN0aW9uKCl7fSl9fSk7YS52YWx1ZXNbY109ZDthW2JdPWR9LAp1YTpmdW5jdGlvbihhLGIsYyl7Yz1zZChjKTtiPXVkKGIpO3FkKGEse25hbWU6Yixmcm9tV2lyZVR5cGU6ZnVuY3Rpb24oZCl7cmV0dXJuIGR9LHRvV2lyZVR5cGU6ZnVuY3Rpb24oZCxlKXtyZXR1cm4gZX0sYXJnUGFja0FkdmFuY2U6OCxyZWFkVmFsdWVGcm9tUG9pbnRlcjpsZShiLGMpLHBpOm51bGx9KX0sUDpmdW5jdGlvbihhLGIsYyxkLGUpe2I9dWQoYik7LTE9PT1lJiYoZT00Mjk0OTY3Mjk1KTtlPXNkKGMpO3ZhciBmPW49Pm47aWYoMD09PWQpe3ZhciBsPTMyLTgqYztmPW49Pm48PGw+Pj5sfWM9Yi5pbmNsdWRlcygidW5zaWduZWQiKT9mdW5jdGlvbihuLHEpe3JldHVybiBxPj4+MH06ZnVuY3Rpb24obixxKXtyZXR1cm4gcX07cWQoYSx7bmFtZTpiLGZyb21XaXJlVHlwZTpmLHRvV2lyZVR5cGU6YyxhcmdQYWNrQWR2YW5jZTo4LHJlYWRWYWx1ZUZyb21Qb2ludGVyOm1lKGIsZSwwIT09ZCkscGk6bnVsbH0pfSxEOmZ1bmN0aW9uKGEsYixjKXtmdW5jdGlvbiBkKGYpe2Y+Pj0KMjt2YXIgbD1oO3JldHVybiBuZXcgZShnYixsW2YrMV0sbFtmXSl9dmFyIGU9W0ludDhBcnJheSxVaW50OEFycmF5LEludDE2QXJyYXksVWludDE2QXJyYXksSW50MzJBcnJheSxVaW50MzJBcnJheSxGbG9hdDMyQXJyYXksRmxvYXQ2NEFycmF5XVtiXTtjPXVkKGMpO3FkKGEse25hbWU6Yyxmcm9tV2lyZVR5cGU6ZCxhcmdQYWNrQWR2YW5jZTo4LHJlYWRWYWx1ZUZyb21Qb2ludGVyOmR9LHt4azohMH0pfSx0YTpmdW5jdGlvbihhLGIpe2I9dWQoYik7dmFyIGM9InN0ZDo6c3RyaW5nIj09PWI7cWQoYSx7bmFtZTpiLGZyb21XaXJlVHlwZTpmdW5jdGlvbihkKXt2YXIgZT1oW2Q+PjJdLGY9ZCs0O2lmKGMpZm9yKHZhciBsPWYsbj0wO248PWU7KytuKXt2YXIgcT1mK247aWYobj09ZXx8MD09dFtxXSl7bD1kYihsLHEtbCk7aWYodm9pZCAwPT09dil2YXIgdj1sO2Vsc2Ugdis9U3RyaW5nLmZyb21DaGFyQ29kZSgwKSx2Kz1sO2w9cSsxfX1lbHNle3Y9QXJyYXkoZSk7Zm9yKG49MDtuPGU7KytuKXZbbl09ClN0cmluZy5mcm9tQ2hhckNvZGUodFtmK25dKTt2PXYuam9pbigiIil9YmUoZCk7cmV0dXJuIHZ9LHRvV2lyZVR5cGU6ZnVuY3Rpb24oZCxlKXtlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXImJihlPW5ldyBVaW50OEFycmF5KGUpKTt2YXIgZj0ic3RyaW5nIj09dHlwZW9mIGU7Znx8ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXl8fGUgaW5zdGFuY2VvZiBVaW50OENsYW1wZWRBcnJheXx8ZSBpbnN0YW5jZW9mIEludDhBcnJheXx8eGQoIkNhbm5vdCBwYXNzIG5vbi1zdHJpbmcgdG8gc3RkOjpzdHJpbmciKTt2YXIgbD1jJiZmP2ZiKGUpOmUubGVuZ3RoO3ZhciBuPWRnKDQrbCsxKSxxPW4rNDtoW24+PjJdPWw7aWYoYyYmZillYihlLHQscSxsKzEpO2Vsc2UgaWYoZilmb3IoZj0wO2Y8bDsrK2Ype3ZhciB2PWUuY2hhckNvZGVBdChmKTsyNTU8diYmKGJlKHEpLHhkKCJTdHJpbmcgaGFzIFVURi0xNiBjb2RlIHVuaXRzIHRoYXQgZG8gbm90IGZpdCBpbiA4IGJpdHMiKSk7dFtxK2ZdPXZ9ZWxzZSBmb3IoZj0KMDtmPGw7KytmKXRbcStmXT1lW2ZdO251bGwhPT1kJiZkLnB1c2goYmUsbik7cmV0dXJuIG59LGFyZ1BhY2tBZHZhbmNlOjgscmVhZFZhbHVlRnJvbVBvaW50ZXI6ZmQscGk6ZnVuY3Rpb24oZCl7YmUoZCl9fSl9LGhhOmZ1bmN0aW9uKGEsYixjKXtjPXVkKGMpO2lmKDI9PT1iKXt2YXIgZD1vZTt2YXIgZT1wZTt2YXIgZj1xZTt2YXIgbD0oKT0+bGI7dmFyIG49MX1lbHNlIDQ9PT1iJiYoZD1yZSxlPXNlLGY9dGUsbD0oKT0+aCxuPTIpO3FkKGEse25hbWU6Yyxmcm9tV2lyZVR5cGU6ZnVuY3Rpb24ocSl7Zm9yKHZhciB2PWhbcT4+Ml0sdz1sKCksQyxHPXErNCxwPTA7cDw9djsrK3Ape3ZhciB5PXErNCtwKmI7aWYocD09dnx8MD09d1t5Pj5uXSlHPWQoRyx5LUcpLHZvaWQgMD09PUM/Qz1HOihDKz1TdHJpbmcuZnJvbUNoYXJDb2RlKDApLEMrPUcpLEc9eStifWJlKHEpO3JldHVybiBDfSx0b1dpcmVUeXBlOmZ1bmN0aW9uKHEsdil7InN0cmluZyIhPXR5cGVvZiB2JiZ4ZCgiQ2Fubm90IHBhc3Mgbm9uLXN0cmluZyB0byBDKysgc3RyaW5nIHR5cGUgIisKYyk7dmFyIHc9Zih2KSxDPWRnKDQrdytiKTtoW0M+PjJdPXc+Pm47ZSh2LEMrNCx3K2IpO251bGwhPT1xJiZxLnB1c2goYmUsQyk7cmV0dXJuIEN9LGFyZ1BhY2tBZHZhbmNlOjgscmVhZFZhbHVlRnJvbVBvaW50ZXI6ZmQscGk6ZnVuY3Rpb24ocSl7YmUocSl9fSl9LHg6ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe2RkW2FdPXtuYW1lOnVkKGIpLFZpOllkKGMsZCksc2k6WWQoZSxmKSxlbGVtZW50czpbXX19LGk6ZnVuY3Rpb24oYSxiLGMsZCxlLGYsbCxuLHEpe2RkW2FdLmVsZW1lbnRzLnB1c2goe3VqOmIsTmk6WWQoYyxkKSx0ajplLEhqOmYsR2o6WWQobCxuKSxJajpxfSl9LEs6ZnVuY3Rpb24oYSxiLGMsZCxlLGYpe3JkW2FdPXtuYW1lOnVkKGIpLFZpOllkKGMsZCksc2k6WWQoZSxmKSxVajpbXX19LHQ6ZnVuY3Rpb24oYSxiLGMsZCxlLGYsbCxuLHEsdil7cmRbYV0uVWoucHVzaCh7c2s6dWQoYiksdWo6YyxOaTpZZChkLGUpLHRqOmYsSGo6bCxHajpZZChuLHEpLElqOnZ9KX0sVWc6ZnVuY3Rpb24oYSwKYil7Yj11ZChiKTtxZChhLHtDazohMCxuYW1lOmIsYXJnUGFja0FkdmFuY2U6MCxmcm9tV2lyZVR5cGU6ZnVuY3Rpb24oKXt9LHRvV2lyZVR5cGU6ZnVuY3Rpb24oKXt9fSl9LFZnOmZ1bmN0aW9uKGEpe2Rve3ZhciBiPWhbYT4+Ml07YSs9NDt2YXIgYz1oW2E+PjJdO2ErPTQ7dmFyIGQ9aFthPj4yXTthKz00O2I9ZGIoYik7U2MoIi8iLFNiKGIpLCEwLCEwKTtVYyhiLG51bGwsamIuc3ViYXJyYXkoZCxkK2MpLCEwLCEwLCEwKX13aGlsZShoW2E+PjJdKX0sQWI6ZnVuY3Rpb24oKXtyZXR1cm4hMH0scDpmdW5jdGlvbihhLGIsYyl7YT1pZShhKTtiPWtlKGIsImVtdmFsOjphcyIpO3ZhciBkPVtdLGU9VGQoZCk7aFtjPj4yXT1lO3JldHVybiBiLnRvV2lyZVR5cGUoZCxhKX0sajpmdW5jdGlvbihhLGIsYyxkKXthPWllKGEpO2M9dWUoYixjKTtmb3IodmFyIGU9QXJyYXkoYiksZj0wO2Y8YjsrK2Ype3ZhciBsPWNbZl07ZVtmXT1sLnJlYWRWYWx1ZUZyb21Qb2ludGVyKGQpO2QrPWwuYXJnUGFja0FkdmFuY2V9YT0KYS5hcHBseSh2b2lkIDAsZSk7cmV0dXJuIFRkKGEpfSxROmZ1bmN0aW9uKGEsYixjLGQsZSl7YT14ZVthXTtiPWllKGIpO2M9d2UoYyk7dmFyIGY9W107aFtkPj4yXT1UZChmKTtyZXR1cm4gYShiLGMsZixlKX0sYTpoZSxMOmZ1bmN0aW9uKGEpe2lmKDA9PT1hKXJldHVybiBUZCh5ZSgpKTthPXdlKGEpO3JldHVybiBUZCh5ZSgpW2FdKX0sUjpmdW5jdGlvbihhLGIpe3ZhciBjPXVlKGEsYiksZD1jWzBdO2I9ZC5uYW1lKyJfJCIrYy5zbGljZSgxKS5tYXAoZnVuY3Rpb24odyl7cmV0dXJuIHcubmFtZX0pLmpvaW4oIl8iKSsiJCI7dmFyIGU9QWVbYl07aWYodm9pZCAwIT09ZSlyZXR1cm4gZTtlPVsicmV0VHlwZSJdO2Zvcih2YXIgZj1bZF0sbD0iIixuPTA7bjxhLTE7KytuKWwrPSgwIT09bj8iLCAiOiIiKSsiYXJnIituLGUucHVzaCgiYXJnVHlwZSIrbiksZi5wdXNoKGNbMStuXSk7dmFyIHE9InJldHVybiBmdW5jdGlvbiAiK2tkKCJtZXRob2RDYWxsZXJfIitiKSsiKGhhbmRsZSwgbmFtZSwgZGVzdHJ1Y3RvcnMsIGFyZ3MpIHtcbiIsCnY9MDtmb3Iobj0wO248YS0xOysrbilxKz0iICAgIHZhciBhcmciK24rIiA9IGFyZ1R5cGUiK24rIi5yZWFkVmFsdWVGcm9tUG9pbnRlcihhcmdzIisodj8iKyIrdjoiIikrIik7XG4iLHYrPWNbbisxXS5hcmdQYWNrQWR2YW5jZTtxKz0iICAgIHZhciBydiA9IGhhbmRsZVtuYW1lXSgiK2wrIik7XG4iO2ZvcihuPTA7bjxhLTE7KytuKWNbbisxXS5kZWxldGVPYmplY3QmJihxKz0iICAgIGFyZ1R5cGUiK24rIi5kZWxldGVPYmplY3QoYXJnIituKyIpO1xuIik7ZC5Da3x8KHErPSIgICAgcmV0dXJuIHJldFR5cGUudG9XaXJlVHlwZShkZXN0cnVjdG9ycywgcnYpO1xuIik7ZS5wdXNoKHErIn07XG4iKTthPWRlKGUpLmFwcGx5KG51bGwsZik7ZT16ZShhKTtyZXR1cm4gQWVbYl09ZX0sXzpmdW5jdGlvbihhKXthPXdlKGEpO3JldHVybiBUZChnW2FdKX0sbzpmdW5jdGlvbihhLGIpe2E9aWUoYSk7Yj1pZShiKTtyZXR1cm4gVGQoYVtiXSl9LGQ6ZnVuY3Rpb24oYSl7NDxhJiYoZ2VbYV0uQ2orPQoxKX0sUzpmdW5jdGlvbihhLGIsYyxkKXthPWllKGEpO3ZhciBlPUNlW2JdO2V8fChlPUJlKGIpLENlW2JdPWUpO3JldHVybiBlKGEsYyxkKX0sdjpmdW5jdGlvbigpe3JldHVybiBUZChbXSl9LGY6ZnVuY3Rpb24oYSl7cmV0dXJuIFRkKHdlKGEpKX0sQjpmdW5jdGlvbigpe3JldHVybiBUZCh7fSl9LG06ZnVuY3Rpb24oYSl7dmFyIGI9aWUoYSk7ZWQoYik7aGUoYSl9LGc6ZnVuY3Rpb24oYSxiLGMpe2E9aWUoYSk7Yj1pZShiKTtjPWllKGMpO2FbYl09Y30sZTpmdW5jdGlvbihhLGIpe2E9a2UoYSwiX2VtdmFsX3Rha2VfdmFsdWUiKTthPWEucmVhZFZhbHVlRnJvbVBvaW50ZXIoYik7cmV0dXJuIFRkKGEpfSxjOmZ1bmN0aW9uKCl7V2EoIiIpfSxiYTpmdW5jdGlvbihhLGIsYyl7RGUubGVuZ3RoPTA7dmFyIGQ7Zm9yKGM+Pj0yO2Q9dFtiKytdOyljKz0xMDUhPWQmYyxEZS5wdXNoKDEwNT09ZD9EW2NdOmhhW2MrKz4+MV0pLCsrYztyZXR1cm4gSmJbYV0uYXBwbHkobnVsbCxEZSl9LGhlOmZ1bmN0aW9uKGEsCmIsYyl7dmFyIGQ9Zy5jYW52YXM7RFthPj4yXT1kLndpZHRoO0RbYj4+Ml09ZC5oZWlnaHQ7RFtjPj4yXT0kZT8xOjB9LEE6TGUseWc6ZnVuY3Rpb24oYSl7Ti5hY3RpdmVUZXh0dXJlKGEpfSx4ZzpmdW5jdGlvbihhLGIpe04uYXR0YWNoU2hhZGVyKERmW2FdLEhmW2JdKX0semQ6ZnVuY3Rpb24oYSxiKXtOLmJlZ2luUXVlcnkoYSxLZltiXSl9LE9nOmZ1bmN0aW9uKGEsYil7Ti5uaS5iZWdpblF1ZXJ5RVhUKGEsS2ZbYl0pfSxmZDpmdW5jdGlvbihhKXtOLmJlZ2luVHJhbnNmb3JtRmVlZGJhY2soYSl9LHdnOmZ1bmN0aW9uKGEsYixjKXtOLmJpbmRBdHRyaWJMb2NhdGlvbihEZlthXSxiLGRiKGMpKX0sdmc6ZnVuY3Rpb24oYSxiKXszNTA1MT09YT9OLkZpPWI6MzUwNTI9PWEmJihOLm1pPWIpO04uYmluZEJ1ZmZlcihhLENmW2JdKX0sY2Q6ZnVuY3Rpb24oYSxiLGMpe04uYmluZEJ1ZmZlckJhc2UoYSxiLENmW2NdKX0sZGQ6ZnVuY3Rpb24oYSxiLGMsZCxlKXtOLmJpbmRCdWZmZXJSYW5nZShhLApiLENmW2NdLGQsZSl9LHVnOmZ1bmN0aW9uKGEsYil7Ti5iaW5kRnJhbWVidWZmZXIoYSxFZltiXSl9LHRnOmZ1bmN0aW9uKGEsYil7Ti5iaW5kUmVuZGVyYnVmZmVyKGEsRmZbYl0pfSxnYzpmdW5jdGlvbihhLGIpe04uYmluZFNhbXBsZXIoYSxMZltiXSl9LHNnOmZ1bmN0aW9uKGEsYil7Ti5iaW5kVGV4dHVyZShhLEdmW2JdKX0sX2I6ZnVuY3Rpb24oYSxiKXtOLmJpbmRUcmFuc2Zvcm1GZWVkYmFjayhhLE1mW2JdKX0sbGQ6ZnVuY3Rpb24oYSl7Ti5iaW5kVmVydGV4QXJyYXkoSWZbYV0pfSxHZzpmdW5jdGlvbihhKXtOLmJpbmRWZXJ0ZXhBcnJheShJZlthXSl9LHJnOmZ1bmN0aW9uKGEsYixjLGQpe04uYmxlbmRDb2xvcihhLGIsYyxkKX0scWc6ZnVuY3Rpb24oYSl7Ti5ibGVuZEVxdWF0aW9uKGEpfSxwZzpmdW5jdGlvbihhLGIpe04uYmxlbmRFcXVhdGlvblNlcGFyYXRlKGEsYil9LG9nOmZ1bmN0aW9uKGEsYil7Ti5ibGVuZEZ1bmMoYSxiKX0sbmc6ZnVuY3Rpb24oYSxiLGMsZCl7Ti5ibGVuZEZ1bmNTZXBhcmF0ZShhLApiLGMsZCl9LG9kOmZ1bmN0aW9uKGEsYixjLGQsZSxmLGwsbixxLHYpe04uYmxpdEZyYW1lYnVmZmVyKGEsYixjLGQsZSxmLGwsbixxLHYpfSxtZzpmdW5jdGlvbihhLGIsYyxkKXsyPD1ULnZlcnNpb24/YyYmYj9OLmJ1ZmZlckRhdGEoYSx0LGQsYyxiKTpOLmJ1ZmZlckRhdGEoYSxiLGQpOk4uYnVmZmVyRGF0YShhLGM/dC5zdWJhcnJheShjLGMrYik6YixkKX0sbGc6ZnVuY3Rpb24oYSxiLGMsZCl7Mjw9VC52ZXJzaW9uP2MmJk4uYnVmZmVyU3ViRGF0YShhLGIsdCxkLGMpOk4uYnVmZmVyU3ViRGF0YShhLGIsdC5zdWJhcnJheShkLGQrYykpfSxrZzpmdW5jdGlvbihhKXtyZXR1cm4gTi5jaGVja0ZyYW1lYnVmZmVyU3RhdHVzKGEpfSxqZzpmdW5jdGlvbihhKXtOLmNsZWFyKGEpfSxGYzpmdW5jdGlvbihhLGIsYyxkKXtOLmNsZWFyQnVmZmVyZmkoYSxiLGMsZCl9LEdjOmZ1bmN0aW9uKGEsYixjKXtOLmNsZWFyQnVmZmVyZnYoYSxiLEIsYz4+Mil9LEljOmZ1bmN0aW9uKGEsYixjKXtOLmNsZWFyQnVmZmVyaXYoYSwKYixELGM+PjIpfSxIYzpmdW5jdGlvbihhLGIsYyl7Ti5jbGVhckJ1ZmZlcnVpdihhLGIsaCxjPj4yKX0saWc6ZnVuY3Rpb24oYSxiLGMsZCl7Ti5jbGVhckNvbG9yKGEsYixjLGQpfSxoZzpmdW5jdGlvbihhKXtOLmNsZWFyRGVwdGgoYSl9LGdnOmZ1bmN0aW9uKGEpe04uY2xlYXJTdGVuY2lsKGEpfSxxYzpmdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4gTi5jbGllbnRXYWl0U3luYyhOZlthXSxiLChjPj4+MCkrNDI5NDk2NzI5NipkKX0sZmc6ZnVuY3Rpb24oYSxiLGMsZCl7Ti5jb2xvck1hc2soISFhLCEhYiwhIWMsISFkKX0sZWc6ZnVuY3Rpb24oYSl7Ti5jb21waWxlU2hhZGVyKEhmW2FdKX0sZGc6ZnVuY3Rpb24oYSxiLGMsZCxlLGYsbCxuKXsyPD1ULnZlcnNpb24/Ti5taXx8IWw/Ti5jb21wcmVzc2VkVGV4SW1hZ2UyRChhLGIsYyxkLGUsZixsLG4pOk4uY29tcHJlc3NlZFRleEltYWdlMkQoYSxiLGMsZCxlLGYsdCxuLGwpOk4uY29tcHJlc3NlZFRleEltYWdlMkQoYSxiLGMsZCxlLApmLG4/dC5zdWJhcnJheShuLG4rbCk6bnVsbCl9LEZkOmZ1bmN0aW9uKGEsYixjLGQsZSxmLGwsbixxKXtOLm1pP04uY29tcHJlc3NlZFRleEltYWdlM0QoYSxiLGMsZCxlLGYsbCxuLHEpOk4uY29tcHJlc3NlZFRleEltYWdlM0QoYSxiLGMsZCxlLGYsbCx0LHEsbil9LGNnOmZ1bmN0aW9uKGEsYixjLGQsZSxmLGwsbixxKXsyPD1ULnZlcnNpb24/Ti5taXx8IW4/Ti5jb21wcmVzc2VkVGV4U3ViSW1hZ2UyRChhLGIsYyxkLGUsZixsLG4scSk6Ti5jb21wcmVzc2VkVGV4U3ViSW1hZ2UyRChhLGIsYyxkLGUsZixsLHQscSxuKTpOLmNvbXByZXNzZWRUZXhTdWJJbWFnZTJEKGEsYixjLGQsZSxmLGwscT90LnN1YmFycmF5KHEscStuKTpudWxsKX0sRWQ6ZnVuY3Rpb24oYSxiLGMsZCxlLGYsbCxuLHEsdix3KXtOLm1pP04uY29tcHJlc3NlZFRleFN1YkltYWdlM0QoYSxiLGMsZCxlLGYsbCxuLHEsdix3KTpOLmNvbXByZXNzZWRUZXhTdWJJbWFnZTNEKGEsYixjLGQsZSxmLGwsbixxLHQsdywKdil9LENjOmZ1bmN0aW9uKGEsYixjLGQsZSl7Ti5jb3B5QnVmZmVyU3ViRGF0YShhLGIsYyxkLGUpfSxiZzpmdW5jdGlvbihhLGIsYyxkLGUsZixsLG4pe04uY29weVRleEltYWdlMkQoYSxiLGMsZCxlLGYsbCxuKX0sYWc6ZnVuY3Rpb24oYSxiLGMsZCxlLGYsbCxuKXtOLmNvcHlUZXhTdWJJbWFnZTJEKGEsYixjLGQsZSxmLGwsbil9LEdkOmZ1bmN0aW9uKGEsYixjLGQsZSxmLGwsbixxKXtOLmNvcHlUZXhTdWJJbWFnZTNEKGEsYixjLGQsZSxmLGwsbixxKX0sJGY6ZnVuY3Rpb24oKXt2YXIgYT1TZihEZiksYj1OLmNyZWF0ZVByb2dyYW0oKTtiLm5hbWU9YTtiLnppPWIueGk9Yi55aT0wO2IubWo9MTtEZlthXT1iO3JldHVybiBhfSxfZjpmdW5jdGlvbihhKXt2YXIgYj1TZihIZik7SGZbYl09Ti5jcmVhdGVTaGFkZXIoYSk7cmV0dXJuIGJ9LFpmOmZ1bmN0aW9uKGEpe04uY3VsbEZhY2UoYSl9LFlmOmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPTA7YzxhO2MrKyl7dmFyIGQ9RFtiKzQqCmM+PjJdLGU9Q2ZbZF07ZSYmKE4uZGVsZXRlQnVmZmVyKGUpLGUubmFtZT0wLENmW2RdPW51bGwsZD09Ti5GaSYmKE4uRmk9MCksZD09Ti5taSYmKE4ubWk9MCkpfX0sWGY6ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9MDtjPGE7KytjKXt2YXIgZD1EW2IrNCpjPj4yXSxlPUVmW2RdO2UmJihOLmRlbGV0ZUZyYW1lYnVmZmVyKGUpLGUubmFtZT0wLEVmW2RdPW51bGwpfX0sV2Y6ZnVuY3Rpb24oYSl7aWYoYSl7dmFyIGI9RGZbYV07Yj8oTi5kZWxldGVQcm9ncmFtKGIpLGIubmFtZT0wLERmW2FdPW51bGwpOk8oMTI4MSl9fSxCZDpmdW5jdGlvbihhLGIpe2Zvcih2YXIgYz0wO2M8YTtjKyspe3ZhciBkPURbYis0KmM+PjJdLGU9S2ZbZF07ZSYmKE4uZGVsZXRlUXVlcnkoZSksS2ZbZF09bnVsbCl9fSxRZzpmdW5jdGlvbihhLGIpe2Zvcih2YXIgYz0wO2M8YTtjKyspe3ZhciBkPURbYis0KmM+PjJdLGU9S2ZbZF07ZSYmKE4ubmkuZGVsZXRlUXVlcnlFWFQoZSksS2ZbZF09bnVsbCl9fSxWZjpmdW5jdGlvbihhLApiKXtmb3IodmFyIGM9MDtjPGE7YysrKXt2YXIgZD1EW2IrNCpjPj4yXSxlPUZmW2RdO2UmJihOLmRlbGV0ZVJlbmRlcmJ1ZmZlcihlKSxlLm5hbWU9MCxGZltkXT1udWxsKX19LGpjOmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPTA7YzxhO2MrKyl7dmFyIGQ9RFtiKzQqYz4+Ml0sZT1MZltkXTtlJiYoTi5kZWxldGVTYW1wbGVyKGUpLGUubmFtZT0wLExmW2RdPW51bGwpfX0sVWY6ZnVuY3Rpb24oYSl7aWYoYSl7dmFyIGI9SGZbYV07Yj8oTi5kZWxldGVTaGFkZXIoYiksSGZbYV09bnVsbCk6TygxMjgxKX19LHJjOmZ1bmN0aW9uKGEpe2lmKGEpe3ZhciBiPU5mW2FdO2I/KE4uZGVsZXRlU3luYyhiKSxiLm5hbWU9MCxOZlthXT1udWxsKTpPKDEyODEpfX0sVGY6ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9MDtjPGE7YysrKXt2YXIgZD1EW2IrNCpjPj4yXSxlPUdmW2RdO2UmJihOLmRlbGV0ZVRleHR1cmUoZSksZS5uYW1lPTAsR2ZbZF09bnVsbCl9fSxaYjpmdW5jdGlvbihhLGIpe2Zvcih2YXIgYz0KMDtjPGE7YysrKXt2YXIgZD1EW2IrNCpjPj4yXSxlPU1mW2RdO2UmJihOLmRlbGV0ZVRyYW5zZm9ybUZlZWRiYWNrKGUpLGUubmFtZT0wLE1mW2RdPW51bGwpfX0sa2Q6ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9MDtjPGE7YysrKXt2YXIgZD1EW2IrNCpjPj4yXTtOLmRlbGV0ZVZlcnRleEFycmF5KElmW2RdKTtJZltkXT1udWxsfX0sRmc6ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9MDtjPGE7YysrKXt2YXIgZD1EW2IrNCpjPj4yXTtOLmRlbGV0ZVZlcnRleEFycmF5KElmW2RdKTtJZltkXT1udWxsfX0sU2Y6ZnVuY3Rpb24oYSl7Ti5kZXB0aEZ1bmMoYSl9LFJmOmZ1bmN0aW9uKGEpe04uZGVwdGhNYXNrKCEhYSl9LFFmOmZ1bmN0aW9uKGEsYil7Ti5kZXB0aFJhbmdlKGEsYil9LFBmOmZ1bmN0aW9uKGEsYil7Ti5kZXRhY2hTaGFkZXIoRGZbYV0sSGZbYl0pfSxPZjpmdW5jdGlvbihhKXtOLmRpc2FibGUoYSl9LE5mOmZ1bmN0aW9uKGEpe04uZGlzYWJsZVZlcnRleEF0dHJpYkFycmF5KGEpfSwKTWY6ZnVuY3Rpb24oYSxiLGMpe04uZHJhd0FycmF5cyhhLGIsYyl9LHZjOmZ1bmN0aW9uKGEsYixjLGQpe04uZHJhd0FycmF5c0luc3RhbmNlZChhLGIsYyxkKX0sQmc6ZnVuY3Rpb24oYSxiLGMsZCl7Ti5kcmF3QXJyYXlzSW5zdGFuY2VkKGEsYixjLGQpfSxJYjpmdW5jdGlvbihhLGIsYyxkKXtOLmRyYXdBcnJheXNJbnN0YW5jZWQoYSxiLGMsZCl9LE5kOmZ1bmN0aW9uKGEsYixjLGQpe04uZHJhd0FycmF5c0luc3RhbmNlZChhLGIsYyxkKX0sSmI6ZnVuY3Rpb24oYSxiLGMsZCl7Ti5kcmF3QXJyYXlzSW5zdGFuY2VkKGEsYixjLGQpfSx2ZDpmdW5jdGlvbihhLGIpe2Zvcih2YXIgYz1XZlthXSxkPTA7ZDxhO2QrKyljW2RdPURbYis0KmQ+PjJdO04uZHJhd0J1ZmZlcnMoYyl9LExkOmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPVdmW2FdLGQ9MDtkPGE7ZCsrKWNbZF09RFtiKzQqZD4+Ml07Ti5kcmF3QnVmZmVycyhjKX0sQ2c6ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9V2ZbYV0sZD0wO2Q8CmE7ZCsrKWNbZF09RFtiKzQqZD4+Ml07Ti5kcmF3QnVmZmVycyhjKX0sTGY6ZnVuY3Rpb24oYSxiLGMsZCl7Ti5kcmF3RWxlbWVudHMoYSxiLGMsZCl9LHVjOmZ1bmN0aW9uKGEsYixjLGQsZSl7Ti5kcmF3RWxlbWVudHNJbnN0YW5jZWQoYSxiLGMsZCxlKX0sQWc6ZnVuY3Rpb24oYSxiLGMsZCxlKXtOLmRyYXdFbGVtZW50c0luc3RhbmNlZChhLGIsYyxkLGUpfSxHYjpmdW5jdGlvbihhLGIsYyxkLGUpe04uZHJhd0VsZW1lbnRzSW5zdGFuY2VkKGEsYixjLGQsZSl9LEhiOmZ1bmN0aW9uKGEsYixjLGQsZSl7Ti5kcmF3RWxlbWVudHNJbnN0YW5jZWQoYSxiLGMsZCxlKX0sTWQ6ZnVuY3Rpb24oYSxiLGMsZCxlKXtOLmRyYXdFbGVtZW50c0luc3RhbmNlZChhLGIsYyxkLGUpfSxKZDpmdW5jdGlvbihhLGIsYyxkLGUsZil7WGYoYSxkLGUsZil9LEtmOmZ1bmN0aW9uKGEpe04uZW5hYmxlKGEpfSxKZjpmdW5jdGlvbihhKXtOLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGEpfSx5ZDpmdW5jdGlvbihhKXtOLmVuZFF1ZXJ5KGEpfSwKTmc6ZnVuY3Rpb24oYSl7Ti5uaS5lbmRRdWVyeUVYVChhKX0sZWQ6ZnVuY3Rpb24oKXtOLmVuZFRyYW5zZm9ybUZlZWRiYWNrKCl9LHRjOmZ1bmN0aW9uKGEsYil7cmV0dXJuKGE9Ti5mZW5jZVN5bmMoYSxiKSk/KGI9U2YoTmYpLGEubmFtZT1iLE5mW2JdPWEsYik6MH0sSWY6ZnVuY3Rpb24oKXtOLmZpbmlzaCgpfSxIZjpmdW5jdGlvbigpe04uZmx1c2goKX0sR2Y6ZnVuY3Rpb24oYSxiLGMsZCl7Ti5mcmFtZWJ1ZmZlclJlbmRlcmJ1ZmZlcihhLGIsYyxGZltkXSl9LEZmOmZ1bmN0aW9uKGEsYixjLGQsZSl7Ti5mcmFtZWJ1ZmZlclRleHR1cmUyRChhLGIsYyxHZltkXSxlKX0sbWQ6ZnVuY3Rpb24oYSxiLGMsZCxlKXtOLmZyYW1lYnVmZmVyVGV4dHVyZUxheWVyKGEsYixHZltjXSxkLGUpfSxFZjpmdW5jdGlvbihhKXtOLmZyb250RmFjZShhKX0sRGY6ZnVuY3Rpb24oYSxiKXtZZihhLGIsImNyZWF0ZUJ1ZmZlciIsQ2YpfSxCZjpmdW5jdGlvbihhLGIpe1lmKGEsYiwiY3JlYXRlRnJhbWVidWZmZXIiLApFZil9LENkOmZ1bmN0aW9uKGEsYil7WWYoYSxiLCJjcmVhdGVRdWVyeSIsS2YpfSxSZzpmdW5jdGlvbihhLGIpe2Zvcih2YXIgYz0wO2M8YTtjKyspe3ZhciBkPU4ubmkuY3JlYXRlUXVlcnlFWFQoKTtpZighZCl7Zm9yKE8oMTI4Mik7YzxhOylEW2IrNCpjKys+PjJdPTA7YnJlYWt9dmFyIGU9U2YoS2YpO2QubmFtZT1lO0tmW2VdPWQ7RFtiKzQqYz4+Ml09ZX19LEFmOmZ1bmN0aW9uKGEsYil7WWYoYSxiLCJjcmVhdGVSZW5kZXJidWZmZXIiLEZmKX0sa2M6ZnVuY3Rpb24oYSxiKXtZZihhLGIsImNyZWF0ZVNhbXBsZXIiLExmKX0semY6ZnVuY3Rpb24oYSxiKXtZZihhLGIsImNyZWF0ZVRleHR1cmUiLEdmKX0sWWI6ZnVuY3Rpb24oYSxiKXtZZihhLGIsImNyZWF0ZVRyYW5zZm9ybUZlZWRiYWNrIixNZil9LGpkOmZ1bmN0aW9uKGEsYil7WWYoYSxiLCJjcmVhdGVWZXJ0ZXhBcnJheSIsSWYpfSxFZzpmdW5jdGlvbihhLGIpe1lmKGEsYiwiY3JlYXRlVmVydGV4QXJyYXkiLElmKX0sQ2Y6ZnVuY3Rpb24oYSl7Ti5nZW5lcmF0ZU1pcG1hcChhKX0sCnlmOmZ1bmN0aW9uKGEsYixjLGQsZSxmLGwpe1pmKCJnZXRBY3RpdmVBdHRyaWIiLGEsYixjLGQsZSxmLGwpfSx4ZjpmdW5jdGlvbihhLGIsYyxkLGUsZixsKXtaZigiZ2V0QWN0aXZlVW5pZm9ybSIsYSxiLGMsZCxlLGYsbCl9LHhjOmZ1bmN0aW9uKGEsYixjLGQsZSl7YT1EZlthXTtpZihhPU4uZ2V0QWN0aXZlVW5pZm9ybUJsb2NrTmFtZShhLGIpKWUmJjA8Yz8oYz1lYihhLHQsZSxjKSxkJiYoRFtkPj4yXT1jKSk6ZCYmKERbZD4+Ml09MCl9LHljOmZ1bmN0aW9uKGEsYixjLGQpe2lmKGQpaWYoYT1EZlthXSwzNTM5Mz09YyljPU4uZ2V0QWN0aXZlVW5pZm9ybUJsb2NrTmFtZShhLGIpLERbZD4+Ml09Yy5sZW5ndGgrMTtlbHNle2lmKGE9Ti5nZXRBY3RpdmVVbmlmb3JtQmxvY2tQYXJhbWV0ZXIoYSxiLGMpLG51bGwhPT1hKWlmKDM1Mzk1PT1jKWZvcihjPTA7YzxhLmxlbmd0aDtjKyspRFtkKzQqYz4+Ml09YVtjXTtlbHNlIERbZD4+Ml09YX1lbHNlIE8oMTI4MSl9LEFjOmZ1bmN0aW9uKGEsCmIsYyxkLGUpe2lmKGUpaWYoMDxiJiYwPT1jKU8oMTI4MSk7ZWxzZXthPURmW2FdO2Zvcih2YXIgZj1bXSxsPTA7bDxiO2wrKylmLnB1c2goRFtjKzQqbD4+Ml0pO2lmKGE9Ti5nZXRBY3RpdmVVbmlmb3JtcyhhLGYsZCkpZm9yKGI9YS5sZW5ndGgsbD0wO2w8YjtsKyspRFtlKzQqbD4+Ml09YVtsXX1lbHNlIE8oMTI4MSl9LHdmOmZ1bmN0aW9uKGEsYixjLGQpe2E9Ti5nZXRBdHRhY2hlZFNoYWRlcnMoRGZbYV0pO3ZhciBlPWEubGVuZ3RoO2U+YiYmKGU9Yik7RFtjPj4yXT1lO2ZvcihiPTA7YjxlOysrYilEW2QrNCpiPj4yXT1IZi5pbmRleE9mKGFbYl0pfSx2ZjpmdW5jdGlvbihhLGIpe3JldHVybiBOLmdldEF0dHJpYkxvY2F0aW9uKERmW2FdLGRiKGIpKX0sdWY6ZnVuY3Rpb24oYSxiKXthZyhhLGIsNCl9LGxjOmZ1bmN0aW9uKGEsYixjKXtjPyRmKGMsTi5nZXRCdWZmZXJQYXJhbWV0ZXIoYSxiKSk6TygxMjgxKX0sdGY6ZnVuY3Rpb24oYSxiLGMpe2M/RFtjPj4yXT1OLmdldEJ1ZmZlclBhcmFtZXRlcihhLApiKTpPKDEyODEpfSxzZjpmdW5jdGlvbigpe3ZhciBhPU4uZ2V0RXJyb3IoKXx8UmY7UmY9MDtyZXR1cm4gYX0scmY6ZnVuY3Rpb24oYSxiKXthZyhhLGIsMil9LFNjOmZ1bmN0aW9uKGEsYil7cmV0dXJuIE4uZ2V0RnJhZ0RhdGFMb2NhdGlvbihEZlthXSxkYihiKSl9LHFmOmZ1bmN0aW9uKGEsYixjLGQpe2E9Ti5nZXRGcmFtZWJ1ZmZlckF0dGFjaG1lbnRQYXJhbWV0ZXIoYSxiLGMpO2lmKGEgaW5zdGFuY2VvZiBXZWJHTFJlbmRlcmJ1ZmZlcnx8YSBpbnN0YW5jZW9mIFdlYkdMVGV4dHVyZSlhPWEubmFtZXwwO0RbZD4+Ml09YX0sbWM6ZnVuY3Rpb24oYSxiLGMpe2JnKGEsYixjLDEpfSxvYzpmdW5jdGlvbihhLGIpe2FnKGEsYiwxKX0sZ2Q6ZnVuY3Rpb24oYSxiLGMpe2JnKGEsYixjLDApfSxwZjpmdW5jdGlvbihhLGIpe2FnKGEsYiwwKX0sTWI6ZnVuY3Rpb24oYSxiLGMsZCxlKXtpZigwPmQpTygxMjgxKTtlbHNlIGlmKGUpe2lmKGE9Ti5nZXRJbnRlcm5hbGZvcm1hdFBhcmFtZXRlcihhLApiLGMpLG51bGwhPT1hKWZvcihiPTA7YjxhLmxlbmd0aCYmYjxkOysrYilEW2UrNCpiPj4yXT1hW2JdfWVsc2UgTygxMjgxKX0sVWI6ZnVuY3Rpb24oKXtPKDEyODIpfSxuZjpmdW5jdGlvbihhLGIsYyxkKXthPU4uZ2V0UHJvZ3JhbUluZm9Mb2coRGZbYV0pO251bGw9PT1hJiYoYT0iKHVua25vd24gZXJyb3IpIik7Yj0wPGImJmQ/ZWIoYSx0LGQsYik6MDtjJiYoRFtjPj4yXT1iKX0sb2Y6ZnVuY3Rpb24oYSxiLGMpe2lmKGMpaWYoYT49QmYpTygxMjgxKTtlbHNlIGlmKGE9RGZbYV0sMzU3MTY9PWIpYT1OLmdldFByb2dyYW1JbmZvTG9nKGEpLG51bGw9PT1hJiYoYT0iKHVua25vd24gZXJyb3IpIiksRFtjPj4yXT1hLmxlbmd0aCsxO2Vsc2UgaWYoMzU3MTk9PWIpe2lmKCFhLnppKWZvcihiPTA7YjxOLmdldFByb2dyYW1QYXJhbWV0ZXIoYSwzNTcxOCk7KytiKWEuemk9TWF0aC5tYXgoYS56aSxOLmdldEFjdGl2ZVVuaWZvcm0oYSxiKS5uYW1lLmxlbmd0aCsxKTtEW2M+PjJdPWEueml9ZWxzZSBpZigzNTcyMj09CmIpe2lmKCFhLnhpKWZvcihiPTA7YjxOLmdldFByb2dyYW1QYXJhbWV0ZXIoYSwzNTcyMSk7KytiKWEueGk9TWF0aC5tYXgoYS54aSxOLmdldEFjdGl2ZUF0dHJpYihhLGIpLm5hbWUubGVuZ3RoKzEpO0RbYz4+Ml09YS54aX1lbHNlIGlmKDM1MzgxPT1iKXtpZighYS55aSlmb3IoYj0wO2I8Ti5nZXRQcm9ncmFtUGFyYW1ldGVyKGEsMzUzODIpOysrYilhLnlpPU1hdGgubWF4KGEueWksTi5nZXRBY3RpdmVVbmlmb3JtQmxvY2tOYW1lKGEsYikubGVuZ3RoKzEpO0RbYz4+Ml09YS55aX1lbHNlIERbYz4+Ml09Ti5nZXRQcm9ncmFtUGFyYW1ldGVyKGEsYik7ZWxzZSBPKDEyODEpfSxJZzpmdW5jdGlvbihhLGIsYyl7aWYoYyl7YT1LZlthXTtiPTI+VC52ZXJzaW9uP04ubmkuZ2V0UXVlcnlPYmplY3RFWFQoYSxiKTpOLmdldFF1ZXJ5UGFyYW1ldGVyKGEsYik7dmFyIGQ7ImJvb2xlYW4iPT10eXBlb2YgYj9kPWI/MTowOmQ9YjskZihjLGQpfWVsc2UgTygxMjgxKX0sS2c6ZnVuY3Rpb24oYSwKYixjKXtpZihjKXthPU4ubmkuZ2V0UXVlcnlPYmplY3RFWFQoS2ZbYV0sYik7dmFyIGQ7ImJvb2xlYW4iPT10eXBlb2YgYT9kPWE/MTowOmQ9YTtEW2M+PjJdPWR9ZWxzZSBPKDEyODEpfSxIZzpmdW5jdGlvbihhLGIsYyl7aWYoYyl7YT1LZlthXTtiPTI+VC52ZXJzaW9uP04ubmkuZ2V0UXVlcnlPYmplY3RFWFQoYSxiKTpOLmdldFF1ZXJ5UGFyYW1ldGVyKGEsYik7dmFyIGQ7ImJvb2xlYW4iPT10eXBlb2YgYj9kPWI/MTowOmQ9YjskZihjLGQpfWVsc2UgTygxMjgxKX0sd2Q6ZnVuY3Rpb24oYSxiLGMpe2lmKGMpe2E9Ti5nZXRRdWVyeVBhcmFtZXRlcihLZlthXSxiKTt2YXIgZDsiYm9vbGVhbiI9PXR5cGVvZiBhP2Q9YT8xOjA6ZD1hO0RbYz4+Ml09ZH1lbHNlIE8oMTI4MSl9LEpnOmZ1bmN0aW9uKGEsYixjKXtpZihjKXthPU4ubmkuZ2V0UXVlcnlPYmplY3RFWFQoS2ZbYV0sYik7dmFyIGQ7ImJvb2xlYW4iPT10eXBlb2YgYT9kPWE/MTowOmQ9YTtEW2M+PjJdPWR9ZWxzZSBPKDEyODEpfSwKeGQ6ZnVuY3Rpb24oYSxiLGMpe2M/RFtjPj4yXT1OLmdldFF1ZXJ5KGEsYik6TygxMjgxKX0sTGc6ZnVuY3Rpb24oYSxiLGMpe2M/RFtjPj4yXT1OLm5pLmdldFF1ZXJ5RVhUKGEsYik6TygxMjgxKX0sbWY6ZnVuY3Rpb24oYSxiLGMpe2M/RFtjPj4yXT1OLmdldFJlbmRlcmJ1ZmZlclBhcmFtZXRlcihhLGIpOk8oMTI4MSl9LGFjOmZ1bmN0aW9uKGEsYixjKXtjP0JbYz4+Ml09Ti5nZXRTYW1wbGVyUGFyYW1ldGVyKExmW2FdLGIpOk8oMTI4MSl9LGJjOmZ1bmN0aW9uKGEsYixjKXtjP0RbYz4+Ml09Ti5nZXRTYW1wbGVyUGFyYW1ldGVyKExmW2FdLGIpOk8oMTI4MSl9LGtmOmZ1bmN0aW9uKGEsYixjLGQpe2E9Ti5nZXRTaGFkZXJJbmZvTG9nKEhmW2FdKTtudWxsPT09YSYmKGE9Iih1bmtub3duIGVycm9yKSIpO2I9MDxiJiZkP2ViKGEsdCxkLGIpOjA7YyYmKERbYz4+Ml09Yil9LGpmOmZ1bmN0aW9uKGEsYixjLGQpe2E9Ti5nZXRTaGFkZXJQcmVjaXNpb25Gb3JtYXQoYSxiKTtEW2M+PgoyXT1hLnJhbmdlTWluO0RbYys0Pj4yXT1hLnJhbmdlTWF4O0RbZD4+Ml09YS5wcmVjaXNpb259LGhmOmZ1bmN0aW9uKGEsYixjLGQpe2lmKGE9Ti5nZXRTaGFkZXJTb3VyY2UoSGZbYV0pKWI9MDxiJiZkP2ViKGEsdCxkLGIpOjAsYyYmKERbYz4+Ml09Yil9LGxmOmZ1bmN0aW9uKGEsYixjKXtjPzM1NzE2PT1iPyhhPU4uZ2V0U2hhZGVySW5mb0xvZyhIZlthXSksbnVsbD09PWEmJihhPSIodW5rbm93biBlcnJvcikiKSxEW2M+PjJdPWE/YS5sZW5ndGgrMTowKTozNTcyMD09Yj8oYT1OLmdldFNoYWRlclNvdXJjZShIZlthXSksRFtjPj4yXT1hP2EubGVuZ3RoKzE6MCk6RFtjPj4yXT1OLmdldFNoYWRlclBhcmFtZXRlcihIZlthXSxiKTpPKDEyODEpfSxnZjpmdW5jdGlvbihhKXt2YXIgYj1PZlthXTtpZighYil7c3dpdGNoKGEpe2Nhc2UgNzkzOTpiPU4uZ2V0U3VwcG9ydGVkRXh0ZW5zaW9ucygpfHxbXTtiPWIuY29uY2F0KGIubWFwKGZ1bmN0aW9uKGQpe3JldHVybiJHTF8iK2R9KSk7CmI9Y2coYi5qb2luKCIgIikpO2JyZWFrO2Nhc2UgNzkzNjpjYXNlIDc5Mzc6Y2FzZSAzNzQ0NTpjYXNlIDM3NDQ2OihiPU4uZ2V0UGFyYW1ldGVyKGEpKXx8TygxMjgwKTtiPWImJmNnKGIpO2JyZWFrO2Nhc2UgNzkzODpiPU4uZ2V0UGFyYW1ldGVyKDc5MzgpO2I9Mjw9VC52ZXJzaW9uPyJPcGVuR0wgRVMgMy4wICgiK2IrIikiOiJPcGVuR0wgRVMgMi4wICgiK2IrIikiO2I9Y2coYik7YnJlYWs7Y2FzZSAzNTcyNDpiPU4uZ2V0UGFyYW1ldGVyKDM1NzI0KTt2YXIgYz1iLm1hdGNoKC9eV2ViR0wgR0xTTCBFUyAoWzAtOV1cLlswLTldWzAtOV0/KSg/OiR8IC4qKS8pO251bGwhPT1jJiYoMz09Y1sxXS5sZW5ndGgmJihjWzFdKz0iMCIpLGI9Ik9wZW5HTCBFUyBHTFNMIEVTICIrY1sxXSsiICgiK2IrIikiKTtiPWNnKGIpO2JyZWFrO2RlZmF1bHQ6TygxMjgwKX1PZlthXT1ifXJldHVybiBifSxFYzpmdW5jdGlvbihhLGIpe2lmKDI+VC52ZXJzaW9uKXJldHVybiBPKDEyODIpLDA7dmFyIGM9ClBmW2FdO2lmKGMpcmV0dXJuIDA+Ynx8Yj49Yy5sZW5ndGg/KE8oMTI4MSksMCk6Y1tiXTtzd2l0Y2goYSl7Y2FzZSA3OTM5OnJldHVybiBjPU4uZ2V0U3VwcG9ydGVkRXh0ZW5zaW9ucygpfHxbXSxjPWMuY29uY2F0KGMubWFwKGZ1bmN0aW9uKGQpe3JldHVybiJHTF8iK2R9KSksYz1jLm1hcChmdW5jdGlvbihkKXtyZXR1cm4gY2coZCl9KSxjPVBmW2FdPWMsMD5ifHxiPj1jLmxlbmd0aD8oTygxMjgxKSwwKTpjW2JdO2RlZmF1bHQ6cmV0dXJuIE8oMTI4MCksMH19LG5jOmZ1bmN0aW9uKGEsYixjLGQsZSl7MD5jP08oMTI4MSk6ZT8oYT1OLmdldFN5bmNQYXJhbWV0ZXIoTmZbYV0sYiksbnVsbCE9PWEmJihEW2U+PjJdPWEsZCYmKERbZD4+Ml09MSkpKTpPKDEyODEpfSxmZjpmdW5jdGlvbihhLGIsYyl7Yz9CW2M+PjJdPU4uZ2V0VGV4UGFyYW1ldGVyKGEsYik6TygxMjgxKX0sZWY6ZnVuY3Rpb24oYSxiLGMpe2M/RFtjPj4yXT1OLmdldFRleFBhcmFtZXRlcihhLGIpOk8oMTI4MSl9LAphZDpmdW5jdGlvbihhLGIsYyxkLGUsZixsKXthPURmW2FdO2lmKGE9Ti5nZXRUcmFuc2Zvcm1GZWVkYmFja1ZhcnlpbmcoYSxiKSlsJiYwPGM/KGM9ZWIoYS5uYW1lLHQsbCxjKSxkJiYoRFtkPj4yXT1jKSk6ZCYmKERbZD4+Ml09MCksZSYmKERbZT4+Ml09YS5zaXplKSxmJiYoRFtmPj4yXT1hLnR5cGUpfSx6YzpmdW5jdGlvbihhLGIpe3JldHVybiBOLmdldFVuaWZvcm1CbG9ja0luZGV4KERmW2FdLGRiKGIpKX0sQmM6ZnVuY3Rpb24oYSxiLGMsZCl7aWYoZClpZigwPGImJigwPT1jfHwwPT1kKSlPKDEyODEpO2Vsc2V7YT1EZlthXTtmb3IodmFyIGU9W10sZj0wO2Y8YjtmKyspZS5wdXNoKGRiKERbYys0KmY+PjJdKSk7aWYoYT1OLmdldFVuaWZvcm1JbmRpY2VzKGEsZSkpZm9yKGI9YS5sZW5ndGgsZj0wO2Y8YjtmKyspRFtkKzQqZj4+Ml09YVtmXX1lbHNlIE8oMTI4MSl9LGJmOmZ1bmN0aW9uKGEsYil7Yj1kYihiKTtpZihhPURmW2FdKXtmZyhhKTt2YXIgYz1hLktpLGQ9MCxlPWIsCmY9ZWcoYik7MDxmJiYoZD1wYXJzZUludChiLnNsaWNlKGYrMSkpPj4+MCxlPWIuc2xpY2UoMCxmKSk7aWYoKGU9YS5ualtlXSkmJmQ8ZVswXSYmKGQrPWVbMV0sY1tkXT1jW2RdfHxOLmdldFVuaWZvcm1Mb2NhdGlvbihhLGIpKSlyZXR1cm4gZH1lbHNlIE8oMTI4MSk7cmV0dXJuLTF9LGRmOmZ1bmN0aW9uKGEsYixjKXtnZyhhLGIsYywyKX0sY2Y6ZnVuY3Rpb24oYSxiLGMpe2dnKGEsYixjLDApfSxUYzpmdW5jdGlvbihhLGIsYyl7Z2coYSxiLGMsMCl9LF9jOmZ1bmN0aW9uKGEsYixjKXtoZyhhLGIsYywwKX0sWWM6ZnVuY3Rpb24oYSxiLGMpe2hnKGEsYixjLDApfSxfZTpmdW5jdGlvbihhLGIsYyl7Yz9EW2M+PjJdPU4uZ2V0VmVydGV4QXR0cmliT2Zmc2V0KGEsYik6TygxMjgxKX0sYWY6ZnVuY3Rpb24oYSxiLGMpe2hnKGEsYixjLDIpfSwkZTpmdW5jdGlvbihhLGIsYyl7aGcoYSxiLGMsNSl9LFplOmZ1bmN0aW9uKGEsYil7Ti5oaW50KGEsYil9LFJiOmZ1bmN0aW9uKGEsYixjKXtmb3IodmFyIGQ9CldmW2JdLGU9MDtlPGI7ZSsrKWRbZV09RFtjKzQqZT4+Ml07Ti5pbnZhbGlkYXRlRnJhbWVidWZmZXIoYSxkKX0sUWI6ZnVuY3Rpb24oYSxiLGMsZCxlLGYsbCl7Zm9yKHZhciBuPVdmW2JdLHE9MDtxPGI7cSsrKW5bcV09RFtjKzQqcT4+Ml07Ti5pbnZhbGlkYXRlU3ViRnJhbWVidWZmZXIoYSxuLGQsZSxmLGwpfSxZZTpmdW5jdGlvbihhKXtyZXR1cm4oYT1DZlthXSk/Ti5pc0J1ZmZlcihhKTowfSxYZTpmdW5jdGlvbihhKXtyZXR1cm4gTi5pc0VuYWJsZWQoYSl9LFdlOmZ1bmN0aW9uKGEpe3JldHVybihhPUVmW2FdKT9OLmlzRnJhbWVidWZmZXIoYSk6MH0sVmU6ZnVuY3Rpb24oYSl7cmV0dXJuKGE9RGZbYV0pP04uaXNQcm9ncmFtKGEpOjB9LEFkOmZ1bmN0aW9uKGEpe3JldHVybihhPUtmW2FdKT9OLmlzUXVlcnkoYSk6MH0sUGc6ZnVuY3Rpb24oYSl7cmV0dXJuKGE9S2ZbYV0pP04ubmkuaXNRdWVyeUVYVChhKTowfSxVZTpmdW5jdGlvbihhKXtyZXR1cm4oYT1GZlthXSk/Ti5pc1JlbmRlcmJ1ZmZlcihhKToKMH0saGM6ZnVuY3Rpb24oYSl7cmV0dXJuKGE9TGZbYV0pP04uaXNTYW1wbGVyKGEpOjB9LFRlOmZ1bmN0aW9uKGEpe3JldHVybihhPUhmW2FdKT9OLmlzU2hhZGVyKGEpOjB9LHNjOmZ1bmN0aW9uKGEpe3JldHVybiBOLmlzU3luYyhOZlthXSl9LFNlOmZ1bmN0aW9uKGEpe3JldHVybihhPUdmW2FdKT9OLmlzVGV4dHVyZShhKTowfSxYYjpmdW5jdGlvbihhKXtyZXR1cm4gTi5pc1RyYW5zZm9ybUZlZWRiYWNrKE1mW2FdKX0saGQ6ZnVuY3Rpb24oYSl7cmV0dXJuKGE9SWZbYV0pP04uaXNWZXJ0ZXhBcnJheShhKTowfSxEZzpmdW5jdGlvbihhKXtyZXR1cm4oYT1JZlthXSk/Ti5pc1ZlcnRleEFycmF5KGEpOjB9LFJlOmZ1bmN0aW9uKGEpe04ubGluZVdpZHRoKGEpfSxRZTpmdW5jdGlvbihhKXthPURmW2FdO04ubGlua1Byb2dyYW0oYSk7YS5LaT0wO2Eubmo9e319LFdiOmZ1bmN0aW9uKCl7Ti5wYXVzZVRyYW5zZm9ybUZlZWRiYWNrKCl9LFBlOmZ1bmN0aW9uKGEsYil7MzMxNz09YSYmCihRZj1iKTtOLnBpeGVsU3RvcmVpKGEsYil9LE9lOmZ1bmN0aW9uKGEsYil7Ti5wb2x5Z29uT2Zmc2V0KGEsYil9LFRiOmZ1bmN0aW9uKCl7TygxMjgwKX0sU2I6ZnVuY3Rpb24oKXtPKDEyODApfSxNZzpmdW5jdGlvbihhLGIpe04ubmkucXVlcnlDb3VudGVyRVhUKEtmW2FdLGIpfSxLZDpmdW5jdGlvbihhKXtOLnJlYWRCdWZmZXIoYSl9LE5lOmZ1bmN0aW9uKGEsYixjLGQsZSxmLGwpe2lmKDI8PVQudmVyc2lvbilpZihOLkZpKU4ucmVhZFBpeGVscyhhLGIsYyxkLGUsZixsKTtlbHNle3ZhciBuPWlnKGYpO04ucmVhZFBpeGVscyhhLGIsYyxkLGUsZixuLGw+PmpnKG4pKX1lbHNlKGw9a2coZixlLGMsZCxsKSk/Ti5yZWFkUGl4ZWxzKGEsYixjLGQsZSxmLGwpOk8oMTI4MCl9LE1lOmZ1bmN0aW9uKCl7fSxMZTpmdW5jdGlvbihhLGIsYyxkKXtOLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoYSxiLGMsZCl9LG5kOmZ1bmN0aW9uKGEsYixjLGQsZSl7Ti5yZW5kZXJidWZmZXJTdG9yYWdlTXVsdGlzYW1wbGUoYSwKYixjLGQsZSl9LFZiOmZ1bmN0aW9uKCl7Ti5yZXN1bWVUcmFuc2Zvcm1GZWVkYmFjaygpfSxLZTpmdW5jdGlvbihhLGIpe04uc2FtcGxlQ292ZXJhZ2UoYSwhIWIpfSxkYzpmdW5jdGlvbihhLGIsYyl7Ti5zYW1wbGVyUGFyYW1ldGVyZihMZlthXSxiLGMpfSxjYzpmdW5jdGlvbihhLGIsYyl7Ti5zYW1wbGVyUGFyYW1ldGVyZihMZlthXSxiLEJbYz4+Ml0pfSxmYzpmdW5jdGlvbihhLGIsYyl7Ti5zYW1wbGVyUGFyYW1ldGVyaShMZlthXSxiLGMpfSxlYzpmdW5jdGlvbihhLGIsYyl7Ti5zYW1wbGVyUGFyYW1ldGVyaShMZlthXSxiLERbYz4+Ml0pfSxKZTpmdW5jdGlvbihhLGIsYyxkKXtOLnNjaXNzb3IoYSxiLGMsZCl9LEllOmZ1bmN0aW9uKCl7TygxMjgwKX0sSGU6ZnVuY3Rpb24oYSxiLGMsZCl7Yj1UZihiLGMsZCk7Ti5zaGFkZXJTb3VyY2UoSGZbYV0sYil9LEdlOmZ1bmN0aW9uKGEsYixjKXtOLnN0ZW5jaWxGdW5jKGEsYixjKX0sRmU6ZnVuY3Rpb24oYSxiLGMsZCl7Ti5zdGVuY2lsRnVuY1NlcGFyYXRlKGEsCmIsYyxkKX0sRWU6ZnVuY3Rpb24oYSl7Ti5zdGVuY2lsTWFzayhhKX0sRGU6ZnVuY3Rpb24oYSxiKXtOLnN0ZW5jaWxNYXNrU2VwYXJhdGUoYSxiKX0sQ2U6ZnVuY3Rpb24oYSxiLGMpe04uc3RlbmNpbE9wKGEsYixjKX0sQmU6ZnVuY3Rpb24oYSxiLGMsZCl7Ti5zdGVuY2lsT3BTZXBhcmF0ZShhLGIsYyxkKX0sQWU6ZnVuY3Rpb24oYSxiLGMsZCxlLGYsbCxuLHEpe2lmKDI8PVQudmVyc2lvbilpZihOLm1pKU4udGV4SW1hZ2UyRChhLGIsYyxkLGUsZixsLG4scSk7ZWxzZSBpZihxKXt2YXIgdj1pZyhuKTtOLnRleEltYWdlMkQoYSxiLGMsZCxlLGYsbCxuLHYscT4+amcodikpfWVsc2UgTi50ZXhJbWFnZTJEKGEsYixjLGQsZSxmLGwsbixudWxsKTtlbHNlIE4udGV4SW1hZ2UyRChhLGIsYyxkLGUsZixsLG4scT9rZyhuLGwsZCxlLHEpOm51bGwpfSxJZDpmdW5jdGlvbihhLGIsYyxkLGUsZixsLG4scSx2KXtpZihOLm1pKU4udGV4SW1hZ2UzRChhLGIsYyxkLGUsZixsLG4scSx2KTtlbHNlIGlmKHYpe3ZhciB3PQppZyhxKTtOLnRleEltYWdlM0QoYSxiLGMsZCxlLGYsbCxuLHEsdyx2Pj5qZyh3KSl9ZWxzZSBOLnRleEltYWdlM0QoYSxiLGMsZCxlLGYsbCxuLHEsbnVsbCl9LHplOmZ1bmN0aW9uKGEsYixjKXtOLnRleFBhcmFtZXRlcmYoYSxiLGMpfSx5ZTpmdW5jdGlvbihhLGIsYyl7Ti50ZXhQYXJhbWV0ZXJmKGEsYixCW2M+PjJdKX0seGU6ZnVuY3Rpb24oYSxiLGMpe04udGV4UGFyYW1ldGVyaShhLGIsYyl9LHdlOmZ1bmN0aW9uKGEsYixjKXtOLnRleFBhcmFtZXRlcmkoYSxiLERbYz4+Ml0pfSxPYjpmdW5jdGlvbihhLGIsYyxkLGUpe04udGV4U3RvcmFnZTJEKGEsYixjLGQsZSl9LE5iOmZ1bmN0aW9uKGEsYixjLGQsZSxmKXtOLnRleFN0b3JhZ2UzRChhLGIsYyxkLGUsZil9LHZlOmZ1bmN0aW9uKGEsYixjLGQsZSxmLGwsbixxKXtpZigyPD1ULnZlcnNpb24paWYoTi5taSlOLnRleFN1YkltYWdlMkQoYSxiLGMsZCxlLGYsbCxuLHEpO2Vsc2UgaWYocSl7dmFyIHY9aWcobik7Ti50ZXhTdWJJbWFnZTJEKGEsCmIsYyxkLGUsZixsLG4sdixxPj5qZyh2KSl9ZWxzZSBOLnRleFN1YkltYWdlMkQoYSxiLGMsZCxlLGYsbCxuLG51bGwpO2Vsc2Ugdj1udWxsLHEmJih2PWtnKG4sbCxlLGYscSkpLE4udGV4U3ViSW1hZ2UyRChhLGIsYyxkLGUsZixsLG4sdil9LEhkOmZ1bmN0aW9uKGEsYixjLGQsZSxmLGwsbixxLHYsdyl7aWYoTi5taSlOLnRleFN1YkltYWdlM0QoYSxiLGMsZCxlLGYsbCxuLHEsdix3KTtlbHNlIGlmKHcpe3ZhciBDPWlnKHYpO04udGV4U3ViSW1hZ2UzRChhLGIsYyxkLGUsZixsLG4scSx2LEMsdz4+amcoQykpfWVsc2UgTi50ZXhTdWJJbWFnZTNEKGEsYixjLGQsZSxmLGwsbixxLHYsbnVsbCl9LGJkOmZ1bmN0aW9uKGEsYixjLGQpe2E9RGZbYV07Zm9yKHZhciBlPVtdLGY9MDtmPGI7ZisrKWUucHVzaChkYihEW2MrNCpmPj4yXSkpO04udHJhbnNmb3JtRmVlZGJhY2tWYXJ5aW5ncyhhLGUsZCl9LHVlOmZ1bmN0aW9uKGEsYil7Ti51bmlmb3JtMWYoVihhKSxiKX0sdGU6ZnVuY3Rpb24oYSwKYixjKXtpZigyPD1ULnZlcnNpb24pYiYmTi51bmlmb3JtMWZ2KFYoYSksQixjPj4yLGIpO2Vsc2V7aWYoMjg4Pj1iKWZvcih2YXIgZD1sZ1tiLTFdLGU9MDtlPGI7KytlKWRbZV09QltjKzQqZT4+Ml07ZWxzZSBkPUIuc3ViYXJyYXkoYz4+MixjKzQqYj4+Mik7Ti51bmlmb3JtMWZ2KFYoYSksZCl9fSxyZTpmdW5jdGlvbihhLGIpe04udW5pZm9ybTFpKFYoYSksYil9LHFlOmZ1bmN0aW9uKGEsYixjKXtpZigyPD1ULnZlcnNpb24pYiYmTi51bmlmb3JtMWl2KFYoYSksRCxjPj4yLGIpO2Vsc2V7aWYoMjg4Pj1iKWZvcih2YXIgZD1tZ1tiLTFdLGU9MDtlPGI7KytlKWRbZV09RFtjKzQqZT4+Ml07ZWxzZSBkPUQuc3ViYXJyYXkoYz4+MixjKzQqYj4+Mik7Ti51bmlmb3JtMWl2KFYoYSksZCl9fSxSYzpmdW5jdGlvbihhLGIpe04udW5pZm9ybTF1aShWKGEpLGIpfSxNYzpmdW5jdGlvbihhLGIsYyl7YiYmTi51bmlmb3JtMXVpdihWKGEpLGgsYz4+MixiKX0scGU6ZnVuY3Rpb24oYSxiLGMpe04udW5pZm9ybTJmKFYoYSksCmIsYyl9LG9lOmZ1bmN0aW9uKGEsYixjKXtpZigyPD1ULnZlcnNpb24pYiYmTi51bmlmb3JtMmZ2KFYoYSksQixjPj4yLDIqYik7ZWxzZXtpZigxNDQ+PWIpZm9yKHZhciBkPWxnWzIqYi0xXSxlPTA7ZTwyKmI7ZSs9MilkW2VdPUJbYys0KmU+PjJdLGRbZSsxXT1CW2MrKDQqZSs0KT4+Ml07ZWxzZSBkPUIuc3ViYXJyYXkoYz4+MixjKzgqYj4+Mik7Ti51bmlmb3JtMmZ2KFYoYSksZCl9fSxuZTpmdW5jdGlvbihhLGIsYyl7Ti51bmlmb3JtMmkoVihhKSxiLGMpfSxtZTpmdW5jdGlvbihhLGIsYyl7aWYoMjw9VC52ZXJzaW9uKWImJk4udW5pZm9ybTJpdihWKGEpLEQsYz4+MiwyKmIpO2Vsc2V7aWYoMTQ0Pj1iKWZvcih2YXIgZD1tZ1syKmItMV0sZT0wO2U8MipiO2UrPTIpZFtlXT1EW2MrNCplPj4yXSxkW2UrMV09RFtjKyg0KmUrNCk+PjJdO2Vsc2UgZD1ELnN1YmFycmF5KGM+PjIsYys4KmI+PjIpO04udW5pZm9ybTJpdihWKGEpLGQpfX0sUWM6ZnVuY3Rpb24oYSxiLGMpe04udW5pZm9ybTJ1aShWKGEpLApiLGMpfSxMYzpmdW5jdGlvbihhLGIsYyl7YiYmTi51bmlmb3JtMnVpdihWKGEpLGgsYz4+MiwyKmIpfSxsZTpmdW5jdGlvbihhLGIsYyxkKXtOLnVuaWZvcm0zZihWKGEpLGIsYyxkKX0sa2U6ZnVuY3Rpb24oYSxiLGMpe2lmKDI8PVQudmVyc2lvbiliJiZOLnVuaWZvcm0zZnYoVihhKSxCLGM+PjIsMypiKTtlbHNle2lmKDk2Pj1iKWZvcih2YXIgZD1sZ1szKmItMV0sZT0wO2U8MypiO2UrPTMpZFtlXT1CW2MrNCplPj4yXSxkW2UrMV09QltjKyg0KmUrNCk+PjJdLGRbZSsyXT1CW2MrKDQqZSs4KT4+Ml07ZWxzZSBkPUIuc3ViYXJyYXkoYz4+MixjKzEyKmI+PjIpO04udW5pZm9ybTNmdihWKGEpLGQpfX0samU6ZnVuY3Rpb24oYSxiLGMsZCl7Ti51bmlmb3JtM2koVihhKSxiLGMsZCl9LGllOmZ1bmN0aW9uKGEsYixjKXtpZigyPD1ULnZlcnNpb24pYiYmTi51bmlmb3JtM2l2KFYoYSksRCxjPj4yLDMqYik7ZWxzZXtpZig5Nj49Yilmb3IodmFyIGQ9bWdbMypiLTFdLGU9MDtlPDMqYjtlKz0KMylkW2VdPURbYys0KmU+PjJdLGRbZSsxXT1EW2MrKDQqZSs0KT4+Ml0sZFtlKzJdPURbYysoNCplKzgpPj4yXTtlbHNlIGQ9RC5zdWJhcnJheShjPj4yLGMrMTIqYj4+Mik7Ti51bmlmb3JtM2l2KFYoYSksZCl9fSxQYzpmdW5jdGlvbihhLGIsYyxkKXtOLnVuaWZvcm0zdWkoVihhKSxiLGMsZCl9LEtjOmZ1bmN0aW9uKGEsYixjKXtiJiZOLnVuaWZvcm0zdWl2KFYoYSksaCxjPj4yLDMqYil9LGdlOmZ1bmN0aW9uKGEsYixjLGQsZSl7Ti51bmlmb3JtNGYoVihhKSxiLGMsZCxlKX0sZmU6ZnVuY3Rpb24oYSxiLGMpe2lmKDI8PVQudmVyc2lvbiliJiZOLnVuaWZvcm00ZnYoVihhKSxCLGM+PjIsNCpiKTtlbHNle2lmKDcyPj1iKXt2YXIgZD1sZ1s0KmItMV0sZT1CO2M+Pj0yO2Zvcih2YXIgZj0wO2Y8NCpiO2YrPTQpe3ZhciBsPWMrZjtkW2ZdPWVbbF07ZFtmKzFdPWVbbCsxXTtkW2YrMl09ZVtsKzJdO2RbZiszXT1lW2wrM119fWVsc2UgZD1CLnN1YmFycmF5KGM+PjIsYysxNipiPj4yKTsKTi51bmlmb3JtNGZ2KFYoYSksZCl9fSxlZTpmdW5jdGlvbihhLGIsYyxkLGUpe04udW5pZm9ybTRpKFYoYSksYixjLGQsZSl9LGRlOmZ1bmN0aW9uKGEsYixjKXtpZigyPD1ULnZlcnNpb24pYiYmTi51bmlmb3JtNGl2KFYoYSksRCxjPj4yLDQqYik7ZWxzZXtpZig3Mj49Yilmb3IodmFyIGQ9bWdbNCpiLTFdLGU9MDtlPDQqYjtlKz00KWRbZV09RFtjKzQqZT4+Ml0sZFtlKzFdPURbYysoNCplKzQpPj4yXSxkW2UrMl09RFtjKyg0KmUrOCk+PjJdLGRbZSszXT1EW2MrKDQqZSsxMik+PjJdO2Vsc2UgZD1ELnN1YmFycmF5KGM+PjIsYysxNipiPj4yKTtOLnVuaWZvcm00aXYoVihhKSxkKX19LE5jOmZ1bmN0aW9uKGEsYixjLGQsZSl7Ti51bmlmb3JtNHVpKFYoYSksYixjLGQsZSl9LEpjOmZ1bmN0aW9uKGEsYixjKXtiJiZOLnVuaWZvcm00dWl2KFYoYSksaCxjPj4yLDQqYil9LHdjOmZ1bmN0aW9uKGEsYixjKXthPURmW2FdO04udW5pZm9ybUJsb2NrQmluZGluZyhhLGIsYyl9LGNlOmZ1bmN0aW9uKGEsCmIsYyxkKXtpZigyPD1ULnZlcnNpb24pYiYmTi51bmlmb3JtTWF0cml4MmZ2KFYoYSksISFjLEIsZD4+Miw0KmIpO2Vsc2V7aWYoNzI+PWIpZm9yKHZhciBlPWxnWzQqYi0xXSxmPTA7Zjw0KmI7Zis9NCllW2ZdPUJbZCs0KmY+PjJdLGVbZisxXT1CW2QrKDQqZis0KT4+Ml0sZVtmKzJdPUJbZCsoNCpmKzgpPj4yXSxlW2YrM109QltkKyg0KmYrMTIpPj4yXTtlbHNlIGU9Qi5zdWJhcnJheShkPj4yLGQrMTYqYj4+Mik7Ti51bmlmb3JtTWF0cml4MmZ2KFYoYSksISFjLGUpfX0sdWQ6ZnVuY3Rpb24oYSxiLGMsZCl7YiYmTi51bmlmb3JtTWF0cml4MngzZnYoVihhKSwhIWMsQixkPj4yLDYqYil9LHNkOmZ1bmN0aW9uKGEsYixjLGQpe2ImJk4udW5pZm9ybU1hdHJpeDJ4NGZ2KFYoYSksISFjLEIsZD4+Miw4KmIpfSxiZTpmdW5jdGlvbihhLGIsYyxkKXtpZigyPD1ULnZlcnNpb24pYiYmTi51bmlmb3JtTWF0cml4M2Z2KFYoYSksISFjLEIsZD4+Miw5KmIpO2Vsc2V7aWYoMzI+PWIpZm9yKHZhciBlPQpsZ1s5KmItMV0sZj0wO2Y8OSpiO2YrPTkpZVtmXT1CW2QrNCpmPj4yXSxlW2YrMV09QltkKyg0KmYrNCk+PjJdLGVbZisyXT1CW2QrKDQqZis4KT4+Ml0sZVtmKzNdPUJbZCsoNCpmKzEyKT4+Ml0sZVtmKzRdPUJbZCsoNCpmKzE2KT4+Ml0sZVtmKzVdPUJbZCsoNCpmKzIwKT4+Ml0sZVtmKzZdPUJbZCsoNCpmKzI0KT4+Ml0sZVtmKzddPUJbZCsoNCpmKzI4KT4+Ml0sZVtmKzhdPUJbZCsoNCpmKzMyKT4+Ml07ZWxzZSBlPUIuc3ViYXJyYXkoZD4+MixkKzM2KmI+PjIpO04udW5pZm9ybU1hdHJpeDNmdihWKGEpLCEhYyxlKX19LHRkOmZ1bmN0aW9uKGEsYixjLGQpe2ImJk4udW5pZm9ybU1hdHJpeDN4MmZ2KFYoYSksISFjLEIsZD4+Miw2KmIpfSxxZDpmdW5jdGlvbihhLGIsYyxkKXtiJiZOLnVuaWZvcm1NYXRyaXgzeDRmdihWKGEpLCEhYyxCLGQ+PjIsMTIqYil9LGFlOmZ1bmN0aW9uKGEsYixjLGQpe2lmKDI8PVQudmVyc2lvbiliJiZOLnVuaWZvcm1NYXRyaXg0ZnYoVihhKSwhIWMsCkIsZD4+MiwxNipiKTtlbHNle2lmKDE4Pj1iKXt2YXIgZT1sZ1sxNipiLTFdLGY9QjtkPj49Mjtmb3IodmFyIGw9MDtsPDE2KmI7bCs9MTYpe3ZhciBuPWQrbDtlW2xdPWZbbl07ZVtsKzFdPWZbbisxXTtlW2wrMl09ZltuKzJdO2VbbCszXT1mW24rM107ZVtsKzRdPWZbbis0XTtlW2wrNV09ZltuKzVdO2VbbCs2XT1mW24rNl07ZVtsKzddPWZbbis3XTtlW2wrOF09ZltuKzhdO2VbbCs5XT1mW24rOV07ZVtsKzEwXT1mW24rMTBdO2VbbCsxMV09ZltuKzExXTtlW2wrMTJdPWZbbisxMl07ZVtsKzEzXT1mW24rMTNdO2VbbCsxNF09ZltuKzE0XTtlW2wrMTVdPWZbbisxNV19fWVsc2UgZT1CLnN1YmFycmF5KGQ+PjIsZCs2NCpiPj4yKTtOLnVuaWZvcm1NYXRyaXg0ZnYoVihhKSwhIWMsZSl9fSxyZDpmdW5jdGlvbihhLGIsYyxkKXtiJiZOLnVuaWZvcm1NYXRyaXg0eDJmdihWKGEpLCEhYyxCLGQ+PjIsOCpiKX0scGQ6ZnVuY3Rpb24oYSxiLGMsZCl7YiYmTi51bmlmb3JtTWF0cml4NHgzZnYoVihhKSwKISFjLEIsZD4+MiwxMipiKX0sJGQ6ZnVuY3Rpb24oYSl7YT1EZlthXTtOLnVzZVByb2dyYW0oYSk7Ti5Raj1hfSxfZDpmdW5jdGlvbihhKXtOLnZhbGlkYXRlUHJvZ3JhbShEZlthXSl9LFpkOmZ1bmN0aW9uKGEsYil7Ti52ZXJ0ZXhBdHRyaWIxZihhLGIpfSxYZDpmdW5jdGlvbihhLGIpe04udmVydGV4QXR0cmliMWYoYSxCW2I+PjJdKX0sV2Q6ZnVuY3Rpb24oYSxiLGMpe04udmVydGV4QXR0cmliMmYoYSxiLGMpfSxWZDpmdW5jdGlvbihhLGIpe04udmVydGV4QXR0cmliMmYoYSxCW2I+PjJdLEJbYis0Pj4yXSl9LFVkOmZ1bmN0aW9uKGEsYixjLGQpe04udmVydGV4QXR0cmliM2YoYSxiLGMsZCl9LFRkOmZ1bmN0aW9uKGEsYil7Ti52ZXJ0ZXhBdHRyaWIzZihhLEJbYj4+Ml0sQltiKzQ+PjJdLEJbYis4Pj4yXSl9LFNkOmZ1bmN0aW9uKGEsYixjLGQsZSl7Ti52ZXJ0ZXhBdHRyaWI0ZihhLGIsYyxkLGUpfSxSZDpmdW5jdGlvbihhLGIpe04udmVydGV4QXR0cmliNGYoYSxCW2I+PjJdLApCW2IrND4+Ml0sQltiKzg+PjJdLEJbYisxMj4+Ml0pfSwkYjpmdW5jdGlvbihhLGIpe04udmVydGV4QXR0cmliRGl2aXNvcihhLGIpfSx6ZzpmdW5jdGlvbihhLGIpe04udmVydGV4QXR0cmliRGl2aXNvcihhLGIpfSxLYjpmdW5jdGlvbihhLGIpe04udmVydGV4QXR0cmliRGl2aXNvcihhLGIpfSxPZDpmdW5jdGlvbihhLGIpe04udmVydGV4QXR0cmliRGl2aXNvcihhLGIpfSxMYjpmdW5jdGlvbihhLGIpe04udmVydGV4QXR0cmliRGl2aXNvcihhLGIpfSxYYzpmdW5jdGlvbihhLGIsYyxkLGUpe04udmVydGV4QXR0cmliSTRpKGEsYixjLGQsZSl9LFZjOmZ1bmN0aW9uKGEsYil7Ti52ZXJ0ZXhBdHRyaWJJNGkoYSxEW2I+PjJdLERbYis0Pj4yXSxEW2IrOD4+Ml0sRFtiKzEyPj4yXSl9LFdjOmZ1bmN0aW9uKGEsYixjLGQsZSl7Ti52ZXJ0ZXhBdHRyaWJJNHVpKGEsYixjLGQsZSl9LFVjOmZ1bmN0aW9uKGEsYil7Ti52ZXJ0ZXhBdHRyaWJJNHVpKGEsaFtiPj4yXSxoW2IrND4+Ml0saFtiKwo4Pj4yXSxoW2IrMTI+PjJdKX0sJGM6ZnVuY3Rpb24oYSxiLGMsZCxlKXtOLnZlcnRleEF0dHJpYklQb2ludGVyKGEsYixjLGQsZSl9LFFkOmZ1bmN0aW9uKGEsYixjLGQsZSxmKXtOLnZlcnRleEF0dHJpYlBvaW50ZXIoYSxiLGMsISFkLGUsZil9LFBkOmZ1bmN0aW9uKGEsYixjLGQpe04udmlld3BvcnQoYSxiLGMsZCl9LHBjOmZ1bmN0aW9uKGEsYixjLGQpe04ud2FpdFN5bmMoTmZbYV0sYiwoYz4+PjApKzQyOTQ5NjcyOTYqZCl9LEJiOmZ1bmN0aW9uKGEpe3ZhciBiPXQubGVuZ3RoO2E+Pj49MDtpZigyMTQ3NDgzNjQ4PGEpcmV0dXJuITE7Zm9yKHZhciBjPTE7ND49YztjKj0yKXt2YXIgZD1iKigxKy4yL2MpO2Q9TWF0aC5taW4oZCxhKzEwMDY2MzI5Nik7dmFyIGU9TWF0aDtkPU1hdGgubWF4KGEsZCk7ZT1lLm1pbi5jYWxsKGUsMjE0NzQ4MzY0OCxkKyg2NTUzNi1kJTY1NTM2KSU2NTUzNik7YTp7dHJ5e1hhLmdyb3coZS1nYi5ieXRlTGVuZ3RoKzY1NTM1Pj4+MTYpO21iKCk7dmFyIGY9CjE7YnJlYWsgYX1jYXRjaChsKXt9Zj12b2lkIDB9aWYoZilyZXR1cm4hMH1yZXR1cm4hMX0sc2E6ZnVuY3Rpb24oYSxiKXtiPj49MjtiPXthbHBoYTohIURbYl0sZGVwdGg6ISFEW2IrMV0sc3RlbmNpbDohIURbYisyXSxhbnRpYWxpYXM6ISFEW2IrM10scHJlbXVsdGlwbGllZEFscGhhOiEhRFtiKzRdLHByZXNlcnZlRHJhd2luZ0J1ZmZlcjohIURbYis1XSxwb3dlclByZWZlcmVuY2U6cGdbRFtiKzZdXSxmYWlsSWZNYWpvclBlcmZvcm1hbmNlQ2F2ZWF0OiEhRFtiKzddLHlqOkRbYis4XSxrbDpEW2IrOV0sU2o6RFtiKzEwXSxyazpEW2IrMTFdLG9sOkRbYisxMl0scGw6RFtiKzEzXX07Im51bWJlciI9PXR5cGVvZiBhJiYoYT1kYihhKSk7YT1hJiYiI2NhbnZhcyIhPT1hPyJ1bmRlZmluZWQiIT10eXBlb2Yga2YmJkpmW2FdP0pmW2FdOnJnKGEpOiJ1bmRlZmluZWQiIT10eXBlb2Yga2YmJkpmLmNhbnZhcz9KZi5jYW52YXM6Zy5jYW52YXM7cmV0dXJuIWF8fGIucms/MDpsZihhLGIpfSwKWmM6ZnVuY3Rpb24oYSl7VD09YSYmKFQ9MCk7VD09PW1mW2FdJiYoVD1udWxsKTtpZigib2JqZWN0Ij09dHlwZW9mIG9nKWZvcih2YXIgYj1tZlthXS5MaS5jYW52YXMsYz0wO2M8bmcubGVuZ3RoOysrYylpZihuZ1tjXS50YXJnZXQ9PWIpe3ZhciBkPWMtLSxlPW5nW2RdO2UudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZS5lbCxlLmRsLGUucmwpO25nLnNwbGljZShkLDEpfW1mW2FdJiZtZlthXS5MaS5jYW52YXMmJihtZlthXS5MaS5jYW52YXMuaGs9dm9pZCAwKTttZlthXT1udWxsfSxEZDpmdW5jdGlvbihhKXthPj49Mjtmb3IodmFyIGI9MDsxND5iOysrYilEW2ErYl09MDtEW2FdPURbYSsxXT1EW2ErM109RFthKzRdPURbYSs4XT1EW2ErMTBdPTF9LGlkOmZ1bmN0aW9uKGEpe3JldHVybiBuZihhKT8wOi01fSx5YjpmdW5jdGlvbihhLGIpe3ZhciBjPTA7dGcoKS5mb3JFYWNoKGZ1bmN0aW9uKGQsZSl7dmFyIGY9YitjO2U9aFthKzQqZT4+Ml09Zjtmb3IoZj0wO2Y8ZC5sZW5ndGg7KytmKWpiW2UrKz4+CjBdPWQuY2hhckNvZGVBdChmKTtqYltlPj4wXT0wO2MrPWQubGVuZ3RoKzF9KTtyZXR1cm4gMH0semI6ZnVuY3Rpb24oYSxiKXt2YXIgYz10ZygpO2hbYT4+Ml09Yy5sZW5ndGg7dmFyIGQ9MDtjLmZvckVhY2goZnVuY3Rpb24oZSl7ZCs9ZS5sZW5ndGgrMX0pO2hbYj4+Ml09ZDtyZXR1cm4gMH0saWE6T2UscGE6ZnVuY3Rpb24oYSl7dHJ5e3ZhciBiPWNkKGEpO0ljKGIpO3JldHVybiAwfWNhdGNoKGMpe2lmKCJ1bmRlZmluZWQiPT10eXBlb2YgJGN8fCEoYyBpbnN0YW5jZW9mIEkpKXRocm93IGM7cmV0dXJuIGMuRGl9fSxDYjpmdW5jdGlvbihhLGIsYyxkKXt0cnl7YTp7dmFyIGU9Y2QoYSk7YT1iO2Zvcih2YXIgZj1iPTA7ZjxjO2YrKyl7dmFyIGw9aFthPj4yXSxuPWhbYSs0Pj4yXTthKz04O3ZhciBxPWUsdj1sLHc9bixDPXZvaWQgMCxHPWpiO2lmKDA+d3x8MD5DKXRocm93IG5ldyBJKDI4KTtpZihudWxsPT09cS5mZCl0aHJvdyBuZXcgSSg4KTtpZigxPT09KHEuZmxhZ3MmMjA5NzE1NSkpdGhyb3cgbmV3IEkoOCk7CmlmKDE2Mzg0PT09KHEubm9kZS5tb2RlJjYxNDQwKSl0aHJvdyBuZXcgSSgzMSk7aWYoIXEuZmkucmVhZCl0aHJvdyBuZXcgSSgyOCk7dmFyIHA9InVuZGVmaW5lZCIhPXR5cGVvZiBDO2lmKCFwKUM9cS5wb3NpdGlvbjtlbHNlIGlmKCFxLnNlZWthYmxlKXRocm93IG5ldyBJKDcwKTt2YXIgeT1xLmZpLnJlYWQocSxHLHYsdyxDKTtwfHwocS5wb3NpdGlvbis9eSk7dmFyIEY9eTtpZigwPkYpe3ZhciBSPS0xO2JyZWFrIGF9Yis9RjtpZihGPG4pYnJlYWt9Uj1ifWhbZD4+Ml09UjtyZXR1cm4gMH1jYXRjaChjYSl7aWYoInVuZGVmaW5lZCI9PXR5cGVvZiAkY3x8IShjYSBpbnN0YW5jZW9mIEkpKXRocm93IGNhO3JldHVybiBjYS5EaX19LHViOmZ1bmN0aW9uKGEsYixjLGQsZSl7dHJ5e2I9YysyMDk3MTUyPj4+MDw0MTk0MzA1LSEhYj8oYj4+PjApKzQyOTQ5NjcyOTYqYzpOYU47aWYoaXNOYU4oYikpcmV0dXJuIDYxO3ZhciBmPWNkKGEpO0pjKGYsYixkKTtJYj1bZi5wb3NpdGlvbj4+PgowLChIYj1mLnBvc2l0aW9uLDE8PStNYXRoLmFicyhIYik/MDxIYj8oTWF0aC5taW4oK01hdGguZmxvb3IoSGIvNDI5NDk2NzI5NiksNDI5NDk2NzI5NSl8MCk+Pj4wOn5+K01hdGguY2VpbCgoSGItKyh+fkhiPj4+MCkpLzQyOTQ5NjcyOTYpPj4+MDowKV07RFtlPj4yXT1JYlswXTtEW2UrND4+Ml09SWJbMV07Zi5zaiYmMD09PWImJjA9PT1kJiYoZi5zaj1udWxsKTtyZXR1cm4gMH1jYXRjaChsKXtpZigidW5kZWZpbmVkIj09dHlwZW9mICRjfHwhKGwgaW5zdGFuY2VvZiBJKSl0aHJvdyBsO3JldHVybiBsLkRpfX0scWE6ZnVuY3Rpb24oYSxiLGMsZCl7dHJ5e2E6e3ZhciBlPWNkKGEpO2E9Yjtmb3IodmFyIGY9Yj0wO2Y8YztmKyspe3ZhciBsPWhbYT4+Ml0sbj1oW2ErND4+Ml07YSs9ODt2YXIgcT1PYyhlLGpiLGwsbik7aWYoMD5xKXt2YXIgdj0tMTticmVhayBhfWIrPXF9dj1ifWhbZD4+Ml09djtyZXR1cm4gMH1jYXRjaCh3KXtpZigidW5kZWZpbmVkIj09dHlwZW9mICRjfHwhKHcgaW5zdGFuY2VvZgpJKSl0aHJvdyB3O3JldHVybiB3LkRpfX0sZWE6ZnVuY3Rpb24oYSl7Ti5hY3RpdmVUZXh0dXJlKGEpfSxsYTpmdW5jdGlvbihhLGIpe04uYXR0YWNoU2hhZGVyKERmW2FdLEhmW2JdKX0sX2c6ZnVuY3Rpb24oYSxiKXtOLmJlZ2luUXVlcnkoYSxLZltiXSl9LGFhOmZ1bmN0aW9uKGEsYil7MzUwNTE9PWE/Ti5GaT1iOjM1MDUyPT1hJiYoTi5taT1iKTtOLmJpbmRCdWZmZXIoYSxDZltiXSl9LGRhOmZ1bmN0aW9uKGEsYil7Ti5iaW5kRnJhbWVidWZmZXIoYSxFZltiXSl9LGViOmZ1bmN0aW9uKGEsYil7Ti5iaW5kUmVuZGVyYnVmZmVyKGEsRmZbYl0pfSxpYjpmdW5jdGlvbihhLGIpe04uYmluZFRleHR1cmUoYSxHZltiXSl9LFdhOmZ1bmN0aW9uKGEsYil7Ti5ibGVuZEZ1bmMoYSxiKX0sWGE6ZnVuY3Rpb24oYSxiLGMsZCl7Ti5ibGVuZEZ1bmNTZXBhcmF0ZShhLGIsYyxkKX0seGg6ZnVuY3Rpb24oYSxiLGMsZCl7Mjw9VC52ZXJzaW9uP2MmJmI/Ti5idWZmZXJEYXRhKGEsdCxkLGMsYik6Ck4uYnVmZmVyRGF0YShhLGIsZCk6Ti5idWZmZXJEYXRhKGEsYz90LnN1YmFycmF5KGMsYytiKTpiLGQpfSx3aDpmdW5jdGlvbihhLGIsYyxkKXsyPD1ULnZlcnNpb24/YyYmTi5idWZmZXJTdWJEYXRhKGEsYix0LGQsYyk6Ti5idWZmZXJTdWJEYXRhKGEsYix0LnN1YmFycmF5KGQsZCtjKSl9LHM6ZnVuY3Rpb24oYSl7Ti5jbGVhcihhKX0sWmE6ZnVuY3Rpb24oYSxiLGMsZCl7Ti5jbGVhckNvbG9yKGEsYixjLGQpfSxZYTpmdW5jdGlvbihhKXtOLmNsZWFyU3RlbmNpbChhKX0sYWI6ZnVuY3Rpb24oYSxiLGMsZCl7Ti5jb2xvck1hc2soISFhLCEhYiwhIWMsISFkKX0sb2g6ZnVuY3Rpb24oYSl7Ti5jb21waWxlU2hhZGVyKEhmW2FdKX0sRmE6ZnVuY3Rpb24oKXt2YXIgYT1TZihEZiksYj1OLmNyZWF0ZVByb2dyYW0oKTtiLm5hbWU9YTtiLnppPWIueGk9Yi55aT0wO2IubWo9MTtEZlthXT1iO3JldHVybiBhfSxxaDpmdW5jdGlvbihhKXt2YXIgYj1TZihIZik7SGZbYl09Ti5jcmVhdGVTaGFkZXIoYSk7CnJldHVybiBifSxnYjpmdW5jdGlvbihhLGIpe2Zvcih2YXIgYz0wO2M8YTtjKyspe3ZhciBkPURbYis0KmM+PjJdLGU9Q2ZbZF07ZSYmKE4uZGVsZXRlQnVmZmVyKGUpLGUubmFtZT0wLENmW2RdPW51bGwsZD09Ti5GaSYmKE4uRmk9MCksZD09Ti5taSYmKE4ubWk9MCkpfX0sY2I6ZnVuY3Rpb24oYSxiKXtmb3IodmFyIGM9MDtjPGE7KytjKXt2YXIgZD1EW2IrNCpjPj4yXSxlPUVmW2RdO2UmJihOLmRlbGV0ZUZyYW1lYnVmZmVyKGUpLGUubmFtZT0wLEVmW2RdPW51bGwpfX0sbmg6ZnVuY3Rpb24oYSl7aWYoYSl7dmFyIGI9RGZbYV07Yj8oTi5kZWxldGVQcm9ncmFtKGIpLGIubmFtZT0wLERmW2FdPW51bGwpOk8oMTI4MSl9fSwkZzpmdW5jdGlvbihhLGIpe2Zvcih2YXIgYz0wO2M8YTtjKyspe3ZhciBkPURbYis0KmM+PjJdLGU9S2ZbZF07ZSYmKE4uZGVsZXRlUXVlcnkoZSksS2ZbZF09bnVsbCl9fSxkYjpmdW5jdGlvbihhLGIpe2Zvcih2YXIgYz0wO2M8YTtjKyspe3ZhciBkPURbYisKNCpjPj4yXSxlPUZmW2RdO2UmJihOLmRlbGV0ZVJlbmRlcmJ1ZmZlcihlKSxlLm5hbWU9MCxGZltkXT1udWxsKX19LHJoOmZ1bmN0aW9uKGEpe2lmKGEpe3ZhciBiPUhmW2FdO2I/KE4uZGVsZXRlU2hhZGVyKGIpLEhmW2FdPW51bGwpOk8oMTI4MSl9fSxoYjpmdW5jdGlvbihhLGIpe2Zvcih2YXIgYz0wO2M8YTtjKyspe3ZhciBkPURbYis0KmM+PjJdLGU9R2ZbZF07ZSYmKE4uZGVsZXRlVGV4dHVyZShlKSxlLm5hbWU9MCxHZltkXT1udWxsKX19LFZhOmZ1bmN0aW9uKGEpe04uZGVwdGhGdW5jKGEpfSwkYTpmdW5jdGlvbihhKXtOLmRlcHRoTWFzayghIWEpfSxVYTpmdW5jdGlvbihhLGIpe04uZGVwdGhSYW5nZShhLGIpfSxPYTpmdW5jdGlvbihhKXtOLmRpc2FibGUoYSl9LEk6ZnVuY3Rpb24oYSl7Ti5kaXNhYmxlVmVydGV4QXR0cmliQXJyYXkoYSl9LFU6ZnVuY3Rpb24oYSxiLGMpe04uZHJhd0FycmF5cyhhLGIsYyl9LHlhOmZ1bmN0aW9uKGEsYixjLGQpe04uZHJhd0FycmF5c0luc3RhbmNlZChhLApiLGMsZCl9LGZoOmZ1bmN0aW9uKGEsYil7Zm9yKHZhciBjPVdmW2FdLGQ9MDtkPGE7ZCsrKWNbZF09RFtiKzQqZD4+Ml07Ti5kcmF3QnVmZmVycyhjKX0sRGE6WGYsemE6ZnVuY3Rpb24oYSxiLGMsZCxlKXtOLmRyYXdFbGVtZW50c0luc3RhbmNlZChhLGIsYyxkLGUpfSxQYTpmdW5jdGlvbihhKXtOLmVuYWJsZShhKX0sRTpmdW5jdGlvbihhKXtOLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KGEpfSxaZzpmdW5jdGlvbihhKXtOLmVuZFF1ZXJ5KGEpfSxpaDpmdW5jdGlvbigpe04uZmluaXNoKCl9LEJhOmZ1bmN0aW9uKGEsYixjLGQpe04uZnJhbWVidWZmZXJSZW5kZXJidWZmZXIoYSxiLGMsRmZbZF0pfSxlaDpmdW5jdGlvbihhLGIsYyxkLGUpe04uZnJhbWVidWZmZXJUZXh0dXJlMkQoYSxiLGMsR2ZbZF0sZSl9LF9hOmZ1bmN0aW9uKGEpe04uZnJvbnRGYWNlKGEpfSx5aDpmdW5jdGlvbihhLGIpe1lmKGEsYiwiY3JlYXRlQnVmZmVyIixDZil9LENhOmZ1bmN0aW9uKGEsYil7WWYoYSwKYiwiY3JlYXRlRnJhbWVidWZmZXIiLEVmKX0sYWg6ZnVuY3Rpb24oYSxiKXtZZihhLGIsImNyZWF0ZVF1ZXJ5IixLZil9LGhoOmZ1bmN0aW9uKGEsYil7WWYoYSxiLCJjcmVhdGVSZW5kZXJidWZmZXIiLEZmKX0sdGg6ZnVuY3Rpb24oYSxiKXtZZihhLGIsImNyZWF0ZVRleHR1cmUiLEdmKX0sdmg6ZnVuY3Rpb24oYSl7Ti5nZW5lcmF0ZU1pcG1hcChhKX0sa2g6ZnVuY3Rpb24oYSxiLGMsZCxlLGYsbCl7WmYoImdldEFjdGl2ZUF0dHJpYiIsYSxiLGMsZCxlLGYsbCl9LGpoOmZ1bmN0aW9uKGEsYixjLGQsZSxmLGwpe1pmKCJnZXRBY3RpdmVVbmlmb3JtIixhLGIsYyxkLGUsZixsKX0sbWg6ZnVuY3Rpb24oYSxiKXtyZXR1cm4gTi5nZXRBdHRyaWJMb2NhdGlvbihEZlthXSxkYihiKSl9LGtiOmZ1bmN0aW9uKGEsYil7YWcoYSxiLDQpfSxtYjpmdW5jdGlvbigpe3ZhciBhPU4uZ2V0RXJyb3IoKXx8UmY7UmY9MDtyZXR1cm4gYX0sVzpmdW5jdGlvbihhLGIpe2FnKGEsYiwyKX0sbjpmdW5jdGlvbihhLApiKXthZyhhLGIsMCl9LCQ6ZnVuY3Rpb24oYSxiLGMpe2lmKGMpaWYoYT49QmYpTygxMjgxKTtlbHNlIGlmKGE9RGZbYV0sMzU3MTY9PWIpYT1OLmdldFByb2dyYW1JbmZvTG9nKGEpLG51bGw9PT1hJiYoYT0iKHVua25vd24gZXJyb3IpIiksRFtjPj4yXT1hLmxlbmd0aCsxO2Vsc2UgaWYoMzU3MTk9PWIpe2lmKCFhLnppKWZvcihiPTA7YjxOLmdldFByb2dyYW1QYXJhbWV0ZXIoYSwzNTcxOCk7KytiKWEuemk9TWF0aC5tYXgoYS56aSxOLmdldEFjdGl2ZVVuaWZvcm0oYSxiKS5uYW1lLmxlbmd0aCsxKTtEW2M+PjJdPWEueml9ZWxzZSBpZigzNTcyMj09Yil7aWYoIWEueGkpZm9yKGI9MDtiPE4uZ2V0UHJvZ3JhbVBhcmFtZXRlcihhLDM1NzIxKTsrK2IpYS54aT1NYXRoLm1heChhLnhpLE4uZ2V0QWN0aXZlQXR0cmliKGEsYikubmFtZS5sZW5ndGgrMSk7RFtjPj4yXT1hLnhpfWVsc2UgaWYoMzUzODE9PWIpe2lmKCFhLnlpKWZvcihiPTA7YjxOLmdldFByb2dyYW1QYXJhbWV0ZXIoYSwKMzUzODIpOysrYilhLnlpPU1hdGgubWF4KGEueWksTi5nZXRBY3RpdmVVbmlmb3JtQmxvY2tOYW1lKGEsYikubGVuZ3RoKzEpO0RbYz4+Ml09YS55aX1lbHNlIERbYz4+Ml09Ti5nZXRQcm9ncmFtUGFyYW1ldGVyKGEsYik7ZWxzZSBPKDEyODEpfSx3YTpmdW5jdGlvbihhLGIsYyl7aWYoYyl7YT1OLmdldFF1ZXJ5UGFyYW1ldGVyKEtmW2FdLGIpO3ZhciBkOyJib29sZWFuIj09dHlwZW9mIGE/ZD1hPzE6MDpkPWE7RFtjPj4yXT1kfWVsc2UgTygxMjgxKX0sbGI6ZnVuY3Rpb24oYSxiLGMsZCl7YT1OLmdldFNoYWRlclByZWNpc2lvbkZvcm1hdChhLGIpO0RbYz4+Ml09YS5yYW5nZU1pbjtEW2MrND4+Ml09YS5yYW5nZU1heDtEW2Q+PjJdPWEucHJlY2lzaW9ufSxvYTpmdW5jdGlvbihhKXt2YXIgYj1PZlthXTtpZighYil7c3dpdGNoKGEpe2Nhc2UgNzkzOTpiPU4uZ2V0U3VwcG9ydGVkRXh0ZW5zaW9ucygpfHxbXTtiPWIuY29uY2F0KGIubWFwKGZ1bmN0aW9uKGQpe3JldHVybiJHTF8iKwpkfSkpO2I9Y2coYi5qb2luKCIgIikpO2JyZWFrO2Nhc2UgNzkzNjpjYXNlIDc5Mzc6Y2FzZSAzNzQ0NTpjYXNlIDM3NDQ2OihiPU4uZ2V0UGFyYW1ldGVyKGEpKXx8TygxMjgwKTtiPWImJmNnKGIpO2JyZWFrO2Nhc2UgNzkzODpiPU4uZ2V0UGFyYW1ldGVyKDc5MzgpO2I9Mjw9VC52ZXJzaW9uPyJPcGVuR0wgRVMgMy4wICgiK2IrIikiOiJPcGVuR0wgRVMgMi4wICgiK2IrIikiO2I9Y2coYik7YnJlYWs7Y2FzZSAzNTcyNDpiPU4uZ2V0UGFyYW1ldGVyKDM1NzI0KTt2YXIgYz1iLm1hdGNoKC9eV2ViR0wgR0xTTCBFUyAoWzAtOV1cLlswLTldWzAtOV0/KSg/OiR8IC4qKS8pO251bGwhPT1jJiYoMz09Y1sxXS5sZW5ndGgmJihjWzFdKz0iMCIpLGI9Ik9wZW5HTCBFUyBHTFNMIEVTICIrY1sxXSsiICgiK2IrIikiKTtiPWNnKGIpO2JyZWFrO2RlZmF1bHQ6TygxMjgwKX1PZlthXT1ifXJldHVybiBifSxsaDpmdW5jdGlvbihhLGIpe2I9ZGIoYik7aWYoYT1EZlthXSl7ZmcoYSk7dmFyIGM9CmEuS2ksZD0wLGU9YixmPWVnKGIpOzA8ZiYmKGQ9cGFyc2VJbnQoYi5zbGljZShmKzEpKT4+PjAsZT1iLnNsaWNlKDAsZikpO2lmKChlPWEubmpbZV0pJiZkPGVbMF0mJihkKz1lWzFdLGNbZF09Y1tkXXx8Ti5nZXRVbmlmb3JtTG9jYXRpb24oYSxiKSkpcmV0dXJuIGR9ZWxzZSBPKDEyODEpO3JldHVybi0xfSxPOmZ1bmN0aW9uKGEpe3JldHVybiBOLmlzRW5hYmxlZChhKX0sRWE6ZnVuY3Rpb24oYSl7YT1EZlthXTtOLmxpbmtQcm9ncmFtKGEpO2EuS2k9MDthLm5qPXt9fSxiYjpmdW5jdGlvbihhLGIpezMzMTc9PWEmJihRZj1iKTtOLnBpeGVsU3RvcmVpKGEsYil9LFRhOmZ1bmN0aW9uKGEsYil7Ti5wb2x5Z29uT2Zmc2V0KGEsYil9LGRoOmZ1bmN0aW9uKGEsYixjLGQsZSxmLGwpe2lmKDI8PVQudmVyc2lvbilpZihOLkZpKU4ucmVhZFBpeGVscyhhLGIsYyxkLGUsZixsKTtlbHNle3ZhciBuPWlnKGYpO04ucmVhZFBpeGVscyhhLGIsYyxkLGUsZixuLGw+PmpnKG4pKX1lbHNlKGw9a2coZiwKZSxjLGQsbCkpP04ucmVhZFBpeGVscyhhLGIsYyxkLGUsZixsKTpPKDEyODApfSxnaDpmdW5jdGlvbihhLGIsYyxkKXtOLnJlbmRlcmJ1ZmZlclN0b3JhZ2UoYSxiLGMsZCl9LFNhOmZ1bmN0aW9uKGEsYixjLGQpe04uc2Npc3NvcihhLGIsYyxkKX0scGg6ZnVuY3Rpb24oYSxiLGMsZCl7Yj1UZihiLGMsZCk7Ti5zaGFkZXJTb3VyY2UoSGZbYV0sYil9LGNhOmZ1bmN0aW9uKGEsYixjKXtOLnN0ZW5jaWxGdW5jKGEsYixjKX0sVjpmdW5jdGlvbihhLGIsYyxkKXtOLnN0ZW5jaWxGdW5jU2VwYXJhdGUoYSxiLGMsZCl9LFJhOmZ1bmN0aW9uKGEpe04uc3RlbmNpbE1hc2soYSl9LG5hOmZ1bmN0aW9uKGEsYil7Ti5zdGVuY2lsTWFza1NlcGFyYXRlKGEsYil9LFFhOmZ1bmN0aW9uKGEsYixjKXtOLnN0ZW5jaWxPcChhLGIsYyl9LG1hOmZ1bmN0aW9uKGEsYixjLGQpe04uc3RlbmNpbE9wU2VwYXJhdGUoYSxiLGMsZCl9LFo6ZnVuY3Rpb24oYSxiLGMsZCxlLGYsbCxuLHEpe2lmKDI8PVQudmVyc2lvbilpZihOLm1pKU4udGV4SW1hZ2UyRChhLApiLGMsZCxlLGYsbCxuLHEpO2Vsc2UgaWYocSl7dmFyIHY9aWcobik7Ti50ZXhJbWFnZTJEKGEsYixjLGQsZSxmLGwsbix2LHE+PmpnKHYpKX1lbHNlIE4udGV4SW1hZ2UyRChhLGIsYyxkLGUsZixsLG4sbnVsbCk7ZWxzZSBOLnRleEltYWdlMkQoYSxiLGMsZCxlLGYsbCxuLHE/a2cobixsLGQsZSxxKTpudWxsKX0sdWg6ZnVuY3Rpb24oYSxiLGMpe04udGV4UGFyYW1ldGVyZihhLGIsYyl9LEY6ZnVuY3Rpb24oYSxiLGMpe04udGV4UGFyYW1ldGVyaShhLGIsYyl9LHE6ZnVuY3Rpb24oYSxiKXtOLnVuaWZvcm0xZihWKGEpLGIpfSxOOmZ1bmN0aW9uKGEsYixjKXtpZigyPD1ULnZlcnNpb24pYiYmTi51bmlmb3JtMWZ2KFYoYSksQixjPj4yLGIpO2Vsc2V7aWYoMjg4Pj1iKWZvcih2YXIgZD1sZ1tiLTFdLGU9MDtlPGI7KytlKWRbZV09QltjKzQqZT4+Ml07ZWxzZSBkPUIuc3ViYXJyYXkoYz4+MixjKzQqYj4+Mik7Ti51bmlmb3JtMWZ2KFYoYSksZCl9fSxrOmZ1bmN0aW9uKGEsYil7Ti51bmlmb3JtMWkoVihhKSwKYil9LHo6ZnVuY3Rpb24oYSxiLGMpe04udW5pZm9ybTJmKFYoYSksYixjKX0sQWE6ZnVuY3Rpb24oYSxiLGMpe2lmKDI8PVQudmVyc2lvbiliJiZOLnVuaWZvcm0yZnYoVihhKSxCLGM+PjIsMipiKTtlbHNle2lmKDE0ND49Yilmb3IodmFyIGQ9bGdbMipiLTFdLGU9MDtlPDIqYjtlKz0yKWRbZV09QltjKzQqZT4+Ml0sZFtlKzFdPUJbYysoNCplKzQpPj4yXTtlbHNlIGQ9Qi5zdWJhcnJheShjPj4yLGMrOCpiPj4yKTtOLnVuaWZvcm0yZnYoVihhKSxkKX19LGNoOmZ1bmN0aW9uKGEsYixjKXtOLnVuaWZvcm0yaShWKGEpLGIsYyl9LGphOmZ1bmN0aW9uKGEsYixjLGQpe04udW5pZm9ybTNmKFYoYSksYixjLGQpfSxIOmZ1bmN0aW9uKGEsYixjKXtpZigyPD1ULnZlcnNpb24pYiYmTi51bmlmb3JtM2Z2KFYoYSksQixjPj4yLDMqYik7ZWxzZXtpZig5Nj49Yilmb3IodmFyIGQ9bGdbMypiLTFdLGU9MDtlPDMqYjtlKz0zKWRbZV09QltjKzQqZT4+Ml0sZFtlKzFdPUJbYysoNCplKzQpPj4yXSwKZFtlKzJdPUJbYysoNCplKzgpPj4yXTtlbHNlIGQ9Qi5zdWJhcnJheShjPj4yLGMrMTIqYj4+Mik7Ti51bmlmb3JtM2Z2KFYoYSksZCl9fSxUOmZ1bmN0aW9uKGEsYixjLGQsZSl7Ti51bmlmb3JtNGYoVihhKSxiLGMsZCxlKX0scjpmdW5jdGlvbihhLGIsYyl7aWYoMjw9VC52ZXJzaW9uKWImJk4udW5pZm9ybTRmdihWKGEpLEIsYz4+Miw0KmIpO2Vsc2V7aWYoNzI+PWIpe3ZhciBkPWxnWzQqYi0xXSxlPUI7Yz4+PTI7Zm9yKHZhciBmPTA7Zjw0KmI7Zis9NCl7dmFyIGw9YytmO2RbZl09ZVtsXTtkW2YrMV09ZVtsKzFdO2RbZisyXT1lW2wrMl07ZFtmKzNdPWVbbCszXX19ZWxzZSBkPUIuc3ViYXJyYXkoYz4+MixjKzE2KmI+PjIpO04udW5pZm9ybTRmdihWKGEpLGQpfX0sa2E6ZnVuY3Rpb24oYSxiLGMsZCl7aWYoMjw9VC52ZXJzaW9uKWImJk4udW5pZm9ybU1hdHJpeDNmdihWKGEpLCEhYyxCLGQ+PjIsOSpiKTtlbHNle2lmKDMyPj1iKWZvcih2YXIgZT1sZ1s5KmItMV0sZj0wO2Y8CjkqYjtmKz05KWVbZl09QltkKzQqZj4+Ml0sZVtmKzFdPUJbZCsoNCpmKzQpPj4yXSxlW2YrMl09QltkKyg0KmYrOCk+PjJdLGVbZiszXT1CW2QrKDQqZisxMik+PjJdLGVbZis0XT1CW2QrKDQqZisxNik+PjJdLGVbZis1XT1CW2QrKDQqZisyMCk+PjJdLGVbZis2XT1CW2QrKDQqZisyNCk+PjJdLGVbZis3XT1CW2QrKDQqZisyOCk+PjJdLGVbZis4XT1CW2QrKDQqZiszMik+PjJdO2Vsc2UgZT1CLnN1YmFycmF5KGQ+PjIsZCszNipiPj4yKTtOLnVuaWZvcm1NYXRyaXgzZnYoVihhKSwhIWMsZSl9fSx1OmZ1bmN0aW9uKGEsYixjLGQpe2lmKDI8PVQudmVyc2lvbiliJiZOLnVuaWZvcm1NYXRyaXg0ZnYoVihhKSwhIWMsQixkPj4yLDE2KmIpO2Vsc2V7aWYoMTg+PWIpe3ZhciBlPWxnWzE2KmItMV0sZj1CO2Q+Pj0yO2Zvcih2YXIgbD0wO2w8MTYqYjtsKz0xNil7dmFyIG49ZCtsO2VbbF09ZltuXTtlW2wrMV09ZltuKzFdO2VbbCsyXT1mW24rMl07ZVtsKzNdPWZbbiszXTtlW2wrNF09ZltuKwo0XTtlW2wrNV09ZltuKzVdO2VbbCs2XT1mW24rNl07ZVtsKzddPWZbbis3XTtlW2wrOF09ZltuKzhdO2VbbCs5XT1mW24rOV07ZVtsKzEwXT1mW24rMTBdO2VbbCsxMV09ZltuKzExXTtlW2wrMTJdPWZbbisxMl07ZVtsKzEzXT1mW24rMTNdO2VbbCsxNF09ZltuKzE0XTtlW2wrMTVdPWZbbisxNV19fWVsc2UgZT1CLnN1YmFycmF5KGQ+PjIsZCs2NCpiPj4yKTtOLnVuaWZvcm1NYXRyaXg0ZnYoVihhKSwhIWMsZSl9fSxmYjpmdW5jdGlvbihhKXthPURmW2FdO04udXNlUHJvZ3JhbShhKTtOLlFqPWF9LHhhOmZ1bmN0aW9uKGEsYil7Ti52ZXJ0ZXhBdHRyaWIxZihhLGIpfSxiaDpmdW5jdGlvbihhLGIsYyxkLGUpe04udmVydGV4QXR0cmliNGYoYSxiLGMsZCxlKX0sRzpmdW5jdGlvbihhLGIpe04udmVydGV4QXR0cmliRGl2aXNvcihhLGIpfSxDOmZ1bmN0aW9uKGEsYixjLGQsZSxmKXtOLnZlcnRleEF0dHJpYlBvaW50ZXIoYSxiLGMsISFkLGUsZil9LGpiOmZ1bmN0aW9uKGEsYixjLGQpe04udmlld3BvcnQoYSwKYixjLGQpfSxzaDpmdW5jdGlvbihhLGIsYyxkLGUpe2NmKCk7YT10LnN1YmFycmF5KGEsYStiKTtiPW51bGw7Yz1bImltYWdlL2pwZWciLCJpbWFnZS9wbmciLCJpbWFnZS9naWYiLCJpbWFnZS9ibXAiLCJpbWFnZS9zdmcreG1sIl1bY107dmFyIGY9W04uTFVNSU5BTkNFLE4uTFVNSU5BTkNFX0FMUEhBLE4uUkdCLE4uUkdCQV1bZC0xXTt2b2lkIDA9PT1mJiYoZj1OLlJHQkEpO2lmKGVmKXRyeXtiPW5ldyBCbG9iKFthXSx7dHlwZTpjfSksYi5zaXplIT09YS5sZW5ndGgmJihiPW5ldyBCbG9iKFsobmV3IFVpbnQ4QXJyYXkoYSkpLmJ1ZmZlcl0se3R5cGU6Y30pKX1jYXRjaChHKXt9Ynx8KGM9bmV3IGZmLGMuYXBwZW5kKChuZXcgVWludDhBcnJheShhKSkuYnVmZmVyKSxiPWMuZ2V0QmxvYigpKTt2YXIgbD13Zygid3JhcHBlclRleHR1cmVQcmVMb2FkIiwibnVtYmVyIixbIm51bWJlciIsIm51bWJlciIsIm51bWJlciIsIm51bWJlciJdKSxuPXdnKCJ3cmFwcGVyVGV4dHVyZVBvc3RMb2FkIiwKbnVsbCxbIm51bWJlciIsIm51bWJlciIsIm51bWJlciJdKSxxPXdnKCJ3cmFwcGVyVGV4dHVyZU9uRXJyb3IiLG51bGwsWyJudW1iZXIiLCJudW1iZXIiXSksdj1nZi5jcmVhdGVPYmplY3RVUkwoYiksdz1kb2N1bWVudC5jcmVhdGVFbGVtZW50KCJpbWciKSxDPWcuJCRmYWNhZGU7dy5vbmxvYWQ9ZnVuY3Rpb24oKXtpZihDPT09Zy4kJGZhY2FkZSl7dmFyIEc9MTtsJiYoRz1sKGUsdy53aWR0aCx3LmhlaWdodCxkKSk7dmFyIHA9MDtpZihHKXRyeXtOLnRleEltYWdlMkQoTi5URVhUVVJFXzJELDAsZixmLE4uVU5TSUdORURfQllURSx3KSxwPTF9Y2F0Y2goeSl7fW4mJm4oMCxlLHApfWVsc2UgbiYmbigxLGUsMCk7Z2YucmV2b2tlT2JqZWN0VVJMKHYpfTt3Lm9uZXJyb3I9ZnVuY3Rpb24oKXtDPT09Zy4kJGZhY2FkZT9xJiZxKDAsZSk6cSYmcSgxLGUpO2dmLnJldm9rZU9iamVjdFVSTCh2KX07dy5zcmM9dn0sdmE6ZnVuY3Rpb24oKXtyZXR1cm4gZy5ZaT94Zy5jbG9zZS5hcHBseSh4ZywKYXJndW1lbnRzKTp5Zy5jbG9zZS5hcHBseSh5Zyxhcmd1bWVudHMpfSxZZzpmdW5jdGlvbigpe3dpbmRvdy5hZGRFdmVudExpc3RlbmVyKCJiZWZvcmV1bmxvYWQiLGZ1bmN0aW9uKCl7Zy5ZaT94Zy5jbG9zZSgpOnlnLmNsb3NlKCl9KX0sWGc6ZnVuY3Rpb24oYSxiLGMpe2cuWWo9MDtzZWxmLmJvd3Nlci5jaHJvbWUmJjA+c2VsZi5ib3dzZXIuY29tcGFyZVZlcnNpb25zKFtzZWxmLmJvd3Nlci52ZXJzaW9uLCI2OCJdKSYmKGcuWWk9ITApO3JldHVybiBnLllpP3hnLmNvbm5lY3QuYXBwbHkoeGcsYXJndW1lbnRzKTp5Zy5jb25uZWN0LmFwcGx5KHlnLGFyZ3VtZW50cyl9LFdnOmZ1bmN0aW9uKGEsYil7cmV0dXJuIGcuWWk/eGcuRmouYXBwbHkoeGcsYXJndW1lbnRzKTp5Zy5Gai5hcHBseSh5Zyxhcmd1bWVudHMpfSx4YjpmdW5jdGlvbihhLGIsYyxkKXtyZXR1cm4gQ2coYSxiLGMsZCl9fTsKKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gYShlKXtnLmFzbT1lLmV4cG9ydHM7WGE9Zy5hc20uRmg7bWIoKTtuYj1nLmFzbS5IaDtwYi51bnNoaWZ0KGcuYXNtLkdoKTt5Yigid2FzbS1pbnN0YW50aWF0ZSIpfWZ1bmN0aW9uIGIoZSl7YShlLmluc3RhbmNlKX1mdW5jdGlvbiBjKGUpe3JldHVybiBHYigpLnRoZW4oZnVuY3Rpb24oZil7cmV0dXJuIFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKGYsZCl9KS50aGVuKGZ1bmN0aW9uKGYpe3JldHVybiBmfSkudGhlbihlLGZ1bmN0aW9uKGYpe1NhKCJmYWlsZWQgdG8gYXN5bmNocm9ub3VzbHkgcHJlcGFyZSB3YXNtOiAiK2YpO1dhKGYpfSl9dmFyIGQ9e2E6S2d9O3hiKCJ3YXNtLWluc3RhbnRpYXRlIik7aWYoZy5pbnN0YW50aWF0ZVdhc20pdHJ5e3JldHVybiBnLmluc3RhbnRpYXRlV2FzbShkLGEpfWNhdGNoKGUpe1NhKCJNb2R1bGUuaW5zdGFudGlhdGVXYXNtIGNhbGxiYWNrIGZhaWxlZCB3aXRoIGVycm9yOiAiK2UpLGZhKGUpfShmdW5jdGlvbigpe3JldHVybiBWYXx8CiJmdW5jdGlvbiIhPXR5cGVvZiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZ3x8emIoKXx8RGIuc3RhcnRzV2l0aCgiZmlsZTovLyIpfHxIYXx8ImZ1bmN0aW9uIiE9dHlwZW9mIGZldGNoP2MoYik6ZmV0Y2goRGIse2NyZWRlbnRpYWxzOiJzYW1lLW9yaWdpbiJ9KS50aGVuKGZ1bmN0aW9uKGUpe3JldHVybiBXZWJBc3NlbWJseS5pbnN0YW50aWF0ZVN0cmVhbWluZyhlLGQpLnRoZW4oYixmdW5jdGlvbihmKXtTYSgid2FzbSBzdHJlYW1pbmcgY29tcGlsZSBmYWlsZWQ6ICIrZik7U2EoImZhbGxpbmcgYmFjayB0byBBcnJheUJ1ZmZlciBpbnN0YW50aWF0aW9uIik7cmV0dXJuIGMoYil9KX0pfSkoKS5jYXRjaChmYSk7cmV0dXJue319KSgpO2cuX19fd2FzbV9jYWxsX2N0b3JzPWZ1bmN0aW9uKCl7cmV0dXJuKGcuX19fd2FzbV9jYWxsX2N0b3JzPWcuYXNtLkdoKS5hcHBseShudWxsLGFyZ3VtZW50cyl9OwpnLl9jYWxsRnVuY1dyYXBwZXI9ZnVuY3Rpb24oKXtyZXR1cm4oZy5fY2FsbEZ1bmNXcmFwcGVyPWcuYXNtLkloKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O2cuX21haW49ZnVuY3Rpb24oKXtyZXR1cm4oZy5fbWFpbj1nLmFzbS5KaCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTtnLl93cmFwcGVyVGV4dHVyZVByZUxvYWQ9ZnVuY3Rpb24oKXtyZXR1cm4oZy5fd3JhcHBlclRleHR1cmVQcmVMb2FkPWcuYXNtLktoKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O2cuX3dyYXBwZXJUZXh0dXJlUG9zdExvYWQ9ZnVuY3Rpb24oKXtyZXR1cm4oZy5fd3JhcHBlclRleHR1cmVQb3N0TG9hZD1nLmFzbS5MaCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTtnLl93cmFwcGVyVGV4dHVyZU9uRXJyb3I9ZnVuY3Rpb24oKXtyZXR1cm4oZy5fd3JhcHBlclRleHR1cmVPbkVycm9yPWcuYXNtLk1oKS5hcHBseShudWxsLGFyZ3VtZW50cyl9Owp2YXIgYmU9Zy5fZnJlZT1mdW5jdGlvbigpe3JldHVybihiZT1nLl9mcmVlPWcuYXNtLk5oKS5hcHBseShudWxsLGFyZ3VtZW50cyl9LEpnPWcuX19fZXJybm9fbG9jYXRpb249ZnVuY3Rpb24oKXtyZXR1cm4oSmc9Zy5fX19lcnJub19sb2NhdGlvbj1nLmFzbS5PaCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxkZz1nLl9tYWxsb2M9ZnVuY3Rpb24oKXtyZXR1cm4oZGc9Zy5fbWFsbG9jPWcuYXNtLlBoKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O2cuX3dlYlNvY2tldEhhbmRsZXJPbk1lc3NhZ2U9ZnVuY3Rpb24oKXtyZXR1cm4oZy5fd2ViU29ja2V0SGFuZGxlck9uTWVzc2FnZT1nLmFzbS5RaCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTt2YXIgYWU9Zy5fX19nZXRUeXBlTmFtZT1mdW5jdGlvbigpe3JldHVybihhZT1nLl9fX2dldFR5cGVOYW1lPWcuYXNtLlJoKS5hcHBseShudWxsLGFyZ3VtZW50cyl9OwpnLl9fZW1iaW5kX2luaXRpYWxpemVfYmluZGluZ3M9ZnVuY3Rpb24oKXtyZXR1cm4oZy5fX2VtYmluZF9pbml0aWFsaXplX2JpbmRpbmdzPWcuYXNtLlNoKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O3ZhciBtYT1nLnN0YWNrU2F2ZT1mdW5jdGlvbigpe3JldHVybihtYT1nLnN0YWNrU2F2ZT1nLmFzbS5UaCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxzYT1nLnN0YWNrUmVzdG9yZT1mdW5jdGlvbigpe3JldHVybihzYT1nLnN0YWNrUmVzdG9yZT1nLmFzbS5VaCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfSxuYT1nLnN0YWNrQWxsb2M9ZnVuY3Rpb24oKXtyZXR1cm4obmE9Zy5zdGFja0FsbG9jPWcuYXNtLlZoKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O2cuZHluQ2FsbF92aWlpamlpaWlpaWlpaWlpPWZ1bmN0aW9uKCl7cmV0dXJuKGcuZHluQ2FsbF92aWlpamlpaWlpaWlpaWlpPWcuYXNtLldoKS5hcHBseShudWxsLGFyZ3VtZW50cyl9OwpnLmR5bkNhbGxfaWlqPWZ1bmN0aW9uKCl7cmV0dXJuKGcuZHluQ2FsbF9paWo9Zy5hc20uWGgpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07Zy5keW5DYWxsX2lpaWlpaWppaT1mdW5jdGlvbigpe3JldHVybihnLmR5bkNhbGxfaWlpaWlpamlpPWcuYXNtLlloKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O2cuZHluQ2FsbF9qaWppPWZ1bmN0aW9uKCl7cmV0dXJuKGcuZHluQ2FsbF9qaWppPWcuYXNtLlpoKS5hcHBseShudWxsLGFyZ3VtZW50cyl9O2cuZHluQ2FsbF92aWlqaWk9ZnVuY3Rpb24oKXtyZXR1cm4oZy5keW5DYWxsX3ZpaWppaT1nLmFzbS5faCkuYXBwbHkobnVsbCxhcmd1bWVudHMpfTtnLmR5bkNhbGxfaWlpaWlqPWZ1bmN0aW9uKCl7cmV0dXJuKGcuZHluQ2FsbF9paWlpaWo9Zy5hc20uJGgpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07Zy5keW5DYWxsX2lpaWlpamo9ZnVuY3Rpb24oKXtyZXR1cm4oZy5keW5DYWxsX2lpaWlpamo9Zy5hc20uYWkpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07CmcuZHluQ2FsbF9paWlpaWlqaj1mdW5jdGlvbigpe3JldHVybihnLmR5bkNhbGxfaWlpaWlpamo9Zy5hc20uYmkpLmFwcGx5KG51bGwsYXJndW1lbnRzKX07Zy5fX19lbXNjcmlwdGVuX2VtYmVkZGVkX2ZpbGVfZGF0YT02NTg4MzI7Zy5hZGRSdW5EZXBlbmRlbmN5PXhiO2cucmVtb3ZlUnVuRGVwZW5kZW5jeT15YjtnLkZTX2NyZWF0ZVBhdGg9U2M7Zy5GU19jcmVhdGVEYXRhRmlsZT1VYztnLkZTX2NyZWF0ZVByZWxvYWRlZEZpbGU9WmM7Zy5GU19jcmVhdGVMYXp5RmlsZT1YYztnLkZTX2NyZWF0ZURldmljZT1WYztnLkZTX3VubGluaz1FYztnLmNjYWxsPURnO2cuY3dyYXA9d2c7dmFyIExnO3diPWZ1bmN0aW9uIE1nKCl7TGd8fE5nKCk7TGd8fCh3Yj1NZyl9OwpmdW5jdGlvbiBOZygpe2Z1bmN0aW9uIGEoKXtpZighTGcmJihMZz0hMCxnLmNhbGxlZFJ1bj0hMCwhYmIpKXtnLm5vRlNJbml0fHxRY3x8KFFjPSEwLFBjKCksZy5zdGRpbj1nLnN0ZGluLGcuc3Rkb3V0PWcuc3Rkb3V0LGcuc3RkZXJyPWcuc3RkZXJyLGcuc3RkaW4/VmMoIi9kZXYiLCJzdGRpbiIsZy5zdGRpbik6RGMoIi9kZXYvdHR5IiwiL2Rldi9zdGRpbiIpLGcuc3Rkb3V0P1ZjKCIvZGV2Iiwic3Rkb3V0IixudWxsLGcuc3Rkb3V0KTpEYygiL2Rldi90dHkiLCIvZGV2L3N0ZG91dCIpLGcuc3RkZXJyP1ZjKCIvZGV2Iiwic3RkZXJyIixudWxsLGcuc3RkZXJyKTpEYygiL2Rldi90dHkxIiwiL2Rldi9zdGRlcnIiKSxIYygiL2Rldi9zdGRpbiIsMCksSGMoIi9kZXYvc3Rkb3V0IiwxKSxIYygiL2Rldi9zdGRlcnIiLDEpKTtuYz0hMTtLYihwYik7S2IocmIpO2FhKGcpO2lmKGcub25SdW50aW1lSW5pdGlhbGl6ZWQpZy5vblJ1bnRpbWVJbml0aWFsaXplZCgpO2lmKE9nKXt2YXIgYj0KZy5fbWFpbjt0cnl7dmFyIGM9YigwLDApO09lKGMsITApfWNhdGNoKGQpe1BlKGQpfX1pZihnLnBvc3RSdW4pZm9yKCJmdW5jdGlvbiI9PXR5cGVvZiBnLnBvc3RSdW4mJihnLnBvc3RSdW49W2cucG9zdFJ1bl0pO2cucG9zdFJ1bi5sZW5ndGg7KWI9Zy5wb3N0UnVuLnNoaWZ0KCksc2IudW5zaGlmdChiKTtLYihzYil9fWlmKCEoMDx1Yikpe2lmKGcucHJlUnVuKWZvcigiZnVuY3Rpb24iPT10eXBlb2YgZy5wcmVSdW4mJihnLnByZVJ1bj1bZy5wcmVSdW5dKTtnLnByZVJ1bi5sZW5ndGg7KXRiKCk7S2Iob2IpOzA8dWJ8fChnLnNldFN0YXR1cz8oZy5zZXRTdGF0dXMoIlJ1bm5pbmcuLi4iKSxzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7c2V0VGltZW91dChmdW5jdGlvbigpe2cuc2V0U3RhdHVzKCIiKX0sMSk7YSgpfSwxKSk6YSgpKX19aWYoZy5wcmVJbml0KWZvcigiZnVuY3Rpb24iPT10eXBlb2YgZy5wcmVJbml0JiYoZy5wcmVJbml0PVtnLnByZUluaXRdKTswPGcucHJlSW5pdC5sZW5ndGg7KWcucHJlSW5pdC5wb3AoKSgpOwp2YXIgT2c9ITA7Zy5ub0luaXRpYWxSdW4mJihPZz0hMSk7TmcoKTsKCgogIHJldHVybiBTY0VuZ2luZU1vZHVsZS5yZWFkeQp9Cik7Cn0pKCk7CmV4cG9ydCBkZWZhdWx0IFNjRW5naW5lTW9kdWxlOw==", pg = mg;
window.bowser = dg;
function gg(n) {
  return n !== null && typeof n == "object" && "isWrapper" in n && !!n.isWrapper && "base" in n && n.base !== void 0 && "args" in n && n.args !== void 0;
}
const vi = class {
  // store instance arguments and return empty base object that will
  // be populated asynchronously
  static async createInstance(n) {
    const t = {
      isWrapper: !0,
      base: {},
      args: n,
      enginePath: n.enginePath ?? vi.defaultEnginePath
    };
    return await vi.createScInstance(t), t.base;
  }
  static catchExceptions(n, t) {
    return function(...e) {
      try {
        t.apply(this, e);
      } catch (i) {
        console.log("Unhandled exception in " + n + "():"), console.log(i);
      }
    };
  }
  static getElement(n) {
    return typeof n != "string" ? n : document.getElementById(n);
  }
  static getAvailableCore() {
    for (const n of vi.core_pool)
      if (n.$$available)
        return n;
    return null;
  }
  static createCore(n) {
    const t = {
      $$available: !1,
      $$wrapper: document.createElement("div"),
      $$facade: n,
      callAfterMap: { index: 0, indexedWrappers: {} },
      canvas: document.createElement("canvas"),
      wasmBinary: vi.defaultBinary
    };
    return vi.core_pool.push(t), t.$$wrapper.setAttribute(
      "style",
      "position: absolute; overflow: hidden; width: 100%; height: 100%; padding: 0; margin: 0; border: 0;"
    ), t.canvas.setAttribute(
      "style",
      "position: absolute; top: 0; left: 0; width: 100%; height: 100%; padding: 0; margin: 0; border: 0;"
    ), t;
  }
  static getCore(n, t) {
    let e = vi.getAvailableCore();
    const i = !e;
    return e === null && (e = vi.createCore(n)), e.$$available = !1, e.canvas.style.display = "", e.$$wrapper.appendChild(e.canvas), e.$$facade = n, e.$$onReady = vi.catchExceptions("onReady", function() {
      const s = t.onReady;
      typeof s == "function" && s(n);
    }), typeof t.onError == "function" && (e.onAbort = vi.catchExceptions("onError", function(s) {
      t.onError("fatal error: see console " + s);
    })), typeof t.enginePath == "string" && (e.locateFile = (s) => `${t.enginePath}/${s}`), { core: e, isNew: i };
  }
  static getFacade(n) {
    let t, e;
    gg(n) ? (t = n.base, e = n.args) : (t = {}, e = n);
    const i = vi.getElement(e.container);
    if (!i)
      throw new TypeError("'container' argument is missing or invalid");
    return t.container = i, { facade: t, args: e };
  }
  static createSubContainer(n, t) {
    const e = document.createElement("div");
    e.setAttribute(
      "style",
      "position: relative; overflow: hidden; width: 100%; height: 100%; padding: 0; margin: 0; border: 0;"
    );
    const i = document.createElement("div");
    return i.setAttribute(
      "style",
      "position: absolute; top: 0; left: 0; width: 100%; height: 100%; padding: 0; margin: 0; border: 0;"
    ), i.onmousedown = function(s) {
      s.preventDefault();
    }, i.oncontextmenu = function(s) {
      s.preventDefault();
    }, e.appendChild(t.$$wrapper), e.appendChild(i), n.container.innerHTML = "", n.container.appendChild(e), e;
  }
  static async createScInstance(n) {
    const { facade: t, args: e } = vi.getFacade(n), { core: i, isNew: s } = vi.getCore(t, e);
    return vi.createSubContainer(t, i), s ? i.locateFile ? import(i.locateFile("engine.esm.js")).then((o) => {
      o.default(i);
    }) : vi.defaultModule ? vi.defaultModule(i) : import(
      /* @vite-ignore */
      pg
    ).then((r) => {
      vi.defaultModule = r.default, r.default(i);
    }) : setTimeout(function() {
      i.$$setReady && i.$$setReady();
    }), t;
  }
};
let Xo = vi;
Xo.core_pool = [];
const R0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AntiAliasingMode: ch,
  AttachScope: lr,
  BimMask: ei,
  BimType: Co,
  BlurIntervalUnit: ko,
  CullingVectorSpace: ad,
  CuttingSectionKey: Pr,
  DataKey: El,
  DrawMode: Dn,
  DrawStrategy: ld,
  ElementMask: cd,
  ElementType: Je,
  GroupKey: td,
  HighlightFilter: xs,
  HighlightMode: hh,
  ImageFormat: Ss,
  ImageKey: ed,
  InclusionKey: ve,
  InstanceKey: lh,
  Key: ah,
  LightKey: id,
  LightSpace: rd,
  LightType: od,
  LinePatternLengthUnit: hd,
  MasterModelKey: Hn,
  MatrixKey: nd,
  MeshKey: Zo,
  ModelKey: Ji,
  OverlayAnchor: kn,
  OverlayUnit: Gr,
  PointShape: ud,
  PointSizeUnit: dd,
  Projection: Lo,
  SessionType: Oe,
  SetVisibility: hs,
  SimpleReflectionAttenuationUnit: uh,
  SmaaQuality: md,
  StateFailure: dh,
  StreamcacheModule: Xo,
  TextureInterpolation: gl,
  TextureMipMapping: fl,
  TextureModifier: Mo,
  TextureParameterization: _l,
  TextureTiling: yl,
  TransparencyMode: pd,
  UnspecifiedMeasurementUnit: nn,
  ViewKey: sd,
  XRayGroup: bl,
  getStateFailure: gd,
  isError: $s
}, Symbol.toStringTag, { value: "Module" }));
function Nl(n) {
  const t = /* @__PURE__ */ new Map();
  return n.forEach((e, i) => {
    t.set(i, e);
  }), t;
}
function fg(n) {
  const t = /* @__PURE__ */ new Set();
  return n.forEach((e) => {
    t.add(e);
  }), t;
}
function Wo(n) {
  const t = /* @__PURE__ */ new Set();
  for (const e of n)
    t.add(e);
  return t;
}
function us(n) {
  const t = [];
  return n.forEach((e) => {
    t.push(e);
  }), t;
}
function Ic(n, t) {
  const e = us(n).filter((i) => !t.has(i));
  return Wo(e);
}
function Il(n) {
  const t = {
    origin: [],
    direction: []
  };
  return n.origin.toArray(t.origin), n.direction.toArray(t.direction), t;
}
function La(n) {
  const t = new x_();
  return t.pos1.fromArray(n.point1), t.pos2.fromArray(n.point2), t.distance = n.distance, t;
}
function Ct(n, t) {
  return (n & t) === t;
}
function Nr(n, t, e) {
  return e ? n | t : n & ~t;
}
function _g(n) {
  let t = "";
  const e = n.byteLength;
  for (let i = 0; i < e; i++)
    t += String.fromCharCode(n[i]);
  return window.btoa(t);
}
function iu(n) {
  let t = Math.abs(n.x), e = Math.abs(n.y), i = Math.abs(n.z);
  return t = +t.toFixed(6), e = +e.toFixed(6), i = +i.toFixed(6), t > e && t > i ? new d(1, 0, 0) : e > t && e > i ? new d(0, 1, 0) : i > t && i > e ? new d(0, 0, 1) : null;
}
function Fo(n) {
  return JSON.parse(JSON.stringify(n));
}
function yg(n, t) {
  for (const e in n)
    Object.prototype.hasOwnProperty.call(n, e) && (t[e] = n[e]);
}
function Zr(n, t) {
  return n === void 0 ? t : n;
}
function Ko(n, t) {
  const e = n.length > t.length ? n.length : t.length;
  for (let i = 0; i < e; ++i) {
    const s = n[i] || 0, r = t[i] || 0;
    if (s > r)
      return !0;
    if (s < r)
      return !1;
  }
  return !0;
}
function yd(n) {
  if (n.length === 0)
    return "";
  let t = `${n[0]}`;
  for (let e = 1; e < n.length; ++e)
    t += `.${n[e]}`;
  return t;
}
function bg() {
  return window.crypto || window.msCrypto;
}
const Ig = "²", wg = "³";
function nu(n) {
  if (n instanceof Map)
    return n;
  const t = /* @__PURE__ */ new Map(), e = Object.keys(n);
  for (const i of e) {
    const s = n[i];
    t.set(parseInt(i, 10), s);
  }
  return t;
}
const bd = /* @__PURE__ */ new Map();
function Ui(n, t) {
  bd.set(n, t);
}
function mh(n) {
  return bd.get(n);
}
const en = -1;
function Qr(n) {
  return console.assert(n !== en), n > en;
}
function vg(n) {
  return console.assert(Qr(n)), n;
}
function Os(n, t) {
  return Qr(n) ? Ne(t).toRuntimeId(n) : n;
}
class ph {
  static parseXml(t) {
    console.assert(t.localName === "Material");
    let e = null, i = null;
    const s = t.getAttribute("Color");
    if (s !== null) {
      const r = s.split(" ");
      if (r.length !== 4)
        throw new ce('Expected "Color" attribute to have four channel components.');
      const o = parseFloat(r[0]), a = parseFloat(r[1]), l = parseFloat(r[2]), c = parseFloat(r[3]);
      e = new it(o, a, l), i = c;
    }
    return new ph(e, i);
  }
  constructor(t, e) {
    t !== null && (this._color = t), e !== null && (this._alpha = e);
  }
  getColor() {
    return this._color !== void 0 ? this._color : null;
  }
  getAlpha() {
    return this._alpha !== void 0 ? this._alpha : null;
  }
}
var Qt = /* @__PURE__ */ ((n) => (n[n.Id = 1] = "Id", n[n.Name = 2] = "Name", n[n.Visiblity = 4] = "Visiblity", n[n.Transform = 8] = "Transform", n[n.SubNodes = 16] = "SubNodes", n[n.Instance = 32] = "Instance", n[n.InstanceQuickAccess = 64] = "InstanceQuickAccess", n[n.BodyInstances = 128] = "BodyInstances", n[n.Attributes = 256] = "Attributes", n[n.PartDataLink = 512] = "PartDataLink", n[n.Bodies = 1024] = "Bodies", n[n.FaceMeasurement = 2048] = "FaceMeasurement", n[n.EdgeMeasurement = 4096] = "EdgeMeasurement", n[n.MeshKey = 8192] = "MeshKey", n[n.Unit = 16384] = "Unit", n[n.Views = 32768] = "Views", n[n.Pmis = 65536] = "Pmis", n[n.ScInclusionKey = 131072] = "ScInclusionKey", n[n.ScInstanceKey = 262144] = "ScInstanceKey", n[n.ExternalModel = 524288] = "ExternalModel", n[n.PhysicalProperties = 1048576] = "PhysicalProperties", n[n.VersionNumber = 2097152] = "VersionNumber", n[n.ProductBits = 4194304] = "ProductBits", n[n.Header = 8388608] = "Header", n[n.FrontUpVector = 16777216] = "FrontUpVector", n[n.ExchangeId = 33554432] = "ExchangeId", n[n.LayerId = 67108864] = "LayerId", n[n.LayerList = 134217728] = "LayerList", n[n.Filters = 268435456] = "Filters", n[n.UserData = 536870912] = "UserData", n[n.UseNodeParseBits2 = 1073741824] = "UseNodeParseBits2", n))(Qt || {}), Un = /* @__PURE__ */ ((n) => (n[n.FaceAttributes = 1] = "FaceAttributes", n[n.EdgeAttributes = 2] = "EdgeAttributes", n[n.OriginalName = 4] = "OriginalName", n[n.GenericTypes = 8] = "GenericTypes", n[n.GenericTypeId = 16] = "GenericTypeId", n[n.GenericId = 32] = "GenericId", n[n.DoublePrecisionMatrices = 64] = "DoublePrecisionMatrices", n[n.PointAttributes = 128] = "PointAttributes", n[n.Relationships = 256] = "Relationships", n))(Un || {}), ui = /* @__PURE__ */ ((n) => (n[n.Name = 1] = "Name", n[n.Camera = 2] = "Camera", n[n.Pmi = 4] = "Pmi", n[n.Frame = 8] = "Frame", n[n.ShowNodes = 16] = "ShowNodes", n[n.HideNodes = 32] = "HideNodes", n[n.MoveNodes = 64] = "MoveNodes", n[n.CuttingPlanes = 128] = "CuttingPlanes", n[n.IsAnnotationView = 256] = "IsAnnotationView", n[n.IsNotCameraSet = 512] = "IsNotCameraSet", n[n.IsNotPmiFilteringSet = 1024] = "IsNotPmiFilteringSet", n[n.IsNotGeomFilteringSet = 2048] = "IsNotGeomFilteringSet", n[n.IsNotCrosssectionSet = 4096] = "IsNotCrosssectionSet", n[n.IsNotExplosionSet = 8192] = "IsNotExplosionSet", n[n.IsCombineState = 16384] = "IsCombineState", n[n.IsPerspective = 32768] = "IsPerspective", n[n.IsDefaultView = 65536] = "IsDefaultView", n))(ui || {}), Us = /* @__PURE__ */ ((n) => (n[n.Name = 1] = "Name", n[n.TopoRef = 2] = "TopoRef", n[n.Attributes = 4] = "Attributes", n[n.InitiallyHidden = 8] = "InitiallyHidden", n[n.HasMultipleBodies = 16] = "HasMultipleBodies", n[n.ExchangeId = 32] = "ExchangeId", n))(Us || {}), ja = /* @__PURE__ */ ((n) => (n[n.Name = 1] = "Name", n[n.LayerItem = 2] = "LayerItem", n[n.EntityItem = 4] = "EntityItem", n))(ja || {}), Id = /* @__PURE__ */ ((n) => (n[n.Name = 1] = "Name", n))(Id || {}), wc = /* @__PURE__ */ ((n) => (n[n.ValueName = 1] = "ValueName", n[n.Units = 2] = "Units", n))(wc || {}), Ha = /* @__PURE__ */ ((n) => (n[n.Type = 1] = "Type", n[n.Related = 2] = "Related", n[n.Relating = 4] = "Relating", n))(Ha || {}), mi = /* @__PURE__ */ ((n) => (n[n.BeforeAction = 0] = "BeforeAction", n[n.AfterAction = 1] = "AfterAction", n))(mi || {});
function Sg(n, t) {
  let e = 0;
  for (let i = 0; i < n.length; ++i) {
    const s = n[i];
    t(s) && (n[e++] = s);
  }
  n.length = e;
}
class ji {
  /**
   * Creates a new lazy value, which is the result of the supplied function
   * once the lazy value is forced.
   */
  static create(t) {
    return new ji(t);
  }
  constructor(t) {
    this._deferredValue = t;
  }
  /**
   * Forces the lazy value given at construction and returns it.
   */
  get() {
    return this._deferredValue !== null && (this._resolvedValue = this._deferredValue(), this._deferredValue = null), this._resolvedValue;
  }
}
const xg = 1024;
class su {
  constructor() {
    this.items = [], this.next = null;
  }
}
class wd {
  constructor() {
    this.clear();
  }
  clear() {
    this._head = new su(), this._tail = this._head, this._size = 0;
  }
  get length() {
    return this._size;
  }
  push(t) {
    if (++this._size, this._tail.items.length === xg) {
      const e = new su();
      this._tail.next = e, this._tail = e;
    }
    this._tail.items.push(t);
  }
  pop() {
    console.assert(this._size > 0), console.assert(this._head.items.length > 0), --this._size;
    const t = this._head.items.shift();
    if (this._head.items.length === 0) {
      const e = this._head.next;
      e === null ? console.assert(this._head === this._tail) : this._head = e;
    }
    return t;
  }
}
function be() {
  let n, t;
  const e = new Promise((i, s) => {
    n = i, t = s;
  });
  return e.resolve = n, e.reject = t, e;
}
class Po {
  /**
   * Creates a new [ActionQueue]
   * @param maxActivePromises Max number of promises to leave open before they begin getting deferred
   * @param suppressFailures Whether or not rejected promises and actions that throw cause the queue to fail
   */
  constructor(t, e) {
    this._failed = !1, this._failureError = null, this._activePromiseCount = 0, this._idlePromise = null, console.assert(t > 0, "Don't create a non-progressible queue."), this._maxActivePromises = t, this._suppressFailures = e, this._deferredActions = new wd();
  }
  /**
   * Returns `true` if there are no actions waiting to be evaluated
   * @returns Boolean indicating idle status
   */
  isIdle() {
    return this._activePromiseCount === 0;
  }
  /**
   * Returns a `Promise<void>` that resolves when all actions have been completed or rejects if there
   * was a failure
   *
   * It should be noted that if the queue is configured not to suppress failures and an action throws an error,
   * any deferred actions (actions that were queued but not active at the time of the failure) will be
   * cleared from the queue and will not be evaluated
   * @returns A promise that resolves/rejects when all actions have been completed
   */
  async waitForIdle() {
    if (this.isIdle()) {
      if (this._failed)
        throw this._failureError;
      return;
    }
    return this._idlePromise === null && (this._idlePromise = be()), this._idlePromise;
  }
  /**
   * Pushes a new [ActionLike] to be evaluated onto the queue
   * @param action
   */
  push(t) {
    typeof t == "function" && (t = ji.create(t)), this._activePromiseCount < this._maxActivePromises ? (console.assert(this._deferredActions.length === 0), this._immediateAction(t)) : this._deferredActions.push(t);
  }
  _immediateAction(t) {
    if (this._failed)
      return console.assert(this._deferredActions.length === 0), !0;
    let e;
    try {
      e = t.get();
    } catch (i) {
      this._suppressFailures || (this._failed = !0, this._failureError = i, this._deferredActions.clear());
    }
    return e === void 0 ? !0 : (++this._activePromiseCount, e.then((i) => (this._finalizePromise(), i)).catch((i) => {
      throw this._finalizePromise(), i;
    }), !1);
  }
  _finalizePromise() {
    if (--this._activePromiseCount, this._failed && console.assert(this._deferredActions.length === 0), this._deferredActions.length > 0)
      do {
        const t = this._deferredActions.pop();
        if (!this._immediateAction(t))
          break;
      } while (this._deferredActions.length > 0);
    this._tryActivateIdlePromise();
  }
  _tryActivateIdlePromise() {
    this._activePromiseCount === 0 && (console.assert(this._deferredActions.length === 0), this._idlePromise !== null && (this._failed ? this._idlePromise.reject(this._failureError) : this._idlePromise.resolve(), this._idlePromise = null));
  }
}
class fs {
  /**
   * Creates a new `CurrentAction`.
   * @param suppressFailures Controls whether or not thrown action errors cause `waitForIdle` to throw.
   */
  constructor(t) {
    this._active = null, this._pending = null, this._idlePromise = null, this._suppressFailures = t;
  }
  /**
   * Queries the idle state of this object.
   * @return `true` if there are no executing actions and `false` otherwise.
   */
  isIdle() {
    return this._active === null;
  }
  /**
   * Creates `Promise` that can be used to wait for this object to become idle.
   *
   * If this object was created with `suppressFailures`, then the returned `Promise`
   * never throws. Otherwise action failures (from `this.set`) propagate to the returned `Promise`.
   *
   * @return The idle `Promise`.
   */
  waitForIdle() {
    return this.isIdle() ? Promise.resolve() : (this._idlePromise === null && (this._idlePromise = be()), this._idlePromise);
  }
  /**
   * Sets the action to execute to the one supplied.
   *
   * If this object is idle, then the action is immediately executed,
   * and this object is no longer as long as the action is running.
   *
   * Otherwise if the object is not idle, then action becomes pended
   * and will execute after the current one finishes. If an action is
   * already pended, then the prior pending action is replaced by the
   * newly supplied action and is discarded.
   *
   * @param action
   */
  set(t) {
    if (typeof t == "function" && (t = ji.create(t)), this._active === null) {
      let e;
      try {
        e = t.get();
      } catch (i) {
        return this._advance(!this._suppressFailures, i);
      }
      if (e === void 0)
        return this._advance(!1, null);
      this._active = e.then(() => {
        this._advance(!1, null);
      }).catch((i) => {
        this._advance(!this._suppressFailures, i);
      });
    } else
      this._pending = t;
  }
  _advance(t, e) {
    if (this._active = null, t && (this._pending = null), this._pending === null)
      this._idlePromise !== null && (t ? this._idlePromise.reject(e) : this._idlePromise.resolve(), this._idlePromise = null);
    else {
      const i = this._pending;
      this._pending = null, this.set(i);
    }
  }
  /**
   * Clears and discards any pending actions. If an action is
   * currently being executed, it remains unaffected by this.
   */
  clear() {
    this._pending = null;
  }
}
function zt(n) {
  return Promise.all(n);
}
class Zg {
  constructor(t) {
    this.promise = be(), this.ids = t;
  }
}
class Cg {
  constructor() {
    this._aliasMap = /* @__PURE__ */ new Map(), this._callbackMap = /* @__PURE__ */ new Map(), this._activeTriggerDepth = 0, this._pendingClearUnboundFilteredNames = /* @__PURE__ */ new Set(), this._aliasMap.set("sceneRendered", "frameDrawn");
  }
  _filterName(t) {
    const e = this._aliasMap.get(t);
    return e === void 0 ? t : e;
  }
  bind(t, e) {
    const i = Object.keys(t);
    for (const s of i) {
      const r = t[s];
      if (typeof r == "function") {
        const o = this._filterName(s), a = this._callbackMap.get(o);
        a === void 0 ? this._callbackMap.set(o, [r]) : e ? a.unshift(r) : a.push(r);
      }
    }
  }
  unbind(t) {
    const e = Object.keys(t);
    for (const i of e) {
      const s = this._filterName(i), r = this._callbackMap.get(s);
      if (r !== void 0) {
        const o = t[i];
        for (let a = 0; a < r.length; a++)
          r[a] === o && (r[a] = null, this._pendingClearUnboundFilteredNames.add(s));
      }
    }
    this._clearUnboundCallbacks();
  }
  _clearUnboundCallbacks() {
    this._pendingClearUnboundFilteredNames.size !== 0 && this._activeTriggerDepth === 0 && (this._pendingClearUnboundFilteredNames.forEach((t) => {
      let e = this._callbackMap.get(t);
      e !== void 0 && (e = e.filter((i) => i !== null), e.length === 0 ? this._callbackMap.delete(t) : this._callbackMap.set(t, e));
    }), this._pendingClearUnboundFilteredNames.clear());
  }
  async promiseTrigger(t, e, ...i) {
    console.assert(t !== e);
    try {
      await this._unsafePromiseTrigger(t, i);
    } catch (s) {
      console.error(`Rejected promise in '${t}' callback:`, s);
    } finally {
      e !== null && this.unsafeTrigger(e, i);
    }
  }
  // Unsafe from a type safety point of view.
  _unsafePromiseTrigger(t, e) {
    const i = this._filterName(t), s = this._callbackMap.get(i), r = [];
    if (s !== void 0) {
      ++this._activeTriggerDepth;
      for (const o of s)
        if (o !== null)
          try {
            r.push(o(...e ?? []));
          } catch (a) {
            console.error(`Unhandled exception in '${t}' callback:`, a);
          }
      --this._activeTriggerDepth, this._clearUnboundCallbacks();
    }
    return zt(r);
  }
  trigger(t, ...e) {
    this.unsafeTrigger(t, e);
  }
  // Unsafe from a type safety point of view.
  unsafeTrigger(t, e) {
    const i = this._filterName(t), s = this._callbackMap.get(i);
    if (s !== void 0) {
      ++this._activeTriggerDepth;
      for (const r of s)
        if (r !== null)
          try {
            r(...e ?? []);
          } catch (o) {
            console.error(`Unhandled exception in '${t}' callback:`, o);
          }
      --this._activeTriggerDepth, this._clearUnboundCallbacks();
    }
  }
}
var vd = /* @__PURE__ */ ((n) => (n[n.Undefined = 0] = "Undefined", n[n.Line = 1] = "Line", n[n.Circle = 2] = "Circle", n[n.Other = 6] = "Other", n))(vd || {}), Sd = /* @__PURE__ */ ((n) => (n[n.Undefined = 0] = "Undefined", n[n.Cylinder = 3] = "Cylinder", n[n.Plane = 4] = "Plane", n[n.Cone = 5] = "Cone", n[n.Other = 6] = "Other", n[n.Sphere = 7] = "Sphere", n[n.Torus = 8] = "Torus", n[n.Blend01 = 9] = "Blend01", n[n.Blend02 = 10] = "Blend02", n[n.Blend03 = 11] = "Blend03", n[n.Nurbs = 12] = "Nurbs", n[n.Cylindrical = 13] = "Cylindrical", n[n.Offset = 14] = "Offset", n[n.Pipe = 15] = "Pipe", n[n.Ruled = 16] = "Ruled", n[n.Revolution = 17] = "Revolution", n[n.Extrusion = 18] = "Extrusion", n[n.FromCurves = 19] = "FromCurves", n[n.Transform = 20] = "Transform", n))(Sd || {});
let ma = class vc {
  constructor(t) {
    this.length = t;
  }
  static fromJson(t) {
    return new vc(t.length);
  }
  copy() {
    return new vc(this.length);
  }
  type() {
    return 1;
  }
}, qr = class Sc {
  constructor(t, e, i) {
    this.radius = t, this.origin = e.copy(), this.normal = i.copy();
  }
  static fromJson(t) {
    const e = t.radius, i = new d(t.origin.x, t.origin.y, t.origin.z), s = new d(t.normal.x, t.normal.y, t.normal.z);
    return new Sc(e, i, s);
  }
  copy() {
    return new Sc(this.radius, this.origin, this.normal);
  }
  type() {
    return 2;
  }
};
class Es {
  constructor(t) {
    this.length = t;
  }
  static fromJson(t) {
    return new Es(t.length);
  }
  copy() {
    return new Es(this.length);
  }
  type() {
    return 6;
  }
}
class pa {
  copy() {
    return new pa();
  }
  type() {
    return 6;
  }
}
class Ce {
  constructor(t, e, i) {
    this.radius = t, this.origin = e.copy(), this.normal = i.copy();
  }
  static fromJson(t) {
    const e = t.radius, i = new d(t.origin.x, t.origin.y, t.origin.z), s = new d(t.normal.x, t.normal.y, t.normal.z);
    return new Ce(e, i, s);
  }
  copy() {
    return new Ce(this.radius, this.origin, this.normal);
  }
  type() {
    return 3;
  }
}
class Re {
  constructor(t, e) {
    this.origin = t.copy(), this.normal = e.copy();
  }
  static fromJson(t) {
    const e = new d(t.origin.x, t.origin.y, t.origin.z), i = new d(t.normal.x, t.normal.y, t.normal.z);
    return new Re(e, i);
  }
  copy() {
    return new Re(this.origin, this.normal);
  }
  type() {
    return 4;
  }
}
class cr {
  constructor(t, e, i, s) {
    this.radius = t, this.origin = e.copy(), this.normal = i.copy(), this.halfAngle = s;
  }
  static fromJson(t) {
    const e = t.radius, i = t.halfAngle, s = new d(t.origin.x, t.origin.y, t.origin.z), r = new d(t.normal.x, t.normal.y, t.normal.z);
    return new cr(e, s, r, i);
  }
  copy() {
    return new cr(this.radius, this.origin, this.normal, this.halfAngle);
  }
  type() {
    return 5;
  }
}
class hr {
  constructor(t, e, i) {
    this.radius = t, this.origin = e.copy(), this.normal = i.copy();
  }
  static fromJson(t) {
    const e = t.radius, i = new d(t.origin.x, t.origin.y, t.origin.z), s = new d(t.normal.x, t.normal.y, t.normal.z);
    return new hr(e, i, s);
  }
  copy() {
    return new hr(this.radius, this.origin, this.normal);
  }
  type() {
    return 7;
  }
}
class ur {
  constructor(t, e, i, s) {
    this.majorRadius = t, this.minorRadius = e, this.origin = i.copy(), this.normal = s.copy();
  }
  static fromJson(t) {
    const e = new d(t.origin.x, t.origin.y, t.origin.z), i = new d(t.normal.x, t.normal.y, t.normal.z), s = t.majRadius, r = t.minRadius;
    return new ur(s, r, e, i);
  }
  copy() {
    return new ur(this.majorRadius, this.minorRadius, this.origin, this.normal);
  }
  type() {
    return 8;
  }
}
class ga {
  copy() {
    return new ga();
  }
  type() {
    return 9;
  }
}
class fa {
  copy() {
    return new fa();
  }
  type() {
    return 10;
  }
}
class _a {
  copy() {
    return new _a();
  }
  type() {
    return 11;
  }
}
class ya {
  copy() {
    return new ya();
  }
  type() {
    return 12;
  }
}
class ba {
  copy() {
    return new ba();
  }
  type() {
    return 13;
  }
}
class Ia {
  copy() {
    return new Ia();
  }
  type() {
    return 14;
  }
}
class wa {
  copy() {
    return new wa();
  }
  type() {
    return 15;
  }
}
class va {
  copy() {
    return new va();
  }
  type() {
    return 16;
  }
}
class Sa {
  copy() {
    return new Sa();
  }
  type() {
    return 17;
  }
}
class xa {
  copy() {
    return new xa();
  }
  type() {
    return 18;
  }
}
class Za {
  copy() {
    return new Za();
  }
  type() {
    return 19;
  }
}
class Ca {
  copy() {
    return new Ca();
  }
  type() {
    return 20;
  }
}
function gh() {
  let n, t;
  const e = new Promise((i, s) => {
    n = (r) => {
      e.state = ds.Resolved, i(r);
    }, t = (r) => {
      e.state = ds.Rejected, s(r);
    };
  });
  return e.state = ds.Pending, e.resolve = n, e.reject = t, e;
}
function os(n, t) {
  const e = new Promise((i, s) => {
    t.then(() => {
      e.isReady = !0, i(n);
    }, s);
  });
  return e.unsafeValue = n, e.readyPromise = t, e.isReady = !1, e;
}
class Hi {
  constructor() {
    this._faceMeshData = [], this._pointMeshData = [], this._polylineMeshData = [], this._faceWinding = yn.CounterClockwise, this._backfacesEnabled = !1, this._isManifold = !1;
  }
  /**
   * Adds face data to the mesh. Note that the arrays passed into this function are not copied and should remain unchanged until the mesh has been created.
   * When adding vertex data into the mesh using this method, it is important to note that the data is interpreted as triangles in which each vertex must be explicitly enumerated.
   * @param vertexData floating point data describing the points in space for the faces to be added to the mesh
   * @param normalData normals for the corresponding vertex data points.
   * @param rgba32data colors for the corresponding vertex data points (four bytes per rbga).
   * @param uvs texture parameters for the corresponding vertex data points.
   * @param bits bitmask associated with the face.
   */
  addFaces(t, e, i, s, r = 0) {
    this._faceMeshData.push(new kg(t, e, i, s, r));
  }
  /**
   * Adds point data to the mesh. Note that the arrays passed into this function are not copied and should remain unchanged until the mesh has been created.
   * @param pointData floating point data describing the points to be added to the mesh
   * @param rgba32data colors for the corresponding vertex data points (four bytes per rbga).
   * @param bits bitmask associated with the point.
   */
  addPoints(t, e, i = 0) {
    this._pointMeshData.push(new Wg(t, e, i));
  }
  /**
   * Adds polyline data to the mesh.Note that the arrays passed into this function are not copied and should remain unchanged until the mesh has been created.
   * @param polylineData floating point data describing the polyline to be added to the mesh
   * @param rgba32data colors for the corresponding vertex data points (four bytes per rbga).
   * @param bits bitmask associated with the line.
   */
  addPolyline(t, e, i = 0) {
    this._polylineMeshData.push(new Mg(t, e, i));
  }
  /**
   * Removes all data from the object.
   */
  clear() {
    this._faceMeshData.length = 0, this._pointMeshData.length = 0, this._polylineMeshData.length = 0;
  }
  /**
   * Sets the face winding to be used for this mesh. The default value is CounterClockwise.
   * @param faceWinding the face winding to use for mesh geometry.
   */
  setFaceWinding(t) {
    this._faceWinding = t;
  }
  /**
   * Gets the face winding used for this mesh.
   */
  getFaceWinding() {
    return this._faceWinding;
  }
  /**
   * Sets whether backfaces should be enabled for this geometry. The default value is false.
   * Setting this to true for geometry with a large amount of faces may affect performance.
   * @param backfacesEnabled indicated whether backfaces should be enabled for this geometry.
   */
  setBackfacesEnabled(t) {
    this._backfacesEnabled = t;
  }
  /**
   * Gets whether backfaces are enabled for this geometry
   * @returns value indicting whether backfaces are enabled for this geometry.
   */
  getBackfacesEnabled() {
    return this._backfacesEnabled;
  }
  /**
   * Sets whether the mesh is a manifold one or not (if the mesh is not set as manifold, then capping won't happen while cutting).
   * @param isManifold indicated whether or not it's a manifold mesh.
   */
  setManifold(t) {
    this._isManifold = t;
  }
  /**
   * Gets if the mesh is set as manifold.
   * @returns value indicating whether or not it's a manifold mesh.
   */
  isManifold() {
    return this._isManifold;
  }
  /** @hidden */
  _getFaceData() {
    return this._faceMeshData;
  }
  /** @hidden */
  _getPointData() {
    return this._pointMeshData;
  }
  /** @hidden */
  _getPolylineData() {
    return this._polylineMeshData;
  }
}
class bn {
  /**
   * Creates a new MeshInstanceData object.
   * @param meshId the [[MeshId]] of the mesh to instantiate
   * @param matrix a matrix that will be applied to this instance
   * @param instanceName a name that will be visible when querying the model hierarchy
   * @param faceColor the color for faces of this instance
   * @param lineColor the color for lines of this instance
   * @param pointColor the color for points of this instance
   * @param creationFlags additional options that can be used to alter the behavior of this instance
   */
  constructor(t, e, i, s, r, o, a) {
    this._meshId = null, this._matrix = null, this._faceColor = null, this._lineColor = null, this._pointColor = null, this._instanceName = null, this._faceOpacity = 1, this._lineOpacity = 1, this._pointOpacity = 1, this._creationFlags = St.None, this._overlayIndex = 0, t && (this._meshId = t.slice()), e && (this._matrix = e.copy()), i && (this._instanceName = i), s && (this._faceColor = s.copy()), r && (this._lineColor = r.copy()), o && (this._pointColor = o.copy()), a && (this._creationFlags = a);
  }
  /**
   * Creates a copy of this MeshInstanceData.
   * @returns Copy of this MeshInstanceData object.
   */
  copy() {
    const t = new bn(
      this.getMeshId(),
      this.getMatrix(),
      this.getInstanceName(),
      this.getFaceColor(),
      this.getLineColor(),
      this.getPointColor(),
      this.getCreationFlags()
    );
    return t.setPointOpacity(this.getOpacity()), t.setLineOpacity(this.getLineOpacity()), t.setOpacity(this.getOpacity()), t.setOverlayIndex(this.getOverlayIndex()), t;
  }
  /**
   * Resets all fields of this object.
   */
  clear() {
    this._meshId = null, this._matrix = null, this._faceColor = null, this._lineColor = null, this._pointColor = null, this._instanceName = null, this._faceOpacity = 1, this._lineOpacity = 1, this._pointOpacity = 1, this._creationFlags = St.None, this._overlayIndex = 0;
  }
  /**
   * Gets the [[MeshId]] of the mesh to use for this instance.
   * [[MeshId]]s are created with [[Model.createMesh]] or retrieved with [[Model.getMeshIds]].
   * @returns the mesh ID to use for this instance.
   */
  getMeshId() {
    return this._meshId !== null ? this._meshId.slice() : null;
  }
  /**
   * Sets the [[MeshId]] of the mesh to use for the instance.
   * [[MeshId]]s are created with [[Model.createMesh]] or retrieved with [[Model.getMeshIds]].
   * @param meshId the [[MeshId]] to use.
   */
  setMeshId(t) {
    this._meshId = t.slice();
  }
  /**
   * Gets the matrix to apply to this instance.
   * @returns the current matrix that will be applied to this instance upon creation.
   */
  getMatrix() {
    return this._matrix !== null ? this._matrix.copy() : null;
  }
  /**
   * Gets the mesh instance creation flags (SuppressCameraScale, DoNotExplode, DoNotLight...)
   * @returns the mesh instance creation flags (null if none set)
   */
  getCreationFlags() {
    return this._creationFlags;
  }
  /**
   * Sets the mesh instance creation flags (SuppressCameraScale, DoNotExplode, DoNotLight...)
   * @param flags creation flags
   */
  setCreationFlags(t) {
    this._creationFlags = t;
  }
  /**
   * Sets the matrix that will be applied to this instance.
   * @param matrix the matrix to apply.
   */
  setMatrix(t) {
    this._matrix = t.copy();
  }
  /**
   * Gets the name that will be applied to the instance.
   * @returns the instance name.
   */
  getInstanceName() {
    return this._instanceName;
  }
  /**
   * Sets the name that will be assigned to this instance. This name will be visible when querying the model hierarchy.
   * @param instanceName the name to assign to this instance.
   */
  setInstanceName(t) {
    this._instanceName = t;
  }
  /**
   * Sets the color for face elements in this instance.
   * @param faceColor the color to apply to face elements.
   */
  setFaceColor(t) {
    this._faceColor = t.copy();
  }
  /**
   * Gets the color for face elements in this instance.
   * @returns the color for face elements.
   */
  getFaceColor() {
    return this._faceColor !== null ? this._faceColor.copy() : null;
  }
  /**
   * Sets the color for line elements in this instance.
   * @param lineColor the color to apply to line elements.
   */
  setLineColor(t) {
    this._lineColor = t.copy();
  }
  /**
   * Gets the color for line elements in this instance.
   * @returns the color for line elements.
   */
  getLineColor() {
    return this._lineColor !== null ? this._lineColor.copy() : null;
  }
  /**
   * Sets the color for point elements in this instance.
   * @param pointColor the color to apply to point elements.
   */
  setPointColor(t) {
    this._pointColor = t.copy();
  }
  /**
   * Gets the color for point elements in this instance.
   * @returns the color for point elements.
   */
  getPointColor() {
    return this._pointColor !== null ? this._pointColor.copy() : null;
  }
  /**
   * Sets the point opacity for this instance.
   * @param pointOpacity opacity value to set.
   */
  setPointOpacity(t) {
    this._pointOpacity = t;
  }
  /**
   * Gets the point opacity value for this instance.
   * @returns the point opacity value for this instance.
   */
  getPointOpacity() {
    return this._pointOpacity;
  }
  /**
   * Sets the line opacity for this instance.
   * @param lineOpacity opacity value to set.
   */
  setLineOpacity(t) {
    this._lineOpacity = t;
  }
  /**
   * Gets the line opacity value for this instance.
   * @returns the line opacity value for this instance.
   */
  getLineOpacity() {
    return this._lineOpacity;
  }
  /**
   * Sets the face opacity for this instance.
   * @param faceOpacity opacity value to set.
   */
  setOpacity(t) {
    this._faceOpacity = t;
  }
  /**
   * Gets the face opacity value for this instance.
   * @returns the face opacity value for this instance.
   */
  getOpacity() {
    return this._faceOpacity;
  }
  /**
   * Sets the overlay index for this instance.
   * @param overlayIndex overlay index to set.
   */
  setOverlayIndex(t) {
    this._overlayIndex = t;
  }
  /**
   * Gets the overlay index for this instance.
   * @returns the overlay index for this instance.
   */
  getOverlayIndex() {
    return this._overlayIndex;
  }
}
class kg {
  constructor(t, e, i, s, r = 0) {
    this.vertexData = t, this.normalData = e, this.rgba32data = i, this.uvData = s, this.bits = r;
  }
}
class Mg {
  constructor(t, e, i = 0) {
    this.vertexData = t, this.rgba32data = e, this.bits = i;
  }
}
class Wg {
  constructor(t, e, i = 0) {
    this.vertexData = t, this.rgba32data = e, this.bits = i;
  }
}
function xd() {
  const n = (1 + Math.sqrt(5)) / 2, t = Math.sqrt(10 + 2 * Math.sqrt(5)) / (4 * n), e = t / 2, i = t / (2 * n), s = [];
  s[0] = new d(-i, e, 0), s[1] = new d(i, e, 0), s[2] = new d(-i, -e, 0), s[3] = new d(i, -e, 0), s[4] = new d(0, -i, e), s[5] = new d(0, i, e), s[6] = new d(0, -i, -e), s[7] = new d(0, i, -e), s[8] = new d(e, 0, -i), s[9] = new d(e, 0, i), s[10] = new d(-e, 0, -i), s[11] = new d(-e, 0, i);
  for (const u of s)
    u.normalize();
  let r = [
    [0, 11, 5],
    [0, 5, 1],
    [0, 1, 7],
    [0, 7, 10],
    [0, 10, 11],
    [1, 5, 9],
    [5, 11, 4],
    [11, 10, 2],
    [10, 7, 6],
    [7, 1, 8],
    [3, 9, 4],
    [3, 4, 2],
    [3, 2, 6],
    [3, 6, 8],
    [3, 8, 9],
    [4, 9, 5],
    [2, 4, 11],
    [6, 2, 10],
    [8, 6, 7],
    [9, 8, 1]
  ], o = 12;
  const a = 2;
  for (let u = 0; u < a; u++) {
    const p = [];
    r.map((m) => {
      const g = s[m[0]], _ = s[m[1]], y = s[m[2]];
      s[o++] = new d(g.x + _.x, g.y + _.y, g.z + _.z).scale(0.5).normalize(), s[o++] = new d(_.x + y.x, _.y + y.y, _.z + y.z).scale(0.5).normalize(), s[o++] = new d(y.x + g.x, y.y + g.y, y.z + g.z).scale(0.5).normalize(), p.push([m[0], o - 3, o - 1]), p.push([o - 3, o - 2, o - 1]), p.push([o - 3, m[1], o - 2]), p.push([o - 2, m[2], o - 1]);
    }), r = p;
  }
  const l = [], c = [];
  for (const u of r)
    for (let p = 0; p < 3; p++) {
      const m = u[p];
      l.push(s[m].x), l.push(s[m].y), l.push(s[m].z);
      const g = s[m].normalize();
      c.push(g.x), c.push(g.y), c.push(g.z);
    }
  const h = new Hi();
  return h.addFaces(l, c), h.setFaceWinding(yn.CounterClockwise), h;
}
function fh(n, t, e, i, s, r) {
  const o = new Q(), a = Gg(
    i,
    t,
    e + r,
    s,
    o
  ), l = Pg(n, t, e, o), c = Yg(
    n,
    i,
    t,
    e,
    r
  ), h = a[0].concat(l[0]).concat(c[0]), u = a[1].concat(l[1]).concat(c[1]), p = new Hi();
  return p.setFaceWinding(yn.Clockwise), p.addFaces(h, u), p;
}
function Zd(n) {
  const t = Math.PI * 2 / n, e = [];
  for (let i = 0; i < n; i++) {
    const s = i * t, r = Math.cos(s), o = Math.sin(s);
    e.push(r), e.push(o);
  }
  return e;
}
function Zs(n, t, e, i = 1) {
  let s = d.cross(e, new d(0, 1, 0));
  s.length() < 1e-3 && (s = d.cross(e, new d(0, 0, 1)));
  const r = d.cross(s, e), o = Math.PI * 2 / n, a = [];
  for (let l = 0; l < n; l++) {
    const c = l * o, h = Math.sin(c), u = Math.cos(c), p = s.copy().scale(h).add(r.copy().scale(u)).scale(i).add(t);
    a.push(p);
  }
  return a;
}
function Cd(n, t, e, i) {
  const o = [], a = [];
  let l;
  for (let v = 0; v < n.length - 3; v += 3) {
    const C = new d(n[v], n[v + 1], n[v + 2]), k = new d(n[v + 3], n[v + 4], n[v + 5]), Y = Zs(e, C, t, i), P = Zs(e, k, t, i);
    l = Ua(C, k, Y, P, !1), Array.prototype.push.apply(o, l[0]), Array.prototype.push.apply(a, l[1]);
  }
  const c = n.length;
  let h = new d(n[c - 3], n[c - 2], n[c - 1]), u = h.copy().subtract(new d(n[c - 6], n[c - 5], n[c - 4])).normalize(), p = Zs(
    e * 2,
    h,
    t,
    i
  ), m = h.copy().add(u.copy().scale(2 / 3)), g = Zs(
    e * 2,
    m,
    t,
    i * 2
  ), _ = m.copy().add(u.copy().scale(2));
  l = Ua(
    h,
    m,
    p,
    g,
    !1
  ), Array.prototype.push.apply(o, l[0]), Array.prototype.push.apply(a, l[1]);
  for (let v = 0; v < p.length; v++) {
    const C = (v + 1) % p.length;
    o.push(_), o.push(g[v]), o.push(g[C]);
    const k = g[v].copy().subtract(m).normalize().add(_.copy().normalize()).normalize();
    a.push(k), a.push(k), a.push(k);
  }
  h = new d(n[0], n[1], n[2]), u = h.copy().subtract(new d(n[3], n[4], n[5])).normalize(), p = Zs(
    e * 2,
    h,
    t,
    i
  ), m = h.copy().add(u.copy().scale(2 / 3)), g = Zs(
    e * 2,
    m,
    t,
    i * 2
  ), _ = m.copy().add(u.copy().scale(2)), l = Ua(
    m,
    h,
    g,
    p,
    !1
  ), Array.prototype.push.apply(o, l[0]), Array.prototype.push.apply(a, l[1]);
  for (let v = 0; v < p.length; v++) {
    const C = (v + 1) % p.length;
    o.push(_), o.push(g[C]), o.push(g[v]);
    const k = g[v].copy().subtract(m).normalize().add(_.copy().normalize()).normalize();
    a.push(k), a.push(k), a.push(k);
  }
  const y = [], b = [];
  for (let v = 0; v < o.length; v++) {
    const C = o[v];
    y.push(C.x), y.push(C.y), y.push(C.z);
    const k = a[v];
    b.push(k.x), b.push(k.y), b.push(k.z);
  }
  const w = new Hi();
  return w.setFaceWinding(yn.CounterClockwise), w.addFaces(y, b), w;
}
function Ua(n, t, e, i, s) {
  const r = [], o = [];
  for (let a = 0; a < e.length; a++) {
    const l = (a + 1) % e.length;
    r.push(e[a]), r.push(e[l]), r.push(i[a]), r.push(e[l]), r.push(i[l]), r.push(i[a]), o.push(d.subtract(e[a], n)), o.push(d.subtract(e[l], n)), o.push(d.subtract(i[a], t)), o.push(d.subtract(e[l], n)), o.push(d.subtract(i[l], t)), o.push(d.subtract(i[a], t));
  }
  if (s) {
    const a = d.subtract(n, t);
    for (const l of o)
      l.add(a).normalize();
  }
  return [r, o];
}
function Pg(n, t, e, i) {
  const s = [], r = [], o = Zd(t), a = o;
  for (let p = 0; p < a.length; p++)
    a[p] *= n;
  const l = [], c = [];
  for (let p = 0; p < a.length; p += 2) {
    const m = a[p], g = a[p + 1], _ = (p + 2) % a.length, y = a[_], b = a[_ + 1], w = o[p], v = o[p + 1], C = o[_], k = o[_ + 1];
    l[0] = new d(m, e, g), l[1] = new d(m, 0, g), l[2] = new d(y, 0, b), l[3] = new d(y, 0, b), l[4] = new d(y, e, b), l[5] = new d(m, e, g), c[0] = new d(w, 0, v), c[1] = new d(w, 0, v), c[2] = new d(C, 0, k), c[3] = new d(C, 0, k), c[4] = new d(C, 0, k), c[5] = new d(w, 0, v);
    for (let Y = 0; Y < l.length; Y++) {
      const P = i.transform(l[Y]);
      s.push(P);
      const L = i.transform(c[Y]);
      r.push(L);
    }
    l[0] = new d(y, 0, b), l[1] = new d(m, 0, g), l[2] = d.zero(), c[0] = new d(0, -1, 0), c[1] = new d(0, -1, 0), c[2] = new d(0, -1, 0);
    for (let Y = 0; Y < 3; Y++) {
      const P = i.transform(l[Y]);
      s.push(P);
      const L = i.transform(c[Y]);
      r.push(L);
    }
  }
  const h = [], u = [];
  for (let p = 0; p < s.length; p++) {
    const m = s[p];
    h.push(m.x), h.push(m.y), h.push(m.z);
    const g = r[p];
    u.push(g.x), u.push(g.y), u.push(g.z);
  }
  return [h, u];
}
function Gg(n, t, e, i, s) {
  const r = Zd(t), o = r;
  for (let _ = 0; _ < o.length; _++)
    o[_] *= n;
  const a = new d(0, e + i, 0), l = new d(0, e, 0), c = s.transform(a), h = s.transform(l), u = [], p = [];
  for (let _ = 0; _ < o.length; _ += 2) {
    const y = o[_], b = o[_ + 1], w = (_ + 2) % o.length, v = o[w], C = o[w + 1], k = r[_], Y = r[_ + 1], P = r[w], L = r[w + 1], R = new d(y, e, b), D = new d(v, e, C), J = s.transform(R), G = s.transform(D);
    u.push(c), u.push(J), u.push(G);
    const X = new d(0, 1, 0), Z = new d(k, 0, Y), W = new d(P, 0, L), st = s.transform(X), j = s.transform(Z), gt = s.transform(W);
    p.push(st), p.push(j), p.push(gt);
    const U = new d(y, e, b), ht = new d(v, e, C), z = s.transform(U), O = s.transform(ht);
    u.push(h), u.push(O), u.push(z);
    const _t = new d(0, -1, 0), rt = s.transform(_t);
    p.push(rt), p.push(rt), p.push(rt);
  }
  const m = [], g = [];
  for (let _ = 0; _ < u.length; _++) {
    const y = u[_];
    m.push(y.x), m.push(y.y), m.push(y.z);
    const b = p[_];
    g.push(b.x), g.push(b.y), g.push(b.z);
  }
  return [m, g];
}
function Yg(n, t, e, i, s) {
  const r = new d(0, 0, i), o = new d(0, 0, i + s), a = new d(0, 0, 1), l = Zs(e, r, a, n), c = Zs(e, o, a, t), h = Ua(r, o, l, c, !0), u = [], p = [];
  for (let m = 0; m < h[0].length; m++)
    u.push(h[0][m].x), u.push(h[0][m].z), u.push(h[0][m].y), p.push(h[1][m].x), p.push(h[1][m].z), p.push(h[1][m].y);
  return [u, p];
}
function Vg(n) {
}
function $n(n) {
  throw new re();
}
class Tg {
  constructor(t, e) {
    this._state = t, this._reducer = e;
  }
  /**
   * Handle an action and update the state
   *
   * @param evt The action to handle
   * @param payload The payload if any
   */
  handle(t, e) {
    this._state = this._reducer(this._state, { name: t, payload: e });
  }
}
function Ll(n) {
  return new Promise((t) => {
    setTimeout(t, n);
  });
}
function Eg(n, ...t) {
  return setTimeout(n, 0, ...t);
}
function Rg(n, t) {
  return n === t;
}
function Ng(n) {
  return n instanceof ma;
}
function Lg(n) {
  return n instanceof qr;
}
function Xg(n) {
  return n instanceof Es;
}
function Fg(n) {
  return n instanceof Re;
}
function Kg(n) {
  return n instanceof Ce || n instanceof Re || n instanceof cr || n instanceof hr || n instanceof ur || n instanceof ga || n instanceof fa || n instanceof _a || n instanceof ya || n instanceof ba || n instanceof Ia || n instanceof wa || n instanceof va || n instanceof Sa || n instanceof xa || n instanceof Za || n instanceof Ca || n instanceof pa;
}
class As {
  constructor() {
    this._timerId = null, this._action = null, this._beforeActionIdlePromise = null, this._afterActionIdlePromise = null;
  }
  /**
   * Returns true if no pending action exists and false otherwise.
   */
  isIdle(t) {
    return t === mi.BeforeAction ? this._timerId === null : this._action === null;
  }
  /**
   * Returns a promise that resolves when the timer becomes (or already is) idle.
   */
  waitForIdle(t) {
    return t === mi.BeforeAction ? this._timerId === null ? Promise.resolve() : (this._beforeActionIdlePromise === null && (this._beforeActionIdlePromise = be()), this._beforeActionIdlePromise) : this._action === null ? Promise.resolve() : (this._afterActionIdlePromise === null && (this._afterActionIdlePromise = be()), this._afterActionIdlePromise);
  }
  _triggerIdlePromise(t) {
    t === mi.BeforeAction ? this._beforeActionIdlePromise !== null && (this._beforeActionIdlePromise.resolve(), this._beforeActionIdlePromise = null) : this._afterActionIdlePromise !== null && (this._afterActionIdlePromise.resolve(), this._afterActionIdlePromise = null);
  }
  _clearTimeout() {
    this._timerId !== null && (clearTimeout(this._timerId), this._timerId = null);
  }
  /**
   * Clears the pending action if it exists.
   */
  clear() {
    this._clearTimeout(), this._triggerIdlePromise(mi.BeforeAction), this._action = null, this._triggerIdlePromise(mi.AfterAction);
  }
  /**
   * Sets a new delayed action. If one is already pending before this call is made, it gets cleared.
   * @param delay The delay in milliseconds to pend the action.
   * @param action The action to pend.
   */
  set(t, e) {
    this._clearTimeout(), this._action = e, this._timerId = setTimeout(() => {
      this._timerId = null, this._triggerIdlePromise(mi.BeforeAction);
      const i = this._afterActionIdlePromise;
      this._afterActionIdlePromise = null, this._action(), this._timerId === null && (this._action = null), i !== null && i.resolve();
    }, t);
  }
}
function Og() {
  const n = new As();
  n.set(0, () => {
    n.set(0, () => {
    }), n.waitForIdle(mi.AfterAction).then(() => {
      console.log("inner-1");
    }), n.clear(), n.waitForIdle(mi.AfterAction).then(() => {
      console.log("inner-2");
    }), n.set(0, () => {
    }), n.waitForIdle(mi.AfterAction).then(() => {
      console.log("inner-3");
    });
  }), n.waitForIdle(mi.AfterAction).then(() => {
    console.log("outer");
  });
}
const N0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ActionQueue: Po,
  CurrentAction: fs,
  Lazy: ji,
  StateMachine: Tg,
  Timer: As,
  TimerIdleType: mi,
  TypeAssert: Vg,
  TypeAssertNever: $n,
  _timerStressTest: Og,
  copyMap: Nl,
  copySet: fg,
  createCylinderMeshDataFromArc: Cd,
  createOpenPromise: be,
  createTrackedOpenPromise: gh,
  createUnsafePromise: os,
  delayCall: Eg,
  exchangeIdEqual: Rg,
  filterInPlace: Sg,
  generateConeCylinderMeshData: fh,
  generateSphereMeshData: xd,
  isCircleElement: Lg,
  isFace: Kg,
  isLineElement: Ng,
  isOtherEdgeElement: Xg,
  isPlaneElement: Fg,
  setSubtraction: Ic,
  setToArray: us,
  sleep: Ll,
  toSet: Wo,
  waitForAll: zt
}, Symbol.toStringTag, { value: "Module" }));
var ds = /* @__PURE__ */ ((n) => (n[n.Pending = 0] = "Pending", n[n.Resolved = 1] = "Resolved", n[n.Rejected = 2] = "Rejected", n))(ds || {}), Di = /* @__PURE__ */ ((n) => (n[n.Direct = 0] = "Direct", n[n.Indirect = 1] = "Indirect", n))(Di || {}), Qa = /* @__PURE__ */ ((n) => (n[n.X = 2] = "X", n[n.Y = 4] = "Y", n[n.Z = 8] = "Z", n))(Qa || {}), qa = /* @__PURE__ */ ((n) => (n[n.X = 16] = "X", n[n.Y = 32] = "Y", n[n.Z = 64] = "Z", n))(qa || {}), ho = /* @__PURE__ */ ((n) => (n[n.None = 0] = "None", n[n.EyeX_UpY = 34] = "EyeX_UpY", n[n.EyeX_UpZ = 66] = "EyeX_UpZ", n[n.EyeY_UpX = 20] = "EyeY_UpX", n[n.EyeY_UpZ = 68] = "EyeY_UpZ", n[n.EyeZ_UpX = 24] = "EyeZ_UpX", n[n.EyeZ_UpY = 40] = "EyeZ_UpY", n))(ho || {}), dn = /* @__PURE__ */ ((n) => (n[n.StemHeight = 2] = "StemHeight", n[n.CapHeight = 0.5] = "CapHeight", n[n.TaperHeight = 0.1] = "TaperHeight", n[n.SegmentCount = 20] = "SegmentCount", n[n.CylinderRadius = 0.2] = "CylinderRadius", n[n.ConeBaseRadius = 0.4] = "ConeBaseRadius", n[n.LetterOffsetPos = 0.6] = "LetterOffsetPos", n[n.LetterWidth = 0.3] = "LetterWidth", n[n.LetterHeight = 0.5] = "LetterHeight", n))(dn || {}), ki = /* @__PURE__ */ ((n) => (n[n.None = 0] = "None", n[n.Position = 1] = "Position", n[n.Target = 2] = "Target", n[n.Up = 4] = "Up", n[n.Width = 8] = "Width", n[n.Height = 16] = "Height", n[n.Projection = 32] = "Projection", n[n.NearLimit = 64] = "NearLimit", n))(ki || {}), wl = /* @__PURE__ */ ((n) => (n[n.Attachment = 0] = "Attachment", n[n.Model = 1] = "Model", n))(wl || {}), vl = /* @__PURE__ */ ((n) => (n[n.AllKeys = 0] = "AllKeys", n[n.KeyCountOnly = 1] = "KeyCountOnly", n))(vl || {}), uo = /* @__PURE__ */ ((n) => (n[n.Add = 0] = "Add", n[n.Update = 1] = "Update", n))(uo || {}), mo = /* @__PURE__ */ ((n) => (n[n.MetaData = 0] = "MetaData", n[n.Count = 1] = "Count", n))(mo || {}), kd = /* @__PURE__ */ ((n) => (n[n.SelectionBitsFaceHasMeasurementData = 1] = "SelectionBitsFaceHasMeasurementData", n[n.SelectionBitsFacePlanar = 2] = "SelectionBitsFacePlanar", n[n.SelectionBitsEdgeHasMeasurementData = 4] = "SelectionBitsEdgeHasMeasurementData", n))(kd || {}), $a = /* @__PURE__ */ ((n) => (n[n.Outside = 0] = "Outside", n[n.PartiallyInside = 1] = "PartiallyInside", n[n.FullyInside = 2] = "FullyInside", n))($a || {}), Md = /* @__PURE__ */ ((n) => (n[n.Unsent = 0] = "Unsent", n[n.Opened = 1] = "Opened", n[n.HeadersRecieved = 2] = "HeadersRecieved", n[n.Loading = 3] = "Loading", n[n.Done = 4] = "Done", n))(Md || {}), Wd = /* @__PURE__ */ ((n) => (n[n.Ok = 200] = "Ok", n))(Wd || {});
class ci {
  constructor() {
    this._position = new d(0, 0, 1), this._target = d.zero(), this._up = new d(0, 1, 0), this._width = 0, this._height = 0, this._projection = te.Orthographic, this._nearLimit = 0.01, this._cameraFlags = ki.None;
  }
  /** @hidden */
  _clearFlags() {
    this._cameraFlags = ki.None;
  }
  /** @hidden */
  _getFlags() {
    return this._cameraFlags;
  }
  /**
   * Creates a copy of the camera.
   * @returns new object initialized with the current values of this camera
   */
  copy() {
    return ci.create(
      this._position,
      this._target,
      this._up,
      this._projection,
      this._width,
      this._height,
      this._nearLimit
    );
  }
  /**
   * Sets the camera position
   * @param position the new camera position
   */
  setPosition(t) {
    this._position.assign(t), this._cameraFlags |= ki.Position;
  }
  /**
   * gets the camera position
   * @returns the camera position
   */
  getPosition() {
    return this._position.copy();
  }
  /**
   * Sets the camera target
   * @param target the new camera target
   */
  setTarget(t) {
    this._target.assign(t), this._cameraFlags |= ki.Target;
  }
  /**
   * gets the camera target
   * @returns the camera target
   */
  getTarget() {
    return this._target.copy();
  }
  /**
   * Sets the camera up vector
   * @param up the new camera up vector
   */
  setUp(t) {
    this._up.assign(t), this._cameraFlags |= ki.Up;
  }
  /**
   * gets the camera up vector
   * @returns the camera up vector
   */
  getUp() {
    return this._up.copy();
  }
  /**
   * Sets the camera width
   * @param width the new camera width
   */
  setWidth(t) {
    this._width = t, this._cameraFlags |= ki.Width;
  }
  /**
   * gets the camera width
   * @returns the camera width
   */
  getWidth() {
    return this._width;
  }
  /**
   * Sets the camera height
   * @param height the new camera height
   */
  setHeight(t) {
    this._height = t, this._cameraFlags |= ki.Height;
  }
  /**
   * gets the camera height
   * @returns the camera width
   */
  getHeight() {
    return this._height;
  }
  /**
   * Sets the camera projection
   * @param projection the new camera Projection
   */
  setProjection(t) {
    this._projection = t, this._cameraFlags |= ki.Projection;
  }
  /**
   * gets the camera projection
   * @returns the camera projection
   */
  getProjection() {
    return this._projection;
  }
  /**
   * Sets the camera near clipping limit
   * @param nearLimit the new camera near clipping limit
   */
  setNearLimit(t) {
    this._nearLimit = t, this._cameraFlags |= ki.NearLimit;
  }
  /**
   * gets the camera near clipping limit
   * @returns the camera near clipping limit
   */
  getNearLimit() {
    return this._nearLimit;
  }
  /**
   * Returns checks for equality with another camera
   * @param cam the camera to compare against
   */
  equals(t) {
    return this._position.equals(t._position) && this._target.equals(t._target) && this._up.equals(t._up) && this._width === t._width && this._height === t._height && this._projection === t._projection && this._nearLimit === t._nearLimit;
  }
  /**
   * Returns checks for equality with another camera with tolerance
   * @param cam the camera to compare against
   * @param tolerance floating point tolerance
   */
  equalsWithTolerance(t, e) {
    const i = (s, r) => Math.abs(s - r) < e;
    return this._position.equalsWithTolerance(t._position, e) && this._target.equalsWithTolerance(t._target, e) && this._up.equalsWithTolerance(t._up, e) && i(this._width, t._width) && i(this._height, t._height) && i(this._projection, t._projection) && i(this._nearLimit, t._nearLimit);
  }
  /**
   * Move the camera along a delta
   * @param delta
   */
  dolly(t) {
    this._position.subtract(t), this._target.subtract(t);
  }
  /**
   * Finds the intersection point with the camera plane
   * @param point
   * @param view
   */
  getCameraPlaneIntersectionPoint(t, e) {
    const i = d.subtract(this._position, this._target).normalize(), s = je.createFromPointAndNormal(this._target, i), r = e.raycastFromPoint(t);
    if (r === null)
      return null;
    const o = d.zero();
    return s.intersectsRay(r, o) ? o : null;
  }
  /**
   * Returns the camera's view matrix. This matrix places the camera at
   * `<0,0,0>`, with the negative z-axis pointing toward the camera's
   * target and the y-axis in the direction of the camera's up-vector.
   * @param viewer The [[WebViewer]] for which the matrix should be valid.
   */
  getViewMatrix(t) {
    return t._getScEngine().getViewMatrix(this);
  }
  /**
   * Returns the camera's projection matrix.
   * @param viewer The [[WebViewer]] for which the matrix should be valid.
   */
  getProjectionMatrix(t) {
    return t._getScEngine().getProjectionMatrix(this);
  }
  /**
   * Returns the camera's projection matrix multiplied by its view matrix.
   * @param viewer The [[WebViewer]] for which the matrix should be valid.
   */
  getFullMatrix(t) {
    return t._getScEngine().getFullCameraMatrix(this);
  }
  /**
   * Creates a new camera object with the given parameters.
   * @param pos the camera position.
   * @param tar the camera target.
   * @param up the camera up vector.
   * @param projection the camera projection mode.
   * @param width camea view width.
   * @param height camera view height.
   * @param nearLimit the camera near limit.
   * @returns a new camera object.
   */
  static create(t, e, i, s, r, o, a) {
    const l = new ci();
    return l._position.assign(t), l._target.assign(e), l._up.assign(i), l._projection = s, l._width = r, l._height = o, a !== void 0 && (l._nearLimit = a), l;
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      position: this._position.toJson(),
      target: this._target.toJson(),
      up: this._up.toJson(),
      width: this._width,
      height: this._height,
      projection: this._projection,
      nearLimit: this._nearLimit,
      className: "Communicator.Camera"
    };
  }
  /**
   * Creates a new [[Camera]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t) {
    const e = t, i = d.fromJson(e.position), s = d.fromJson(e.target), r = d.fromJson(e.up);
    return ci.create(
      i,
      s,
      r,
      e.projection,
      e.width,
      e.height,
      e.nearLimit
    );
  }
  transform(t) {
    if (t.isIdentity())
      return this.copy();
    const e = Math.abs(this._width), i = Math.abs(this._height), s = this.getUp().normalize().scale(i), r = d.subtract(this._position, this._target), o = d.cross(s, r).normalize().scale(e), a = this.getTarget(), l = d.add(a, o), c = d.add(a, s), h = d.add(a, r);
    t.transform(a, a), t.transform(l, l), t.transform(c, c), t.transform(h, h);
    const u = d.subtract(l, a), p = d.subtract(c, a), m = d.subtract(h, a), g = d.add(a, m), _ = a, y = p.copy().normalize();
    let b = u.length(), w = p.length();
    return this._width < 0 && (b = -b), this._height < 0 && (w = -w), ci.create(
      g,
      _,
      y,
      this._projection,
      b,
      w,
      this._nearLimit
    );
  }
}
function Ag(n) {
  if (typeof window < "u" && n.length < 8192 && "escape" in window) {
    let a;
    try {
      const l = new TextDecoder().decode(n), c = window.escape(l);
      a = decodeURIComponent(c);
    } catch {
      a = "";
    }
    return a;
  }
  let t, e, i, s, r;
  t = "";
  const o = n.length;
  for (e = 0; e < o; )
    switch (i = n[e++], i >> 4) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
        t += String.fromCharCode(i);
        break;
      case 12:
      case 13:
        s = n[e++], t += String.fromCharCode((i & 31) << 6 | s & 63);
        break;
      case 14:
        s = n[e++], r = n[e++], t += String.fromCharCode(
          (i & 15) << 12 | (s & 63) << 6 | (r & 63) << 0
        );
        break;
    }
  return t;
}
const Dg = /^\d+$/;
function Pd(n) {
  return Dg.test(n);
}
const Xa = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz`~!@#$%^&*()_+-=[]{};:'\",.<>\\|/?".split(
  ""
);
function nc(n) {
  if (console.assert(n >= 0), n === 0)
    return Xa[0];
  const t = [];
  for (; n !== 0; ) {
    const e = Math.floor(n / Xa.length), i = n % Xa.length, s = Xa[i];
    t.push(s), n = e;
  }
  return t.join("");
}
const zg = ["0000000", "000000", "00000", "0000", "000", "00", "0", ""];
function Bg(n) {
  const t = n.toString(16);
  return zg[t.length - 1] + t;
}
class _e {
  static _parseUint_32(t) {
    if (!Pd(t))
      return null;
    const e = parseInt(t, 10);
    return e <= 4294967295 ? e : null;
  }
  static _parseFloat(t) {
    const e = parseFloat(t);
    return isNaN(e) ? null : e;
  }
  static parseFloat(t, e) {
    const i = t.getAttribute(e);
    return i === null ? null : this._parseFloat(i);
  }
  static _parseScKey(t, e) {
    const i = t.getAttribute(e);
    return i === null ? null : this._parseUint_32(i);
  }
  static parseDataKey(t, e) {
    return this._parseScKey(t, e);
  }
  static parseMeshKey(t, e) {
    return this._parseScKey(t, e);
  }
  static parseInstanceKeyFromInc(t, e) {
    const i = t.getAttribute(e);
    if (i === null)
      return null;
    const s = i.split(" ");
    return s.length !== 2 || this._parseUint_32(s[0]) === null ? null : this._parseUint_32(s[1]);
  }
  static parseNodeId(t, e) {
    const i = t.getAttribute(e);
    return i === null ? null : this._parseUint_32(i);
  }
  static parseLayerId(t, e) {
    const i = t.getAttribute(e);
    return i === null ? null : this._parseUint_32(i);
  }
  static parseUint(t, e) {
    const i = t.getAttribute(e);
    return i === null ? null : this._parseUint_32(i);
  }
  static parseUints(t, e) {
    const i = t.getAttribute(e);
    if (i === null)
      return null;
    const s = [], r = i.match(/[0-9]+/g) || [];
    for (const o of r) {
      const a = this._parseUint_32(o);
      if (a === null)
        return null;
      s.push(a);
    }
    return s;
  }
  static parseFloats(t, e) {
    const i = t.getAttribute(e);
    if (i === null)
      return null;
    const s = [], r = i.match(/\S+/g) || [];
    for (const o of r) {
      const a = this._parseFloat(o);
      if (a === null)
        return null;
      s.push(a);
    }
    return s;
  }
  static parseNodeIds(t, e) {
    return this.parseUints(t, e);
  }
  static _parsePoint3(t, e) {
    const i = t.getAttribute(e);
    if (i === null)
      return null;
    const s = i.split(" ");
    if (s.length !== 3)
      return null;
    const r = [];
    for (const o of s) {
      const a = Number(o);
      if (isNaN(a))
        return null;
      r.push(a);
    }
    return new d(r[0], r[1], r[2]);
  }
  static parseBounding(t, e) {
    const i = t.getElementsByTagName(e);
    if (i.length !== 1)
      return null;
    const s = i[0], r = this._parsePoint3(s, "Min");
    if (r === null)
      return null;
    const o = this._parsePoint3(s, "Max");
    return o === null ? null : new ni(r, o);
  }
  static parseCamera(t) {
    const e = _e.parseUint(t, "Projection");
    if (e === null)
      return null;
    const i = t.getAttribute("field");
    if (i === null)
      return null;
    const s = i.split(" ");
    if (s.length !== 2)
      return null;
    const r = parseFloat(s[0]), o = parseFloat(s[1]), a = t.getAttribute("definition");
    if (a === null)
      return null;
    const l = a.split(" ");
    if (l.length !== 9)
      return null;
    const c = (m, g) => new d(
      parseFloat(m[g]),
      parseFloat(m[g + 1]),
      parseFloat(m[g + 2])
    ), h = c(l, 0), u = c(l, 3), p = c(l, 6);
    return ci.create(h, u, p, e, r, o);
  }
}
class Oo {
  constructor() {
    this.isInclusive = !1, this.ids = [];
  }
  static parseBinary(t) {
    const e = new Oo();
    e.isInclusive = t.parseBoolean();
    const i = t.parseCount_32();
    for (let s = 0; s < i; s++)
      e.ids.push(t.parseNodeId());
    return e;
  }
  static parseXml(t) {
    const e = new Oo();
    e.isInclusive = t.getAttribute("Inclusive") === "1";
    const i = _e.parseNodeIds(t, "Ids");
    if (i !== null) {
      e.ids = i;
      const s = t.getAttribute("Count");
      if (s !== null) {
        const r = parseInt(s, 10);
        console.assert(r === e.ids.length);
      }
    } else
      console.error("'Entities' tag has missing or malformed 'Ids' attribute");
    return e;
  }
}
class Ao {
  constructor() {
    this.isInclusive = !1, this.authoredIds = [];
  }
  static parseBinary(t) {
    const e = new Ao();
    e.isInclusive = t.parseBoolean();
    const i = t.parseCount_32();
    for (let s = 0; s < i; s++)
      e.authoredIds.push(t.parseLayerId());
    return e;
  }
  static parseXml(t) {
    const e = new Ao();
    e.isInclusive = t.getAttribute("Inclusive") === "1";
    const i = _e.parseUints(t, "Ids");
    if (i !== null) {
      e.authoredIds = i;
      const s = t.getAttribute("Count");
      if (s !== null) {
        const r = parseInt(s, 10);
        console.assert(r === e.authoredIds.length);
      }
    } else
      console.error("'Layers' tag has missing or malformed 'Ids' attribute");
    return e;
  }
}
class Do {
  constructor() {
    this.isDisplayfilter = !1, this.name = null, this.isActive = !1, this.layers = null, this.entities = null;
  }
  static parseBinary(t) {
    const e = new Do();
    let i = null, s = null;
    const r = t.parseLayerParseBits();
    return e.isDisplayfilter = t.parseBoolean(), Ct(r, ja.Name) && (e.name = t.parseCString()), e.isActive = t.parseBoolean(), Ct(r, ja.LayerItem) && (i = Ao.parseBinary(t)), Ct(r, ja.EntityItem) && (s = Oo.parseBinary(t)), e.layers = i, e.entities = s, e;
  }
  static parseXml(t) {
    const e = new Do(), i = t.getAttribute("Name");
    i !== null && (e.name = i), e.isDisplayfilter = t.getAttribute("Display") === "1", e.isActive = t.getAttribute("Active") === "1";
    for (let s = t.firstElementChild; s !== null; s = s.nextElementSibling)
      s.localName === "Layers" ? (console.assert(e.layers === null), e.layers = Ao.parseXml(s)) : s.localName === "Entities" ? (console.assert(e.entities === null), e.entities = Oo.parseXml(s)) : console.error(`Unknown tag: ${t.localName}`);
    return e;
  }
}
var Gs = /* @__PURE__ */ ((n) => (n[n.Undefined = 0] = "Undefined", n[n.Unconnected = 1] = "Unconnected", n[n.Connected = 2] = "Connected", n))(Gs || {});
class _h {
  constructor() {
    this.relationships = [];
  }
  static parseBinary(t, e) {
    const i = new _h(), s = e.parseCount_32();
    for (let r = 0; r < s; r++) {
      let o = Gs.Undefined;
      const a = e.parseCString(), l = e.parseCString();
      e.parseBoolean() ? (o = Gs.Connected, dr.registerBimId(a, t)) : o = Gs.Unconnected, i.relationships.push({
        category: o,
        id: a,
        name: l
      });
    }
    return i;
  }
}
class Sl {
  constructor() {
    this.relationElt = {
      id: "",
      name: "",
      category: Gs.Undefined
    };
  }
  static parseBinary(t, e) {
    const i = new Sl();
    return i.relationElt.id = e.parseCString(), i.relationElt.name = e.parseCString(), e.parseBoolean() ? (i.relationElt.category = Gs.Connected, dr.registerBimId(i.relationElt.id, t)) : i.relationElt.category = Gs.Unconnected, i;
  }
  //TODO with the writer
  static parseXml(t) {
    return new Sl();
  }
}
class dr {
  constructor() {
    this.type = qd.Undefined, this.related = null, this.relating = null;
  }
  static registerBimId(t, e) {
    const i = e.toRuntimeId(parseInt(t, 10));
    i !== null && e.addBimIdToMap(t, i);
  }
  static parseBinary(t, e) {
    const i = new dr(), s = e.parseRelationshipParseBits();
    return Ct(s, Ha.Type) && (i.type = e.parseCount_32()), Ct(s, Ha.Relating) && (i.relating = Sl.parseBinary(t, e)), Ct(s, Ha.Related) && (i.related = _h.parseBinary(t, e)), i;
  }
  //TODO with the writer
  static parseXml(t) {
    const e = new dr(), i = t.getAttribute("Type");
    return i !== null && (e.type = Number(i)), e;
  }
}
class Wn {
  static parseBinary(t) {
    let e = null;
    const i = t.getHeader();
    let s = 0;
    i !== null && i.supportsAttributeBits() && (s = t.parseAttributeParseBits());
    const r = t.parseCString();
    Ct(s, wc.ValueName) && (e = t.parseCString());
    const o = t.parseAttributeType(), a = t.parseCString();
    let l = [];
    return Ct(s, wc.Units) && (l = t.parseUnits()), new Wn(o, r, e, a, l);
  }
  static parseXml(t) {
    console.assert(t.localName === "Attr");
    let e = Jn.Undefined, i = "", s = "";
    const r = [], o = t.getAttribute("ValueName"), a = t.getAttribute("Name");
    if (a !== null && (i = a, i === "__PRC_RESERVED_ATTRIBUTE_A3DF_ProductInformation"))
      return new Wn(e, i, o, s, r);
    const l = t.getAttribute("Type");
    if (l !== null)
      switch (l) {
        case "i":
          e = Jn.Int;
          break;
        case "f":
          e = Jn.Float;
          break;
        case "t":
          e = Jn.Time;
          break;
        case "s":
          e = Jn.String;
          break;
      }
    const c = t.getAttribute("Value");
    return c !== null && (s = c), new Wn(e, i, o, s, r);
  }
  constructor(t, e, i, s, r) {
    this._type = t, this._valueName = i, this._title = e, this._value = s, this._unit = r;
  }
  getType() {
    return this._type;
  }
  getValueName() {
    return this._valueName;
  }
  getTitle() {
    return this._title;
  }
  getValue() {
    return this._value;
  }
  getUnit() {
    return lg(this._unit);
  }
  copy() {
    let t = null;
    return this._valueName !== null && (t = this._valueName.slice()), new Wn(
      this._type,
      this._title.slice(),
      t,
      this._value.slice(),
      this._unit.slice()
    );
  }
}
let Xi = class Gd {
  static parseBinary(t) {
    return t.parseMatrix();
  }
  static parseXml(t) {
    console.assert(t.localName === "Transformation");
    const e = [], i = t.getAttribute("RelativeTransfo");
    if (i !== null) {
      const s = i.split(" ");
      console.assert(s.length === 16);
      for (let r = 0; r < 16; ++r) {
        const o = parseFloat(s[r]);
        console.assert(!isNaN(o)), e.push(o);
      }
    }
    return e;
  }
  static getIdentity() {
    return [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
  }
  static copy(t) {
    return t.slice();
  }
  static isIdentity(t) {
    return t[0] === 1 && t[1] === 0 && t[2] === 0 && t[3] === 0 && t[4] === 0 && t[5] === 1 && t[6] === 0 && t[7] === 0 && t[8] === 0 && t[9] === 0 && t[10] === 1 && t[11] === 0 && t[12] === 0 && t[13] === 0 && t[14] === 0 && t[15] === 1;
  }
  static multiply(t, e) {
    const i = Gd.getIdentity();
    return i[0] = t[0] * e[0] + t[1] * e[4] + t[2] * e[8] + t[3] * e[12], i[1] = t[0] * e[1] + t[1] * e[5] + t[2] * e[9] + t[3] * e[13], i[2] = t[0] * e[2] + t[1] * e[6] + t[2] * e[10] + t[3] * e[14], i[3] = t[0] * e[3] + t[1] * e[7] + t[2] * e[11] + t[3] * e[15], i[4] = t[4] * e[0] + t[5] * e[4] + t[6] * e[8] + t[7] * e[12], i[5] = t[4] * e[1] + t[5] * e[5] + t[6] * e[9] + t[7] * e[13], i[6] = t[4] * e[2] + t[5] * e[6] + t[6] * e[10] + t[7] * e[14], i[7] = t[4] * e[3] + t[5] * e[7] + t[6] * e[11] + t[7] * e[15], i[8] = t[8] * e[0] + t[9] * e[4] + t[10] * e[8] + t[11] * e[12], i[9] = t[8] * e[1] + t[9] * e[5] + t[10] * e[9] + t[11] * e[13], i[10] = t[8] * e[2] + t[9] * e[6] + t[10] * e[10] + t[11] * e[14], i[11] = t[8] * e[3] + t[9] * e[7] + t[10] * e[11] + t[11] * e[15], i[12] = t[12] * e[0] + t[13] * e[4] + t[14] * e[8] + t[15] * e[12], i[13] = t[12] * e[1] + t[13] * e[5] + t[14] * e[9] + t[15] * e[13], i[14] = t[12] * e[2] + t[13] * e[6] + t[14] * e[10] + t[15] * e[14], i[15] = t[12] * e[3] + t[13] * e[7] + t[14] * e[11] + t[15] * e[15], i;
  }
  constructor() {
  }
};
const ru = We.InitiallyShown;
let Rs = class {
  /**
   * Parses the `NodeInfo` for a node without inserting it into the tree.
   */
  static parseXml(t, e, i) {
    let s = _e.parseNodeId(e, "Id");
    s === null && (console.assert(!1), s = t.generateDynamicNodeId());
    const r = e.getAttribute("Name");
    let o = null;
    const a = [];
    let l = e.firstElementChild;
    for (; l !== null; ) {
      if (l.localName === "Transformation")
        console.assert(o === null), o = Xi.parseXml(l), Xi.isIdentity(o) && (o = null);
      else if (l.localName === "Attributes") {
        let u = l.firstElementChild;
        for (; u !== null; ) {
          console.assert(u.localName === "Attr");
          const p = Wn.parseXml(u);
          a.push(p), u = u.nextElementSibling;
        }
      }
      l = l.nextElementSibling;
    }
    const c = e.getAttribute("ExchangeId"), h = i.ignoreLayers ? null : _e.parseLayerId(e, "LayerId");
    return {
      nodeId: s,
      bits: ru,
      name: r,
      localTransform: o,
      attributes: a,
      header: _n.dynamic,
      exchangeId: c,
      layerId: h,
      genericTypeId: null,
      genericId: null,
      userDatas: null
    };
  }
  /**
   * Parses the `NodeInfo` for a node without inserting it into the tree.
   */
  static parseBinary(t, e, i, s) {
    let r;
    i.hasBits1(Qt.Id) ? r = e.parseNodeId() : (console.assert(!1), r = t.generateDynamicNodeId());
    const o = i.hasBits1(Qt.Name) ? e.parseCString() : null;
    let a = ru;
    if (i.hasBits1(Qt.Visiblity)) {
      const _ = e.parseVisibility();
      _.shown || (a &= ~We.InitiallyShown), _.removed && (a |= We.InitiallyRemoved);
    }
    let l = null;
    i.hasBits1(Qt.Transform) && (l = Xi.parseBinary(e), Xi.isIdentity(l) && (l = null));
    let c = null;
    i.hasBits1(Qt.Attributes) && (c = e.parseDataKey());
    const h = i.hasBits1(Qt.ExchangeId) ? e.parseCString() : null;
    let u = null;
    if (i.hasBits1(Qt.LayerId)) {
      const _ = e.parseLayerId();
      s.ignoreLayers || (u = _);
    }
    let p = null;
    if (i.hasBits2(Un.GenericTypeId)) {
      const _ = e.parseGenericTypeId();
      s.ignoreGenericTypes || (p = _);
    }
    let m = null;
    i.hasBits2(Un.GenericId) && (m = e.parseGenericId());
    let g = null;
    if (i.hasBits1(Qt.UserData)) {
      g = /* @__PURE__ */ new Map();
      const _ = e.parseCount_32();
      for (let y = 0; y < _; ++y) {
        const b = e.parseUserDataIndex(), w = e.parseCount_32(), v = e.parseBytes(w);
        g.set(b, v);
      }
    }
    return {
      nodeId: r,
      bits: a,
      name: o,
      localTransform: l,
      attributes: c !== null ? c : [],
      header: e.getHeader(),
      exchangeId: h,
      layerId: u,
      genericTypeId: p,
      genericId: m,
      userDatas: g
    };
  }
  constructor() {
    console.assert(!1);
  }
};
function Jg(n, t) {
  const e = typeof n == "number";
  return e === (typeof t == "number") ? n < t ? -1 : n > t ? 1 : 0 : e ? -1 : 1;
}
class Ws {
  /**
   * Creates a new lazy value, which is the result of the supplied function
   * once the lazy value is forced (or the value itself if a `T` is directly supplied).
   */
  static create(t) {
    return new Ws(t);
  }
  constructor(t) {
    this._value = t;
  }
  /**
   * Forces the lazy value given at construction and returns it.
   */
  get() {
    return typeof this._value == "function" && (this._value = this._value()), this._value;
  }
}
class Si {
  /**
   * Creates a new lazy value, which is the result of the supplied function
   * once the lazy value is forced (or the value itself if a `T` is directly supplied).
   */
  static create(t) {
    return new Si(t);
  }
  constructor(t) {
    typeof t == "function" && (t = Ws.create(t)), t instanceof Promise && (t = this._rectifyResult(t)), this._value = t;
  }
  /**
   * Returns whether or not this has been both forced (lazy).
   * This says nothing about resolution (promise).
   */
  isUnforced() {
    return this._value instanceof Ws;
  }
  /**
   * Returns whether or not this has been both forced (lazy) and resolved (promise).
   */
  isResolved() {
    return !(this._value instanceof Ws) && !(this._value instanceof Promise);
  }
  /**
   * Returns the final promised value synchronously.
   *
   * This is only legal to call if `isResolved()` returns `true`.
   *
   */
  getResolved() {
    return console.assert(this.isResolved()), this._value;
  }
  /**
   * Forces the lazy promise and then delegates to the forced promise's `then()` method.
   *
   * Note: This intentionally returns a normal `Promise`, not a `LazyPromise`.
   */
  then(t, e) {
    return this._value instanceof Ws && (this._value = this._rectifyResult(this._value.get())), this._value instanceof Promise ? this._value.then(t, e) : (this._value, Promise.resolve(this._value).then(t, e));
  }
  _rectifyResult(t) {
    return t instanceof Promise ? t.then((e) => (this._value = e, e)) : t;
  }
}
function jg(n) {
  return n == null;
}
function se(n) {
  return Array.isArray(n) ? n.slice() : n == null ? [] : [n];
}
function zi(n) {
  return n.length === 0 ? null : n.length === 1 ? n[0] : n;
}
function Mi(n, t) {
  return n ? Array.isArray(n) ? (n.push(t), n) : [n, t] : t;
}
class Pi {
  constructor(t, e, i) {
    if (this._bits = 0, this._nodeId = i.nodeId, this._bits = i.bits, i.name !== null && (this._name = i.name), i.localTransform !== null && (this._localTransform = Xi.copy(i.localTransform)), typeof i.attributes == "number") {
      const s = i.attributes;
      this._lazyAttributes = Pi._lazyLoadAttributes(
        t,
        e,
        s,
        i.header
      );
    } else
      i.attributes.length > 0 && (this._lazyAttributes = Si.create(i.attributes));
    i.exchangeId !== null && (this._exchangeId = i.exchangeId), i.layerId !== null && (this._layerId = i.layerId), i.genericTypeId !== null && (this._genericTypeId = i.genericTypeId), i.genericId !== null && (this._genericId = i.genericId), i.userDatas !== null && (this._userDatas = Nl(i.userDatas));
  }
  static _lazyLoadAttributes(t, e, i, s) {
    return Si.create(async () => {
      const r = t.getAbstractScEngine(), o = await t.enqueue(() => r.safeGetMetaData(e, i)), a = [];
      if (o !== null) {
        const l = new rr(s, o), c = new jo(l);
        for (; c.hasNext(); ) {
          const h = Wn.parseBinary(c);
          a.push(h);
        }
      }
      return a;
    });
  }
  hasAuthoredId() {
    return Qr(this._nodeId);
  }
  getAuthoredId() {
    return vg(this._nodeId);
  }
  getName() {
    return this._name !== void 0 ? this._name : null;
  }
  getExchangeId() {
    return this._exchangeId ?? null;
  }
  getAuthoredLayerId() {
    return this._layerId !== void 0 ? this._layerId : null;
  }
  getGenericTypeId() {
    return this._genericTypeId !== void 0 ? this._genericTypeId : null;
  }
  getGenericId() {
    return this._genericId !== void 0 ? this._genericId : null;
  }
  _hasBits(t) {
    return Ct(this._bits, t);
  }
  isLoaded() {
    return this._hasBits(We.IsLoaded);
  }
  markLoaded() {
    this._bits |= We.IsLoaded;
  }
  _setVisibility(t) {
    this._bits |= We.IsShownSpecified, t ? this._bits |= We.IsShown : this._bits &= ~We.IsShown;
  }
  isVisible() {
    return this._hasBits(We.IsShownSpecified) ? this._hasBits(We.IsShown) : this.isInitiallyShown();
  }
  isInitiallyShown() {
    return this._hasBits(We.InitiallyRemoved) ? !1 : this._hasBits(We.InitiallyShown);
  }
  _toAffineTransformation(t) {
    const e = t.slice();
    return e[3] = 0, e[7] = 0, e[11] = 0, e[15] = 1, e;
  }
  setLocalTransformAsInitial(t) {
    this._localTransform = this._toAffineTransformation(t);
  }
  overrideLocalTransform(t) {
    this._localTransformOverride = this._toAffineTransformation(t);
  }
  hasLocalTransformOverride() {
    return this._localTransformOverride !== void 0;
  }
  removeLocalTransformOverride() {
    console.assert(this._localTransformOverride !== void 0), delete this._localTransformOverride;
  }
  getLocalTransform() {
    return this._localTransformOverride !== void 0 ? this._localTransformOverride : this._localTransform !== void 0 ? this._localTransform : null;
  }
  async getAttributes() {
    return this._lazyAttributes !== void 0 ? this._lazyAttributes.then((t) => {
      if (this._lazyAttributes !== void 0) {
        for (const e of t)
          this.addAttribute(e);
        delete this._lazyAttributes;
      }
      return this.getAttributes();
    }) : se(this._attributes);
  }
  addAttribute(t) {
    this._attributes = Mi(this._attributes, t);
  }
  getUserDataIndices() {
    const t = [];
    return this._userDatas !== void 0 && this._userDatas.forEach((e, i) => {
      t.push(i);
    }), t.sort(Jg);
  }
  getUserData(t) {
    if (this._userDatas !== void 0) {
      const e = this._userDatas.get(t);
      if (e !== void 0)
        return e;
    }
    throw new xh(t);
  }
}
class Kr {
  static parseBinary(t) {
    const e = t.parseInstanceKey(), i = t.parsePmiTopoRef(), s = t.parseIndex_32();
    return {
      bodyInstanceKey: e,
      topoItemType: i,
      itemIndex: s
    };
  }
  static reify(t, e) {
    const i = t.getInclusionKey();
    return new Kr(
      i,
      e.bodyInstanceKey,
      e.topoItemType,
      e.itemIndex
    );
  }
  static fromBodyInstance(t, e, i) {
    const s = t.getInstanceInc();
    return new Kr(s[0], s[1], e, i);
  }
  constructor(t, e, i, s) {
    this._inclusionKey = t, this._bodyInstanceKey = e, this._topoItemType = i, this._itemIndex = s;
  }
  getBodyInstanceInc() {
    return [this._inclusionKey, this._bodyInstanceKey];
  }
  getTopoItemType() {
    return this._topoItemType;
  }
  getItemIndex() {
    return this._itemIndex;
  }
}
class Ys {
  static parseBinary(t) {
    const e = t.parseLayerParseBits(), i = t.parseLayerId();
    let s = null;
    return Ct(e, Id.Name) && (s = t.parseCString()), {
      id: i,
      name: s
    };
  }
  static parseXml(t) {
    const e = t.getAttribute("Name"), i = _e.parseUint(t, "Id");
    return i === null ? (console.error("'Layer' tag missing 'Id' attribute"), null) : {
      id: i,
      name: e
    };
  }
  constructor(t, e, i, s) {
    this.id = t, this.name = e, this.nodes = i, this.treeNodes = s;
  }
}
Ys.NoLayerId = -1;
class $r extends Pi {
  constructor(t, e, i, s) {
    super(t, e, s.nodeInfo), this._bits |= s.bits, this._parent = i, this._instanceKey = s.instanceKey;
    const r = this.getAuthoredLayerId();
    r !== null && t.registerNodeInLayer(this, r), r !== null && !this.isOutOfHierarchy() && t.registerTreeNodeInLayer(this, r), r === null && !this.isOutOfHierarchy() && Qr(s.nodeInfo.nodeId) && (t.registerNodeInLayer(this, Ys.NoLayerId), t.registerTreeNodeInLayer(this, Ys.NoLayerId));
  }
  setRequested() {
    this._bits |= zn.Requested;
  }
  isRequested() {
    return this._hasBits(zn.Requested);
  }
  isOutOfHierarchy() {
    return this._hasBits(zn.OutOfHierarchy);
  }
  preventFromResetting() {
    return this._hasBits(zn.PreventFromResetting);
  }
  isImplicitBody() {
    return this._hasBits(zn.ImplicitBody);
  }
  getParent() {
    return this._parent;
  }
  getInstanceKey() {
    return this._instanceKey;
  }
}
class Ge extends $r {
  constructor(t, e, i, s) {
    super(t, e, i, s), t.registerBodyInstance(this, s.inclusionKey);
  }
  static parseXml(t, e, i, s) {
    const r = Rs.parseXml(t, e, s), o = _e.parseInstanceKeyFromInc(e, "MeshInstanceKey");
    if (o === null)
      throw new ce('Expected "MeshInstanceKey" attribute.');
    return {
      nodeInfo: r,
      inclusionKey: i,
      instanceKey: o,
      bits: 0
    };
  }
  static parseBinary(t, e, i, s) {
    const r = ke(e), o = r.getRemapper(), a = r.getMasterModelKey(), l = i.parseNodeParseBits(), c = Rs.parseBinary(t, i, l, s);
    let h;
    if (l.hasBits1(Qt.ScInclusionKey) ? h = i.parseInclusionKey(o, a) : h = e.getInclusionKey(), !l.hasBits1(Qt.ScInstanceKey))
      throw new pr('Expected "ScInstanceKey" in binary data.');
    const u = i.parseInstanceKey();
    return {
      nodeInfo: c,
      inclusionKey: h,
      instanceKey: u,
      bits: 0
    };
  }
  static reify(t, e, i, s) {
    const r = ke(i), o = new Ge(t, e, i, s);
    return r.attachedInvisibly() && o.setVisibility(!1), o;
  }
  static createDynamic(t, e, i, s, r, o, a, l) {
    const c = Ne(o), u = ke(c).getMasterModelKey(), g = {
      nodeInfo: {
        nodeId: t.massageAuthoredUserId(c, s),
        bits: a,
        name: r,
        localTransform: null,
        attributes: [],
        header: _n.dynamic,
        exchangeId: null,
        layerId: null,
        genericTypeId: null,
        genericId: null,
        userDatas: null
      },
      inclusionKey: e,
      instanceKey: i,
      bits: l
    };
    return new Ge(t, u, o, g);
  }
  getName() {
    const t = super.getName();
    if (t !== null)
      return t;
    const i = this.getParent().getBodyInstances();
    if (i.length > 1) {
      for (let s = 0; s < i.length; ++s) {
        const r = i[s];
        if (this === r)
          return `body ${s + 1}`;
      }
      console.assert(!1);
    }
    return "body";
  }
  getInstanceInc() {
    const t = this._instanceKey;
    let e = ve.Local;
    return (this.hasAuthoredId() || this.isImplicitBody()) && (e = Ne(this).getInclusionKey()), [e, t];
  }
  setVisibility(t) {
    t !== this.isVisible() && this.getParent().markBranchVisibilityDirty(), this._setVisibility(t);
  }
  getRuntimeId() {
    return Os(this._nodeId, this);
  }
}
class In extends $r {
  constructor(t, e, i, s) {
    super(t, e, i, s), t.registerPmiBody(this, s.inclusionKey);
  }
  static parseBinary(t, e, i, s, r) {
    let o = Ge.parseBinary(t, e, i, r);
    if (s) {
      let a = o.nodeInfo, l = a.bits;
      l &= ~We.InitiallyShown, a = { ...a, bits: l }, o = { ...o, nodeInfo: a };
    }
    return o;
  }
  static reify(t, e, i, s) {
    const r = ke(i), o = new In(t, e, i, s);
    return r.attachedInvisibly() && o.setVisibility(!1), o;
  }
  getName() {
    const t = super.getName();
    return t !== null ? t : "PMI body";
  }
  getInstanceInc() {
    const t = this._instanceKey;
    let e = ve.Local;
    return (this.hasAuthoredId() || this.isImplicitBody()) && (e = Ne(this).getInclusionKey()), [e, t];
  }
  setVisibility(t) {
    t !== this.isVisible() && this.getParent().getParent().markBranchVisibilityDirty(), this._setVisibility(t);
  }
  getRuntimeId() {
    return Os(this._nodeId, this);
  }
}
class Hg {
  constructor(t) {
    this.faceIds = [], this.edgeIds = [], this.body = t;
  }
}
class gi extends Pi {
  constructor(t, e, i, s) {
    const o = ke(e).getMasterModelKey();
    let a = 0;
    i.initiallyShown && (a |= We.InitiallyShown);
    const l = {
      nodeId: i.nodeId,
      bits: a,
      name: i.name,
      localTransform: null,
      attributes: i.attributesDataKey ? i.attributesDataKey : [],
      header: _n.dynamic,
      exchangeId: null,
      layerId: null,
      genericTypeId: null,
      genericId: null,
      userDatas: null
    };
    super(t, o, l), this._bits |= zn.PreventFromResetting, this._parent = s, this._packed = gi._pack(i.pmiType, i.pmiSubType);
    for (const c of i.pmiBodyInfos) {
      const h = this._loadPmiBody(t, o, c);
      this._pmiBodies = Mi(this._pmiBodies, h), h.markLoaded();
    }
    if (i.topoRefInfos.length > 0 && (this._topoRefs = gi._loadTopoRefs(e, i.topoRefInfos)), i.topoRefs.length > 0)
      if (this._topoRefs === void 0)
        this._topoRefs = i.topoRefs.slice();
      else
        for (const c of i.topoRefs)
          this._topoRefs.push(c);
    t.registerPmi(this);
  }
  static parseBinary(t, e, i, s) {
    const r = i.parsePmiParseBits(), o = i.parseNodeId();
    let a = null;
    Ct(r, Us.Name) && (a = i.parseCString());
    let l = null;
    Ct(r, Us.ExchangeId) && (l = i.parseCString());
    let c = null;
    Ct(r, Us.Attributes) && (c = i.parseDataKey());
    let h = 1;
    Ct(r, Us.HasMultipleBodies) && (h = i.parseCount_32());
    const u = [], p = Ct(r, Us.InitiallyHidden);
    for (let b = 0; b < h; ++b) {
      const w = In.parseBinary(
        t,
        e,
        i,
        p,
        s
      );
      u.push(w);
    }
    const m = u.length > 0 ? Ct(u[0].nodeInfo.bits, We.InitiallyShown) : !1, g = i.parsePmiType(), _ = i.parsePmiSubType(), y = [];
    if (Ct(r, Us.TopoRef)) {
      const b = i.parseCount_32();
      for (let w = 0; w < b; ++w) {
        const v = Kr.parseBinary(i);
        y.push(v);
      }
    }
    return {
      nodeId: o,
      name: a,
      attributesDataKey: c,
      pmiBodyInfos: u,
      initiallyShown: m,
      pmiType: g,
      pmiSubType: _,
      topoRefInfos: y,
      topoRefs: [],
      exchangeId: l
    };
  }
  static reify(t, e, i, s) {
    const r = ke(e), o = new gi(t, e, i, s);
    return r.attachedInvisibly() && o.setVisibility(!1), o;
  }
  static createDynamic(t, e, i, s, r, o, a, l) {
    const h = {
      nodeId: t.generateDynamicNodeId(),
      name: s,
      attributesDataKey: null,
      pmiBodyInfos: a,
      initiallyShown: !0,
      pmiType: r,
      pmiSubType: o,
      topoRefInfos: [],
      topoRefs: l,
      exchangeId: null
    };
    return new gi(t, e, h, i);
  }
  static _loadTopoRefs(t, e) {
    const i = [];
    for (const s of e) {
      const r = Kr.reify(t, s);
      i.push(r);
    }
    return i;
  }
  _loadPmiBody(t, e, i) {
    return In.reify(t, e, this, i);
  }
  getPmiBodies() {
    return se(this._pmiBodies);
  }
  static _pack(t, e) {
    return t + 100 * e;
  }
  getPmiType() {
    return this._packed % 100;
  }
  getPmiSubType() {
    return Math.floor(this._packed / 100) % 100;
  }
  getParent() {
    return this._parent;
  }
  getRuntimeId() {
    return Os(this._nodeId, this);
  }
  getBranchVisibility() {
    let t = this.isVisible() ? Pt.Shown : Pt.Hidden;
    for (const e of se(this._pmiBodies))
      e.isOutOfHierarchy() || (t |= e.isVisible() ? Pt.Shown : Pt.Hidden);
    return t;
  }
  setVisibility(t) {
    this._setVisibility(t);
  }
  getPmiTopologyReferences(t) {
    if (this._topoRefs === void 0)
      return [];
    const e = /* @__PURE__ */ new Map();
    for (const s of this._topoRefs) {
      const r = s.getBodyInstanceInc(), o = t.lookupAnyBodyByInstanceInc(r[0], r[1]);
      if (o === null)
        continue;
      let a = e.get(o);
      switch (a === void 0 && (a = new Hg(o), e.set(o, a)), s.getTopoItemType()) {
        case $o.Face:
          a.faceIds.push(s.getItemIndex());
          break;
        case $o.Edge:
          a.edgeIds.push(s.getItemIndex());
          break;
      }
    }
    const i = [];
    return e.forEach((s) => {
      i.push(s);
    }), i;
  }
}
class sr {
  static parseBinary(t) {
    const e = t.parseFloat_64(), i = t.parseFloat_64(), s = t.parsePoint3_64();
    return new sr(e, i, s);
  }
  constructor(t, e, i) {
    this.surfaceArea = t, this.volume = e, this.centerOfGravity = i;
  }
}
function Ug(n) {
  const t = Sd;
  switch (n.parseFaceType()) {
    case t.Cylinder:
      return Qg.parseBinary(n);
    case t.Plane:
      return qg.parseBinary(n);
    case t.Cone:
      return $g.parseBinary(n);
    case t.Other:
      return nf.parseBinary(n);
    case t.Sphere:
      return tf.parseBinary(n);
    case t.Torus:
      return ef.parseBinary(n);
    case t.Blend01:
      return sf.parseBinary(n);
    case t.Blend02:
      return rf.parseBinary(n);
    case t.Blend03:
      return of.parseBinary(n);
    case t.Nurbs:
      return af.parseBinary(n);
    case t.Cylindrical:
      return lf.parseBinary(n);
    case t.Offset:
      return cf.parseBinary(n);
    case t.Pipe:
      return hf.parseBinary(n);
    case t.Ruled:
      return uf.parseBinary(n);
    case t.Revolution:
      return df.parseBinary(n);
    case t.Extrusion:
      return mf.parseBinary(n);
    case t.FromCurves:
      return pf.parseBinary(n);
    case t.Transform:
      return gf.parseBinary(n);
    default:
      throw new pr("Unexpected measurement face type.");
  }
}
class Qg {
  static parseBinary(t) {
    const e = t.parseFloat_32(), i = t.parsePoint3_32(), s = t.parsePoint3_32();
    return new Ce(e, i, s);
  }
}
class qg {
  static parseBinary(t) {
    const e = t.parsePoint3_32(), i = t.parsePoint3_32();
    return new Re(e, i);
  }
}
class $g {
  static parseBinary(t) {
    const e = t.parseFloat_32(), i = t.parsePoint3_32(), s = t.parsePoint3_32(), r = t.parseFloat_32();
    return new cr(e, i, s, r);
  }
}
class tf {
  static parseBinary(t) {
    const e = t.parseFloat_32(), i = t.parsePoint3_32(), s = t.parsePoint3_32();
    return new hr(e, i, s);
  }
}
class ef {
  static parseBinary(t) {
    const e = t.parseFloat_32(), i = t.parseFloat_32(), s = t.parsePoint3_32(), r = t.parsePoint3_32();
    return new ur(e, i, s, r);
  }
}
let nf = class {
  static parseBinary(t) {
    return new pa();
  }
};
class sf {
  static parseBinary(t) {
    return new ga();
  }
}
class rf {
  static parseBinary(t) {
    return new fa();
  }
}
class of {
  static parseBinary(t) {
    return new _a();
  }
}
class af {
  static parseBinary(t) {
    return new ya();
  }
}
class lf {
  static parseBinary(t) {
    return new ba();
  }
}
let cf = class {
  static parseBinary(t) {
    return new Ia();
  }
};
class hf {
  static parseBinary(t) {
    return new wa();
  }
}
class uf {
  static parseBinary(t) {
    return new va();
  }
}
class df {
  static parseBinary(t) {
    return new Sa();
  }
}
class mf {
  static parseBinary(t) {
    return new xa();
  }
}
class pf {
  static parseBinary(t) {
    return new Za();
  }
}
let gf = class {
  static parseBinary(t) {
    return new Ca();
  }
};
function ff(n) {
  const t = vd;
  switch (n.parseEdgeType()) {
    case t.Line:
      return _f.parseBinary(n);
    case t.Circle:
      return yf.parseBinary(n);
    case t.Other:
      return bf.parseBinary(n);
    default:
      throw new pr("Unexpected measurement edge type.");
  }
}
let _f = class {
  static parseBinary(t) {
    const e = t.parseFloat_32();
    return new ma(e);
  }
}, yf = class {
  static parseBinary(t) {
    const e = t.parseFloat_32(), i = t.parsePoint3_32(), s = t.parsePoint3_32();
    return new qr(e, i, s);
  }
};
class bf {
  static parseBinary(t) {
    const e = t.parseFloat_32();
    return new Es(e);
  }
}
class Go {
  constructor(t) {
    this.attributes = t;
  }
  copy() {
    return new Go(this.attributes.map((t) => t.copy()));
  }
}
function no(n, t) {
  return n !== void 0 && t < n.length ? n[t] : null;
}
function ou(n, t, e) {
  return n === void 0 && (n = []), n.length = Math.max(n.length, t + 1), n[t] = e, n;
}
var Cr = /* @__PURE__ */ ((n) => (n[n.Unknown = 0] = "Unknown", n[n.BRep = 1] = "BRep", n[n.Tessellation = 2] = "Tessellation", n[n.Wireframe = 3] = "Wireframe", n[n.PointCloud = 4] = "PointCloud", n))(Cr || {});
class Ke extends Pi {
  constructor(t, e, i, s) {
    if (super(t, e, i.nodeInfo), this._parent = s, this._bodyType = i.bodyType, i.faceMeasurementProps.length > 0 && (this._faceMeasurementProps = i.faceMeasurementProps.slice()), i.edgeMeasurementProps.length > 0 && (this._edgeMeasurementProps = i.edgeMeasurementProps.slice()), i.physicalProps !== null && (this._physicalProps = i.physicalProps), i.faceAttributes.length > 0) {
      this._faceAttributes = [];
      for (const r of i.faceAttributes)
        this._faceAttributes.push(r === null ? null : r.copy());
    }
    if (i.edgeAttributes.length > 0) {
      this._edgeAttributes = [];
      for (const r of i.edgeAttributes)
        this._edgeAttributes.push(r === null ? null : r.copy());
    }
    if (i.pointAttributes.length > 0) {
      this._pointAttributes = [];
      for (const r of i.pointAttributes)
        this._pointAttributes.push(r === null ? null : r.copy());
    }
    t.registerRepresentationItem(this);
  }
  static parseXml(t, e, i) {
    const s = Rs.parseXml(t, e, i), r = _e.parseMeshKey(e, "TCKey_Mesh");
    return {
      nodeInfo: s,
      meshKey: r,
      bodyType: 0,
      faceMeasurementProps: [],
      edgeMeasurementProps: [],
      physicalProps: null,
      faceAttributes: [],
      edgeAttributes: [],
      pointAttributes: []
    };
  }
  static parseBinary(t, e, i) {
    const s = e.parseNodeParseBits(), r = Rs.parseBinary(t, e, s, i), o = e.parseBodyType();
    let a = null;
    s.hasBits1(Qt.MeshKey) && (a = e.parseMeshKey());
    const l = [];
    if (s.hasBits1(Qt.FaceMeasurement)) {
      const g = e.parseCount_32();
      for (let _ = 0; _ < g; ++_) {
        const y = Ug(e);
        l.push(y);
      }
    }
    const c = [];
    if (s.hasBits1(Qt.EdgeMeasurement)) {
      const g = e.parseCount_32();
      for (let _ = 0; _ < g; ++_) {
        const y = ff(e);
        c.push(y);
      }
    }
    let h = null;
    s.hasBits1(Qt.PhysicalProperties) && (h = sr.parseBinary(e));
    const u = [];
    if (s.hasBits2(Un.FaceAttributes)) {
      const g = e.parseCount_32();
      for (let _ = 0; _ < g; _++) {
        const y = [], b = e.parseCount_32();
        for (let w = 0; w < b; w++) {
          const v = Wn.parseBinary(e);
          v.getType() !== Jn.Ignored && y.push(v);
        }
        u.push(y.length > 0 ? new Go(y) : null);
      }
    }
    const p = [];
    if (s.hasBits2(Un.EdgeAttributes)) {
      const g = e.parseCount_32();
      for (let _ = 0; _ < g; _++) {
        const y = [], b = e.parseCount_32();
        for (let w = 0; w < b; w++) {
          const v = Wn.parseBinary(e);
          v.getType() !== Jn.Ignored && y.push(v);
        }
        p.push(y.length > 0 ? new Go(y) : null);
      }
    }
    const m = [];
    if (s.hasBits2(Un.PointAttributes)) {
      const g = e.parseCount_32();
      for (let _ = 0; _ < g; _++) {
        const y = [], b = e.parseCount_32();
        for (let w = 0; w < b; w++) {
          const v = Wn.parseBinary(e);
          v.getType() !== Jn.Ignored && y.push(v);
        }
        m.push(y.length > 0 ? new Go(y) : null);
      }
    }
    return {
      nodeInfo: r,
      meshKey: a,
      bodyType: o,
      faceMeasurementProps: l,
      edgeMeasurementProps: c,
      physicalProps: h,
      faceAttributes: u,
      edgeAttributes: p,
      pointAttributes: m
    };
  }
  static reify(t, e, i, s) {
    return new Ke(t, e, i, s);
  }
  static createDynamic(t, e, i, s, r) {
    const o = r.getInclusionContextForNodeId(), c = {
      nodeInfo: {
        nodeId: t.massageAuthoredUserId(o, e),
        bits: We.InitiallyShown,
        name: i,
        localTransform: null,
        attributes: [],
        header: _n.dynamic,
        exchangeId: null,
        layerId: null,
        genericTypeId: null,
        genericId: null,
        userDatas: null
      },
      meshKey: null,
      bodyType: 0,
      faceMeasurementProps: [],
      edgeMeasurementProps: [],
      physicalProps: null,
      faceAttributes: [],
      edgeAttributes: [],
      pointAttributes: []
    };
    return new Ke(t, s, c, r);
  }
  setPhysicalProperties(t) {
    this._physicalProps = t;
  }
  getPhysicalProperties() {
    return this._physicalProps !== void 0 ? this._physicalProps : null;
  }
  getParent() {
    return this._parent;
  }
  getFaceCount() {
    return this._faceMeasurementProps !== void 0 ? this._faceMeasurementProps.length : 0;
  }
  getEdgeCount() {
    return this._edgeMeasurementProps !== void 0 ? this._edgeMeasurementProps.length : 0;
  }
  getFaceAttributes(t) {
    return no(this._faceAttributes, t);
  }
  getEdgeAttributes(t) {
    return no(this._edgeAttributes, t);
  }
  getPointAttributes(t) {
    return no(this._pointAttributes, t);
  }
  getFaceMeasurementProperty(t) {
    return no(this._faceMeasurementProps, t);
  }
  getEdgeMeasurementProperty(t) {
    return no(this._edgeMeasurementProps, t);
  }
  setFaceMeasurementProperty(t, e) {
    this._faceMeasurementProps = ou(this._faceMeasurementProps, t, e.copy());
  }
  setEdgeMeasurementProperty(t, e) {
    this._edgeMeasurementProps = ou(this._edgeMeasurementProps, t, e.copy());
  }
  getBodyType() {
    return this._bodyType;
  }
  getRuntimeId() {
    return Os(this._nodeId, this._parent.getInclusionContextForNodeId());
  }
}
class Ei extends Pi {
  constructor(t, e, i, s) {
    const r = i;
    if (super(t, r, s.nodeInfo), this._inclusionContextForNodeId = e, this._modelKey = i, s.repItemInfos.length > 0) {
      const o = this._loadRepresentationItems(
        t,
        r,
        s.repItemInfos
      );
      this._repItems = zi(o);
    }
    t.registerPartDefinition(this);
  }
  static parseXml(t, e, i) {
    let s = Rs.parseXml(t, e, i);
    if (s.name === null) {
      const a = e.getAttribute("FilePath");
      a !== null && (s = { ...s, name: a });
    }
    const r = [];
    let o = e.firstElementChild;
    for (; o !== null; ) {
      if (o.localName === "Body") {
        const a = Ke.parseXml(t, o, i);
        r.push(a);
      }
      o = o.nextElementSibling;
    }
    return {
      nodeInfo: s,
      repItemInfos: r
    };
  }
  static parseBinary(t, e, i) {
    const s = e.parseNodeParseBits(), r = Rs.parseBinary(t, e, s, i), o = [];
    if (s.hasBits1(Qt.Bodies)) {
      const a = e.parseCount_32();
      for (let l = 0; l < a; ++l) {
        const c = Ke.parseBinary(t, e, i);
        o.push(c);
      }
    }
    return {
      nodeInfo: r,
      repItemInfos: o
    };
  }
  static reify(t, e, i, s) {
    return new Ei(t, e, i, s);
  }
  static createDynamic(t, e, i) {
    const s = t.getRootNode(), r = Ne(s), l = {
      nodeInfo: {
        nodeId: t.massageAuthoredUserId(r, e),
        bits: We.InitiallyShown,
        name: i,
        localTransform: null,
        attributes: [],
        header: _n.dynamic,
        exchangeId: null,
        layerId: null,
        genericTypeId: null,
        genericId: null,
        userDatas: null
      },
      repItemInfos: []
    };
    return new Ei(t, r, Ji.Local, l);
  }
  static createMissing(t) {
    const e = this.createDynamic(t, null, null);
    return e._bits |= bc.IsMissing, e;
  }
  isMissing() {
    return this._hasBits(bc.IsMissing);
  }
  _loadRepresentationItems(t, e, i) {
    const s = [];
    for (const r of i) {
      const o = Ke.reify(t, e, r, this);
      this._addRepresentationItem(o), s.push(o);
    }
    return s;
  }
  getRuntimeId() {
    return Os(this._nodeId, this._inclusionContextForNodeId);
  }
  getInclusionContextForNodeId() {
    return this._inclusionContextForNodeId;
  }
  addReferrer(t) {
    const e = gn(t), i = gn(this._inclusionContextForNodeId);
    console.assert(e === i), this._referrers = Mi(this._referrers, t);
  }
  createRepItem(t, e) {
    const i = this._modelKey, s = Ke.createDynamic(
      t,
      e,
      null,
      i,
      this
    );
    return this._addRepresentationItem(s), s;
  }
  _addRepresentationItem(t) {
    this._repItems = Mi(this._repItems, t);
  }
  getRepresentationItems() {
    return se(this._repItems);
  }
  getReferrers() {
    return se(this._referrers);
  }
  removeAllReferrers() {
    const t = this.getReferrers();
    for (const e of t) {
      const i = e.removePartDefinition();
      console.assert(this === i);
    }
    delete this._referrers;
  }
  getModelKey() {
    return this._modelKey;
  }
}
class er {
  static pushRelatedItemFromParser(t) {
    const e = [];
    for (const i of t.relationships)
      e.push({
        category: i.category,
        id: i.id,
        name: i.name
      });
    return e;
  }
  static addFromRelatingElt(t, e) {
    const i = t.related, s = t.type;
    if (s != null)
      if (!e.has(s) && i !== null)
        e.set(s, {
          related: this.pushRelatedItemFromParser(i),
          relating: []
        });
      else {
        const r = t.related;
        if (r !== null)
          for (const o of r.relationships) {
            const a = e.get(s);
            a !== void 0 && this.findBimObjectInArray(a.related, {
              id: o.id,
              category: o.category,
              name: o.name
            }) === !1 && a.related.push({
              id: o.id,
              category: o.category,
              name: o.name
            });
          }
      }
  }
  static findBimObjectInArray(t, e) {
    for (const i of t)
      if (i.category === e.category && i.name === e.name && i.id === e.id)
        return !0;
    return !1;
  }
  static addFromRelatedElt(t, e) {
    const i = t.type;
    i !== null && !e.has(i) && t.relating !== null && e.set(i, {
      related: [],
      relating: [
        {
          category: t.relating.relationElt.category,
          id: t.relating.relationElt.id,
          name: t.relating.relationElt.name
        }
      ]
    });
  }
  static findIndexInRelated(t, e) {
    let i = -1, s = 0;
    for (const r of e) {
      if (r.id === t) {
        i = s;
        break;
      }
      s++;
    }
    return i;
  }
}
class ms extends $r {
  constructor(t, e, i, s) {
    super(t, e, i, s), this._bits &= ~We.InitiallyShown, t.registerViewFrame(this, s.inclusionKey);
  }
  static parseXml(t, e, i, s) {
    return Ge.parseXml(t, e, i, s);
  }
  static parseBinary(t, e, i, s) {
    return Ge.parseBinary(t, e, i, s);
  }
  static reify(t, e, i, s) {
    const r = ke(i), o = new ms(t, e, i, s);
    return r.attachedInvisibly() && o.setVisibility(!1), o;
  }
  getName() {
    const t = this.getName();
    return t !== null ? t : "CAD View frame";
  }
  getInstanceInc() {
    const t = this._instanceKey;
    let e = ve.Local;
    return (this.hasAuthoredId() || this.isImplicitBody()) && (e = Ne(this).getInclusionKey()), [e, t];
  }
  setVisibility(t) {
    t !== this.isVisible() && this.getParent().getParent().markBranchVisibilityDirty(), this._setVisibility(t);
  }
  getRuntimeId() {
    return Os(this._nodeId, this);
  }
}
var ft = /* @__PURE__ */ ((n) => (n[n.None = 0] = "None", n[n.LoadedNodesOnly = 1] = "LoadedNodesOnly", n))(ft || {});
class Yd {
  constructor(t) {
    this._configuration = t.configuration, this._visibilityFormatter = t.visibilityFormatter, this._resetNonAffectedToDefault = t.resetNonAffectedToDefault, this._state = {
      currentNode: null,
      nodeConfiguration: null,
      appliedVisibility: null,
      inheritedVisibilityStack: [],
      bodiesToShow: [],
      bodiesToHide: []
    }, this.enterProductOccurrence = this.enterProductOccurrence.bind(this), this.leaveProductOccurrence = this.leaveProductOccurrence.bind(this), this.enterAnyBody = this.enterAnyBody.bind(this), this.leaveAnyBody = this.leaveAnyBody.bind(this), this.enterCadView = this.enterCadView.bind(this), this.leaveCadView = this.leaveCadView.bind(this), this.enterPmi = this.enterPmi.bind(this), this.leavePmi = this.leavePmi.bind(this);
  }
  /**
   * Get the visibility formatter of the updater.
   */
  get visibilityFormatter() {
    return this._visibilityFormatter;
  }
  /**
   * Set the visibility formatter of the updater.
   * @param func the formatter to use.
   */
  set visibilityFormatter(t) {
    this._visibilityFormatter = t;
  }
  /**
   * The currently visited node
   */
  get currentNode() {
    return this._state.currentNode;
  }
  /**
   * Getter for the visitor's configuration
   */
  get configuration() {
    return this._configuration;
  }
  /**
   * Getter for the current node's configuration
   */
  get nodeConfiguration() {
    return this._state.nodeConfiguration;
  }
  /**
   * Getter for the output visibility for the current node
   */
  get appliedVisibility() {
    return this._state.appliedVisibility;
  }
  /**
   * Getter for the visitor's state
   */
  get state() {
    return this._state;
  }
  /**
   * Getter for the visit result
   *
   * Mainly the bodies to update.
   */
  get result() {
    return {
      bodies: {
        hide: this._state.bodiesToHide,
        show: this._state.bodiesToShow
      }
    };
  }
  /**
   * Update the visitor state and set the node visibility
   * @param node the node to update
   */
  _updateNodeVisibility(t) {
    this._updateVisitorState(t, !1);
    const e = this.appliedVisibility;
    e !== null && t.setVisibility(e);
  }
  /**
   * Get the visibility config for the current node
   * it contains several fields:
   * explicitVisibility: the value of the node from the visibilityFormatter for the current
   * node, if any visible: whether or not the current node is visible initiallyShown: the node
   * initial visibility
   * initiallyOrConfigurationShown: if configuration.initially.shown is true it
   * returns initiallyShown, otherwise it return initiallyShown or true if the configuration
   * is on the same branch.
   * @returns The current node visibility config
   */
  _getVisibilityConfig() {
    const t = this.currentNode, e = t.isInitiallyShown();
    let i = e;
    return !this._configuration.initially.shown && this._configuration.filterByConfiguration && (i = i || !this._configuration.containsAnyConfig || this._configuration.containsCurrentConfig), {
      explicitVisibility: this._visibilityFormatter ? this._visibilityFormatter(t) : void 0,
      visible: t.isVisible(),
      initiallyShown: e,
      initiallyOrConfigurationShown: i
    };
  }
  /**
   * Get the visibility for a PmiBody node
   *
   * For PMI we allow to switch them to visible if you just set the visibility on the PMI
   * (not its body instance subnode), it's because we don't display the PMI body instance in
   * the tree anymore.
   * @returns true or null
   */
  _getPmiBodyVisibility() {
    const e = this.currentNode.getParent();
    return this._visibilityFormatter && this._visibilityFormatter(e) === !0 ? !0 : null;
  }
  /**
   * If a node is initially hidden and has no explicit visibility set then we keep it
   * hidden by returning null, except for a some exceptions like PmiBody nodes.
   * @returns Null for regular node a boolean otherwise.
   */
  _getInitiallyHiddenNodeVisibility() {
    return this.currentNode instanceof In ? this._getPmiBodyVisibility() : null;
  }
  /**
   * Get the inherited visibility value of the node
   * @returns The inherited visibility value of the node if it's different than its current visibility or null
   */
  _getInheritedVisibility() {
    const t = this._state.inheritedVisibilityStack[this._state.inheritedVisibilityStack.length - 1];
    return t !== this.nodeConfiguration.visible ? t && !this.nodeConfiguration.initiallyShown && this._configuration.initially.immutableHidden ? this._getInitiallyHiddenNodeVisibility() : t : null;
  }
  /**
   * When a node is not affected by the traversal, it visibility status is reinitialized if
   * resetNonAffectedToDefault is set and if its not already set to the expected value.
   * @returns The new visibility status if it's different from the current, null otherwise
   */
  _handleNonAffectedNodeVisibility() {
    return this._resetNonAffectedToDefault && this.nodeConfiguration.visible !== this.nodeConfiguration.initiallyOrConfigurationShown ? this._state.nodeConfiguration.initiallyOrConfigurationShown : null;
  }
  /**
   * Get the visibility status of the current node
   * @param preventFromResetting whether or not unaffected node will be reinitialized
   * @returns The new visibility status of the node if it's different from the current one, null otherwise
   */
  _getNodeVisibility(t) {
    return this.nodeConfiguration && this.nodeConfiguration.explicitVisibility !== void 0 ? this.nodeConfiguration.explicitVisibility : ks(this.currentNode) ? null : this._configuration.node !== void 0 && this._configuration.filterByConfiguration && this._configuration.containsAnyConfig && !this._configuration.containsCurrentConfig ? !1 : this._state.inheritedVisibilityStack.length > 0 ? this._getInheritedVisibility() : t ? null : this._handleNonAffectedNodeVisibility();
  }
  /**
   * Update the state of the visitor.
   * It set the given node as the current node, generates it visibility config, update the
   * hierarchy and compute the new visibility status.
   * @param node The current node to visit
   * @param preventFromResetting whether or not to reinitialize the node if its not affected.
   */
  _updateVisitorState(t, e) {
    this._state.currentNode = t, this._state.nodeConfiguration = this._getVisibilityConfig(), this._state.nodeConfiguration.explicitVisibility !== void 0 ? this._state.inheritedVisibilityStack.push(this._state.nodeConfiguration.explicitVisibility) : this._state.inheritedVisibilityStack.length > 0 && this._state.inheritedVisibilityStack.push(
      this._state.inheritedVisibilityStack[this._state.inheritedVisibilityStack.length - 1]
    ), this._state.appliedVisibility = this._getNodeVisibility(e);
  }
  /**
   * When the node is left it's popped out of the hierarchy
   */
  leaveNode() {
    this._state.inheritedVisibilityStack.length > 0 && this._state.inheritedVisibilityStack.pop();
  }
  /**
   * Check whether or not the current node is the configuration node and update the visibility.
   * If it is the configuration node it tags the config so the visitor knows the current
   * branch contains the configuration node.
   *
   * @param node the current node
   */
  enterProductOccurrence(t) {
    t.isAConfigurationNode() && (this._configuration.containsAnyConfig = !0, this._configuration.node === t && (this._configuration.containsCurrentConfig = !0)), this._updateNodeVisibility(t);
  }
  /**
   * Check whether or not the current node is the configuration node and update the visibility.
   * If it is the configuration node it removes the tag so the visitor knows the current
   * branch does not contains the configuration node anymore.
   * @param node
   */
  leaveProductOccurrence(t) {
    this.leaveNode(), t.isAConfigurationNode() && (this._configuration.containsAnyConfig = !1, this._configuration.node === t && (this._configuration.containsCurrentConfig = !1));
  }
  /**
   * Updates visibility for Pmi node
   * @param pmi the current Pmi Node
   */
  enterPmi(t) {
    this._updateNodeVisibility(t);
  }
  /**
   * Pops Pmi from hierarchy
   * @param _ not used
   */
  leavePmi(t) {
    this.leaveNode();
  }
  /**
   * Updates visibility for CadView node
   * @param cadView the current CadView Node
   */
  enterCadView(t) {
    this._updateNodeVisibility(t);
  }
  /**
   * Pops CadView from hierarchy
   * @param _ not used
   */
  leaveCadView(t) {
    this.leaveNode();
  }
  /**
   * Updates the visitor's state and apply the new visibility status if any. If the Visibility
   * changes the body is stored in the list of the bodies to hide or to show depending of it's
   * new status.
   * @param body the current AnyBody node
   */
  enterAnyBody(t) {
    const e = t.preventFromResetting();
    this._updateVisitorState(t, e);
    const i = this.appliedVisibility;
    i !== null && (t.setVisibility(i), i ? this._state.bodiesToShow.push(t) : this._state.bodiesToHide.push(t));
  }
  /**
   * Pops AnyBody from hierarchy
   * @param _ not used
   */
  leaveAnyBody(t) {
    return this.leaveNode();
  }
}
class If extends Yd {
  constructor(t) {
    super(t), this.enterProductOccurrence = this.enterProductOccurrence.bind(this);
  }
  /**
   * Check whether or not the current node is the configuration node and update the visitor
   * status without updating the node visibility status.
   * If it is the configuration node it tags the config so the visitor knows the current
   * branch contains the configuration node.
   *
   * @param node the current ProductOccurence
   */
  enterProductOccurrence(t) {
    t.isAConfigurationNode() && (this.configuration.containsAnyConfig = !0, this.configuration.node === t && (this.configuration.containsCurrentConfig = !0)), this._updateVisitorState(t, !0);
  }
}
async function Vd(n, t = !1) {
  const e = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set(), s = (a) => t ? a.isInitiallyShown() : a.isVisible(), r = {
    enterAnyBody: (a) => {
      if (a instanceof Ge) {
        const l = a.getRuntimeId();
        s(a) ? e.add(l) : i.add(l);
      }
    }
  };
  await yi.walk(r, n, ft.None);
  const o = e.size >= i.size;
  return new C_(o, o ? i : e);
}
function xl(n) {
  const t = [];
  for (const e of n) {
    const i = e.getInstanceInc();
    t.push(i[0], i[1]);
  }
  return t;
}
function au(n) {
  const t = [];
  for (const e of n) {
    const i = e.getRuntimeId();
    t.push(i);
  }
  return t;
}
class Td {
  constructor(t) {
    this._assemblyTree = t.assemblyTree, this._engine = t.engine, this._callbackManager = t.callbackManager, this._startNode = t.startNode, this._setVisibility = t.setVisibility, this._initiallyHiddenStayHidden = t.initiallyHiddenStayHidden, this._configurationNode = t.configurationNode, this._configuration = null;
  }
  /**
   * Get the visibility formatter for the given attach context
   * @param attachContext the attach context
   * @param setVisibility the visibility directive to apply
   * @returns the default formatter for attach context
   */
  static getAttachContextFormatter(t, e) {
    return (i) => {
      if (i instanceof Yt && t.getChildren().indexOf(i) !== -1)
        switch (e) {
          case hs.Hide:
            return !1;
          case hs.Show:
            return !0;
          case hs.Initial:
            return;
        }
    };
  }
  /**
   * Get the updater configuration
   */
  get configuration() {
    return this._configuration;
  }
  /**
   * Generates the configuration for the updater
   *
   * Determine if the configuration we're activating has initially visible nodes or not.
   *
   * It also checks whether the configuration node is an ancestor of the start node. In this
   * case it tags the configuration so it knows the current branch contains the configuration.
   *
   * In the case of older SCs (pre 2022 SP1) non-default configurations had all their nodes
   * set to initially hidden. Since then that has been changed so that the initial visibility states
   * of nodes under configurations reflects their visibility when the configuration is activated.
   * Thus, we need to know which of those cases we're dealing with, by checking for any nodes set to be
   * initially shown.
   *
   * If we're working with configurations we may need to show initially hidden nodes
   * regardless of assembly tree settings.
   * We want to reveal hidden nodes if the configuration has marked them as hidden.
   * See comment the comment above for more details.
   *
   * @returns a promise resolving with the configuration
   */
  async _generateConfig() {
    let t = !1, e = !1, i = !1, s = !1;
    if (this._configurationNode) {
      console.assert(this._configurationNode.isAConfigurationNode()), t = !0;
      const r = await Vd(this._configurationNode, !0);
      if ((r.defaultVisibility || r.visibilityExceptions.size !== 0) && (s = !0), !(this._startNode instanceof hi)) {
        let o = this._startNode;
        for (; o !== null; ) {
          if (o instanceof Yt && o.isAConfigurationNode()) {
            i = !0, o === this._configurationNode && (e = !0);
            break;
          }
          const a = o.getParent();
          if (!(a instanceof Yt))
            break;
          o = a;
        }
      }
    }
    return this._initiallyHiddenStayHidden === void 0 && (this._configurationNode !== void 0 ? this._initiallyHiddenStayHidden = s : this._initiallyHiddenStayHidden = this._assemblyTree.getInitiallyHiddenStayHidden()), {
      filterByConfiguration: t,
      containsCurrentConfig: e,
      containsAnyConfig: i,
      node: this._configurationNode,
      setVisibility: this._setVisibility,
      initially: {
        shown: s,
        immutableHidden: this._initiallyHiddenStayHidden
      }
    };
  }
  /**
   * Update the visibility of the bodies in the graphic engine.
   *
   * Once the assembly tree has been updated we need to tell the engine that some instances
   * need to be updated so that it can refresh the view.
   *
   * @param bodies the lists of the bodies to show and to hide
   */
  _applyVisibilities(t) {
    if (this._setVisibility) {
      const e = this._startNode.getAttachScope();
      console.assert(e !== lr.OfInitialEmptyModel), this._engine.setVisibilityByAttachment(e, this._setVisibility);
    } else {
      const e = xl(t.show), i = xl(t.hide);
      if (this._engine.pauseRendering(), this._engine.setPartVisibility(e, !0, !0), this._engine.setPartVisibility(i, !1, !0), this._engine.resumeRendering(), this._callbackManager) {
        const s = au(t.show), r = au(t.hide);
        this._callbackManager.trigger("visibilityChanged", s, r);
      }
    }
  }
  /**
   * Traverse the assembly tree within a walker to to allow the given visitor to update it.
   * @param visitor The visitor that will update the assembly tree
   * @param {optional} startNode The root of the traversal, default: the updater startNode
   */
  async traverse(t, e) {
    await yi.walk(t, e || this._startNode, ft.None);
  }
  /**
   * Initialize the configuration and the attach context if needed
   */
  async init() {
    this._startNode instanceof hi || console.assert(this._setVisibility === void 0), this._configuration = await this._generateConfig();
  }
  /**
   * Not effect.
   * To allow inheriting classes to cool down or check result after the update.
   */
  async quit() {
  }
  /**
   * Update the assembly tree and the view using the given visitor.
   * @param visitor the Visitor that will update the assembly tree.
   */
  async update(t, e, ...i) {
    const s = new t({ ...e, configuration: this.configuration }, ...i);
    return await this.traverse(s), this._applyVisibilities(s.result.bodies), s;
  }
  /**
   * Update the assembly tree separately with each node as start node
   * @param visitor the visitor used to update the assembly.
   * @param nodeVisibilities the node roots and their visible status.
   */
  async updatePerNode(t, e, i, ...s) {
    const r = new t({ ...i, configuration: this.configuration }, ...s);
    return e.forEach(async (o, a) => {
      const l = r.visibilityFormatter;
      r.visibilityFormatter = (c) => c === c ? o : l ? l(c) : void 0, await this.traverse(r, a), r.visibilityFormatter = l;
    }), this._applyVisibilities(r.result.bodies), r;
  }
}
async function wf(n) {
  return yh({
    ...n,
    startNode: n.attachContext,
    visibilityFormatter: Td.getAttachContextFormatter(
      n.attachContext,
      n.setVisibility
    ),
    resetNonAffectedToDefault: n.setVisibility === hs.Initial,
    initiallyHiddenStayHidden: n.setVisibility !== hs.Show
  });
}
async function xc(n) {
  return yh(n);
}
async function vf(n) {
  return yh({
    ...n,
    visitorType: If
  });
}
async function yh(n, ...t) {
  const e = new Td({
    assemblyTree: n.assemblyTree,
    engine: n.engine,
    callbackManager: n.callbackManager,
    startNode: n.startNode,
    setVisibility: n.setVisibility !== null ? n.setVisibility : void 0,
    initiallyHiddenStayHidden: n.initiallyHiddenStayHidden,
    configurationNode: n.configurationNode
  });
  await e.init();
  const i = await e.update(
    n.visitorType || Yd,
    {
      visibilityFormatter: n.visibilityFormatter,
      resetNonAffectedToDefault: n.resetNonAffectedToDefault
    },
    ...t
  );
  console.assert(i.state.inheritedVisibilityStack.length === 0), await e.quit();
}
async function Sf(n, t) {
  const e = [], i = [], s = {
    enterAnyBody: (a) => {
      if (a instanceof In || a instanceof ms) {
        const l = a.isVisible();
        a.setVisibility(l), l ? e.push(a) : i.push(a);
      }
    }
  };
  await yi.walk(s, t, ft.None);
  const r = xl(e), o = xl(i);
  n.pauseRendering(), n.synchronizeVisibilities(r, !0), n.synchronizeVisibilities(o, !1), n.resumeRendering();
}
const vr = 0, sc = (n) => (n + 1 >>> 1) - 1, Fa = (n) => (n << 1) + 1, so = (n) => n + 1 << 1;
class xf {
  constructor(t) {
    this._heap = [], this._comparator = t;
  }
  clear() {
    this._heap.length = 0;
  }
  get length() {
    return this._heap.length;
  }
  peek() {
    return this._heap[vr];
  }
  push(t) {
    this._heap.push(t), this._siftUp();
  }
  pop() {
    const t = this.peek(), e = this.length - 1;
    return e > vr && this._swap(vr, e), this._heap.pop(), this._siftDown(), t;
  }
  replace(t) {
    const e = this.peek();
    return this._heap[vr] = t, this._siftDown(), e;
  }
  _greater(t, e) {
    return this._comparator(this._heap[t], this._heap[e]);
  }
  _swap(t, e) {
    [this._heap[t], this._heap[e]] = [this._heap[e], this._heap[t]];
  }
  _siftUp() {
    let t = this.length - 1;
    for (; t > vr && this._greater(t, sc(t)); )
      this._swap(t, sc(t)), t = sc(t);
  }
  _siftDown() {
    let t = vr;
    for (; Fa(t) < this.length && this._greater(Fa(t), t) || so(t) < this.length && this._greater(so(t), t); ) {
      const e = so(t) < this.length && this._greater(so(t), Fa(t)) ? so(t) : Fa(t);
      this._swap(t, e), t = e;
    }
  }
}
class Ed {
  constructor(t, e, i) {
    this._lazyPromise = t, this._wrapperPromise = e, i !== null && (this.compareValue = i);
  }
  kill() {
    this._lazyPromise = null;
  }
  /*
   * Causes this promise to be killed, and the associated open promise to be resolved.
   * This allows anything waiting on the associated open promise to resolve.
   */
  cancel(t) {
    this._lazyPromise = null, this._wrapperPromise.resolve(t);
  }
  fetch(t, e) {
    this._lazyPromise === null ? (this._wrapperPromise.reject(null), setTimeout(e, 0)) : t(this._lazyPromise).then((i) => {
      this._wrapperPromise.resolve(i);
    }).catch((i) => {
      this._wrapperPromise.reject(i);
    });
  }
}
class Rd {
  constructor(t, e, i) {
    this._failed = !1, this._failureError = null, this._activePromiseCount = 0, this._idlePromise = null, this._latestPromise = Promise.resolve(), this._needsResorting = !1, console.assert(t > 0, "Don't create a non-progressible queue."), this._maxActivePromises = t, this._deferredPromises = e, this._failureFailsAll = i;
  }
  maxActivePromises() {
    return this._maxActivePromises;
  }
  activePromiseCount() {
    return this._activePromiseCount;
  }
  isIdle() {
    return this._activePromiseCount === 0;
  }
  async waitForIdle() {
    if (this.isIdle()) {
      if (this._failureFailsAll && this._failed)
        throw this._failureError;
      return;
    }
    return this._idlePromise === null && (this._idlePromise = be()), this._idlePromise;
  }
  killDeferred() {
    const t = [];
    for (; this._deferredPromises.length > 0; ) {
      const e = this._dequeue();
      e.kill(), t.push(e);
    }
    for (const e of t)
      this._queue(e);
  }
  _push(t, e) {
    typeof t == "function" && (t = ji.create(t));
    let i;
    return this._activePromiseCount < this._maxActivePromises ? i = this._immediatePromise(t) : i = this._deferPromise(t, e), this._latestPromise = i, i;
  }
  _resort() {
    console.assert(this._needsResorting), this._needsResorting = !1;
    const t = this._drainQueue();
    for (const e of t)
      this._queue(e);
  }
  _drainQueue() {
    const t = [];
    for (; this._deferredPromises.length > 0; ) {
      const e = this._dequeue();
      t.push(e);
    }
    return t;
  }
  _deferPromise(t, e) {
    const i = be(), s = new Ed(t, i, e);
    return this._queue(s), i;
  }
  async _immediatePromise(t) {
    if (this._failureFailsAll && this._failed)
      throw this._failureError;
    ++this._activePromiseCount;
    try {
      const e = await t.get();
      return this._finalizePromise(), e;
    } catch (e) {
      throw this._failureFailsAll && !this._failed && (this._failed = !0, this._failureError = e, this._idlePromise !== null && this._idlePromise.reject(e)), this._finalizePromise(), e;
    }
  }
  // Kicks off the next item in the queue.
  // Precondition: _deferredPromises.length > 0 && _activePromiseCount < _maxActivePromises
  _fetchNext() {
    this._dequeue().fetch(
      (t) => this._immediatePromise(t),
      () => {
        this._finalizePromise();
      }
    );
  }
  _finalizePromise() {
    --this._activePromiseCount, this._deferredPromises.length > 0 ? (this._needsResorting && this._resort(), this._fetchNext()) : this._activePromiseCount === 0 && (this._idlePromise !== null && (this._failureFailsAll && this._failed ? this._idlePromise.reject(this._failureError) : this._idlePromise.resolve(), this._idlePromise = null), this._latestPromise = Promise.resolve());
  }
}
class Ns extends Rd {
  _queue(t) {
    this._deferredPromises.push(t);
  }
  _dequeue() {
    return this._deferredPromises.pop();
  }
  constructor(t, e) {
    super(t, new wd(), e);
  }
  push(t) {
    return this._push(t, null);
  }
  async waitOnLatest() {
    await this._latestPromise;
  }
}
class Nd extends Rd {
  _queue(t) {
    this._deferredPromises.push(t);
  }
  _dequeue() {
    return this._deferredPromises.pop();
  }
  constructor(t, e, i) {
    const s = (o, a) => e(o.compareValue, a.compareValue), r = new xf(s);
    super(t, r, i);
  }
  push(t, e) {
    return this._push(t, e);
  }
  markDirty() {
    this._needsResorting = !0;
  }
}
class Zf extends Ns {
  _queue(t) {
    this._deferredPromises.clear(), this._deferredPromises.push(t);
  }
  constructor(t) {
    super(1, t);
  }
}
class Cf extends Nd {
  constructor(t, e, i, s, r) {
    super(i, s, r), this._cutoffAttachments = [], this._attachPriorityManager = e, this._cutoffScale = t;
  }
  setCutoffScale(t) {
    this._cutoffScale = Math.max(Math.min(t, 2), 0);
  }
  cutoffEnabled() {
    return this._cutoffScale !== 0;
  }
  isEmpty() {
    return this._cutoffAttachments.length === 0 && this._deferredPromises.length === 0;
  }
  /*
   * This method will effectively 'cancel' a pending loadSubtreebyXXX operation.
   * The difference between this and the base implementation is that all deferred promises will acually be resolved.
   * This allows for the promise returned by the initial method invocation to resolve when in stream cutoff mode if all items never passed the cutoff test.
   */
  killDeferred() {
    const t = this._drainQueue(), e = this._cutoffAttachments;
    this._cutoffAttachments = [];
    for (const i of t)
      i.cancel(null);
    for (const i of e)
      i.cancel(null);
  }
  /*
   * gets the calculated cutoff value from the attachPriorityManager.
   * Attachments must have a projected size equal to or grater than this value with the current camerta to be considered for fetching.
   * The value returned takes into account the sorting method implemented by the PriorityPromiseQueue
   */
  _getCutoffValue() {
    return this._cutoffScale * -this._attachPriorityManager.getCalculatedCutoff() - 1;
  }
  /*
   * Main entrypoint for items into the prefetch queue.  If cutoff is disabled, then the default behavior will be used and all items streamed.
   * When cutoff scale is enabled, then an items projected size will determine if it is enqueued for fetching or held back for reconsideration on camera update.
   */
  push(t, e) {
    if (!this.cutoffEnabled())
      return this._push(t, e);
    const i = this._attachPriorityManager.getPriorityCompareValue(e), s = this._getCutoffValue();
    if (i > s) {
      typeof t == "function" && (t = ji.create(t));
      const r = be(), o = new Ed(t, r, e);
      return this._cutoffAttachments.push(o), r;
    } else
      return this._push(t, e);
  }
  /*
   * Override method which will apply the cutoff scale logic on all items currently needing to be fetched.
   * This may cause some items which were in the queue to be held back, and new items cycled in to be fetched based on
   * their projected size and the current camera.
   */
  _resort() {
    if (!this.cutoffEnabled()) {
      super._resort();
      return;
    }
    this._needsResorting = !1;
    const t = this._drainQueue(), e = this._cutoffAttachments;
    this._cutoffAttachments = [], this._updateDeferredPromiseArray(t), this._updateDeferredPromiseArray(e);
  }
  /*
   * If the queue has deferred promises left, it will automatically be resorted by the PromiseQueueImpl when the next promise finalizes.
   * Otherwise, we want to force a resort now and kick off the next attachment fetch
   */
  update() {
    if (!this.cutoffEnabled()) {
      this.markDirty();
      return;
    }
    this._cutoffAttachments.length > 0 && (this._resort(), this._refillQueue());
  }
  _refillQueue() {
    const t = Math.min(
      this.maxActivePromises() - this.activePromiseCount(),
      this._deferredPromises.length
    );
    for (let e = 0; e < t; e++)
      this._fetchNext();
  }
  /*
   * This method will scan an array of deferred promises and either place them in the queue to be fetched if they pass the cutoff scale test.
   * items which do not make the cut will be held back for reconsideration when the camera is updated again.
   */
  _updateDeferredPromiseArray(t) {
    for (const e of t) {
      const i = this._attachPriorityManager.getPriorityCompareValue(
        e.compareValue
      ), s = this._getCutoffValue();
      i > s ? this._cutoffAttachments.push(e) : this._queue(e);
    }
  }
}
async function po(n, t, e, i) {
  const s = [], r = [], o = [], a = /* @__PURE__ */ new Set(), l = (p) => {
    if (a.has(p))
      return !1;
    a.add(p);
    const m = p.getLocalTransform();
    if (m !== null) {
      let g = s[s.length - 1];
      g = Xi.multiply(m, g), s.push(g);
    }
    return !0;
  }, c = (p) => {
    p.getLocalTransform() !== null && (console.assert(s.length > 1), s.pop());
  }, h = {
    followProductOccurrence: l,
    leaveProductOccurrence: c,
    followPmi: l,
    leavePmi: c,
    followCadView: l,
    leaveCadView: c,
    followAnyBody: l,
    enterAnyBody: (p) => {
      if (!p.isOutOfHierarchy() || i) {
        const m = p.getInstanceInc();
        o.push(m[0], m[1]);
        const g = Q.createFromArray(s[s.length - 1]);
        r.push(g);
      }
    },
    leaveAnyBody: c
  }, u = new Ns(1, !0);
  for (const p of e) {
    const m = ji.create(async () => {
      console.assert(s.length === 0);
      const g = Uo(p.getParent());
      s.push(g), await yi.walk(h, p, ft.None), console.assert(s.length === 1), s.pop();
    });
    u.push(m);
  }
  await u.waitForIdle(), console.assert(2 * r.length === o.length), n.setMatrices(o, r), t.trigger("_updateTransform", i);
}
function Ka(n) {
  return n.isLoaded();
}
function Sr() {
  return !0;
}
function un() {
}
class Ld {
  constructor(t, e) {
    this.followProductOccurrence = Sr, this.enterProductOccurrence = un, this.leaveProductOccurrence = un, this.followPartDefinition = Sr, this.enterPartDefinition = un, this.leavePartDefinition = un, this.followRepresentationItem = Sr, this.enterRepresentationItem = un, this.leaveRepresentationItem = un, this.followAnyBody = Sr, this.enterAnyBody = un, this.leaveAnyBody = un, this.followCadView = Sr, this.enterCadView = un, this.leaveCadView = un, this.followPmi = Sr, this.enterPmi = un, this.leavePmi = un, e === ft.LoadedNodesOnly && (console.assert(t.followProductOccurrence === void 0), console.assert(t.followAnyBody === void 0), console.assert(t.followCadView === void 0), console.assert(t.followPmi === void 0), this.followProductOccurrence = Ka, this.followAnyBody = Ka, this.followCadView = Ka, this.followPmi = Ka), t.followProductOccurrence !== void 0 && (this.followProductOccurrence = t.followProductOccurrence), t.enterProductOccurrence !== void 0 && (this.enterProductOccurrence = t.enterProductOccurrence), t.leaveProductOccurrence !== void 0 && (this.leaveProductOccurrence = t.leaveProductOccurrence), t.followPartDefinition !== void 0 && (this.followPartDefinition = t.followPartDefinition), t.enterPartDefinition !== void 0 && (this.enterPartDefinition = t.enterPartDefinition), t.leavePartDefinition !== void 0 && (this.leavePartDefinition = t.leavePartDefinition), t.followRepresentationItem !== void 0 && (this.followRepresentationItem = t.followRepresentationItem), t.enterRepresentationItem !== void 0 && (this.enterRepresentationItem = t.enterRepresentationItem), t.leaveRepresentationItem !== void 0 && (this.leaveRepresentationItem = t.leaveRepresentationItem), t.followAnyBody !== void 0 && (this.followAnyBody = t.followAnyBody), t.enterAnyBody !== void 0 && (this.enterAnyBody = t.enterAnyBody), t.leaveAnyBody !== void 0 && (this.leaveAnyBody = t.leaveAnyBody), t.followCadView !== void 0 && (this.followCadView = t.followCadView), t.enterCadView !== void 0 && (this.enterCadView = t.enterCadView), t.leaveCadView !== void 0 && (this.leaveCadView = t.leaveCadView), t.followPmi !== void 0 && (this.followPmi = t.followPmi), t.enterPmi !== void 0 && (this.enterPmi = t.enterPmi), t.leavePmi !== void 0 && (this.leavePmi = t.leavePmi);
  }
}
class ka {
  static walk(t, e, i) {
    if (i === ft.LoadedNodesOnly && !e.isLoaded())
      return;
    const s = new ka(t, i);
    return e instanceof Yt ? s._walkProductOccurrence(e) : e instanceof gi ? s._walkPmi(e) : e instanceof Ri ? s._walkCadView(e) : s._walkAnyBody(e);
  }
  constructor(t, e) {
    this._visitor = new Ld(t, e);
  }
  _walkRepresentationItem(t) {
    console.assert(t.isLoaded()), this._visitor.followRepresentationItem(t) && (this._visitor.enterRepresentationItem(t), this._visitor.leaveRepresentationItem(t));
  }
  _walkPartDefinition(t) {
    if (console.assert(t.isLoaded()), this._visitor.followPartDefinition(t)) {
      this._visitor.enterPartDefinition(t);
      const e = t.getRepresentationItems();
      for (const i of e)
        this._walkRepresentationItem(i);
      this._visitor.leavePartDefinition(t);
    }
  }
  _walkAnyBody(t) {
    console.assert(t.isLoaded()), this._visitor.followAnyBody(t) && (this._visitor.enterAnyBody(t), this._visitor.leaveAnyBody(t));
  }
  _walkPmi(t) {
    if (console.assert(t.isLoaded()), this._visitor.followPmi(t)) {
      this._visitor.enterPmi(t);
      for (const e of t.getPmiBodies())
        this._walkAnyBody(e);
      this._visitor.leavePmi(t);
    }
  }
  _walkCadView(t) {
    if (console.assert(t.isLoaded()), this._visitor.followCadView(t)) {
      this._visitor.enterCadView(t);
      const e = t.getViewFrame();
      e !== null && this._walkAnyBody(e), this._visitor.leaveCadView(t);
    }
  }
  _walkProductOccurrence(t) {
    if (console.assert(t.isLoaded()), this._visitor.followProductOccurrence(t)) {
      this._visitor.enterProductOccurrence(t);
      const e = t.getPartDefinitionSync();
      e !== null && this._walkPartDefinition(e);
      const i = t.getChildrenSync();
      for (const a of i)
        this._walkProductOccurrence(a);
      const s = t.getBodyInstances();
      for (const a of s)
        this._walkAnyBody(a);
      const r = t.getPmis();
      for (const a of r)
        this._walkPmi(a);
      const o = t.getCadViews();
      for (const a of o)
        this._walkCadView(a);
      this._visitor.leaveProductOccurrence(t);
    }
  }
}
function Xd(n, t, e, i, s, r) {
  const o = [], l = {
    enterAnyBody: (h) => {
      if (s.has(h))
        return;
      if (s.add(h), h instanceof Ge) {
        if (!Ct(e, bt.BodyInstance) || h.isOutOfHierarchy() && !i)
          return;
      } else if (h instanceof In) {
        if (!Ct(e, bt.PmiBody))
          return;
      } else if (!Ct(e, bt.ViewFrame))
        return;
      const u = h.getInstanceInc();
      o.push(u[0], u[1]);
    }
  }, c = n.walk(l, t, r);
  return c ? c.then(() => o) : o;
}
function Fd(n, t, e, i) {
  return Xd(
    yi,
    n,
    t,
    e,
    i,
    ft.None
  );
}
function zo(n, t, e, i, s) {
  return Xd(
    ka,
    n,
    t,
    e,
    i,
    s
  );
}
function Kd(n, t, e, i) {
  let s = null;
  const r = /* @__PURE__ */ new Set();
  for (const o of t) {
    const a = n.lookupAnyTreeNode(o);
    if (a === null)
      throw new sn(o);
    const l = ks(a), c = zo(
      a,
      e,
      l,
      r,
      i
    );
    if (s === null)
      s = c;
    else
      for (const h of c)
        s.push(h);
  }
  return s !== null ? s : [];
}
async function Od(n, t, e, i, s, r) {
  const o = Kd(
    n,
    e,
    i,
    ft.None
  );
  if (o.length === 0)
    throw new Mt("Cannot get the bounding of node without geometry.");
  return t.getPartsBounding(o, s, r);
}
function kf(n, t) {
  const e = new Ns(1, !0);
  e.push(() => n.clear());
  for (const i of t)
    e.push(() => n.addPlane(i, null));
  return e.waitForIdle();
}
function Mf(n, t, e) {
  const i = e.getRuntimeId(), s = n.get(i);
  s !== void 0 ? (e.overrideLocalTransform(s), t.push(e)) : e.hasLocalTransformOverride() && (e.removeLocalTransformOverride(), t.push(e));
}
function Wf(n, t) {
  t.hasLocalTransformOverride() && (t.removeLocalTransformOverride(), n.push(t));
}
class Ri extends Pi {
  constructor(t, e, i, s, r) {
    const a = ke(e).getMasterModelKey(), l = {
      nodeId: i.nodeId,
      bits: 0,
      name: i.name,
      localTransform: null,
      attributes: [],
      header: _n.dynamic,
      exchangeId: null,
      layerId: null,
      genericTypeId: null,
      genericId: null,
      userDatas: null
    };
    if (super(t, a, l), this._parent = r, this._bits |= i.bits, i.camera !== null && (this._camera = {
      initial: i.camera.copy(),
      derived: i.camera.copy()
    }), this._instanceMarkupKeysToShow = Wo(i.instanceMarkupKeysToShow), Ri.isAuthoredViewInfo(i, s) ? (this._nodesToShow = Ri._toRuntimeIds(e, i.nodesToShow), this._nodesToHide = Ri._toRuntimeIds(e, i.nodesToHide), i.transformMap.size > 0 && (this._transformMap = /* @__PURE__ */ new Map(), i.transformMap.forEach((c, h) => {
      const u = e.toRuntimeId(h);
      this._transformMap.set(u, Xi.copy(c));
    }))) : (this._nodesToShow = Wo(i.nodesToShow), this._nodesToHide = Wo(i.nodesToHide), i.transformMap.size > 0 && (this._transformMap = Nl(i.transformMap))), i.viewFrameInfo !== null && (this._viewFrame = this._loadViewFrame(t, a, i.viewFrameInfo)), i.cuttingPlanes.length > 0) {
      this._cuttingPlanes = zi(i.cuttingPlanes);
      let c = 1;
      const h = hu(this), u = ke(h), p = Pn(u);
      if (p) {
        const m = h.getMeasurementUnit(), g = p.getMeasurementUnit();
        m !== g && (c = m / g);
      }
      c !== 1 && se(this._cuttingPlanes).forEach((m) => {
        m.d *= c;
      });
    }
    t.registerCadView(this);
  }
  static parseXml(t, e, i, s) {
    let r = 0;
    const o = _e.parseNodeId(e, "Id");
    if (o === null)
      throw new ce('Expected "Id" attribute.');
    const a = e.getAttribute("Name");
    if (a === null)
      throw new ce('Expected "Name" attribute');
    const l = (Y, P, L, R) => {
      const D = Y.getAttribute("Enabled");
      if (D === null)
        throw new ce(`Expected ${L} attribute`);
      return P = Nr(P, R, D === "1"), P;
    }, c = e.getAttribute("isAnnotationView");
    c === null ? r = Nr(r, we.IsAnnotationView, !1) : r = Nr(r, we.IsAnnotationView, c === "true");
    let h = null, u = null, p = [], m = [], g = [], _ = /* @__PURE__ */ new Map(), y = [];
    const b = (Y) => {
      const P = _e.parseUint(Y, "Projection");
      if (P === null)
        throw new ce('Expected "Projection" attribute');
      const L = Y.getAttribute("field");
      if (L === null)
        throw new ce('Expected "field" attribute');
      const R = L.split(" ");
      if (R.length !== 2)
        throw new ce("Expected 2 field values");
      const D = parseFloat(R[0]), J = parseFloat(R[1]), G = Y.getAttribute("definition");
      if (G === null)
        throw new ce('Expected "definition" attribute');
      const X = G.split(" ");
      if (X.length !== 9)
        throw new ce("Expected 9 definition values");
      const Z = (gt, U) => new d(
        parseFloat(gt[U]),
        parseFloat(gt[U + 1]),
        parseFloat(gt[U + 2])
      ), W = Z(X, 0), st = Z(X, 3), j = Z(X, 6);
      return ci.create(W, st, j, P, D, J);
    }, w = (Y) => {
      const P = [];
      if (_e.parseUint(Y, "Count") === null)
        throw new ce('Expected "PMIToShow Count" attribute');
      const R = _e.parseNodeIds(Y, "IDs");
      if (R === null)
        throw new ce('Expected "PMIToShow Ids" attribute');
      for (let D = 0; D < R.length; D += 2)
        P.push(R[D + 1]);
      return P;
    }, v = (Y) => {
      const P = [], L = _e.parseUint(Y, "Count");
      if (L === null)
        throw new ce('Expected "ClipPlanes Count" attribute');
      const R = _e.parseFloats(Y, "Plane");
      if (R === null)
        throw new ce('Expected "Plane" attribute');
      if (R.length / 4 !== L)
        throw new ce(`Expected ${L} Planes`);
      for (let D = 0; D < R.length; D += 4)
        P.push(
          je.createFromCoefficients(R[D], R[D + 1], R[D + 2], R[D + 3])
        );
      return P;
    }, C = (Y) => {
      const P = /* @__PURE__ */ new Map(), L = _e.parseUint(Y, "Count");
      if (L === null)
        throw new ce('Expected "IDLocalTransform Count" attribute');
      const R = _e.parseFloats(Y, "IDTransform");
      if (R === null)
        throw new ce('Expected "IDTransform" attribute');
      {
        if (R.length / 13 !== L)
          throw new ce(`Expected ${L} IDTransform values`);
        const D = (J, G) => {
          const X = Xi.getIdentity();
          return X[1] = J[G + 1], X[2] = J[G + 2], X[3] = J[G + 3], X[4] = J[G + 4], X[6] = J[G + 5], X[7] = J[G + 6], X[8] = J[G + 7], X[9] = J[G + 8], X[11] = J[G + 9], X[12] = J[G + 10], X[13] = J[G + 11], X[14] = J[G + 12], X;
        };
        for (let J = 0; J < R.length; J += 13) {
          const G = R[J], X = D(R, J);
          P.set(G, X);
        }
      }
      return P;
    };
    let k = e.firstElementChild;
    for (; k !== null; )
      k.localName === "Camera" ? (console.assert(h === null), h = b(k)) : k.localName === "Frame" ? u = ms.parseXml(
        t,
        k,
        i.getInclusionKey(),
        s
      ) : k.localName === "PMIToShow" ? p = w(k) : k.localName === "InstanceToShow" ? m = _e.parseNodeIds(k, "IDs") : k.localName === "InstanceToHide" ? g = _e.parseNodeIds(k, "IDs") : k.localName === "ClipPlanes" ? y = v(k) : k.localName === "IDLocalTransform" ? _ = C(k) : k.localName === "IsCameraSet" ? r = l(
        k,
        r,
        "IsCameraSet",
        we.IsCameraSet
      ) : k.localName === "IsPMIFilteringSet" ? r = l(
        k,
        r,
        "IsPMIFilteringSet",
        we.IsPmiFilteringSet
      ) : k.localName === "IsGeomFilteringSet" ? r = l(
        k,
        r,
        "IsGeomFilteringSet",
        we.IsGeomFilteringSet
      ) : k.localName === "IsCrosssectionSet" ? r = l(
        k,
        r,
        "IsCrosssectionSet",
        we.IsCrossSectionSet
      ) : k.localName === "IsExplosionSet" ? r = l(
        k,
        r,
        "IsExplosionSet",
        we.IsExplosionSet
      ) : k.localName === "IsCombineState" && (r = l(
        k,
        r,
        "IsCombineState",
        we.IsCombineState
      )), k = k.nextElementSibling;
    return {
      nodeId: o,
      name: a,
      camera: h,
      instanceMarkupKeysToShow: p,
      viewFrameInfo: u,
      nodesToShow: m ?? [],
      nodesToHide: g ?? [],
      transformMap: _,
      cuttingPlanes: y,
      bits: r
    };
  }
  static parseBinary(t, e, i, s) {
    const r = i.parseViewParseBits(), o = i.parseNodeId();
    let a = null;
    Ct(r, ui.Name) && (a = i.parseCString());
    let l = 0, c = !1;
    Ct(r, ui.IsAnnotationView) ? (c = !0, a += " # Annotation View") : a !== null && a.indexOf("# Annotation View") >= 0 && (c = !0), c && (l |= we.IsAnnotationView), Ct(r, ui.IsNotPmiFilteringSet) || (l |= we.IsPmiFilteringSet), Ct(r, ui.IsNotGeomFilteringSet) || (l |= we.IsGeomFilteringSet), Ct(r, ui.IsNotCrosssectionSet) || (l |= we.IsCrossSectionSet), Ct(r, ui.IsNotExplosionSet) || (l |= we.IsExplosionSet), Ct(r, ui.IsCombineState) && (l |= we.IsCombineState), Ct(r, ui.IsDefaultView) && (l |= we.IsDefaultView);
    const h = Ct(r, ui.IsPerspective);
    h && (l |= we.IsPerspective);
    let u = null;
    if (Ct(r, ui.Camera)) {
      const w = h ? te.Perspective : te.Orthographic, v = i.parsePoint3_32(), C = i.parsePoint3_32(), k = i.parsePoint3_32(), Y = i.parseFloat_32(), P = i.parseFloat_32();
      Ct(r, ui.IsNotCameraSet) || (l |= we.IsCameraSet, u = ci.create(v, C, k, w, Y, P), (Y < 0 || P < 0) && (l |= we.HasDynamicFrame));
    }
    const p = [];
    if (Ct(r, ui.Pmi)) {
      const w = i.parseCount_32();
      for (let v = 0; v < w; ++v) {
        const C = i.parseInstanceKey();
        p.push(C);
      }
    }
    let m = null;
    Ct(r, ui.Frame) && (m = ms.parseBinary(t, e, i, s));
    const g = [];
    if (Ct(r, ui.ShowNodes)) {
      const w = i.parseCount_32();
      for (let v = 0; v < w; ++v) {
        const C = i.parseNodeId();
        g.push(C);
      }
    }
    const _ = [];
    if (Ct(r, ui.HideNodes)) {
      const w = i.parseCount_32();
      for (let v = 0; v < w; ++v) {
        const C = i.parseNodeId();
        _.push(C);
      }
    }
    const y = /* @__PURE__ */ new Map();
    if (Ct(r, ui.MoveNodes)) {
      const w = i.parseCount_32();
      for (let v = 0; v < w; ++v) {
        const C = i.parseNodeId(), k = Xi.parseBinary(i);
        y.set(C, k);
      }
    }
    const b = [];
    if (Ct(r, ui.CuttingPlanes)) {
      const w = i.parseCount_32();
      for (let v = 0; v < w; ++v) {
        const C = i.parsePlane3_32();
        b.push(C);
      }
    }
    return {
      nodeId: o,
      name: a,
      camera: u,
      instanceMarkupKeysToShow: p,
      viewFrameInfo: m,
      nodesToShow: g,
      nodesToHide: _,
      transformMap: y,
      cuttingPlanes: b,
      bits: l
    };
  }
  static reify(t, e, i, s) {
    const r = ke(e), o = new Ri(t, e, i, 0, s);
    return r.attachedInvisibly() && o.setVisibility(!1), o;
  }
  static createDynamic(t, e, i, s, r, o, a, l, c) {
    const h = Ne(e), u = t.generateDynamicNodeId(), p = [];
    for (const _ of r)
      for (const y of _.getPmiBodies()) {
        const b = Ne(y);
        console.assert(h === b);
        const v = y.getInstanceInc()[1];
        p.push(v);
      }
    const m = {
      nodeId: u,
      name: i,
      camera: s,
      instanceMarkupKeysToShow: p,
      viewFrameInfo: null,
      nodesToShow: o,
      nodesToHide: a,
      transformMap: l,
      cuttingPlanes: c !== null ? [c] : [],
      bits: we.IsCameraSet
    };
    return new Ri(
      t,
      h,
      m,
      1,
      e
    );
  }
  static isAuthoredViewInfo(t, e) {
    return e === 0;
  }
  static _toRuntimeIds(t, e) {
    const i = /* @__PURE__ */ new Set();
    for (const s of e) {
      const r = t.toRuntimeId(s);
      i.add(r);
    }
    return i;
  }
  _loadViewFrame(t, e, i) {
    return ms.reify(t, e, this, i);
  }
  getViewFrame() {
    return this._viewFrame ?? null;
  }
  getParent() {
    return this._parent;
  }
  getRuntimeId() {
    return Os(this._nodeId, this);
  }
  getBranchVisibility() {
    let t = this.isVisible() ? Pt.Shown : Pt.Hidden;
    return this._viewFrame !== void 0 && !this._viewFrame.isOutOfHierarchy() && (t |= this._viewFrame.isVisible() ? Pt.Shown : Pt.Hidden), t;
  }
  setVisibility(t) {
    this._setVisibility(t);
  }
  isPmiFilteringSet() {
    return this._hasBits(we.IsPmiFilteringSet);
  }
  isDefaultView() {
    return this._hasBits(we.IsDefaultView);
  }
  IsCombineState() {
    return this._hasBits(we.IsCombineState);
  }
  deactivate(t) {
    return t.clearAllCuttingSections();
  }
  async _replaceCuttingPlanes(t, e) {
    await t.clearAllCuttingSections();
    const i = t.getCuttingSectionCount();
    if (e.length > i)
      throw new Mt(
        `System does not support more than ${i} cutting planes in a CadView`
      );
    const s = e.reduce(
      (r, o, a) => {
        const l = t.getCuttingSection(a);
        return console.assert(l !== null), r.push(kf(l, [o])), r;
      },
      []
    );
    await Promise.all(s), await t.activateCuttingSections();
  }
  async activate(t, e, i, s, r, o, a, l) {
    return await this._activateView(
      t,
      e,
      i,
      s,
      l
    ), this._activateCamera(t, e, r, o, a);
  }
  // XXX: I have doubts that this is implemented correctly. Intentionally matching old behavior for now.
  async _activateView(t, e, i, s, r) {
    const o = t.getRootNode();
    r !== null && console.assert(r.isAConfigurationNode());
    const a = (r == null ? void 0 : r.getRuntimeId()) ?? en;
    let l = en;
    const c = /* @__PURE__ */ new Map(), h = [], u = [];
    let p = Wf;
    this._transformMap !== void 0 && (p = (b, w) => {
      Mf(this._transformMap, b, w);
    });
    const m = {
      enterProductOccurrence: (b) => {
        const w = b;
        w.isAConfigurationNode() && (l = w.getRuntimeId());
        const v = l, C = w.forEachPmi((k) => {
          const Y = k.getPmiBodies();
          if (Y.length === 0)
            return;
          let P = !0;
          if (this.isPmiFilteringSet()) {
            P = !1;
            for (const L of Y) {
              const D = L.getInstanceInc()[1];
              if (this._instanceMarkupKeysToShow.has(D)) {
                P = !0;
                break;
              }
            }
          }
          r !== null && (P = P && (v === a || v === en)), c.set(k, P);
          for (const L of Y)
            c.set(L, P);
        }).then(() => {
          const k = w.getRuntimeId();
          return this._nodesToHide.has(k) || w.isADrawingSheetNode() ? c.set(w, !1) : this._nodesToShow.has(k) && (r !== null ? c.set(
            w,
            v === a || v === en
          ) : c.set(w, !0)), p(h, w), w.forEachCadView((Y) => {
            const P = Y;
            if (P._viewFrame !== void 0) {
              let L = P === this;
              r !== null && (L = L && (v === a || v === en)), c.set(Y, L), c.set(P._viewFrame, L);
            }
          });
        });
        u.push(C);
      },
      leaveProductOccurrence: (b) => {
        b.isAConfigurationNode() && (l = en);
      },
      enterAnyBody: (b) => {
        if (b.isOutOfHierarchy())
          return;
        p(h, b);
        let w = b.getParent();
        for (; w !== null && !(w instanceof gi); ) {
          const C = w.getRuntimeId();
          if (this._nodesToHide.has(C)) {
            c.set(w, !1);
            break;
          } else if (this._nodesToShow.has(C)) {
            c.set(w, !0);
            break;
          }
          w = Jd(w.getParent());
        }
        const v = b.getRuntimeId();
        this._nodesToShow.has(v) ? c.set(b, !0) : this._nodesToHide.has(v) && c.set(b, !1), r !== null && l !== en && l !== a && c.set(b, !1);
      }
    };
    await yi.walk(m, o, ft.None), await Promise.all(u);
    const g = [];
    let _ = xc({
      assemblyTree: t,
      engine: e,
      startNode: o,
      visibilityFormatter: (b) => c.get(b),
      resetNonAffectedToDefault: !0,
      configurationNode: r ?? void 0,
      callbackManager: i,
      initiallyHiddenStayHidden: !1
    });
    g.push(_), _ = po(e, i, h, !1), g.push(_), await zt(g);
    const y = se(this._cuttingPlanes);
    await this._replaceCuttingPlanes(s, y);
  }
  async _activateCamera(t, e, i, s, r) {
    const o = this._camera;
    if (o === void 0) {
      t.disableAutomaticFitWorld() || await i.fitWorld(s);
      return;
    }
    if (!r)
      return i._setCameraPromise(o.initial, s);
    const a = hu(this), l = ke(a), c = Pn(l);
    let h = Q.createFromArray(Uo(l));
    if (c !== null) {
      const u = a.getMeasurementUnit(), p = c.getMeasurementUnit();
      if (u !== p) {
        const m = u / p, g = new Q();
        g.setScaleComponent(m, m, m), h = Q.multiply(g, h);
      }
    }
    if (o.derived = o.initial.transform(h), this._hasBits(we.HasDynamicFrame)) {
      const p = this._viewFrame !== void 0 ? await Od(
        t,
        e,
        [this._viewFrame.getRuntimeId()],
        bt.All,
        !1,
        !1
      ) : await e.getModelBounding(!0, !1, !1), m = d.subtract(o.derived.getTarget(), o.derived.getPosition()), g = p.extents().length(), _ = m.copy().normalize().scale(g), y = p.center(), b = d.subtract(y, _);
      return o.derived.setPosition(b), o.derived.setTarget(y), o.derived.setWidth(g), o.derived.setHeight(g), i._setCameraPromise(o.derived, s);
    } else if (o.derived.getProjection() === te.Orthographic) {
      const u = d.subtract(
        o.derived.getTarget(),
        o.derived.getPosition()
      ), p = await e.getModelBounding(!0, !1, !1), m = d.subtract(p.center(), o.derived.getPosition()), g = 1 / u.length(), _ = g * d.dot(u, m);
      if (_ > 0) {
        u.scale(g);
        const y = Math.max(o.derived.getWidth(), o.derived.getHeight()), b = d.add(
          o.derived.getPosition(),
          d.scale(u, _)
        ), w = d.subtract(
          b,
          d.scale(u, 2.5 * y)
        );
        o.derived.setPosition(w), o.derived.setTarget(b);
      }
      return i._setCameraPromise(o.derived, s);
    } else if (o.derived.getProjection() === te.Perspective) {
      const p = await e.getModelBounding(!0, !1, !1), m = d.subtract(p.max, p.min).length(), g = d.subtract(
        o.derived.getTarget(),
        o.derived.getPosition()
      ), _ = g.length(), y = _ / m;
      if (m === 0 || y > 0.01)
        return i._setCameraPromise(o.derived, s);
      const b = m * 0.01 * 1.001, w = o.derived.getWidth() / _, v = o.derived.getHeight() / _, C = w * b, k = v * b, Y = g.copy().normalize().scale(b), P = d.add(o.derived.getPosition(), Y);
      return o.derived.setTarget(P), o.derived.setWidth(C), o.derived.setHeight(k), i._setCameraPromise(o.derived, s);
    } else
      return i._setCameraPromise(o.derived, s);
  }
  hasPmi(t) {
    const e = Ne(this).getInclusionKey(), i = Ne(t).getInclusionKey();
    if (e !== i)
      return !1;
    for (const s of t.getPmiBodies()) {
      const r = s.getInstanceInc()[1];
      if (this._instanceMarkupKeysToShow.has(r))
        return !0;
    }
    return !1;
  }
  isAnnotationView() {
    return this._hasBits(we.IsAnnotationView);
  }
  isCombineStateView() {
    return this._hasBits(we.IsCombineState);
  }
  setViewFrame(t) {
    console.assert(this._viewFrame === void 0), this._viewFrame = t;
  }
}
class yi {
  static walk(t, e, i) {
    if (i === ft.LoadedNodesOnly && !e.isLoaded())
      return Promise.resolve();
    const s = new yi(t, i);
    if (e instanceof Pi)
      return s._walkAnyTreeNode(e);
    {
      const r = new Po(1, !1), o = e.getChildren();
      for (const a of o)
        r.push(() => s._walkAnyTreeNode(a));
      return r.waitForIdle();
    }
  }
  static forceLazyPromises(t) {
    return this.walk({}, t, ft.None);
  }
  constructor(t, e) {
    this._visitor = new Ld(t, e);
  }
  _walkAnyTreeNode(t) {
    let e;
    return t instanceof Yt ? e = this._walkProductOccurrence(t) : t instanceof gi ? e = this._walkPmi(t) : t instanceof Ri ? e = this._walkCadView(t) : e = this._walkAnyBody(t), e === void 0 ? Promise.resolve() : e;
  }
  _walkRepresentationItem(t) {
    this._visitor.followRepresentationItem(t) && (this._visitor.enterRepresentationItem(t), this._visitor.leaveRepresentationItem(t));
  }
  _walkPartDefinition(t) {
    if (this._visitor.followPartDefinition(t)) {
      this._visitor.enterPartDefinition(t);
      const e = t.getRepresentationItems();
      for (const i of e)
        this._walkRepresentationItem(i);
      this._visitor.leavePartDefinition(t);
    }
  }
  _walkAnyBody(t) {
    this._visitor.followAnyBody(t) && (this._visitor.enterAnyBody(t), this._visitor.leaveAnyBody(t));
  }
  _walkPmi(t) {
    if (this._visitor.followPmi(t)) {
      this._visitor.enterPmi(t);
      for (const e of t.getPmiBodies())
        this._walkAnyBody(e);
      this._visitor.leavePmi(t);
    }
  }
  _walkCadView(t) {
    if (this._visitor.followCadView(t)) {
      this._visitor.enterCadView(t);
      const e = t.getViewFrame();
      e !== null && this._walkAnyBody(e), this._visitor.leaveCadView(t);
    }
  }
  _walkProductOccurrence(t) {
    const e = new Po(1, !1);
    if (this._visitor.followProductOccurrence(t)) {
      this._visitor.enterProductOccurrence(t);
      const i = t.getRawPartDefinition();
      i !== null && (i instanceof Si ? e.push(() => {
        if (i.isResolved())
          return this._walkPartDefinition(i.getResolved());
      }) : e.push(() => i.then((l) => {
        if (l !== null) {
          const c = l.value;
          if (c.isResolved())
            return this._walkPartDefinition(c.getResolved());
        }
        return Promise.resolve();
      })));
      const s = t.tryGetChildrenSync();
      if (s !== null)
        for (const l of s)
          e.push(() => this._walkProductOccurrence(l));
      else
        e.push(() => t.getChildren().then((l) => {
          if (l.length === 0)
            return;
          const c = new Po(1, !1);
          for (const h of l)
            c.push(() => this._walkProductOccurrence(h));
          if (!c.isIdle())
            return c.waitForIdle();
        }));
      const r = t.getBodyInstances();
      for (const l of r)
        e.push(() => this._walkAnyBody(l));
      const o = t.getPmis();
      for (const l of o)
        e.push(() => this._walkPmi(l));
      const a = t.getCadViews();
      for (const l of a)
        e.push(() => this._walkCadView(l));
      e.push(() => this._visitor.leaveProductOccurrence(t));
    }
    if (!e.isIdle())
      return e.waitForIdle();
  }
}
function Ad(n) {
  const t = n.getPrototype();
  if (t === null)
    return;
  let e;
  const i = t.getProductOccurrence();
  return i.isResolved() ? e = Zc(i.getResolved()) : e = i.then(Zc), e.then(() => {
    console.assert(i.isResolved()), i.getResolved().markLoaded();
  });
}
async function Zc(n) {
  const t = [], e = {
    enterProductOccurrence: (i) => {
      const s = Ad(i);
      s !== void 0 && t.push(s);
    }
  };
  return await yi.walk(e, n, ft.None), zt(t);
}
function lu(n) {
  n.markLoaded();
  const t = n.getRepresentationItems();
  for (const e of t)
    e.markLoaded();
}
function cu(n) {
  const t = n.getRawPartDefinition();
  if (t !== null)
    return t instanceof Si ? t.isResolved() ? void 0 : t.then(lu) : t.then((e) => {
      if (e === null)
        return;
      const i = e.value;
      if (!i.isResolved())
        return i.then(lu);
    });
}
function Bo(n) {
  const t = Ad(n);
  return t !== void 0 ? t.then(() => cu(n)) : cu(n);
}
async function Pf(n) {
  const t = [], e = {
    enterProductOccurrence: (i) => {
      const s = Bo(i);
      s !== void 0 && t.push(s);
    }
  };
  return await yi.walk(e, n, ft.None), zt(t);
}
class bh {
  constructor(t) {
    this._referrers = null, this._prototype = t;
  }
  _addReferrer(t) {
    this._referrers = Mi(this._referrers, t);
  }
  _getReferrers() {
    return se(this._referrers);
  }
  _getPrototype() {
    return this._prototype;
  }
  _removeReferrer(t) {
    let e = !1, i = se(this._referrers);
    return i = i.filter((s) => s === t ? (e = !0, !1) : !0), e ? (i.length === 0 ? this._referrers = null : this._referrers = zi(i), !0) : !1;
  }
  async _purgeContents() {
    this._prototype.isUnforced() || await (await this._prototype).purgeContents();
  }
  _isLoaded() {
    return this._prototype.isResolved() && this._prototype.getResolved().isLoaded();
  }
}
class Yr {
  constructor(t, e) {
    t instanceof bh && (t = Ws.create(t)), this._shared = t, this._inclusionContext = e;
  }
  getInclusionContext() {
    return this._inclusionContext;
  }
  addReferrer(t) {
    this._shared.get()._addReferrer(t);
  }
  getReferrers() {
    return this._shared.get()._getReferrers();
  }
  getProductOccurrence() {
    return this._shared.get()._getPrototype();
  }
  removeReferrer(t) {
    if (this._shared.get()._removeReferrer(t)) {
      const e = t.removePrototype();
      return console.assert(this === e), !0;
    }
    return !1;
  }
  removeAllReferrers() {
    const t = this.getReferrers();
    for (const e of t)
      this.removeReferrer(e) || console.assert(!1);
  }
  purgeContents() {
    return this._shared.get()._purgeContents();
  }
  isLoaded() {
    return this._shared.get()._isLoaded();
  }
}
function Jo(n) {
  return "modelName" in n;
}
function Gf(n) {
  return !Jo(n);
}
function Dd(n) {
  return n.config.implicitlyLoadXmlExternalModels || Gf(n);
}
class Ih {
  static create(t) {
    return new Ih(t);
  }
  constructor(t) {
    this.value = t;
  }
}
function wh(n) {
  if (n.length === 0)
    return;
  const t = n[0].getBranchVisibility();
  for (let e = 1, i = n.length; e < i; ++e)
    if (t !== n[e].getBranchVisibility())
      return Pt.Mixed;
  return t;
}
function Yf(n) {
  const t = n.getBodyInstances();
  if (t.length === 0)
    return;
  const e = t[0].isVisible();
  for (let i = 1, s = t.length; i < s; ++i)
    if (e !== t[i].isVisible())
      return Pt.Mixed;
  return e ? Pt.Shown : Pt.Hidden;
}
function Vf(n) {
  return wh(n.getChildrenSync());
}
function Tf(n) {
  return wh(n.getPmis());
}
function Ef(n) {
  return wh(n.getCadViews());
}
function Rf(n) {
  const t = n.isVisible() ? Pt.Shown : Pt.Hidden, e = Vf(n);
  if (e !== void 0 && e !== t)
    return Pt.Mixed;
  const i = Yf(n);
  if (i !== void 0 && i !== t)
    return Pt.Mixed;
  const s = Tf(n);
  if (s !== void 0 && s !== t)
    return Pt.Mixed;
  const r = Ef(n);
  return r !== void 0 && r !== t ? Pt.Mixed : e === void 0 && i === void 0 && s === void 0 && r === void 0 ? null : t;
}
const Nf = -2;
function xr(n, t) {
  const e = [];
  for (const i of n) {
    const s = t(i);
    s && e.push(s);
  }
  return zt(e);
}
var Cc = /* @__PURE__ */ ((n) => (n[n.NodeTypeDrawingSheet = 6] = "NodeTypeDrawingSheet", n))(Cc || {}), ne = ((n) => (n[n.IsAConfigurationNode = he.IsAConfigurationNode] = "IsAConfigurationNode", n[n.NodeTypeProduct = he.NodeTypeProduct] = "NodeTypeProduct", n[n.NodeTypeGroup = he.NodeTypeGroup] = "NodeTypeGroup", n[n.NodeTypeDrawingSheet = he.NodeTypeDrawingSheet] = "NodeTypeDrawingSheet", n[n.NodeTypeDrawingView = he.NodeTypeDrawingView] = "NodeTypeDrawingView", n[n.IsADefaultNodeType = he.IsADefaultNodeType] = "IsADefaultNodeType", n[n.BranchVisibilityHidden = he.BranchVisibilityHidden] = "BranchVisibilityHidden", n[n.BranchVisibilityShown = he.BranchVisibilityShown] = "BranchVisibilityShown", n[n.BranchVisibilityDirty = he.BranchVisibilityDirty] = "BranchVisibilityDirty", n[n.IsMissing = he.IsMissing] = "IsMissing", n[n.OutOfHierarchy = he.OutOfHierarchy] = "OutOfHierarchy", n[n.IsExternalModelRoot = he.IsExternalModelRoot] = "IsExternalModelRoot", n))(ne || {});
class Yt extends Pi {
  constructor(t, e, i, s, r, o, a) {
    a = Yt._amendInfo(s, a);
    const l = ke(r), c = l.getMasterModelKey(), h = gn(l);
    super(s, c, a.nodeInfo), this._parent = o, this._bits |= a.productBits | ne.BranchVisibilityDirty;
    const u = a.nodeInfo.header, p = [];
    if (a.prototypeDataKey !== null && (console.assert(i !== null), this._prototypeContext = this._loadPrototypeContext(
      e,
      i,
      s,
      r,
      a.prototypeDataKey,
      u
    )), console.assert(a.quickAccessPartDefinitionDataId === null || a.partDefinition === null), a.partDefinition !== null ? Array.isArray(a.partDefinition) ? this._partDefinition = this._lazyLoadPartDefinitionById(
      s,
      r,
      a.partDefinition,
      u,
      e
    ) : this._partDefinition = this._lazyLoadPartDefinitionByInfo(
      s,
      r,
      a.partDefinition,
      c
    ) : a.quickAccessPartDefinitionDataId !== null && (this._partDefinition = this._lazyLoadPartDefinitionById(
      s,
      r,
      a.quickAccessPartDefinitionDataId,
      u,
      e
    )), a.childDataKeys.length > 0) {
      console.assert(i !== null);
      const g = (async () => {
        const _ = await this._loadProductOccurrences(
          e,
          i,
          s,
          r,
          a.childDataKeys,
          u
        );
        this._children = zi(_);
      })();
      p.push(g);
    }
    if (a.bodyInstanceInfos.length > 0) {
      const g = this._loadBodyInstances(
        s,
        c,
        a.bodyInstanceInfos
      );
      this._bodyInstances = zi(g);
    }
    if (a.cadViewInfos.length > 0) {
      const g = this._loadCadViews(s, r, a.cadViewInfos);
      this._cadViews = zi(g);
    }
    if (a.pmiInfos.length > 0) {
      const g = this._loadPmis(s, r, a.pmiInfos);
      this._pmis = zi(g);
    }
    if (a.measurementUnit !== null && (this._measurementUnit = a.measurementUnit), a.externalModelInfo !== null)
      if (console.assert(t !== null), console.assert(i !== null), Dd(a.externalModelInfo)) {
        const g = this._loadAndAttachExternalModel(
          i,
          r,
          a.externalModelInfo
        );
        p.push(g);
      } else
        this._pendingExternalModels = Mi(this._pendingExternalModels, a.externalModelInfo);
    for (const g of a.layerInfos) {
      const _ = h.getRuntimeLayerId(g.id);
      _ === null ? s.createLayer(g.id, g.name, h) : g.name !== null && s.updateLayerName(_, g.name);
    }
    for (const g of a.filters)
      s.addFilter(g, h);
    for (const g of a.relationships)
      r.addRelationship(g);
    for (const g of a.bimInfos)
      r.addBimInfos(g);
    const m = this.getAuthoredLayerId();
    if (m !== null && (s.registerNodeInLayer(this, m), this.isOutOfHierarchy() || s.registerTreeNodeInLayer(this, m)), s.registerProductOccurrence(this), t === null) {
      if (p.length > 0)
        throw new re();
    } else
      t.resolve(zt(p));
  }
  static parseXml(t, e, i, s, r) {
    const o = i.getInclusionKey(), a = Rs.parseXml(e, s, t), l = _e.parseFloat(s, "Unit"), c = [], h = [], u = [], p = [], m = [], g = [];
    let _ = null, y = null, b = null, w = s.firstElementChild;
    for (; w !== null; ) {
      if (w.localName === "PartDefinition") {
        _ = Ei.parseXml(e, w, t);
        break;
      } else if (w.localName === "BodyInstance") {
        const v = Ge.parseXml(
          e,
          w,
          o,
          t
        );
        c.push(v);
      } else if (w.localName === "Material")
        console.assert(y === null), y = ph.parseXml(w);
      else if (w.localName === "ExternalModel") {
        console.assert(b === null);
        const v = w.getAttribute("Name");
        if (v !== null) {
          const C = _e.parseFloat(w, "Unit"), k = _e.parseBounding(w, "BoundingBox"), Y = 0, P = _e.parseUint(w, "CancelUnitScale") === 1;
          b = {
            config: t,
            modelName: v,
            bounding: k,
            measurementUnit: C,
            toAttachData: r,
            reservedNodeIdOffset: Y,
            cancelUnitScale: P
          };
        }
      } else if (w.localName === "CADView" && !t.ignoreCadViews) {
        const v = Ri.parseXml(e, w, i, t);
        g.push(v);
      } else if (w.localName === "Filter" && !t.ignoreFilters)
        h.push(Do.parseXml(w));
      else if (w.localName === "Layer" && !t.ignoreLayers) {
        const v = Ys.parseXml(w);
        v !== null && u.push(v);
      } else if (w.localName === "Relationships" && !t.ignoreBimRelationships) {
        const v = dr.parseXml(w);
        if (v !== null && p.push(v), v.related !== null)
          for (const C of v.related.relationships)
            er.findBimObjectInArray(m, C) === !1 && m.push(C);
        v.relating !== null && er.findBimObjectInArray(
          m,
          v.relating.relationElt
        ) === !1 && m.push(v.relating.relationElt);
      }
      w = w.nextElementSibling;
    }
    return {
      nodeInfo: a,
      productBits: 0,
      childDataKeys: [],
      prototypeDataKey: null,
      partDefinition: _,
      quickAccessPartDefinitionDataId: null,
      externalModelInfo: b,
      bodyInstanceInfos: c,
      cadViewInfos: g,
      pmiInfos: [],
      measurementUnit: l,
      simpleMaterial: y,
      layerInfos: u,
      filters: h,
      relationships: p,
      bimInfos: m
    };
  }
  static parseBinary(t, e, i, s) {
    const r = ke(i), o = r.getRemapper(), a = s.parseNodeParseBits();
    if (a.hasBits1(Qt.VersionNumber) && s.parseAssemblyDataVersion(2), a.hasBits2(Un.GenericTypes)) {
      const P = s.parseGenericTypes();
      t.ignoreGenericTypes || r.setGenericTypeMaps(P);
    }
    const l = Rs.parseBinary(e, s, a, t);
    let c = 0;
    a.hasBits1(Qt.ProductBits) && (c = s.parseProductBits());
    const h = [];
    if (a.hasBits1(Qt.SubNodes)) {
      const P = s.parseCount_32();
      for (let L = 0; L < P; ++L) {
        const R = s.parseDataKey();
        h.push(R);
      }
    }
    let u = null, p = null;
    if (a.hasBits1(Qt.Instance) && (u = s.parseDataKey(), a.hasBits1(Qt.InstanceQuickAccess))) {
      const P = s.parseModelKey(o);
      console.assert(P !== Ji.Local);
      const L = s.parseDataKey();
      p = [P, L];
    }
    const m = [];
    if (a.hasBits1(Qt.BodyInstances)) {
      const P = s.parseCount_32();
      for (let L = 0; L < P; ++L) {
        const R = Ge.parseBinary(
          e,
          i,
          s,
          t
        );
        m.push(R);
      }
    }
    let g = null;
    if (a.hasBits1(Qt.ExternalModel)) {
      const P = s.parseModelKey(o);
      console.assert(P !== Ji.Local);
      const L = s.parseInclusionKey(o, P);
      g = {
        config: t,
        inclusionKey: L,
        modelKey: P
      };
    }
    let _ = null;
    if (a.hasBits1(Qt.PartDataLink)) {
      let P = s.parseModelKey(o);
      P === Ji.Local && (P = r.getMasterModelKey());
      const L = s.parseDataKey();
      _ = [P, L];
    }
    const y = [];
    if (a.hasBits1(Qt.Views)) {
      const P = s.parseCount_32();
      for (let L = 0; L < P; ++L) {
        const R = Ri.parseBinary(e, i, s, t);
        t.ignoreCadViews || y.push(R);
      }
    }
    const b = [];
    if (a.hasBits1(Qt.Pmis)) {
      const P = s.parseCount_32();
      for (let L = 0; L < P; ++L) {
        const R = gi.parseBinary(e, i, s, t);
        b.push(R);
      }
    }
    let w = null;
    if (a.hasBits1(Qt.Unit) && (w = s.parseFloat_64()), a.hasBits1(Qt.FrontUpVector)) {
      const P = s.parsePoint3_64(), L = s.parsePoint3_64();
      e.setViewAxes(P, L);
    }
    const v = [];
    if (a.hasBits1(Qt.LayerList)) {
      const P = s.parseCount_32();
      for (let L = 0; L < P; ++L) {
        const R = Ys.parseBinary(s);
        t.ignoreLayers || v.push(R);
      }
    }
    const C = [];
    if (a.hasBits1(Qt.Filters)) {
      const P = s.parseCount_32();
      for (let L = 0; L < P; ++L) {
        const R = Do.parseBinary(s);
        t.ignoreFilters || C.push(R);
      }
    }
    const k = [], Y = [];
    if (a.hasBits2(Un.Relationships)) {
      const P = s.parseCount_32();
      for (let L = 0; L < P; ++L) {
        const R = dr.parseBinary(i, s);
        if (t.ignoreBimRelationships || k.push(R), R.relating !== null && !t.ignoreBimRelationships && (er.findBimObjectInArray(Y, R.relating.relationElt) === !1 && Y.push(R.relating.relationElt), R.related !== null))
          for (const D of R.related.relationships)
            er.findBimObjectInArray(Y, D) === !1 && Y.push(D);
      }
    }
    return {
      nodeInfo: l,
      productBits: c,
      childDataKeys: h,
      prototypeDataKey: u,
      partDefinition: _,
      quickAccessPartDefinitionDataId: p,
      externalModelInfo: g,
      bodyInstanceInfos: m,
      cadViewInfos: y,
      pmiInfos: b,
      measurementUnit: w,
      simpleMaterial: null,
      layerInfos: v,
      filters: C,
      relationships: k,
      bimInfos: Y
    };
  }
  /**
   * Like `reify` but with a synchronous return result.
   *
   * Usage requirements:
   *      - `info.childDataKeys` must be empty.
   *      - `info.externalModelInfo` must be `null`.
   */
  static reifySync(t, e, i, s, r, o) {
    console.assert(r.childDataKeys.length === 0), console.assert(r.externalModelInfo === null);
    const a = ke(s), l = new Yt(
      null,
      t,
      e,
      i,
      s,
      o,
      r
    );
    return a.attachedInvisibly() && l.setVisibility(!1), l;
  }
  static async reify(t, e, i, s, r, o) {
    const a = be(), l = new Yt(
      a,
      t,
      e,
      i,
      s,
      o,
      r
    );
    return await a, l;
  }
  static createDynamic(t, e, i, s, r, o, a = !1, l = null) {
    const c = Ne(e), h = t.massageAuthoredUserId(c, s), u = o ? We.InitiallyShown : 0, p = {
      nodeId: h,
      bits: u,
      name: i,
      localTransform: r,
      attributes: [],
      header: _n.dynamic,
      exchangeId: null,
      layerId: null,
      genericTypeId: null,
      genericId: null,
      userDatas: null
    }, m = a ? ne.OutOfHierarchy : 0, g = {
      nodeInfo: p,
      productBits: m,
      childDataKeys: [],
      prototypeDataKey: null,
      partDefinition: null,
      quickAccessPartDefinitionDataId: null,
      bodyInstanceInfos: [],
      externalModelInfo: null,
      cadViewInfos: [],
      pmiInfos: [],
      measurementUnit: l,
      simpleMaterial: null,
      layerInfos: [],
      filters: [],
      relationships: [],
      bimInfos: []
    }, _ = new mr();
    return _.attachInvisibly = !o, new Yt(
      null,
      _,
      null,
      t,
      c,
      e,
      g
    );
  }
  static createMissing(t, e) {
    const i = this.createDynamic(t, e, "Missing", null, null, !1);
    return i._bits |= ne.IsMissing, i;
  }
  isMissing() {
    return this._hasBits(ne.IsMissing);
  }
  static _amendInfo(t, e) {
    if (e.nodeInfo.name !== null)
      return e;
    let i = null;
    if (Ct(e.productBits, ne.NodeTypeProduct) ? i = t.generateProductName() : Ct(e.productBits, ne.NodeTypeGroup) ? i = t.generateGroupName() : Ct(e.productBits, ne.NodeTypeDrawingSheet) ? i = t.generateDrawingSheetName() : Ct(e.productBits, ne.NodeTypeDrawingView) && (i = t.generateDrawingViewName()), i === null)
      return e;
    const s = { ...e.nodeInfo, name: i };
    return { ...e, nodeInfo: s };
  }
  async _loadExternalModel(t, e, i) {
    if (Jo(i))
      return t.attachByExternalModelInfo(i, this, e);
    const s = this.getAuthoredId();
    return gn(e).handleExternalModel(s, e, i.inclusionKey) ? t.attachByExternalModelInfo(i, this, e) : null;
  }
  async _loadAndAttachExternalModel(t, e, i) {
    const s = await this._loadExternalModel(
      t,
      e,
      i
    );
    return s !== null && this.addAttachContext(s), s;
  }
  async loadPendingExternalModels(t) {
    if (!this.hasPendingExternalModels())
      return [];
    const e = Ne(this), i = [];
    for (const r of se(this._pendingExternalModels)) {
      const o = this._loadAndAttachExternalModel(t, e, r);
      i.push(o);
    }
    delete this._pendingExternalModels;
    const s = [];
    for (const r of await Promise.all(i))
      r !== null && s.push(r);
    return s;
  }
  _lazyLoadPartDefinitionByInfo(t, e, i, s) {
    const r = s, o = Ei.reify(t, e, r, i);
    return Si.create(o);
  }
  _lazyLoadPartDefinitionById(t, e, i, s, r) {
    const o = t.getAbstractScEngine(), a = gn(e);
    let l = t.lookupPartDefinitionByDataId(
      a,
      i[0],
      i[1]
    );
    return l !== null ? Si.create(async () => {
      const c = await l;
      return c.addReferrer(this), c;
    }) : (l = Si.create(async () => {
      const c = i[0], h = i[1], u = await t.enqueue(() => o.safeGetMetaData(c, h));
      if (u !== null) {
        const p = new rr(s, u), m = new jo(p), g = Ei.parseBinary(t, m, r), _ = Ei.reify(t, e, c, g);
        return _.addReferrer(this), _;
      }
      return Ei.createMissing(t);
    }), t.registerPartDefinitionByDataId(
      a,
      i[0],
      i[1],
      l
    ), l);
  }
  static async _loadProductOccurrence(t, e, i, s, r, o) {
    const a = new jo(r), l = Yt.parseBinary(t, i, s, a);
    return Yt.reify(
      t,
      e,
      i,
      s,
      l,
      o
    );
  }
  _loadPrototypeContext(t, e, i, s, r, o) {
    const a = ke(s), l = gn(a), h = a.getMasterModelKey(), u = {
      prototypeContext: null,
      sharedPrototypeContext: i.lookupPrototypeByDataId(
        l,
        h,
        r
      )
    };
    if (u.sharedPrototypeContext === null) {
      const p = Si.create(async () => {
        const m = i.getAbstractScEngine(), g = await i.enqueue(() => m.safeGetMetaData(h, r));
        if (g !== null) {
          const _ = new rr(o, g);
          return Yt._loadProductOccurrence(
            t,
            e,
            i,
            s,
            _,
            u.prototypeContext
          );
        }
        return Yt.createMissing(i, u.prototypeContext);
      });
      u.sharedPrototypeContext = new bh(p), i.registerPrototypeByDataId(
        l,
        h,
        r,
        u.sharedPrototypeContext
      );
    }
    return u.prototypeContext = new Yr(u.sharedPrototypeContext, s), u.prototypeContext.addReferrer(this), u.prototypeContext;
  }
  async _loadProductOccurrences(t, e, i, s, r, o) {
    const c = ke(s).getMasterModelKey(), h = i.getAbstractScEngine(), u = await i.enqueue(() => h.safeGetMetaDatas(c, r)), p = [];
    for (let m = 0; m < r.length; ++m) {
      let g;
      if (u !== null) {
        const _ = u[m];
        u[m] = new Uint8Array(0);
        const y = new rr(o, _);
        g = await Yt._loadProductOccurrence(
          t,
          e,
          i,
          s,
          y,
          this
        );
        const b = e.onLoadChildProductOccurrence();
        b && await b;
      } else
        g = Yt.createMissing(i, this);
      p.push(g);
    }
    return p;
  }
  _loadBodyInstances(t, e, i) {
    const s = [];
    for (const r of i) {
      const o = Ge.reify(t, e, this, r);
      s.push(o);
    }
    return s;
  }
  _loadCadViews(t, e, i) {
    const s = [];
    for (const r of i) {
      const o = Ri.reify(t, e, r, this);
      s.push(o), o.markLoaded();
    }
    return s;
  }
  _loadPmis(t, e, i) {
    const s = [];
    for (const r of i) {
      const o = gi.reify(t, e, r, this);
      s.push(o);
    }
    return s;
  }
  getParent() {
    return this._parent;
  }
  getRuntimeId() {
    return Os(this._nodeId, this);
  }
  isAbsoluteRoot() {
    return this._nodeId === Nf;
  }
  getPrototype() {
    return this._prototypeContext !== void 0 ? this._prototypeContext : null;
  }
  isAConfigurationNode() {
    return this._hasBits(ne.IsAConfigurationNode);
  }
  isADefaultNode() {
    return this._hasBits(ne.IsADefaultNodeType);
  }
  isAProductNode() {
    return Ct(this._bits, ne.NodeTypeProduct);
  }
  isAGroupNode() {
    return Ct(this._bits, ne.NodeTypeGroup);
  }
  isADrawingSheetNode() {
    return Ct(this._bits, ne.NodeTypeDrawingSheet);
  }
  isADrawingViewNode() {
    return Ct(this._bits, ne.NodeTypeDrawingView);
  }
  addProductOccurrence(t) {
    console.assert(t.getParent() === this), this._children = Mi(this._children, t), this._itemWasAdded();
  }
  addBodyInstance(t) {
    console.assert(t.getParent() === this), this._bodyInstances = Mi(this._bodyInstances, t), this._itemWasAdded();
  }
  addCadView(t) {
    console.assert(t.getParent() === this), this._cadViews = Mi(this._cadViews, t), this._itemWasAdded();
  }
  addPmi(t) {
    console.assert(t.getParent() === this), this._pmis = Mi(this._pmis, t), this._itemWasAdded();
  }
  addLoadContext(t) {
    console.assert(t.getParent() === this), this._childContexts = Mi(this._childContexts, t), this._itemWasAdded();
  }
  addAttachContext(t) {
    console.assert(t.getParent() === this), this._childContexts = Mi(this._childContexts, t), this._itemWasAdded();
  }
  _followPrototypesWhileEmpty() {
    if (this._prototypeContext === void 0 || this._children !== void 0 || this._childContexts !== void 0)
      return this;
    const t = this._prototypeContext.getProductOccurrence();
    return t.isResolved() ? t.getResolved()._followPrototypesWhileEmpty() : this;
  }
  // Boxed because [[Promise.resolve<Thenable<T>>(x) => Promise<T>]], not [[Promise<<Thenable<T>>>]].
  getRawPartDefinition() {
    if (this._partDefinition !== void 0)
      return this._partDefinition;
    if (this._prototypeContext !== void 0) {
      const t = this._prototypeContext.getProductOccurrence();
      return t.isResolved() ? t.getResolved().getRawPartDefinition() : null;
    }
    return null;
  }
  // Boxed because [[Promise.resolve<Thenable<T>>(x) => Promise<T>]], not [[Promise<<Thenable<T>>>]].
  async getPartDefinition() {
    const t = this.getRawPartDefinition();
    return t instanceof Si ? Ih.create(t) : t instanceof Promise ? t : null;
  }
  getPartDefinitionSync() {
    if (console.assert(this.isLoaded()), this._partDefinition !== void 0 && this._partDefinition.isResolved())
      return this._partDefinition.getResolved();
    if (this._prototypeContext !== void 0) {
      const t = this._prototypeContext.getProductOccurrence();
      if (t.isResolved())
        return t.getResolved().getPartDefinitionSync();
    }
    return null;
  }
  getChildContexts() {
    return se(this._childContexts);
  }
  _getChildren() {
    const t = se(this._children), e = se(this._childContexts);
    for (const i of e)
      t.push(...i.getChildren());
    return t;
  }
  async getChildren() {
    return (await this._followPrototypesWhileEmpty())._getChildren();
  }
  getChildrenSync() {
    console.assert(this.isLoaded());
    const t = this.tryGetChildrenSync();
    if (t === null)
      throw new re();
    return t;
  }
  tryGetChildrenSync() {
    const t = this._followPrototypesWhileEmpty();
    return t instanceof Promise ? null : t._getChildren();
  }
  async forEachChild(t) {
    const e = await this.getChildren();
    return xr(e, t);
  }
  forEachBodyInstance(t) {
    const e = this.getBodyInstances();
    return xr(e, t);
  }
  forEachPmi(t) {
    const e = this.getPmis();
    return xr(e, t);
  }
  forEachCadView(t) {
    const e = this.getCadViews();
    return xr(e, t);
  }
  hasBodyInstances() {
    return this._bodyInstances !== void 0;
  }
  getBodyInstances() {
    return se(this._bodyInstances);
  }
  getCadViews() {
    return se(this._cadViews);
  }
  getPmis() {
    return se(this._pmis);
  }
  setMeasurementUnit(t) {
    this._measurementUnit = t;
  }
  unsetMeasurementUnit() {
    this._measurementUnit = void 0;
  }
  hasMeasurementUnit() {
    return this._measurementUnit !== void 0;
  }
  getMeasurementUnit() {
    let t = this;
    do {
      if (t._measurementUnit !== void 0)
        return t._measurementUnit;
      t = Pn(t._parent);
    } while (t !== null);
    return 1;
  }
  async getPhysicalProperties(t) {
    const e = async () => {
      if (Array.isArray(this._children)) {
        const p = [];
        for (const w of this._children)
          await Bo(w), p.push(await w.getPhysicalProperties(t));
        if (!p.some((w) => w !== null))
          return null;
        let m = 0, g = 0;
        const _ = d.zero();
        let y = 0;
        if (p.forEach((w) => {
          w !== null && (y += 1, m += w.volume, g += w.surfaceArea, _.add(w.centerOfGravity));
        }), y === 0)
          return null;
        const b = d.scale(_, 1 / y);
        return Promise.resolve(new sr(g, m, b));
      }
      return this._children instanceof Yt ? (await Bo(this._children), this._children.getPhysicalProperties(t)) : null;
    }, i = await this.getPartDefinition();
    if (i === null)
      return t ? e() : null;
    const r = (await i.value).getRepresentationItems();
    if (r.length === 0)
      return t ? e() : null;
    let o = 0, a = 0;
    const l = d.zero();
    let c = 0;
    for (const p of r) {
      const m = p.getPhysicalProperties();
      m !== null && (o += m.volume, a += m.surfaceArea, l.add(m.centerOfGravity), c++);
    }
    c !== 0 && l.scale(1 / c);
    const h = new sr(a, o, l), u = await e();
    return u !== null ? new sr(
      h.surfaceArea + u.surfaceArea,
      h.volume + u.volume,
      d.add(h.centerOfGravity, u.centerOfGravity).scale(0.5)
    ) : h;
  }
  setPartDefinition(t) {
    console.assert(this._partDefinition === void 0), this._partDefinition = Si.create(t);
  }
  setPrototype(t) {
    console.assert(this._prototypeContext === void 0), this._prototypeContext = t, this._markBranchVisibilityDirty(!1);
  }
  removePrototype() {
    if (this._prototypeContext === void 0)
      throw new re();
    const t = this._prototypeContext;
    return delete this._prototypeContext, this._markBranchVisibilityDirty(!1), t;
  }
  getBranchVisibility() {
    return this._updateBranchVisibility(), this._getBranchVisibility();
  }
  _getBranchVisibility() {
    let t = this.isVisible() ? Pt.Shown : Pt.Hidden;
    return this._hasBits(ne.BranchVisibilityShown) && t !== Pt.Shown && (t = Pt.Mixed), this._hasBits(ne.BranchVisibilityHidden) && t !== Pt.Hidden && (t = Pt.Mixed), t;
  }
  _setBranchVisibility(t) {
    const e = this.isVisible();
    console.assert(e ? t !== Pt.Hidden : t === Pt.Hidden), this._bits &= ~(ne.BranchVisibilityHidden | ne.BranchVisibilityShown), (t === Pt.Hidden || t === Pt.Mixed) && (this._bits |= ne.BranchVisibilityHidden), (Ct(t, Pt.Shown) || t === Pt.Mixed) && (this._bits |= ne.BranchVisibilityShown);
  }
  _updateBranchVisibility() {
    if (!this._hasBits(ne.BranchVisibilityDirty))
      return;
    let t = this.isVisible() ? Pt.Shown : Pt.Hidden;
    const e = this._getSubBranchVisibilities();
    e !== null && e !== t && (t = Pt.Mixed), this._setBranchVisibility(t), this._bits &= ~ne.BranchVisibilityDirty;
  }
  _getSubBranchVisibilities() {
    return Rf(this);
  }
  _itemWasAdded() {
    this._getBranchVisibility() !== Pt.Mixed && this._markBranchVisibilityDirty(!0);
  }
  _onItemRemoved() {
    this._getBranchVisibility() !== Pt.Hidden && this._markBranchVisibilityDirty(!1);
  }
  markBranchVisibilityDirty() {
    this._markBranchVisibilityDirty(!1);
  }
  _markBranchVisibilityDirty(t) {
    if (!this._hasBits(ne.BranchVisibilityDirty) && !(t && this._getBranchVisibility() === Pt.Mixed))
      if (this._bits |= ne.BranchVisibilityDirty, this._parent instanceof Yr) {
        const e = this._parent.getReferrers();
        for (const i of e)
          i._markBranchVisibilityDirty(t);
      } else {
        const e = Pn(this._parent);
        if (e !== null)
          return e._markBranchVisibilityDirty(t);
      }
  }
  setVisibility(t) {
    this.isVisible() !== t && (this._setVisibility(t), this._markBranchVisibilityDirty(!1));
  }
  _removeDirectChild(t) {
    let e = se(this._children);
    const i = e.length;
    return e = e.filter((s) => s !== t), e.length === i ? !1 : (e.length === 0 ? delete this._children : this._children = zi(e), this._onItemRemoved(), !0);
  }
  _removeIndirectChild(t) {
    let e = !1, i = se(this._childContexts);
    for (const s of i)
      if (s.removeProductOccurrence(t)) {
        e = !0;
        break;
      }
    return e ? (i = i.filter((s) => s.hasChildren()), i.length === 0 ? delete this._childContexts : this._childContexts = zi(i), this._onItemRemoved(), !0) : !1;
  }
  removeProductOccurrence(t) {
    return this._removeDirectChild(t) ? !0 : this._removeIndirectChild(t);
  }
  removePmi(t) {
    let e = se(this._pmis);
    const i = e.length;
    return e = e.filter((s) => s !== t), e.length === i ? !1 : (e.length === 0 ? delete this._pmis : this._pmis = zi(e), this._onItemRemoved(), !0);
  }
  removeBodyInstance(t) {
    let e = se(this._bodyInstances);
    const i = e.length;
    return e = e.filter((s) => s !== t), e.length === i ? !1 : (e.length === 0 ? delete this._bodyInstances : this._bodyInstances = zi(e), this._onItemRemoved(), !0);
  }
  purgeContents() {
    this._markBranchVisibilityDirty(!1);
    const t = [];
    let e;
    this._partDefinition !== void 0 && (this._partDefinition.isUnforced() || (e = this._partDefinition.then((r) => {
      r.removeAllReferrers(), delete this._partDefinition;
    }), t.push(e))), this._prototypeContext !== void 0 && (e = this._prototypeContext.purgeContents(), t.push(e), this._prototypeContext.removeReferrer(this), delete this._prototypeContext);
    const i = se(this._children);
    e = xr(i, (r) => r.purgeContents()), t.push(e), delete this._children;
    const s = se(this._childContexts);
    return e = xr(s, (r) => r.purgeContents()), t.push(e), delete this._childContexts, delete this._bodyInstances, delete this._cadViews, delete this._pmis, delete this._measurementUnit, zt(t);
  }
  removePartDefinition() {
    if (this._partDefinition === void 0 || !this._partDefinition.isResolved())
      throw new re();
    const t = this._partDefinition;
    return delete this._partDefinition, t.getResolved();
  }
  isOutOfHierarchy() {
    return this._hasBits(ne.OutOfHierarchy);
  }
  markIsExternalModelRoot(t) {
    console.assert(!this._hasBits(ne.IsExternalModelRoot)), this._bits |= ne.IsExternalModelRoot, t.markSeenExternalModel();
  }
  isExternalModelRoot() {
    return this._hasBits(ne.IsExternalModelRoot);
  }
  addPendingExternalModel(t) {
    this._pendingExternalModels = Mi(this._pendingExternalModels, t);
  }
  hasPendingExternalModels() {
    return !jg(this._pendingExternalModels);
  }
}
class zd {
  constructor() {
    this._leftToRight = /* @__PURE__ */ new Map(), this._rightToLeft = /* @__PURE__ */ new Map();
  }
  set(t, e) {
    this._leftToRight.set(t, e), this._rightToLeft.set(e, t);
  }
  getLeft(t) {
    return this._rightToLeft.get(t);
  }
  getRight(t) {
    return this._leftToRight.get(t);
  }
}
class Bd {
  constructor() {
    this._bits1 = 0, this._bits2 = 0;
  }
  hasBits1(t) {
    return Ct(this._bits1, t);
  }
  hasBits2(t) {
    return Ct(this._bits2, t);
  }
  parseBits1(t) {
    this._bits1 = t.parseIndex_32();
  }
  parseBits2(t) {
    this.hasBits1(Qt.UseNodeParseBits2) && (this._bits2 = t.parseIndex_32());
  }
}
class Lf {
  constructor(t, e) {
    this.shown = t, this.removed = e;
  }
}
class jo {
  constructor(t) {
    this._bytes = t.bytes, this._header = t.header, this._dataView = new DataView(
      this._bytes.buffer,
      this._bytes.byteOffset,
      this._bytes.byteLength
    ), this._currentPos = 0;
  }
  hasNext() {
    return this._currentPos < this._bytes.length;
  }
  parseCount_32() {
    return this._parseUint_32();
  }
  parseIndex_32() {
    return this._parseUint_32();
  }
  parseAssemblyDataVersion(t) {
    const e = [];
    for (let i = 0; i < t; ++i)
      e.push(this._parseUint_32());
    return e;
  }
  parseAssemblyDataHeaderVersion() {
    return this._parseUint_32();
  }
  parseVisibility() {
    let t;
    ((r) => {
      r[r.Removed = 1] = "Removed", r[r.Shown = 2] = "Shown";
    })(t || (t = {}));
    const e = this._parseInt_8(), i = Ct(
      e,
      2
      /* Shown */
    ), s = Ct(
      e,
      1
      /* Removed */
    );
    return new Lf(i, s);
  }
  parseProductBits() {
    let t = this._parseUint_8();
    return this._header !== null && this._header.headerVersion >= 2 || !Ct(t, Cc.NodeTypeDrawingSheet) || (t &= ~Cc.NodeTypeDrawingSheet, t |= ne.NodeTypeDrawingSheet), t;
  }
  parseUnits() {
    const t = this.parseInt32(), e = [];
    for (let i = 0; i < t; i++) {
      const s = this.parseUInt32(), r = this.parseInt32(), o = this.parseFloat_64();
      e.push({
        basicUnit: s,
        exponent: r,
        factor: o
      });
    }
    return e;
  }
  parseCString() {
    const t = this._currentPos;
    let e = this._bytes[this._currentPos++];
    for (; e !== 0; )
      e = this._bytes[this._currentPos++];
    return Ag(this._bytes.subarray(t, this._currentPos - 1));
  }
  parseUInt32() {
    return this._parseUint_32();
  }
  parseInt32() {
    return this._parseInt_32();
  }
  parseBytes(t) {
    const e = this._currentPos;
    this._currentPos += t;
    const i = this._bytes.subarray(e, this._currentPos);
    return new Uint8Array(i);
  }
  parseNodeId() {
    const t = this._parseUint_32();
    return console.assert(t !== en), t;
  }
  parseLayerId() {
    const t = this._parseUint_32();
    return console.assert(t !== en), t;
  }
  parseGenericTypes() {
    const t = this._parseUint_32(), e = new zd();
    for (let i = 0; i < t; i++) {
      const s = this.parseCString(), r = this._parseUint_32();
      e.set(r, s);
    }
    return e;
  }
  parseGenericTypeId() {
    return this._parseUint_32();
  }
  parseGenericId() {
    return this.parseCString();
  }
  _parseScKey() {
    const t = this._parseUint_32();
    return console.assert(t !== ah.Invalid), t;
  }
  parseDataKey() {
    return this._parseScKey();
  }
  parseInstanceKey() {
    return this._parseScKey();
  }
  parseMeshKey() {
    return this._parseScKey();
  }
  parseModelKey(t) {
    const e = this._parseScKey();
    return t !== null ? t.getEffectiveModelKey(e) : e;
  }
  parseInclusionKey(t, e) {
    const i = this._parseScKey();
    return t !== null ? t.getEffectiveInclusionKey(i, e) : i;
  }
  parseMatrix() {
    const t = this._header !== null && this._header.doublePrecisionMatrices ? () => this.parseFloat_64() : () => this.parseFloat_32(), e = Xi.getIdentity();
    for (let i = 0; i < 4; ++i)
      for (let s = 0; s < 3; ++s)
        e[4 * i + s] = t();
    return e;
  }
  _parseInt_8() {
    return this._dataView.getInt8(this._currentPos++);
  }
  _parseUint_8() {
    return this._dataView.getUint8(this._currentPos++);
  }
  _parseUint_32() {
    const t = this._dataView.getUint32(this._currentPos, !0);
    return this._currentPos += 4, t;
  }
  _parseInt_32() {
    const t = this._dataView.getInt32(this._currentPos, !0);
    return this._currentPos += 4, t;
  }
  _parseFloat_32() {
    const t = this._dataView.getFloat32(this._currentPos, !0);
    return this._currentPos += 4, t;
  }
  _parseFloat_64() {
    const t = this._dataView.getFloat64(this._currentPos, !0);
    return this._currentPos += 8, t;
  }
  parseFloat_32() {
    return this._parseFloat_32();
  }
  parseFloat_64() {
    return this._parseFloat_64();
  }
  parseAttributeType() {
    return this._parseInt_8();
  }
  parseNodeParseBits() {
    const t = new Bd();
    return t.parseBits1(this), t.parseBits2(this), t;
  }
  parseViewParseBits() {
    return this._parseUint_32();
  }
  parsePmiParseBits() {
    return this._parseUint_32();
  }
  parseLayerParseBits() {
    return this._parseUint_32();
  }
  parseAttributeParseBits() {
    return this._parseUint_32();
  }
  parseRelationshipParseBits() {
    return this._parseUint_32();
  }
  parseBoolean() {
    return this._parseUint_8() !== 0;
  }
  parsePoint3_32() {
    return new d(this._parseFloat_32(), this._parseFloat_32(), this._parseFloat_32());
  }
  parsePoint3_64() {
    return new d(this._parseFloat_64(), this._parseFloat_64(), this._parseFloat_64());
  }
  parsePlane3_32() {
    return je.createFromCoefficients(
      this._parseFloat_32(),
      this._parseFloat_32(),
      this._parseFloat_32(),
      this._parseFloat_32()
    );
  }
  parsePmiType() {
    return this._parseUint_32();
  }
  parsePmiSubType() {
    return this._parseUint_32();
  }
  parsePmiTopoRef() {
    return this._parseInt_8();
  }
  parseBodyType() {
    return this._parseUint_8();
  }
  parseFaceType() {
    return this._parseInt_8();
  }
  parseEdgeType() {
    return this._parseInt_8();
  }
  parseUserDataIndex() {
    const t = this._parseUint_32(), e = this._parseUint_32();
    return e <= 2097151 ? 4294967296 * e + t : `${e.toString(16)}${Bg(t)}`.toUpperCase();
  }
  getHeader() {
    return this._header;
  }
}
function Xf(n, t) {
  const e = (s) => {
    t.push(s);
  }, i = {
    enterProductOccurrence: e,
    enterAnyBody: e,
    enterCadView: e,
    enterPmi: e,
    enterPartDefinition: e,
    enterRepresentationItem: e
  };
  return yi.walk(i, n, ft.None);
}
async function ir(n) {
  const t = [], e = [];
  for (const i of n) {
    const s = Xf(i, e);
    t.push(s);
  }
  await zt(t);
  for (const i of e)
    i.markLoaded();
}
class Ff {
  constructor(t, e) {
    this.value = t, this.kids = e.slice();
  }
}
const vh = [24, 4, 0];
class Qs {
  constructor(t) {
    this.referencedInfo = t;
  }
}
function rc(n) {
  return n instanceof Qs ? n.referencedInfo : n;
}
function Kf(n, t) {
  let e = n.nodeInfo.localTransform;
  return e === null ? e = t : e = Xi.multiply(e, t), {
    ...n,
    nodeInfo: {
      ...n.nodeInfo,
      localTransform: e
    }
  };
}
class oc {
  /**
   * This is used to parse `ModelFileInfo` without adding it to the tree.
   */
  static parseXml(t, e, i, s, r) {
    console.assert(s.localName === "ModelFile");
    const o = /* @__PURE__ */ new Map(), a = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ new Map(), c = (m) => {
      let g = Yt.parseXml(
        t,
        e,
        i,
        m,
        r
      );
      const _ = g.nodeInfo.nodeId;
      if (l.has(g.nodeInfo.nodeId)) {
        const v = new Qs(g);
        o.set(_, v);
      } else
        a.has(g.nodeInfo.nodeId) || (a.set(g.nodeInfo.nodeId, null), t.additionalMatrix !== null && (g = Kf(g, t.additionalMatrix.m))), o.set(_, g);
      const b = _e.parseNodeIds(m, "Children") ?? [];
      for (const v of b)
        a.set(v, g);
      const w = _e.parseNodeId(m, "InstanceRef");
      if (w !== null) {
        const v = l.get(w);
        v === void 0 ? l.set(w, [g]) : v.push(g);
      }
    };
    let h = s.firstElementChild;
    for (; h !== null; ) {
      if (h.localName !== "ProductOccurence")
        throw new ce(`Unexpected element "${h.localName}".`);
      if (_e.parseNodeId(h, "Id") === null)
        throw new ce('Expected "Id" attribute.');
      c(h), h = h.nextElementSibling;
    }
    const u = this._parentMapToChildMap(o, a, l);
    return {
      treeInfos: this._childMapRoseTrees(u)
    };
  }
  static _parentMapToChildMap(t, e, i) {
    const s = /* @__PURE__ */ new Map(), r = (o, a) => {
      const l = s.get(o);
      l === void 0 ? s.set(o, [a]) : l.push(a);
    };
    return e.forEach((o, a) => {
      const l = t.get(a);
      if (l instanceof Qs)
        throw new ce('Expected a referenced node for "InstanceRef".');
      r(o, l);
    }), i.forEach((o, a) => {
      console.assert(o.length > 0);
      const l = t.get(a);
      if (!(l instanceof Qs))
        throw new ce(
          `Node is both an "InstanceRef" and contained in another node's "Children" list.`
        );
      for (const c of o)
        r(c, l);
    }), s;
  }
  static _childMapRoseTrees(t) {
    const e = (r) => {
      const o = [], a = rc(r), l = t.get(a);
      if (l !== void 0) {
        console.assert(l.length > 0);
        for (const c of l) {
          const h = e(c);
          o.push(h);
        }
      }
      return new Ff(r, o);
    }, i = t.get(null);
    if (i === void 0)
      return console.assert(t.size === 0), [];
    const s = [];
    for (const r of i) {
      if (r instanceof Qs) {
        console.assert(!1);
        continue;
      }
      const o = e(r);
      s.push(o);
    }
    return s;
  }
  /**
   * Inserts `ModelFileInfo` into the assembly tree.
   */
  static async reify(t, e, i, s, r, o) {
    const a = [], l = [], c = [];
    for (const u of o.treeInfos) {
      if (u.value instanceof Qs) {
        console.assert(!1);
        continue;
      }
      const p = this._reifyProductOccurrence(
        t,
        e,
        i,
        s,
        r,
        r,
        u,
        a
      );
      l.push(p), c.push(p.getRuntimeId());
    }
    const h = e.promiseTrigger(
      "_subtreeLoaded",
      "subtreeLoaded",
      c,
      ps.LoadModel
    );
    return a.push(h), await zt(a), l;
  }
  static _rectifyExternalModelInfo(t, e) {
    let i = {
      ...e.referencedInfo.externalModelInfo,
      reservedNodeIdOffset: 0
    };
    if (i === null)
      throw new ce('"InstanceRef" node does not contain "ExternalModel".');
    if (!Jo(i))
      throw new re();
    console.assert(i.reservedNodeIdOffset === 0);
    const s = t.newNodeIdOffset();
    return i = {
      ...i,
      reservedNodeIdOffset: s
    }, i;
  }
  static _reifyProductOccurrence(t, e, i, s, r, o, a, l) {
    const c = rc(a.value);
    if (c.childDataKeys.length !== 0)
      throw new re();
    if (c.externalModelInfo !== null)
      throw new ts('Unexpected "ExternalModel". Should be a child of an "InstanceRef".');
    const h = Yt.reifySync(
      t,
      i,
      s,
      r,
      c,
      o
    );
    o.addProductOccurrence(h), h.markLoaded();
    for (const u of a.kids)
      if (u.value instanceof Qs) {
        console.assert(u.kids.length === 0);
        const p = this._rectifyExternalModelInfo(s, u.value);
        if (Dd(p)) {
          const m = i.attachByExternalModelInfo(p, h, r).then(async (g) => {
            if (g === null)
              return;
            await ir([g]), h.addAttachContext(g);
            const _ = g.getChildren().map((y) => y.getRuntimeId());
            await e.promiseTrigger(
              "_subtreeLoaded",
              "subtreeLoaded",
              _,
              ps.LoadModel
            );
          });
          l.push(m);
        } else
          h.addPendingExternalModel(p);
      } else
        console.assert(u.value.externalModelInfo === null), this._reifyProductOccurrence(
          t,
          e,
          i,
          s,
          r,
          h,
          u,
          l
        );
    return h;
  }
  static _parseBounding(t, e) {
    const i = rc(t.value);
    let s = nn;
    i.measurementUnit !== null && (s = i.measurementUnit);
    let r = 1;
    s === nn ? s = e : e !== nn && (r = s / e);
    let o = new Q().setScaleComponent(r, r, r);
    const a = i.nodeInfo.localTransform;
    if (a !== null) {
      const h = Q.createFromArray(a);
      o = Q.multiply(h, o);
    }
    const l = ni.invalid();
    for (const h of t.kids) {
      let u = this._parseBounding(h, s);
      u = o.transformBox(u), l.addBox(u);
    }
    const c = i.externalModelInfo;
    if (c !== null) {
      if (!Jo(c))
        throw new re();
      let h = c.bounding;
      if (h !== null && !h.isDegenerate()) {
        const u = c.measurementUnit || nn;
        if (e !== nn && u !== nn) {
          const p = u / s, m = new Q().setScaleComponent(
            p,
            p,
            p
          );
          o = Q.multiply(m, o);
        }
        h = o.transformBox(h), l.addBox(h);
      }
    }
    return l;
  }
  static parseBounding(t, e) {
    const i = ni.invalid();
    for (const s of t.treeInfos)
      for (const r of s.kids) {
        const o = this._parseBounding(r, e);
        i.addBox(o);
      }
    return i;
  }
  constructor() {
  }
}
const Ho = class {
  constructor(n, t, e, i, s, r, o, a) {
    this.headerVersion = n, this._rootAssemblyDataKey = t, this.isDrawing = e, this.isMeasurable = i, this.originalFileName = s, this.originalFileType = r, this.doublePrecisionMatrices = o, this.assemblyDataVersion = a;
  }
  supportsAttributeBits() {
    return this.headerVersion >= 5;
  }
  rootAssemblyDataKey() {
    return console.assert(this._rootAssemblyDataKey !== El.Invalid), this._rootAssemblyDataKey;
  }
  // double precision matrices
  static parseBinary(n) {
    if (n.length === 0)
      return null;
    const t = new jo(new rr(null, n)), e = new Bd();
    if (e.parseBits1(t), !e.hasBits1(Qt.Header))
      return null;
    const i = t.parseAssemblyDataHeaderVersion();
    if (i > Ho._maxHeaderVersion)
      throw new pr(`Unknown header version: ${i}`);
    let s = [];
    if (i >= 4 && (s = t.parseAssemblyDataVersion(3), !Ko(vh, s)))
      throw new pr(`Invalid version: ${yd(s)}`);
    e.parseBits2(t);
    const r = t.parseDataKey(), o = t.parseBoolean();
    let a, l = "", c = Rr.Unknown, h = !1;
    return i >= 1 ? a = t.parseBoolean() : a = !0, i >= 3 && (h = e.hasBits2(Un.DoublePrecisionMatrices), e.hasBits2(Un.OriginalName) && (l = t.parseCString()), c = t.parseIndex_32()), new Ho(
      i,
      r,
      o,
      a,
      l,
      c,
      h,
      s
    );
  }
};
let _n = Ho;
_n._maxHeaderVersion = 5;
_n.dynamic = new Ho(
  Ho._maxHeaderVersion,
  El.Invalid,
  !1,
  // isDrawing
  !1,
  // isMeasurable
  "",
  // originalFileName
  Rr.Unknown,
  !0,
  []
);
class rr {
  constructor(t, e) {
    this.header = t, this.bytes = e;
  }
}
class xi {
  constructor(t, e, i, s) {
    this._productOccurrences = null, this._relationship = [], this._bimNodeIdMap = /* @__PURE__ */ new Map(), this._bimInfos = [], console.assert(i !== void 0), console.assert(i === ve.Local == (s === Ji.Local)), this._attachContext = e, this._inclusionKey = i, this._modelKey = s;
    let r = e.getReservedNodeIdOffset();
    r !== null ? e.forgetReservedNodeIdOffset() : r = t.newNodeIdOffset(), this._nodeIdOffset = r, t.registerInclusionContext(this);
  }
  split(t, e) {
    return new xi(t, e, this._inclusionKey, this._modelKey);
  }
  getIdOffset() {
    return this._nodeIdOffset;
  }
  toRuntimeId(t) {
    return console.assert(Qr(t)), t + this._nodeIdOffset;
  }
  getInclusionKey() {
    return this._inclusionKey;
  }
  getModelKey() {
    return this._modelKey;
  }
  getParent() {
    return this._attachContext;
  }
  /** Naming clarity for when you know you want it as the attach-context */
  getAttachContext() {
    return this._attachContext;
  }
  addProductOccurrence(t) {
    console.assert(t.getParent() === this), this._productOccurrences = Mi(this._productOccurrences, t);
  }
  getChildren() {
    return se(this._productOccurrences);
  }
  removeProductOccurrence(t) {
    let e = se(this._productOccurrences);
    const i = e.length;
    return e = e.filter((s) => s !== t), e.length === 0 ? this._productOccurrences = null : this._productOccurrences = zi(e), e.length < i;
  }
  purgeContents() {
    const t = [], e = se(this._productOccurrences);
    for (const i of e) {
      const s = i.purgeContents();
      t.push(s);
    }
    return this._productOccurrences = null, this._relationship.length = 0, zt(t);
  }
  hasChildren() {
    return this._productOccurrences !== null;
  }
  isLoaded() {
    if (this._productOccurrences instanceof Yt)
      return this._productOccurrences.isLoaded();
    if (this._productOccurrences === null)
      return !0;
    for (const t of this._productOccurrences)
      if (!t.isLoaded())
        return !1;
    return !0;
  }
  addRelationship(t) {
    this._relationship.push(t);
  }
  getRelationships() {
    return this._relationship;
  }
  addBimInfos(t) {
    this._bimInfos.push(t);
  }
  getBimInfos() {
    return this._bimInfos;
  }
  addBimIdToMap(t, e) {
    this._bimNodeIdMap.set(t, e);
  }
  getRuntimeNodeFromBimId(t) {
    const e = this._bimNodeIdMap.get(t);
    return e !== void 0 ? e : null;
  }
}
class hi {
  constructor(t, e, i, s, r) {
    this._reservedNodeIdOffset = null, this._inclusionContexts = null, this._originalFileName = "", this._originalFileType = Vo.Unknown, this._assemblyDataVersion = [], this._genericTypeMaps = null, console.assert(s !== Hn.Invalid), this._remapper = t, this._attachScope = e, this._attachedInvisibly = i, this._masterModelKey = s, this._parent = r;
  }
  async getRootNodeMetaData(t) {
    if (this._masterModelKey === Hn.Invalid)
      return null;
    const e = t.getAbstractScEngine(), i = this._masterModelKey, s = 1, r = await e.safeGetMetaData(i, s);
    if (r !== null) {
      const o = t.tryParseHeader(r);
      if (o === null)
        return new rr(null, r);
      const a = await o;
      this._originalFileName = a.originalFileName, this._originalFileType = a.originalFileType, this._assemblyDataVersion = a.assemblyDataVersion;
      const l = await e.safeGetMetaData(i, a.rootAssemblyDataKey());
      return l !== null ? new rr(a, l) : null;
    }
    return null;
  }
  getAttachScope() {
    return this._attachScope;
  }
  attachedInvisibly() {
    return this._attachedInvisibly;
  }
  getMasterModelKey() {
    return this._masterModelKey;
  }
  addInclusionContext(t) {
    console.assert(t.getParent() === this), this._inclusionContexts = Mi(this._inclusionContexts, t);
  }
  getRemapper() {
    return this._remapper;
  }
  getParent() {
    return this._parent;
  }
  getChildren() {
    const t = this._inclusionContexts;
    if (t === null)
      return [];
    if (Array.isArray(t)) {
      console.assert(t.length > 0);
      const e = t[0].getChildren();
      for (let i = 1; i < t.length; ++i) {
        const s = t[i];
        e.push(...s.getChildren());
      }
      return e;
    } else
      return t.getChildren();
  }
  getInclusionContexts() {
    return se(this._inclusionContexts);
  }
  split(t, e, i) {
    return new hi(
      this._remapper,
      t,
      e,
      this._masterModelKey,
      i
    );
  }
  hasChildren() {
    return this._inclusionContexts !== null;
  }
  removeProductOccurrence(t) {
    let e = null, i = se(this._inclusionContexts);
    for (const s of i)
      if (s.removeProductOccurrence(t)) {
        e = s;
        break;
      }
    return e === null ? !1 : (i = i.filter((s) => s.hasChildren()), i.length === 0 ? this._inclusionContexts = null : this._inclusionContexts = zi(i), !0);
  }
  purgeContents() {
    const t = [], e = se(this._inclusionContexts);
    for (const i of e) {
      const s = i.purgeContents();
      t.push(s);
    }
    return this._inclusionContexts = null, zt(t);
  }
  isLoaded() {
    if (this._inclusionContexts instanceof xi)
      return this._inclusionContexts.isLoaded();
    if (this._inclusionContexts === null)
      return !0;
    for (const t of this._inclusionContexts)
      if (!t.isLoaded())
        return !1;
    return !0;
  }
  setReservedNodeIdOffset(t) {
    console.assert(this._reservedNodeIdOffset === null), this._reservedNodeIdOffset = t;
  }
  getReservedNodeIdOffset() {
    return this._reservedNodeIdOffset;
  }
  forgetReservedNodeIdOffset() {
    console.assert(this._reservedNodeIdOffset !== null), this._reservedNodeIdOffset = null;
  }
  getOriginalFileName() {
    return this._originalFileName;
  }
  getOriginalFileType() {
    return this._originalFileType;
  }
  setGenericTypeMaps(t) {
    this._genericTypeMaps = t;
  }
  getGenericTypeMaps() {
    return this._genericTypeMaps;
  }
  getAssemblyDataVersion() {
    return this._assemblyDataVersion;
  }
}
function Of(n) {
  if (typeof n == "string")
    throw new re();
  return n;
}
class on {
  constructor(t, e, i) {
    this._handledExternalModels = null, this._attachContexts = null, this._registeredScsModelKeys = /* @__PURE__ */ new Map(), this._layerIdMap = new zd(), this._parent = t, this._scsBufferCache = i;
  }
  /**
   * Returns whether or not an authored external model should be handled or not.
   */
  handleExternalModel(t, e, i) {
    const s = e.getInclusionKey(), r = `${nc(i)} ${nc(
      s
    )} ${nc(t)}`;
    return this._handledExternalModels === null && (this._handledExternalModels = /* @__PURE__ */ new Set()), this._handledExternalModels.has(r) ? !1 : (this._handledExternalModels.add(r), !0);
  }
  getParent() {
    return this._parent;
  }
  addAttachContext(t) {
    this._attachContexts = Mi(this._attachContexts, t);
  }
  getChildren() {
    const t = this._attachContexts;
    if (t === null)
      return [];
    if (Array.isArray(t)) {
      console.assert(t.length > 0);
      const e = t[0].getChildren();
      for (let i = 1; i < t.length; ++i) {
        const s = t[i];
        e.push(...s.getChildren());
      }
      return e;
    } else
      return t.getChildren();
  }
  getAttachContexts() {
    return this._attachContexts === null ? [] : Array.isArray(this._attachContexts) ? this._attachContexts : [this._attachContexts];
  }
  hasChildren() {
    return this._attachContexts !== null;
  }
  removeProductOccurrence(t) {
    let e = null, i = se(this._attachContexts);
    for (const s of i)
      if (s.removeProductOccurrence(t)) {
        e = s;
        break;
      }
    return e === null ? !1 : (i = i.filter((s) => s.hasChildren()), i.length === 0 ? this._attachContexts = null : this._attachContexts = zi(i), !0);
  }
  purgeContents() {
    const t = [], e = se(this._attachContexts);
    for (const i of e) {
      const s = i.purgeContents();
      t.push(s);
    }
    return this._attachContexts = null, zt(t);
  }
  isLoaded() {
    if (this._attachContexts instanceof hi)
      return this._attachContexts.isLoaded();
    if (this._attachContexts === null)
      return !0;
    for (const t of this._attachContexts)
      if (!t.isLoaded())
        return !1;
    return !0;
  }
  /**
   * This should not be called more than once per `ExternalModelName` in a given `LoadContext`.
   */
  initializeScsModelKeysOf(t) {
    console.assert(this._registeredScsModelKeys.get(t) === void 0), this._registeredScsModelKeys.set(t, gh());
  }
  /**
   * Gets the model keys of an SCS model by its external name from a shattered XML file.
   *
   * Returns:
   *  - `null` if `initializeScsModelKeysOf` was not called for the given model.
   *  - `TrackedOpenPromise<null>` if the model has no attachment data.
   *  - `TrackedOpenPromise<ModelKey[]>` if the model has attachment data.
   */
  getScsModelKeysOf(t) {
    const e = this._registeredScsModelKeys.get(t);
    return e === void 0 ? null : e;
  }
  markAsFirstLoad() {
    console.assert(this._isFirstLoad === void 0), this._isFirstLoad = !0;
  }
  isFirstLoad() {
    return this._isFirstLoad === !0;
  }
  async toScsBuffer(t, e) {
    const i = Si.create(async () => {
      const s = await e(t);
      return Of(s);
    });
    return this._scsBufferCache === null ? i : this._scsBufferCache.load(t, i);
  }
  // This gets called on both successful and erroneous loads.
  onLoadComplete() {
    this._scsBufferCache = null;
  }
  addLayerIdToMap(t, e) {
    this._layerIdMap.set(t, e);
  }
  getAuthoredLayerId(t) {
    const e = this._layerIdMap.getRight(t);
    return e !== void 0 ? e : null;
  }
  getRuntimeLayerId(t) {
    const e = this._layerIdMap.getLeft(t);
    return e !== void 0 ? e : null;
  }
  // Maps runtime layer IDs to authored layer IDs
}
function Uo(n) {
  let t = Xi.getIdentity(), e = n;
  for (; e !== null; )
    if (e instanceof Pi) {
      const i = e.getLocalTransform();
      i && (t = Xi.multiply(t, i)), e instanceof Ei ? e = null : e = e.getParent();
    } else if (e instanceof xi)
      e = e.getParent();
    else if (e instanceof hi)
      e = e.getParent();
    else if (e instanceof on)
      e = e.getParent();
    else
      return t;
  return t;
}
function Jd(n) {
  let t = n;
  for (; ; )
    if (t instanceof Pi)
      if (t instanceof $r)
        t = t.getParent();
      else
        return t;
    else if (t instanceof on)
      t = t.getParent();
    else if (t instanceof xi)
      t = t.getParent();
    else if (t instanceof hi)
      t = t.getParent();
    else {
      if (t === null)
        return null;
      console.assert(!1), t = t.getInclusionContext();
    }
}
function ks(n) {
  return n instanceof $r || n instanceof Yt ? n.isOutOfHierarchy() : !1;
}
function Af(n) {
  return n instanceof Yt || n instanceof gi || n instanceof Ri ? n.getBranchVisibility() : n.isVisible() ? Pt.Shown : Pt.Hidden;
}
function Df(n) {
  if (n instanceof Yt)
    return n.isADrawingSheetNode() ? At.DrawingSheet : n.hasBodyInstances() ? At.PartInstance : At.AssemblyNode;
  if (n instanceof Ei)
    return At.Part;
  if (n instanceof In)
    return At.PmiBody;
  if (n instanceof ms)
    return At.ViewFrame;
  if (n instanceof Ge)
    return At.BodyInstance;
  if (n instanceof Ke)
    switch (n.getBodyType()) {
      case Cr.BRep:
        return At.BrepBody;
      case Cr.Tessellation:
        return At.TessBody;
      case Cr.Wireframe:
        return At.WireBody;
      case Cr.PointCloud:
        return At.PointsBody;
      case Cr.Unknown:
      default:
        return At.Body;
    }
  else
    return n instanceof gi ? At.Pmi : At.CadView;
}
function Qo(n) {
  const t = n.getGenericTypeId();
  if (t !== null) {
    const i = ke(n).getGenericTypeMaps();
    if (i !== null)
      return i.getRight(t) || null;
  }
  return null;
}
function Ne(n) {
  let t = n;
  for (; ; )
    if (t instanceof Pi)
      t = t.getParent();
    else {
      if (t instanceof xi)
        return t;
      if (t instanceof In)
        t = t.getParent();
      else if (t instanceof ms)
        t = t.getParent();
      else
        return t.getInclusionContext();
    }
}
function gn(n) {
  let t = n;
  for (; ; )
    if (t instanceof hi)
      t = t.getParent();
    else {
      if (t instanceof on)
        return t;
      t instanceof Pi || t instanceof xi ? t = t.getParent() : t = t.getInclusionContext();
    }
}
function ke(n) {
  let t = n;
  for (; ; )
    if (t instanceof xi)
      t = t.getParent();
    else {
      if (t instanceof hi)
        return t;
      if (t instanceof Pi)
        t = t.getParent();
      else if (t instanceof on) {
        const e = t.getParent();
        if (e === null)
          throw new re();
        t = e;
      } else
        t = t.getInclusionContext();
    }
}
function hu(n) {
  let t = null, e = n;
  for (; ; )
    if (e instanceof Yt)
      t = e, e = e.getParent();
    else if (e instanceof Pi)
      e = e.getParent();
    else if (e instanceof xi) {
      if (t === null)
        throw new re();
      return t;
    } else
      e = e.getInclusionContext();
}
function Pn(n) {
  let t = n;
  for (; ; ) {
    if (t instanceof Yt)
      return t;
    if (t instanceof hi)
      t = t.getParent();
    else if (t instanceof xi)
      t = t.getParent();
    else if (t instanceof on) {
      const e = t.getParent();
      if (e === null)
        return null;
      t = e;
    } else if (t instanceof $r)
      t = t.getParent();
    else if (t instanceof gi)
      t = t.getParent();
    else if (t instanceof Ri)
      t = t.getParent();
    else
      return console.assert(!1), null;
  }
}
const zf = "IFCCOLUMN", Bf = "IFCCOVERING", Jf = "IFCCURTAINWALL", jf = "IFCDOOR", Hf = "IFCRAMP", Uf = "IFCROOF", Qf = "IFCSLAB", qf = "IFCSTAIR", $f = "IFCSTAIRFLIGHT", t_ = "IFCTRANSPORTELEMENT", e_ = "IFCWALL", i_ = "IFCWALLSTANDARDCASE", n_ = "IFCWINDOW";
function s_(n, t) {
  let e = n;
  for (; e !== null; ) {
    if (e.getName() === t || Qo(e) === t)
      return !0;
    e = Pn(e.getParent());
  }
  return !1;
}
function r_(n) {
  switch (n) {
    case zf:
    case Jf:
    case qf:
    case $f:
    case e_:
    case i_:
    case n_:
      return ei.Wall | ei.Floor;
    case Bf:
    case Hf:
    case Uf:
    case Qf:
      return ei.Floor;
    case jf:
    case t_:
      return ei.Door | ei.Floor;
  }
  return ei.None;
}
async function o_(n, t, e, i) {
  const s = await t.getNodeOrRepItem(e);
  if (s === null || s instanceof Ke || s instanceof Ei)
    return ei.None;
  let r = Qo(s);
  if (r === null) {
    if (i === null)
      return ei.None;
    const a = await s.getAttributes();
    for (const l of a)
      if (l.getTitle() === i) {
        r = l.getValue();
        break;
      }
    if (r === null)
      return ei.None;
  }
  const o = n(r);
  return o !== ei.None ? o : ei.None;
}
async function a_(n) {
  const t = [], e = {
    enterAnyBody: (i) => {
      i instanceof Ge && t.push(i);
    }
  };
  return await yi.walk(e, n, ft.None), t;
}
async function l_(n) {
  const t = await a_(n), e = /* @__PURE__ */ new Set();
  for (const i of t) {
    const s = i.getParent();
    e.add(s);
  }
  return us(e);
}
async function c_(n, t, e, i) {
  const s = [];
  for (const c of e) {
    const h = o_(
      n,
      t,
      c,
      i
    );
    s.push(h);
  }
  const r = await Promise.all(s), o = [], a = [], l = [];
  for (let c = 0; c < e.length; ++c) {
    const h = e[c], u = r[c];
    u !== ei.None && (u & ei.Floor && o.push(h), u & ei.Wall && a.push(h), u & ei.Door && l.push(h));
  }
  return {
    floors: o,
    walls: a,
    doors: l
  };
}
function ac(n) {
  const t = [];
  for (const e of n) {
    const i = e.getBodyInstances();
    for (const s of i) {
      const r = s.getInstanceInc();
      t.push(r[0], r[1]);
    }
  }
  return t;
}
async function h_(n, t, e, i, s) {
  const r = await l_(i), o = await c_(
    n,
    e,
    r,
    s
  ), a = ac(o.floors);
  t.registerBimInstances(a, Co.Floor);
  const l = ac(o.walls);
  t.registerBimInstances(l, Co.Wall);
  const c = ac(o.doors);
  t.registerBimInstances(c, Co.Door);
}
async function u_(n, t, e) {
  const i = [], s = [], r = {
    enterAnyBody: (c) => {
      if (c instanceof Ge && !c.isOutOfHierarchy()) {
        i.push(c);
        const h = c.getInstanceInc();
        s.push(h[0], h[1]);
      }
    }
  };
  await yi.walk(r, n, ft.None);
  const o = /* @__PURE__ */ new Map(), a = await t.getPartColor(s, e), l = a.length;
  console.assert(l === i.length);
  for (let c = 0; c < l; ++c) {
    const h = a[c];
    h !== null && o.set(i[c].getRuntimeId(), h);
  }
  return o;
}
function Or(n) {
  return [n.x, n.y, n.z];
}
function d_(n) {
  return [Math.abs(n[0]), Math.abs(n[1]), Math.abs(n[2])];
}
function m_(n, t) {
  return [n[0] * t[0], n[1] * t[1], n[2] * t[2]];
}
function p_(n, t) {
  return [n[0] + t[0], n[1] + t[1], n[2] + t[2]];
}
function g_(n, t) {
  return [n[0] - t[0], n[1] - t[1], n[2] - t[2]];
}
function f_(n, t) {
  return [n[0] + t[0], n[1] + t[1], n[2] + t[2], n[3] + t[3]];
}
function kc(n, t) {
  return [n[0] - t[0], n[1] - t[1], n[2] - t[2], n[3] - t[3]];
}
function rs(n, t) {
  return n[0] * t[0] + n[1] * t[1] + n[2] * t[2];
}
function Sh(n) {
  const t = n[0], e = n[1], i = n[2];
  return t * t + e * e + i * i;
}
function uu(n) {
  return Math.sqrt(Sh(n));
}
function __(n, t) {
  return [n * t[0], n * t[1], n * t[2]];
}
function lc(n) {
  return [n.x, n.y, n.z, n.w];
}
function go(n, t) {
  const e = n.m, i = t;
  return [e[i], e[i + 4], e[i + 8], e[i + 12]];
}
function du(n) {
  const t = n[0], e = n[1], i = n[2], s = n[3];
  return t * t + e * e + i * i + s * s;
}
function cc(n, t) {
  return [n * t[0], n * t[1], n * t[2], n * t[3]];
}
function y_(n, t, e) {
  let i = rs(n, e) + e[3];
  return i *= i, i < 1e-5 && (i = 1e-5), t / i;
}
const Ni = 400, or = "_empty", jd = en;
function Oa(n) {
  return n;
}
class Yo {
  /** @hidden */
  constructor(t, e) {
    this._pmiColor = it.black(), this._pmiColorOverride = !1, this._viewAxes = new mu(), this._viewAxesSet = !1, this._engine = t, this._callbackManager = e, this._callbackManager.bind({
      _firstModelLoaded: async (i) => {
      },
      _resetAssemblyTreeBegin: async () => {
        this._viewAxes = new mu(), this._viewAxesSet = !1;
      }
    });
  }
  /** @hidden */
  _setModelStructure(t) {
    console.assert(this._modelStructure === void 0), this._modelStructure = t;
  }
  /**
   * Sets the up and front vectors for the model coordinate system.
   * Both the upVector and frontVector must be unique, cardinal axes.
   * @param frontVector
   * @param upVector
   */
  setViewAxes(t, e) {
    if (t.isAxis() && e.isAxis() && !t.equals(e))
      this._viewAxes.frontVector = t, this._viewAxes.upVector = e, this._callbackManager.trigger("viewAxes", t, e), this._viewAxesSet = !0;
    else
      throw new Mt("The upVector and frontVector must be unique, cardinal axes.");
  }
  /**
   * Gets whether there has been a successful call to setViewAxes.
   */
  viewAxesHaveBeenSet() {
    return this._viewAxesSet;
  }
  /**
   * @returns the up and front vectors for the model coordinate system.
   */
  getViewAxes() {
    return this._viewAxes;
  }
  /**
   * Gets the world space bounding box for the model.
   * @returns Promise that resolves with a Box representing the world space bounding box of the model.
   */
  async getModelBounding(t, e, i = !1) {
    let s = new ni();
    try {
      s = await this._engine.getModelBounding(
        t,
        e,
        i
      );
    } catch (r) {
      let o = !1;
      $s(r) && gd(r) === dh.Cancelled && (o = !0), console.assert(o);
    }
    return s;
  }
  /**
   * Gets the world space bounding box for the model. This does not take node visibility into account.
   * @returns Promise that resolves with a Box representing the world space bounding box of the model.
   */
  async getLooseBounding() {
    return this._engine.getLooseBounding();
  }
  /** @hidden */
  _allowNodeDeletion(t) {
    return this._modelStructure.allowNodeDeletion(t);
  }
  /** @hidden */
  _preventNodeDeletion(t) {
    return this._modelStructure.preventNodeDeletion(t);
  }
  /** @hidden */
  _preventMeshDeletion(t) {
    return console.assert(t[0] === Ji.Local), this._modelStructure.preventMeshDeletion(t[1]);
  }
  /** @hidden */
  _getNodeFromInstanceInc(t, e, i, s) {
    return this._modelStructure.getNodeFromInstanceInc(
      t,
      e,
      i,
      s
    );
  }
  /**
   * Gets the world space bounding box for a list of nodes.
   * @param nodeIds IDs of the nodes for which you wish to get the bounding box.
   * @param config Allows fine control of what body types to compute the bounding against. If not provided, all body types are considered.
   * @returns Promise that resolves with the world space bounding box for the given IDs.
   */
  getNodesBounding(t, e) {
    let i = bt.All, s = !1, r = !1;
    return e !== void 0 && (e.bodyInstance === !1 && (i &= ~bt.BodyInstance), e.pmiBody === !1 && (i &= ~bt.PmiBody), e.viewFrame === !1 && (i &= ~bt.ViewFrame), e.ignoreInvisible && (s = !0), e.tightBounding && (r = !0)), this._modelStructure.getBounding(t, i, s, r);
  }
  /**
   * Gets the world space bounding box for a node including any effects (explosion, camera suppression, etc).
   * Note: This function can have performance implications when used on nodes with many children.
   * @param nodeId ID of the node for which you wish to get the bounding box.
   * @returns Promise that resolves with the world space bounding box for the given ID.
   */
  async getNodeRealBounding(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      [t],
      bt.All,
      ft.None
    );
    if (e.length === 0)
      throw new Mt("Cannot get bounding of node without geometry.");
    return this._engine.getDrawnPartsBounding(e);
  }
  /**
   * Sets the visibility for a given set of nodes.
   * @param mapping The mapping of node IDs to boolean value indicating the visibility setting for that node.
   * @param initiallyHiddenStayHidden Controls whether or not initially hidden geometries stay hidden. Default behavior is driven by [[setBehaviorInitiallyHidden]].
   * @param mode an optional walk mode to use while traversing the model tree
   * @returns Promise that resolves when the operation has completed.
   */
  setNodesVisibilities(t, e = null) {
    return t = nu(t), this._modelStructure.setVisibilitiesByMap(
      t,
      e !== null ? e : void 0
    );
  }
  /**
   * Sets visibility for a given list of nodes.
   * @param nodeIds The node IDs whose visibilities will be set.
   * @param visibility If true, nodes will be shown. If false, they will be hidden.
   * @param initiallyHiddenStayHidden Controls whether or not initially hidden geometries stay hidden. Default behavior is driven by [[setBehaviorInitiallyHidden]].
   * @param mode an optional walk mode to use while traversing the model tree
   * @returns Promise that resolves when the operation has completed.
   */
  setNodesVisibility(t, e, i = null) {
    return this._modelStructure.setVisibilitiesByValue(
      t,
      e,
      i
    );
  }
  setBodyNodesVisibility(t, e) {
    const i = this._modelStructure.lookupAnyTreeNode(t);
    if (i === null)
      throw new sn(t);
    const s = typeof e == "boolean" ? (r) => e : e;
    return this._modelStructure.setBodyNodesVisibility(
      i,
      (r) => s(r.getRuntimeId())
    );
  }
  /**
   * Resets visibility for all nodes in the model.
   * @returns Promise that resolves when the operation has completed.
   */
  resetNodesVisibility() {
    return this.isDrawing() ? this._callbackManager.promiseTrigger("_resetDrawing", null) : this._modelStructure.resetAllVisibilities();
  }
  /**
   * Returns a defaultVisibility boolean value and a visibilityException set of NodeIds.
   * defaultVisibility will be true if there are more nodes visible than hidden, and false otherwise.
   * If defaultVisibility is true, set of nodes that are hidden, if false, nodes that are visible.
   */
  async getVisibilityState(t) {
    const e = this._modelStructure.lookupAnyTreeNode(t);
    if (e === null)
      throw new sn(t);
    return Vd(e);
  }
  /**
   * Resets transform for all nodes in the model.
   * @returns Promise that resolves when the operation has completed.
   */
  resetNodesTransform() {
    return this._modelStructure.resetAllTransforms();
  }
  /**
   * Resets the state of the model to its default
   * @returns Promise that resolves when the operation has completed.
   */
  reset() {
    return this.resetModelOpacity(), this._modelStructure.reset();
  }
  /**
   * Remove all nodes, CAD views, configurations, and sheets from the model.
   *
   * If you intend to load additional models via the `loadSubtree` family
   * of methods, you should wait on the resolution of this promise before doing so.
   */
  clear() {
    return this._modelStructure.clear();
  }
  /**
   * Sets the color on the faces for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to set
   * @param color the color to set
   * @returns Promise that resolves when this operation has completed.
   */
  setNodesFaceColor(t, e) {
    return this._setNodesFaceColor(t, e), Promise.resolve();
  }
  /**
   * Sets the ambient color on the faces for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to set
   * @param color the color to set
   */
  setNodesAmbientColor(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    i.length > 0 && this._engine.setPartAmbientColor(i, vt.Faces, e);
  }
  /**
   * Sets the ambient mix on the faces for a given list of nodes.
   * The mix is between the material ambient light and the global ambient light,
   * with 1.0 representing full material ambient mix and 0.0 representing full global
   * ambient light.
   * @param nodeIds IDs of nodes whose color to set
   * @param value the decimal value to set, between 0 and 1
   */
  setNodesAmbientMix(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    i.length > 0 && this._engine.setPartAmbientMix(i, vt.Faces, e);
  }
  /**
   * Sets the emissive color on the faces for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to set
   * @param color the color to set
   */
  setNodesFaceEmissiveColor(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    i.length > 0 && this._engine.setPartEmissiveColor(i, vt.Faces, e);
  }
  /**
   * Resets the emissive color on the faces for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to reset
   */
  unsetNodesFaceEmissiveColor(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    e.length > 0 && this._engine.unsetPartEmissiveColor(e, vt.Faces);
  }
  /**
   * Sets the specular color on the faces for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to set
   * @param color the color to set
   */
  setNodesFaceSpecularColor(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    i.length > 0 && this._engine.setPartSpecularColor(i, vt.Faces, e);
  }
  /**
   * Resets the specular color on the faces for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to reset
   */
  unsetNodesFaceSpecularColor(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    e.length > 0 && this._engine.unsetPartSpecularColor(e, vt.Faces);
  }
  /**
   * Sets the specular intensity on the faces for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to set
   * @param value the value to set
   */
  setNodesFaceSpecularIntensity(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    i.length > 0 && this._engine.setPartSpecularIntensity(i, vt.Faces, e);
  }
  /**
   * Resets the specular intensity on the faces for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to set
   */
  unsetNodesFaceSpecularIntensity(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    e.length > 0 && this._engine.unsetPartSpecularIntensity(e, vt.Faces);
  }
  _setNodesFaceColor(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    i.length > 0 && this._engine.setPartColor(i, vt.Faces, e);
  }
  _unsetNodesColor(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    i.length > 0 && this._engine.unsetPartColor(i, e);
  }
  /**
   * Unsets the color on the faces for a given list of nodes.
   * @param nodeIds IDs of nodes to modify
   * @param color the color to set
   * @returns Promise that resolves when this operation has completed.
   */
  unsetNodesFaceColor(t) {
    return this._unsetNodesColor(t, vt.Faces), Promise.resolve();
  }
  /**
   * Sets the color on the lines/edges for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to set
   * @param color the color to set
   * @returns Promise that resolves when this operation has completed.
   */
  setNodesLineColor(t, e) {
    return this._setNodesLineColor(t, e), Promise.resolve();
  }
  _setNodesLineColor(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    i.length > 0 && this._engine.setPartColor(i, vt.Lines, e);
  }
  /**
   * Unsets the color on the lines for a given list of nodes.
   * @param nodeIds IDs of nodes to modify
   * @param color the color to set
   * @returns Promise that resolves when this operation has completed.
   */
  unsetNodesLineColor(t) {
    return this._unsetNodesColor(t, vt.Lines), Promise.resolve();
  }
  /**
   * Sets whether the supplied nodes should appear highlighted. When a node is highlighted,
   * the highlight color will override any color previously set on the model.
   *
   * *Tip:* An easy way to unhighlight the entire model is to call [[setNodesHighlighted]]
   * on the root node of the model:
   * ```
   * hwv.model.setNodesHighlighted([hwv.model.getAbsoluteRootNode()], false);
   * ```
   * (In this case, `hwv` is your instance of [[WebViewer]].)
   *
   * @param nodeIds array of IDs for this operation.
   * @param highlighted value indicating whether the supplied nodes should be highlighted.
   * @returns Promise that resolves when this operation has completed.
   */
  setNodesHighlighted(t, e) {
    if (t.length === 0)
      return Promise.resolve();
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.LoadedNodesOnly
    );
    return i.length > 0 && this._engine.highlightParts(i, e), Promise.resolve();
  }
  /**
   * Returns whether the supplied nodes have been highlighted with [[setNodesHighlighted]].
   * @param nodeIds the list of nodes to be queried
   */
  getNodesHighlighted(t) {
    const e = this._getInstanceIncsFromLeafNodes(t);
    return e.length > 0 ? this._engine.getPartHighlighted(e) : Promise.resolve([]);
  }
  /**
   * Sets colors for a given set of nodes.
   *
   * @param params object mapping node IDs to color to set for that node
   * @param alsoApplyToWireframe change or not lines color
   * @param alsoApplyToPoints change or not points color
   * @returns Promise that resolves when this operation has completed.
   */
  setNodesColors(t, e = !1, i = !1) {
    const s = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Map(), o = (a, l) => {
      const c = this._modelStructure.lookupAnyTreeNode(a);
      if (c !== null) {
        const h = zo(
          c,
          bt.All,
          !1,
          s,
          ft.None
        );
        if (h.length > 0) {
          const u = (l.r << 16) + (l.g << 8) + l.b, p = r.get(u);
          p ? r.set(u, p.concat(h)) : r.set(u, h);
        }
      }
    };
    if (t instanceof Map)
      t.forEach((a, l) => {
        o(l, a);
      });
    else {
      const a = Object.keys(t);
      for (const l of a) {
        const c = parseInt(l, 10);
        o(c, t[c]);
      }
    }
    return r.forEach((a, l) => {
      const c = new it(l >> 16, (l & 65280) >> 8, l & 255);
      this._engine.setPartColor(a, vt.Faces, c), e && this._engine.setPartColor(a, vt.Lines, c), i && this._engine.setPartColor(a, vt.Points, c);
    }), Promise.resolve();
  }
  /**
   * Gets an array of PMI topology references linking a PMI node to a body element, like a face or an edge.
   * @param pmiNodeId the ID of the PMI node.
   */
  getPmiTopologyReferences(t) {
    const e = [], i = (r, o, a) => {
      const l = new v_();
      return l.bodyId = r, l.subElementType = o, l.subElementIndex = a, l;
    }, s = this._modelStructure.getPmiTopologyReferences(t);
    if (s !== null)
      for (const r of s) {
        const o = r.body.getRuntimeId(), a = r.faceIds;
        for (const c of a)
          e.push(i(o, $o.Face, c));
        const l = r.edgeIds;
        for (const c of l)
          e.push(i(o, $o.Edge, c));
      }
    return e.length === 0 ? null : e;
  }
  /**
   * Returns names and ids of all the PMIs available in the scene
   * @returns a map associating PMI IDs to PMI names
   */
  getPmis() {
    return this._modelStructure.getPmis();
  }
  /**
   * Returns the type of a given PMI
   * @param idPMI ID of the PMI
   * @returns Type of the PMI (Dimension, Datum, GD&T...)
   */
  getPmiType(t) {
    return this._modelStructure.getPmiType(t);
  }
  /**
   * Returns the subtype of a given PMI
   * @param idPMI ID of the PMI
   * @returns Subtype of the PMI (Dimension distance, Datum target, GD&T fcf...)
   */
  getPmiSubtype(t) {
    return this._modelStructure.getPmiSubType(t);
  }
  /**
   * Saves a PMI override color
   * @param color the override color
   */
  setPmiColor(t) {
    this._pmiColor.assign(t);
  }
  /**
   * Returns the set PMI override color  (if none is set, defaults to black)
   * @returns color
   */
  getPmiColor() {
    return this._pmiColor.copy();
  }
  /**
   * Takes a boolean value and either enables the set PMI override color or resets all PMI colors to their default
   * @returns Promise that resolves when this operation has completed.
   */
  setPmiColorOverride(t, e) {
    return this._pmiColorOverride = t, t ? this._modelStructure.setPmiColor(this._pmiColor, e) : this._modelStructure.resetPmiColor(e), Promise.resolve();
  }
  /**
   * @returns a boolean value indicating the status of the PMI override color.
   */
  getPmiColorOverride() {
    return this._pmiColorOverride;
  }
  /**
   * Computes the distance between two bodies
   * @param partId1 id for the part which the first face belongs to
   * @param partId2 id for the part which the second face belongs to
   * @returns a promise that resolves with a Markup.Measure.FaceFaceDistanceItem when the operation completes
   */
  computeMinimumBodyBodyDistance(t, e) {
    const i = this._modelStructure.lookupAnyBody(t);
    if (i === null)
      throw new Vi(t, li.AnyBody);
    const s = this._modelStructure.lookupAnyBody(e);
    if (s === null)
      throw new Vi(e, li.AnyBody);
    const r = i.getInstanceInc(), o = s.getInstanceInc();
    return this._engine.computeMinimumBodyBodyDistance(r, o);
  }
  /**
   * Computes the distance between two faces
   * @param partId1 id for the part which the first face belongs to
   * @param faceId1 id for the face in the first part
   * @param partId2 id for the part which the second face belongs to
   * @param faceId2 id for the face in the second part
   * @returns a promise that resolves with a Markup.Measure.FaceFaceDistanceItem when the operation completes
   */
  computeMinimumFaceFaceDistance(t, e, i, s) {
    const r = this._modelStructure.lookupAnyBody(t);
    if (r === null)
      throw new Vi(t, li.AnyBody);
    const o = this._modelStructure.lookupAnyBody(i);
    if (o === null)
      throw new Vi(i, li.AnyBody);
    const a = r.getInstanceInc(), l = o.getInstanceInc();
    return this._engine.computeMininimumFaceFaceDistance(
      [a[0], a[1]],
      e,
      [l[0], l[1]],
      s
    );
  }
  /**
   * Computers the minimum distance between a face and a ray.
   * @param nodeId id of the node the face belongs to
   * @param faceId id of the face in the node
   * @param ray the ray to test against
   * @returns a promise that resolves with a Markup.Measure.FaceFaceDistanceItem when the operation completes
   */
  computeMinimumFaceRayDistance(t, e, i) {
    const s = this._modelStructure.lookupAnyBody(t);
    if (s === null)
      throw new Vi(t, li.AnyBody);
    const r = s.getInstanceInc();
    return this._engine.computeMinimumFaceRayDistance(r, e, i);
  }
  /**
   * Computers the minimum distance between a face and an infinite line.
   * @param nodeId id of the node the face belongs to
   * @param faceId id of the face in the node
   * @param ray the line (in the form of a ray) to test against
   * @returns a promise that resolves with a Markup.Measure.FaceFaceDistanceItem when the operation completes
   */
  computeMinimumFaceLineDistance(t, e, i) {
    const s = this._modelStructure.lookupAnyBody(t);
    if (s === null)
      throw new Vi(t, li.AnyBody);
    const r = s.getInstanceInc();
    return this._engine.computeMinimumFaceLineDistance(r, e, i);
  }
  /**
   * Sets the color for a face element. This color will take precedence over any currently set color on the node
   * @param nodeId the Id of the node containing the face
   * @param faceId the Id of the face in the node that will have its color set
   * @param color the color to set
   */
  setNodeFaceColor(t, e, i) {
    return this._setNodeFaceColor(t, e, i), Promise.resolve();
  }
  _setNodeFaceColor(t, e, i) {
    const s = this._modelStructure.gatherInstanceIncsFromNodeIds(
      [t],
      bt.All,
      ft.None
    );
    if (s.length === 2) {
      const r = s;
      this._engine.setElementColor(r, vt.Faces, e, 1, i);
    }
  }
  /**
   * Sets the visibility for a face element. This visibility setting will take precedence over other element visibility settings
   * @param partId the Id of the part containing the face
   * @param faceId the Id of the face in the node that will have its visibility set
   * @param visibility visibility state to be set
   */
  setNodeFaceVisibility(t, e, i) {
    this._setNodeElementVisibility(t, e, i, vt.Faces);
  }
  /**
   * Clears the visibility for a node's face elements, resetting them to default.
   * @param partId the Id of the part to be reset
   */
  clearNodeFaceVisibility(t) {
    this._clearNodeElementVisibility(t, vt.Faces);
  }
  _setNodeElementVisibility(t, e, i, s) {
    const r = this._modelStructure.gatherInstanceIncsFromNodeIds(
      [t],
      bt.All,
      ft.None
    );
    if (r.length === 2) {
      const o = r;
      this._engine.setElementVisibility(o, s, e, 1, i);
    }
  }
  _clearNodeElementVisibility(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      [t],
      bt.All,
      ft.None
    );
    if (i.length === 2) {
      const s = i;
      this._engine.clearElementVisibility(s, e);
    }
  }
  _unsetElementColor(t, e, i) {
    if (i < 0)
      return;
    const s = this._getInstanceIncFromSingleLeafNode(t);
    this._engine.unsetElementColor(s, e, i, 1);
  }
  /**
   * Unsets the color for a face element. This will return the face's color to its default state.
   * @param nodeId the Id of the node containing the face
   * @param faceId the Id of the face in the node that will have its color unset
   */
  unsetNodeFaceColor(t, e) {
    return this._unsetElementColor(t, vt.Faces, e), Promise.resolve();
  }
  /**
   * Sets whether the face element for a given node should appear highlighted.
   * When a face element is highlighted, the highlight color will override
   * any color previously set on the element.
   * @param nodeId the id for the node containing the face element.
   * @param faceId the face Id that is the target of this operation.
   * @param highlighted value indicating whether the supplied face element should be highlighted.
   */
  setNodeFaceHighlighted(t, e, i) {
    return this._setNodeFaceHighlighted(t, e, i), Promise.resolve();
  }
  _setNodeFaceHighlighted(t, e, i) {
    const s = this._modelStructure.gatherInstanceIncsFromNodeIds(
      [t],
      bt.All,
      ft.LoadedNodesOnly
    );
    s.length > 0 && this._engine.highlightElements(s, vt.Faces, e, 1, i);
  }
  async _getElementHighlighted(t, e, i) {
    const s = this._getInstanceIncFromSingleLeafNode(t), [r] = await this._engine.getElementHighlighted(s, e, i);
    return r;
  }
  /**
   * Returns whether the supplied face element has been highlighted with [[setNodeFaceHighlighted]].
   * @param nodeId the ID of the node containing the face element
   * @param faceIndex the index of the face within the node
   */
  getNodeFaceHighlighted(t, e) {
    return this._getElementHighlighted(t, vt.Faces, e);
  }
  /**
   * Gets the color set via [[setNodePointColor]] on a point element.
   * If no color has been set, `null` will be returned.
   * <br><br> See also: [[getNodeEffectivePointColor]]
   * @param nodeId the ID of the node containing the point
   * @param pointIndex the index of the point in the node
   */
  getNodePointColor(t, e) {
    return this._getNodeElementColor(t, vt.Points, e);
  }
  /**
   * Gets the color set via [[setNodePointColor]] on a point element. If no color has been set,
   * the node's point color will be returned. If the node's point color has not been set,
   * the color specified when the model was authored will be returned.
   * @param nodeId the ID of the node containing the point
   * @param pointIndex the index of the point in the node
   */
  getNodeEffectivePointColor(t, e) {
    return this._getNodeEffectiveElementColor(t, vt.Points, e);
  }
  /**
   * Sets the color for a point element.
   * @param partId the Id of the node containing the point.
   * @param pointId the Id of the point in the node that will have its color set.
   * @param color the color to set.
   */
  setNodePointColor(t, e, i) {
    const s = this._modelStructure.lookupAnyBody(t);
    if (s === null)
      throw new Vi(t, li.AnyBody);
    const r = s.getInstanceInc();
    this._engine.setElementColor(r, vt.Points, e, 1, i);
  }
  /**
   * Unsets the color for a point element. This will return the point's color to its default state.
   * @param partId the Id of the node containing the point
   * @param pointId the Id of the point in the node that will have its color unset
   */
  unsetNodePointColor(t, e) {
    this._unsetElementColor(t, vt.Points, e);
  }
  /**
   * Gets the color set via [[setNodesPointColor]] on the points of a list of leaf nodes.
   * If no color has been explicitly set for a particular node, `null` will appear at the corresponding
   * position in the returned array.
   * <br><br> See also: [[getNodesEffectivePointColor]]
   * @param nodeIds IDs of the nodes to be queried
   */
  getNodesPointColor(t) {
    return this._getNodesColor(t, vt.Points);
  }
  /**
   * Gets the color set on the points of a list of leaf nodes. If no color has been set,
   * the color specified when the model was authored will be returned.
   * @param nodeIds IDs of the nodes to be queried
   */
  getNodesEffectivePointColor(t) {
    return this._getNodesEffectiveColor(t, vt.Points);
  }
  /**
   * Sets the color on the points for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to set
   * @returns Promise that resolves when this operation has completed.
   */
  setNodesPointColor(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    i.length > 0 && this._engine.setPartColor(i, vt.Points, e);
  }
  /**
   * Unsets the color on the points for a given list of nodes.
   * @param nodeIds IDs of nodes to modify
   */
  unsetNodesPointColor(t) {
    this._unsetNodesColor(t, vt.Points);
  }
  /**
   * Sets the color for a line element.
   * @param nodeId the Id of the node containing the line.
   * @param lineId the Id of the line in the node that will have its color set.
   * @param color the color to set.
   */
  setNodeLineColor(t, e, i) {
    return this._setNodeLineColor(t, e, i), Promise.resolve();
  }
  _setNodeLineColor(t, e, i) {
    const s = this._modelStructure.lookupAnyBody(t);
    if (s === null)
      throw new Vi(t, li.AnyBody);
    const r = s.getInstanceInc();
    this._engine.setElementColor(r, vt.Lines, e, 1, i);
  }
  /**
   * Unsets the color for a line element. This will return the line's color to its default state.
   * @param nodeId the Id of the node containing the line
   * @param lineId the Id of the line in the node that will have its color unset
   */
  unsetNodeLineColor(t, e) {
    return this._unsetElementColor(t, vt.Lines, e), Promise.resolve();
  }
  /**
   * Sets the visibility for a line element. This visibility setting will take precedence over other element visibility settings
   * @param partId the Id of the part containing the line
   * @param lineId the Id of the line in the node that will have its visibility set
   * @param visibility visibility state to be set
   */
  setNodeLineVisibility(t, e, i) {
    this._setNodeElementVisibility(t, e, i, vt.Lines);
  }
  /**
   * Clears the visibility for a node's line elements, resetting them to default.
   * @param partId the Id of the part to clear visibilities from
   */
  clearNodeLineVisibility(t) {
    this._clearNodeElementVisibility(t, vt.Lines);
  }
  /**
   * Sets whether the line element for a given node should appear highlighted. When a line element is highlighted, the highlight color will override any color previously set on the element.
   * @param nodeId the id for the node containing the line element.
   * @param lineId the line Id that is the target of this operation.
   * @param highlighted value indicating whether the supplied line element should be highlighted.
   */
  setNodeLineHighlighted(t, e, i) {
    return this._setNodeLineHighlighted(t, e, i), Promise.resolve();
  }
  _setNodeLineHighlighted(t, e, i) {
    const s = this._modelStructure.gatherInstanceIncsFromNodeIds(
      [t],
      bt.All,
      ft.LoadedNodesOnly
    );
    s.length > 0 && this._engine.highlightElements(s, vt.Lines, e, 1, i);
  }
  /**
   * Returns whether the supplied line element has been highlighted with [[setNodeLineHighlighted]].
   * @param nodeId the ID of the node containing the line element
   * @param lineIndex the index of the line within the node
   */
  getNodeLineHighlighted(t, e) {
    return this._getElementHighlighted(t, vt.Lines, e);
  }
  /**
   * Sets the visibility for a point element. This visibility setting will take precedence over other element visibility settings
   * @param partId the Id of the part containing the point
   * @param pointId the Id of the point in the node that will have its visibility set
   * @param visibility visibility state to be set
   */
  setNodePointVisibility(t, e, i) {
    this._setNodeElementVisibility(t, e, i, vt.Points);
  }
  /**
   * Clears the visibility for a node's point elements, resetting it to default.
   * @param partId the Id of the part to clear visibilities from
   */
  clearNodePointVisibility(t) {
    this._clearNodeElementVisibility(t, vt.Points);
  }
  /**
   * Sets whether the point element for a given node should appear highlighted. When a point element is highlighted, the highlight color will override any color previously set on the element.
   * @param nodeId the id for the node containing the point element.
   * @param pointId the point Id that is the target of this operation.
   * @param highlighted value indicating whether the supplied point element should be highlighted.
   */
  setNodePointHighlighted(t, e, i) {
    return this._setNodePointHighlighted(t, e, i), Promise.resolve();
  }
  _setNodePointHighlighted(t, e, i) {
    const s = this._modelStructure.lookupAnyBody(t);
    if (s === null)
      throw new Vi(t, li.AnyBody);
    const r = s.getInstanceInc();
    this._engine.highlightElements(r, vt.Points, e, 1, i);
  }
  /**
   * Returns whether the supplied point element has been highlighted with [[setNodePointHighlighted]].
   * @param nodeId the ID of the node containing the point element
   * @param pointIndex the index of the point within the node
   */
  getNodePointHighlighted(t, e) {
    return this._getElementHighlighted(t, vt.Points, e);
  }
  /**
   * Resets color for all nodes in the model.
   * @returns Promise that resolves when this operation has completed.
   */
  resetNodesColor() {
    return this._engine.resetColors(), Promise.resolve();
  }
  /**
   * Sets opacity for a given list of nodes.
   * @param nodeIds IDs of nodes whose opacity will be set
   * @param opacity opacity value to apply to each node. The value should be between the range of 0.0 and 1.0. 0.0 indicates fully transparent, while 1.0 is fully opaque.
   */
  setNodesOpacity(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    i.length > 0 && this._engine.setPartOpacity(i, e);
  }
  /**
   * Returns whether nodes with the given NodeIds have an opacity value that is not fully opaque.
   * @param nodeIds IDs of nodes to query.
   * @returns array of boolean values corresponding to the id array passed into the function.  A value of true indicates that the node contains transparency and is not fully opaque.
   */
  getNodesHaveTransparency(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    return e.length > 0 ? this._engine.getPartHasTransparency(e) : Promise.resolve([]);
  }
  /**
   * Sets opacity for a given set of nodes.
   * @param params object mapping node IDs to opacity to set for that NodeId. The opacity value should be between the range of 0.0 and 1.0. 0.0 indicates fully transparent, while 1.0 is fully opaque.
   */
  setNodesOpacities(t) {
    t = nu(t);
    const e = /* @__PURE__ */ new Set();
    t.forEach((i, s) => {
      const r = this._modelStructure.lookupAnyTreeNode(s);
      if (r !== null) {
        const o = zo(
          r,
          bt.BodyInstance,
          !1,
          e,
          ft.None
        );
        o.length > 0 && this._engine.setPartOpacity(o, i);
      }
    });
  }
  /**
   * Resets opacity for all nodes in the model.
   * @returns Promise that resolves when this operation has completed.
   */
  resetModelOpacity() {
    this._engine.resetOpacity(), this._callbackManager.trigger("_resetOpacity");
  }
  /**
   * Resets highlight for all nodes in the model.
   * @returns Promise that resolves when this operation has completed.
   */
  resetModelHighlight() {
    return this._engine.clearHighlight(), Promise.resolve();
  }
  /**
   * Resets opacity for a given list of nodes.
   * @param nodeIds IDs of nodes whose opacity will be reset to their default values
   */
  resetNodesOpacity(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    e.length > 0 && this._engine.unsetPartOpacity(e);
  }
  _getNodesColor(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    return i.length > 0 ? this._engine.getPartColor(i, e) : Promise.resolve([]);
  }
  _getNodesEffectiveColor(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    return i.length > 0 ? this._engine.getEffectivePartColor(i, e) : Promise.resolve([]);
  }
  /**
   * Gets the color set via [[setNodesFaceColor]] on the faces of a list of leaf nodes.
   * If no color has been explicitly set for a particular node, `null` will appear at the corresponding
   * position in the returned array.
   * <br><br> See also: [[getNodesEffectiveFaceColor]]
   * @param nodeIds IDs of the nodes to be queried
   */
  getNodesFaceColor(t) {
    return this._getNodesColor(t, vt.Faces);
  }
  /**
   * Gets the color set on the faces of a list of leaf nodes. If no color has been set,
   * the color specified when the model was authored will be returned.
   * @param nodeIds IDs of the nodes to be queried
   */
  getNodesEffectiveFaceColor(t) {
    return this._getNodesEffectiveColor(t, vt.Faces);
  }
  /**
   * Gets the color set via [[setNodesLineColor]] on the lines of a list of leaf nodes.
   * If no color has been set for a particular node, `null` will appear at the corresponding
   * position in the returned array.
   * @param nodeIds IDs of the nodes to be queried
   */
  getNodesLineColor(t) {
    return this._getNodesColor(t, vt.Lines);
  }
  /**
   * Gets the color set on the lines of a list of leaf nodes. If no color has been set,
   * the color specified when the model was authored will be returned.
   * @param nodeIds IDs of the nodes to be queried
   */
  getNodesEffectiveLineColor(t) {
    return this._getNodesEffectiveColor(t, vt.Lines);
  }
  /**
   * Gets a map associating NodeIds to colors that are set on those nodes.
   * Only NodeIds of nodes that have a color set will be included.
   * @param startNodeId The start node to walk when building the color map.
   * @param elementType Returned colors are of this element type.
   */
  async getNodeColorMap(t, e) {
    const i = this._modelStructure.lookupAnyTreeNode(t);
    if (i !== null)
      return u_(i, this._engine, e);
    throw new sn(t);
  }
  /**
   * Gets the opacity set via [[setNodesOpacity]] on a list of leaf nodes.
   * If no value has been set for a particular node, `null` will appear at the corresponding
   * position in the returned array.
   * @param nodeIds IDs of the nodes to be queried
   */
  getNodesOpacity(t) {
    return Promise.resolve(this._getNodesOpacity(t));
  }
  _getNodesOpacity(t) {
    const e = this._getInstanceIncsFromLeafNodes(t);
    return e.length > 0 ? this._engine.getPartOpacity(e) : [];
  }
  /**
   * Gets the opacity set on a list of leaf nodes multiplied by the opacity
   * specified when the model was authored. If no opacity has been set,
   * the opacity specified when the model was authored will be returned directly.
   * @param nodeIds IDs of the nodes to be queried
   * @param elementType the type of element (faces, lines or points) to query
   */
  getNodesEffectiveOpacity(t, e) {
    const i = this._getInstanceIncsFromLeafNodes(t);
    return i && i.length > 0 ? this._engine.getEffectivePartOpacity(i, e) : Promise.resolve([]);
  }
  async _getNodeElementColor(t, e, i) {
    const s = this._getInstanceIncFromSingleLeafNode(t), [r] = await this._engine.getElementColor(s, e, i);
    return r;
  }
  async _getNodeEffectiveElementColor(t, e, i) {
    const s = this._getInstanceIncFromSingleLeafNode(t), [r] = await this._engine.getEffectiveElementColor(s, e, i);
    return r;
  }
  /**
   * Gets the color set via [[setNodeFaceColor]] on a face element.
   * If no color has been set, `null` will be returned.
   * <br><br> See also: [[getNodeEffectiveFaceColor]]
   * @param nodeId the ID of the node containing the face
   * @param faceIndex the index of the face in the node
   */
  getNodeFaceColor(t, e) {
    return this._getNodeElementColor(t, vt.Faces, e);
  }
  /**
   * Gets the color set via [[setNodeFaceColor]] on a face element. If no color has been set,
   * the node's face color will be returned. If the node's face color has not been set,
   * the color specified when the model was authored will be returned.
   * @param nodeId the ID of the node containing the face
   * @param faceIndex the index of the face in the node
   */
  getNodeEffectiveFaceColor(t, e) {
    return this._getNodeEffectiveElementColor(t, vt.Faces, e);
  }
  /**
   * Gets the color set via [[setNodeLineColor]] on a line element.
   * If no color has been set, `null` will be returned.
   * @param nodeId the ID of the node containing the line
   * @param lineIndex the index of the line in the node
   */
  getNodeLineColor(t, e) {
    return this._getNodeElementColor(t, vt.Lines, e);
  }
  /**
   * Gets the color set via [[setNodeLineColor]] on a line element. If no color has been set,
   * the node's line color will be returned. If the node's line color has not been set,
   * the color specified when the model was authored will be returned.
   * @param nodeId the ID of the node containing the line
   * @param lineIndex the index of the line in the node
   */
  getNodeEffectiveLineColor(t, e) {
    return this._getNodeEffectiveElementColor(t, vt.Lines, e);
  }
  /**
   * Returns "Out Of Hierarchy" status for child node for the given Id.
   * @param id Node id to get children of
   * @returns false if node is Out Of Hierarchy, true if it is
   */
  getOutOfHierarchy(t) {
    return this._modelStructure.isOutOfHierarchy(t);
  }
  /**
   * Returns the absolute root node of the assembly tree.
   * @returns Id for the model tree root node or null if the model structure is not loaded.
   */
  getAbsoluteRootNode() {
    return this._modelStructure.getAbsoluteRootNodeId();
  }
  /**
   * Returns IDs for child nodes for the given Id.
   * @param id Node id to get children of
   * @param includeOutOfHierarchy true to include Out Of Hierarchy node, false or null to exclude them
   * @returns ID for the children of this node, or null if the ID is invalid
   */
  getNodeChildren(t, e) {
    return this._modelStructure.getChildIds(t, e || !1);
  }
  /**
   * Returns IDs of nodes who instance the same part as the supplied node.
   * This method should be called on nodes whose type is `PartInstance`.
   * @param id ID of a `PartInstance` node.
   * @returns Array containing `PartInstance` node IDs. These nodes all instance the same part as the supplied node.  If this method is called on a node which is not of type `PartInstance` then `null` will be returned.
   */
  getNodesInstancingSamePart(t) {
    return this._modelStructure.getPartReferrers(t);
  }
  /**
   * Returns the unit multiplier affecting the supplied node.
   * This number is a multiplier of millimeters (for example inches will be `25.4`).
   * The default value is `1.0`.
   * @returns The unit multiplier for the model (in mm)
   */
  getNodeUnitMultiplier(t) {
    return this._modelStructure.getUnit(t);
  }
  /**
   * Creates a CAD view. This method will trigger a "cadViewCreated" callback if the creation is successful.
   * @param id Node id to attach the created view to
   * @param viewName Name of the view
   * @param camera Camera that will be set when the view gets activated
   * @param pmiIds (optional, pass null or empty array if none to send) Node IDs of the PMI to show for the view
   * @param nodesToShow (optional, pass null or empty array if none to send) Node IDs of the elements to force visibility on
   * @param nodesToHide (optional, pass null or empty array if none to send) Node IDs of the elements to force visibility off
   * @param nodeIdsAndLocalTransforms (optional, pass null or empty array if none to send) array of node ID and matrix pair, defining specific local transform to apply
   * @param cuttingPlane (optional, pass null if none to send) Cutting plane to set when the view gets activated. Distance of the planes must be in the same unit as the model.
   * @param meshInstanceData (optional, pass null if none to send) object that specifies the data for the mesh instance of the rectangular frame (mostly found on capture views)
   * @returns id of the view, null is returned if the function fails
   */
  createCadView(t, e, i, s, r, o, a, l, c) {
    s || (s = []), r || (r = []), o || (o = []), a || (a = []), l === void 0 && (l = null), c === void 0 && (c = null);
    const h = this._modelStructure.createCadView(
      t,
      e,
      i,
      s,
      r,
      o,
      a,
      l,
      c
    );
    return h !== null && this._callbackManager.trigger("cadViewCreated", h, e), h;
  }
  /**
   * Gets CAD View information for this model.
   * @returns a map mapping associating CAD View ID to name
   */
  getCadViewMap() {
    return this._modelStructure.getCadViewMap();
  }
  /**
   * Activates a CAD View
   * @param id ID of the CAD View to activate.
   * @param duration camera transition time in milliseconds.
   * @param massageCamera If true, undesirable authored cameras may be modified into a camera with more reasonable values
   * @returns None.
   */
  activateCadView(t, e = Ni, i = !0) {
    return this.resetModelOpacity(), this._modelStructure.activateCadView(t, e, i);
  }
  /**
   * Get PMI IDs for a CAD View
   * @param id ID of the CAD View
   * @returns IDs of visible PMIs for the view
   */
  getCadViewPmis(t) {
    return this._modelStructure.getCadViewPmis(t);
  }
  /**
   * Gets whether or not cad configurations are enabled
   * @returns Boolean indicating whether or not cad configurations are enabled
   */
  cadConfigurationsEnabled() {
    return this._modelStructure.cadConfigurationsEnabled();
  }
  /**
   * Gets CAD configurations
   * @returns an object mapping CAD configuration ID to config name
   */
  getCadConfigurations() {
    return this._modelStructure.getCadConfigurations();
  }
  /**
   * Gets CAD default configuration
   * @returns ID of default CAD Configuration
   */
  getDefaultCadConfiguration() {
    return this._modelStructure.getDefaultCadConfiguration();
  }
  /**
   * Gets CAD default view
   * @returns ID of default CAD Configuration
   */
  getDefaultCadView() {
    return this._modelStructure.getDefaultCadView();
  }
  /**
   * Activate the default CAD view
   * @param duration Duration of the camera animation
   * @param massageCamera If true, undesirable authored cameras may be modified into a camera with more reasonable values
   * @returns None.
   */
  activateDefaultCadView(t = Ni, e = !0) {
    return this._modelStructure.activateDefaultCadView(t, e);
  }
  /**
   * Gets Active CAD configuration
   * @returns ID of activated CAD Configuration
   */
  getActiveCadConfiguration() {
    return this._modelStructure.getActiveCadConfiguration();
  }
  /**
   * Get the configuration in which the view is defined
   * @returns ID of CAD Configuration of the view
   */
  getCadViewConfiguration(t) {
    return this._modelStructure.getCadViewConfiguration(t);
  }
  /**
   * Activates a CAD configuration
   * @param id ID of the CAD Configuration to activate
   * @returns None.
   */
  activateCadConfiguration(t) {
    return this._modelStructure.activateCadConfiguration(t, !0);
  }
  /**
   * Activates Default CAD configuration
   * @param fitNodes Fit view to visible nodes if possible (default true)
   * @returns None.
   */
  activateDefaultCadConfiguration(t = !0) {
    return this._modelStructure.activateDefaultCadConfiguration(t);
  }
  /**
   * Returns point attributes for a node of the given node and point.
   * @param nodeId Node to retrieve point properties from
   * @param pointIndex Index of point for which to retrieve point attributes
   * @returns Promise for the requested point attributes. Properties returned will be null if none associated with the point.
   */
  getPointAttributes(t, e) {
    return this._modelStructure.getPointAttributes(t, e);
  }
  /**
   * Returns edge count for a node of the given node.
   * @param nodeId Node to retrieve edge count from
   * @returns Promise providing the number of edges
   */
  getEdgeCount(t) {
    return this._modelStructure.getEdgeCount(t);
  }
  /**
   * Returns edge attributes for a node of the given node and edge.
   * @param nodeId Node to retrieve edge properties from
   * @param edgeIndex Index of edge for which to retrieve edge attributes
   * @returns Promise for the requested edge attributes. Properties returned will be null if none associated with the edge.
   */
  getEdgeAttributes(t, e) {
    return this._modelStructure.getEdgeAttributes(t, e);
  }
  /**
   * Returns edge properties for a node of the given node and edge.
   * @param nodeId Node to retrieve edge properties from
   * @param edgeid ID of edge for which to retrieve edge properties
   * @returns Promise for the requested edge properties. Properties returned will be null if none associated with the edge.
   */
  getEdgeProperty(t, e) {
    return this._modelStructure.getEdgeProperty(t, e);
  }
  /**
   * Returns face count for a node of the given node and face.
   * @param nodeId Node to retrieve face count from
   * @returns Promise providing the number of faces
   */
  getFaceCount(t) {
    return this._modelStructure.getFaceCount(t);
  }
  /**
   * Returns face attributes for a node of the given node and face.
   * @param nodeId Node to retrieve edge properties from
   * @param faceIndex Index of face for which to retrieve face attributes
   * @returns Promise for the requested face attributes. Properties returned will be null if none associated with the edge.
   */
  getFaceAttributes(t, e) {
    return this._modelStructure.getFaceAttributes(t, e);
  }
  /**
   * Returns Face properties for a node of the given node and face.
   * @param nodeId Node to retrieve face properties from
   * @param faceid ID of face for which to retrieve face properties
   * @returns Promise for the requested face properties. Properties returned will be null if none associated with the face.
   */
  getFaceProperty(t, e) {
    return this._modelStructure.getFaceProperty(t, e);
  }
  /**
   * Set edge property for a node of the given node and edge.
   * @param id Node to set edge properties to
   * @param edgeid ID of edge
   * @param prop property (CircleElement, LineElement...)
   */
  setEdgeProperty(t, e, i) {
    this._modelStructure.setEdgeProperty(t, e, i);
  }
  /**
   * Set face property for a node of the given node and face.
   * @param id Node to set edge properties to
   * @param faceid ID of face
   * @param prop property (CylinderElement, PlaneElement...)
   */
  setFaceProperty(t, e, i) {
    this._modelStructure.setFaceProperty(t, e, i);
  }
  /**
   * Fetch the mesh data for a particular node
   * @param nodeId the node's ID
   */
  async getNodeMeshData(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      [t],
      bt.All,
      ft.None
    );
    if (e.length === 0)
      throw new Mt("Node does not refer to a mesh instance");
    if (e.length > 2)
      throw new Mt("Node refers to multiple mesh instances");
    const i = e, s = await this._engine.getInstancesMeshData(i);
    if (s[1] === Zo.Invalid)
      throw new Mt("Node has instance, but no mesh data");
    return this._engine.getMeshData(s);
  }
  /**
   * Fetch the mesh data for any capping geometry on a particular node
   * @param nodeIds the node IDs to get capping data from.
   */
  async getNodeCappingMeshData(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      [t],
      bt.All,
      ft.None
    );
    if (e.length === 0)
      throw new Mt("Node does not refer to a mesh instance");
    if (e.length > 2)
      throw new Mt("Node refers to multiple mesh instances");
    const i = e, s = await this._engine.getInstancesCappingMeshData(i);
    return s[1] === Zo.Invalid ? null : this._engine.getMeshData(s);
  }
  /**
   * Fetch the mesh data for any capping geometry on a list of nodes and their children
   * @param nodeIds the node IDs to get capping data from.
   */
  async getNodesCappingMeshData(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    ), i = await this._engine.getInstancesCappingMeshData(e), s = [];
    for (let r = 1; r < i.length; r += 2)
      if (i[r] !== Zo.Invalid) {
        const o = [i[r - 1], i[r]], a = await this._engine.getMeshData(o);
        s.push(a);
      }
    return s;
  }
  /**
   * Returns a copy of the Matrix for a node of the given ID
   * @param id Node to retrieve matrix from
   * @returns Copy of the Matrix of the node
   */
  getNodeMatrix(t) {
    return this._modelStructure.getMatrix(t);
  }
  /**
   * Sets Matrix for a node of the given ID
   * @param id Node to set matrix on
   * @param Matrix of the Node
   * @param setAsInitial tells if you want to change the node initial matrix or not
   */
  setNodeMatrix(t, e, i = !1) {
    return this._modelStructure.setMatrix(t, e, i);
  }
  /**
   * Used by Animation system to efficiently update the matrix of many nodes at once.
   * Currently not part of public API due to difference in signature with other bulk operations which use Map based parameter.
   * @hidden
   */
  _setNodesMatrices(t, e, i = !1) {
    return this._modelStructure.setMatrices(t, e, i);
  }
  /**
   * Reset node matrix to the one set as the initial one
   * @param id Node to set matrix on
   */
  resetNodeMatrixToInitial(t) {
    return this._modelStructure.resetToInitialMatrix(t);
  }
  /**
   * Returns net matrix for a node of the given ID
   * @param id Node to retrieve net matrix from
   * @returns Net Matrix of the Node
   */
  getNodeNetMatrix(t) {
    return Q.createFromArray(this._modelStructure.getNetMatrix(t));
  }
  /**
   * Returns the parent Id for the given node id.
   * @param id node id to get the parent of
   * @returns ID of the parent node for the supplied ID. If the ID is invalid or the root ID, null is returned.
   */
  getNodeParent(t) {
    return this._modelStructure.getParentId(t);
  }
  /**
   * Returns the type of the node with the given ID.
   * @param id The ID of the node to get the type for.
   * @returns The type of the node.
   */
  getNodeType(t) {
    return this._modelStructure.getType(t);
  }
  /**
   * Returns the properties for the given node ID.
   * @param id Node ID to get the parent of
   * @param computeFromChildren If true physical properties will be computed from child nodes.
   * @returns object properties for the supplied ID, or null if the ID was invalid
   */
  getNodeProperties(t, e = !0) {
    return this._modelStructure.getProperties(t, e);
  }
  /**
   * Purpose: Adds a property to the node
   * @Param nodeId node id to set the property on
   * @Param property name
   * @Param property value
   * @returns true if all went right, false otherwise
   */
  addPropertyToNode(t, e, i, s) {
    return this._modelStructure.addProperty(t, e, i, s);
  }
  /**
   * Purpose: Sets physical properties
   * @Param nodeId node id to set the property on, the node id has to be a body node
   * @Param gravityCenter gravity center in local coordinates
   * @Param surfaceArea surface area, in squared current unit
   * @Param volume volume, in cubed current unit
   * @returns true if all went right, false otherwise
   */
  setPhysicalProperties(t, e, i, s) {
    return this._modelStructure.setPhysicalProperties(t, e, i, s);
  }
  /**
   * Specifies nodes for the system to load. This method is useful when the viewer was created with the <code>streamOnDemand</code> option set to true.
   * @param nodeIds array of unique IDs for the system to load
   */
  requestNodes(t) {
    return this._modelStructure.requestNodes(t);
  }
  /**
   * Returns the name for a node in the assembly tree.
   * @param nodeId The node ID to get the name of.
   * @returns The name of the node with the given nodeId or null if no name is found.
   */
  getNodeName(t) {
    return this._modelStructure.getName(t) || null;
  }
  /**
   * Returns the Exchange ID of a node in the assembly tree.
   * @param nodeId The node ID to get the Exchange ID from.
   * @returns The Exchange ID of the node with the given nodeId or null if no Exchange ID is found.
   */
  getNodeExchangeId(t) {
    return this._modelStructure.getNodeExchangeId(t);
  }
  /**
   * Returns names and ids of all filters available in the scene
   * @returns a map associating Filter IDs to filter names
   */
  getFilters() {
    return this._modelStructure.getFilters();
  }
  /**
   * @returns The name of a filter for the given filter ID index or null if filter was not found
   */
  getFilterName(t) {
    return this._modelStructure.getFilterName(t);
  }
  /**
   * @param nodeId The ID of the node to query.
   * @returns Filters which retain or remove the given node.
   */
  getFiltersWithNode(t) {
    return this._modelStructure.getFiltersWithNode(t);
  }
  /**
   * @param filtersId array of filters indexes to take in account
   * @returns nodesId of nodes retained by the given filter indices and the type of filter (inclusive or not). Returns null if no filter is found.
   */
  getNodesFromFiltersId(t) {
    return this._modelStructure.getNodesFromFilterIds(t);
  }
  /**
   * Returns names and ids of all layers available in the scene
   * @returns a map associating Layer IDs to Layer names
   */
  getLayers() {
    return this._modelStructure.getLayers();
  }
  /**
   * Return names of layers. Different layers can have the same name. Some layers can be unnamed.
   * @returns Names of layers
   */
  getUniqueLayerNames() {
    return this._modelStructure.getUniqueLayerNames();
  }
  /**
   * @returns The name of a layer for the given filter ID or null if layer was not found
   */
  getLayerName(t) {
    return this._modelStructure.getLayerName(t);
  }
  /**
   * @returns Id of layers for the given filter name or null if no layers are found
   */
  getLayerIdsFromName(t) {
    return this._modelStructure.getLayerIdsFromName(t);
  }
  /**
   * Returns the layer ID of a node in the assembly tree.
   * @param nodeId The node ID to get the Exchange ID from.
   * @returns The layer ID of the node with the given nodeId or null if no layer is found.
   */
  getNodeLayerId(t) {
    return this._modelStructure.getNodeLayerId(t);
  }
  /**
   * Returns IDs of nodes in the given layer.
   * @param layerId The layer ID to get nodes from.
   * @param onlyTreeNodes if true return only nodes present in model Tree
   * @returns An array of nodes Id of nodes with the given layerId or null if no layers are found.
   */
  getNodesFromLayer(t, e) {
    return this._modelStructure.getRuntimeNodesFromLayer(t, e);
  }
  /**
   * Returns IDs of nodes in given layers.
   * @param layersId Array of layers Id to get nodes from.
   * @param onlyTreeNodes if true return only nodes present in model Tree
   * @returns An array of nodes Id of nodes with one of the given layerId or null if no layers are found.
   */
  getNodesFromLayers(t, e) {
    return this._modelStructure.getRuntimeNodesFromLayers(t, e);
  }
  /**
   * Returns IDs of nodes in the given layer.
   * @param layer name the name of layer to get nodes from.
   * @param onlyTreeNodes if true return only nodes present in model Tree
   * @returns An array of nodes Id of nodes with the given layerName or null if no layers are found.
   */
  getNodesFromLayerName(t, e) {
    return this._modelStructure.getRuntimeNodesFromLayerName(t, e);
  }
  /**
   * Returns the current visibility for a node.
   * @param nodeId ID of the node to get visibility for.
   * @returns true if the current node's visibility state is on or false if it is not.
   */
  getNodeVisibility(t) {
    return this._modelStructure.isVisible(t);
  }
  /**
   * Branch visibility indicates the visibility state for all of a node's children.
   * @param nodeId ID of the node at the root of the branch.
   * @returns Shown/Hidden if all children have the same visibility state, Mixed otherwise.
   */
  getBranchVisibility(t) {
    const e = this._modelStructure.getBranchVisibility(t);
    return e === Pt.Shown ? Pt.Shown : e === Pt.Hidden ? Pt.Hidden : (console.assert(e === Pt.Mixed), Pt.Mixed);
  }
  /**
   * Returns a data object. During the authoring phase, a user can store general data within a model. (This is how
   * properties are stored, for example.) This function allows you to retrieve the data from the client application.
   *
   * @see {@link https://docs.techsoft3d.com/communicator/latest/api_ref/data_import/libsc/classSC_1_1Store_1_1Model.html#_CPPv4N2SC5Store5Model6InsertE8uint32_tPK7uint8_t8uint32_t Model::Insert}
   *
   * @param an Array of ModelKey-DataKey pairs ([ModelKey, DataKey, ModelKey, DataKey, ModelKey, DataKey...]
   * @returns promise that resolves when this operation has completed returning an array of 8bits int arrays for each ModelKey-DataKey pairs
   */
  getDataFromIds(t) {
    return this._engine.getDataFromIds(t);
  }
  /**
   * @param meshData [[MeshData]] object containing data to insert into the scene.
   * @returns Promise that resolves with a [[MeshId]] when the mesh has been created. The [[MeshId]] can be used to create instances of the mesh using [[createMeshInstance]].
   */
  async createMesh(t, e) {
    const i = await this._engine.createMesh(t);
    return e && e.doNotDelete && this._preventMeshDeletion(i), i;
  }
  static _flatArrayToPairArray(t) {
    const e = [];
    for (let i = 0; i < t.length; i += 2)
      e.push([t[i], t[i + 1]]);
    return e;
  }
  static _pairArrayToFlatArray(t) {
    const e = [];
    for (const i of t)
      e.push(i[0], i[1]);
    return e;
  }
  /**
   * Retrieve the [[MeshId]] associated with the mesh data attached to the given nodes.
   */
  async getMeshIds(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    ), i = await this._engine.getInstancesMeshData(e);
    return Yo._flatArrayToPairArray(i);
  }
  /**
   * Replace a mesh's data. This will affect all instances of that mesh.
   * @param key the [[MeshId]] identifying the mesh
   * @param data the new data
   */
  replaceMesh(t, e) {
    return this._engine.replaceMesh(t, e);
  }
  /**
   * Creates an instance of a mesh that has been created using [[createMesh]] or retrieved using [[getMeshIds]].
   * @param data object that specifies the data for this mesh instance
   * @param parentNodeId the ID of the desired parent node
   * @param preventFromResetting if set to true, then the visibility and positioning won't be reset when resetxxx() functions gets called.
   * @param isOutOfHierarchy True if the node created shouldn't appear in the model structure.
   * @returns Promise that resolves with a node ID that can be used to perform operations on this instance.
   */
  createMeshInstance(t, e, i, s) {
    return e === void 0 && (e = null), i || (i = !1), s || (s = !1), this._createMeshInstance(t, e, i, s);
  }
  async _createMeshInstance(t, e, i, s) {
    const r = t.getMatrix(), o = r !== null || e !== null;
    let a = t.getCreationFlags();
    i && (a |= St.DoNotReset), console.assert(
      !e || !s,
      "Out of hierarchy instances should not have a parent node."
    );
    const l = e === null || this.getNodeVisibility(e);
    let c = t;
    (o || !l) && (c = t.copy(), c.setCreationFlags(a | St.Invisible));
    const h = await this._engine.createMeshInstance(c), u = this._modelStructure.createMeshInstance(
      h[0],
      h[1],
      t.getInstanceName(),
      e,
      i,
      s,
      !1
    );
    if (o || !l) {
      const g = r || new Q();
      await this.setNodeMatrix(u, g, !0), !(a & St.Invisible) && l && this._engine.setPartVisibility(h, !0, !0);
    }
    let p = l;
    a & St.Invisible && (p = !1);
    const m = this._modelStructure.lookupAnyTreeNode(u);
    return m !== null && m.setVisibility(p), e !== null && await this._callbackManager.promiseTrigger(
      "_subtreeLoaded",
      "subtreeLoaded",
      [u],
      ps.CreateInstance
    ), u;
  }
  /**
   * Creates a PMI Instance from a mesh that has been created using the createMesh method.
   * @param data object that specifies the data for the PMI graphic representation
   * @param pmiType see PmiType enum (Datum, Gdt, Dimension...)
   * @param pmiSubType see PmiSubType enum (DatumTarget, GdtFcf, DimensionDistance...)
   * @param refOnTopoItems see RefOnTopoItem. It defines the PMI links to a body element, like a face or an edge
   * @param parentNodeId the ID of the desired parent node
   * @returns Promise that resolves with a node ID that can be used to perform operations on this instance. You can use deleteMeshInstances() to delete the PMI
   */
  async createPmiInstance(t, e, i, s, r) {
    r === void 0 && (r = null);
    const o = [];
    for (const c of s) {
      const h = this._modelStructure.lookupBodyInstance(c.bodyId);
      if (h === null)
        throw new sn(c.bodyId);
      const u = Kr.fromBodyInstance(
        h,
        c.subElementType,
        c.subElementIndex
      );
      o.push(u);
    }
    const a = await this._engine.createMeshInstance(t), l = this._modelStructure.createPmiInstance(
      a[0],
      a[1],
      e,
      i,
      o,
      t.getInstanceName(),
      r
    );
    return r !== null && await this._callbackManager.promiseTrigger(
      "_subtreeLoaded",
      "subtreeLoaded",
      [l],
      ps.CreatePmi
    ), l;
  }
  /**
   * Creates an image that can be applied as a texture via [[setNodesTexture]].
   * See [[deleteImages]].
   * @param primaryImage The image data and associated options
   * @param thumbnailImage If specified, an uncompressed image that will be used as a
   *                       placeholder for the primary image until it is fully loaded.
   *                       Only useful when `primaryImage` is a compressed image.
   */
  createImage(t, e) {
    return this._engine.createImage(t, e);
  }
  /**
   * Deletes images created with [[createImage]].
   * @param imageIds The IDs of the images to be deleted
   */
  deleteImages(t) {
    return this._engine.destroyImages(Yo._pairArrayToFlatArray(t));
  }
  /**
   * Apply an image to a node as a texture map. See [[createImage]] and [[unsetNodesTexture]].
   * @param nodeIds The nodes on which to apply the texture
   * @param options Options specifying how the texture is applied
   */
  setNodesTexture(t, e) {
    const i = this._getInstanceIncsFromLeafNodes(t);
    return this._engine.setTexture(i, e);
  }
  /**
   * Remove one or more textures applied via [[setNodesTexture]].
   * @param nodeIds The nodes from which to remove the texture or textures
   */
  unsetNodesTexture(t) {
    const e = this._getInstanceIncsFromLeafNodes(t);
    this._engine.unsetTexture(e);
  }
  /**
   * Deletes meshes that have been created at run time.
   *
   * In order for this method to succeed, all mesh instances created for the given IDs
   * must have also been destroyed with [[deleteMeshInstances]].
   *
   * @param meshIds The IDs of meshes that should be deleted
   * @returns Promise that resolves when this operation has completed.
   */
  deleteMeshes(t) {
    return this._engine.destroyMeshes(Yo._pairArrayToFlatArray(t));
  }
  /**
   * Deletes mesh instances that have been created at run time
   * @param nodeIds array of IDs for mesh instances created at run time that should be destroyed
   * @returns Promise that resolves when this operation has completed.
   */
  deleteMeshInstances(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    ), i = [];
    if (e.length > 0) {
      for (const s of t)
        i.push(this._modelStructure.deleteNode(s));
      i.push(this._engine.destroyLocalInstances(e));
    }
    return zt(i);
  }
  _obtainLoadSubtreeConfig(t) {
    if (t[0] instanceof mr)
      return t[0].copy();
    {
      const e = new mr();
      return e.additionalMatrix = t[0] || null, e.allowMissingExternalModels = !!t[1], e.copy();
    }
  }
  loadSubtreeFromXmlFile(t, e, i, ...s) {
    const r = this._obtainLoadSubtreeConfig(s);
    return i || (i = Oa), this._modelStructure.loadSubtreeFromXmlFile(
      t,
      e,
      i,
      r
    );
  }
  loadSubtreeFromXmlBuffer(t, e, i, ...s) {
    const r = this._obtainLoadSubtreeConfig(s);
    return i || (i = Oa), this._modelStructure.loadSubtreeFromXmlDoc(t, e, i, r);
  }
  loadSubtreeFromScsXmlFile(t, e, i, ...s) {
    const r = this._obtainLoadSubtreeConfig(s);
    return i || (i = Oa), this._modelStructure.loadSubtreeFromScsXmlFile(
      t,
      e,
      i,
      r
    );
  }
  loadSubtreeFromScsXmlBuffer(t, e, i, ...s) {
    const r = this._obtainLoadSubtreeConfig(s);
    return i || (i = Oa), this._modelStructure.loadSubtreeFromScsXmlDoc(t, e, i, r);
  }
  loadSubtreeFromModel(t, e, ...i) {
    const s = this._obtainLoadSubtreeConfig(i);
    return this._modelStructure.loadSubtreeFromStream(t, e, s);
  }
  loadSubtreeFromScsFile(t, e, ...i) {
    const s = this._obtainLoadSubtreeConfig(i);
    return this._modelStructure.loadSubtreeFromScsFile(t, e, s);
  }
  loadSubtreeFromScsBuffer(t, e, ...i) {
    const s = this._obtainLoadSubtreeConfig(i);
    return this._modelStructure.loadSubtreeFromScsBuffer(t, e, s);
  }
  /**
   * Loads measurement data from a JSON object
   * @param json JSON object containing measurement data
   */
  loadMeasurementFromJson(t) {
    return this._modelStructure.loadMeasurementFromJson(t);
  }
  /**
   * Loads measurement data from a JSON string
   * @param str JSON string containing measurement data
   */
  loadMeasurementFromString(t) {
    return this._modelStructure.loadMeasurementFromString(t);
  }
  /**
   * Loads measurement data from a ZIP file
   * @param filename Name of a file containing ZIP measurement data
   */
  loadMeasurementFromFile(t) {
    return this._modelStructure.loadMeasurementFromFile(t);
  }
  /**
   * Delete all the current scene and load the specified model instead. Also triggers a "modelSwitched" when finished.
   * @param newModelFilename Name of the model file to load after the existing scene gets deleted
   * @returns A `Promise` of the newly loaded model's root nodes IDs.
   */
  switchToModel(t) {
    return this._callbackManager.trigger("modelLoadBegin"), this._modelStructure.switchToModel(t);
  }
  /**
   * Creates a node
   * @param parentNodeId ID of the node to link the child node to. This ID should not have a type of Body or BodyInstance. If this parameter is `undefined`, the child node will be linked to the root.
   * @param name of the node to create
   * @param nodeID (optional) ID you want the node to have, if not specified the nodeID will be set automatically. Be aware that if the specified node ID is already used by another node, then it will be ignored a new one will be set automatically.
   * @param localMatrix (optional) Initial local matrix of the node (identity if none set)
   * @param visibility (optional) Initial visibility of the node (visible if nothing set)
   * @param measurmentUnit (optional) Specifies optional measurement units for this node. When set to null (the default), the node will inheret the unit setting of the parent node. If set, a scaling matrix will be computed
   *    that scales appropriately based on the unit scaling and applied to the newly created node. If a non-null localMatrix has been specified, that matrix will be combined with the computed scaling matrix.
   * @returns child node ID
   */
  createNode(t, e, i, s, r, o) {
    t === void 0 && (t = null), i === void 0 && (i = null), s === void 0 && (s = null), r == null && (r = !0);
    const a = this._modelStructure.createNode(
      t,
      e,
      i,
      s,
      r,
      o
    );
    return a !== null && this._callbackManager.promiseTrigger(
      "_subtreeLoaded",
      "subtreeLoaded",
      [a],
      ps.CreateNode
    ), a;
  }
  /**
   * Delete a node and all its children
   * @param ID of the node
   */
  async deleteNode(t) {
    const e = this._modelStructure.gatherInclusionKeysFromNodeIds([t]);
    await this._modelStructure.deleteNode(t), await this._engine.detachInclusions(e), this._callbackManager.trigger("subtreeDeleted", [t]);
  }
  /**
   * Creates an part node
   * @param nodeID (optional) ID you want the node to have, if not specified the nodeID will be set automatically. Be aware that if the specified node ID is already used by another node, then it will be ignored and new one will be set automatically.
   * @returns a node ID to access the created part node
   */
  createPart(t) {
    return t === void 0 && (t = null), this._modelStructure.createPart(t);
  }
  /**
   * Set a part on an assembly node
   * @param assemblyNodeID ID of the assembly node
   * @param partNodeID ID of the part node
   * @returns true if all went right, false otherwise
   */
  setPart(t, e) {
    return t == null || e == null ? !1 : this._modelStructure.setPart(t, e);
  }
  /**
   * Creates a representation item on a part
   * @param partNodeId ID of the part node
   * @param repItemId (optional) Id you want the node to have, if not specified the nodeId will be set automatically. Be aware that if the specified node Id is already used by another node, then it will be ignored and a new one will be set automatically.
   * @returns node ID to access the created representation item, null is returned if something went wrong
   */
  createAndAddRepresentationItem(t, e) {
    return t == null ? null : (e === void 0 && (e = null), this._modelStructure.createAndAddRepItem(t, e));
  }
  /**
   * Returns the lowest available node ID
   */
  getLowestAvailableNodeId() {
    return this._modelStructure.getLowestAvailableNodeId();
  }
  /**
   * Allows changing the behavior in the viewer
   * @param instanceModifier InstanceModifier
   * @param nodeIds Array of node ids
   * @param value boolean
   */
  setInstanceModifier(t, e, i) {
    return this._setInstanceModifier(t, e, i, bt.All), Promise.resolve();
  }
  /** @hidden */
  _setInstanceModifier(t, e, i, s) {
    const r = this._modelStructure.gatherInstanceIncsFromNodeIds(
      e,
      s,
      ft.None
    );
    r.length > 0 && this._engine.setInstanceModifier(t, r, i);
  }
  getAssociatedModelKey(t) {
    const e = this._modelStructure.getAssociatedModelKey(t);
    return Promise.resolve(e);
  }
  hasDepthRange(t) {
    const e = this._getInstanceIncsFromLeafNodes(t);
    return this._engine.hasDepthRange(e);
  }
  /**
   * Remaps the depth values used for z-ordering of pixels to the given
   * range, which must be a subset of `[0,1]`. The depth value at the
   * near plane (normally `0`) is mapped to `min` and the value at
   * the far plane (normally `1`) is mapped to `max`.
   *
   * The smaller the range, the more z-fighting you will see among
   * objects set to that range.
   *
   * @param nodeIds the node IDs to operate on
   * @param min the depth value at the near plane
   * @param max the depth value at the far plane
   */
  setDepthRange(t, e, i) {
    return this._setDepthRange(t, e, i), Promise.resolve();
  }
  _setDepthRange(t, e, i) {
    const s = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    this._engine.setDepthRange(s, e, i);
  }
  /**
   * Unsets the depth range set by [[setDepthRange]].
   * @param nodeIds the node IDs to operate on
   */
  unsetDepthRange(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    this._engine.unsetDepthRange(e);
  }
  /** @hidden */
  _gatherInstanceIncsFromNodeIds(t, e = bt.All) {
    return this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      e,
      ft.None
    );
  }
  _getInstanceIncsFromLeafNodes(t) {
    const e = [];
    for (const i of t) {
      const s = this._modelStructure.gatherInstanceIncsFromNodeIds(
        [i],
        bt.All,
        ft.None
      );
      if (s.length === 2) {
        const r = s;
        e.push(r[0], r[1]);
      } else
        throw new Mt("Non-leaf node encountered");
    }
    return e;
  }
  _getInstanceIncFromSingleLeafNode(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      [t],
      bt.All,
      ft.None
    );
    if (e.length === 2)
      return e;
    throw new Mt("Non-leaf node encountered");
  }
  /**
   * Sets the desired mesh level
   * @param nodeIds IDs of nodes in the assembly on which mesh level will be set
   * @param meshLevel 0 standard, 1 low, 2 extra low
   * @returns Promise that resolves when the operation has completed.
   */
  setMeshLevel(t, e) {
    return this._modelStructure.setMeshLevel(t, e), Promise.resolve();
  }
  /**
   * Sets the metallic and roughness factors for the supplied nodes materials.
   * Materials that are not currently set to use the Metallic Roughness shading model will be upgraded to use this mode.
   * @param nodeIds List of nodes to set material properties for
   * @param metallicFactor The metalness of the material
   * @param roughnessFactor The roughness of the material
   */
  setMetallicRoughness(t, e, i) {
    const s = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    this._engine.setMetallicRoughness(s, e, i);
  }
  /**
   * Gets the metallic and roughness factors for the supplied nodes materials.
   * Materials that are not currently set to use the Metallic Roughness shading model will have a null entry
   * @param nodeIds List of nodes to get material properties for
   */
  getMetallicRoughness(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    return this._engine.getMetallicRoughness(e);
  }
  /**
   * Unsets the metallic and roughness values set with [[setMetallicRoughness]]
   * These materials will no longer use the Metallic Roughness shading model.
   * @param nodeIds List of nodes to unset material properties for
   */
  unsetMetallicRoughness(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    this._engine.unsetMetallicRoughness(e);
  }
  /**
   * If enabled then models loaded into an existing scene with a different unit value will be scaled to the unit value of the current scene.
   * @param enabled value indicating if automatic unit scaling will be active
   */
  setEnableAutomaticUnitScaling(t) {
    return this._modelStructure.setEnableAutomaticUnitScaling(t);
  }
  /**
   * By default, objects that are initially hidden stays hidden unless specifically set to be shown. This function allows this behavior to be disabled.
   * @param enabled value indicating if initially hidden objects stay hidden
   */
  setBehaviorInitiallyHidden(t) {
    return this._modelStructure.setBehaviorInitiallyHidden(t);
  }
  /**
   * Tells if the model is a CAD drawing or not
   * @returns true if the model is a CAD drawing
   */
  isDrawing() {
    return this._modelStructure.isACadDrawing();
  }
  /**
   * @returns true if the model contains measurement data.
   */
  isMeasurable() {
    return this._modelStructure.isMeasurable();
  }
  /**
   * @param bodyId ID of the body node containing the line
   * @param lineIndex Index of the line ot be checked
   * @returns true if the line has associated measurement data
   */
  isLineMeasurable(t, e) {
    return this._modelStructure.isLineMeasurable(t, e);
  }
  isFaceMeasurable(t, e) {
    return this._modelStructure.isFaceMeasurable(t, e);
  }
  /**
   * @returns the original file name of the model which contain the given node or null if the node is not found.
   */
  getModelFileNameFromNode(t) {
    return this._modelStructure.getModelFileNameFromNode(t);
  }
  /**
   * @returns the original file type of the model which contain the given node or null if the node is not found.
   */
  getModelFileTypeFromNode(t) {
    return this._modelStructure.getModelFileTypeFromNode(t);
  }
  /**
   * @returns the generic type of the given node or null if the node is not found.
   */
  getNodeGenericType(t) {
    return this._modelStructure.getNodeGenericType(t);
  }
  /**
   * @returns the generic id of the given node or null if the node is not found.
   */
  getNodeGenericId(t) {
    return this._modelStructure.getNodeGenericId(t);
  }
  /**
   * This function recursively discovers BIM nodes in the supplied subtree and registers them.
   * @param startNodeId The root of the subtree to walk for registration.
   * @param attributeToMask The callback used to obtain a node's [[BimMask]] from its attributes.
   * @returns Promise that resolves when the operation has completed.
   */
  async registerBimNodes(t, e, i = null) {
    const s = this._modelStructure.lookupAnyTreeNode(t);
    if (s !== null)
      return typeof i == "boolean" && (i = i ? "TYPE" : null), h_(
        e,
        this._engine,
        this._modelStructure,
        s,
        i
      );
  }
  /**
   * Gets all generic types and NodeIds with that type.
   * @returns Map containing generic types and NodeIds
   */
  getGenericTypeIdMap() {
    return this._modelStructure.getGenericTypeIdMap();
  }
  /**
   * This function returns all NodeIds with an IFC type.
   * @param genericType
   * @returns All NodeIds with an IFC type
   */
  getNodesByGenericType(t) {
    return this._modelStructure.getNodesByGenericType(t);
  }
  /**
   * This function gets all generic types contained in the model.
   * @returns All generic types.
   */
  getGenericTypes() {
    return this._modelStructure.getGenericTypes();
  }
  /**
   * Checks if a [[NodeId]] is a generic type.
   * @param nodeId
   * @param genericType
   */
  hasEffectiveGenericType(t, e) {
    return this._modelStructure.hasEffectiveGenericType(t, e);
  }
  /**
   * This function recursively discovers IFC nodes in the supplied subtree and registers them.
   * @param startNodeId The root of the subtree to walk for registration.
   * @returns Promise that resolves when the operation has completed.
   */
  registerIfcNodes(t, e = null) {
    return this.registerBimNodes(t, r_, e);
  }
  /**
   * Tells if the view is an annotation view or not
   * @param cadViewNodeId Node ID of the CAD view
   * @returns true if the view is an annotation view
   */
  isAnnotationView(t) {
    return this._modelStructure.isAnnotationView(t);
  }
  /**
   * Tells if the view is a combine state view or not
   * @param cadViewNodeId Node ID of the CAD view
   * @returns true if the view is a combine state view
   */
  isCombineStateView(t) {
    return this._modelStructure.isCombineStateView(t);
  }
  /**
   * Sets a vector and angle used to determine an object's visibility based on camera orientation.
   * @param space The space in which the culling vector is defined.
   * @param vector A vector that will be compared with the view vector.
   * @param toleranceDegrees The maximum angle between the culling vector and the view vector within which the object will be visible.
   */
  setNodesCullingVector(t, e, i, s) {
    return this._setNodesCullingVector(t, e, i, s), Promise.resolve();
  }
  _setNodesCullingVector(t, e, i, s) {
    const r = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    return this._engine.setCullingVector(r, e, i, s);
  }
  /**
   * Unsets the vector and angle used to determine an object's visibility based on camera orientation.
   * @param nodeIds The nodes to unset culling vectors on.
   */
  unsetNodesCullingVectors(t) {
    return this._unsetNodesCullingVectors(t), Promise.resolve();
  }
  _unsetNodesCullingVectors(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    );
    this._engine.unsetCullingVector(e);
  }
  /**
   * Retrieves the vector and angle used to determine an object's visibility based on camera orientation.
   * If unset, `null` will appear at the corresponding array index.
   * @param nodeIds The nodes to query culling vectors from.
   * @returns A promise of culling vectors.
   */
  getNodesCullingVectors(t) {
    const e = this._getInstanceIncsFromLeafNodes(t);
    return this._engine.getCullingVector(e);
  }
  /**
   * Retrieves the node ID offset for a given node.
   * @param nodeId The node to obtain the node ID offset from.
   * @returns The node ID offset for the supplied node.
   */
  getNodeIdOffset(t) {
    return this._modelStructure.getIdOffset(t);
  }
  /**
   * Queries if a node is fully loaded or not.
   * @param nodeId The node to query.
   * @returns True if the node is fully loaded; false otherwise.
   */
  isNodeLoaded(t) {
    return this._modelStructure.isNodeLoaded(t);
  }
  /**
   * Triangulates the supplied polygon.
   * @param polygonPoints An array of point data for the polygon. Points are stored [XYZXYZXYZ...] format.
   * @param normal The normal of the polygon to triangulate.
   * @returns An array containing the point data for the generated triangles. Points are stored [XYZXYZXYZ...] format.
   *          This returned list is always divisible by 9 (3 points per triangle; 3 floats per point).
   */
  triangulatePolygon(t, e) {
    const i = Or(e);
    return this._engine.triangulatePolygon(t, i);
  }
  /**
   * Applies the given line pattern to the specified nodes. See also [[unsetNodesLinePattern]].
   * @param nodeIds The IDs of the nodes.
   * @param pattern The line pattern. See [[LinePattern]] for details.
   * @param patternLength The length of a single repetition of the line pattern.
   * @param patternLengthUnit The unit in which the length of the pattern is measured. See [[LinePatternLengthUnit]] for details.
   */
  setNodesLinePattern(t, e, i, s) {
    const r = this._gatherInstanceIncsFromNodeIds(t);
    this._engine.setLinePattern(r, e, i, s);
  }
  /**
   * Removes the line pattern applied by [[setNodesLinePattern]].
   * @param nodeIds The IDs of the nodes.
   */
  unsetNodesLinePattern(t) {
    const e = this._gatherInstanceIncsFromNodeIds(t);
    this._engine.unsetLinePattern(e);
  }
  /** @hidden */
  async _hwfAwaitAssemblyTreeReady() {
    const t = this.getAbsoluteRootNode(), e = this._modelStructure.lookupAnyTreeNode(t);
    if (e === null)
      throw new re();
    const i = gn(e);
    await yi.forceLazyPromises(i), await ir([i]);
  }
  /**
   * Returns all the `UserDataIndex` items associated with the input node.
   * @param nodeId The ID of the node to query.
   * @returns A list of `UserDataIndex`, possibly empty.
   * @throws `InvalidNodeIdError`
   */
  getNodeUserDataIndices(t) {
    return this._modelStructure.getUserDataIndices(t);
  }
  /**
   * Returns the user data for a given node and index.
   * @param nodeId The ID of the node to query.
   * @param index The index of the data.
   * @returns The user data.
   * @throws `InvalidNodeIdError` `InvalidIndexError`
   */
  getNodeUserData(t, e) {
    return this._modelStructure.getUserData(t, e);
  }
  /**
   * Returns a list of node IDs given a list of generic IDs. Note that the
   * returned list of node IDs may be longer than the provided list of generic
   * IDs since one ID can be used by more than one node.
   * @param genericIds Array of generic IDs to find nodes fore
   * @returns Array of node ids corresponding to the provided generic IDs
   */
  getNodeIdsByGenericIds(t) {
    const e = [];
    for (const i of t) {
      const s = this._modelStructure.getNodesByGenericId(i);
      s !== null && s.forEach((r) => {
        e.push(r);
      });
    }
    return e;
  }
  /** @hidden */
  _getModelStructure() {
    return this._modelStructure;
  }
  /**
   * Returns true if the node is within an external model.
   * @param nodeId
   */
  isWithinExternalModel(t) {
    return this._modelStructure.isWithinExternalModel(t);
  }
  /** @hidden */
  _firstAssemblyDataHeader() {
    return this._modelStructure.firstAssemblyDataHeader();
  }
  /**
   * Retrieves the bim id of the corresponding node id.
   * @param node the id of the node for which you want its bim id.
   * @returns the bim id corresponding to the node or null if none.
   */
  getBimIdFromNode(t) {
    return this._modelStructure.getBimIdFromNode(t);
  }
  /**
   * Retrieves the bim ids of the corresponding generic id.
   * @param ifcGuid the generic id for which you want its bim id.
   * @returns the bim id corresponding to the ifcGuid or null if none.
   */
  getBimIdsFromGenericId(t) {
    const e = [], i = this._modelStructure.getNodesByGenericId(t);
    return i !== null && i.forEach((s) => {
      const r = this.getBimIdFromNode(s);
      r !== null && e.push(r);
    }), e;
  }
  /**
   * Retrieves the node id of the corresponding bim id.
   * @param node any known node id of the working model.
   * @param bimID bim id for which you want its node id.
   * @returns the node id corresponding to the BimId or null if none.
   */
  getNodeIdFromBimId(t, e) {
    return this._modelStructure.getRuntimeNodeFromBimId(t, e);
  }
  /**
   * Retrieves the generic id of the corresponding bim id.
   * @param node any known node id of the working model.
   * @param bimId bim id for which you want its generic id.
   * @returns the generic id corresponding to the BimId or null if none.
   */
  getGenericIdFromBimId(t, e) {
    const i = this._modelStructure.getRuntimeNodeFromBimId(t, e);
    return i !== null ? this._modelStructure.getNodeGenericId(i) : null;
  }
  /**
   * Retrieves all type of relationships that a bim id has.
   * @param node any known node id of the working model.
   * @param bimId bim id for which you want its types of relationships.
   * @returns array of type of relationship corresponding to the BimId.
   */
  getRelationshipTypesFromBimId(t, e) {
    const i = [], s = this._modelStructure.getBimIdRelationshipTypes(t, e);
    for (const r of s)
      i.push(r.type);
    return i;
  }
  /**
   * Retrieve all related relationships that a bim id have.
   * @param node any known node id of the working model.
   * @param bimId bim id for which you want its related relationships.
   * @returns array of bim id which are the related relationship of the BimId.
   */
  getBimIdRelatedElements(t, e, i) {
    const s = this._modelStructure.getBimIdRelationshipTypes(t, e);
    for (const r of s)
      if (r.type === i)
        return r.relateds;
    return [];
  }
  /**
   * Retrieve all relating relationships that a bim id have.
   * @param node any known node id of the working model.
   * @param bimId bim id for which you want its relating relationships.
   * @returns array of bim id which are the relating relationship of the BimId.
   */
  getBimIdRelatingElements(t, e, i) {
    const s = this._modelStructure.getBimIdRelationshipTypes(t, e);
    for (const r of s)
      if (r.type === i)
        return r.relatings;
    return [];
  }
  /**
   * Retrieve all relationships that a bim id have, sorted in 2 arrays (relateds and relatings)
   * @param node any known node id of the working model.
   * @param bimId bim id for which you want its relationships.
   * @returns double array of bim id of relationship of the BimId sorted by its relateds and its relatings.
   */
  getBimIdConnectedElements(t, e, i) {
    const s = this._modelStructure.getBimIdRelationshipTypes(t, e);
    for (const r of s)
      if (r.type === i)
        return { relateds: r.relateds, relatings: r.relatings };
    return { relateds: [], relatings: [] };
  }
  /**
   * Retrieve the name of the bim element
   * @param bimId bim id for which you want the bim element name.
   * @param node any known node id of the working model.
   * @returns the name and the info regarding the connection to a node of the bim element.
   */
  getBimInfoFromBimId(t, e) {
    return this._modelStructure.getInfoOfBimId(t, e);
  }
}
var D0 = /* @__PURE__ */ ((n) => {
})(), z0 = /* @__PURE__ */ ((n) => {
})(), ps = /* @__PURE__ */ ((n) => (n[n.LoadModel = 0] = "LoadModel", n[n.CreateNode = 1] = "CreateNode", n[n.CreateInstance = 2] = "CreateInstance", n[n.CreatePmi = 3] = "CreatePmi", n))(ps || {}), b_ = /* @__PURE__ */ ((n) => (n[n.Desktop = 0] = "Desktop", n[n.Mobile = 1] = "Mobile", n))(b_ || {}), vt = /* @__PURE__ */ ((n) => (n[n.Faces = 0] = "Faces", n[n.Lines = 1] = "Lines", n[n.Points = 2] = "Points", n))(vt || {}), te = /* @__PURE__ */ ((n) => (n[n.Perspective = 0] = "Perspective", n[n.Orthographic = 1] = "Orthographic", n))(te || {}), et = /* @__PURE__ */ ((n) => (n[n.Top = 0] = "Top", n[n.Bottom = 1] = "Bottom", n[n.Left = 2] = "Left", n[n.Right = 3] = "Right", n[n.Front = 4] = "Front", n[n.Back = 5] = "Back", n[n.Iso = 6] = "Iso", n[n.TopRightFront = 7] = "TopRightFront", n[n.TopLeftFront = 8] = "TopLeftFront", n[n.TopLeftBack = 9] = "TopLeftBack", n[n.TopRightBack = 10] = "TopRightBack", n[n.TopBack = 11] = "TopBack", n[n.TopFront = 12] = "TopFront", n[n.TopLeft = 13] = "TopLeft", n[n.TopRight = 14] = "TopRight", n[n.BottomRightBack = 15] = "BottomRightBack", n[n.BottomLeftBack = 16] = "BottomLeftBack", n[n.BottomLeftFront = 17] = "BottomLeftFront", n[n.BottomRightFront = 18] = "BottomRightFront", n[n.BottomFront = 19] = "BottomFront", n[n.BottomBack = 20] = "BottomBack", n[n.BottomLeft = 21] = "BottomLeft", n[n.BottomRight = 22] = "BottomRight", n[n.RightBottomBack = 23] = "RightBottomBack", n[n.RightBottomFront = 24] = "RightBottomFront", n[n.RightTopFront = 25] = "RightTopFront", n[n.RightTopBack = 26] = "RightTopBack", n[n.RightTop = 27] = "RightTop", n[n.RightBottom = 28] = "RightBottom", n[n.RightFront = 29] = "RightFront", n[n.RightBack = 30] = "RightBack", n[n.LeftBottomFront = 31] = "LeftBottomFront", n[n.LeftBottomBack = 32] = "LeftBottomBack", n[n.LeftTopBack = 33] = "LeftTopBack", n[n.LeftTopFront = 34] = "LeftTopFront", n[n.LeftTop = 35] = "LeftTop", n[n.LeftBottom = 36] = "LeftBottom", n[n.LeftBack = 37] = "LeftBack", n[n.LeftFront = 38] = "LeftFront", n[n.FrontBottomRight = 39] = "FrontBottomRight", n[n.FrontTopRight = 40] = "FrontTopRight", n[n.FrontTopLeft = 41] = "FrontTopLeft", n[n.FrontBottomLeft = 42] = "FrontBottomLeft", n[n.FrontRight = 43] = "FrontRight", n[n.FrontLeft = 44] = "FrontLeft", n[n.FrontTop = 45] = "FrontTop", n[n.FrontBottom = 46] = "FrontBottom", n[n.BackTopRight = 47] = "BackTopRight", n[n.BackBottomRight = 48] = "BackBottomRight", n[n.BackBottomLeft = 49] = "BackBottomLeft", n[n.BackTopLeft = 50] = "BackTopLeft", n[n.BackLeft = 51] = "BackLeft", n[n.BackRight = 52] = "BackRight", n[n.BackBottom = 53] = "BackBottom", n[n.BackTop = 54] = "BackTop", n))(et || {}), Ht = /* @__PURE__ */ ((n) => (n[n.X = 0] = "X", n[n.Y = 1] = "Y", n[n.Z = 2] = "Z", n))(Ht || {}), Kt = /* @__PURE__ */ ((n) => (n[n.None = -1] = "None", n[n.Left = 0] = "Left", n[n.Middle = 1] = "Middle", n[n.Right = 2] = "Right", n))(Kt || {}), Ai = /* @__PURE__ */ ((n) => (n[n.None = 0] = "None", n[n.Left = 1] = "Left", n[n.Right = 2] = "Right", n[n.Middle = 4] = "Middle", n))(Ai || {}), Bn = /* @__PURE__ */ ((n) => (n[n.Axis = 0] = "Axis", n[n.Plane = 1] = "Plane", n[n.ViewPlane = 2] = "ViewPlane", n[n.Rotate = 3] = "Rotate", n))(Bn || {}), ws = /* @__PURE__ */ ((n) => (n[n.Translate = 0] = "Translate", n[n.Rotate = 1] = "Rotate", n))(ws || {}), Et = /* @__PURE__ */ ((n) => (n[n.Invalid = -1] = "Invalid", n[n.None = 0] = "None", n[n.Navigate = 1] = "Navigate", n[n.Orbit = 2] = "Orbit", n[n.Pan = 3] = "Pan", n[n.Zoom = 4] = "Zoom", n[n.WindowZoom = 5] = "WindowZoom", n[n.Walk = 6] = "Walk", n[n.KeyboardWalk = 7] = "KeyboardWalk", n[n.WalkMode = 8] = "WalkMode", n[n.Turntable = 9] = "Turntable", n[n.Select = 10] = "Select", n[n.AreaSelect = 11] = "AreaSelect", n[n.RayDrillSelect = 12] = "RayDrillSelect", n[n.RedlineCircle = 13] = "RedlineCircle", n[n.RedlineText = 14] = "RedlineText", n[n.RedlineRectangle = 15] = "RedlineRectangle", n[n.RedlinePolyline = 16] = "RedlinePolyline", n[n.MeasureEdgeLength = 17] = "MeasureEdgeLength", n[n.MeasureFaceFaceDistance = 18] = "MeasureFaceFaceDistance", n[n.MeasureLineLineAngle = 19] = "MeasureLineLineAngle", n[n.MeasurePointPointDistance = 20] = "MeasurePointPointDistance", n[n.MeasureBodyBodyDistance = 21] = "MeasureBodyBodyDistance", n[n.MeasureFaceFaceAngle = 22] = "MeasureFaceFaceAngle", n[n.MeasurePolylineDistance = 23] = "MeasurePolylineDistance", n[n.MeasurePolygonArea = 24] = "MeasurePolygonArea", n[n.Note = 25] = "Note", n[n.Cutting = 26] = "Cutting", n[n.Handle = 27] = "Handle", n[n.NavCube = 28] = "NavCube", n[n.AxisTriad = 29] = "AxisTriad", n[n.Floorplan = 30] = "Floorplan", n[n.SpaceMouse = 31] = "SpaceMouse", n))(Et || {}), kt = /* @__PURE__ */ ((n) => (n[n.MouseDown = 0] = "MouseDown", n[n.MouseMove = 1] = "MouseMove", n[n.MouseUp = 2] = "MouseUp", n[n.Mousewheel = 3] = "Mousewheel", n[n.TouchStart = 4] = "TouchStart", n[n.TouchMove = 5] = "TouchMove", n[n.TouchEnd = 6] = "TouchEnd", n[n.KeyDown = 7] = "KeyDown", n[n.KeyUp = 8] = "KeyUp", n[n.ViewOrientationChange = 9] = "ViewOrientationChange", n))(kt || {}), ye = /* @__PURE__ */ ((n) => (n[n.None = 0] = "None", n[n.Shift = 2] = "Shift", n[n.Alt = 4] = "Alt", n[n.Control = 8] = "Control", n[n.Command = 16] = "Command", n))(ye || {}), Gn = /* @__PURE__ */ ((n) => (n[n.Down = 0] = "Down", n[n.Up = 1] = "Up", n[n.Move = 2] = "Move", n[n.Wheel = 3] = "Wheel", n))(Gn || {}), tl = /* @__PURE__ */ ((n) => (n[n.Start = 0] = "Start", n[n.Move = 1] = "Move", n[n.End = 2] = "End", n))(tl || {}), Mc = /* @__PURE__ */ ((n) => (n[n.Down = 0] = "Down", n[n.Up = 1] = "Up", n))(Mc || {}), Ot = /* @__PURE__ */ ((n) => (n[n.Forward = 0] = "Forward", n[n.Backward = 1] = "Backward", n[n.Left = 2] = "Left", n[n.Right = 3] = "Right", n[n.Up = 4] = "Up", n[n.Down = 5] = "Down", n[n.RotateRight = 6] = "RotateRight", n[n.RotateLeft = 7] = "RotateLeft", n[n.TiltUp = 8] = "TiltUp", n[n.TiltDown = 9] = "TiltDown", n))(Ot || {}), Ut = /* @__PURE__ */ ((n) => (n[n.Backspace = 8] = "Backspace", n[n.Shift = 16] = "Shift", n[n.Escape = 27] = "Escape", n[n.PgUp = 33] = "PgUp", n[n.PgDown = 34] = "PgDown", n[n.LeftArrow = 37] = "LeftArrow", n[n.UpArrow = 38] = "UpArrow", n[n.RightArrow = 39] = "RightArrow", n[n.DownArrow = 40] = "DownArrow", n[n.Delete = 46] = "Delete", n[n.a = 65] = "a", n[n.b = 66] = "b", n[n.c = 67] = "c", n[n.d = 68] = "d", n[n.e = 69] = "e", n[n.f = 70] = "f", n[n.g = 71] = "g", n[n.h = 72] = "h", n[n.i = 73] = "i", n[n.j = 74] = "j", n[n.k = 75] = "k", n[n.l = 76] = "l", n[n.m = 77] = "m", n[n.n = 78] = "n", n[n.o = 79] = "o", n[n.p = 80] = "p", n[n.q = 81] = "q", n[n.r = 82] = "r", n[n.s = 83] = "s", n[n.t = 84] = "t", n[n.u = 85] = "u", n[n.v = 86] = "v", n[n.w = 87] = "w", n[n.x = 88] = "x", n[n.y = 89] = "y", n[n.z = 90] = "z", n[n._0 = 48] = "_0", n[n._1 = 49] = "_1", n[n._2 = 50] = "_2", n[n._3 = 51] = "_3", n[n._4 = 52] = "_4", n[n._5 = 53] = "_5", n[n._6 = 54] = "_6", n[n._7 = 55] = "_7", n[n._8 = 56] = "_8", n[n._9 = 57] = "_9", n[n.NumPad_0 = 96] = "NumPad_0", n[n.NumPad_1 = 97] = "NumPad_1", n[n.NumPad_2 = 98] = "NumPad_2", n[n.NumPad_3 = 99] = "NumPad_3", n[n.NumPad_4 = 100] = "NumPad_4", n[n.NumPad_5 = 101] = "NumPad_5", n[n.NumPad_6 = 102] = "NumPad_6", n[n.NumPad_7 = 103] = "NumPad_7", n[n.NumPad_8 = 104] = "NumPad_8", n[n.NumPad_9 = 105] = "NumPad_9", n))(Ut || {}), Xt = /* @__PURE__ */ ((n) => (n[n.None = 0] = "None", n[n.Face = 1] = "Face", n[n.Line = 2] = "Line", n[n.Point = 4] = "Point", n[n.All = 7] = "All", n))(Xt || {}), pi = /* @__PURE__ */ ((n) => (n[n.None = 0] = "None", n[n.Face = 1] = "Face", n[n.Line = 2] = "Line", n[n.Point = 3] = "Point", n[n.Part = 4] = "Part", n))(pi || {}), ai = /* @__PURE__ */ ((n) => (n[n.Set = 0] = "Set", n[n.Add = 1] = "Add", n[n.Toggle = 2] = "Toggle", n))(ai || {}), Ln = /* @__PURE__ */ ((n) => (n[n.HighlightOnly = 0] = "HighlightOnly", n[n.OutlineOnly = 1] = "OutlineOnly", n[n.HighlightAndOutline = 2] = "HighlightAndOutline", n))(Ln || {}), I_ = /* @__PURE__ */ ((n) => (n[n.Info = 0] = "Info", n[n.Warning = 1] = "Warning", n[n.Error = 2] = "Error", n))(I_ || {}), Ps = /* @__PURE__ */ ((n) => (n[n.Interactive = 1] = "Interactive", n[n.All = 2] = "All", n[n.OnDemand = 4] = "OnDemand", n[
  n.Default = 1
  /* Interactive */
] = "Default", n))(Ps || {}), qo = /* @__PURE__ */ ((n) => (n[n.Client = 0] = "Client", n[n.Server = 1] = "Server", n))(qo || {}), xn = /* @__PURE__ */ ((n) => (n[n.Wireframe = 0] = "Wireframe", n[n.Shaded = 1] = "Shaded", n[n.WireframeOnShaded = 2] = "WireframeOnShaded", n[n.HiddenLine = 3] = "HiddenLine", n[n.XRay = 4] = "XRay", n[n.Gooch = 5] = "Gooch", n[n.Toon = 6] = "Toon", n))(xn || {}), w_ = /* @__PURE__ */ ((n) => (n[n.Unsorted = 0] = "Unsorted", n[n.SingleLayer = 1] = "SingleLayer", n))(w_ || {}), Hd = /* @__PURE__ */ ((n) => (n[n.SMAA = 0] = "SMAA", n[n.None = 1] = "None", n))(Hd || {}), Fe = /* @__PURE__ */ ((n) => (n[n.DoNotExplode = 0] = "DoNotExplode", n[n.DoNotCut = 1] = "DoNotCut", n[n.DoNotSelect = 2] = "DoNotSelect", n[n.SuppressCameraScale = 3] = "SuppressCameraScale", n[n.OverrideSceneVisibility = 4] = "OverrideSceneVisibility", n[n.DoNotLight = 5] = "DoNotLight", n[n.DoNotOutlineHighlight = 6] = "DoNotOutlineHighlight", n[n.ExcludeBounding = 7] = "ExcludeBounding", n[n.DoNotUseVertexColors = 8] = "DoNotUseVertexColors", n[n.AlwaysDraw = 9] = "AlwaysDraw", n[n.DoNotXRay = 10] = "DoNotXRay", n[n.ScreenOriented = 11] = "ScreenOriented", n[n.ScreenSpace = 12] = "ScreenSpace", n[n.ScreenSpaceStretched = 13] = "ScreenSpaceStretched", n[n.DoNotReset = 14] = "DoNotReset", n))(Fe || {}), St = /* @__PURE__ */ ((n) => (n[n.None = 0] = "None", n[n.SuppressCameraScale = 1] = "SuppressCameraScale", n[n.ScreenOriented = 2] = "ScreenOriented", n[n.DoNotCut = 4] = "DoNotCut", n[n.DoNotExplode = 8] = "DoNotExplode", n[n.DoNotSelect = 16] = "DoNotSelect", n[n.DoNotLight = 32] = "DoNotLight", n[n.DoNotOutlineHighlight = 64] = "DoNotOutlineHighlight", n[n.ExcludeBounding = 128] = "ExcludeBounding", n[n.DoNotUseVertexColors = 256] = "DoNotUseVertexColors", n[n.Invisible = 512] = "Invisible", n[n.DoNotXRay = 1024] = "DoNotXRay", n[n.AlwaysDraw = 2048] = "AlwaysDraw", n[n.OverrideSceneVisibility = 4096] = "OverrideSceneVisibility", n[n.ScreenSpace = 8192] = "ScreenSpace", n[n.ScreenSpaceStretched = 16384] = "ScreenSpaceStretched", n[n.DoNotReset = 32768] = "DoNotReset", n))(St || {}), vs = /* @__PURE__ */ ((n) => (n[n.None = 0] = "None", n[n.Model = 1] = "Model", n[n.Instance = 2] = "Instance", n[n.Ejected = 4] = "Ejected", n[n.All = 7] = "All", n))(vs || {}), fo = /* @__PURE__ */ ((n) => (n[n.CameraTarget = 0] = "CameraTarget", n[n.ModelCenter = 1] = "ModelCenter", n[n.OrbitTarget = 2] = "OrbitTarget", n))(fo || {}), _o = /* @__PURE__ */ ((n) => (n[n.Mouse = 0] = "Mouse", n[n.Keyboard = 1] = "Keyboard", n))(_o || {}), At = /* @__PURE__ */ ((n) => (n[n.AssemblyNode = 0] = "AssemblyNode", n[n.PartInstance = 1] = "PartInstance", n[n.Part = 2] = "Part", n[n.BodyInstance = 3] = "BodyInstance", n[n.PmiBody = 4] = "PmiBody", n[n.ViewFrame = 5] = "ViewFrame", n[n.Body = 6] = "Body", n[n.BrepBody = 7] = "BrepBody", n[n.TessBody = 8] = "TessBody", n[n.WireBody = 9] = "WireBody", n[n.PointsBody = 10] = "PointsBody", n[n.Pmi = 11] = "Pmi", n[n.CadView = 12] = "CadView", n[n.DrawingSheet = 13] = "DrawingSheet", n[n.Unknown = 14] = "Unknown", n))(At || {}), Ud = /* @__PURE__ */ ((n) => (n[n.Unknown = 0] = "Unknown", n[n.Text = 1] = "Text", n[n.Dimension = 2] = "Dimension", n[n.Arrow = 3] = "Arrow", n[n.Balloon = 4] = "Balloon", n[n.CircleCenter = 5] = "CircleCenter", n[n.Coordinate = 6] = "Coordinate", n[n.Datum = 7] = "Datum", n[n.Fastener = 8] = "Fastener", n[n.Gdt = 9] = "Gdt", n[n.Locator = 10] = "Locator", n[n.MeasurementPoint = 11] = "MeasurementPoint", n[n.Roughness = 12] = "Roughness", n[n.Welding = 13] = "Welding", n[n.Table = 14] = "Table", n[n.Other = 15] = "Other", n[n.GeometricalTolerance = 16] = "GeometricalTolerance", n))(Ud || {}), Qd = /* @__PURE__ */ ((n) => (n[n.Unknown = 0] = "Unknown", n[n.DatumIdent = 1] = "DatumIdent", n[n.DatumTarget = 2] = "DatumTarget", n[n.DimensionDistance = 1] = "DimensionDistance", n[n.DimensionDistanceOffset = 2] = "DimensionDistanceOffset", n[n.DimensionDistanceCumulate = 3] = "DimensionDistanceCumulate", n[n.DimensionChamfer = 4] = "DimensionChamfer", n[n.DimensionSlope = 5] = "DimensionSlope", n[n.DimensionOrdinate = 6] = "DimensionOrdinate", n[n.DimensionRadius = 7] = "DimensionRadius", n[n.DimensionRadiusTangent = 8] = "DimensionRadiusTangent", n[n.DimensionRadiusCylinder = 9] = "DimensionRadiusCylinder", n[n.DimensionRadiusEdge = 10] = "DimensionRadiusEdge", n[n.DimensionDiameter = 11] = "DimensionDiameter", n[n.DimensionDiameterTangent = 12] = "DimensionDiameterTangent", n[n.DimensionDiameterCylinder = 13] = "DimensionDiameterCylinder", n[n.DimensionDiameterEdge = 14] = "DimensionDiameterEdge", n[n.DimensionDiameterCone = 15] = "DimensionDiameterCone", n[n.DimensionLength = 16] = "DimensionLength", n[n.DimensionLengthCurvilinear = 17] = "DimensionLengthCurvilinear", n[n.DimensionLengthCircular = 18] = "DimensionLengthCircular", n[n.DimensionAngle = 19] = "DimensionAngle", n[n.GdtFcf = 1] = "GdtFcf", n[n.WeldingLine = 1] = "WeldingLine", n[n.WeldingSpot = 2] = "WeldingSpot", n[n.OtherSymbolUser = 1] = "OtherSymbolUser", n[n.OtherSymbolUtility = 2] = "OtherSymbolUtility", n[n.OtherSymbolCustom = 3] = "OtherSymbolCustom", n[n.OtherGeometricReference = 4] = "OtherGeometricReference", n[n.OtherRegion = 5] = "OtherRegion", n))(Qd || {}), $o = /* @__PURE__ */ ((n) => (n[n.Unknown = -1] = "Unknown", n[n.Context = 1] = "Context", n[n.Item = 2] = "Item", n[n.MultipleVertex = 3] = "MultipleVertex", n[n.UniqueVertex = 4] = "UniqueVertex", n[n.WireEdge = 5] = "WireEdge", n[n.Edge = 6] = "Edge", n[n.CoEdge = 7] = "CoEdge", n[n.Loop = 8] = "Loop", n[n.Face = 9] = "Face", n[n.Shell = 10] = "Shell", n[n.Connex = 11] = "Connex", n[n.Body = 12] = "Body", n[n.SingleWireBody = 13] = "SingleWireBody", n[n.BrepData = 14] = "BrepData", n[n.WireBody = 17] = "WireBody", n))($o || {}), yn = /* @__PURE__ */ ((n) => (n[n.Unknown = 0] = "Unknown", n[n.Clockwise = 1] = "Clockwise", n[n.CounterClockwise = 2] = "CounterClockwise", n))(yn || {}), Jt = /* @__PURE__ */ ((n) => (n[n.UpperLeftCorner = 0] = "UpperLeftCorner", n[n.LowerLeftCorner = 1] = "LowerLeftCorner", n[n.LowerRightCorner = 2] = "LowerRightCorner", n[n.UpperRightCorner = 3] = "UpperRightCorner", n[n.TopCenter = 4] = "TopCenter", n[n.LeftCenter = 5] = "LeftCenter", n[n.RightCenter = 6] = "RightCenter", n[n.BottomCenter = 7] = "BottomCenter", n[n.Center = 8] = "Center", n))(Jt || {}), Bt = /* @__PURE__ */ ((n) => (n[n.Pixels = 0] = "Pixels", n[n.ProportionOfCanvas = 1] = "ProportionOfCanvas", n[n.MinimumProportionOfCanvas = 2] = "MinimumProportionOfCanvas", n[n.ProportionOfOtherDimension = 3] = "ProportionOfOtherDimension", n))(Bt || {}), Wc = /* @__PURE__ */ ((n) => (n[n.ScreenPixels = 0] = "ScreenPixels", n[n.CSSPixels = 1] = "CSSPixels", n[n.World = 2] = "World", n[n.ProportionOfScreenWidth = 3] = "ProportionOfScreenWidth", n[n.ProportionOfScreenHeight = 4] = "ProportionOfScreenHeight", n[n.ProportionOfBoundingDiagonal = 5] = "ProportionOfBoundingDiagonal", n))(Wc || {}), Pc = /* @__PURE__ */ ((n) => (n[n.Square = 0] = "Square", n[n.Disk = 1] = "Disk", n[n.Sphere = 2] = "Sphere", n))(Pc || {});
class v_ {
  constructor() {
    this.bodyId = jd, this.subElementType = -1, this.subElementIndex = -1;
  }
}
var Pt = /* @__PURE__ */ ((n) => (n[n.Hidden = 0] = "Hidden", n[n.Shown = 1] = "Shown", n[n.Mixed = 2] = "Mixed", n))(Pt || {}), S_ = /* @__PURE__ */ ((n) => (n[n.Object = 0] = "Object", n[n.World = 1] = "World", n))(S_ || {}), Vt = /* @__PURE__ */ ((n) => (n[n.First = 8] = "First", n[
  n.Handles = 8
  /* First */
] = "Handles", n[n.AxisTriad = 9] = "AxisTriad", n[n.NavCube = 10] = "NavCube", n[n.Floorplan = 11] = "Floorplan", n[n.TestFramework = 12] = "TestFramework", n))(Vt || {});
class x_ {
  constructor() {
    this.pos1 = d.zero(), this.pos2 = d.zero(), this.distance = 0;
  }
}
class mu {
  constructor() {
    this.frontVector = new d(-1, 0, 0), this.upVector = new d(0, 0, 1);
  }
}
var Z_ = /* @__PURE__ */ ((n) => (n[n.Object = 0] = "Object", n[n.World = 1] = "World", n[n.ProportionOfScreenWidth = 2] = "ProportionOfScreenWidth", n[n.ProportionOfScreenHeight = 3] = "ProportionOfScreenHeight", n))(Z_ || {}), ta = /* @__PURE__ */ ((n) => (n[n.Selected = 0] = "Selected", n[n.Unselected = 1] = "Unselected", n))(ta || {}), mn = /* @__PURE__ */ ((n) => (n[n.Pixels = 0] = "Pixels", n[n.ProportionOfWidth = 1] = "ProportionOfWidth", n[n.ProportionOfHeight = 2] = "ProportionOfHeight", n))(mn || {}), Jn = /* @__PURE__ */ ((n) => (n[n.Undefined = 0] = "Undefined", n[n.Int = 1] = "Int", n[n.Float = 2] = "Float", n[n.Time = 3] = "Time", n[n.String = 4] = "String", n[n.Ignored = 5] = "Ignored", n))(Jn || {});
class pu {
  constructor(t, e) {
    this.isInclusive = t, this.nodeIds = e;
  }
}
class C_ {
  constructor(t, e) {
    this.defaultVisibility = t, this.visibilityExceptions = e;
  }
}
class mr {
  constructor() {
    this.additionalMatrix = null, this.allowMissingExternalModels = !1, this.attachInvisibly = !1, this.implicitlyLoadXmlExternalModels = !0, this.ignoreCadViews = !1, this.ignoreFilters = !1, this.ignoreLayers = !1, this.ignoreGenericTypes = !1, this.ignoreBimRelationships = !1, this._allowSubtreeLoadedCallback = !0;
  }
  copy() {
    const t = new mr();
    return t.additionalMatrix = this.additionalMatrix, t.additionalMatrix !== null && (t.additionalMatrix = t.additionalMatrix.copy()), t.allowMissingExternalModels = this.allowMissingExternalModels, t.attachInvisibly = this.attachInvisibly, t.implicitlyLoadXmlExternalModels = this.implicitlyLoadXmlExternalModels, t.ignoreCadViews = this.ignoreCadViews, t.ignoreFilters = this.ignoreFilters, t.ignoreLayers = this.ignoreLayers, t.ignoreGenericTypes = this.ignoreGenericTypes, t.ignoreBimRelationships = this.ignoreBimRelationships, t._allowSubtreeLoadedCallback = this._allowSubtreeLoadedCallback, t;
  }
}
var Vo = /* @__PURE__ */ ((n) => (n[n.Unknown = 0] = "Unknown", n[n.Catia = 2] = "Catia", n[n.CatiaV5 = 3] = "CatiaV5", n[n.Cadds = 4] = "Cadds", n[n.Unigraphics = 5] = "Unigraphics", n[n.Parasolid = 6] = "Parasolid", n[n.Euclid = 7] = "Euclid", n[n.Iges = 9] = "Iges", n[n.Unisurf = 10] = "Unisurf", n[n.Vda = 11] = "Vda", n[n.Stl = 12] = "Stl", n[n.Wrl = 13] = "Wrl", n[n.Dxf = 14] = "Dxf", n[n.Acis = 15] = "Acis", n[n.ProE = 16] = "ProE", n[n.Step = 18] = "Step", n[n.Ideas = 19] = "Ideas", n[n.Jt = 20] = "Jt", n[n.Slw = 22] = "Slw", n[n.Cgr = 23] = "Cgr", n[n.Prc = 24] = "Prc", n[n.Xvl = 25] = "Xvl", n[n.Hpgl = 26] = "Hpgl", n[n.TopSolid = 27] = "TopSolid", n[n.OneSpaceDesigner = 28] = "OneSpaceDesigner", n[n._3dxml = 29] = "_3dxml", n[n.Inventor = 30] = "Inventor", n[n.PostScript = 31] = "PostScript", n[n.Pdp = 32] = "Pdp", n[n.U3d = 33] = "U3d", n[n.Ifc = 34] = "Ifc", n[n.Dwg = 35] = "Dwg", n[n.Dwf = 36] = "Dwf", n[n.Se = 37] = "Se", n[n.Obj = 38] = "Obj", n[n.Kmz = 39] = "Kmz", n[n.Dae = 40] = "Dae", n[n._3ds = 41] = "_3ds", n[n.Rhino = 43] = "Rhino", n[n.Xml = 44] = "Xml", n[n._3mf = 45] = "_3mf", n[n.Scs = 46] = "Scs", n[n._3dHtml = 47] = "_3dHtml", n[n.Hsf = 48] = "Hsf", n[n.Gltf = 49] = "Gltf", n[n.Revit = 50] = "Revit", n[n.Fbx = 51] = "Fbx", n))(Vo || {}), Gc = /* @__PURE__ */ ((n) => (n[n.World = 0] = "World", n[n.ProportionOfBoundingHeight = 1] = "ProportionOfBoundingHeight", n))(Gc || {}), k_ = /* @__PURE__ */ ((n) => (n[n.Default = 0] = "Default", n[n.PerNode = 1] = "PerNode", n))(k_ || {}), Vr = /* @__PURE__ */ ((n) => (n[n.NorthUp = 0] = "NorthUp", n[n.AvatarUp = 1] = "AvatarUp", n))(Vr || {}), qd = /* @__PURE__ */ ((n) => (n[n.ContainedInSpatialStructure = 0] = "ContainedInSpatialStructure", n[n.Aggregates = 1] = "Aggregates", n[n.VoidsElement = 2] = "VoidsElement", n[n.FillsElement = 3] = "FillsElement", n[n.SpaceBoundary = 4] = "SpaceBoundary", n[n.ConnectsPathElements = 5] = "ConnectsPathElements", n[n.Undefined = 6] = "Undefined", n))(qd || {}), $d = /* @__PURE__ */ ((n) => (n[n.FixedFramerate = 0] = "FixedFramerate", n[n.OcclusionCulling = 1] = "OcclusionCulling", n))($d || {}), Oi = /* @__PURE__ */ ((n) => (n[n.Rgba32 = 0] = "Rgba32", n[n.Rgb24 = 1] = "Rgb24", n[n.Gray8 = 2] = "Gray8", n[n.GrayAlpha16 = 3] = "GrayAlpha16", n[n.Jpeg = 4] = "Jpeg", n[n.Png = 5] = "Png", n))(Oi || {}), Yc = /* @__PURE__ */ ((n) => (n[n.Clamp = 0] = "Clamp", n[n.Repeat = 1] = "Repeat", n[n.Trim = 2] = "Trim", n))(Yc || {}), M_ = /* @__PURE__ */ ((n) => (n[n.UV = 0] = "UV", n))(M_ || {}), W_ = /* @__PURE__ */ ((n) => (n[n.Decal = 1] = "Decal", n))(W_ || {}), To = /* @__PURE__ */ ((n) => (n[n.Model = 1] = "Model", n[n.Svg = 2] = "Svg", n[n.Html = 4] = "Html", n[n.All = 7] = "All", n))(To || {});
class Mt extends Error {
  /**
   * Creates a new CommunicatorError
   */
  constructor(t) {
    super(t), Object.setPrototypeOf(this, Mt.prototype);
  }
}
class xh extends Mt {
  /**
   * Creates a new InvalidIndexError
   */
  constructor(t) {
    super(`Invalid index (${t}).`), Object.setPrototypeOf(this, xh.prototype);
  }
}
class Ms extends Mt {
  /**
   * Creates a new PickOutsideCanvasError
   */
  constructor() {
    super("Cannot pick from outside the canvas area."), Object.setPrototypeOf(this, Ms.prototype);
  }
}
class as extends Mt {
  /**
   * Creates a new SelectionInvalidatedError
   */
  constructor() {
    super("Selection invalidated."), Object.setPrototypeOf(this, as.prototype);
  }
}
class re extends Mt {
  /**
   * Creates a new InternalLogicError
   */
  constructor() {
    super("Internal logic error."), Object.setPrototypeOf(this, re.prototype);
  }
}
class sn extends Mt {
  /**
   * Creates a new InvalidNodeIdError
   */
  constructor(t) {
    super(`Invalid node (${t}).`), Object.setPrototypeOf(this, sn.prototype), this.nodeId = t;
  }
}
class Vi extends Mt {
  /**
   * Creates a new InvalidNodeTypeError
   */
  constructor(t, e, ...i) {
    i.push(e);
    const s = [];
    for (const a of i)
      switch (a) {
        case li.ProductOccurrence:
          s.push(At.DrawingSheet, At.PartInstance, At.AssemblyNode);
          break;
        case li.AnyBody:
          s.push(At.BodyInstance), s.push(At.PmiBody), s.push(At.ViewFrame);
          break;
        case li.BodyInstance:
          s.push(At.BodyInstance);
          break;
        case li.CadView:
          s.push(At.CadView);
          break;
        default:
          $n();
      }
    s.sort();
    const r = [];
    for (const a of s)
      r.push(At[a]);
    const o = r.length === 1 ? `type (${r[0]})` : `types ${r}`;
    super(`Expected node (${t}) to be of ${o}.`), Object.setPrototypeOf(this, Vi.prototype), this.nodeId = t, this.expectedTypes = s;
  }
}
class ts extends Mt {
  /**
   * Creates a new LoadError
   */
  constructor(t) {
    super(t), Object.setPrototypeOf(this, ts.prototype);
  }
}
class Xl extends ts {
  /**
   * Creates a new LoadCancelledError
   */
  constructor() {
    super("Load cancelled."), Object.setPrototypeOf(this, Xl.prototype);
  }
}
class Fl extends ts {
  /**
   * Creates a new MissingModelError
   */
  constructor(t) {
    super(`Missing model: '${t}'.`), Object.setPrototypeOf(this, Fl.prototype);
  }
}
class fn extends Mt {
  /**
   * Creates a new ParseError
   */
  constructor(t) {
    super(t), Object.setPrototypeOf(this, fn.prototype);
  }
}
class pr extends fn {
  /**
   * Creates a new AssemblyDataParseError
   */
  constructor(t) {
    super(t), Object.setPrototypeOf(this, pr.prototype);
  }
}
class ce extends fn {
  /**
   * Creates a new XmlParseError
   */
  constructor(t) {
    super(t), Object.setPrototypeOf(this, ce.prototype);
  }
}
function P_(n) {
  return G_(n);
}
function G_(n) {
  const t = new tm();
  for (const i of n)
    i._gatherForExport(t);
  const e = {};
  if (!t.buffers.isEmpty()) {
    e.buffers = [];
    for (const i of t.buffers.toArray())
      e.buffers.push(i._export());
  }
  if (!t.samplers.isEmpty()) {
    e.samplers = [];
    for (const i of t.samplers.toArray())
      e.samplers.push(i._export(t));
  }
  if (!t.colorMaps.isEmpty()) {
    e.colorMaps = [];
    for (const i of t.colorMaps.toArray())
      e.colorMaps.push(V_(i));
  }
  if (n.length !== 0) {
    e.animations = [];
    for (const i of n)
      e.animations.push(i._export(t));
  }
  return {
    ...e
  };
}
function Y_(n) {
  const t = n, e = new em();
  if (t.buffers !== void 0)
    for (const s of t.buffers)
      e.buffers.push(da._import(s));
  if (t.samplers !== void 0)
    for (const s of t.samplers)
      e.samplers.push(ln._import(e, s));
  if (t.colorMaps !== void 0)
    for (const s of t.colorMaps)
      e.colorMaps.push(T_(s));
  const i = [];
  if (t.animations !== void 0)
    for (const s of t.animations)
      i.push(Tl._import(e, s));
  return i;
}
function V_(n) {
  const t = [];
  for (const e of n)
    t.push([e.position, e.color.r, e.color.g, e.color.b]);
  return t;
}
function T_(n) {
  const t = [];
  for (const e of n)
    t.push({
      position: e[0],
      color: new it(e[1], e[2], e[3])
    });
  return t;
}
class tm {
  constructor() {
    this.buffers = new el(), this.samplers = new el(), this.colorMaps = new el();
  }
}
class em {
  constructor() {
    this.buffers = [], this.samplers = [], this.colorMaps = [];
  }
}
class el {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  add(t) {
    this.map.has(t) || this.map.set(t, this.map.size);
  }
  getIndex(t) {
    const e = this.map.get(t);
    if (e === void 0)
      throw new re();
    return e;
  }
  /**
   * Returns an array containing each element of the set placed at its
   * assigned index.
   */
  toArray() {
    const t = [];
    return this.map.forEach((e, i) => {
      t[e] = i;
    }), t;
  }
  isEmpty() {
    return this.map.size === 0;
  }
}
var im = /* @__PURE__ */ ((n) => (n[n.Stopped = 0] = "Stopped", n[n.Playing = 1] = "Playing", n[n.Paused = 2] = "Paused", n[n.Complete = 3] = "Complete", n))(im || {});
class Zh {
  /** @hidden Do not use.  Create via Animation.Manager API instead. */
  constructor(t, e) {
    this._viewer = t, this.animation = e, this._nodeValues = /* @__PURE__ */ new Map(), this._disabledChannels = /* @__PURE__ */ new Set(), this._currentTime = 0, this._lastUpdate = 0, this.speed = 1, this._animationTime = 0, this._state = 0, this.loop = 0, this._loopCount = 0, this.onComplete = null, this.nodeIdOffset = 0, this.reload();
  }
  /** Sets the enabled state for a channel in this players animation.
   * All channels are enabled by default when a player is created.
   * A channel that has been disabled will not have its value interpolated by the system until it is re-enabled
   * @param channel a channel from the underlying animation
   * @param enabled boolean value indicating whether the channel should be enabled.
   */
  setChannelEnabled(t, e) {
    e ? this._disabledChannels.delete(t) : this._disabledChannels.add(t);
  }
  /**
   * Updates internal state of animation player.
   *
   * Call this method after any part of the underlying animation has been updated.
   * */
  reload() {
    this._nodeValues.clear(), this._animationTime = 0;
    for (const t of this.animation.nodeChannels) {
      const e = t.sampler.buffer.times.length;
      if (e !== 0) {
        if (!this._nodeValues.has(t.nodeId)) {
          const i = new Qu(t.nodeId);
          i.pivotPoint = this.animation.pivotPoints.get(t.nodeId), this._nodeValues.set(t.nodeId, i);
        }
        this._animationTime = Math.max(this._animationTime, t.sampler.buffer.times[e - 1]);
      }
    }
    for (const t of this.animation.cameraChannels) {
      const e = t.sampler.buffer.times.length;
      e !== 0 && (this._animationTime = Math.max(this._animationTime, t.sampler.buffer.times[e - 1]));
    }
  }
  /**
   * Called automatically by the Animation.Manager when it is updating all animations.
   * @returns True if values were modified.
   * @hidden
   */
  _tick(t, e) {
    if (this._state !== 1)
      return !1;
    const i = (t - this._lastUpdate) / 1e3;
    return this._tickTime(i, e), this._lastUpdate = t, !0;
  }
  /**
   * Updates the animation using the supplied delta time specified in seconds.
   * @returns True if values were modified.
   * @hidden
   */
  _tickTime(t, e) {
    if (this._state !== 1)
      return !1;
    this._currentTime += t * this.speed;
    const i = this._currentTime < 0, s = this._currentTime > this._animationTime;
    return i || s ? this.loop < 0 || this.loop > this._loopCount ? (this._loopCount += 1, this._currentTime = i ? this._animationTime : 0, this.evaluate(this._currentTime, e)) : (this._currentTime = this._animationTime, this.evaluate(this._currentTime, e), this._state = 3, this._loopCount = 0, this.onComplete && this.onComplete()) : this.evaluate(this._currentTime, e), !0;
  }
  /** Starts playing the animation. */
  play() {
    this._state !== 1 && (this._state === 3 && (this._currentTime = 0), this._lastUpdate = performance.now(), this._state = 1);
  }
  /** Pauses animation playback. */
  pause() {
    this._state === 1 && (this._state = 2);
  }
  /** Stops animation playback and resets the current time to 0. */
  stop() {
    this._state = 0, this.setTime(0);
  }
  /**
   * Sets the current animation time.
   * @param time time in milliseconds
   */
  setTime(t) {
    const e = new dl();
    this._currentTime = Math.min(t, this._animationTime), this.evaluate(this._currentTime, e), e.apply(this._viewer);
  }
  /**
   * Calculate the values for each channel of the associated [[Animation]]
   * at the given time.
   *
   * @param time The time at which to evaluate the animation.
   * @param out Storage for the evaluated values. If supplied, this object
   * will be returned instead of a new [[BatchedValues]] object. This
   * allows values gathered from multiple players to be combined into one
   * batch.
   */
  evaluate(t, e) {
    e === void 0 && (e = new dl());
    for (const i of this.animation.nodeChannels) {
      const s = this._nodeValues.get(i.nodeId);
      s !== void 0 && !this._disabledChannels.has(i) && i._getValue(t, s);
    }
    this._nodeValues.forEach((i) => {
      if (e === void 0)
        throw new re();
      const s = i.nodeId + this.nodeIdOffset;
      (i.flags & di.Transform) === di.Transform && (i.updateMatrix(), e.node.matrixNodeIds.push(s), e.node.matrices.push(i.matrix)), (i.flags & di.Opacity) === di.Opacity && e.node.opacities.set(s, i.opacity), (i.flags & di.Visibility) === di.Visibility && (i.visibility !== 0 ? e.node.visibilityOn.push(s) : e.node.visibilityOff.push(s)), (i.flags & di.Color) === di.Color && e.node.colors.set(
        s,
        new it(i.color.x, i.color.y, i.color.z)
      ), i.flags = di.None;
    });
    for (const i of this.animation.cameraChannels)
      i.sampler.buffer.times.length > 0 && !this._disabledChannels.has(i) && i._getValue(t, e.camera);
    return e;
  }
  /** Gets the current animation state. */
  getState() {
    return this._state;
  }
  /** Gets the current time in seconds that the animation has been playing. */
  getCurrentTime() {
    return this._currentTime;
  }
  /** Gets the current time in seconds of the entire animation. */
  getAnimationTime() {
    return this._animationTime;
  }
}
Zh.LoopIndefinitely = -1;
class nm {
  /** @hidden Created during WebViewer Initialization. */
  constructor(t) {
    this._viewer = t, this._players = [], this._intervalHandle = null, this._batch = new dl(), this._viewer.setCallbacks({
      assemblyTreeReady: () => {
        this.setTickInterval(50);
      }
    });
  }
  /** Creates a new animation player for the supplied animation. */
  createPlayer(t) {
    const e = new Zh(this._viewer, t);
    return this._players.push(e), e;
  }
  /** Removes the player at the provided index from control of the manager. Returns `true` if a player was removed */
  removePlayerByIndex(t) {
    return t >= this._players.length ? !1 : (this._players.splice(t, 1), !0);
  }
  /** Removes the provided player from control of the manager. Returns `true` is a player was removed */
  removePlayer(t) {
    for (let e = 0; e < this._players.length; e++)
      if (this._players[e] === t)
        return this._players.splice(e, 1), !0;
    return !1;
  }
  /** Removes all players from control of the manager. */
  clear() {
    this._players = [];
  }
  _tick() {
    if (this._players.length === 0)
      return;
    this._batch.clear();
    let t = !1;
    const e = performance.now();
    for (const i of this._players)
      i._tick(e, this._batch) && (t = !0);
    t && (this._viewer.pauseRendering(), this._batch.apply(this._viewer), this._viewer.resumeRendering());
  }
  /** @hidden  Called by the web viewer only*/
  _shutdown() {
    this._intervalHandle !== null && clearInterval(this._intervalHandle);
  }
  /**
   * Sets the interval at which animations are updated.
   * @param milliseconds number of milliseconds between update intervals
   */
  setTickInterval(t) {
    this._intervalHandle && clearInterval(this._intervalHandle), this._intervalHandle = setInterval(() => {
      this._tick();
    }, t);
  }
}
function ro(n, t, e, i) {
  const s = e === Mn.Width || e === Mn.Height ? rn.Scalar : rn.Vec3, r = new da(s), o = new ln(r, i);
  return n.createCameraChannel(t, e, o);
}
function E_(n, t, e) {
  const i = [];
  return i.push(
    ro(
      n,
      `${t}-Position`,
      Mn.Position,
      e
    )
  ), i.push(
    ro(
      n,
      `${t}-Target`,
      Mn.Target,
      e
    )
  ), i.push(
    ro(n, `${t}-Up`, Mn.Up, e)
  ), i.push(
    ro(n, `${t}-Width`, Mn.Width, e)
  ), i.push(
    ro(
      n,
      `${t}-Height`,
      Mn.Height,
      e
    )
  ), i;
}
function R_(n, t, e) {
  const i = t.getPosition();
  e.cameraChannels[0].sampler.buffer.insertVec3Keyframe(
    n,
    i.x,
    i.y,
    i.z
  );
  const s = t.getTarget();
  e.cameraChannels[1].sampler.buffer.insertVec3Keyframe(n, s.x, s.y, s.z);
  const r = t.getUp();
  e.cameraChannels[2].sampler.buffer.insertVec3Keyframe(n, r.x, r.y, r.z), e.cameraChannels[3].sampler.buffer.insertScalarKeyframe(n, t.getWidth()), e.cameraChannels[4].sampler.buffer.insertScalarKeyframe(n, t.getHeight());
}
const B0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Animation: Tl,
  BatchedCameraValues: qu,
  BatchedNodeValues: $u,
  BatchedValues: dl,
  CameraChannel: No,
  CameraProperty: Mn,
  ExportContext: tm,
  ImportContext: em,
  IndexedSet: el,
  InterpolationType: pl,
  KeyType: rn,
  KeyframeBuffer: da,
  Manager: nm,
  NodeChannel: Ro,
  NodeProperty: ml,
  NodeValues: Qu,
  NodeValuesFlags: di,
  Player: Zh,
  PlayerState: im,
  Sampler: ln,
  createCameraChannels: E_,
  exportAnimations: P_,
  importAnimations: Y_,
  keyframeCamera: R_
}, Symbol.toStringTag, { value: "Module" }));
var pn = /* @__PURE__ */ ((n) => (n[n.Unknown = 0] = "Unknown", n[n.v1_0 = 1] = "v1_0", n[n.v2_0 = 2] = "v2_0", n[n.v2_1 = 3] = "v2_1", n))(pn || {}), Ci = /* @__PURE__ */ ((n) => (n[n.Unknown = 0] = "Unknown", n[n.TopicFolder = 1] = "TopicFolder", n[n.Version = 2] = "Version", n[n.Markup = 3] = "Markup", n[n.Snapshot = 4] = "Snapshot", n[n.Viewpoint = 5] = "Viewpoint", n[n.Schema = 6] = "Schema", n[n.Project = 7] = "Project", n))(Ci || {});
const Xn = "HOOPS Communicator";
function yo(n) {
  return n ? "true" : "false";
}
function il(n, t) {
  const e = n.createElement("Component");
  return t.ifcGuid !== void 0 && e.setAttribute("IfcGuid", t.ifcGuid), t.originatingSystem !== void 0 && e.setAttribute("OriginatingSystem", t.originatingSystem), t.authoringToolId !== void 0 && e.setAttribute("AuthoringToolId", t.authoringToolId.toString()), e;
}
function Aa(n) {
  return n.length === 1 ? `0${n}` : n;
}
function sm(n, t) {
  const e = t ? Aa(Math.round(t).toString(16)) : "", i = Aa(Math.round(n.r).toString(16)), s = Aa(Math.round(n.g).toString(16)), r = Aa(Math.round(n.b).toString(16));
  return `${e}${i}${s}${r}`;
}
function Zn(n, t, e) {
  const i = n.createElement("X"), s = n.createElement("Y"), r = n.createElement("Z");
  i.innerHTML = e.x.toString(), s.innerHTML = e.y.toString(), r.innerHTML = e.z.toString(), t.appendChild(i), t.appendChild(s), t.appendChild(r);
}
function Fn(n, t, e) {
  e != null && n.setAttribute(t, e);
}
function On(n, t, e, i) {
  const s = n.createElement(e);
  s.innerHTML = i, t.appendChild(s);
}
function Be(n, t, e, i) {
  i != null && On(n, t, e, i);
}
function bo(n) {
  return n == null ? null : n.toISOString();
}
function Vc(n) {
  return n == null ? null : n.toString();
}
function nl(n) {
  return n == null ? null : n ? "true" : "false";
}
function Da(n) {
  throw new Error('Could not dynamically require "' + n + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var rm = { exports: {} };
/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/
(function(n, t) {
  (function(e) {
    n.exports = e();
  })(function() {
    return function e(i, s, r) {
      function o(c, h) {
        if (!s[c]) {
          if (!i[c]) {
            var u = typeof Da == "function" && Da;
            if (!h && u)
              return u(c, !0);
            if (a)
              return a(c, !0);
            var p = new Error("Cannot find module '" + c + "'");
            throw p.code = "MODULE_NOT_FOUND", p;
          }
          var m = s[c] = { exports: {} };
          i[c][0].call(m.exports, function(g) {
            var _ = i[c][1][g];
            return o(_ || g);
          }, m, m.exports, e, i, s, r);
        }
        return s[c].exports;
      }
      for (var a = typeof Da == "function" && Da, l = 0; l < r.length; l++)
        o(r[l]);
      return o;
    }({ 1: [function(e, i, s) {
      var r = e("./utils"), o = e("./support"), a = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      s.encode = function(l) {
        for (var c, h, u, p, m, g, _, y = [], b = 0, w = l.length, v = w, C = r.getTypeOf(l) !== "string"; b < l.length; )
          v = w - b, u = C ? (c = l[b++], h = b < w ? l[b++] : 0, b < w ? l[b++] : 0) : (c = l.charCodeAt(b++), h = b < w ? l.charCodeAt(b++) : 0, b < w ? l.charCodeAt(b++) : 0), p = c >> 2, m = (3 & c) << 4 | h >> 4, g = 1 < v ? (15 & h) << 2 | u >> 6 : 64, _ = 2 < v ? 63 & u : 64, y.push(a.charAt(p) + a.charAt(m) + a.charAt(g) + a.charAt(_));
        return y.join("");
      }, s.decode = function(l) {
        var c, h, u, p, m, g, _ = 0, y = 0, b = "data:";
        if (l.substr(0, b.length) === b)
          throw new Error("Invalid base64 input, it looks like a data url.");
        var w, v = 3 * (l = l.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
        if (l.charAt(l.length - 1) === a.charAt(64) && v--, l.charAt(l.length - 2) === a.charAt(64) && v--, v % 1 != 0)
          throw new Error("Invalid base64 input, bad content length.");
        for (w = o.uint8array ? new Uint8Array(0 | v) : new Array(0 | v); _ < l.length; )
          c = a.indexOf(l.charAt(_++)) << 2 | (p = a.indexOf(l.charAt(_++))) >> 4, h = (15 & p) << 4 | (m = a.indexOf(l.charAt(_++))) >> 2, u = (3 & m) << 6 | (g = a.indexOf(l.charAt(_++))), w[y++] = c, m !== 64 && (w[y++] = h), g !== 64 && (w[y++] = u);
        return w;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(e, i, s) {
      var r = e("./external"), o = e("./stream/DataWorker"), a = e("./stream/Crc32Probe"), l = e("./stream/DataLengthProbe");
      function c(h, u, p, m, g) {
        this.compressedSize = h, this.uncompressedSize = u, this.crc32 = p, this.compression = m, this.compressedContent = g;
      }
      c.prototype = { getContentWorker: function() {
        var h = new o(r.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new l("data_length")), u = this;
        return h.on("end", function() {
          if (this.streamInfo.data_length !== u.uncompressedSize)
            throw new Error("Bug : uncompressed data size mismatch");
        }), h;
      }, getCompressedWorker: function() {
        return new o(r.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      } }, c.createWorkerFrom = function(h, u, p) {
        return h.pipe(new a()).pipe(new l("uncompressedSize")).pipe(u.compressWorker(p)).pipe(new l("compressedSize")).withStreamInfo("compression", u);
      }, i.exports = c;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e, i, s) {
      var r = e("./stream/GenericWorker");
      s.STORE = { magic: "\0\0", compressWorker: function() {
        return new r("STORE compression");
      }, uncompressWorker: function() {
        return new r("STORE decompression");
      } }, s.DEFLATE = e("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e, i, s) {
      var r = e("./utils"), o = function() {
        for (var a, l = [], c = 0; c < 256; c++) {
          a = c;
          for (var h = 0; h < 8; h++)
            a = 1 & a ? 3988292384 ^ a >>> 1 : a >>> 1;
          l[c] = a;
        }
        return l;
      }();
      i.exports = function(a, l) {
        return a !== void 0 && a.length ? r.getTypeOf(a) !== "string" ? function(c, h, u, p) {
          var m = o, g = p + u;
          c ^= -1;
          for (var _ = p; _ < g; _++)
            c = c >>> 8 ^ m[255 & (c ^ h[_])];
          return -1 ^ c;
        }(0 | l, a, a.length, 0) : function(c, h, u, p) {
          var m = o, g = p + u;
          c ^= -1;
          for (var _ = p; _ < g; _++)
            c = c >>> 8 ^ m[255 & (c ^ h.charCodeAt(_))];
          return -1 ^ c;
        }(0 | l, a, a.length, 0) : 0;
      };
    }, { "./utils": 32 }], 5: [function(e, i, s) {
      s.base64 = !1, s.binary = !1, s.dir = !1, s.createFolders = !0, s.date = null, s.compression = null, s.compressionOptions = null, s.comment = null, s.unixPermissions = null, s.dosPermissions = null;
    }, {}], 6: [function(e, i, s) {
      var r = null;
      r = typeof Promise < "u" ? Promise : e("lie"), i.exports = { Promise: r };
    }, { lie: 37 }], 7: [function(e, i, s) {
      var r = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", o = e("pako"), a = e("./utils"), l = e("./stream/GenericWorker"), c = r ? "uint8array" : "array";
      function h(u, p) {
        l.call(this, "FlateWorker/" + u), this._pako = null, this._pakoAction = u, this._pakoOptions = p, this.meta = {};
      }
      s.magic = "\b\0", a.inherits(h, l), h.prototype.processChunk = function(u) {
        this.meta = u.meta, this._pako === null && this._createPako(), this._pako.push(a.transformTo(c, u.data), !1);
      }, h.prototype.flush = function() {
        l.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
      }, h.prototype.cleanUp = function() {
        l.prototype.cleanUp.call(this), this._pako = null;
      }, h.prototype._createPako = function() {
        this._pako = new o[this._pakoAction]({ raw: !0, level: this._pakoOptions.level || -1 });
        var u = this;
        this._pako.onData = function(p) {
          u.push({ data: p, meta: u.meta });
        };
      }, s.compressWorker = function(u) {
        return new h("Deflate", u);
      }, s.uncompressWorker = function() {
        return new h("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e, i, s) {
      function r(m, g) {
        var _, y = "";
        for (_ = 0; _ < g; _++)
          y += String.fromCharCode(255 & m), m >>>= 8;
        return y;
      }
      function o(m, g, _, y, b, w) {
        var v, C, k = m.file, Y = m.compression, P = w !== c.utf8encode, L = a.transformTo("string", w(k.name)), R = a.transformTo("string", c.utf8encode(k.name)), D = k.comment, J = a.transformTo("string", w(D)), G = a.transformTo("string", c.utf8encode(D)), X = R.length !== k.name.length, Z = G.length !== D.length, W = "", st = "", j = "", gt = k.dir, U = k.date, ht = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
        g && !_ || (ht.crc32 = m.crc32, ht.compressedSize = m.compressedSize, ht.uncompressedSize = m.uncompressedSize);
        var z = 0;
        g && (z |= 8), P || !X && !Z || (z |= 2048);
        var O = 0, _t = 0;
        gt && (O |= 16), b === "UNIX" ? (_t = 798, O |= function(ut, oe) {
          var Le = ut;
          return ut || (Le = oe ? 16893 : 33204), (65535 & Le) << 16;
        }(k.unixPermissions, gt)) : (_t = 20, O |= function(ut) {
          return 63 & (ut || 0);
        }(k.dosPermissions)), v = U.getUTCHours(), v <<= 6, v |= U.getUTCMinutes(), v <<= 5, v |= U.getUTCSeconds() / 2, C = U.getUTCFullYear() - 1980, C <<= 4, C |= U.getUTCMonth() + 1, C <<= 5, C |= U.getUTCDate(), X && (st = r(1, 1) + r(h(L), 4) + R, W += "up" + r(st.length, 2) + st), Z && (j = r(1, 1) + r(h(J), 4) + G, W += "uc" + r(j.length, 2) + j);
        var rt = "";
        return rt += `
\0`, rt += r(z, 2), rt += Y.magic, rt += r(v, 2), rt += r(C, 2), rt += r(ht.crc32, 4), rt += r(ht.compressedSize, 4), rt += r(ht.uncompressedSize, 4), rt += r(L.length, 2), rt += r(W.length, 2), { fileRecord: u.LOCAL_FILE_HEADER + rt + L + W, dirRecord: u.CENTRAL_FILE_HEADER + r(_t, 2) + rt + r(J.length, 2) + "\0\0\0\0" + r(O, 4) + r(y, 4) + L + W + J };
      }
      var a = e("../utils"), l = e("../stream/GenericWorker"), c = e("../utf8"), h = e("../crc32"), u = e("../signature");
      function p(m, g, _, y) {
        l.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = g, this.zipPlatform = _, this.encodeFileName = y, this.streamFiles = m, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      a.inherits(p, l), p.prototype.push = function(m) {
        var g = m.meta.percent || 0, _ = this.entriesCount, y = this._sources.length;
        this.accumulate ? this.contentBuffer.push(m) : (this.bytesWritten += m.data.length, l.prototype.push.call(this, { data: m.data, meta: { currentFile: this.currentFile, percent: _ ? (g + 100 * (_ - y - 1)) / _ : 100 } }));
      }, p.prototype.openedSource = function(m) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = m.file.name;
        var g = this.streamFiles && !m.file.dir;
        if (g) {
          var _ = o(m, g, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({ data: _.fileRecord, meta: { percent: 0 } });
        } else
          this.accumulate = !0;
      }, p.prototype.closedSource = function(m) {
        this.accumulate = !1;
        var g = this.streamFiles && !m.file.dir, _ = o(m, g, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(_.dirRecord), g)
          this.push({ data: function(y) {
            return u.DATA_DESCRIPTOR + r(y.crc32, 4) + r(y.compressedSize, 4) + r(y.uncompressedSize, 4);
          }(m), meta: { percent: 100 } });
        else
          for (this.push({ data: _.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
            this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, p.prototype.flush = function() {
        for (var m = this.bytesWritten, g = 0; g < this.dirRecords.length; g++)
          this.push({ data: this.dirRecords[g], meta: { percent: 100 } });
        var _ = this.bytesWritten - m, y = function(b, w, v, C, k) {
          var Y = a.transformTo("string", k(C));
          return u.CENTRAL_DIRECTORY_END + "\0\0\0\0" + r(b, 2) + r(b, 2) + r(w, 4) + r(v, 4) + r(Y.length, 2) + Y;
        }(this.dirRecords.length, _, m, this.zipComment, this.encodeFileName);
        this.push({ data: y, meta: { percent: 100 } });
      }, p.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, p.prototype.registerPrevious = function(m) {
        this._sources.push(m);
        var g = this;
        return m.on("data", function(_) {
          g.processChunk(_);
        }), m.on("end", function() {
          g.closedSource(g.previous.streamInfo), g._sources.length ? g.prepareNextSource() : g.end();
        }), m.on("error", function(_) {
          g.error(_);
        }), this;
      }, p.prototype.resume = function() {
        return !!l.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
      }, p.prototype.error = function(m) {
        var g = this._sources;
        if (!l.prototype.error.call(this, m))
          return !1;
        for (var _ = 0; _ < g.length; _++)
          try {
            g[_].error(m);
          } catch {
          }
        return !0;
      }, p.prototype.lock = function() {
        l.prototype.lock.call(this);
        for (var m = this._sources, g = 0; g < m.length; g++)
          m[g].lock();
      }, i.exports = p;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e, i, s) {
      var r = e("../compressions"), o = e("./ZipFileWorker");
      s.generateWorker = function(a, l, c) {
        var h = new o(l.streamFiles, c, l.platform, l.encodeFileName), u = 0;
        try {
          a.forEach(function(p, m) {
            u++;
            var g = function(w, v) {
              var C = w || v, k = r[C];
              if (!k)
                throw new Error(C + " is not a valid compression method !");
              return k;
            }(m.options.compression, l.compression), _ = m.options.compressionOptions || l.compressionOptions || {}, y = m.dir, b = m.date;
            m._compressWorker(g, _).withStreamInfo("file", { name: p, dir: y, date: b, comment: m.comment || "", unixPermissions: m.unixPermissions, dosPermissions: m.dosPermissions }).pipe(h);
          }), h.entriesCount = u;
        } catch (p) {
          h.error(p);
        }
        return h;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e, i, s) {
      function r() {
        if (!(this instanceof r))
          return new r();
        if (arguments.length)
          throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var o = new r();
          for (var a in this)
            typeof this[a] != "function" && (o[a] = this[a]);
          return o;
        };
      }
      (r.prototype = e("./object")).loadAsync = e("./load"), r.support = e("./support"), r.defaults = e("./defaults"), r.version = "3.10.1", r.loadAsync = function(o, a) {
        return new r().loadAsync(o, a);
      }, r.external = e("./external"), i.exports = r;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e, i, s) {
      var r = e("./utils"), o = e("./external"), a = e("./utf8"), l = e("./zipEntries"), c = e("./stream/Crc32Probe"), h = e("./nodejsUtils");
      function u(p) {
        return new o.Promise(function(m, g) {
          var _ = p.decompressed.getContentWorker().pipe(new c());
          _.on("error", function(y) {
            g(y);
          }).on("end", function() {
            _.streamInfo.crc32 !== p.decompressed.crc32 ? g(new Error("Corrupted zip : CRC32 mismatch")) : m();
          }).resume();
        });
      }
      i.exports = function(p, m) {
        var g = this;
        return m = r.extend(m || {}, { base64: !1, checkCRC32: !1, optimizedBinaryString: !1, createFolders: !1, decodeFileName: a.utf8decode }), h.isNode && h.isStream(p) ? o.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : r.prepareContent("the loaded zip file", p, !0, m.optimizedBinaryString, m.base64).then(function(_) {
          var y = new l(m);
          return y.load(_), y;
        }).then(function(_) {
          var y = [o.Promise.resolve(_)], b = _.files;
          if (m.checkCRC32)
            for (var w = 0; w < b.length; w++)
              y.push(u(b[w]));
          return o.Promise.all(y);
        }).then(function(_) {
          for (var y = _.shift(), b = y.files, w = 0; w < b.length; w++) {
            var v = b[w], C = v.fileNameStr, k = r.resolve(v.fileNameStr);
            g.file(k, v.decompressed, { binary: !0, optimizedBinaryString: !0, date: v.date, dir: v.dir, comment: v.fileCommentStr.length ? v.fileCommentStr : null, unixPermissions: v.unixPermissions, dosPermissions: v.dosPermissions, createFolders: m.createFolders }), v.dir || (g.file(k).unsafeOriginalName = C);
          }
          return y.zipComment.length && (g.comment = y.zipComment), g;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e, i, s) {
      var r = e("../utils"), o = e("../stream/GenericWorker");
      function a(l, c) {
        o.call(this, "Nodejs stream input adapter for " + l), this._upstreamEnded = !1, this._bindStream(c);
      }
      r.inherits(a, o), a.prototype._bindStream = function(l) {
        var c = this;
        (this._stream = l).pause(), l.on("data", function(h) {
          c.push({ data: h, meta: { percent: 0 } });
        }).on("error", function(h) {
          c.isPaused ? this.generatedError = h : c.error(h);
        }).on("end", function() {
          c.isPaused ? c._upstreamEnded = !0 : c.end();
        });
      }, a.prototype.pause = function() {
        return !!o.prototype.pause.call(this) && (this._stream.pause(), !0);
      }, a.prototype.resume = function() {
        return !!o.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
      }, i.exports = a;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e, i, s) {
      var r = e("readable-stream").Readable;
      function o(a, l, c) {
        r.call(this, l), this._helper = a;
        var h = this;
        a.on("data", function(u, p) {
          h.push(u) || h._helper.pause(), c && c(p);
        }).on("error", function(u) {
          h.emit("error", u);
        }).on("end", function() {
          h.push(null);
        });
      }
      e("../utils").inherits(o, r), o.prototype._read = function() {
        this._helper.resume();
      }, i.exports = o;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e, i, s) {
      i.exports = { isNode: typeof Buffer < "u", newBufferFrom: function(r, o) {
        if (Buffer.from && Buffer.from !== Uint8Array.from)
          return Buffer.from(r, o);
        if (typeof r == "number")
          throw new Error('The "data" argument must not be a number');
        return new Buffer(r, o);
      }, allocBuffer: function(r) {
        if (Buffer.alloc)
          return Buffer.alloc(r);
        var o = new Buffer(r);
        return o.fill(0), o;
      }, isBuffer: function(r) {
        return Buffer.isBuffer(r);
      }, isStream: function(r) {
        return r && typeof r.on == "function" && typeof r.pause == "function" && typeof r.resume == "function";
      } };
    }, {}], 15: [function(e, i, s) {
      function r(k, Y, P) {
        var L, R = a.getTypeOf(Y), D = a.extend(P || {}, h);
        D.date = D.date || /* @__PURE__ */ new Date(), D.compression !== null && (D.compression = D.compression.toUpperCase()), typeof D.unixPermissions == "string" && (D.unixPermissions = parseInt(D.unixPermissions, 8)), D.unixPermissions && 16384 & D.unixPermissions && (D.dir = !0), D.dosPermissions && 16 & D.dosPermissions && (D.dir = !0), D.dir && (k = b(k)), D.createFolders && (L = y(k)) && w.call(this, L, !0);
        var J = R === "string" && D.binary === !1 && D.base64 === !1;
        P && P.binary !== void 0 || (D.binary = !J), (Y instanceof u && Y.uncompressedSize === 0 || D.dir || !Y || Y.length === 0) && (D.base64 = !1, D.binary = !0, Y = "", D.compression = "STORE", R = "string");
        var G = null;
        G = Y instanceof u || Y instanceof l ? Y : g.isNode && g.isStream(Y) ? new _(k, Y) : a.prepareContent(k, Y, D.binary, D.optimizedBinaryString, D.base64);
        var X = new p(k, G, D);
        this.files[k] = X;
      }
      var o = e("./utf8"), a = e("./utils"), l = e("./stream/GenericWorker"), c = e("./stream/StreamHelper"), h = e("./defaults"), u = e("./compressedObject"), p = e("./zipObject"), m = e("./generate"), g = e("./nodejsUtils"), _ = e("./nodejs/NodejsStreamInputAdapter"), y = function(k) {
        k.slice(-1) === "/" && (k = k.substring(0, k.length - 1));
        var Y = k.lastIndexOf("/");
        return 0 < Y ? k.substring(0, Y) : "";
      }, b = function(k) {
        return k.slice(-1) !== "/" && (k += "/"), k;
      }, w = function(k, Y) {
        return Y = Y !== void 0 ? Y : h.createFolders, k = b(k), this.files[k] || r.call(this, k, null, { dir: !0, createFolders: Y }), this.files[k];
      };
      function v(k) {
        return Object.prototype.toString.call(k) === "[object RegExp]";
      }
      var C = { load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, forEach: function(k) {
        var Y, P, L;
        for (Y in this.files)
          L = this.files[Y], (P = Y.slice(this.root.length, Y.length)) && Y.slice(0, this.root.length) === this.root && k(P, L);
      }, filter: function(k) {
        var Y = [];
        return this.forEach(function(P, L) {
          k(P, L) && Y.push(L);
        }), Y;
      }, file: function(k, Y, P) {
        if (arguments.length !== 1)
          return k = this.root + k, r.call(this, k, Y, P), this;
        if (v(k)) {
          var L = k;
          return this.filter(function(D, J) {
            return !J.dir && L.test(D);
          });
        }
        var R = this.files[this.root + k];
        return R && !R.dir ? R : null;
      }, folder: function(k) {
        if (!k)
          return this;
        if (v(k))
          return this.filter(function(R, D) {
            return D.dir && k.test(R);
          });
        var Y = this.root + k, P = w.call(this, Y), L = this.clone();
        return L.root = P.name, L;
      }, remove: function(k) {
        k = this.root + k;
        var Y = this.files[k];
        if (Y || (k.slice(-1) !== "/" && (k += "/"), Y = this.files[k]), Y && !Y.dir)
          delete this.files[k];
        else
          for (var P = this.filter(function(R, D) {
            return D.name.slice(0, k.length) === k;
          }), L = 0; L < P.length; L++)
            delete this.files[P[L].name];
        return this;
      }, generate: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, generateInternalStream: function(k) {
        var Y, P = {};
        try {
          if ((P = a.extend(k || {}, { streamFiles: !1, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: o.utf8encode })).type = P.type.toLowerCase(), P.compression = P.compression.toUpperCase(), P.type === "binarystring" && (P.type = "string"), !P.type)
            throw new Error("No output type specified.");
          a.checkSupport(P.type), P.platform !== "darwin" && P.platform !== "freebsd" && P.platform !== "linux" && P.platform !== "sunos" || (P.platform = "UNIX"), P.platform === "win32" && (P.platform = "DOS");
          var L = P.comment || this.comment || "";
          Y = m.generateWorker(this, P, L);
        } catch (R) {
          (Y = new l("error")).error(R);
        }
        return new c(Y, P.type || "string", P.mimeType);
      }, generateAsync: function(k, Y) {
        return this.generateInternalStream(k).accumulate(Y);
      }, generateNodeStream: function(k, Y) {
        return (k = k || {}).type || (k.type = "nodebuffer"), this.generateInternalStream(k).toNodejsStream(Y);
      } };
      i.exports = C;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e, i, s) {
      i.exports = e("stream");
    }, { stream: void 0 }], 17: [function(e, i, s) {
      var r = e("./DataReader");
      function o(a) {
        r.call(this, a);
        for (var l = 0; l < this.data.length; l++)
          a[l] = 255 & a[l];
      }
      e("../utils").inherits(o, r), o.prototype.byteAt = function(a) {
        return this.data[this.zero + a];
      }, o.prototype.lastIndexOfSignature = function(a) {
        for (var l = a.charCodeAt(0), c = a.charCodeAt(1), h = a.charCodeAt(2), u = a.charCodeAt(3), p = this.length - 4; 0 <= p; --p)
          if (this.data[p] === l && this.data[p + 1] === c && this.data[p + 2] === h && this.data[p + 3] === u)
            return p - this.zero;
        return -1;
      }, o.prototype.readAndCheckSignature = function(a) {
        var l = a.charCodeAt(0), c = a.charCodeAt(1), h = a.charCodeAt(2), u = a.charCodeAt(3), p = this.readData(4);
        return l === p[0] && c === p[1] && h === p[2] && u === p[3];
      }, o.prototype.readData = function(a) {
        if (this.checkOffset(a), a === 0)
          return [];
        var l = this.data.slice(this.zero + this.index, this.zero + this.index + a);
        return this.index += a, l;
      }, i.exports = o;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e, i, s) {
      var r = e("../utils");
      function o(a) {
        this.data = a, this.length = a.length, this.index = 0, this.zero = 0;
      }
      o.prototype = { checkOffset: function(a) {
        this.checkIndex(this.index + a);
      }, checkIndex: function(a) {
        if (this.length < this.zero + a || a < 0)
          throw new Error("End of data reached (data length = " + this.length + ", asked index = " + a + "). Corrupted zip ?");
      }, setIndex: function(a) {
        this.checkIndex(a), this.index = a;
      }, skip: function(a) {
        this.setIndex(this.index + a);
      }, byteAt: function() {
      }, readInt: function(a) {
        var l, c = 0;
        for (this.checkOffset(a), l = this.index + a - 1; l >= this.index; l--)
          c = (c << 8) + this.byteAt(l);
        return this.index += a, c;
      }, readString: function(a) {
        return r.transformTo("string", this.readData(a));
      }, readData: function() {
      }, lastIndexOfSignature: function() {
      }, readAndCheckSignature: function() {
      }, readDate: function() {
        var a = this.readInt(4);
        return new Date(Date.UTC(1980 + (a >> 25 & 127), (a >> 21 & 15) - 1, a >> 16 & 31, a >> 11 & 31, a >> 5 & 63, (31 & a) << 1));
      } }, i.exports = o;
    }, { "../utils": 32 }], 19: [function(e, i, s) {
      var r = e("./Uint8ArrayReader");
      function o(a) {
        r.call(this, a);
      }
      e("../utils").inherits(o, r), o.prototype.readData = function(a) {
        this.checkOffset(a);
        var l = this.data.slice(this.zero + this.index, this.zero + this.index + a);
        return this.index += a, l;
      }, i.exports = o;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e, i, s) {
      var r = e("./DataReader");
      function o(a) {
        r.call(this, a);
      }
      e("../utils").inherits(o, r), o.prototype.byteAt = function(a) {
        return this.data.charCodeAt(this.zero + a);
      }, o.prototype.lastIndexOfSignature = function(a) {
        return this.data.lastIndexOf(a) - this.zero;
      }, o.prototype.readAndCheckSignature = function(a) {
        return a === this.readData(4);
      }, o.prototype.readData = function(a) {
        this.checkOffset(a);
        var l = this.data.slice(this.zero + this.index, this.zero + this.index + a);
        return this.index += a, l;
      }, i.exports = o;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e, i, s) {
      var r = e("./ArrayReader");
      function o(a) {
        r.call(this, a);
      }
      e("../utils").inherits(o, r), o.prototype.readData = function(a) {
        if (this.checkOffset(a), a === 0)
          return new Uint8Array(0);
        var l = this.data.subarray(this.zero + this.index, this.zero + this.index + a);
        return this.index += a, l;
      }, i.exports = o;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e, i, s) {
      var r = e("../utils"), o = e("../support"), a = e("./ArrayReader"), l = e("./StringReader"), c = e("./NodeBufferReader"), h = e("./Uint8ArrayReader");
      i.exports = function(u) {
        var p = r.getTypeOf(u);
        return r.checkSupport(p), p !== "string" || o.uint8array ? p === "nodebuffer" ? new c(u) : o.uint8array ? new h(r.transformTo("uint8array", u)) : new a(r.transformTo("array", u)) : new l(u);
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e, i, s) {
      s.LOCAL_FILE_HEADER = "PK", s.CENTRAL_FILE_HEADER = "PK", s.CENTRAL_DIRECTORY_END = "PK", s.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", s.ZIP64_CENTRAL_DIRECTORY_END = "PK", s.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(e, i, s) {
      var r = e("./GenericWorker"), o = e("../utils");
      function a(l) {
        r.call(this, "ConvertWorker to " + l), this.destType = l;
      }
      o.inherits(a, r), a.prototype.processChunk = function(l) {
        this.push({ data: o.transformTo(this.destType, l.data), meta: l.meta });
      }, i.exports = a;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e, i, s) {
      var r = e("./GenericWorker"), o = e("../crc32");
      function a() {
        r.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      e("../utils").inherits(a, r), a.prototype.processChunk = function(l) {
        this.streamInfo.crc32 = o(l.data, this.streamInfo.crc32 || 0), this.push(l);
      }, i.exports = a;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e, i, s) {
      var r = e("../utils"), o = e("./GenericWorker");
      function a(l) {
        o.call(this, "DataLengthProbe for " + l), this.propName = l, this.withStreamInfo(l, 0);
      }
      r.inherits(a, o), a.prototype.processChunk = function(l) {
        if (l) {
          var c = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = c + l.data.length;
        }
        o.prototype.processChunk.call(this, l);
      }, i.exports = a;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e, i, s) {
      var r = e("../utils"), o = e("./GenericWorker");
      function a(l) {
        o.call(this, "DataWorker");
        var c = this;
        this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, l.then(function(h) {
          c.dataIsReady = !0, c.data = h, c.max = h && h.length || 0, c.type = r.getTypeOf(h), c.isPaused || c._tickAndRepeat();
        }, function(h) {
          c.error(h);
        });
      }
      r.inherits(a, o), a.prototype.cleanUp = function() {
        o.prototype.cleanUp.call(this), this.data = null;
      }, a.prototype.resume = function() {
        return !!o.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, r.delay(this._tickAndRepeat, [], this)), !0);
      }, a.prototype._tickAndRepeat = function() {
        this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (r.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
      }, a.prototype._tick = function() {
        if (this.isPaused || this.isFinished)
          return !1;
        var l = null, c = Math.min(this.max, this.index + 16384);
        if (this.index >= this.max)
          return this.end();
        switch (this.type) {
          case "string":
            l = this.data.substring(this.index, c);
            break;
          case "uint8array":
            l = this.data.subarray(this.index, c);
            break;
          case "array":
          case "nodebuffer":
            l = this.data.slice(this.index, c);
        }
        return this.index = c, this.push({ data: l, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
      }, i.exports = a;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e, i, s) {
      function r(o) {
        this.name = o || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
      }
      r.prototype = { push: function(o) {
        this.emit("data", o);
      }, end: function() {
        if (this.isFinished)
          return !1;
        this.flush();
        try {
          this.emit("end"), this.cleanUp(), this.isFinished = !0;
        } catch (o) {
          this.emit("error", o);
        }
        return !0;
      }, error: function(o) {
        return !this.isFinished && (this.isPaused ? this.generatedError = o : (this.isFinished = !0, this.emit("error", o), this.previous && this.previous.error(o), this.cleanUp()), !0);
      }, on: function(o, a) {
        return this._listeners[o].push(a), this;
      }, cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
      }, emit: function(o, a) {
        if (this._listeners[o])
          for (var l = 0; l < this._listeners[o].length; l++)
            this._listeners[o][l].call(this, a);
      }, pipe: function(o) {
        return o.registerPrevious(this);
      }, registerPrevious: function(o) {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.streamInfo = o.streamInfo, this.mergeStreamInfo(), this.previous = o;
        var a = this;
        return o.on("data", function(l) {
          a.processChunk(l);
        }), o.on("end", function() {
          a.end();
        }), o.on("error", function(l) {
          a.error(l);
        }), this;
      }, pause: function() {
        return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
      }, resume: function() {
        if (!this.isPaused || this.isFinished)
          return !1;
        var o = this.isPaused = !1;
        return this.generatedError && (this.error(this.generatedError), o = !0), this.previous && this.previous.resume(), !o;
      }, flush: function() {
      }, processChunk: function(o) {
        this.push(o);
      }, withStreamInfo: function(o, a) {
        return this.extraStreamInfo[o] = a, this.mergeStreamInfo(), this;
      }, mergeStreamInfo: function() {
        for (var o in this.extraStreamInfo)
          Object.prototype.hasOwnProperty.call(this.extraStreamInfo, o) && (this.streamInfo[o] = this.extraStreamInfo[o]);
      }, lock: function() {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.isLocked = !0, this.previous && this.previous.lock();
      }, toString: function() {
        var o = "Worker " + this.name;
        return this.previous ? this.previous + " -> " + o : o;
      } }, i.exports = r;
    }, {}], 29: [function(e, i, s) {
      var r = e("../utils"), o = e("./ConvertWorker"), a = e("./GenericWorker"), l = e("../base64"), c = e("../support"), h = e("../external"), u = null;
      if (c.nodestream)
        try {
          u = e("../nodejs/NodejsStreamOutputAdapter");
        } catch {
        }
      function p(g, _) {
        return new h.Promise(function(y, b) {
          var w = [], v = g._internalType, C = g._outputType, k = g._mimeType;
          g.on("data", function(Y, P) {
            w.push(Y), _ && _(P);
          }).on("error", function(Y) {
            w = [], b(Y);
          }).on("end", function() {
            try {
              var Y = function(P, L, R) {
                switch (P) {
                  case "blob":
                    return r.newBlob(r.transformTo("arraybuffer", L), R);
                  case "base64":
                    return l.encode(L);
                  default:
                    return r.transformTo(P, L);
                }
              }(C, function(P, L) {
                var R, D = 0, J = null, G = 0;
                for (R = 0; R < L.length; R++)
                  G += L[R].length;
                switch (P) {
                  case "string":
                    return L.join("");
                  case "array":
                    return Array.prototype.concat.apply([], L);
                  case "uint8array":
                    for (J = new Uint8Array(G), R = 0; R < L.length; R++)
                      J.set(L[R], D), D += L[R].length;
                    return J;
                  case "nodebuffer":
                    return Buffer.concat(L);
                  default:
                    throw new Error("concat : unsupported type '" + P + "'");
                }
              }(v, w), k);
              y(Y);
            } catch (P) {
              b(P);
            }
            w = [];
          }).resume();
        });
      }
      function m(g, _, y) {
        var b = _;
        switch (_) {
          case "blob":
          case "arraybuffer":
            b = "uint8array";
            break;
          case "base64":
            b = "string";
        }
        try {
          this._internalType = b, this._outputType = _, this._mimeType = y, r.checkSupport(b), this._worker = g.pipe(new o(b)), g.lock();
        } catch (w) {
          this._worker = new a("error"), this._worker.error(w);
        }
      }
      m.prototype = { accumulate: function(g) {
        return p(this, g);
      }, on: function(g, _) {
        var y = this;
        return g === "data" ? this._worker.on(g, function(b) {
          _.call(y, b.data, b.meta);
        }) : this._worker.on(g, function() {
          r.delay(_, arguments, y);
        }), this;
      }, resume: function() {
        return r.delay(this._worker.resume, [], this._worker), this;
      }, pause: function() {
        return this._worker.pause(), this;
      }, toNodejsStream: function(g) {
        if (r.checkSupport("nodestream"), this._outputType !== "nodebuffer")
          throw new Error(this._outputType + " is not supported by this method");
        return new u(this, { objectMode: this._outputType !== "nodebuffer" }, g);
      } }, i.exports = m;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e, i, s) {
      if (s.base64 = !0, s.array = !0, s.string = !0, s.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", s.nodebuffer = typeof Buffer < "u", s.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u")
        s.blob = !1;
      else {
        var r = new ArrayBuffer(0);
        try {
          s.blob = new Blob([r], { type: "application/zip" }).size === 0;
        } catch {
          try {
            var o = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            o.append(r), s.blob = o.getBlob("application/zip").size === 0;
          } catch {
            s.blob = !1;
          }
        }
      }
      try {
        s.nodestream = !!e("readable-stream").Readable;
      } catch {
        s.nodestream = !1;
      }
    }, { "readable-stream": 16 }], 31: [function(e, i, s) {
      for (var r = e("./utils"), o = e("./support"), a = e("./nodejsUtils"), l = e("./stream/GenericWorker"), c = new Array(256), h = 0; h < 256; h++)
        c[h] = 252 <= h ? 6 : 248 <= h ? 5 : 240 <= h ? 4 : 224 <= h ? 3 : 192 <= h ? 2 : 1;
      c[254] = c[254] = 1;
      function u() {
        l.call(this, "utf-8 decode"), this.leftOver = null;
      }
      function p() {
        l.call(this, "utf-8 encode");
      }
      s.utf8encode = function(m) {
        return o.nodebuffer ? a.newBufferFrom(m, "utf-8") : function(g) {
          var _, y, b, w, v, C = g.length, k = 0;
          for (w = 0; w < C; w++)
            (64512 & (y = g.charCodeAt(w))) == 55296 && w + 1 < C && (64512 & (b = g.charCodeAt(w + 1))) == 56320 && (y = 65536 + (y - 55296 << 10) + (b - 56320), w++), k += y < 128 ? 1 : y < 2048 ? 2 : y < 65536 ? 3 : 4;
          for (_ = o.uint8array ? new Uint8Array(k) : new Array(k), w = v = 0; v < k; w++)
            (64512 & (y = g.charCodeAt(w))) == 55296 && w + 1 < C && (64512 & (b = g.charCodeAt(w + 1))) == 56320 && (y = 65536 + (y - 55296 << 10) + (b - 56320), w++), y < 128 ? _[v++] = y : (y < 2048 ? _[v++] = 192 | y >>> 6 : (y < 65536 ? _[v++] = 224 | y >>> 12 : (_[v++] = 240 | y >>> 18, _[v++] = 128 | y >>> 12 & 63), _[v++] = 128 | y >>> 6 & 63), _[v++] = 128 | 63 & y);
          return _;
        }(m);
      }, s.utf8decode = function(m) {
        return o.nodebuffer ? r.transformTo("nodebuffer", m).toString("utf-8") : function(g) {
          var _, y, b, w, v = g.length, C = new Array(2 * v);
          for (_ = y = 0; _ < v; )
            if ((b = g[_++]) < 128)
              C[y++] = b;
            else if (4 < (w = c[b]))
              C[y++] = 65533, _ += w - 1;
            else {
              for (b &= w === 2 ? 31 : w === 3 ? 15 : 7; 1 < w && _ < v; )
                b = b << 6 | 63 & g[_++], w--;
              1 < w ? C[y++] = 65533 : b < 65536 ? C[y++] = b : (b -= 65536, C[y++] = 55296 | b >> 10 & 1023, C[y++] = 56320 | 1023 & b);
            }
          return C.length !== y && (C.subarray ? C = C.subarray(0, y) : C.length = y), r.applyFromCharCode(C);
        }(m = r.transformTo(o.uint8array ? "uint8array" : "array", m));
      }, r.inherits(u, l), u.prototype.processChunk = function(m) {
        var g = r.transformTo(o.uint8array ? "uint8array" : "array", m.data);
        if (this.leftOver && this.leftOver.length) {
          if (o.uint8array) {
            var _ = g;
            (g = new Uint8Array(_.length + this.leftOver.length)).set(this.leftOver, 0), g.set(_, this.leftOver.length);
          } else
            g = this.leftOver.concat(g);
          this.leftOver = null;
        }
        var y = function(w, v) {
          var C;
          for ((v = v || w.length) > w.length && (v = w.length), C = v - 1; 0 <= C && (192 & w[C]) == 128; )
            C--;
          return C < 0 || C === 0 ? v : C + c[w[C]] > v ? C : v;
        }(g), b = g;
        y !== g.length && (o.uint8array ? (b = g.subarray(0, y), this.leftOver = g.subarray(y, g.length)) : (b = g.slice(0, y), this.leftOver = g.slice(y, g.length))), this.push({ data: s.utf8decode(b), meta: m.meta });
      }, u.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({ data: s.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
      }, s.Utf8DecodeWorker = u, r.inherits(p, l), p.prototype.processChunk = function(m) {
        this.push({ data: s.utf8encode(m.data), meta: m.meta });
      }, s.Utf8EncodeWorker = p;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e, i, s) {
      var r = e("./support"), o = e("./base64"), a = e("./nodejsUtils"), l = e("./external");
      function c(_) {
        return _;
      }
      function h(_, y) {
        for (var b = 0; b < _.length; ++b)
          y[b] = 255 & _.charCodeAt(b);
        return y;
      }
      e("setimmediate"), s.newBlob = function(_, y) {
        s.checkSupport("blob");
        try {
          return new Blob([_], { type: y });
        } catch {
          try {
            var b = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            return b.append(_), b.getBlob(y);
          } catch {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      var u = { stringifyByChunk: function(_, y, b) {
        var w = [], v = 0, C = _.length;
        if (C <= b)
          return String.fromCharCode.apply(null, _);
        for (; v < C; )
          y === "array" || y === "nodebuffer" ? w.push(String.fromCharCode.apply(null, _.slice(v, Math.min(v + b, C)))) : w.push(String.fromCharCode.apply(null, _.subarray(v, Math.min(v + b, C)))), v += b;
        return w.join("");
      }, stringifyByChar: function(_) {
        for (var y = "", b = 0; b < _.length; b++)
          y += String.fromCharCode(_[b]);
        return y;
      }, applyCanBeUsed: { uint8array: function() {
        try {
          return r.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
        } catch {
          return !1;
        }
      }(), nodebuffer: function() {
        try {
          return r.nodebuffer && String.fromCharCode.apply(null, a.allocBuffer(1)).length === 1;
        } catch {
          return !1;
        }
      }() } };
      function p(_) {
        var y = 65536, b = s.getTypeOf(_), w = !0;
        if (b === "uint8array" ? w = u.applyCanBeUsed.uint8array : b === "nodebuffer" && (w = u.applyCanBeUsed.nodebuffer), w)
          for (; 1 < y; )
            try {
              return u.stringifyByChunk(_, b, y);
            } catch {
              y = Math.floor(y / 2);
            }
        return u.stringifyByChar(_);
      }
      function m(_, y) {
        for (var b = 0; b < _.length; b++)
          y[b] = _[b];
        return y;
      }
      s.applyFromCharCode = p;
      var g = {};
      g.string = { string: c, array: function(_) {
        return h(_, new Array(_.length));
      }, arraybuffer: function(_) {
        return g.string.uint8array(_).buffer;
      }, uint8array: function(_) {
        return h(_, new Uint8Array(_.length));
      }, nodebuffer: function(_) {
        return h(_, a.allocBuffer(_.length));
      } }, g.array = { string: p, array: c, arraybuffer: function(_) {
        return new Uint8Array(_).buffer;
      }, uint8array: function(_) {
        return new Uint8Array(_);
      }, nodebuffer: function(_) {
        return a.newBufferFrom(_);
      } }, g.arraybuffer = { string: function(_) {
        return p(new Uint8Array(_));
      }, array: function(_) {
        return m(new Uint8Array(_), new Array(_.byteLength));
      }, arraybuffer: c, uint8array: function(_) {
        return new Uint8Array(_);
      }, nodebuffer: function(_) {
        return a.newBufferFrom(new Uint8Array(_));
      } }, g.uint8array = { string: p, array: function(_) {
        return m(_, new Array(_.length));
      }, arraybuffer: function(_) {
        return _.buffer;
      }, uint8array: c, nodebuffer: function(_) {
        return a.newBufferFrom(_);
      } }, g.nodebuffer = { string: p, array: function(_) {
        return m(_, new Array(_.length));
      }, arraybuffer: function(_) {
        return g.nodebuffer.uint8array(_).buffer;
      }, uint8array: function(_) {
        return m(_, new Uint8Array(_.length));
      }, nodebuffer: c }, s.transformTo = function(_, y) {
        if (y = y || "", !_)
          return y;
        s.checkSupport(_);
        var b = s.getTypeOf(y);
        return g[b][_](y);
      }, s.resolve = function(_) {
        for (var y = _.split("/"), b = [], w = 0; w < y.length; w++) {
          var v = y[w];
          v === "." || v === "" && w !== 0 && w !== y.length - 1 || (v === ".." ? b.pop() : b.push(v));
        }
        return b.join("/");
      }, s.getTypeOf = function(_) {
        return typeof _ == "string" ? "string" : Object.prototype.toString.call(_) === "[object Array]" ? "array" : r.nodebuffer && a.isBuffer(_) ? "nodebuffer" : r.uint8array && _ instanceof Uint8Array ? "uint8array" : r.arraybuffer && _ instanceof ArrayBuffer ? "arraybuffer" : void 0;
      }, s.checkSupport = function(_) {
        if (!r[_.toLowerCase()])
          throw new Error(_ + " is not supported by this platform");
      }, s.MAX_VALUE_16BITS = 65535, s.MAX_VALUE_32BITS = -1, s.pretty = function(_) {
        var y, b, w = "";
        for (b = 0; b < (_ || "").length; b++)
          w += "\\x" + ((y = _.charCodeAt(b)) < 16 ? "0" : "") + y.toString(16).toUpperCase();
        return w;
      }, s.delay = function(_, y, b) {
        setImmediate(function() {
          _.apply(b || null, y || []);
        });
      }, s.inherits = function(_, y) {
        function b() {
        }
        b.prototype = y.prototype, _.prototype = new b();
      }, s.extend = function() {
        var _, y, b = {};
        for (_ = 0; _ < arguments.length; _++)
          for (y in arguments[_])
            Object.prototype.hasOwnProperty.call(arguments[_], y) && b[y] === void 0 && (b[y] = arguments[_][y]);
        return b;
      }, s.prepareContent = function(_, y, b, w, v) {
        return l.Promise.resolve(y).then(function(C) {
          return r.blob && (C instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(C)) !== -1) && typeof FileReader < "u" ? new l.Promise(function(k, Y) {
            var P = new FileReader();
            P.onload = function(L) {
              k(L.target.result);
            }, P.onerror = function(L) {
              Y(L.target.error);
            }, P.readAsArrayBuffer(C);
          }) : C;
        }).then(function(C) {
          var k = s.getTypeOf(C);
          return k ? (k === "arraybuffer" ? C = s.transformTo("uint8array", C) : k === "string" && (v ? C = o.decode(C) : b && w !== !0 && (C = function(Y) {
            return h(Y, r.uint8array ? new Uint8Array(Y.length) : new Array(Y.length));
          }(C))), C) : l.Promise.reject(new Error("Can't read the data of '" + _ + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e, i, s) {
      var r = e("./reader/readerFor"), o = e("./utils"), a = e("./signature"), l = e("./zipEntry"), c = e("./support");
      function h(u) {
        this.files = [], this.loadOptions = u;
      }
      h.prototype = { checkSignature: function(u) {
        if (!this.reader.readAndCheckSignature(u)) {
          this.reader.index -= 4;
          var p = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + o.pretty(p) + ", expected " + o.pretty(u) + ")");
        }
      }, isSignature: function(u, p) {
        var m = this.reader.index;
        this.reader.setIndex(u);
        var g = this.reader.readString(4) === p;
        return this.reader.setIndex(m), g;
      }, readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
        var u = this.reader.readData(this.zipCommentLength), p = c.uint8array ? "uint8array" : "array", m = o.transformTo(p, u);
        this.zipComment = this.loadOptions.decodeFileName(m);
      }, readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
        for (var u, p, m, g = this.zip64EndOfCentralSize - 44; 0 < g; )
          u = this.reader.readInt(2), p = this.reader.readInt(4), m = this.reader.readData(p), this.zip64ExtensibleData[u] = { id: u, length: p, value: m };
      }, readBlockZip64EndOfCentralLocator: function() {
        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
          throw new Error("Multi-volumes zip are not supported");
      }, readLocalFiles: function() {
        var u, p;
        for (u = 0; u < this.files.length; u++)
          p = this.files[u], this.reader.setIndex(p.localHeaderOffset), this.checkSignature(a.LOCAL_FILE_HEADER), p.readLocalPart(this.reader), p.handleUTF8(), p.processAttributes();
      }, readCentralDir: function() {
        var u;
        for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(a.CENTRAL_FILE_HEADER); )
          (u = new l({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(u);
        if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0)
          throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      }, readEndOfCentral: function() {
        var u = this.reader.lastIndexOfSignature(a.CENTRAL_DIRECTORY_END);
        if (u < 0)
          throw this.isSignature(0, a.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
        this.reader.setIndex(u);
        var p = u;
        if (this.checkSignature(a.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === o.MAX_VALUE_16BITS || this.diskWithCentralDirStart === o.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === o.MAX_VALUE_16BITS || this.centralDirRecords === o.MAX_VALUE_16BITS || this.centralDirSize === o.MAX_VALUE_32BITS || this.centralDirOffset === o.MAX_VALUE_32BITS) {
          if (this.zip64 = !0, (u = this.reader.lastIndexOfSignature(a.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          if (this.reader.setIndex(u), this.checkSignature(a.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, a.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(a.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(a.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
        }
        var m = this.centralDirOffset + this.centralDirSize;
        this.zip64 && (m += 20, m += 12 + this.zip64EndOfCentralSize);
        var g = p - m;
        if (0 < g)
          this.isSignature(p, a.CENTRAL_FILE_HEADER) || (this.reader.zero = g);
        else if (g < 0)
          throw new Error("Corrupted zip: missing " + Math.abs(g) + " bytes.");
      }, prepareReader: function(u) {
        this.reader = r(u);
      }, load: function(u) {
        this.prepareReader(u), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
      } }, i.exports = h;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e, i, s) {
      var r = e("./reader/readerFor"), o = e("./utils"), a = e("./compressedObject"), l = e("./crc32"), c = e("./utf8"), h = e("./compressions"), u = e("./support");
      function p(m, g) {
        this.options = m, this.loadOptions = g;
      }
      p.prototype = { isEncrypted: function() {
        return (1 & this.bitFlag) == 1;
      }, useUTF8: function() {
        return (2048 & this.bitFlag) == 2048;
      }, readLocalPart: function(m) {
        var g, _;
        if (m.skip(22), this.fileNameLength = m.readInt(2), _ = m.readInt(2), this.fileName = m.readData(this.fileNameLength), m.skip(_), this.compressedSize === -1 || this.uncompressedSize === -1)
          throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        if ((g = function(y) {
          for (var b in h)
            if (Object.prototype.hasOwnProperty.call(h, b) && h[b].magic === y)
              return h[b];
          return null;
        }(this.compressionMethod)) === null)
          throw new Error("Corrupted zip : compression " + o.pretty(this.compressionMethod) + " unknown (inner file : " + o.transformTo("string", this.fileName) + ")");
        this.decompressed = new a(this.compressedSize, this.uncompressedSize, this.crc32, g, m.readData(this.compressedSize));
      }, readCentralPart: function(m) {
        this.versionMadeBy = m.readInt(2), m.skip(2), this.bitFlag = m.readInt(2), this.compressionMethod = m.readString(2), this.date = m.readDate(), this.crc32 = m.readInt(4), this.compressedSize = m.readInt(4), this.uncompressedSize = m.readInt(4);
        var g = m.readInt(2);
        if (this.extraFieldsLength = m.readInt(2), this.fileCommentLength = m.readInt(2), this.diskNumberStart = m.readInt(2), this.internalFileAttributes = m.readInt(2), this.externalFileAttributes = m.readInt(4), this.localHeaderOffset = m.readInt(4), this.isEncrypted())
          throw new Error("Encrypted zip are not supported");
        m.skip(g), this.readExtraFields(m), this.parseZIP64ExtraField(m), this.fileComment = m.readData(this.fileCommentLength);
      }, processAttributes: function() {
        this.unixPermissions = null, this.dosPermissions = null;
        var m = this.versionMadeBy >> 8;
        this.dir = !!(16 & this.externalFileAttributes), m == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), m == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = !0);
      }, parseZIP64ExtraField: function() {
        if (this.extraFields[1]) {
          var m = r(this.extraFields[1].value);
          this.uncompressedSize === o.MAX_VALUE_32BITS && (this.uncompressedSize = m.readInt(8)), this.compressedSize === o.MAX_VALUE_32BITS && (this.compressedSize = m.readInt(8)), this.localHeaderOffset === o.MAX_VALUE_32BITS && (this.localHeaderOffset = m.readInt(8)), this.diskNumberStart === o.MAX_VALUE_32BITS && (this.diskNumberStart = m.readInt(4));
        }
      }, readExtraFields: function(m) {
        var g, _, y, b = m.index + this.extraFieldsLength;
        for (this.extraFields || (this.extraFields = {}); m.index + 4 < b; )
          g = m.readInt(2), _ = m.readInt(2), y = m.readData(_), this.extraFields[g] = { id: g, length: _, value: y };
        m.setIndex(b);
      }, handleUTF8: function() {
        var m = u.uint8array ? "uint8array" : "array";
        if (this.useUTF8())
          this.fileNameStr = c.utf8decode(this.fileName), this.fileCommentStr = c.utf8decode(this.fileComment);
        else {
          var g = this.findExtraFieldUnicodePath();
          if (g !== null)
            this.fileNameStr = g;
          else {
            var _ = o.transformTo(m, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(_);
          }
          var y = this.findExtraFieldUnicodeComment();
          if (y !== null)
            this.fileCommentStr = y;
          else {
            var b = o.transformTo(m, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(b);
          }
        }
      }, findExtraFieldUnicodePath: function() {
        var m = this.extraFields[28789];
        if (m) {
          var g = r(m.value);
          return g.readInt(1) !== 1 || l(this.fileName) !== g.readInt(4) ? null : c.utf8decode(g.readData(m.length - 5));
        }
        return null;
      }, findExtraFieldUnicodeComment: function() {
        var m = this.extraFields[25461];
        if (m) {
          var g = r(m.value);
          return g.readInt(1) !== 1 || l(this.fileComment) !== g.readInt(4) ? null : c.utf8decode(g.readData(m.length - 5));
        }
        return null;
      } }, i.exports = p;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e, i, s) {
      function r(g, _, y) {
        this.name = g, this.dir = y.dir, this.date = y.date, this.comment = y.comment, this.unixPermissions = y.unixPermissions, this.dosPermissions = y.dosPermissions, this._data = _, this._dataBinary = y.binary, this.options = { compression: y.compression, compressionOptions: y.compressionOptions };
      }
      var o = e("./stream/StreamHelper"), a = e("./stream/DataWorker"), l = e("./utf8"), c = e("./compressedObject"), h = e("./stream/GenericWorker");
      r.prototype = { internalStream: function(g) {
        var _ = null, y = "string";
        try {
          if (!g)
            throw new Error("No output type specified.");
          var b = (y = g.toLowerCase()) === "string" || y === "text";
          y !== "binarystring" && y !== "text" || (y = "string"), _ = this._decompressWorker();
          var w = !this._dataBinary;
          w && !b && (_ = _.pipe(new l.Utf8EncodeWorker())), !w && b && (_ = _.pipe(new l.Utf8DecodeWorker()));
        } catch (v) {
          (_ = new h("error")).error(v);
        }
        return new o(_, y, "");
      }, async: function(g, _) {
        return this.internalStream(g).accumulate(_);
      }, nodeStream: function(g, _) {
        return this.internalStream(g || "nodebuffer").toNodejsStream(_);
      }, _compressWorker: function(g, _) {
        if (this._data instanceof c && this._data.compression.magic === g.magic)
          return this._data.getCompressedWorker();
        var y = this._decompressWorker();
        return this._dataBinary || (y = y.pipe(new l.Utf8EncodeWorker())), c.createWorkerFrom(y, g, _);
      }, _decompressWorker: function() {
        return this._data instanceof c ? this._data.getContentWorker() : this._data instanceof h ? this._data : new a(this._data);
      } };
      for (var u = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], p = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, m = 0; m < u.length; m++)
        r.prototype[u[m]] = p;
      i.exports = r;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e, i, s) {
      (function(r) {
        var o, a, l = r.MutationObserver || r.WebKitMutationObserver;
        if (l) {
          var c = 0, h = new l(g), u = r.document.createTextNode("");
          h.observe(u, { characterData: !0 }), o = function() {
            u.data = c = ++c % 2;
          };
        } else if (r.setImmediate || r.MessageChannel === void 0)
          o = "document" in r && "onreadystatechange" in r.document.createElement("script") ? function() {
            var _ = r.document.createElement("script");
            _.onreadystatechange = function() {
              g(), _.onreadystatechange = null, _.parentNode.removeChild(_), _ = null;
            }, r.document.documentElement.appendChild(_);
          } : function() {
            setTimeout(g, 0);
          };
        else {
          var p = new r.MessageChannel();
          p.port1.onmessage = g, o = function() {
            p.port2.postMessage(0);
          };
        }
        var m = [];
        function g() {
          var _, y;
          a = !0;
          for (var b = m.length; b; ) {
            for (y = m, m = [], _ = -1; ++_ < b; )
              y[_]();
            b = m.length;
          }
          a = !1;
        }
        i.exports = function(_) {
          m.push(_) !== 1 || a || o();
        };
      }).call(this, typeof tr < "u" ? tr : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 37: [function(e, i, s) {
      var r = e("immediate");
      function o() {
      }
      var a = {}, l = ["REJECTED"], c = ["FULFILLED"], h = ["PENDING"];
      function u(b) {
        if (typeof b != "function")
          throw new TypeError("resolver must be a function");
        this.state = h, this.queue = [], this.outcome = void 0, b !== o && _(this, b);
      }
      function p(b, w, v) {
        this.promise = b, typeof w == "function" && (this.onFulfilled = w, this.callFulfilled = this.otherCallFulfilled), typeof v == "function" && (this.onRejected = v, this.callRejected = this.otherCallRejected);
      }
      function m(b, w, v) {
        r(function() {
          var C;
          try {
            C = w(v);
          } catch (k) {
            return a.reject(b, k);
          }
          C === b ? a.reject(b, new TypeError("Cannot resolve promise with itself")) : a.resolve(b, C);
        });
      }
      function g(b) {
        var w = b && b.then;
        if (b && (typeof b == "object" || typeof b == "function") && typeof w == "function")
          return function() {
            w.apply(b, arguments);
          };
      }
      function _(b, w) {
        var v = !1;
        function C(P) {
          v || (v = !0, a.reject(b, P));
        }
        function k(P) {
          v || (v = !0, a.resolve(b, P));
        }
        var Y = y(function() {
          w(k, C);
        });
        Y.status === "error" && C(Y.value);
      }
      function y(b, w) {
        var v = {};
        try {
          v.value = b(w), v.status = "success";
        } catch (C) {
          v.status = "error", v.value = C;
        }
        return v;
      }
      (i.exports = u).prototype.finally = function(b) {
        if (typeof b != "function")
          return this;
        var w = this.constructor;
        return this.then(function(v) {
          return w.resolve(b()).then(function() {
            return v;
          });
        }, function(v) {
          return w.resolve(b()).then(function() {
            throw v;
          });
        });
      }, u.prototype.catch = function(b) {
        return this.then(null, b);
      }, u.prototype.then = function(b, w) {
        if (typeof b != "function" && this.state === c || typeof w != "function" && this.state === l)
          return this;
        var v = new this.constructor(o);
        return this.state !== h ? m(v, this.state === c ? b : w, this.outcome) : this.queue.push(new p(v, b, w)), v;
      }, p.prototype.callFulfilled = function(b) {
        a.resolve(this.promise, b);
      }, p.prototype.otherCallFulfilled = function(b) {
        m(this.promise, this.onFulfilled, b);
      }, p.prototype.callRejected = function(b) {
        a.reject(this.promise, b);
      }, p.prototype.otherCallRejected = function(b) {
        m(this.promise, this.onRejected, b);
      }, a.resolve = function(b, w) {
        var v = y(g, w);
        if (v.status === "error")
          return a.reject(b, v.value);
        var C = v.value;
        if (C)
          _(b, C);
        else {
          b.state = c, b.outcome = w;
          for (var k = -1, Y = b.queue.length; ++k < Y; )
            b.queue[k].callFulfilled(w);
        }
        return b;
      }, a.reject = function(b, w) {
        b.state = l, b.outcome = w;
        for (var v = -1, C = b.queue.length; ++v < C; )
          b.queue[v].callRejected(w);
        return b;
      }, u.resolve = function(b) {
        return b instanceof this ? b : a.resolve(new this(o), b);
      }, u.reject = function(b) {
        var w = new this(o);
        return a.reject(w, b);
      }, u.all = function(b) {
        var w = this;
        if (Object.prototype.toString.call(b) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var v = b.length, C = !1;
        if (!v)
          return this.resolve([]);
        for (var k = new Array(v), Y = 0, P = -1, L = new this(o); ++P < v; )
          R(b[P], P);
        return L;
        function R(D, J) {
          w.resolve(D).then(function(G) {
            k[J] = G, ++Y !== v || C || (C = !0, a.resolve(L, k));
          }, function(G) {
            C || (C = !0, a.reject(L, G));
          });
        }
      }, u.race = function(b) {
        var w = this;
        if (Object.prototype.toString.call(b) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var v = b.length, C = !1;
        if (!v)
          return this.resolve([]);
        for (var k = -1, Y = new this(o); ++k < v; )
          P = b[k], w.resolve(P).then(function(L) {
            C || (C = !0, a.resolve(Y, L));
          }, function(L) {
            C || (C = !0, a.reject(Y, L));
          });
        var P;
        return Y;
      };
    }, { immediate: 36 }], 38: [function(e, i, s) {
      var r = {};
      (0, e("./lib/utils/common").assign)(r, e("./lib/deflate"), e("./lib/inflate"), e("./lib/zlib/constants")), i.exports = r;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e, i, s) {
      var r = e("./zlib/deflate"), o = e("./utils/common"), a = e("./utils/strings"), l = e("./zlib/messages"), c = e("./zlib/zstream"), h = Object.prototype.toString, u = 0, p = -1, m = 0, g = 8;
      function _(b) {
        if (!(this instanceof _))
          return new _(b);
        this.options = o.assign({ level: p, method: g, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: m, to: "" }, b || {});
        var w = this.options;
        w.raw && 0 < w.windowBits ? w.windowBits = -w.windowBits : w.gzip && 0 < w.windowBits && w.windowBits < 16 && (w.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new c(), this.strm.avail_out = 0;
        var v = r.deflateInit2(this.strm, w.level, w.method, w.windowBits, w.memLevel, w.strategy);
        if (v !== u)
          throw new Error(l[v]);
        if (w.header && r.deflateSetHeader(this.strm, w.header), w.dictionary) {
          var C;
          if (C = typeof w.dictionary == "string" ? a.string2buf(w.dictionary) : h.call(w.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(w.dictionary) : w.dictionary, (v = r.deflateSetDictionary(this.strm, C)) !== u)
            throw new Error(l[v]);
          this._dict_set = !0;
        }
      }
      function y(b, w) {
        var v = new _(w);
        if (v.push(b, !0), v.err)
          throw v.msg || l[v.err];
        return v.result;
      }
      _.prototype.push = function(b, w) {
        var v, C, k = this.strm, Y = this.options.chunkSize;
        if (this.ended)
          return !1;
        C = w === ~~w ? w : w === !0 ? 4 : 0, typeof b == "string" ? k.input = a.string2buf(b) : h.call(b) === "[object ArrayBuffer]" ? k.input = new Uint8Array(b) : k.input = b, k.next_in = 0, k.avail_in = k.input.length;
        do {
          if (k.avail_out === 0 && (k.output = new o.Buf8(Y), k.next_out = 0, k.avail_out = Y), (v = r.deflate(k, C)) !== 1 && v !== u)
            return this.onEnd(v), !(this.ended = !0);
          k.avail_out !== 0 && (k.avail_in !== 0 || C !== 4 && C !== 2) || (this.options.to === "string" ? this.onData(a.buf2binstring(o.shrinkBuf(k.output, k.next_out))) : this.onData(o.shrinkBuf(k.output, k.next_out)));
        } while ((0 < k.avail_in || k.avail_out === 0) && v !== 1);
        return C === 4 ? (v = r.deflateEnd(this.strm), this.onEnd(v), this.ended = !0, v === u) : C !== 2 || (this.onEnd(u), !(k.avail_out = 0));
      }, _.prototype.onData = function(b) {
        this.chunks.push(b);
      }, _.prototype.onEnd = function(b) {
        b === u && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = b, this.msg = this.strm.msg;
      }, s.Deflate = _, s.deflate = y, s.deflateRaw = function(b, w) {
        return (w = w || {}).raw = !0, y(b, w);
      }, s.gzip = function(b, w) {
        return (w = w || {}).gzip = !0, y(b, w);
      };
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e, i, s) {
      var r = e("./zlib/inflate"), o = e("./utils/common"), a = e("./utils/strings"), l = e("./zlib/constants"), c = e("./zlib/messages"), h = e("./zlib/zstream"), u = e("./zlib/gzheader"), p = Object.prototype.toString;
      function m(_) {
        if (!(this instanceof m))
          return new m(_);
        this.options = o.assign({ chunkSize: 16384, windowBits: 0, to: "" }, _ || {});
        var y = this.options;
        y.raw && 0 <= y.windowBits && y.windowBits < 16 && (y.windowBits = -y.windowBits, y.windowBits === 0 && (y.windowBits = -15)), !(0 <= y.windowBits && y.windowBits < 16) || _ && _.windowBits || (y.windowBits += 32), 15 < y.windowBits && y.windowBits < 48 && !(15 & y.windowBits) && (y.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new h(), this.strm.avail_out = 0;
        var b = r.inflateInit2(this.strm, y.windowBits);
        if (b !== l.Z_OK)
          throw new Error(c[b]);
        this.header = new u(), r.inflateGetHeader(this.strm, this.header);
      }
      function g(_, y) {
        var b = new m(y);
        if (b.push(_, !0), b.err)
          throw b.msg || c[b.err];
        return b.result;
      }
      m.prototype.push = function(_, y) {
        var b, w, v, C, k, Y, P = this.strm, L = this.options.chunkSize, R = this.options.dictionary, D = !1;
        if (this.ended)
          return !1;
        w = y === ~~y ? y : y === !0 ? l.Z_FINISH : l.Z_NO_FLUSH, typeof _ == "string" ? P.input = a.binstring2buf(_) : p.call(_) === "[object ArrayBuffer]" ? P.input = new Uint8Array(_) : P.input = _, P.next_in = 0, P.avail_in = P.input.length;
        do {
          if (P.avail_out === 0 && (P.output = new o.Buf8(L), P.next_out = 0, P.avail_out = L), (b = r.inflate(P, l.Z_NO_FLUSH)) === l.Z_NEED_DICT && R && (Y = typeof R == "string" ? a.string2buf(R) : p.call(R) === "[object ArrayBuffer]" ? new Uint8Array(R) : R, b = r.inflateSetDictionary(this.strm, Y)), b === l.Z_BUF_ERROR && D === !0 && (b = l.Z_OK, D = !1), b !== l.Z_STREAM_END && b !== l.Z_OK)
            return this.onEnd(b), !(this.ended = !0);
          P.next_out && (P.avail_out !== 0 && b !== l.Z_STREAM_END && (P.avail_in !== 0 || w !== l.Z_FINISH && w !== l.Z_SYNC_FLUSH) || (this.options.to === "string" ? (v = a.utf8border(P.output, P.next_out), C = P.next_out - v, k = a.buf2string(P.output, v), P.next_out = C, P.avail_out = L - C, C && o.arraySet(P.output, P.output, v, C, 0), this.onData(k)) : this.onData(o.shrinkBuf(P.output, P.next_out)))), P.avail_in === 0 && P.avail_out === 0 && (D = !0);
        } while ((0 < P.avail_in || P.avail_out === 0) && b !== l.Z_STREAM_END);
        return b === l.Z_STREAM_END && (w = l.Z_FINISH), w === l.Z_FINISH ? (b = r.inflateEnd(this.strm), this.onEnd(b), this.ended = !0, b === l.Z_OK) : w !== l.Z_SYNC_FLUSH || (this.onEnd(l.Z_OK), !(P.avail_out = 0));
      }, m.prototype.onData = function(_) {
        this.chunks.push(_);
      }, m.prototype.onEnd = function(_) {
        _ === l.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = _, this.msg = this.strm.msg;
      }, s.Inflate = m, s.inflate = g, s.inflateRaw = function(_, y) {
        return (y = y || {}).raw = !0, g(_, y);
      }, s.ungzip = g;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e, i, s) {
      var r = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
      s.assign = function(l) {
        for (var c = Array.prototype.slice.call(arguments, 1); c.length; ) {
          var h = c.shift();
          if (h) {
            if (typeof h != "object")
              throw new TypeError(h + "must be non-object");
            for (var u in h)
              h.hasOwnProperty(u) && (l[u] = h[u]);
          }
        }
        return l;
      }, s.shrinkBuf = function(l, c) {
        return l.length === c ? l : l.subarray ? l.subarray(0, c) : (l.length = c, l);
      };
      var o = { arraySet: function(l, c, h, u, p) {
        if (c.subarray && l.subarray)
          l.set(c.subarray(h, h + u), p);
        else
          for (var m = 0; m < u; m++)
            l[p + m] = c[h + m];
      }, flattenChunks: function(l) {
        var c, h, u, p, m, g;
        for (c = u = 0, h = l.length; c < h; c++)
          u += l[c].length;
        for (g = new Uint8Array(u), c = p = 0, h = l.length; c < h; c++)
          m = l[c], g.set(m, p), p += m.length;
        return g;
      } }, a = { arraySet: function(l, c, h, u, p) {
        for (var m = 0; m < u; m++)
          l[p + m] = c[h + m];
      }, flattenChunks: function(l) {
        return [].concat.apply([], l);
      } };
      s.setTyped = function(l) {
        l ? (s.Buf8 = Uint8Array, s.Buf16 = Uint16Array, s.Buf32 = Int32Array, s.assign(s, o)) : (s.Buf8 = Array, s.Buf16 = Array, s.Buf32 = Array, s.assign(s, a));
      }, s.setTyped(r);
    }, {}], 42: [function(e, i, s) {
      var r = e("./common"), o = !0, a = !0;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch {
        o = !1;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch {
        a = !1;
      }
      for (var l = new r.Buf8(256), c = 0; c < 256; c++)
        l[c] = 252 <= c ? 6 : 248 <= c ? 5 : 240 <= c ? 4 : 224 <= c ? 3 : 192 <= c ? 2 : 1;
      function h(u, p) {
        if (p < 65537 && (u.subarray && a || !u.subarray && o))
          return String.fromCharCode.apply(null, r.shrinkBuf(u, p));
        for (var m = "", g = 0; g < p; g++)
          m += String.fromCharCode(u[g]);
        return m;
      }
      l[254] = l[254] = 1, s.string2buf = function(u) {
        var p, m, g, _, y, b = u.length, w = 0;
        for (_ = 0; _ < b; _++)
          (64512 & (m = u.charCodeAt(_))) == 55296 && _ + 1 < b && (64512 & (g = u.charCodeAt(_ + 1))) == 56320 && (m = 65536 + (m - 55296 << 10) + (g - 56320), _++), w += m < 128 ? 1 : m < 2048 ? 2 : m < 65536 ? 3 : 4;
        for (p = new r.Buf8(w), _ = y = 0; y < w; _++)
          (64512 & (m = u.charCodeAt(_))) == 55296 && _ + 1 < b && (64512 & (g = u.charCodeAt(_ + 1))) == 56320 && (m = 65536 + (m - 55296 << 10) + (g - 56320), _++), m < 128 ? p[y++] = m : (m < 2048 ? p[y++] = 192 | m >>> 6 : (m < 65536 ? p[y++] = 224 | m >>> 12 : (p[y++] = 240 | m >>> 18, p[y++] = 128 | m >>> 12 & 63), p[y++] = 128 | m >>> 6 & 63), p[y++] = 128 | 63 & m);
        return p;
      }, s.buf2binstring = function(u) {
        return h(u, u.length);
      }, s.binstring2buf = function(u) {
        for (var p = new r.Buf8(u.length), m = 0, g = p.length; m < g; m++)
          p[m] = u.charCodeAt(m);
        return p;
      }, s.buf2string = function(u, p) {
        var m, g, _, y, b = p || u.length, w = new Array(2 * b);
        for (m = g = 0; m < b; )
          if ((_ = u[m++]) < 128)
            w[g++] = _;
          else if (4 < (y = l[_]))
            w[g++] = 65533, m += y - 1;
          else {
            for (_ &= y === 2 ? 31 : y === 3 ? 15 : 7; 1 < y && m < b; )
              _ = _ << 6 | 63 & u[m++], y--;
            1 < y ? w[g++] = 65533 : _ < 65536 ? w[g++] = _ : (_ -= 65536, w[g++] = 55296 | _ >> 10 & 1023, w[g++] = 56320 | 1023 & _);
          }
        return h(w, g);
      }, s.utf8border = function(u, p) {
        var m;
        for ((p = p || u.length) > u.length && (p = u.length), m = p - 1; 0 <= m && (192 & u[m]) == 128; )
          m--;
        return m < 0 || m === 0 ? p : m + l[u[m]] > p ? m : p;
      };
    }, { "./common": 41 }], 43: [function(e, i, s) {
      i.exports = function(r, o, a, l) {
        for (var c = 65535 & r | 0, h = r >>> 16 & 65535 | 0, u = 0; a !== 0; ) {
          for (a -= u = 2e3 < a ? 2e3 : a; h = h + (c = c + o[l++] | 0) | 0, --u; )
            ;
          c %= 65521, h %= 65521;
        }
        return c | h << 16 | 0;
      };
    }, {}], 44: [function(e, i, s) {
      i.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 45: [function(e, i, s) {
      var r = function() {
        for (var o, a = [], l = 0; l < 256; l++) {
          o = l;
          for (var c = 0; c < 8; c++)
            o = 1 & o ? 3988292384 ^ o >>> 1 : o >>> 1;
          a[l] = o;
        }
        return a;
      }();
      i.exports = function(o, a, l, c) {
        var h = r, u = c + l;
        o ^= -1;
        for (var p = c; p < u; p++)
          o = o >>> 8 ^ h[255 & (o ^ a[p])];
        return -1 ^ o;
      };
    }, {}], 46: [function(e, i, s) {
      var r, o = e("../utils/common"), a = e("./trees"), l = e("./adler32"), c = e("./crc32"), h = e("./messages"), u = 0, p = 4, m = 0, g = -2, _ = -1, y = 4, b = 2, w = 8, v = 9, C = 286, k = 30, Y = 19, P = 2 * C + 1, L = 15, R = 3, D = 258, J = D + R + 1, G = 42, X = 113, Z = 1, W = 2, st = 3, j = 4;
      function gt(x, $) {
        return x.msg = h[$], $;
      }
      function U(x) {
        return (x << 1) - (4 < x ? 9 : 0);
      }
      function ht(x) {
        for (var $ = x.length; 0 <= --$; )
          x[$] = 0;
      }
      function z(x) {
        var $ = x.state, H = $.pending;
        H > x.avail_out && (H = x.avail_out), H !== 0 && (o.arraySet(x.output, $.pending_buf, $.pending_out, H, x.next_out), x.next_out += H, $.pending_out += H, x.total_out += H, x.avail_out -= H, $.pending -= H, $.pending === 0 && ($.pending_out = 0));
      }
      function O(x, $) {
        a._tr_flush_block(x, 0 <= x.block_start ? x.block_start : -1, x.strstart - x.block_start, $), x.block_start = x.strstart, z(x.strm);
      }
      function _t(x, $) {
        x.pending_buf[x.pending++] = $;
      }
      function rt(x, $) {
        x.pending_buf[x.pending++] = $ >>> 8 & 255, x.pending_buf[x.pending++] = 255 & $;
      }
      function ut(x, $) {
        var H, T, V = x.max_chain_length, K = x.strstart, tt = x.prev_length, nt = x.nice_match, A = x.strstart > x.w_size - J ? x.strstart - (x.w_size - J) : 0, lt = x.window, dt = x.w_mask, ct = x.prev, It = x.strstart + D, jt = lt[K + tt - 1], Ft = lt[K + tt];
        x.prev_length >= x.good_match && (V >>= 2), nt > x.lookahead && (nt = x.lookahead);
        do
          if (lt[(H = $) + tt] === Ft && lt[H + tt - 1] === jt && lt[H] === lt[K] && lt[++H] === lt[K + 1]) {
            K += 2, H++;
            do
              ;
            while (lt[++K] === lt[++H] && lt[++K] === lt[++H] && lt[++K] === lt[++H] && lt[++K] === lt[++H] && lt[++K] === lt[++H] && lt[++K] === lt[++H] && lt[++K] === lt[++H] && lt[++K] === lt[++H] && K < It);
            if (T = D - (It - K), K = It - D, tt < T) {
              if (x.match_start = $, nt <= (tt = T))
                break;
              jt = lt[K + tt - 1], Ft = lt[K + tt];
            }
          }
        while (($ = ct[$ & dt]) > A && --V != 0);
        return tt <= x.lookahead ? tt : x.lookahead;
      }
      function oe(x) {
        var $, H, T, V, K, tt, nt, A, lt, dt, ct = x.w_size;
        do {
          if (V = x.window_size - x.lookahead - x.strstart, x.strstart >= ct + (ct - J)) {
            for (o.arraySet(x.window, x.window, ct, ct, 0), x.match_start -= ct, x.strstart -= ct, x.block_start -= ct, $ = H = x.hash_size; T = x.head[--$], x.head[$] = ct <= T ? T - ct : 0, --H; )
              ;
            for ($ = H = ct; T = x.prev[--$], x.prev[$] = ct <= T ? T - ct : 0, --H; )
              ;
            V += ct;
          }
          if (x.strm.avail_in === 0)
            break;
          if (tt = x.strm, nt = x.window, A = x.strstart + x.lookahead, lt = V, dt = void 0, dt = tt.avail_in, lt < dt && (dt = lt), H = dt === 0 ? 0 : (tt.avail_in -= dt, o.arraySet(nt, tt.input, tt.next_in, dt, A), tt.state.wrap === 1 ? tt.adler = l(tt.adler, nt, dt, A) : tt.state.wrap === 2 && (tt.adler = c(tt.adler, nt, dt, A)), tt.next_in += dt, tt.total_in += dt, dt), x.lookahead += H, x.lookahead + x.insert >= R)
            for (K = x.strstart - x.insert, x.ins_h = x.window[K], x.ins_h = (x.ins_h << x.hash_shift ^ x.window[K + 1]) & x.hash_mask; x.insert && (x.ins_h = (x.ins_h << x.hash_shift ^ x.window[K + R - 1]) & x.hash_mask, x.prev[K & x.w_mask] = x.head[x.ins_h], x.head[x.ins_h] = K, K++, x.insert--, !(x.lookahead + x.insert < R)); )
              ;
        } while (x.lookahead < J && x.strm.avail_in !== 0);
      }
      function Le(x, $) {
        for (var H, T; ; ) {
          if (x.lookahead < J) {
            if (oe(x), x.lookahead < J && $ === u)
              return Z;
            if (x.lookahead === 0)
              break;
          }
          if (H = 0, x.lookahead >= R && (x.ins_h = (x.ins_h << x.hash_shift ^ x.window[x.strstart + R - 1]) & x.hash_mask, H = x.prev[x.strstart & x.w_mask] = x.head[x.ins_h], x.head[x.ins_h] = x.strstart), H !== 0 && x.strstart - H <= x.w_size - J && (x.match_length = ut(x, H)), x.match_length >= R)
            if (T = a._tr_tally(x, x.strstart - x.match_start, x.match_length - R), x.lookahead -= x.match_length, x.match_length <= x.max_lazy_match && x.lookahead >= R) {
              for (x.match_length--; x.strstart++, x.ins_h = (x.ins_h << x.hash_shift ^ x.window[x.strstart + R - 1]) & x.hash_mask, H = x.prev[x.strstart & x.w_mask] = x.head[x.ins_h], x.head[x.ins_h] = x.strstart, --x.match_length != 0; )
                ;
              x.strstart++;
            } else
              x.strstart += x.match_length, x.match_length = 0, x.ins_h = x.window[x.strstart], x.ins_h = (x.ins_h << x.hash_shift ^ x.window[x.strstart + 1]) & x.hash_mask;
          else
            T = a._tr_tally(x, 0, x.window[x.strstart]), x.lookahead--, x.strstart++;
          if (T && (O(x, !1), x.strm.avail_out === 0))
            return Z;
        }
        return x.insert = x.strstart < R - 1 ? x.strstart : R - 1, $ === p ? (O(x, !0), x.strm.avail_out === 0 ? st : j) : x.last_lit && (O(x, !1), x.strm.avail_out === 0) ? Z : W;
      }
      function Wt(x, $) {
        for (var H, T, V; ; ) {
          if (x.lookahead < J) {
            if (oe(x), x.lookahead < J && $ === u)
              return Z;
            if (x.lookahead === 0)
              break;
          }
          if (H = 0, x.lookahead >= R && (x.ins_h = (x.ins_h << x.hash_shift ^ x.window[x.strstart + R - 1]) & x.hash_mask, H = x.prev[x.strstart & x.w_mask] = x.head[x.ins_h], x.head[x.ins_h] = x.strstart), x.prev_length = x.match_length, x.prev_match = x.match_start, x.match_length = R - 1, H !== 0 && x.prev_length < x.max_lazy_match && x.strstart - H <= x.w_size - J && (x.match_length = ut(x, H), x.match_length <= 5 && (x.strategy === 1 || x.match_length === R && 4096 < x.strstart - x.match_start) && (x.match_length = R - 1)), x.prev_length >= R && x.match_length <= x.prev_length) {
            for (V = x.strstart + x.lookahead - R, T = a._tr_tally(x, x.strstart - 1 - x.prev_match, x.prev_length - R), x.lookahead -= x.prev_length - 1, x.prev_length -= 2; ++x.strstart <= V && (x.ins_h = (x.ins_h << x.hash_shift ^ x.window[x.strstart + R - 1]) & x.hash_mask, H = x.prev[x.strstart & x.w_mask] = x.head[x.ins_h], x.head[x.ins_h] = x.strstart), --x.prev_length != 0; )
              ;
            if (x.match_available = 0, x.match_length = R - 1, x.strstart++, T && (O(x, !1), x.strm.avail_out === 0))
              return Z;
          } else if (x.match_available) {
            if ((T = a._tr_tally(x, 0, x.window[x.strstart - 1])) && O(x, !1), x.strstart++, x.lookahead--, x.strm.avail_out === 0)
              return Z;
          } else
            x.match_available = 1, x.strstart++, x.lookahead--;
        }
        return x.match_available && (T = a._tr_tally(x, 0, x.window[x.strstart - 1]), x.match_available = 0), x.insert = x.strstart < R - 1 ? x.strstart : R - 1, $ === p ? (O(x, !0), x.strm.avail_out === 0 ? st : j) : x.last_lit && (O(x, !1), x.strm.avail_out === 0) ? Z : W;
      }
      function Dt(x, $, H, T, V) {
        this.good_length = x, this.max_lazy = $, this.nice_length = H, this.max_chain = T, this.func = V;
      }
      function ee() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = w, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new o.Buf16(2 * P), this.dyn_dtree = new o.Buf16(2 * (2 * k + 1)), this.bl_tree = new o.Buf16(2 * (2 * Y + 1)), ht(this.dyn_ltree), ht(this.dyn_dtree), ht(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new o.Buf16(L + 1), this.heap = new o.Buf16(2 * C + 1), ht(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new o.Buf16(2 * C + 1), ht(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function ie(x) {
        var $;
        return x && x.state ? (x.total_in = x.total_out = 0, x.data_type = b, ($ = x.state).pending = 0, $.pending_out = 0, $.wrap < 0 && ($.wrap = -$.wrap), $.status = $.wrap ? G : X, x.adler = $.wrap === 2 ? 0 : 1, $.last_flush = u, a._tr_init($), m) : gt(x, g);
      }
      function Ye(x) {
        var $ = ie(x);
        return $ === m && function(H) {
          H.window_size = 2 * H.w_size, ht(H.head), H.max_lazy_match = r[H.level].max_lazy, H.good_match = r[H.level].good_length, H.nice_match = r[H.level].nice_length, H.max_chain_length = r[H.level].max_chain, H.strstart = 0, H.block_start = 0, H.lookahead = 0, H.insert = 0, H.match_length = H.prev_length = R - 1, H.match_available = 0, H.ins_h = 0;
        }(x.state), $;
      }
      function bi(x, $, H, T, V, K) {
        if (!x)
          return g;
        var tt = 1;
        if ($ === _ && ($ = 6), T < 0 ? (tt = 0, T = -T) : 15 < T && (tt = 2, T -= 16), V < 1 || v < V || H !== w || T < 8 || 15 < T || $ < 0 || 9 < $ || K < 0 || y < K)
          return gt(x, g);
        T === 8 && (T = 9);
        var nt = new ee();
        return (x.state = nt).strm = x, nt.wrap = tt, nt.gzhead = null, nt.w_bits = T, nt.w_size = 1 << nt.w_bits, nt.w_mask = nt.w_size - 1, nt.hash_bits = V + 7, nt.hash_size = 1 << nt.hash_bits, nt.hash_mask = nt.hash_size - 1, nt.hash_shift = ~~((nt.hash_bits + R - 1) / R), nt.window = new o.Buf8(2 * nt.w_size), nt.head = new o.Buf16(nt.hash_size), nt.prev = new o.Buf16(nt.w_size), nt.lit_bufsize = 1 << V + 6, nt.pending_buf_size = 4 * nt.lit_bufsize, nt.pending_buf = new o.Buf8(nt.pending_buf_size), nt.d_buf = 1 * nt.lit_bufsize, nt.l_buf = 3 * nt.lit_bufsize, nt.level = $, nt.strategy = K, nt.method = H, Ye(x);
      }
      r = [new Dt(0, 0, 0, 0, function(x, $) {
        var H = 65535;
        for (H > x.pending_buf_size - 5 && (H = x.pending_buf_size - 5); ; ) {
          if (x.lookahead <= 1) {
            if (oe(x), x.lookahead === 0 && $ === u)
              return Z;
            if (x.lookahead === 0)
              break;
          }
          x.strstart += x.lookahead, x.lookahead = 0;
          var T = x.block_start + H;
          if ((x.strstart === 0 || x.strstart >= T) && (x.lookahead = x.strstart - T, x.strstart = T, O(x, !1), x.strm.avail_out === 0) || x.strstart - x.block_start >= x.w_size - J && (O(x, !1), x.strm.avail_out === 0))
            return Z;
        }
        return x.insert = 0, $ === p ? (O(x, !0), x.strm.avail_out === 0 ? st : j) : (x.strstart > x.block_start && (O(x, !1), x.strm.avail_out), Z);
      }), new Dt(4, 4, 8, 4, Le), new Dt(4, 5, 16, 8, Le), new Dt(4, 6, 32, 32, Le), new Dt(4, 4, 16, 16, Wt), new Dt(8, 16, 32, 32, Wt), new Dt(8, 16, 128, 128, Wt), new Dt(8, 32, 128, 256, Wt), new Dt(32, 128, 258, 1024, Wt), new Dt(32, 258, 258, 4096, Wt)], s.deflateInit = function(x, $) {
        return bi(x, $, w, 15, 8, 0);
      }, s.deflateInit2 = bi, s.deflateReset = Ye, s.deflateResetKeep = ie, s.deflateSetHeader = function(x, $) {
        return x && x.state ? x.state.wrap !== 2 ? g : (x.state.gzhead = $, m) : g;
      }, s.deflate = function(x, $) {
        var H, T, V, K;
        if (!x || !x.state || 5 < $ || $ < 0)
          return x ? gt(x, g) : g;
        if (T = x.state, !x.output || !x.input && x.avail_in !== 0 || T.status === 666 && $ !== p)
          return gt(x, x.avail_out === 0 ? -5 : g);
        if (T.strm = x, H = T.last_flush, T.last_flush = $, T.status === G)
          if (T.wrap === 2)
            x.adler = 0, _t(T, 31), _t(T, 139), _t(T, 8), T.gzhead ? (_t(T, (T.gzhead.text ? 1 : 0) + (T.gzhead.hcrc ? 2 : 0) + (T.gzhead.extra ? 4 : 0) + (T.gzhead.name ? 8 : 0) + (T.gzhead.comment ? 16 : 0)), _t(T, 255 & T.gzhead.time), _t(T, T.gzhead.time >> 8 & 255), _t(T, T.gzhead.time >> 16 & 255), _t(T, T.gzhead.time >> 24 & 255), _t(T, T.level === 9 ? 2 : 2 <= T.strategy || T.level < 2 ? 4 : 0), _t(T, 255 & T.gzhead.os), T.gzhead.extra && T.gzhead.extra.length && (_t(T, 255 & T.gzhead.extra.length), _t(T, T.gzhead.extra.length >> 8 & 255)), T.gzhead.hcrc && (x.adler = c(x.adler, T.pending_buf, T.pending, 0)), T.gzindex = 0, T.status = 69) : (_t(T, 0), _t(T, 0), _t(T, 0), _t(T, 0), _t(T, 0), _t(T, T.level === 9 ? 2 : 2 <= T.strategy || T.level < 2 ? 4 : 0), _t(T, 3), T.status = X);
          else {
            var tt = w + (T.w_bits - 8 << 4) << 8;
            tt |= (2 <= T.strategy || T.level < 2 ? 0 : T.level < 6 ? 1 : T.level === 6 ? 2 : 3) << 6, T.strstart !== 0 && (tt |= 32), tt += 31 - tt % 31, T.status = X, rt(T, tt), T.strstart !== 0 && (rt(T, x.adler >>> 16), rt(T, 65535 & x.adler)), x.adler = 1;
          }
        if (T.status === 69)
          if (T.gzhead.extra) {
            for (V = T.pending; T.gzindex < (65535 & T.gzhead.extra.length) && (T.pending !== T.pending_buf_size || (T.gzhead.hcrc && T.pending > V && (x.adler = c(x.adler, T.pending_buf, T.pending - V, V)), z(x), V = T.pending, T.pending !== T.pending_buf_size)); )
              _t(T, 255 & T.gzhead.extra[T.gzindex]), T.gzindex++;
            T.gzhead.hcrc && T.pending > V && (x.adler = c(x.adler, T.pending_buf, T.pending - V, V)), T.gzindex === T.gzhead.extra.length && (T.gzindex = 0, T.status = 73);
          } else
            T.status = 73;
        if (T.status === 73)
          if (T.gzhead.name) {
            V = T.pending;
            do {
              if (T.pending === T.pending_buf_size && (T.gzhead.hcrc && T.pending > V && (x.adler = c(x.adler, T.pending_buf, T.pending - V, V)), z(x), V = T.pending, T.pending === T.pending_buf_size)) {
                K = 1;
                break;
              }
              K = T.gzindex < T.gzhead.name.length ? 255 & T.gzhead.name.charCodeAt(T.gzindex++) : 0, _t(T, K);
            } while (K !== 0);
            T.gzhead.hcrc && T.pending > V && (x.adler = c(x.adler, T.pending_buf, T.pending - V, V)), K === 0 && (T.gzindex = 0, T.status = 91);
          } else
            T.status = 91;
        if (T.status === 91)
          if (T.gzhead.comment) {
            V = T.pending;
            do {
              if (T.pending === T.pending_buf_size && (T.gzhead.hcrc && T.pending > V && (x.adler = c(x.adler, T.pending_buf, T.pending - V, V)), z(x), V = T.pending, T.pending === T.pending_buf_size)) {
                K = 1;
                break;
              }
              K = T.gzindex < T.gzhead.comment.length ? 255 & T.gzhead.comment.charCodeAt(T.gzindex++) : 0, _t(T, K);
            } while (K !== 0);
            T.gzhead.hcrc && T.pending > V && (x.adler = c(x.adler, T.pending_buf, T.pending - V, V)), K === 0 && (T.status = 103);
          } else
            T.status = 103;
        if (T.status === 103 && (T.gzhead.hcrc ? (T.pending + 2 > T.pending_buf_size && z(x), T.pending + 2 <= T.pending_buf_size && (_t(T, 255 & x.adler), _t(T, x.adler >> 8 & 255), x.adler = 0, T.status = X)) : T.status = X), T.pending !== 0) {
          if (z(x), x.avail_out === 0)
            return T.last_flush = -1, m;
        } else if (x.avail_in === 0 && U($) <= U(H) && $ !== p)
          return gt(x, -5);
        if (T.status === 666 && x.avail_in !== 0)
          return gt(x, -5);
        if (x.avail_in !== 0 || T.lookahead !== 0 || $ !== u && T.status !== 666) {
          var nt = T.strategy === 2 ? function(A, lt) {
            for (var dt; ; ) {
              if (A.lookahead === 0 && (oe(A), A.lookahead === 0)) {
                if (lt === u)
                  return Z;
                break;
              }
              if (A.match_length = 0, dt = a._tr_tally(A, 0, A.window[A.strstart]), A.lookahead--, A.strstart++, dt && (O(A, !1), A.strm.avail_out === 0))
                return Z;
            }
            return A.insert = 0, lt === p ? (O(A, !0), A.strm.avail_out === 0 ? st : j) : A.last_lit && (O(A, !1), A.strm.avail_out === 0) ? Z : W;
          }(T, $) : T.strategy === 3 ? function(A, lt) {
            for (var dt, ct, It, jt, Ft = A.window; ; ) {
              if (A.lookahead <= D) {
                if (oe(A), A.lookahead <= D && lt === u)
                  return Z;
                if (A.lookahead === 0)
                  break;
              }
              if (A.match_length = 0, A.lookahead >= R && 0 < A.strstart && (ct = Ft[It = A.strstart - 1]) === Ft[++It] && ct === Ft[++It] && ct === Ft[++It]) {
                jt = A.strstart + D;
                do
                  ;
                while (ct === Ft[++It] && ct === Ft[++It] && ct === Ft[++It] && ct === Ft[++It] && ct === Ft[++It] && ct === Ft[++It] && ct === Ft[++It] && ct === Ft[++It] && It < jt);
                A.match_length = D - (jt - It), A.match_length > A.lookahead && (A.match_length = A.lookahead);
              }
              if (A.match_length >= R ? (dt = a._tr_tally(A, 1, A.match_length - R), A.lookahead -= A.match_length, A.strstart += A.match_length, A.match_length = 0) : (dt = a._tr_tally(A, 0, A.window[A.strstart]), A.lookahead--, A.strstart++), dt && (O(A, !1), A.strm.avail_out === 0))
                return Z;
            }
            return A.insert = 0, lt === p ? (O(A, !0), A.strm.avail_out === 0 ? st : j) : A.last_lit && (O(A, !1), A.strm.avail_out === 0) ? Z : W;
          }(T, $) : r[T.level].func(T, $);
          if (nt !== st && nt !== j || (T.status = 666), nt === Z || nt === st)
            return x.avail_out === 0 && (T.last_flush = -1), m;
          if (nt === W && ($ === 1 ? a._tr_align(T) : $ !== 5 && (a._tr_stored_block(T, 0, 0, !1), $ === 3 && (ht(T.head), T.lookahead === 0 && (T.strstart = 0, T.block_start = 0, T.insert = 0))), z(x), x.avail_out === 0))
            return T.last_flush = -1, m;
        }
        return $ !== p ? m : T.wrap <= 0 ? 1 : (T.wrap === 2 ? (_t(T, 255 & x.adler), _t(T, x.adler >> 8 & 255), _t(T, x.adler >> 16 & 255), _t(T, x.adler >> 24 & 255), _t(T, 255 & x.total_in), _t(T, x.total_in >> 8 & 255), _t(T, x.total_in >> 16 & 255), _t(T, x.total_in >> 24 & 255)) : (rt(T, x.adler >>> 16), rt(T, 65535 & x.adler)), z(x), 0 < T.wrap && (T.wrap = -T.wrap), T.pending !== 0 ? m : 1);
      }, s.deflateEnd = function(x) {
        var $;
        return x && x.state ? ($ = x.state.status) !== G && $ !== 69 && $ !== 73 && $ !== 91 && $ !== 103 && $ !== X && $ !== 666 ? gt(x, g) : (x.state = null, $ === X ? gt(x, -3) : m) : g;
      }, s.deflateSetDictionary = function(x, $) {
        var H, T, V, K, tt, nt, A, lt, dt = $.length;
        if (!x || !x.state || (K = (H = x.state).wrap) === 2 || K === 1 && H.status !== G || H.lookahead)
          return g;
        for (K === 1 && (x.adler = l(x.adler, $, dt, 0)), H.wrap = 0, dt >= H.w_size && (K === 0 && (ht(H.head), H.strstart = 0, H.block_start = 0, H.insert = 0), lt = new o.Buf8(H.w_size), o.arraySet(lt, $, dt - H.w_size, H.w_size, 0), $ = lt, dt = H.w_size), tt = x.avail_in, nt = x.next_in, A = x.input, x.avail_in = dt, x.next_in = 0, x.input = $, oe(H); H.lookahead >= R; ) {
          for (T = H.strstart, V = H.lookahead - (R - 1); H.ins_h = (H.ins_h << H.hash_shift ^ H.window[T + R - 1]) & H.hash_mask, H.prev[T & H.w_mask] = H.head[H.ins_h], H.head[H.ins_h] = T, T++, --V; )
            ;
          H.strstart = T, H.lookahead = R - 1, oe(H);
        }
        return H.strstart += H.lookahead, H.block_start = H.strstart, H.insert = H.lookahead, H.lookahead = 0, H.match_length = H.prev_length = R - 1, H.match_available = 0, x.next_in = nt, x.input = A, x.avail_in = tt, H.wrap = K, m;
      }, s.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e, i, s) {
      i.exports = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
      };
    }, {}], 48: [function(e, i, s) {
      i.exports = function(r, o) {
        var a, l, c, h, u, p, m, g, _, y, b, w, v, C, k, Y, P, L, R, D, J, G, X, Z, W;
        a = r.state, l = r.next_in, Z = r.input, c = l + (r.avail_in - 5), h = r.next_out, W = r.output, u = h - (o - r.avail_out), p = h + (r.avail_out - 257), m = a.dmax, g = a.wsize, _ = a.whave, y = a.wnext, b = a.window, w = a.hold, v = a.bits, C = a.lencode, k = a.distcode, Y = (1 << a.lenbits) - 1, P = (1 << a.distbits) - 1;
        t:
          do {
            v < 15 && (w += Z[l++] << v, v += 8, w += Z[l++] << v, v += 8), L = C[w & Y];
            e:
              for (; ; ) {
                if (w >>>= R = L >>> 24, v -= R, (R = L >>> 16 & 255) === 0)
                  W[h++] = 65535 & L;
                else {
                  if (!(16 & R)) {
                    if (!(64 & R)) {
                      L = C[(65535 & L) + (w & (1 << R) - 1)];
                      continue e;
                    }
                    if (32 & R) {
                      a.mode = 12;
                      break t;
                    }
                    r.msg = "invalid literal/length code", a.mode = 30;
                    break t;
                  }
                  D = 65535 & L, (R &= 15) && (v < R && (w += Z[l++] << v, v += 8), D += w & (1 << R) - 1, w >>>= R, v -= R), v < 15 && (w += Z[l++] << v, v += 8, w += Z[l++] << v, v += 8), L = k[w & P];
                  i:
                    for (; ; ) {
                      if (w >>>= R = L >>> 24, v -= R, !(16 & (R = L >>> 16 & 255))) {
                        if (!(64 & R)) {
                          L = k[(65535 & L) + (w & (1 << R) - 1)];
                          continue i;
                        }
                        r.msg = "invalid distance code", a.mode = 30;
                        break t;
                      }
                      if (J = 65535 & L, v < (R &= 15) && (w += Z[l++] << v, (v += 8) < R && (w += Z[l++] << v, v += 8)), m < (J += w & (1 << R) - 1)) {
                        r.msg = "invalid distance too far back", a.mode = 30;
                        break t;
                      }
                      if (w >>>= R, v -= R, (R = h - u) < J) {
                        if (_ < (R = J - R) && a.sane) {
                          r.msg = "invalid distance too far back", a.mode = 30;
                          break t;
                        }
                        if (X = b, (G = 0) === y) {
                          if (G += g - R, R < D) {
                            for (D -= R; W[h++] = b[G++], --R; )
                              ;
                            G = h - J, X = W;
                          }
                        } else if (y < R) {
                          if (G += g + y - R, (R -= y) < D) {
                            for (D -= R; W[h++] = b[G++], --R; )
                              ;
                            if (G = 0, y < D) {
                              for (D -= R = y; W[h++] = b[G++], --R; )
                                ;
                              G = h - J, X = W;
                            }
                          }
                        } else if (G += y - R, R < D) {
                          for (D -= R; W[h++] = b[G++], --R; )
                            ;
                          G = h - J, X = W;
                        }
                        for (; 2 < D; )
                          W[h++] = X[G++], W[h++] = X[G++], W[h++] = X[G++], D -= 3;
                        D && (W[h++] = X[G++], 1 < D && (W[h++] = X[G++]));
                      } else {
                        for (G = h - J; W[h++] = W[G++], W[h++] = W[G++], W[h++] = W[G++], 2 < (D -= 3); )
                          ;
                        D && (W[h++] = W[G++], 1 < D && (W[h++] = W[G++]));
                      }
                      break;
                    }
                }
                break;
              }
          } while (l < c && h < p);
        l -= D = v >> 3, w &= (1 << (v -= D << 3)) - 1, r.next_in = l, r.next_out = h, r.avail_in = l < c ? c - l + 5 : 5 - (l - c), r.avail_out = h < p ? p - h + 257 : 257 - (h - p), a.hold = w, a.bits = v;
      };
    }, {}], 49: [function(e, i, s) {
      var r = e("../utils/common"), o = e("./adler32"), a = e("./crc32"), l = e("./inffast"), c = e("./inftrees"), h = 1, u = 2, p = 0, m = -2, g = 1, _ = 852, y = 592;
      function b(G) {
        return (G >>> 24 & 255) + (G >>> 8 & 65280) + ((65280 & G) << 8) + ((255 & G) << 24);
      }
      function w() {
        this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new r.Buf16(320), this.work = new r.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function v(G) {
        var X;
        return G && G.state ? (X = G.state, G.total_in = G.total_out = X.total = 0, G.msg = "", X.wrap && (G.adler = 1 & X.wrap), X.mode = g, X.last = 0, X.havedict = 0, X.dmax = 32768, X.head = null, X.hold = 0, X.bits = 0, X.lencode = X.lendyn = new r.Buf32(_), X.distcode = X.distdyn = new r.Buf32(y), X.sane = 1, X.back = -1, p) : m;
      }
      function C(G) {
        var X;
        return G && G.state ? ((X = G.state).wsize = 0, X.whave = 0, X.wnext = 0, v(G)) : m;
      }
      function k(G, X) {
        var Z, W;
        return G && G.state ? (W = G.state, X < 0 ? (Z = 0, X = -X) : (Z = 1 + (X >> 4), X < 48 && (X &= 15)), X && (X < 8 || 15 < X) ? m : (W.window !== null && W.wbits !== X && (W.window = null), W.wrap = Z, W.wbits = X, C(G))) : m;
      }
      function Y(G, X) {
        var Z, W;
        return G ? (W = new w(), (G.state = W).window = null, (Z = k(G, X)) !== p && (G.state = null), Z) : m;
      }
      var P, L, R = !0;
      function D(G) {
        if (R) {
          var X;
          for (P = new r.Buf32(512), L = new r.Buf32(32), X = 0; X < 144; )
            G.lens[X++] = 8;
          for (; X < 256; )
            G.lens[X++] = 9;
          for (; X < 280; )
            G.lens[X++] = 7;
          for (; X < 288; )
            G.lens[X++] = 8;
          for (c(h, G.lens, 0, 288, P, 0, G.work, { bits: 9 }), X = 0; X < 32; )
            G.lens[X++] = 5;
          c(u, G.lens, 0, 32, L, 0, G.work, { bits: 5 }), R = !1;
        }
        G.lencode = P, G.lenbits = 9, G.distcode = L, G.distbits = 5;
      }
      function J(G, X, Z, W) {
        var st, j = G.state;
        return j.window === null && (j.wsize = 1 << j.wbits, j.wnext = 0, j.whave = 0, j.window = new r.Buf8(j.wsize)), W >= j.wsize ? (r.arraySet(j.window, X, Z - j.wsize, j.wsize, 0), j.wnext = 0, j.whave = j.wsize) : (W < (st = j.wsize - j.wnext) && (st = W), r.arraySet(j.window, X, Z - W, st, j.wnext), (W -= st) ? (r.arraySet(j.window, X, Z - W, W, 0), j.wnext = W, j.whave = j.wsize) : (j.wnext += st, j.wnext === j.wsize && (j.wnext = 0), j.whave < j.wsize && (j.whave += st))), 0;
      }
      s.inflateReset = C, s.inflateReset2 = k, s.inflateResetKeep = v, s.inflateInit = function(G) {
        return Y(G, 15);
      }, s.inflateInit2 = Y, s.inflate = function(G, X) {
        var Z, W, st, j, gt, U, ht, z, O, _t, rt, ut, oe, Le, Wt, Dt, ee, ie, Ye, bi, x, $, H, T, V = 0, K = new r.Buf8(4), tt = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!G || !G.state || !G.output || !G.input && G.avail_in !== 0)
          return m;
        (Z = G.state).mode === 12 && (Z.mode = 13), gt = G.next_out, st = G.output, ht = G.avail_out, j = G.next_in, W = G.input, U = G.avail_in, z = Z.hold, O = Z.bits, _t = U, rt = ht, $ = p;
        t:
          for (; ; )
            switch (Z.mode) {
              case g:
                if (Z.wrap === 0) {
                  Z.mode = 13;
                  break;
                }
                for (; O < 16; ) {
                  if (U === 0)
                    break t;
                  U--, z += W[j++] << O, O += 8;
                }
                if (2 & Z.wrap && z === 35615) {
                  K[Z.check = 0] = 255 & z, K[1] = z >>> 8 & 255, Z.check = a(Z.check, K, 2, 0), O = z = 0, Z.mode = 2;
                  break;
                }
                if (Z.flags = 0, Z.head && (Z.head.done = !1), !(1 & Z.wrap) || (((255 & z) << 8) + (z >> 8)) % 31) {
                  G.msg = "incorrect header check", Z.mode = 30;
                  break;
                }
                if ((15 & z) != 8) {
                  G.msg = "unknown compression method", Z.mode = 30;
                  break;
                }
                if (O -= 4, x = 8 + (15 & (z >>>= 4)), Z.wbits === 0)
                  Z.wbits = x;
                else if (x > Z.wbits) {
                  G.msg = "invalid window size", Z.mode = 30;
                  break;
                }
                Z.dmax = 1 << x, G.adler = Z.check = 1, Z.mode = 512 & z ? 10 : 12, O = z = 0;
                break;
              case 2:
                for (; O < 16; ) {
                  if (U === 0)
                    break t;
                  U--, z += W[j++] << O, O += 8;
                }
                if (Z.flags = z, (255 & Z.flags) != 8) {
                  G.msg = "unknown compression method", Z.mode = 30;
                  break;
                }
                if (57344 & Z.flags) {
                  G.msg = "unknown header flags set", Z.mode = 30;
                  break;
                }
                Z.head && (Z.head.text = z >> 8 & 1), 512 & Z.flags && (K[0] = 255 & z, K[1] = z >>> 8 & 255, Z.check = a(Z.check, K, 2, 0)), O = z = 0, Z.mode = 3;
              case 3:
                for (; O < 32; ) {
                  if (U === 0)
                    break t;
                  U--, z += W[j++] << O, O += 8;
                }
                Z.head && (Z.head.time = z), 512 & Z.flags && (K[0] = 255 & z, K[1] = z >>> 8 & 255, K[2] = z >>> 16 & 255, K[3] = z >>> 24 & 255, Z.check = a(Z.check, K, 4, 0)), O = z = 0, Z.mode = 4;
              case 4:
                for (; O < 16; ) {
                  if (U === 0)
                    break t;
                  U--, z += W[j++] << O, O += 8;
                }
                Z.head && (Z.head.xflags = 255 & z, Z.head.os = z >> 8), 512 & Z.flags && (K[0] = 255 & z, K[1] = z >>> 8 & 255, Z.check = a(Z.check, K, 2, 0)), O = z = 0, Z.mode = 5;
              case 5:
                if (1024 & Z.flags) {
                  for (; O < 16; ) {
                    if (U === 0)
                      break t;
                    U--, z += W[j++] << O, O += 8;
                  }
                  Z.length = z, Z.head && (Z.head.extra_len = z), 512 & Z.flags && (K[0] = 255 & z, K[1] = z >>> 8 & 255, Z.check = a(Z.check, K, 2, 0)), O = z = 0;
                } else
                  Z.head && (Z.head.extra = null);
                Z.mode = 6;
              case 6:
                if (1024 & Z.flags && (U < (ut = Z.length) && (ut = U), ut && (Z.head && (x = Z.head.extra_len - Z.length, Z.head.extra || (Z.head.extra = new Array(Z.head.extra_len)), r.arraySet(Z.head.extra, W, j, ut, x)), 512 & Z.flags && (Z.check = a(Z.check, W, ut, j)), U -= ut, j += ut, Z.length -= ut), Z.length))
                  break t;
                Z.length = 0, Z.mode = 7;
              case 7:
                if (2048 & Z.flags) {
                  if (U === 0)
                    break t;
                  for (ut = 0; x = W[j + ut++], Z.head && x && Z.length < 65536 && (Z.head.name += String.fromCharCode(x)), x && ut < U; )
                    ;
                  if (512 & Z.flags && (Z.check = a(Z.check, W, ut, j)), U -= ut, j += ut, x)
                    break t;
                } else
                  Z.head && (Z.head.name = null);
                Z.length = 0, Z.mode = 8;
              case 8:
                if (4096 & Z.flags) {
                  if (U === 0)
                    break t;
                  for (ut = 0; x = W[j + ut++], Z.head && x && Z.length < 65536 && (Z.head.comment += String.fromCharCode(x)), x && ut < U; )
                    ;
                  if (512 & Z.flags && (Z.check = a(Z.check, W, ut, j)), U -= ut, j += ut, x)
                    break t;
                } else
                  Z.head && (Z.head.comment = null);
                Z.mode = 9;
              case 9:
                if (512 & Z.flags) {
                  for (; O < 16; ) {
                    if (U === 0)
                      break t;
                    U--, z += W[j++] << O, O += 8;
                  }
                  if (z !== (65535 & Z.check)) {
                    G.msg = "header crc mismatch", Z.mode = 30;
                    break;
                  }
                  O = z = 0;
                }
                Z.head && (Z.head.hcrc = Z.flags >> 9 & 1, Z.head.done = !0), G.adler = Z.check = 0, Z.mode = 12;
                break;
              case 10:
                for (; O < 32; ) {
                  if (U === 0)
                    break t;
                  U--, z += W[j++] << O, O += 8;
                }
                G.adler = Z.check = b(z), O = z = 0, Z.mode = 11;
              case 11:
                if (Z.havedict === 0)
                  return G.next_out = gt, G.avail_out = ht, G.next_in = j, G.avail_in = U, Z.hold = z, Z.bits = O, 2;
                G.adler = Z.check = 1, Z.mode = 12;
              case 12:
                if (X === 5 || X === 6)
                  break t;
              case 13:
                if (Z.last) {
                  z >>>= 7 & O, O -= 7 & O, Z.mode = 27;
                  break;
                }
                for (; O < 3; ) {
                  if (U === 0)
                    break t;
                  U--, z += W[j++] << O, O += 8;
                }
                switch (Z.last = 1 & z, O -= 1, 3 & (z >>>= 1)) {
                  case 0:
                    Z.mode = 14;
                    break;
                  case 1:
                    if (D(Z), Z.mode = 20, X !== 6)
                      break;
                    z >>>= 2, O -= 2;
                    break t;
                  case 2:
                    Z.mode = 17;
                    break;
                  case 3:
                    G.msg = "invalid block type", Z.mode = 30;
                }
                z >>>= 2, O -= 2;
                break;
              case 14:
                for (z >>>= 7 & O, O -= 7 & O; O < 32; ) {
                  if (U === 0)
                    break t;
                  U--, z += W[j++] << O, O += 8;
                }
                if ((65535 & z) != (z >>> 16 ^ 65535)) {
                  G.msg = "invalid stored block lengths", Z.mode = 30;
                  break;
                }
                if (Z.length = 65535 & z, O = z = 0, Z.mode = 15, X === 6)
                  break t;
              case 15:
                Z.mode = 16;
              case 16:
                if (ut = Z.length) {
                  if (U < ut && (ut = U), ht < ut && (ut = ht), ut === 0)
                    break t;
                  r.arraySet(st, W, j, ut, gt), U -= ut, j += ut, ht -= ut, gt += ut, Z.length -= ut;
                  break;
                }
                Z.mode = 12;
                break;
              case 17:
                for (; O < 14; ) {
                  if (U === 0)
                    break t;
                  U--, z += W[j++] << O, O += 8;
                }
                if (Z.nlen = 257 + (31 & z), z >>>= 5, O -= 5, Z.ndist = 1 + (31 & z), z >>>= 5, O -= 5, Z.ncode = 4 + (15 & z), z >>>= 4, O -= 4, 286 < Z.nlen || 30 < Z.ndist) {
                  G.msg = "too many length or distance symbols", Z.mode = 30;
                  break;
                }
                Z.have = 0, Z.mode = 18;
              case 18:
                for (; Z.have < Z.ncode; ) {
                  for (; O < 3; ) {
                    if (U === 0)
                      break t;
                    U--, z += W[j++] << O, O += 8;
                  }
                  Z.lens[tt[Z.have++]] = 7 & z, z >>>= 3, O -= 3;
                }
                for (; Z.have < 19; )
                  Z.lens[tt[Z.have++]] = 0;
                if (Z.lencode = Z.lendyn, Z.lenbits = 7, H = { bits: Z.lenbits }, $ = c(0, Z.lens, 0, 19, Z.lencode, 0, Z.work, H), Z.lenbits = H.bits, $) {
                  G.msg = "invalid code lengths set", Z.mode = 30;
                  break;
                }
                Z.have = 0, Z.mode = 19;
              case 19:
                for (; Z.have < Z.nlen + Z.ndist; ) {
                  for (; Dt = (V = Z.lencode[z & (1 << Z.lenbits) - 1]) >>> 16 & 255, ee = 65535 & V, !((Wt = V >>> 24) <= O); ) {
                    if (U === 0)
                      break t;
                    U--, z += W[j++] << O, O += 8;
                  }
                  if (ee < 16)
                    z >>>= Wt, O -= Wt, Z.lens[Z.have++] = ee;
                  else {
                    if (ee === 16) {
                      for (T = Wt + 2; O < T; ) {
                        if (U === 0)
                          break t;
                        U--, z += W[j++] << O, O += 8;
                      }
                      if (z >>>= Wt, O -= Wt, Z.have === 0) {
                        G.msg = "invalid bit length repeat", Z.mode = 30;
                        break;
                      }
                      x = Z.lens[Z.have - 1], ut = 3 + (3 & z), z >>>= 2, O -= 2;
                    } else if (ee === 17) {
                      for (T = Wt + 3; O < T; ) {
                        if (U === 0)
                          break t;
                        U--, z += W[j++] << O, O += 8;
                      }
                      O -= Wt, x = 0, ut = 3 + (7 & (z >>>= Wt)), z >>>= 3, O -= 3;
                    } else {
                      for (T = Wt + 7; O < T; ) {
                        if (U === 0)
                          break t;
                        U--, z += W[j++] << O, O += 8;
                      }
                      O -= Wt, x = 0, ut = 11 + (127 & (z >>>= Wt)), z >>>= 7, O -= 7;
                    }
                    if (Z.have + ut > Z.nlen + Z.ndist) {
                      G.msg = "invalid bit length repeat", Z.mode = 30;
                      break;
                    }
                    for (; ut--; )
                      Z.lens[Z.have++] = x;
                  }
                }
                if (Z.mode === 30)
                  break;
                if (Z.lens[256] === 0) {
                  G.msg = "invalid code -- missing end-of-block", Z.mode = 30;
                  break;
                }
                if (Z.lenbits = 9, H = { bits: Z.lenbits }, $ = c(h, Z.lens, 0, Z.nlen, Z.lencode, 0, Z.work, H), Z.lenbits = H.bits, $) {
                  G.msg = "invalid literal/lengths set", Z.mode = 30;
                  break;
                }
                if (Z.distbits = 6, Z.distcode = Z.distdyn, H = { bits: Z.distbits }, $ = c(u, Z.lens, Z.nlen, Z.ndist, Z.distcode, 0, Z.work, H), Z.distbits = H.bits, $) {
                  G.msg = "invalid distances set", Z.mode = 30;
                  break;
                }
                if (Z.mode = 20, X === 6)
                  break t;
              case 20:
                Z.mode = 21;
              case 21:
                if (6 <= U && 258 <= ht) {
                  G.next_out = gt, G.avail_out = ht, G.next_in = j, G.avail_in = U, Z.hold = z, Z.bits = O, l(G, rt), gt = G.next_out, st = G.output, ht = G.avail_out, j = G.next_in, W = G.input, U = G.avail_in, z = Z.hold, O = Z.bits, Z.mode === 12 && (Z.back = -1);
                  break;
                }
                for (Z.back = 0; Dt = (V = Z.lencode[z & (1 << Z.lenbits) - 1]) >>> 16 & 255, ee = 65535 & V, !((Wt = V >>> 24) <= O); ) {
                  if (U === 0)
                    break t;
                  U--, z += W[j++] << O, O += 8;
                }
                if (Dt && !(240 & Dt)) {
                  for (ie = Wt, Ye = Dt, bi = ee; Dt = (V = Z.lencode[bi + ((z & (1 << ie + Ye) - 1) >> ie)]) >>> 16 & 255, ee = 65535 & V, !(ie + (Wt = V >>> 24) <= O); ) {
                    if (U === 0)
                      break t;
                    U--, z += W[j++] << O, O += 8;
                  }
                  z >>>= ie, O -= ie, Z.back += ie;
                }
                if (z >>>= Wt, O -= Wt, Z.back += Wt, Z.length = ee, Dt === 0) {
                  Z.mode = 26;
                  break;
                }
                if (32 & Dt) {
                  Z.back = -1, Z.mode = 12;
                  break;
                }
                if (64 & Dt) {
                  G.msg = "invalid literal/length code", Z.mode = 30;
                  break;
                }
                Z.extra = 15 & Dt, Z.mode = 22;
              case 22:
                if (Z.extra) {
                  for (T = Z.extra; O < T; ) {
                    if (U === 0)
                      break t;
                    U--, z += W[j++] << O, O += 8;
                  }
                  Z.length += z & (1 << Z.extra) - 1, z >>>= Z.extra, O -= Z.extra, Z.back += Z.extra;
                }
                Z.was = Z.length, Z.mode = 23;
              case 23:
                for (; Dt = (V = Z.distcode[z & (1 << Z.distbits) - 1]) >>> 16 & 255, ee = 65535 & V, !((Wt = V >>> 24) <= O); ) {
                  if (U === 0)
                    break t;
                  U--, z += W[j++] << O, O += 8;
                }
                if (!(240 & Dt)) {
                  for (ie = Wt, Ye = Dt, bi = ee; Dt = (V = Z.distcode[bi + ((z & (1 << ie + Ye) - 1) >> ie)]) >>> 16 & 255, ee = 65535 & V, !(ie + (Wt = V >>> 24) <= O); ) {
                    if (U === 0)
                      break t;
                    U--, z += W[j++] << O, O += 8;
                  }
                  z >>>= ie, O -= ie, Z.back += ie;
                }
                if (z >>>= Wt, O -= Wt, Z.back += Wt, 64 & Dt) {
                  G.msg = "invalid distance code", Z.mode = 30;
                  break;
                }
                Z.offset = ee, Z.extra = 15 & Dt, Z.mode = 24;
              case 24:
                if (Z.extra) {
                  for (T = Z.extra; O < T; ) {
                    if (U === 0)
                      break t;
                    U--, z += W[j++] << O, O += 8;
                  }
                  Z.offset += z & (1 << Z.extra) - 1, z >>>= Z.extra, O -= Z.extra, Z.back += Z.extra;
                }
                if (Z.offset > Z.dmax) {
                  G.msg = "invalid distance too far back", Z.mode = 30;
                  break;
                }
                Z.mode = 25;
              case 25:
                if (ht === 0)
                  break t;
                if (ut = rt - ht, Z.offset > ut) {
                  if ((ut = Z.offset - ut) > Z.whave && Z.sane) {
                    G.msg = "invalid distance too far back", Z.mode = 30;
                    break;
                  }
                  oe = ut > Z.wnext ? (ut -= Z.wnext, Z.wsize - ut) : Z.wnext - ut, ut > Z.length && (ut = Z.length), Le = Z.window;
                } else
                  Le = st, oe = gt - Z.offset, ut = Z.length;
                for (ht < ut && (ut = ht), ht -= ut, Z.length -= ut; st[gt++] = Le[oe++], --ut; )
                  ;
                Z.length === 0 && (Z.mode = 21);
                break;
              case 26:
                if (ht === 0)
                  break t;
                st[gt++] = Z.length, ht--, Z.mode = 21;
                break;
              case 27:
                if (Z.wrap) {
                  for (; O < 32; ) {
                    if (U === 0)
                      break t;
                    U--, z |= W[j++] << O, O += 8;
                  }
                  if (rt -= ht, G.total_out += rt, Z.total += rt, rt && (G.adler = Z.check = Z.flags ? a(Z.check, st, rt, gt - rt) : o(Z.check, st, rt, gt - rt)), rt = ht, (Z.flags ? z : b(z)) !== Z.check) {
                    G.msg = "incorrect data check", Z.mode = 30;
                    break;
                  }
                  O = z = 0;
                }
                Z.mode = 28;
              case 28:
                if (Z.wrap && Z.flags) {
                  for (; O < 32; ) {
                    if (U === 0)
                      break t;
                    U--, z += W[j++] << O, O += 8;
                  }
                  if (z !== (4294967295 & Z.total)) {
                    G.msg = "incorrect length check", Z.mode = 30;
                    break;
                  }
                  O = z = 0;
                }
                Z.mode = 29;
              case 29:
                $ = 1;
                break t;
              case 30:
                $ = -3;
                break t;
              case 31:
                return -4;
              case 32:
              default:
                return m;
            }
        return G.next_out = gt, G.avail_out = ht, G.next_in = j, G.avail_in = U, Z.hold = z, Z.bits = O, (Z.wsize || rt !== G.avail_out && Z.mode < 30 && (Z.mode < 27 || X !== 4)) && J(G, G.output, G.next_out, rt - G.avail_out) ? (Z.mode = 31, -4) : (_t -= G.avail_in, rt -= G.avail_out, G.total_in += _t, G.total_out += rt, Z.total += rt, Z.wrap && rt && (G.adler = Z.check = Z.flags ? a(Z.check, st, rt, G.next_out - rt) : o(Z.check, st, rt, G.next_out - rt)), G.data_type = Z.bits + (Z.last ? 64 : 0) + (Z.mode === 12 ? 128 : 0) + (Z.mode === 20 || Z.mode === 15 ? 256 : 0), (_t == 0 && rt === 0 || X === 4) && $ === p && ($ = -5), $);
      }, s.inflateEnd = function(G) {
        if (!G || !G.state)
          return m;
        var X = G.state;
        return X.window && (X.window = null), G.state = null, p;
      }, s.inflateGetHeader = function(G, X) {
        var Z;
        return G && G.state && 2 & (Z = G.state).wrap ? ((Z.head = X).done = !1, p) : m;
      }, s.inflateSetDictionary = function(G, X) {
        var Z, W = X.length;
        return G && G.state ? (Z = G.state).wrap !== 0 && Z.mode !== 11 ? m : Z.mode === 11 && o(1, X, W, 0) !== Z.check ? -3 : J(G, X, W, W) ? (Z.mode = 31, -4) : (Z.havedict = 1, p) : m;
      }, s.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e, i, s) {
      var r = e("../utils/common"), o = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], a = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], l = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], c = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      i.exports = function(h, u, p, m, g, _, y, b) {
        var w, v, C, k, Y, P, L, R, D, J = b.bits, G = 0, X = 0, Z = 0, W = 0, st = 0, j = 0, gt = 0, U = 0, ht = 0, z = 0, O = null, _t = 0, rt = new r.Buf16(16), ut = new r.Buf16(16), oe = null, Le = 0;
        for (G = 0; G <= 15; G++)
          rt[G] = 0;
        for (X = 0; X < m; X++)
          rt[u[p + X]]++;
        for (st = J, W = 15; 1 <= W && rt[W] === 0; W--)
          ;
        if (W < st && (st = W), W === 0)
          return g[_++] = 20971520, g[_++] = 20971520, b.bits = 1, 0;
        for (Z = 1; Z < W && rt[Z] === 0; Z++)
          ;
        for (st < Z && (st = Z), G = U = 1; G <= 15; G++)
          if (U <<= 1, (U -= rt[G]) < 0)
            return -1;
        if (0 < U && (h === 0 || W !== 1))
          return -1;
        for (ut[1] = 0, G = 1; G < 15; G++)
          ut[G + 1] = ut[G] + rt[G];
        for (X = 0; X < m; X++)
          u[p + X] !== 0 && (y[ut[u[p + X]]++] = X);
        if (P = h === 0 ? (O = oe = y, 19) : h === 1 ? (O = o, _t -= 257, oe = a, Le -= 257, 256) : (O = l, oe = c, -1), G = Z, Y = _, gt = X = z = 0, C = -1, k = (ht = 1 << (j = st)) - 1, h === 1 && 852 < ht || h === 2 && 592 < ht)
          return 1;
        for (; ; ) {
          for (L = G - gt, D = y[X] < P ? (R = 0, y[X]) : y[X] > P ? (R = oe[Le + y[X]], O[_t + y[X]]) : (R = 96, 0), w = 1 << G - gt, Z = v = 1 << j; g[Y + (z >> gt) + (v -= w)] = L << 24 | R << 16 | D | 0, v !== 0; )
            ;
          for (w = 1 << G - 1; z & w; )
            w >>= 1;
          if (w !== 0 ? (z &= w - 1, z += w) : z = 0, X++, --rt[G] == 0) {
            if (G === W)
              break;
            G = u[p + y[X]];
          }
          if (st < G && (z & k) !== C) {
            for (gt === 0 && (gt = st), Y += Z, U = 1 << (j = G - gt); j + gt < W && !((U -= rt[j + gt]) <= 0); )
              j++, U <<= 1;
            if (ht += 1 << j, h === 1 && 852 < ht || h === 2 && 592 < ht)
              return 1;
            g[C = z & k] = st << 24 | j << 16 | Y - _ | 0;
          }
        }
        return z !== 0 && (g[Y + z] = G - gt << 24 | 64 << 16 | 0), b.bits = st, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(e, i, s) {
      i.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 52: [function(e, i, s) {
      var r = e("../utils/common"), o = 0, a = 1;
      function l(V) {
        for (var K = V.length; 0 <= --K; )
          V[K] = 0;
      }
      var c = 0, h = 29, u = 256, p = u + 1 + h, m = 30, g = 19, _ = 2 * p + 1, y = 15, b = 16, w = 7, v = 256, C = 16, k = 17, Y = 18, P = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], L = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], R = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], D = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], J = new Array(2 * (p + 2));
      l(J);
      var G = new Array(2 * m);
      l(G);
      var X = new Array(512);
      l(X);
      var Z = new Array(256);
      l(Z);
      var W = new Array(h);
      l(W);
      var st, j, gt, U = new Array(m);
      function ht(V, K, tt, nt, A) {
        this.static_tree = V, this.extra_bits = K, this.extra_base = tt, this.elems = nt, this.max_length = A, this.has_stree = V && V.length;
      }
      function z(V, K) {
        this.dyn_tree = V, this.max_code = 0, this.stat_desc = K;
      }
      function O(V) {
        return V < 256 ? X[V] : X[256 + (V >>> 7)];
      }
      function _t(V, K) {
        V.pending_buf[V.pending++] = 255 & K, V.pending_buf[V.pending++] = K >>> 8 & 255;
      }
      function rt(V, K, tt) {
        V.bi_valid > b - tt ? (V.bi_buf |= K << V.bi_valid & 65535, _t(V, V.bi_buf), V.bi_buf = K >> b - V.bi_valid, V.bi_valid += tt - b) : (V.bi_buf |= K << V.bi_valid & 65535, V.bi_valid += tt);
      }
      function ut(V, K, tt) {
        rt(V, tt[2 * K], tt[2 * K + 1]);
      }
      function oe(V, K) {
        for (var tt = 0; tt |= 1 & V, V >>>= 1, tt <<= 1, 0 < --K; )
          ;
        return tt >>> 1;
      }
      function Le(V, K, tt) {
        var nt, A, lt = new Array(y + 1), dt = 0;
        for (nt = 1; nt <= y; nt++)
          lt[nt] = dt = dt + tt[nt - 1] << 1;
        for (A = 0; A <= K; A++) {
          var ct = V[2 * A + 1];
          ct !== 0 && (V[2 * A] = oe(lt[ct]++, ct));
        }
      }
      function Wt(V) {
        var K;
        for (K = 0; K < p; K++)
          V.dyn_ltree[2 * K] = 0;
        for (K = 0; K < m; K++)
          V.dyn_dtree[2 * K] = 0;
        for (K = 0; K < g; K++)
          V.bl_tree[2 * K] = 0;
        V.dyn_ltree[2 * v] = 1, V.opt_len = V.static_len = 0, V.last_lit = V.matches = 0;
      }
      function Dt(V) {
        8 < V.bi_valid ? _t(V, V.bi_buf) : 0 < V.bi_valid && (V.pending_buf[V.pending++] = V.bi_buf), V.bi_buf = 0, V.bi_valid = 0;
      }
      function ee(V, K, tt, nt) {
        var A = 2 * K, lt = 2 * tt;
        return V[A] < V[lt] || V[A] === V[lt] && nt[K] <= nt[tt];
      }
      function ie(V, K, tt) {
        for (var nt = V.heap[tt], A = tt << 1; A <= V.heap_len && (A < V.heap_len && ee(K, V.heap[A + 1], V.heap[A], V.depth) && A++, !ee(K, nt, V.heap[A], V.depth)); )
          V.heap[tt] = V.heap[A], tt = A, A <<= 1;
        V.heap[tt] = nt;
      }
      function Ye(V, K, tt) {
        var nt, A, lt, dt, ct = 0;
        if (V.last_lit !== 0)
          for (; nt = V.pending_buf[V.d_buf + 2 * ct] << 8 | V.pending_buf[V.d_buf + 2 * ct + 1], A = V.pending_buf[V.l_buf + ct], ct++, nt === 0 ? ut(V, A, K) : (ut(V, (lt = Z[A]) + u + 1, K), (dt = P[lt]) !== 0 && rt(V, A -= W[lt], dt), ut(V, lt = O(--nt), tt), (dt = L[lt]) !== 0 && rt(V, nt -= U[lt], dt)), ct < V.last_lit; )
            ;
        ut(V, v, K);
      }
      function bi(V, K) {
        var tt, nt, A, lt = K.dyn_tree, dt = K.stat_desc.static_tree, ct = K.stat_desc.has_stree, It = K.stat_desc.elems, jt = -1;
        for (V.heap_len = 0, V.heap_max = _, tt = 0; tt < It; tt++)
          lt[2 * tt] !== 0 ? (V.heap[++V.heap_len] = jt = tt, V.depth[tt] = 0) : lt[2 * tt + 1] = 0;
        for (; V.heap_len < 2; )
          lt[2 * (A = V.heap[++V.heap_len] = jt < 2 ? ++jt : 0)] = 1, V.depth[A] = 0, V.opt_len--, ct && (V.static_len -= dt[2 * A + 1]);
        for (K.max_code = jt, tt = V.heap_len >> 1; 1 <= tt; tt--)
          ie(V, lt, tt);
        for (A = It; tt = V.heap[1], V.heap[1] = V.heap[V.heap_len--], ie(V, lt, 1), nt = V.heap[1], V.heap[--V.heap_max] = tt, V.heap[--V.heap_max] = nt, lt[2 * A] = lt[2 * tt] + lt[2 * nt], V.depth[A] = (V.depth[tt] >= V.depth[nt] ? V.depth[tt] : V.depth[nt]) + 1, lt[2 * tt + 1] = lt[2 * nt + 1] = A, V.heap[1] = A++, ie(V, lt, 1), 2 <= V.heap_len; )
          ;
        V.heap[--V.heap_max] = V.heap[1], function(Ft, si) {
          var cn, Ii, hn, pe, En, Rn, Gi = si.dyn_tree, He = si.max_code, Yi = si.stat_desc.static_tree, qi = si.stat_desc.has_stree, wn = si.stat_desc.extra_bits, Zi = si.stat_desc.extra_base, Ve = si.stat_desc.max_length, zs = 0;
          for (pe = 0; pe <= y; pe++)
            Ft.bl_count[pe] = 0;
          for (Gi[2 * Ft.heap[Ft.heap_max] + 1] = 0, cn = Ft.heap_max + 1; cn < _; cn++)
            Ve < (pe = Gi[2 * Gi[2 * (Ii = Ft.heap[cn]) + 1] + 1] + 1) && (pe = Ve, zs++), Gi[2 * Ii + 1] = pe, He < Ii || (Ft.bl_count[pe]++, En = 0, Zi <= Ii && (En = wn[Ii - Zi]), Rn = Gi[2 * Ii], Ft.opt_len += Rn * (pe + En), qi && (Ft.static_len += Rn * (Yi[2 * Ii + 1] + En)));
          if (zs !== 0) {
            do {
              for (pe = Ve - 1; Ft.bl_count[pe] === 0; )
                pe--;
              Ft.bl_count[pe]--, Ft.bl_count[pe + 1] += 2, Ft.bl_count[Ve]--, zs -= 2;
            } while (0 < zs);
            for (pe = Ve; pe !== 0; pe--)
              for (Ii = Ft.bl_count[pe]; Ii !== 0; )
                He < (hn = Ft.heap[--cn]) || (Gi[2 * hn + 1] !== pe && (Ft.opt_len += (pe - Gi[2 * hn + 1]) * Gi[2 * hn], Gi[2 * hn + 1] = pe), Ii--);
          }
        }(V, K), Le(lt, jt, V.bl_count);
      }
      function x(V, K, tt) {
        var nt, A, lt = -1, dt = K[1], ct = 0, It = 7, jt = 4;
        for (dt === 0 && (It = 138, jt = 3), K[2 * (tt + 1) + 1] = 65535, nt = 0; nt <= tt; nt++)
          A = dt, dt = K[2 * (nt + 1) + 1], ++ct < It && A === dt || (ct < jt ? V.bl_tree[2 * A] += ct : A !== 0 ? (A !== lt && V.bl_tree[2 * A]++, V.bl_tree[2 * C]++) : ct <= 10 ? V.bl_tree[2 * k]++ : V.bl_tree[2 * Y]++, lt = A, jt = (ct = 0) === dt ? (It = 138, 3) : A === dt ? (It = 6, 3) : (It = 7, 4));
      }
      function $(V, K, tt) {
        var nt, A, lt = -1, dt = K[1], ct = 0, It = 7, jt = 4;
        for (dt === 0 && (It = 138, jt = 3), nt = 0; nt <= tt; nt++)
          if (A = dt, dt = K[2 * (nt + 1) + 1], !(++ct < It && A === dt)) {
            if (ct < jt)
              for (; ut(V, A, V.bl_tree), --ct != 0; )
                ;
            else
              A !== 0 ? (A !== lt && (ut(V, A, V.bl_tree), ct--), ut(V, C, V.bl_tree), rt(V, ct - 3, 2)) : ct <= 10 ? (ut(V, k, V.bl_tree), rt(V, ct - 3, 3)) : (ut(V, Y, V.bl_tree), rt(V, ct - 11, 7));
            lt = A, jt = (ct = 0) === dt ? (It = 138, 3) : A === dt ? (It = 6, 3) : (It = 7, 4);
          }
      }
      l(U);
      var H = !1;
      function T(V, K, tt, nt) {
        rt(V, (c << 1) + (nt ? 1 : 0), 3), function(A, lt, dt, ct) {
          Dt(A), ct && (_t(A, dt), _t(A, ~dt)), r.arraySet(A.pending_buf, A.window, lt, dt, A.pending), A.pending += dt;
        }(V, K, tt, !0);
      }
      s._tr_init = function(V) {
        H || (function() {
          var K, tt, nt, A, lt, dt = new Array(y + 1);
          for (A = nt = 0; A < h - 1; A++)
            for (W[A] = nt, K = 0; K < 1 << P[A]; K++)
              Z[nt++] = A;
          for (Z[nt - 1] = A, A = lt = 0; A < 16; A++)
            for (U[A] = lt, K = 0; K < 1 << L[A]; K++)
              X[lt++] = A;
          for (lt >>= 7; A < m; A++)
            for (U[A] = lt << 7, K = 0; K < 1 << L[A] - 7; K++)
              X[256 + lt++] = A;
          for (tt = 0; tt <= y; tt++)
            dt[tt] = 0;
          for (K = 0; K <= 143; )
            J[2 * K + 1] = 8, K++, dt[8]++;
          for (; K <= 255; )
            J[2 * K + 1] = 9, K++, dt[9]++;
          for (; K <= 279; )
            J[2 * K + 1] = 7, K++, dt[7]++;
          for (; K <= 287; )
            J[2 * K + 1] = 8, K++, dt[8]++;
          for (Le(J, p + 1, dt), K = 0; K < m; K++)
            G[2 * K + 1] = 5, G[2 * K] = oe(K, 5);
          st = new ht(J, P, u + 1, p, y), j = new ht(G, L, 0, m, y), gt = new ht(new Array(0), R, 0, g, w);
        }(), H = !0), V.l_desc = new z(V.dyn_ltree, st), V.d_desc = new z(V.dyn_dtree, j), V.bl_desc = new z(V.bl_tree, gt), V.bi_buf = 0, V.bi_valid = 0, Wt(V);
      }, s._tr_stored_block = T, s._tr_flush_block = function(V, K, tt, nt) {
        var A, lt, dt = 0;
        0 < V.level ? (V.strm.data_type === 2 && (V.strm.data_type = function(ct) {
          var It, jt = 4093624447;
          for (It = 0; It <= 31; It++, jt >>>= 1)
            if (1 & jt && ct.dyn_ltree[2 * It] !== 0)
              return o;
          if (ct.dyn_ltree[18] !== 0 || ct.dyn_ltree[20] !== 0 || ct.dyn_ltree[26] !== 0)
            return a;
          for (It = 32; It < u; It++)
            if (ct.dyn_ltree[2 * It] !== 0)
              return a;
          return o;
        }(V)), bi(V, V.l_desc), bi(V, V.d_desc), dt = function(ct) {
          var It;
          for (x(ct, ct.dyn_ltree, ct.l_desc.max_code), x(ct, ct.dyn_dtree, ct.d_desc.max_code), bi(ct, ct.bl_desc), It = g - 1; 3 <= It && ct.bl_tree[2 * D[It] + 1] === 0; It--)
            ;
          return ct.opt_len += 3 * (It + 1) + 5 + 5 + 4, It;
        }(V), A = V.opt_len + 3 + 7 >>> 3, (lt = V.static_len + 3 + 7 >>> 3) <= A && (A = lt)) : A = lt = tt + 5, tt + 4 <= A && K !== -1 ? T(V, K, tt, nt) : V.strategy === 4 || lt === A ? (rt(V, 2 + (nt ? 1 : 0), 3), Ye(V, J, G)) : (rt(V, 4 + (nt ? 1 : 0), 3), function(ct, It, jt, Ft) {
          var si;
          for (rt(ct, It - 257, 5), rt(ct, jt - 1, 5), rt(ct, Ft - 4, 4), si = 0; si < Ft; si++)
            rt(ct, ct.bl_tree[2 * D[si] + 1], 3);
          $(ct, ct.dyn_ltree, It - 1), $(ct, ct.dyn_dtree, jt - 1);
        }(V, V.l_desc.max_code + 1, V.d_desc.max_code + 1, dt + 1), Ye(V, V.dyn_ltree, V.dyn_dtree)), Wt(V), nt && Dt(V);
      }, s._tr_tally = function(V, K, tt) {
        return V.pending_buf[V.d_buf + 2 * V.last_lit] = K >>> 8 & 255, V.pending_buf[V.d_buf + 2 * V.last_lit + 1] = 255 & K, V.pending_buf[V.l_buf + V.last_lit] = 255 & tt, V.last_lit++, K === 0 ? V.dyn_ltree[2 * tt]++ : (V.matches++, K--, V.dyn_ltree[2 * (Z[tt] + u + 1)]++, V.dyn_dtree[2 * O(K)]++), V.last_lit === V.lit_bufsize - 1;
      }, s._tr_align = function(V) {
        rt(V, 2, 3), ut(V, v, J), function(K) {
          K.bi_valid === 16 ? (_t(K, K.bi_buf), K.bi_buf = 0, K.bi_valid = 0) : 8 <= K.bi_valid && (K.pending_buf[K.pending++] = 255 & K.bi_buf, K.bi_buf >>= 8, K.bi_valid -= 8);
        }(V);
      };
    }, { "../utils/common": 41 }], 53: [function(e, i, s) {
      i.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, {}], 54: [function(e, i, s) {
      (function(r) {
        (function(o, a) {
          if (!o.setImmediate) {
            var l, c, h, u, p = 1, m = {}, g = !1, _ = o.document, y = Object.getPrototypeOf && Object.getPrototypeOf(o);
            y = y && y.setTimeout ? y : o, l = {}.toString.call(o.process) === "[object process]" ? function(C) {
              process.nextTick(function() {
                w(C);
              });
            } : function() {
              if (o.postMessage && !o.importScripts) {
                var C = !0, k = o.onmessage;
                return o.onmessage = function() {
                  C = !1;
                }, o.postMessage("", "*"), o.onmessage = k, C;
              }
            }() ? (u = "setImmediate$" + Math.random() + "$", o.addEventListener ? o.addEventListener("message", v, !1) : o.attachEvent("onmessage", v), function(C) {
              o.postMessage(u + C, "*");
            }) : o.MessageChannel ? ((h = new MessageChannel()).port1.onmessage = function(C) {
              w(C.data);
            }, function(C) {
              h.port2.postMessage(C);
            }) : _ && "onreadystatechange" in _.createElement("script") ? (c = _.documentElement, function(C) {
              var k = _.createElement("script");
              k.onreadystatechange = function() {
                w(C), k.onreadystatechange = null, c.removeChild(k), k = null;
              }, c.appendChild(k);
            }) : function(C) {
              setTimeout(w, 0, C);
            }, y.setImmediate = function(C) {
              typeof C != "function" && (C = new Function("" + C));
              for (var k = new Array(arguments.length - 1), Y = 0; Y < k.length; Y++)
                k[Y] = arguments[Y + 1];
              var P = { callback: C, args: k };
              return m[p] = P, l(p), p++;
            }, y.clearImmediate = b;
          }
          function b(C) {
            delete m[C];
          }
          function w(C) {
            if (g)
              setTimeout(w, 0, C);
            else {
              var k = m[C];
              if (k) {
                g = !0;
                try {
                  (function(Y) {
                    var P = Y.callback, L = Y.args;
                    switch (L.length) {
                      case 0:
                        P();
                        break;
                      case 1:
                        P(L[0]);
                        break;
                      case 2:
                        P(L[0], L[1]);
                        break;
                      case 3:
                        P(L[0], L[1], L[2]);
                        break;
                      default:
                        P.apply(a, L);
                    }
                  })(k);
                } finally {
                  b(C), g = !1;
                }
              }
            }
          }
          function v(C) {
            C.source === o && typeof C.data == "string" && C.data.indexOf(u) === 0 && w(+C.data.slice(u.length));
          }
        })(typeof self > "u" ? r === void 0 ? this : r : self);
      }).call(this, typeof tr < "u" ? tr : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}] }, {}, [10])(10);
  });
})(rm);
var Ch = rm.exports;
const om = /* @__PURE__ */ Rl(Ch), N_ = new om();
class sl {
  constructor(t, e) {
    this._version = pn.Unknown, this._topicsMap = /* @__PURE__ */ new Map(), this._bcfFileName = t, this._id = e;
  }
  /**
   * Exports BCF data to a file. Prompts the user to save it on their device.
   * @param filename Filename BCF data will be exported as
   */
  async exportBCF(t) {
    await this.toBcfZipBlob().then((e) => {
      const i = document.createElement("a"), s = URL.createObjectURL(e);
      i.href = s, i.download = `${t}.bcf`, document.body.appendChild(i), i.click(), setTimeout(() => {
        document.body.removeChild(i), URL.revokeObjectURL(s);
      }, 0);
    });
  }
  /**
   * Creates a BCFZIP blob. The resulting blob is importable using `BcfManager.addBCFFromBuffer`.
   */
  toBcfZipBlob() {
    const t = new XMLSerializer(), e = '<?xml version="1.0" encoding="UTF-8"?><Version VersionId="2.1" xsi:noNamespaceSchemaLocation="version.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><DetailedVersion>2.1</DetailedVersion></Version>', i = N_.file("bcf.version", e);
    return this._topicsMap.forEach((s, r) => {
      const o = i.folder(r);
      if (o === null) {
        console.error("Failed to create folder for BCF topic");
        return;
      }
      const a = t.serializeToString(s.getMarkup().export());
      o.file("markup.bcf", a), s.getViewpointMap().forEach((h, u) => {
        const p = t.serializeToString(h.export());
        o.file(u, p);
      }), s.getSnapshotMap().forEach((h, u) => {
        o.file(u, h.getData());
      });
    }), i.generateAsync({ type: "blob" });
  }
  /**
   * Adds a BCF topic.
   * @param topicId
   * @param topic
   */
  addTopic(t, e) {
    this._topicsMap.set(t, e);
  }
  /**
   * @returns A map associating BCF topic ids to BCF topic data.
   */
  getTopics() {
    return this._topicsMap;
  }
  /**
   * Gets a BCF topic.
   * @param topicId
   */
  getTopic(t) {
    return this._topicsMap.get(t) || null;
  }
  /**
   * Gets the BCF version.
   */
  getVersion() {
    return this._version;
  }
  /**
   * Sets the BCF version.
   * @param version
   */
  setVersion(t) {
    this._version = t;
  }
  /**
   * Gets the BCF filename.
   */
  getFilename() {
    return this._bcfFileName;
  }
  /**
   * Identifier used to keep track of loaded BCF data.
   */
  getId() {
    return this._id;
  }
}
function Qi() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(n) {
    const t = new Uint32Array(1);
    bg().getRandomValues(t);
    const e = t[0] / 4294967295 * 16 | 0;
    return (n === "x" ? e : e & 3 | 8).toString(16);
  });
}
class am {
  constructor(t, e, i, s, r, o) {
    this._ifcProject = t, this._ifcSpatialStructureElement = e, this._isExternal = i, this._filename = s, this._date = r, this._reference = o;
  }
  /**
   * [[GenericId]] Reference to the project to which this topic is related in the IFC file
   */
  getIfcProject() {
    return this._ifcProject || null;
  }
  /**
   * [[GenericId]] Reference to the spatial structure element, e.g. IfcBuildingStorey, to which this topic is related.
   */
  getIfcSpacialStructureElement() {
    return this._ifcSpatialStructureElement || null;
  }
  /**
   * Is the IFC file external or within the bcfzip
   */
  getIsExternal() {
    return this._isExternal || null;
  }
  /**
   * The BIM file related to this topic.
   */
  getBimFilename() {
    return this._filename || null;
  }
  /**
   * Date of the BIM file.
   */
  getBimDate() {
    return this._date || null;
  }
  /**
   * URI to IfcFile.
   * IsExternal=false "..\example.ifc" (within bcfzip)
   * IsExternal=true "https://.../example.ifc"
   */
  getReference() {
    return this._reference || null;
  }
}
class lm {
  constructor(t, e, i, s) {
    this._viewpointFilename = void 0, this._snapshotFilename = void 0, this._index = void 0, this._guid = t, this._viewpointFilename = e, this._snapshotFilename = i, s !== void 0 && (this._index = parseInt(s, 10));
  }
  getGuid() {
    return this._guid;
  }
  getViewpointFilename() {
    return this._viewpointFilename || null;
  }
  getSnapshotFilename() {
    return this._snapshotFilename || null;
  }
  getIndex() {
    return this._index || null;
  }
}
class Tc {
  constructor(t, e, i, s, r, o, a) {
    this._guid = t, this._date = e, this._author = i, this._text = s, this._viewpointGuid = r, this._modifiedDate = o, this._modifiedAuthor = a;
  }
  getId() {
    return this._guid;
  }
  getDate() {
    return this._date;
  }
  setDate(t) {
    this._date = t;
  }
  getAuthor() {
    return this._author;
  }
  setAuthor(t) {
    this._author = t;
  }
  getText() {
    return this._text;
  }
  setText(t) {
    this._text = t;
  }
  getViewpointGuid() {
    return this._viewpointGuid || null;
  }
  setViewpointGuid(t) {
    this._viewpointGuid = t !== null ? t : void 0;
  }
  getModifiedDate() {
    return this._modifiedDate || null;
  }
  setModifiedDate(t) {
    this._modifiedDate = t !== null ? t : void 0;
  }
  getModifiedAuthor() {
    return this._modifiedAuthor || null;
  }
  setModifiedAuthor(t) {
    this._modifiedAuthor = t !== null ? t : void 0;
  }
}
class cm {
  constructor(t, e, i) {
    this._markupHeaderFiles = [], this._topic = {
      guid: "",
      title: "",
      creationDate: /* @__PURE__ */ new Date(),
      creationAuthor: ""
    }, this._comments = /* @__PURE__ */ new Map(), this._viewpoints = /* @__PURE__ */ new Map(), this._filename = t, this._bcfTopic = i, this._parseDocument(e);
  }
  _parseDocument(t) {
    if (t === null)
      return;
    let i = t.documentElement.firstElementChild;
    for (; i !== null; ) {
      const s = i.localName;
      if (s === null)
        break;
      switch (s) {
        case "Header":
          this._parseHeader(i);
          break;
        case "Topic":
          this._parseTopic(i);
          break;
        case "Comment":
          this._parseComment(i);
          break;
        case "Viewpoints":
          this._parseViewpoint(i);
          break;
      }
      i = i.nextElementSibling;
    }
  }
  _exportHeader(t) {
    const e = t.createElement("Header");
    return Fn(e, "ProjectGuid", this._projectGuid), this._markupHeaderFiles.forEach((i) => {
      const s = t.createElement("File");
      Fn(s, "IfcProject", i.getIfcProject()), Fn(
        s,
        "IfcSpatialStructureElement",
        i.getIfcSpacialStructureElement()
      ), Fn(
        s,
        "isExternal",
        nl(i.getIsExternal())
      ), Be(t, s, "Filename", i.getBimFilename()), Be(t, s, "Date", bo(i.getBimDate())), Be(t, s, "Reference", i.getReference()), e.appendChild(s);
    }), e;
  }
  _exportTopicData(t) {
    const e = t.createElement("Topic");
    if (e.setAttribute("Guid", this._topic.guid), Fn(e, "TopicType", this._topic.topicType), Fn(e, "TopicStatus", this._topic.topicStatus), On(t, e, "Title", this._topic.title), On(t, e, "CreationDate", this._topic.creationDate.toISOString()), On(t, e, "CreationAuthor", this._topic.creationAuthor), Be(t, e, "ReferenceLink", this._topic.referenceLink), Be(t, e, "Priority", this._topic.priority), Be(t, e, "Index", Vc(this._topic.index)), Be(
      t,
      e,
      "ModifiedDate",
      bo(this._topic.modifiedDate)
    ), Be(t, e, "ModifiedAuthor", this._topic.modifiedAuthor), Be(t, e, "DueDate", bo(this._topic.dueDate)), Be(t, e, "AssignedTo", this._topic.assignedTo), Be(t, e, "Description", this._topic.description), Be(t, e, "Stage", this._topic.stage), this._topic.labels) {
      const i = t.createElement("Labels");
      this._topic.labels.forEach((s) => {
        On(t, i, "Label", s);
      }), e.appendChild(i);
    }
    return e;
  }
  _exportBimSnippet(t, e) {
    const i = t.createElement("BimSnippet");
    return i.setAttribute("SnippetType", e.snippetType), Fn(
      i,
      "isExternal",
      nl(e.isExternal)
    ), On(t, i, "Reference", e.reference), Be(t, i, "ReferenceSchema", e.referenceSchema), i;
  }
  _exportDocumentReference(t, e) {
    const i = t.createElement("DocumentReference");
    return Fn(i, "Guid", e.guid), Fn(
      i,
      "isExternal",
      nl(e.isExternal)
    ), Be(
      t,
      i,
      "ReferencedDocument",
      e.referencedDocument
    ), Be(t, i, "Description", e.description), i;
  }
  _exportRelatedTopic(t, e) {
    const i = t.createElement("RelatedTopic");
    return i.setAttribute("Guid", e.guid), i;
  }
  _exportTopic(t) {
    const e = this._exportTopicData(t);
    return this._topic.bimSnippets && this._topic.bimSnippets.forEach((i) => {
      e.appendChild(this._exportBimSnippet(t, i));
    }), this._topic.documentReferences && this._topic.documentReferences.forEach((i) => {
      e.appendChild(this._exportDocumentReference(t, i));
    }), this._topic.relatedTopics && this._topic.relatedTopics.forEach((i) => {
      e.appendChild(this._exportRelatedTopic(t, i));
    }), e;
  }
  _exportComment(t, e) {
    const i = t.createElement("Comment");
    i.setAttribute("Guid", e.getId()), On(t, i, "Date", e.getDate().toISOString()), On(t, i, "Author", e.getAuthor()), On(t, i, "Comment", e.getText()), Be(
      t,
      i,
      "ModifiedDate",
      bo(e.getModifiedDate())
    ), Be(t, i, "ModifiedAuthor", e.getModifiedAuthor());
    const s = e.getViewpointGuid();
    if (s) {
      const r = t.createElement("Viewpoint");
      r.setAttribute("Guid", s), i.appendChild(r);
    }
    return i;
  }
  _exportViewpoint(t, e) {
    const i = t.createElement("Viewpoints");
    return i.setAttribute("Guid", e.getGuid()), Be(t, i, "Viewpoint", e.getViewpointFilename()), Be(t, i, "Snapshot", e.getSnapshotFilename()), Be(
      t,
      i,
      "Index",
      Vc(e.getIndex())
    ), i;
  }
  /**
   * @returns XML document containing the markup data.
   */
  export() {
    const t = document.implementation.createDocument("", "", null), e = t.createElement("Markup");
    return e.appendChild(this._exportHeader(t)), e.appendChild(this._exportTopic(t)), this._comments.forEach((i) => {
      e.appendChild(this._exportComment(t, i));
    }), this._viewpoints.forEach((i) => {
      e.appendChild(this._exportViewpoint(t, i));
    }), t.appendChild(e), t;
  }
  /**
   * @returns the project GUID.
   */
  getProjectGuid() {
    return this._projectGuid || null;
  }
  /**
   * @returns a list of [[BCFMarkupHeaderFile]] containing data related to IFC files.
   */
  getMarkupHeaderFiles() {
    return this._markupHeaderFiles;
  }
  /**
   * Gets the Markup filename.
   */
  getFilename() {
    return this._filename;
  }
  /**
   * Gets the topic id.
   */
  getTopicId() {
    return this._topic.guid;
  }
  /**
   * Sets the topic id.
   * @param guid
   */
  setTopicId(t) {
    this._topic.guid = t;
  }
  /**
   * Gets the topic type.
   */
  getTopicType() {
    return this._topic.topicType || null;
  }
  /**
   * Sets the topic type.
   * @param topicType
   */
  setTopicType(t) {
    this._topic.topicType = t !== null ? t : void 0;
  }
  /**
   * Gets the topic status.
   */
  getTopicStatus() {
    return this._topic.topicStatus || null;
  }
  /**
   * Sets the topic status.
   * @param topicStatus
   */
  setTopicStatus(t) {
    this._topic.topicStatus = t !== null ? t : void 0;
  }
  /**
   * Gets the title of the markup topic.
   */
  getTopicTitle() {
    return this._topic.title;
  }
  /**
   * Sets the title of the markup topic.
   * @param title
   */
  setTopicTitle(t) {
    this._topic.title = t;
  }
  /**
   * Gets the creation date of the markup topic.
   */
  getTopicCreationDate() {
    return this._topic.creationDate;
  }
  /**
   * Sets the creation date of the markup topic;
   * @param date
   */
  setTopicCreationDate(t) {
    this._topic.creationDate = t;
  }
  /**
   * Gets the name of the user that created the markup topic.
   */
  getTopicCreationAuthor() {
    return this._topic.creationAuthor;
  }
  /**
   * Sets the name of the user that created the markup topic.
   * @param author
   */
  setTopicCreationAuthor(t) {
    this._topic.creationAuthor = t;
  }
  /**
   * List of references to the topic, for example, a work request management system or an URI to a model.
   */
  getTopicReferenceLink() {
    return this._topic.referenceLink || null;
  }
  /**
   * Sets the ReferenceLink.
   * @param referenceLink
   */
  setTopicReferenceLink(t) {
    this._topic.referenceLink = t === null ? void 0 : t;
  }
  /**
   * Gets the topic priority.
   */
  getTopicPriority() {
    return this._topic.priority || null;
  }
  /**
   * Sets the topic priority.
   * @param priority
   */
  setTopicPriority(t) {
    this._topic.priority = t === null ? void 0 : t;
  }
  /**
   * Number to maintain the order of the topics.
   */
  getTopicIndex() {
    return this._topic.index || null;
  }
  /**
   * Sets the topic index.
   * @param index
   */
  setTopicIndex(t) {
    this._topic.index = t === null ? void 0 : t;
  }
  /**
   * Tags for grouping Topics.
   */
  getTopicLabels() {
    return this._topic.labels === void 0 ? [] : this._topic.labels.slice();
  }
  /**
   * Sets the topic labels.
   * @param labels
   */
  setTopicLabels(t) {
    this._topic.labels = t.slice();
  }
  /**
   * Date when the topic was last modified. Exists only when Topic has been modified after creation.
   */
  getTopicModifiedDate() {
    return this._topic.modifiedDate || null;
  }
  /**
   * Sets the topic modified date.
   * @param date
   */
  setTopicModifiedDate(t) {
    this._topic.modifiedDate = t === null ? void 0 : t;
  }
  /**
   * User who modified the topic. Exists only when Topic has been modified after creation.
   */
  getTopicModifiedAuthor() {
    return this._topic.modifiedAuthor || null;
  }
  /**
   * Sets the author that last modified the topic.
   * @param modifiedAuthor
   */
  setTopicModifiedAuthor(t) {
    this._topic.modifiedAuthor = t === null ? void 0 : t;
  }
  /**
   * Date when the issue needs to be resolved by.
   */
  getTopicDueDate() {
    return this._topic.dueDate || null;
  }
  /**
   * Sets the topic due date.
   * @param date
   */
  setTopicDueDate(t) {
    this._topic.dueDate = t === null ? void 0 : t;
  }
  /**
   * The user to whom this topic is assigned to. Recommended to be in email format. The list of possible values are defined in the extension schema.
   */
  getTopicAssignedTo() {
    return this._topic.assignedTo || null;
  }
  /**
   * Sets the user that the topic is assigned to.
   */
  setTopicAssignedTo(t) {
    this._topic.assignedTo = t === null ? void 0 : t;
  }
  /**
   * Description of the topic.
   */
  getTopicDescription() {
    return this._topic.description || null;
  }
  /**
   * Sets the topic description;
   * @param description
   */
  setTopicDescription(t) {
    this._topic.description = t === null ? void 0 : t;
  }
  /**
   * Stage this topic is part of.
   */
  getTopicStage() {
    return this._topic.stage || null;
  }
  /**
   * Sets the topic stage;
   * @param stage
   */
  setTopicState(t) {
    this._topic.stage = t === null ? void 0 : t;
  }
  /**
   * Gets a map of GUIDs and corresponding comments.
   */
  getComments() {
    return this._comments;
  }
  /**
   * Adds a comment to the topic.
   * @param date
   * @param author
   * @param text
   * @param viewpointGuid
   * @param modifiedDate
   * @param modifiedAuthor
   */
  addComment(t, e, i, s, r, o) {
    const a = Qi(), l = new Tc(
      a,
      t,
      e,
      i,
      s,
      r,
      o
    );
    return this._comments.set(a, l), l;
  }
  /**
   * Updates a topic comment.
   * @param comment
   */
  updateComment(t) {
    const e = t.getId();
    this._comments.set(e, t);
  }
  /**
   * Deletes a comment from the topic..
   * @param guid
   */
  deleteComment(t) {
    this._comments.delete(t);
  }
  /**
   * Gets a map of GUIDs and corresponding viewpoints.
   */
  getViewpoints() {
    return this._viewpoints;
  }
  _addFile(t) {
    const e = this._getElementAttributes(t), i = this._getChildData(t), s = i.get("Date"), r = {
      date: s === void 0 ? void 0 : new Date(s),
      filename: i.get("Filename"),
      reference: i.get("Reference"),
      ifcProject: e.get("IfcProject"),
      ifcSpatialStructureElement: e.get("IfcSpatialStructureElement"),
      isExternal: e.get("isExternal") === "true"
    };
    this._markupHeaderFiles.push(
      new am(
        r.ifcProject,
        r.ifcSpatialStructureElement,
        r.isExternal,
        r.filename,
        r.date,
        r.reference
      )
    );
  }
  _parseHeader(t) {
    const i = this._getElementAttributes(t).get("ProjectGuid");
    i !== void 0 && (this._projectGuid = i);
    let s = t.firstElementChild;
    s !== null && (this._addFile(s), s = s.nextElementSibling);
  }
  _parseTopic(t) {
    const e = this._getElementAttributes(t), i = e.get("Guid");
    if (i === void 0)
      return;
    this._topic.guid = i, this._topic.topicType = e.get("TopicType") || e.get("Status"), this._topic.topicStatus = e.get("TopicStatus") || e.get("VerbalStatus");
    let s = t.firstElementChild;
    if (s !== null)
      for (; s !== null; ) {
        const r = s.localName;
        if (r === null)
          break;
        const o = this._getChildData(s), a = this._getElementAttributes(s);
        switch (r) {
          case "BimSnippet":
            {
              this._topic.bimSnippets === void 0 && (this._topic.bimSnippets = []);
              const l = o.get("Reference"), c = a.get("SnippetType");
              if (l !== void 0 && c !== void 0) {
                const h = {
                  snippetType: c,
                  reference: l
                };
                a.get("isExternal") && (h.isExternal = a.get("isExternal") === "true"), o.get("ReferenceSchema") && (h.referenceSchema = o.get("ReferenceSchema")), this._topic.bimSnippets.push(h);
              }
            }
            break;
          case "DocumentReference":
            {
              this._topic.documentReferences === void 0 && (this._topic.documentReferences = []);
              const l = {};
              o.get("Guid") && (l.guid = o.get("Guid")), o.get("isExternal") && (l.isExternal = o.get("isExternal") === "true"), o.get("Description") && (l.description = o.get("Description")), o.get("ReferencedDocument") && (l.referencedDocument = o.get("ReferencedDocument")), this._topic.documentReferences.push(l);
            }
            break;
          case "RelatedTopic":
            {
              this._topic.relatedTopics === void 0 && (this._topic.relatedTopics = []);
              const l = o.get("Guid");
              if (l !== void 0) {
                const c = {
                  guid: l
                };
                this._topic.relatedTopics.push(c);
              }
            }
            break;
          case "ReferenceLink":
            s.textContent && (this._topic.referenceLink = s.textContent);
            break;
          case "Title":
            s.textContent && (this._topic.title = s.textContent);
            break;
          case "Priority":
            s.textContent && (this._topic.priority = s.textContent);
            break;
          case "Index":
            s.textContent && (this._topic.index = parseInt(s.textContent, 10));
            break;
          case "Labels":
            {
              let l = s.firstChild;
              if (!l)
                break;
              for (this._topic.labels === void 0 && (this._topic.labels = []); l; )
                l.textContent && this._topic.labels.push(l.textContent), l = l.nextSibling;
            }
            break;
          case "CreationDate":
            s.textContent && (this._topic.creationDate = new Date(s.textContent));
            break;
          case "CreationAuthor":
            s.textContent && (this._topic.creationAuthor = s.textContent);
            break;
          case "ModifiedDate":
            s.textContent && (this._topic.modifiedDate = new Date(s.textContent));
            break;
          case "ModifiedAuthor":
            s.textContent && (this._topic.modifiedAuthor = s.textContent);
            break;
          case "DueDate":
            s.textContent && (this._topic.dueDate = new Date(s.textContent));
            break;
          case "AssignedTo":
            s.textContent && (this._topic.assignedTo = s.textContent);
            break;
          case "Description":
            s.textContent && (this._topic.description = s.textContent);
            break;
          case "Stage":
            s.textContent && (this._topic.stage = s.textContent);
            break;
        }
        s = s.nextElementSibling;
      }
  }
  _parseComment(t) {
    let e = "", i = /* @__PURE__ */ new Date(), s = "", r = "", o, a, l;
    const h = this._getElementAttributes(t).get("Guid");
    if (h)
      e = h;
    else
      return;
    let u = t.firstElementChild;
    if (u !== null)
      for (; u !== null; ) {
        const m = u.localName;
        if (m === null)
          break;
        switch (m) {
          case "Date":
            u.textContent && (i = new Date(u.textContent));
            break;
          case "Author":
            u.textContent && (s = u.textContent);
            break;
          case "Comment":
            u.textContent && (r = u.textContent);
            break;
          case "Viewpoint":
            o = this._getElementAttributes(u).get("Guid");
            break;
          case "ModifiedDate":
            u.textContent && (a = new Date(u.textContent));
            break;
          case "ModifiedAuthor":
            u.textContent && (l = u.textContent);
            break;
        }
        u = u.nextElementSibling;
      }
    const p = new Tc(
      e,
      i,
      s,
      r,
      o,
      a,
      l
    );
    this._comments.set(e, p);
  }
  _parseViewpoint(t) {
    const i = this._getElementAttributes(t).get("Guid");
    if (i !== void 0) {
      const s = this._getChildData(t), r = s.get("Viewpoint"), o = s.get("Snapshot"), a = s.get("Index");
      this.addViewpoint(i, r, o, a);
    }
  }
  addViewpoint(t, e, i, s) {
    this._viewpoints.set(
      t,
      new lm(t, e, i, s)
    );
  }
  _getChildData(t) {
    const e = /* @__PURE__ */ new Map();
    let i = t.firstElementChild;
    for (; i !== null; ) {
      const s = i.localName;
      let r = null;
      i.firstElementChild === null && (r = i.textContent), s !== null && r !== null && e.set(s, r), i = i.nextElementSibling;
    }
    return e;
  }
  _getElementAttributes(t) {
    const e = t.attributes, i = /* @__PURE__ */ new Map();
    for (let s = 0; s < e.length; ++s) {
      const r = e[s], o = r.name, a = r.value;
      i.set(o, a);
    }
    return i;
  }
}
class ar {
  constructor(t, e) {
    this._filename = t, this._data = e;
  }
  /**
   * Creates a BCF Snapshot from an HTMLImageElement.
   * @param filename
   * @param image
   */
  static createFromImage(t, e) {
    const i = ar.snapshotDataFromImage(e);
    return new ar(t, i);
  }
  /**
   * Gets the filename.
   */
  getFilename() {
    return this._filename;
  }
  /**
   * Gets png data.
   */
  getData() {
    return this._data;
  }
  /**
   * Gets a url for images corresponding to viewpoints.
   */
  getUrl() {
    const t = new Blob([this._data], { type: "image/png" });
    return URL.createObjectURL(t, { oneTimeOnly: !0 });
  }
  /**
   * Gets image data as a Uint8Array from an HTMLImageElement.
   * @param img
   */
  static snapshotDataFromImage(t) {
    const e = t.src;
    return ar._convertDataURIToBinary(e);
  }
  static _convertDataURIToBinary(t) {
    const e = ";base64,", i = t.indexOf(e) + e.length, s = window.atob(t.substring(i)), r = new Uint8Array(s.length);
    for (let o = 0; o < s.length; o++) {
      const a = s[o].charCodeAt(0);
      r[o] = a;
    }
    return r;
  }
}
class _s {
  constructor() {
    this._behindView = !1;
  }
  /**
   * Called when the MarkupItem is removed from the system.
   * Any cleanup that needs to be done should be performed in this method.
   */
  remove() {
  }
  // XXX: This should probably have a `Promise<void>` return type. See `NoteText.prototype.remove` for an example.
  /**
   * Called when the markup item should be redrawn on the screen. This most typically happens when the scene is rendered.
   */
  draw() {
  }
  /**
   * Called when a hit test is performed on this markup item.
   * @param point position in window where the hit test is being performed.
   * @returns boolean value indicating whether this item was picked
   */
  hit(t) {
    return !1;
  }
  /**
   * Called when a hit test is performed on this markup item.
   * @param point position in window where the hit test is being performed.
   * @param pickTolerance amount of tolerance allowed for a hit in pixels.
   * @returns boolean value indicating whether this item was picked
   */
  hitWithTolerance(t, e) {
    return !1;
  }
  /**
   * Called when this markup item is selected by the system.
   */
  onSelect() {
  }
  /**
   * Called when this markup item is deselected by the system
   */
  onDeselect() {
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return {};
  }
  /**
   * Gets the fully qualified class name for this markup item. E.g. "Communicator.Markup.Redline.RedlineCircle"
   * @returns fully qualified class name
   */
  getClassName() {
    return "Communicator.Markup.MarkupItem";
  }
}
class to extends _s {
  constructor(t) {
    super(), this._viewer = t;
  }
  onDragStart(t) {
    return !1;
  }
  onDragMove(t) {
    return !1;
  }
  onDragEnd(t) {
    return !1;
  }
  remove() {
    this._viewer.trigger("redlineDeleted", this), this._viewer.markupManager.refreshMarkup();
  }
}
class kh {
  constructor() {
    this._strokeWidth = 1, this._strokeColor = it.black();
  }
  /** @hidden */
  _assign(t) {
    this._strokeWidth = t._strokeWidth, this._strokeColor.assign(t._strokeColor);
  }
  /**
   * Sets the stroke color for this shape
   * @param color the stroke color
   */
  setStrokeColor(t) {
    this._strokeColor.assign(t);
  }
  /**
   * Gets the stroke color for this shape
   * @returns the stroke color
   */
  getStrokeColor() {
    return this._strokeColor.copy();
  }
  /**
   * Sets the stroke width for this shape in pixels
   * @param strokeWidth the stroke width in pixels
   */
  setStrokeWidth(t) {
    this._strokeWidth = t;
  }
  /**
   * Gets the stroke width for this shape in pixels
   * @returns the stroke width in pixels
   */
  getStrokeWidth() {
    return this._strokeWidth;
  }
}
class yr extends kh {
  constructor() {
    super(...arguments), this._fillColor = it.black(), this._fillOpacity = 1;
  }
  /** @hidden */
  _assign(t) {
    super._assign(t), this._fillColor.assign(t._fillColor), this._fillOpacity = t._fillOpacity;
  }
  /**
   * Gets the fill opacity for this shape
   * @returns the fill opacity
   */
  getFillOpacity() {
    return this._fillOpacity;
  }
  /**
   * Sets the fill opacity for this shape
   * @param fillOpacity the fill opacity
   */
  setFillOpacity(t) {
    this._fillOpacity = t;
  }
  /**
   * Sets the fill color for this shape
   * @param color the fill color
   */
  setFillColor(t) {
    this._fillColor.assign(t);
  }
  /**
   * Gets the fill color for this shape
   * @returns the fill color
   */
  getFillColor() {
    return this._fillColor.copy();
  }
}
var ii = /* @__PURE__ */ ((n) => (n[n.None = 0] = "None", n[n.Arrowhead = 1] = "Arrowhead", n[n.Circle = 2] = "Circle", n))(ii || {});
const gu = 9;
class Ma extends kh {
  constructor() {
    super(...arguments), this._startEndcapType = 0, this._startEndcapColor = it.black(), this._startEndcapSize = gu, this._endEndcapType = 0, this._endEndcapColor = it.black(), this._endEndcapSize = gu, this._endcapsInverted = !1;
  }
  /** @hidden */
  _assign(t) {
    super._assign(t), this._startEndcapType = t._startEndcapType, this._startEndcapColor.assign(t._startEndcapColor), this._startEndcapSize = t._startEndcapSize, this._endEndcapType = t._endEndcapType, this._endEndcapColor.assign(t._endEndcapColor), this._endEndcapSize = t._endEndcapSize, this._endcapsInverted = t._endcapsInverted;
  }
  /**
   * Gets the start endcap type for this shape. The default Value is none.
   * @returns the start endcap type
   */
  getStartEndcapType() {
    return this._startEndcapType;
  }
  /**
   * Sets the start endcap type for this shape
   * @param endcapType the new endcap type
   */
  setStartEndcapType(t) {
    this._startEndcapType = t;
  }
  /**
   * Gets the color of the start endcap. Default value is black.
   * @returns color for the start endcap.
   */
  getStartEndcapColor() {
    return this._startEndcapColor.copy();
  }
  /**
   * Sets the color for the start endcap.
   * @param color the start endcap color value.
   */
  setStartEndcapColor(t) {
    this._startEndcapColor.assign(t);
  }
  /**
   * Gets the size of the start endcap in pixels. Default value is 9.
   * @returns size of the start endcap.
   */
  getStartEndcapSize() {
    return this._startEndcapSize;
  }
  /**
   * Sets the size of the start endcap in pixels.
   * @param size the start endcap.
   */
  setStartEndcapSize(t) {
    this._startEndcapSize = t;
  }
  /**
   * Gets the end endcap type for this shape. The default value is none.
   * @returns the end endcap type
   */
  getEndEndcapType() {
    return this._endEndcapType;
  }
  /**
   * Sets the end endcap type for this shape
   * @param endcapType the new endcap type
   */
  setEndEndcapType(t) {
    this._endEndcapType = t;
  }
  /**
   * Convenience for setting the start and eend endcap type for this shape
   * @param endcapType the new endcap type
   */
  setEndcapType(t) {
    this._startEndcapType = t, this._endEndcapType = t;
  }
  /**
   * Gets the size of the end endcap in pixels. Default value is 9.
   * @returns size of the end endcap.
   */
  getEndEndcapSize() {
    return this._endEndcapSize;
  }
  /**
   * Sets the size of the end endcap in pixels.
   * @param size the end endcap.
   */
  setEndEndcapSize(t) {
    this._endEndcapSize = t;
  }
  /**
   * Gets the color of the end endcap. Default value is black.
   * @returns color for the end endcap.
   */
  getEndEndcapColor() {
    return this._endEndcapColor.copy();
  }
  /**
   * Sets the color for the end endcap.
   * @param color the end endcap color value.
   */
  setEndEndcapColor(t) {
    this._endEndcapColor.assign(t);
  }
  /**
   * Gets whether endcaps are inverted for this shape. The default value is false.
   * @returns value indicating whether endcaps are inverted
   */
  getEndcapsInverted() {
    return this._endcapsInverted;
  }
  /**
   * Sets whether endcapsare inverted for this shape.
   * @param inverted value indicated whether endcaps should be inverted
   */
  setEndcapsInverted(t) {
    this._endcapsInverted = t;
  }
}
class qn extends yr {
  constructor() {
    super(...arguments), this._center = E.zero(), this._radius = 1;
  }
  /**
   * Sets the values for the circle
   * @param center the center point of the circle.
   * @radius the circle radius.
   */
  set(t, e) {
    this._center.assign(t), this.setRadius(e);
  }
  /**
   * Gets the center of the circle
   * @returns the circle center
   */
  getCenter() {
    return this._center.copy();
  }
  /**
   * Sets the center of the circle
   * @param the circle center
   */
  setCenter(t) {
    this._center.assign(t);
  }
  /**
   * Gets the radius of the circle
   * @returns the circle radius
   */
  getRadius() {
    return this._radius;
  }
  /**
   * Sets the radius of the circle
   * @param radius the circle radius
   */
  setRadius(t) {
    this._radius = t;
  }
}
class hm {
  constructor(t, e) {
    this.center = t.copy(), this.radius = e;
  }
}
class Mh extends yr {
  constructor() {
    super(...arguments), this._circles = [];
  }
  /**
   * Removes all circles from this collection
   */
  clear() {
    this._circles = [];
  }
  /**
   * Adds a circle to the collection
   * @param center circle center
   * @param radius the circle radius
   */
  addCircle(t, e) {
    this._circles.push(new hm(t, e));
  }
  /**
   * Updates a circle in the collection
   * @param index the index of the circle to update
   * @param center circle center
   * @param radius the circle radius
   */
  setCircle(t, e, i) {
    const s = this._circles[t];
    s.center.assign(e), s.radius = i;
  }
  /**
   * Gets the circles in the collection
   */
  getCircles() {
    return this._circles;
  }
}
const rl = class extends to {
  constructor(n) {
    super(n), this._uniqueId = Qi(), this._centerPt = d.zero(), this._radiusPt = d.zero(), this._circleShape = new qn(), this._previousDragPlanePosition = d.zero(), this._circleShape.setFillOpacity(0), this._circleShape.setStrokeColor(it.red()), this._circleShape.setStrokeWidth(2);
  }
  setCenter(n) {
    this._centerPt.assign(n);
  }
  getCenter() {
    return this._centerPt.copy();
  }
  setRadiusPoint(n) {
    this._radiusPt.assign(n);
  }
  getRadiusPoint() {
    return this._radiusPt.copy();
  }
  getUniqueId() {
    return this._uniqueId;
  }
  _update() {
    const n = this._viewer.view, t = E.fromPoint3(n.projectPoint(this._centerPt)), e = E.fromPoint3(n.projectPoint(this._radiusPt)), i = E.distance(t, e);
    this._circleShape.set(t, i);
  }
  draw() {
    this._update(), this._viewer.markupManager.getRenderer().drawCircle(this._circleShape);
  }
  hit(n) {
    return this.hitWithTolerance(n, 0);
  }
  hitWithTolerance(n, t) {
    this._update();
    const e = this._circleShape.getStrokeWidth() + t, i = E.distance(this._circleShape.getCenter(), n) - this._circleShape.getRadius();
    return Math.abs(i) <= e;
  }
  onSelect() {
    this._circleShape.setStrokeWidth(4);
  }
  onDeselect() {
    this._circleShape.setStrokeWidth(2);
  }
  isValid() {
    return this._circleShape.getRadius() > rl._validRadiusTolerance;
  }
  // dragging methods
  onDragStart(n) {
    const t = this._viewer.view, e = t.getCamera().getCameraPlaneIntersectionPoint(n, t);
    return e !== null && this._previousDragPlanePosition.assign(e), !1;
  }
  onDragMove(n) {
    const t = this._viewer.view, e = t.getCamera().getCameraPlaneIntersectionPoint(n, t);
    if (e !== null) {
      const i = d.subtract(e, this._previousDragPlanePosition);
      this._centerPt.add(i), this._radiusPt.add(i), this._previousDragPlanePosition.assign(e);
    }
    return !0;
  }
  // Serialization methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      uniqueId: this._uniqueId,
      centerPoint: this._centerPt.toJson(),
      radiusPoint: this._radiusPt.toJson(),
      className: this.getClassName()
    };
  }
  /**
   * Creates a new [[RedlineCircle]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(n, t) {
    const e = n, i = new rl(t);
    return i._uniqueId = e.uniqueId, i.setCenter(d.fromJson(e.centerPoint)), i.setRadiusPoint(d.fromJson(e.radiusPoint)), i;
  }
  getClassName() {
    return rl.className;
  }
};
let gr = rl;
gr.className = "Communicator.Markup.Redline.RedlineCircle";
gr._validRadiusTolerance = 1;
Ui(gr.className, gr.fromJson);
class br extends Ma {
  constructor() {
    super(...arguments), this._points = [];
  }
  /**
   * Removes all points from this polyline
   */
  clearPoints() {
    this._points = [];
  }
  /**
   * Gets the points in this polyline
   * @returns the points in this polyline
   */
  getPoints() {
    return this._points;
  }
  /**
   * Adds a point to the polyline
   * @param point the point to add to the line
   */
  pushPoint(t) {
    this._points.push(t.copy());
  }
}
class L_ extends Ma {
  constructor() {
    super(...arguments), this._polylines = [];
  }
  /**
   * Removes all polylines from the collection
   */
  clear() {
    this._polylines = [];
  }
  /**
   * Creates a new array of points that represent a polyline. Add Point2 objects to the array to construct the polyline
   * @returns new array which represents a polyline.
   */
  createPolyline() {
    const t = [];
    return this._polylines.push(t), t;
  }
  /**
   * @returns the polylines in this collection
   */
  getPolylines() {
    return this._polylines;
  }
}
const Ec = class extends to {
  constructor(n) {
    super(n), this._uniqueId = Qi(), this._points = [], this._polylineShape = new br(), this._previousDragPlanePosition = d.zero(), this._polylineShape.setStrokeWidth(2), this._polylineShape.setStrokeColor(it.red());
  }
  addPoint(n) {
    this._points.push(n.copy());
  }
  getPoints() {
    const n = [];
    return this._points.forEach((t) => {
      n.push(t.copy());
    }), n;
  }
  _update() {
    const n = this._viewer.view;
    this._polylineShape.clearPoints();
    for (const t of this._points) {
      const e = E.fromPoint3(n.projectPoint(t));
      this._polylineShape.pushPoint(e);
    }
  }
  draw() {
    this._update(), this.isValid() && this._viewer.markupManager.getRenderer().drawPolyline(this._polylineShape);
  }
  hit(n) {
    return this.hitWithTolerance(n, 0);
  }
  hitWithTolerance(n, t) {
    this._update();
    const e = this._polylineShape.getStrokeWidth() + t, i = this._polylineShape.getPoints();
    if (i.length > 1) {
      for (let s = 1; s < i.length; s++)
        if (co(n, i[s - 1], i[s], e))
          return !0;
    }
    return !1;
  }
  onSelect() {
    this._polylineShape.setStrokeWidth(4);
  }
  onDeselect() {
    this._polylineShape.setStrokeWidth(2);
  }
  getClassName() {
    return Ec.className;
  }
  isValid() {
    return this._points.length > 1;
  }
  // dragging methods
  onDragStart(n) {
    const t = this._viewer.view, e = t.getCamera().getCameraPlaneIntersectionPoint(n, t);
    return e !== null && this._previousDragPlanePosition.assign(e), !1;
  }
  onDragMove(n) {
    const t = this._viewer.view, e = t.getCamera().getCameraPlaneIntersectionPoint(n, t);
    if (e !== null) {
      const i = d.subtract(e, this._previousDragPlanePosition);
      for (const s of this._points)
        s.add(i);
      this._polylineShape.clearPoints(), this._previousDragPlanePosition.assign(e);
    }
    return !0;
  }
  // Serialization methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    const n = [];
    for (const t of this._points)
      n.push(t.toJson());
    return {
      uniqueId: this._uniqueId,
      points: n
    };
  }
  /**
   * Creates a new [[RedlinePolyline]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(n, t) {
    const e = n, i = new Ec(t);
    i._uniqueId = e.uniqueId;
    for (const s of e.points)
      i.addPoint(d.fromJson(s));
    return i;
  }
};
let Ar = Ec;
Ar.className = "Communicator.Markup.Redline.RedlinePolyline";
Ui(Ar.className, Ar.fromJson);
class Kl extends yr {
  constructor() {
    super(...arguments), this._borderRadius = 0;
  }
  /** @hidden */
  _assign(t) {
    super._assign(t), this._borderRadius = t._borderRadius;
  }
  /**
   * Gets the border radius for this shape
   * @returns the border radius
   */
  getBorderRadius() {
    return this._borderRadius;
  }
  /**
   * Sets the border radius for this shape
   * @param borderRadius the border radius in pixels
   */
  setBorderRadius(t) {
    this._borderRadius = t;
  }
}
class Ol extends Kl {
  /**
   * Creates a new rectangle markup item
   * @param position the screen space position of the top left of the rectangle.
   * @param size the point object representing the width and height of the rectangle in pixels.
   */
  constructor(t, e) {
    super(), this._position = E.zero(), this._size = E.zero(), t && this._position.assign(t), e && this._size.assign(e);
  }
  /** @hidden */
  _assign(t) {
    super._assign(t), this._position.assign(t._position), this._size.assign(t._size);
  }
  /**
   * Sets the rectanlge position
   * @param position the top left corner of the rectangle
   */
  setPosition(t) {
    this._position.assign(t);
  }
  /**
   * Gets rectangle position
   * @returns the rectangle position
   */
  getPosition() {
    return this._position.copy();
  }
  /**
   * Sets the rectanlge size
   * @param size indicating the rectangle width and height
   */
  setSize(t) {
    this._size.assign(t);
  }
  /**
   * Gets rectangle size
   * @returns the rectangle size
   */
  getSize() {
    return this._size.copy();
  }
}
class um {
  constructor(t, e) {
    this.position = t.copy(), this.size = e.copy();
  }
}
class X_ extends Kl {
  constructor() {
    super(...arguments), this._rectangles = [];
  }
  /**
   * Removes all rectangles from this collection
   */
  clear() {
    this._rectangles = [];
  }
  /**
   * Adds a rectangle to the collection
   * @param position the top left corner of the rectangle
   * @param size indicating the rectangle width and height
   */
  addRectangle(t, e) {
    this._rectangles.push(new um(t, e));
  }
  /**
   * Gets the rectangles in the collection
   */
  getRectangles() {
    return this._rectangles;
  }
}
const Io = class extends to {
  constructor(n) {
    super(n), this._uniqueId = Qi(), this._point1 = d.zero(), this._point2 = d.zero(), this._rectangleShape = new Ol(), this._previousDragPlanePosition = d.zero(), this._rectangleShape.setFillOpacity(0), this._rectangleShape.setStrokeColor(it.red()), this._rectangleShape.setStrokeWidth(2);
  }
  setPoint1(n) {
    this._point1.assign(n);
  }
  getPoint1() {
    return this._point1.copy();
  }
  setPoint2(n) {
    this._point2.assign(n);
  }
  getPoint2() {
    return this._point2.copy();
  }
  getUniqueId() {
    return this._uniqueId;
  }
  _update() {
    const n = this._viewer.view, t = n.projectPoint(this._point1), e = n.projectPoint(this._point2), i = new E(
      Math.min(t.x, e.x),
      Math.min(t.y, e.y)
    ), s = new E(
      Math.max(t.x, e.x),
      Math.max(t.y, e.y)
    ), r = E.subtract(s, i);
    this._rectangleShape.setPosition(i), this._rectangleShape.setSize(r);
  }
  draw() {
    this._update(), this._viewer.markupManager.getRenderer().drawRectangle(this._rectangleShape);
  }
  hit(n) {
    return this.hitWithTolerance(n, 0);
  }
  hitWithTolerance(n, t) {
    this._update();
    const e = this._rectangleShape.getStrokeWidth() + t, i = this._rectangleShape.getPosition(), s = this._rectangleShape.getSize(), r = i, o = new E(i.x + s.x, r.y), a = new E(i.x, i.y + s.y), l = new E(i.x + s.x, i.y + s.y);
    return co(n, r, o, e) || co(n, o, l, e) || co(n, l, a, e) ? !0 : !!co(n, a, r, e);
  }
  onSelect() {
    this._rectangleShape.setStrokeWidth(4);
  }
  onDeselect() {
    this._rectangleShape.setStrokeWidth(2);
  }
  isValid() {
    const n = this._rectangleShape.getSize();
    return n.x > Io._validSizeTolerance.x && n.y > Io._validSizeTolerance.y;
  }
  // dragging methods
  onDragStart(n) {
    const t = this._viewer.view, e = t.getCamera().getCameraPlaneIntersectionPoint(n, t);
    return e !== null && this._previousDragPlanePosition.assign(e), !1;
  }
  onDragMove(n) {
    const t = this._viewer.view, e = t.getCamera().getCameraPlaneIntersectionPoint(n, t);
    if (e !== null) {
      const i = d.subtract(e, this._previousDragPlanePosition);
      this._point1.add(i), this._point2.add(i), this._previousDragPlanePosition.assign(e);
    }
    return !0;
  }
  // serialization methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      uniqueId: this._uniqueId,
      className: this.getClassName(),
      point1: this._point1.toJson(),
      point2: this._point2.toJson()
    };
  }
  /**
   * Creates a new [[RedlineRectangle]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(n, t) {
    const e = n, i = new Io(t);
    return i._uniqueId = e.uniqueId, i.setPoint1(d.fromJson(e.point1)), i.setPoint2(d.fromJson(e.point2)), i;
  }
  getClassName() {
    return Io.className;
  }
};
let fr = Io;
fr.className = "Communicator.Markup.Redline.RedlineRectangle";
fr._validSizeTolerance = new E(5, 5);
Ui(fr.className, fr.fromJson);
const ol = class {
  constructor(n, t) {
    this._sizeChanged = !1, this._sizeUpdateCallback = n, this._textUpdateCallback = t, this._createTextBox();
  }
  _createTextBox() {
    this._currentSize = ol._defaultSize.copy(), this._textArea = document.createElement("textarea"), this._textArea.style.position = "absolute", this._textArea.style.width = `${ol._defaultSize.x}px`, this._textArea.style.height = `${ol._defaultSize.y}px`, this._textArea.style.zIndex = "1", this._textArea.style.pointerEvents = "none", this._textArea.style.resize = "none", this._textArea.style.letterSpacing = "1px", this.setBorderWidth(2), this._textArea.onmousemove = (t) => {
      t.stopPropagation();
      const e = new E(
        parseInt(this._textArea.style.width, 10),
        parseInt(this._textArea.style.height, 10)
      );
      this.setSize(e);
    }, this._textArea.onmouseup = (t) => {
      t.stopPropagation(), this._sizeChanged && (this._sizeChanged = !1, this._sizeUpdateCallback(this._currentSize));
    };
    const n = () => {
      this._textUpdateCallback(this._textArea.value);
    };
    this._textArea.oninput = n;
  }
  setPosition(n) {
    this._textArea.style.left = `${n.x}px`, this._textArea.style.top = `${n.y}px`;
  }
  setBorderWidth(n) {
    this._textArea.style.outline = `${n}px solid red`;
  }
  setText(n) {
    this._textArea.textContent = n;
  }
  setSize(n) {
    this._currentSize.equals(n) || (this._sizeChanged = !0, this._currentSize.assign(n), this._textArea.style.width = `${n.x}px`, this._textArea.style.height = `${n.y}px`);
  }
  focus() {
    this._textArea.focus(), this._textArea.style.pointerEvents = "auto", this._textArea.style.resize = "both";
  }
  blur() {
    this._textArea.blur(), this._textArea.style.pointerEvents = "none", this._textArea.style.resize = "none";
  }
  getTextArea() {
    return this._textArea;
  }
};
let Wh = ol;
Wh._defaultSize = new E(100, 100);
const al = class extends to {
  constructor(n, t = al.defaultText) {
    super(n), this._uniqueId = Qi(), this._position = d.zero(), this._size = new E(100, 100), this._redlineElementId = null, this._previousDragPlanePosition = d.zero(), this._text = t;
    const e = (s) => {
      this.setSize(s);
    }, i = (s) => {
      this.setText(s);
    };
    this._redlineTextElement = new Wh(e, i), this._redlineTextElement.setText(this._text), this._callbacks = {
      selectionArray: () => {
        this.onDeselect();
      }
    }, this._viewer.setCallbacks(this._callbacks);
  }
  setPosition(n) {
    this._position.assign(n);
  }
  getPosition() {
    return this._position.copy();
  }
  setSize(n) {
    this._size.assign(n), this._redlineTextElement.setSize(n), this._viewer.trigger("redlineUpdated", this);
  }
  getSize() {
    return this._size.copy();
  }
  setText(n) {
    this._text = n, this._redlineTextElement.setText(n), this._viewer.trigger("redlineUpdated", this);
  }
  getText() {
    return this._text;
  }
  draw() {
    const n = E.fromPoint3(this._viewer.view.projectPoint(this._position));
    this._redlineTextElement.setPosition(n), this._redlineElementId === null && (this._redlineElementId = this._viewer.markupManager.addMarkupElement(
      this._redlineTextElement.getTextArea()
    ));
  }
  hit(n) {
    return this.hitWithTolerance(n, 0);
  }
  hitWithTolerance(n, t) {
    const e = this._redlineTextElement.getTextArea(), i = new E(
      parseFloat(e.style.left || "0"),
      parseFloat(e.style.top || "0")
    ), s = new E(
      parseFloat(e.style.width || "0"),
      parseFloat(e.style.height || "0")
    );
    return Uu(n, i, s, t);
  }
  getClassName() {
    return al.className;
  }
  onSelect() {
    this._redlineTextElement.setBorderWidth(4), this._redlineTextElement.focus();
  }
  onDeselect() {
    this._redlineTextElement.setBorderWidth(2), this._redlineTextElement.blur();
  }
  isValid() {
    return this._text.length > 0;
  }
  remove() {
    this._redlineElementId && (this._viewer.markupManager.removeMarkupElement(this._redlineElementId), this._redlineElementId = null), this._callbacks !== null && (this._viewer.unsetCallbacks(this._callbacks), this._callbacks = null), super.remove();
  }
  // drag methods and drop methods
  onDragStart(n) {
    const t = this._viewer.view, e = t.getCamera().getCameraPlaneIntersectionPoint(n, t);
    return e !== null && this._previousDragPlanePosition.assign(e), !1;
  }
  onDragMove(n) {
    const t = this._viewer.view, e = t.getCamera().getCameraPlaneIntersectionPoint(n, t);
    if (e !== null) {
      const i = d.subtract(e, this._previousDragPlanePosition), s = this.getPosition();
      s.add(i), this.setPosition(s), this._previousDragPlanePosition.assign(e);
    }
    return !0;
  }
  // Serialization methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      uniqueId: this._uniqueId,
      className: this.getClassName(),
      position: this._position.toJson(),
      size: this._size.toJson(),
      text: this._text
    };
  }
  /**
   * Creates a new [[RedlineText]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(n, t) {
    const e = n, i = new al(t, e.text);
    return i._uniqueId = e.uniqueId, i.setPosition(d.fromJson(e.position)), i.setSize(E.fromJson(e.size)), i;
  }
};
let Ls = al;
Ls.className = "Communicator.Markup.Redline.RedlineText";
Ls.defaultText = "Type Here...";
Ui(Ls.className, Ls.fromJson);
const F_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  RedlineCircle: gr,
  RedlinePolyline: Ar,
  RedlineRectangle: fr,
  RedlineText: Ls,
  RedlineTextElement: Wh
}, Symbol.toStringTag, { value: "Module" })), Rc = class extends _s {
  constructor(n, t = null, e = null, i = null, s = null) {
    super(), this._uniqueId = Qi(), this._lineMeshId = null, this._lineMeshInstanceId = null, this._lineColor = it.red(), this._lineOpacity = 1, this._linePattern = null, this._linePatternLength = null, this._linePatternLengthUnit = null, this._viewer = n, this._firstPoint = t, this._secondPoint = e, this._firstNodeId = i, this._secondNodeId = s;
  }
  /**
   * Sets the line color.
   * @param color
   */
  setLineColor(n) {
    this._lineColor = n;
  }
  /**
   * Gets the line color.
   */
  getLineColor() {
    return this._lineColor;
  }
  /**
   * Sets the line opacity.
   * @param opacity
   */
  setLineOpacity(n) {
    this._lineOpacity = n;
  }
  /**
   * Gets the line opacity.
   */
  getLineOpacity() {
    return this._lineOpacity;
  }
  /**
   * Sets the line pattern.
   * @param pattern The line pattern.
   * @param patternLength The length of a single repetition of the line pattern.
   * @param patternLengthUnit The unit in which the pattern length is measured.
   */
  setLinePattern(n, t, e) {
    this._linePattern = n, this._linePatternLength = t, this._linePatternLengthUnit = e;
  }
  /**
   * Gets the line pattern.
   */
  getLinePattern() {
    return this._linePattern !== void 0 ? this._linePattern : null;
  }
  /**
   * Gets the length of a single repetition of the line pattern.
   */
  getLinePatternLength() {
    return this._linePatternLength !== void 0 ? this._linePatternLength : null;
  }
  /**
   * Gets the unit in which the line pattern length is measured.
   */
  getLinePatternLengthUnit() {
    return this._linePatternLengthUnit !== void 0 ? this._linePatternLengthUnit : null;
  }
  /**
   * Sets the first point on the line.
   * @param firstPoint
   */
  setFirstPoint(n) {
    this._firstPoint = n;
  }
  /**
   * Gets the first point on the line.
   * @returns the first point, or null if none is set.
   */
  getFirstPoint() {
    return this._firstPoint;
  }
  /**
   * Sets the second point on the line.
   * @param secondPoint
   */
  setSecondPoint(n) {
    this._secondPoint = n;
  }
  /**
   * Gets the second point on the line.
   * @returns the second point, or null if none is set.
   */
  getSecondPoint() {
    return this._secondPoint;
  }
  /**
   * Sets the NodeId of the part associated with the first line point
   * @param nodeId
   */
  setFirstNodeId(n) {
    this._firstNodeId = n;
  }
  /**
   * Gets the NodeId of the part associated with the first line point
   */
  getFirstNodeId() {
    return this._firstNodeId;
  }
  /**
   * Sets the NodeId of the part associated with the second line point
   * @param nodeId
   */
  setSecondNodeId(n) {
    this._secondNodeId = n;
  }
  /**
   * Gets the NodeId of the part associated with the second line point
   */
  getSecondNodeId() {
    return this._secondNodeId;
  }
  /**
   * Gets the node id associated with the line markup.
   */
  getNodeId() {
    return this._lineMeshInstanceId;
  }
  /**
   * Removes the line geometry from the scene.
   */
  async removeLine() {
    const n = this._viewer.model;
    this._lineMeshInstanceId !== null && (await n.deleteMeshInstances([this._lineMeshInstanceId]), this._lineMeshInstanceId = null, this._lineMeshId !== null && (await n.deleteMeshes([this._lineMeshId]), this._lineMeshId = null));
  }
  /**
   * Draws updated line geometry in the scene.
   */
  async updateLine() {
    if (await this.removeLine(), this._firstPoint !== null && this._secondPoint !== null) {
      const n = new Hi();
      n.addPolyline([
        this._firstPoint.x,
        this._firstPoint.y,
        this._firstPoint.z,
        this._secondPoint.x,
        this._secondPoint.y,
        this._secondPoint.z
      ]);
      const t = this._viewer.model, e = await t.createMesh(n);
      this._lineMeshId = e;
      const i = new bn(e);
      i.setLineColor(this._lineColor), i.setLineOpacity(this._lineOpacity), i.setCreationFlags(St.ExcludeBounding);
      const s = await t.createMeshInstance(i);
      this._linePattern !== null && t.setNodesLinePattern(
        [s],
        this._linePattern,
        this._linePatternLength,
        this._linePatternLengthUnit
      ), this._lineMeshInstanceId = s;
    }
  }
  /**
   * Returns a unique markup id for this line.
   */
  getId() {
    return this._uniqueId;
  }
  /**
   * Sets a markup id for this line.
   * @param id
   */
  setId(n) {
    this._uniqueId = n;
  }
  /**
   * Returns the class name for this markup item.
   */
  getClassName() {
    return Rc.className;
  }
  _toJson() {
    return {
      className: this.getClassName(),
      uniqueId: this._uniqueId,
      firstPoint: this.getFirstPoint(),
      secondPoint: this.getSecondPoint(),
      firstNodeId: this.getFirstNodeId(),
      secondNodeId: this.getSecondNodeId(),
      lineColor: this.getLineColor(),
      lineOpacity: this.getLineOpacity(),
      linePattern: this.getLinePattern(),
      linePatternLength: this.getLinePatternLength(),
      linePatternLengthUnit: this.getLinePatternLengthUnit()
    };
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  /**
   * Creates a new [[LineMarkup]] from an object given by [[toJson]].
   * @param An object given by [[toJson]].
   * @returns The prepared object.
   */
  static async fromJson(n, t) {
    const e = n, i = new Rc(
      t,
      d.fromJson(e.firstPoint),
      d.fromJson(e.secondPoint),
      e.firstNodeId,
      e.secondNodeId
    );
    return i.setId(e.uniqueId), i.setLineColor(it.fromJson(e.lineColor)), i.setLineOpacity(e.lineOpacity), e.linePattern != null && e.linePatternLength != null && e.linePatternLengthUnit != null && i.setLinePattern(e.linePattern, e.linePatternLength, e.linePatternLengthUnit), i;
  }
};
let Dr = Rc;
Dr.className = "Communicator.Markup.Line.LineMarkup";
Ui(Dr.className, Dr.fromJson);
const K_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  LineMarkup: Dr
}, Symbol.toStringTag, { value: "Module" }));
class zr {
  constructor(t, e, i, s, r, o) {
    this._version = pn.Unknown, this._components = {}, this._lines = [], this._clippingPlanes = [], this._viewer = o, this._filename = t, this._version = i, this._modelBounding = s, this._unitScale = 1e3 / r, this._parseDocument(e);
  }
  static async createViewpoint(t, e, i = null) {
    const s = (Y) => {
      const P = [];
      return Y.forEach((L) => {
        let R = null;
        for (; L !== null && R === null; )
          R = r.getNodeGenericId(L), L = r.getNodeParent(L);
        P.push(R);
      }), console.assert(Y.length === P.length), P;
    }, r = t.model, o = r.getAbsoluteRootNode(), a = await r.getVisibilityState(o), l = await r.getNodeColorMap(o, Je.Faces), c = await r.getModelBounding(!0, !1), h = r.getNodeUnitMultiplier(o), u = new zr(
      e,
      null,
      pn.v2_1,
      c,
      h,
      t
    ), p = a.defaultVisibility;
    u.setDefaultVisibility(p);
    const m = a.visibilityExceptions, g = [];
    m.forEach((Y) => {
      g.push(Y);
    });
    const _ = [], y = s(g);
    for (let Y = 0; Y < y.length; Y++) {
      const P = y[Y];
      let L;
      P !== null ? L = r.getNodeIdsByGenericIds([P]) : L = [g[Y]];
      for (const R of L) {
        const D = await r.getVisibilityState(R), J = { genericId: P, nodeId: R };
        p ? D.visibilityExceptions.size === 0 && _.push(J) : (D.visibilityExceptions.size !== 0 || D.defaultVisibility) && _.push(J);
      }
    }
    u.setVisibilityExceptionNodes(_);
    const w = t.selectionManager.getResults().map((Y) => Y.getNodeId()), v = s(w), C = [];
    for (let Y = 0; Y < w.length; Y++) {
      const P = {
        genericId: v[Y],
        nodeId: w[Y]
      };
      C.push(P);
    }
    u.setSelectionNodes(C);
    const k = /* @__PURE__ */ new Map();
    if (l.size > 0 && l.forEach((Y, P) => {
      const L = r.getNodeParent(P);
      if (L === null)
        return;
      const R = r.getNodeGenericId(L);
      let D = k.get(Y);
      D === void 0 && (D = /* @__PURE__ */ new Set(), k.set(Y, D)), D.add({ genericId: R, nodeId: P });
    }), u.setColorNodes(k), u.setCamera(t.view.getCamera()), i !== null) {
      const Y = zr._markupRedlineToBcf(i.getMarkup(), t.view);
      u.setLines(Y);
    }
    return u;
  }
  static _markupRedlineToBcf(t, e) {
    const r = (h) => {
      const u = e.projectPoint(h);
      return e.unprojectPoint(E.fromPoint3(u), 0);
    }, o = (h, u, p) => {
      const m = Math.PI * 2 / p, g = [];
      for (let _ = 0; _ <= p; _++) {
        const y = _ * m;
        g.push(
          new E(h.x + Math.cos(y) * u, h.y + Math.sin(y) * u)
        );
      }
      return g;
    }, a = (h) => {
      for (let u = 0; u < h.length - 1; ++u) {
        const p = h[u], m = h[u + 1];
        if (p !== null && m !== null) {
          const g = [p.copy().scale(1e-3), m.copy().scale(1e-3)];
          c.push(g);
        }
      }
    }, l = (h) => {
      for (let u = 0; u < h.length; ++u) {
        const p = h[u], m = h[(u + 1) % h.length];
        if (p !== null && m !== null) {
          const g = [p.copy().scale(1e-3), m.copy().scale(1e-3)];
          c.push(g);
        }
      }
    }, c = [];
    return t.forEach((h) => {
      if (h instanceof Ar) {
        const p = h.getPoints().map(r);
        a(p);
      } else if (h instanceof gr) {
        const u = h.getCenter(), p = h.getRadiusPoint(), m = E.fromPoint3(e.projectPoint(u)), g = E.fromPoint3(e.projectPoint(p)), _ = E.subtract(g, m).length(), b = o(m, _, 40).map((w) => e.unprojectPoint(w, 0));
        l(b);
      } else if (h instanceof fr) {
        const u = h.getPoint1(), p = h.getPoint2(), m = E.fromPoint3(e.projectPoint(u)), g = E.fromPoint3(e.projectPoint(p)), _ = [];
        _.push(e.unprojectPoint(m, 0)), _.push(
          e.unprojectPoint(new E(m.x, g.y), 0)
        ), _.push(e.unprojectPoint(g, 0)), _.push(
          e.unprojectPoint(new E(g.x, m.y), 0)
        ), l(_);
      }
    }), c;
  }
  _parseDocument(t) {
    if (t === null)
      return;
    const e = t.documentElement, i = e.attributes.getNamedItem("Guid");
    i !== null && (this._viewpointGuid = i.value);
    let s = e.firstElementChild;
    for (; s !== null; ) {
      const r = s.localName;
      if (r === null)
        break;
      switch (r) {
        case "Components":
          this._version >= pn.v2_1 ? this._parseComponents(s) : this._parseComponentsV2_0(s);
          break;
        case "OrthogonalCamera":
          this._parseOrthogonalCamera(s);
          break;
        case "PerspectiveCamera":
          this._parsePerspectiveCamera(s);
          break;
        case "Lines":
          this._parseLines(s);
          break;
        case "ClippingPlanes":
          this._parseClippingPlanes(s);
          break;
      }
      s = s.nextElementSibling;
    }
  }
  _exportComponents(t) {
    const e = t.createElement("Components"), i = t.createElement("ViewSetupHints"), s = this._components.viewSetupHints;
    s && (e.setAttribute("SpacesVisible", yo(s.spacesVisible)), e.setAttribute(
      "SpaceBoundariesVisible",
      yo(s.spaceBoundariesVisible)
    ), e.setAttribute("OpeningsVisible", yo(s.openingsVisible))), e.appendChild(i);
    const r = t.createElement("Selection"), o = this._components.selection;
    o && o.forEach((p) => {
      r.appendChild(il(t, p));
    }), e.appendChild(r);
    const a = t.createElement("Visibility"), l = this._components.defaultVisibility, c = this._components.visibilityExceptions;
    if (l !== void 0 && c !== void 0) {
      a.setAttribute("DefaultVisibility", yo(l));
      const p = t.createElement("Exceptions");
      c.forEach((m) => {
        p.appendChild(il(t, m));
      }), a.appendChild(p);
    }
    e.appendChild(a);
    const h = t.createElement("Coloring"), u = this._components.coloring;
    return u && u.forEach((p) => {
      const m = t.createElement("Color");
      m.setAttribute("Color", sm(p.color, p.alpha)), p.components.forEach((g) => {
        m.appendChild(il(t, g));
      }), h.appendChild(m);
    }), e.appendChild(h), e;
  }
  _exportOrthogonalCamera(t, e) {
    const i = t.createElement("OrthogonalCamera"), s = t.createElement("CameraViewPoint"), r = t.createElement("CameraDirection"), o = t.createElement("CameraUpVector");
    Zn(t, s, e.cameraViewPoint), Zn(t, r, e.cameraDirection), Zn(t, o, e.cameraUpVector);
    const a = t.createElement("ViewToWorldScale");
    return a.innerHTML = e.viewToWorldScale.toString(), i.appendChild(s), i.appendChild(r), i.appendChild(o), i.appendChild(a), i;
  }
  _exportPerspectiveCamera(t, e) {
    const i = t.createElement("PerspectiveCamera"), s = t.createElement("CameraViewPoint"), r = t.createElement("CameraDirection"), o = t.createElement("CameraUpVector");
    Zn(t, s, e.cameraViewPoint), Zn(t, r, e.cameraDirection), Zn(t, o, e.cameraUpVector);
    const a = t.createElement("FieldOfView");
    return a.innerHTML = e.fieldOfView.toString(), i.appendChild(s), i.appendChild(r), i.appendChild(o), i.appendChild(a), i;
  }
  _exportLines(t) {
    const e = t.createElement("Lines");
    return this._lines.forEach((i) => {
      const s = t.createElement("Line"), r = t.createElement("StartPoint"), o = t.createElement("EndPoint");
      Zn(t, r, i.startPoint), Zn(t, o, i.endPoint), s.appendChild(r), s.appendChild(o), e.appendChild(s);
    }), e;
  }
  _exportClippingPlanes(t) {
    const e = t.createElement("ClippingPlanes");
    return this._clippingPlanes.forEach((i) => {
      const s = t.createElement("ClippingPlane"), r = t.createElement("Location"), o = t.createElement("Direction");
      Zn(t, r, i.location), Zn(t, o, i.direction), s.appendChild(r), s.appendChild(o), e.appendChild(s);
    }), e;
  }
  /**
   * @returns XML document containing the viewpoint data.
   */
  export() {
    const t = document.implementation.createDocument("", "", null), e = t.createElement("VisualizationInfo");
    return e.appendChild(this._exportComponents(t)), this._viewpointGuid !== void 0 && e.setAttribute("Guid", this._viewpointGuid), this._orthogonalCamera ? e.appendChild(this._exportOrthogonalCamera(t, this._orthogonalCamera)) : this._perspectiveCamera && e.appendChild(this._exportPerspectiveCamera(t, this._perspectiveCamera)), this._lines.length > 0 && e.appendChild(this._exportLines(t)), this._clippingPlanes.length > 0 && e.appendChild(this._exportClippingPlanes(t)), t.appendChild(e), t;
  }
  /**
   * Activates viewpoint.
   * Sets the camera, visibility, cutting planes, colors, and markup.
   */
  async activate() {
    await this._activateCamera(), await this._activateComponentsVisibility(), await this._activateMarkup(), await this._activateCuttingPlanes(), this._activateSelected(), await this._activateColors();
  }
  async _activateCamera() {
    const t = this.getCamera();
    t !== null && await this._viewer.view._setCameraPromise(t, 800);
  }
  async _activateComponentsVisibility() {
    const t = this._viewer.model, e = this._getDefaultVisibility(), i = this.getVisibilityExceptionNodes();
    i.length ? (await t.setNodesVisibility([-2], e), await t.setNodesVisibility(i, !e)) : await t.reset();
  }
  async _activateMarkup() {
    const t = this._viewer.lineManager;
    await t.removeAllLines();
    const e = [];
    for (let i = 0; i < this._lines.length; ++i) {
      const s = this._lines[i], r = new Dr(
        this._viewer,
        s.startPoint.copy().scale(1e3),
        s.endPoint.copy().scale(1e3)
      );
      e.push(t.addLine(r));
    }
    await Promise.all(e);
  }
  async _activateCuttingPlanes() {
    const e = await this._viewer.model.getModelBounding(!0, !1), i = this._viewer.cuttingManager;
    await i.clearAllCuttingSections();
    for (let s = 0; s < this._clippingPlanes.length; ++s) {
      const r = i.getCuttingSection(s);
      await r.clear();
      const o = this._clippingPlanes[s], a = o.location.copy().scale(1e3), l = o.direction.normalize(), c = je.createFromPointAndNormal(a, l), h = i.createReferenceGeometryFromFaceNormal(
        l,
        a,
        e
      );
      await r.addPlane(c, h);
    }
    await i.activateCuttingSections();
  }
  _activateSelected() {
    const t = this._getNodeIdsFromComponents(this._components.selection);
    this._viewer.selectionManager.clear(), t.forEach((e) => {
      this._viewer.selectionManager.selectNode(e, ai.Add);
    });
  }
  async _activateColors() {
    const t = this._viewer.model, e = t.getAbsoluteRootNode();
    if (t.unsetNodesFaceColor([e]), t.unsetNodesLineColor([e]), this._components.coloring !== void 0) {
      const i = /* @__PURE__ */ new Map();
      for (let s = 0; s < this._components.coloring.length; ++s) {
        const r = this._components.coloring[s];
        this._getNodeIdsFromComponents(r.components).forEach((a) => {
          i.set(a, r.color);
        });
      }
      await this._viewer.model.setNodesColors(i);
    }
  }
  /**
   * Gets the viewpoint filename.
   */
  getFilename() {
    return this._filename;
  }
  /**
   * Gets the GUID associated with the viewpoint.
   */
  getViewpointGuid() {
    return this._viewpointGuid || null;
  }
  _fromBCFPerspectiveCamera(t, e) {
    const i = new ci();
    i.setProjection(te.Perspective);
    const s = t.cameraViewPoint.copy().scale(this._unitScale), r = t.cameraDirection.copy().normalize().scale(e), o = d.add(s, r), a = t.cameraUpVector.copy().normalize();
    i.setPosition(s), i.setTarget(o), i.setUp(a);
    const l = cs(t.fieldOfView), c = Math.tan(l / 2), u = 2 * d.subtract(i.getTarget(), i.getPosition()).length() * c;
    return i.setWidth(u), i.setHeight(u), i;
  }
  _fromBCFOrthogonalCamera(t, e) {
    const i = new ci();
    i.setProjection(te.Orthographic);
    const s = t.cameraViewPoint.copy().scale(this._unitScale), r = t.cameraDirection.copy().normalize().scale(e), o = d.add(s, r), a = t.cameraUpVector.copy().normalize();
    i.setPosition(s), i.setTarget(o), i.setUp(a);
    const l = t.viewToWorldScale * this._unitScale * 2;
    return i.setWidth(l), i.setHeight(l), i;
  }
  /**
   * Gets the viewpoint camera, or null if none is set.
   */
  getCamera() {
    const t = this._modelBounding.extents().length();
    return this._perspectiveCamera ? this._fromBCFPerspectiveCamera(this._perspectiveCamera, t / 40) : this._orthogonalCamera ? this._fromBCFOrthogonalCamera(this._orthogonalCamera, t) : null;
  }
  /**
   * Sets the viewpoint camera.
   * @param camera
   */
  setCamera(t) {
    t.getProjection() === te.Perspective ? (this._perspectiveCamera = this._toBCFPerspectiveCamera(t), this._orthogonalCamera = void 0) : (this._orthogonalCamera = this._toBCFOrthogonalCamera(t), this._perspectiveCamera = void 0);
  }
  _toBCFOrthogonalCamera(t) {
    const e = t.getPosition(), i = t.getTarget(), s = d.subtract(i, e).normalize(), r = t.getUp().normalize(), o = e.copy().scale(1 / this._unitScale), l = t.getWidth() / (this._unitScale * 2);
    return {
      cameraDirection: s,
      cameraUpVector: r,
      cameraViewPoint: o,
      viewToWorldScale: l
    };
  }
  _toBCFPerspectiveCamera(t) {
    const e = t.getPosition(), i = t.getTarget(), s = d.subtract(i, e).normalize(), r = t.getUp().normalize(), o = e.copy().scale(1 / this._unitScale), a = t.getWidth(), l = d.subtract(t.getTarget(), t.getPosition()).length(), c = a / (2 * l), h = Math.atan(c) * 2, u = Vl(h);
    return {
      cameraDirection: s,
      cameraUpVector: r,
      cameraViewPoint: o,
      fieldOfView: u
    };
  }
  /**
   * Sets the default visibility.
   * If true, visibility exceptions are hidden.
   * If false, visibility exceptions are shown.
   * @param defaultVisibility
   */
  setDefaultVisibility(t) {
    this._components.defaultVisibility = t;
  }
  _getDefaultVisibility() {
    return this._components.defaultVisibility !== void 0 ? this._components.defaultVisibility : !0;
  }
  /**
   * Sets the visibility exceptions. These nodes will be shown or hidden based on the default visibility setting.
   * @param visibilityExceptions Array of GenericIds corresponding to components.
   */
  setVisibilityExceptions(t) {
    const e = t.map(
      (i) => {
        const s = this._viewer.model.getNodeIdsByGenericIds([i]), r = s.length !== 0 ? s[0] : void 0;
        return {
          ifcGuid: i,
          authoringToolId: r,
          originatingSystem: Xn
        };
      }
    );
    this._components.visibilityExceptions = e;
  }
  /**
   * Sets the visibility exceptions. These nodes will be shown or hidden based on the default visibility setting.
   * @param visibilityExceptions Array of BcfNodes corresponding to components.
   */
  setVisibilityExceptionNodes(t) {
    const e = t.map(
      (i) => ({
        ifcGuid: i.genericId !== null ? i.genericId : void 0,
        authoringToolId: i.nodeId,
        originatingSystem: Xn
      })
    );
    this._components.visibilityExceptions = e;
  }
  /**
   * Gets the visibility exception generic ids.
   * @returns Array of GenericIds corresponding to components.
   */
  getVisibilityExceptions() {
    return this._getGenericIdsFromComponents(this._components.visibilityExceptions);
  }
  /**
   * Gets the visibility exception node ids.
   * @returns Array of NodeIds corresponding to components.
   */
  getVisibilityExceptionNodes() {
    return this._getNodeIdsFromComponents(this._components.visibilityExceptions);
  }
  /**
   * Sets the colors.
   * @param colorGenericIdMap Map correlating color to GenericIds.
   */
  setColors(t) {
    const e = [];
    t.forEach((i, s) => {
      const r = [];
      i.forEach((a) => {
        const l = this._viewer.model.getNodeIdsByGenericIds([a]), c = l.length !== 0 ? l[0] : void 0;
        r.push({
          ifcGuid: a,
          authoringToolId: c,
          originatingSystem: Xn
        });
      });
      const o = {
        color: s,
        components: r
      };
      e.push(o);
    }), this._components.coloring = e;
  }
  /**
   * Sets the colors.
   * @param colorNodeMap Map correlating color to BfcNodes.
   */
  setColorNodes(t) {
    const e = [];
    t.forEach((i, s) => {
      const r = [];
      i.forEach((a) => {
        const l = a.genericId !== null ? a.genericId : void 0;
        r.push({
          ifcGuid: l,
          authoringToolId: a.nodeId,
          originatingSystem: Xn
        });
      });
      const o = {
        color: s,
        components: r
      };
      e.push(o);
    }), this._components.coloring = e;
  }
  /**
   * @returns Map correlating color to components.
   */
  getColors() {
    const t = /* @__PURE__ */ new Map(), e = this._components.coloring;
    return e !== void 0 && e.forEach((i) => {
      const s = i.color.copy(), r = /* @__PURE__ */ new Set();
      i.components.map((o) => {
        o.ifcGuid !== void 0 && r.add(o.ifcGuid);
      }), t.set(s, r);
    }), t;
  }
  /**
   * @returns Map correlating color to nodes.
   */
  getColorsToNodes() {
    const t = /* @__PURE__ */ new Map(), e = this._components.coloring;
    return e !== void 0 && e.forEach((i) => {
      const s = i.color.copy(), r = /* @__PURE__ */ new Set();
      i.components.map((o) => {
        o.authoringToolId !== void 0 && o.originatingSystem === Xn && r.add(o.authoringToolId);
      }), t.set(s, r);
    }), t;
  }
  /**
   * Sets the markup lines.
   * @param lines array of start point and end point line pairs.
   */
  setLines(t) {
    this._lines = [], t.forEach((e) => {
      const i = {
        startPoint: e[0].copy(),
        endPoint: e[1].copy()
      };
      this._lines.push(i);
    });
  }
  /**
   * Gets markup lines.
   * @returns Array containing start point and end point line pairs.
   */
  getLines() {
    const t = [];
    return this._lines.forEach((e) => {
      t.push([e.startPoint.copy(), e.endPoint.copy()]);
    }), t;
  }
  /**
   * Sets the clipping planes.
   * @param planes array containing position and direction pairs.
   */
  setClippingPlanes(t) {
    this._clippingPlanes = [], t.forEach((e) => {
      const i = {
        location: e[0].copy(),
        direction: e[1].copy()
      };
      this._clippingPlanes.push(i);
    });
  }
  /**
   * Gets the clipping planes.
   * @returns Array containing position and direction pairs.
   */
  getClippingPlanes() {
    const t = [];
    return this._clippingPlanes.forEach((e) => {
      t.push([e.location.copy(), e.direction.copy()]);
    }), t;
  }
  /**
   * Sets a list of items to be added to the selection set.
   */
  setSelection(t) {
    const e = t.map((i) => {
      const s = this._viewer.model.getNodeIdsByGenericIds([i]), r = s.length !== 0 ? s[0] : void 0;
      return {
        ifcGuid: i,
        authoringToolId: r,
        originatingSystem: Xn
      };
    });
    this._components.selection = e;
  }
  /**
   * Sets a list of items to be added to the selection set.
   */
  setSelectionNodes(t) {
    const e = t.map((i) => ({
      ifcGuid: i.genericId !== null ? i.genericId : void 0,
      authoringToolId: i.nodeId,
      originatingSystem: Xn
    }));
    this._components.selection = e;
  }
  /**
   * Gets a list of generic IDs that are in the selection set.
   */
  getSelection() {
    const t = [], e = this._components.selection;
    return e !== void 0 && e.forEach((i) => {
      i.ifcGuid && t.push(i.ifcGuid);
    }), t;
  }
  /**
   * Gets a list of node IDs that are in the selection set.
   */
  getSelectionNodes() {
    const t = [], e = this._components.selection;
    return e !== void 0 && e.forEach((i) => {
      i.authoringToolId !== void 0 && i.originatingSystem === Xn && t.push(i.authoringToolId);
    }), t;
  }
  _getGenericIdsFromComponents(t) {
    if (!t)
      return [];
    const e = [];
    for (let i = 0; i < t.length; ++i) {
      const s = t[i];
      s.ifcGuid !== void 0 && e.push(s.ifcGuid);
    }
    return e;
  }
  _getNodeIdsFromComponents(t) {
    if (!t)
      return [];
    const e = /* @__PURE__ */ new Set(), i = [];
    for (let r = 0; r < t.length; ++r) {
      const o = t[r];
      o.authoringToolId !== void 0 && o.originatingSystem === Xn ? e.add(o.authoringToolId) : o.ifcGuid !== void 0 && i.push(o.ifcGuid);
    }
    const s = this._viewer.model.getNodeIdsByGenericIds(i);
    for (const r of s)
      e.add(r);
    return Array.from(e);
  }
  _parseComponentsV2_0(t) {
    console.assert(this._version <= pn.v2_0);
    const e = [], i = [], s = [];
    let r = !0, o = t.firstElementChild;
    for (; o !== null; ) {
      const a = o.localName;
      if (a === null)
        break;
      switch (a) {
        case "Component":
          {
            const l = o.attributes, c = l.getNamedItem("IfcGuid"), h = l.getNamedItem("Selected"), u = l.getNamedItem("Visible"), p = l.getNamedItem("Color");
            if (c !== null && c.value) {
              const g = {
                ifcGuid: c.value
              };
              if (h !== null && h.value === "true" && e.push(g), r = !1, u !== null && u.value === "false" || i.push(g), p !== null && p.value) {
                const _ = p.value;
                s.push(this._colorFromArgb(_, [g]));
              }
            }
          }
          break;
      }
      o = o.nextElementSibling;
    }
    this._components = {
      defaultVisibility: r,
      selection: e,
      visibilityExceptions: i,
      coloring: s
    };
  }
  _parseComponents(t) {
    console.assert(this._version >= pn.v2_1);
    let e = t.firstElementChild;
    const i = {
      spacesVisible: !1,
      spaceBoundariesVisible: !1,
      openingsVisible: !1
    };
    let s = [], r = !0, o = [], a = [];
    for (; e !== null; ) {
      const l = e.localName;
      if (l === null)
        break;
      const c = e.attributes;
      switch (l) {
        case "ViewSetupHints":
          {
            const h = c.getNamedItem("SpacesVisible"), u = c.getNamedItem("SpaceBoundariesVisible"), p = c.getNamedItem("OpeningsVisible");
            h !== null && (i.spacesVisible = h.value === "true"), u !== null && (i.spaceBoundariesVisible = u.value === "true"), p !== null && (i.openingsVisible = p.value === "true");
          }
          break;
        case "Selection":
          s = this._getComponents(e);
          break;
        case "Visibility":
          {
            const h = c.getNamedItem("DefaultVisibility");
            h && (r = h.value === "true");
            const u = e.firstElementChild;
            u !== null && (o = this._getComponents(u));
          }
          break;
        case "Coloring":
          a = this._getColoring(e);
          break;
      }
      e = e.nextElementSibling;
    }
    this._components = {
      viewSetupHints: i,
      selection: s,
      defaultVisibility: r,
      visibilityExceptions: o,
      coloring: a
    };
  }
  _getCameraData(t) {
    const e = [];
    let i = t.firstElementChild;
    for (; i !== null; )
      switch (i.nodeName) {
        case "FieldOfView":
        case "ViewToWorldScale":
          {
            const s = i.textContent;
            s !== null && e.push(parseFloat(s)), i = null;
          }
          break;
        default:
          e.push(this._getPoint(i)), i = i.nextElementSibling;
      }
    return e;
  }
  _parseOrthogonalCamera(t) {
    const e = this._getCameraData(t);
    e.length === 4 && (this._orthogonalCamera = {
      cameraViewPoint: e[0],
      cameraDirection: e[1],
      cameraUpVector: e[2],
      viewToWorldScale: e[3]
    });
  }
  _parsePerspectiveCamera(t) {
    const e = this._getCameraData(t);
    e.length === 4 && (this._perspectiveCamera = {
      cameraViewPoint: e[0],
      cameraDirection: e[1],
      cameraUpVector: e[2],
      fieldOfView: e[3]
    });
  }
  _parseLines(t) {
    let e = t.firstElementChild;
    for (; e !== null; )
      this._lines.push(this._getLine(e)), e = e.nextElementSibling;
  }
  _parseClippingPlanes(t) {
    let e = t.firstElementChild;
    for (; e !== null; )
      this._clippingPlanes.push(this._getClippingPlane(e)), e = e.nextElementSibling;
  }
  _getClippingPlane(t) {
    let e = t.firstElementChild, i = d.zero(), s = d.zero();
    return e !== null && (i = this._getPoint(e), e = e.nextElementSibling, e !== null && (s = this._getPoint(e))), {
      location: i,
      direction: s
    };
  }
  _getLine(t) {
    let e = t.firstElementChild, i = d.zero(), s = d.zero();
    return e !== null && (i = this._getPoint(e), e = e.nextElementSibling, e !== null && (s = this._getPoint(e))), {
      startPoint: i,
      endPoint: s
    };
  }
  _getPoint(t) {
    const e = [];
    let i = t.firstElementChild;
    for (; i !== null; ) {
      const s = i.firstChild;
      s !== null && e.push(parseFloat(s.wholeText)), i = i.nextElementSibling;
    }
    return console.assert(e.length === 3), new d(e[0], e[1], e[2]);
  }
  _colorFromArgb(t, e) {
    const i = {
      color: it.black(),
      components: e
    }, s = [];
    for (let r = 0; r < t.length; r += 2) {
      const o = t.substr(r, 2);
      s.push(parseInt(o, 16));
    }
    return s.length === 3 ? i.color.set(s[0], s[1], s[2]) : s.length === 4 && (i.alpha = s[0], i.color.set(s[1], s[2], s[3])), i;
  }
  _getColoring(t) {
    const e = [];
    let i = t.firstElementChild;
    for (; i !== null; ) {
      const r = i.attributes.getNamedItem("Color"), o = this._getComponents(i);
      r && o.length && e.push(this._colorFromArgb(r.value, o)), i = i.nextElementSibling;
    }
    return e;
  }
  _getComponents(t) {
    const e = [];
    let i = t.firstElementChild;
    for (; i !== null; ) {
      const s = i.attributes, r = s.getNamedItem("IfcGuid"), o = s.getNamedItem("OriginatingSystem"), a = s.getNamedItem("AuthoringToolId");
      if (r !== null) {
        const l = {
          ifcGuid: r.value
        };
        o !== null && (l.originatingSystem = o.value), a !== null && (l.authoringToolId = parseInt(a.value, 10)), e.push(l);
      }
      i = i.nextElementSibling;
    }
    return e;
  }
}
class Al {
  constructor(t, e, i, s) {
    this._viewpointMap = /* @__PURE__ */ new Map(), this._snapshotMap = /* @__PURE__ */ new Map(), this._viewer = s, this._topicId = i, this._bcfDataId = t, this._bcfFilename = e;
  }
  /**
   * Takes a MarkupView and creates a BCF Topic from it.
   * @param bcfDataId
   * @param bcfFilename
   * @param viewer
   * @param markupView
   * @param topicTitle
   */
  static async createTopic(t, e, i, s, r = null) {
    const o = Qi(), a = new Al(e, i, o, t), l = "markup.bcf", c = a.addMarkup(l, null);
    c.setTopicTitle(s), c.setTopicId(o);
    const h = "viewpoint.bcfv", u = await zr.createViewpoint(t, h, r);
    a.setViewpoint(h, u);
    const p = "snapshot.png", m = (r !== null ? r.getSnapshotImage() : null) || await t.takeSnapshot(), g = ar.createFromImage(p, m);
    return a.setSnapshot(p, g), a;
  }
  /**
   * Gets the topic id corresponding to the BCF topic folder.
   */
  getTopicId() {
    return this._topicId;
  }
  /**
   * Adds a BCF markup.
   * @param markup BCF markup data.
   */
  addMarkup(t, e) {
    return this._markup = new cm(t, e, this), this._markup;
  }
  /**
   * @returns BCF markup data.
   */
  getMarkup() {
    return this._markup;
  }
  /**
   * Creates and adds BCF viewpoint.
   * @param fileName viewpoint filename.
   * @param viewpoint BCF viewpoint data.
   */
  addViewpoint(t, e, i, s, r) {
    const o = new zr(
      t,
      e,
      i,
      s,
      r,
      this._viewer
    );
    return this.setViewpoint(t, o), o;
  }
  /**
   * Adds a BCF Viewpoint. If there is a already a viewpoint with the same filename, it will be replaced.
   * @param filename
   * @param viewpoint
   */
  setViewpoint(t, e) {
    this._viewpointMap.set(t, e);
  }
  /**
   * @returns A map associating viewpoint filenames with viewpoint data.
   */
  getViewpointMap() {
    return this._viewpointMap;
  }
  /**
   * Gets viewpoint data.
   * @param filename viewpoint filename.
   */
  getViewpoint(t) {
    return this._viewpointMap.get(t) || null;
  }
  /**
   * Creates and adds a Snapshot.
   * @param fileName Snapshot filename.
   * @param png Image data.
   */
  addSnapshot(t, e) {
    const i = new ar(t, e);
    this.setSnapshot(t, i);
  }
  /**
   * Adds a BCF Snapshot. If there is already a snapshot with the smae filename, it will be replaced.
   * @param filename
   * @param snapshot
   */
  setSnapshot(t, e) {
    this._snapshotMap.set(t, e);
  }
  /**
   * @returns A map associating snapshot filenames with snapshot data.
   */
  getSnapshotMap() {
    return this._snapshotMap;
  }
  /**
   * Gets snapshot data.
   * @param filename snapshot or corresponding viewpoint filename
   */
  getSnapshot(t) {
    return this._snapshotMap.get(this._massageSnapshotFilename(t)) || null;
  }
  _massageSnapshotFilename(t) {
    if (t === "viewpoint.bcfv")
      return "snapshot.png";
    const e = t.split(".");
    return e[1] === "bcfv" ? `${e[0]}.png` : t;
  }
}
const J0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BCFComment: Tc,
  BCFData: sl,
  BCFFileType: Ci,
  BCFMarkup: cm,
  BCFMarkupHeaderFile: am,
  BCFMarkupViewpoint: lm,
  BCFSnapshot: ar,
  BCFTopic: Al,
  BCFVersion: pn,
  BCFViewpoint: zr,
  addElem: On,
  appendPoint3: Zn,
  argbStringFromColor: sm,
  boolToString: yo,
  conditionalAddElem: Be,
  conditionalBoolToString: nl,
  conditionalDateToString: bo,
  conditionalNumberToString: Vc,
  conditionalSetAttribute: Fn,
  defaultOriginatingSystem: Xn,
  exportComponent: il
}, Symbol.toStringTag, { value: "Module" }));
var Zl = /* @__PURE__ */ ((n) => (n[n.avatarOffset = 1500] = "avatarOffset", n[n.maxClimbHeight = 600] = "maxClimbHeight", n[n.negligibleClimbHeight = 20] = "negligibleClimbHeight", n[n.maxFallDistance = 5e3] = "maxFallDistance", n))(Zl || {}), Cl = /* @__PURE__ */ ((n) => (n[n.avatarOffset = 150] = "avatarOffset", n))(Cl || {}), kl = /* @__PURE__ */ ((n) => (n[n.transparencyRange = 4e3] = "transparencyRange", n))(kl || {});
const j0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DefaultDoorConfig: kl,
  DefaultFloorConfig: Zl,
  DefaultWallConfig: Cl
}, Symbol.toStringTag, { value: "Module" }));
var Xs = /* @__PURE__ */ ((n) => (n[n.Never = 0] = "Never", n[n.Bim = 1] = "Bim", n[n.BimWalk = 2] = "BimWalk", n))(Xs || {}), oi = /* @__PURE__ */ ((n) => (n.Inactive = "inactive", n.Activating = "activating", n.Active = "active", n))(oi || {});
function Nc(n) {
  if (n.length === 0)
    return new Q();
  if (n.length === 1)
    return n[0];
  let t = Q.multiply(n[1], n[0]);
  for (let e = 2; e < n.length; ++e)
    t = Q.multiply(n[e], t);
  return t;
}
function kr(n, t, e) {
  return Math.max(t, Math.min(e, n));
}
function dm(n, t) {
  return n.x >= t.min.x && n.x <= t.max.x && n.y >= t.min.y && n.y <= t.max.y && n.z >= t.min.z && n.z <= t.max.z;
}
function Lc(n, t) {
  return n.z >= t.min.z && n.z <= t.max.z;
}
class mm {
  constructor(t, e, i, s, r) {
    this.floorplanNode = null, this.floorNode = t, this.bounds = e, this.slabNodes = i, this.spaceNodes = s, this.floorplanMeshCreationNodes = r;
  }
}
class Wa {
  constructor() {
    this.overlayAnchor = Jt.LowerRightCorner, this.overlaySize = new E(0.25, 1), this.overlayWidthUnit = Bt.ProportionOfCanvas, this.overlayHeightUnit = Bt.ProportionOfOtherDimension, this.overlayOffset = new E(0, 0), this.overlayOffsetXUnit = Bt.Pixels, this.overlayOffsetYUnit = Bt.Pixels, this.backgroundColor = it.white(), this.backgroundOpacity = 0.25, this.borderColor = it.black(), this.borderOpacity = 1, this.avatarColor = it.createFromFloat(1, 0, 1), this.avatarOutlineColor = it.black(), this.avatarOpacity = 1, this.avatarScale = 1, this.fixedAvatarScale = !0, this.overlayFeetPerPixel = 0.1, this.zoomLevel = 1, this.autoActivate = Xs.BimWalk, this.floorplanOrientation = Vr.NorthUp, this.customAvatar = null, this.trackCameraEnabled = !1;
  }
  /**
   * Per-floor information.
   * @returns Copy of this configuration object.
   */
  copy() {
    const t = new Wa();
    return t.overlayAnchor = this.overlayAnchor, t.overlaySize = this.overlaySize.copy(), t.overlayWidthUnit = this.overlayWidthUnit, t.overlayHeightUnit = this.overlayHeightUnit, t.overlayOffset = this.overlayOffset.copy(), t.overlayOffsetXUnit = this.overlayOffsetXUnit, t.overlayOffsetYUnit = this.overlayOffsetYUnit, t.backgroundColor = this.backgroundColor.copy(), t.backgroundOpacity = this.backgroundOpacity, t.borderColor = this.borderColor.copy(), t.borderOpacity = this.borderOpacity, t.avatarColor = this.avatarColor.copy(), t.avatarOutlineColor = this.avatarOutlineColor.copy(), t.avatarOpacity = this.avatarOpacity, t.avatarScale = this.avatarScale, t.fixedAvatarScale = this.fixedAvatarScale, t.customAvatar = this.customAvatar, t.overlayFeetPerPixel = this.overlayFeetPerPixel, t.zoomLevel = this.zoomLevel, t.trackCameraEnabled = this.trackCameraEnabled, t.autoActivate = this.autoActivate, t.floorplanOrientation = this.floorplanOrientation, t;
  }
}
class Ie {
  constructor(t = Xt.Face) {
    this.respectVisibility = !0, this.forceEffectiveVisibilityMask = Xt.None, this.forceEffectiveSceneVisibilityMask = Xt.None, this.respectDepthRange = !0, this.oneEntityPerTypePerInstance = !0, this.restrictLinesAndPointsToSelectedFaceInstances = !0, this.enableProximityFaces = !1, this.ignoreCappingGeometry = !1, this.ignoreOverlays = !1, this.restrictToOverlays = !1, this.selectionMask = t;
  }
  /** Returns a copy of this [[PickConfig]]. */
  copy() {
    const t = new Ie();
    return yg(this, t), t;
  }
  get allowFaces() {
    return (this.selectionMask & Xt.Face) !== 0;
  }
  set allowFaces(t) {
    this.selectionMask = Nr(this.selectionMask, Xt.Face, t);
  }
  get allowLines() {
    return (this.selectionMask & Xt.Line) !== 0;
  }
  set allowLines(t) {
    this.selectionMask = Nr(this.selectionMask, Xt.Line, t);
  }
  get allowPoints() {
    return (this.selectionMask & Xt.Point) !== 0;
  }
  set allowPoints(t) {
    this.selectionMask = Nr(this.selectionMask, Xt.Point, t);
  }
}
class Dl {
  constructor(t = Xt.All) {
    this.mustBeFullyContained = !1, this.respectVisibility = !0, this.forceEffectiveVisibilityMask = Xt.None, this.forceEffectiveSceneVisibilityMask = Xt.None, this.allowFaces = !0, this.allowLines = !0, this.allowPoints = !0, this.ignoreCuttingSections = !0, this.onlyStreamedInstances = !1, this.ignoreUnrequestedInstances = !1, this.allowFaces = (t & Xt.Face) !== 0, this.allowLines = (t & Xt.Line) !== 0, this.allowPoints = (t & Xt.Point) !== 0;
  }
}
class Fs {
  constructor(t, e, i, s) {
    this.x = t, this.xUnit = e, this.y = i, this.yUnit = s;
  }
}
class pm {
  constructor(t, e, i) {
    this._anchor = t, this._position = e, this._size = i;
  }
  getAnchor() {
    return this._anchor;
  }
  getPosition() {
    return this._position;
  }
  getSize() {
    return this._size;
  }
}
class gm {
  /** @hidden */
  constructor(t, e) {
    this._viewer = t, this._engine = e, this._viewports = [];
    for (let i = 0; i <= this.maxIndex(); i++)
      this._viewports.push(null);
  }
  /**
   * Gets the maximum index value that can be used for indexing overlays.
   * @returns the maximum index value.
   */
  maxIndex() {
    return Vt.First - 1;
  }
  /**
   * Creates an overlay or updates an existing one.
   * @param index the index of the overlay. This value may be any number between 1 and maxIndex(). If No overlay exists for this index one will be created.
   * @param anchor the anchor point for the viewport.
   * @param x the x value of the viewport location.
   * @param xUnit the unit type of the x parameter.
   * @param y the y value of the viewport location.
   * @param yUnit the unit type of the y parameter.
   */
  setViewport(t, e, i, s, r, o, a, l, c, h) {
    if (t === 0)
      throw new Mt("Index 0 is reserved and may not be used to specify an overlay.");
    if (t < 0)
      throw new Mt(`Invalid index ${t} specified when setting viewport.`);
    if (s === Bt.ProportionOfOtherDimension && o === Bt.ProportionOfOtherDimension)
      throw new Mt("Both x and y may not be set proportional to each other");
    if (l === Bt.ProportionOfOtherDimension && h === Bt.ProportionOfOtherDimension)
      throw new Mt(
        "Both width and height may not be set proportional to each other"
      );
    this._validateUnit(i, s, "x"), this._validateUnit(r, o, "y"), this._validateUnit(a, l, "width"), this._validateUnit(c, h, "height");
    const u = new Fs(i, s, r, o), p = new Fs(a, l, c, h), m = new pm(e, u, p);
    return this._viewports[t] = m, this._engine.setOverlayViewport(
      t,
      e,
      i,
      s,
      r,
      o,
      a,
      l,
      c,
      h
    ), this._viewer._getCallbackManager().trigger("overlayViewportSet", t), Promise.resolve();
  }
  /**
   * @hidden
   * Gets the position of a viewport as it was defined with OverlayUnits
   * @param index Index to get position of
   * @returns OverlayUnitPoint expressing overlay's position
   */
  _getViewportPosition(t) {
    const e = this._viewports[t];
    return e === null ? null : e.getPosition();
  }
  /**
   * Gets position in pixels of the viewport with the supplied index, or `null` if none has been set.
   * Note: This does not take the anchor point into account
   * @param index The index of the overlay to get the position of.
   */
  getViewportPixelPosition(t) {
    const e = this._viewports[t];
    if (e === null)
      return null;
    const i = e.getPosition();
    return this._toPixelPoint(i);
  }
  /**
   * Gets the calculated position of the upper-left corner of the viewport with the supplied index, or `null`
   * if none has been set.
   * @param index The index of the overlay to get the offset of
   */
  getViewportPixelOffsetInCanvas(t) {
    const e = this.getViewportPixelPosition(t);
    if (e === null)
      return null;
    const i = this.getViewportPixelSize(t);
    if (i === null)
      return null;
    const s = this.getViewportAnchor(t);
    if (s === null)
      return null;
    const r = this._getOverlayOffset(s, i), o = E.add(r, e);
    switch (s) {
      case Jt.UpperRightCorner:
      case Jt.RightCenter:
      case Jt.LowerRightCorner:
        o.x = r.x - e.x;
        break;
    }
    switch (s) {
      case Jt.LeftCenter:
      case Jt.Center:
      case Jt.RightCenter:
      case Jt.LowerLeftCorner:
      case Jt.BottomCenter:
      case Jt.LowerRightCorner:
        o.y = r.y - e.y;
    }
    return o;
  }
  /**
   * @hidden
   * Gets the size of a viewport as it was defined with OverlayUnits
   * @param index Index to get size of
   * @returns OverlayUnitPoint expressing overlay's size
   */
  _getViewportSize(t) {
    const e = this._viewports[t];
    return e === null ? null : e.getSize();
  }
  /**
   * Gets size in pixels of the viewport with the supplied index, or `null` if none has been set.
   * @param index The index of the overlay to get the size of.
   */
  getViewportPixelSize(t) {
    const e = this._viewports[t];
    if (e === null)
      return null;
    const i = e.getSize();
    return this._toPixelPoint(i);
  }
  /**
   * Get the anchor point of the viewport with the supplied index, or `null` if none has been set.
   * @param index The index of the overlay to get the anchor of.
   */
  getViewportAnchor(t) {
    const e = this._viewports[t];
    return e === null ? null : e.getAnchor();
  }
  /**
   * Sets the visibility state for the given viewport.
   * @param index the overlay index.
   * @param visibility boolean value indicating whether the overlay should be rendered.
   */
  setVisibility(t, e) {
    return this._engine.setOverlayVisibility(t, e), Promise.resolve();
  }
  /**
   * Removes an overlay from the system. All nodes that have been assigned to this overlay will be returned to the default view.
   * @param index the index of the overlay to destroy.
   */
  destroy(t) {
    return this._engine.destroyOverlay(t), this._viewports[t] = null, Promise.resolve();
  }
  /**
   * Adds nodes into the overlay at the given index. They will no longer be rendered in the main window or any other overlay.
   * This method should not be called before the model structure ready callback has been triggered.
   * @param index the overlay index to add nodes into.
   * @param nodes the nodes to add into the overlay.
   */
  addNodes(t, e) {
    const i = this._viewer.model._gatherInstanceIncsFromNodeIds(e);
    return i.length > 0 && this._engine.addNodesToOverlay(i, t), Promise.resolve();
  }
  /**
   * Sets the camera for the given index.
   * @param index
   * @param camera
   */
  setCamera(t, e) {
    return this._engine.setOverlayCamera(t, e), Promise.resolve();
  }
  /** @hidden */
  _getOverlayOffset(t, e) {
    const s = this._viewer.view.getCanvasSize(), r = E.zero();
    return t === Jt.LowerRightCorner || t === Jt.UpperRightCorner || t === Jt.RightCenter ? r.x = s.x - e.x : (t === Jt.Center || t === Jt.TopCenter || t === Jt.BottomCenter) && (r.x = 0.5 * (s.x - e.x)), t === Jt.LowerLeftCorner || t === Jt.LowerRightCorner || t === Jt.BottomCenter ? r.y = s.y - e.y : (t === Jt.Center || t === Jt.LeftCenter || t === Jt.RightCenter) && (r.y = 0.5 * (s.y - e.y)), r;
  }
  /**
   * @hidden
   * Converts an OverlayUnitPoint to a pixel defined Point2 using the viewer's current dimensions
   * @param unitPoint Point defined with [[OverlayUnit]]s to convert
   * @returns point expressed in pixels based on viewer's current size
   */
  _toPixelPoint(t) {
    const e = this._viewer.view.getCanvasSize(), i = E.zero();
    let s = !1;
    switch (t.xUnit) {
      case Bt.Pixels:
        i.x = t.x;
        break;
      case Bt.ProportionOfCanvas:
        i.x = e.x * t.x;
        break;
      case Bt.ProportionOfOtherDimension:
        s = !0;
        break;
    }
    switch (t.yUnit) {
      case Bt.Pixels:
        i.y = t.y;
        break;
      case Bt.ProportionOfCanvas:
        i.y = e.y * t.y;
        break;
      case Bt.ProportionOfOtherDimension:
        i.y = i.x * t.y;
        break;
    }
    return s && (i.x = t.x * i.y), i;
  }
  _validateUnit(t, e, i) {
    if (e !== Bt.Pixels && (t < 0 || t > 1))
      throw new fn(
        `value for ${i} should be between 0.0 and 1.0 when specifying non pixel value`
      );
  }
}
const H0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  OverlayManager: gm,
  OverlayUnitPoint: Fs,
  OverlayViewport: pm
}, Symbol.toStringTag, { value: "Module" })), Kn = class {
  /** @hidden */
  constructor(n, t, e, i, s, r) {
    this._active = oi.Inactive, this._isSceneReady = !1, this._isModelLoaded = !1, this._isOverlayVisible = !1, this._isCallbacksSet = !1, this._onCameraUpdateFunc = this._doCameraUpdate.bind(this), this._onFrameDrawnFunc = this._onFrameDrawn.bind(this), this._floorplanNode = null, this._currentFloorInfo = null, this._config = new Wa(), this._floorLock = !1, this._tightBoundings = !1, this._genericStoreyType = "IFCBUILDINGSTOREY", this._floorInfos = /* @__PURE__ */ new Map(), this._floorInfosArray = new Array(), this._avatarNode = null, this._avatarDirty = !0, this._borderNode = null, this._borderDirty = !0, this._backgroundNode = null, this._backgroundDirty = !0, this._canvasSize = new E(1, 1), this._sync = new Ns(1, !0), this._setFloorplanSync = new Zf(!1), this._viewer = n, this._model = t, this._engine = i, this._modelStructure = s, this._overlayManager = e, this._config = r.copy(), this._viewer.setCallbacks({
      sceneReady: () => {
        console.assert(
          this._active !== oi.Active,
          "Got sceneReady while Floorplan is Active"
        ), this._isSceneReady = !0, this._active === oi.Activating && this._sync.push(() => this._doUpdateActivation());
      },
      modelSwitchStart: () => {
        this._isModelLoaded = !1, this._sync.push(async () => this._deactivate());
      },
      firstModelLoaded: () => {
        this._isModelLoaded = !0, this._onModelLoaded();
      },
      subtreeLoaded: () => {
        this._isModelLoaded = !0, this._onModelLoaded();
      }
    });
  }
  /** Sets a custom avatar. See [[FloorplanConfig.customAvatar]] for detailed information. */
  async setCustomAvatar(n) {
    if (this._config.customAvatar !== n)
      return await this._doSetCustomAvatar(n), this._avatarDirty = !0, this._onConfigurationChanged();
  }
  /** Sets the size of the floorplan overlay window. See [[FloorplanConfig.overlaySize]] for detailed information. */
  async setOverlaySize(n, t, e) {
    return this._config.overlaySize = n.copy(), this._config.overlayWidthUnit = t, this._config.overlayHeightUnit = e, this._onConfigurationChanged();
  }
  /** Sets the anchor position of the floorplan overlay window. See [[FloorplanConfig.overlayAnchor]] for detailed information. */
  async setOverlayAnchor(n) {
    return this._config.overlayAnchor = n, this._onConfigurationChanged();
  }
  /** Sets the offset position of the floorplan overlay window. See [[FloorplanConfig.overlayOffset]] for detailed information. */
  async setOverlayOffset(n) {
    return this._config.overlayOffset = n.copy(), this._onConfigurationChanged();
  }
  /** Sets the overlay scaling. See [[FloorplanConfig.overlayFeetPerPixel]] for detailed information. */
  async setOverlayFeetPerPixel(n) {
    return this._config.overlayFeetPerPixel = n, this._onConfigurationChanged();
  }
  /** Sets the overlay zoom level. See [[FloorplanConfig.zoomLevel]] for detailed information. */
  async setZoomLevel(n) {
    return this._config.zoomLevel = n, this._onConfigurationChanged();
  }
  /** Sets the overlay background color. See [[FloorplanConfig.backgroundColor]] for detailed information. */
  async setBackgroundColor(n) {
    return this._config.backgroundColor = n, this._backgroundDirty = !0, this._onConfigurationChanged();
  }
  /** Sets the overlay background opacity. See [[FloorplanConfig.backgroundOpacity]] for detailed information. */
  async setBackgroundOpacity(n) {
    return this._config.backgroundOpacity = n, this._backgroundDirty = !0, this._onConfigurationChanged();
  }
  /** Sets the overlay border color. See [[FloorplanConfig.borderColor]] for detailed information. */
  async setBorderColor(n) {
    return this._config.borderColor = n, this._borderDirty = !0, this._onConfigurationChanged();
  }
  /** Sets the overlay border opacity. See [[FloorplanConfig.borderOpacity]] for detailed information. */
  async setBorderOpacity(n) {
    return this._config.borderOpacity = n, this._borderDirty = !0, this._onConfigurationChanged();
  }
  /** Sets the avatar primary color. See [[FloorplanConfig.avatarColor]] for detailed information. */
  async setAvatarColor(n) {
    return this._config.avatarColor = n, this._avatarDirty = !0, this._onConfigurationChanged();
  }
  /** Sets the avatar outline color. See [[FloorplanConfig.avatarOutlineColor]] for detailed information. */
  async setAvatarOutlineColor(n) {
    return this._config.avatarOutlineColor = n, this._avatarDirty = !0, this._onConfigurationChanged();
  }
  /** Sets the avatar opacity. See [[FloorplanConfig.avatarOpacity]] for detailed information. */
  async setAvatarOpacity(n) {
    return this._config.avatarOpacity = n, this._avatarDirty = !0, this._onConfigurationChanged();
  }
  /** Sets the avatar scale. See [[FloorplanConfig.avatarScale]] for detailed information. */
  async setAvatarScale(n) {
    return this._config.avatarScale = n, this._avatarDirty = !0, this._onConfigurationChanged();
  }
  /** Sets the avatar size to fixed scale. See [[FloorplanConfig.fixedAvatarScale]] for detailed information. */
  async setFixedAvatarScale(n) {
    if (this._config.fixedAvatarScale !== n)
      return await this._deleteAvatarNode(), this._config.fixedAvatarScale = n, this._avatarDirty = !0, this._onConfigurationChanged();
  }
  /** Sets the floorplan tracking mode. See [[FloorplanConfig.trackCameraEnabled]] for detailed information. */
  async setTrackCameraEnabled(n) {
    return this._config.trackCameraEnabled = n, this._onConfigurationChanged();
  }
  /** Sets the floorplan display orientation. See [[FloorplanConfig.floorplanOrientation]] for detailed information. */
  async setFloorplanOrientation(n) {
    return this._config.floorplanOrientation = n, this._onConfigurationChanged();
  }
  /** Sets the auto-activate capability for any models loaded after this call. See [[FloorplanConfig.autoActivate]] for detailed information. */
  async setAutoActivate(n) {
    return this._config.autoActivate = n, this._onConfigurationChanged();
  }
  /** Locks floorplan to current floor such that changing floors will not change the displayed floorplan. */
  async setFloorLock(n) {
    if (this._floorLock = n, this.isActive() && !n) {
      const t = this._viewer.view.getCamera().getPosition();
      await this._setFloorplanFromPosition(t);
    }
  }
  /** Returns `true` if displayed floor has been locked with [[setFloorLock]]. */
  getFloorLock() {
    return this._floorLock;
  }
  /**
   * Makes floorplans use tight boundings during creation which can result in a better fit for the overlay.
   * This involves recreating any already existing floorplans.
   * This can be significantly more time consuming than using loose boundings if your floors are complex.
   * Defaults to `false`.
   */
  async setUseTightBoundings(n) {
    n !== this._tightBoundings && (await this._deleteAllFloorplans(), this._tightBoundings = n, this.isActive() && await this._onProcessIfc());
  }
  /**
   * Updates the floorplan to use the given configuration. This function allows
   * the user to set all configuration values with a single operation. There are
   * also `set<config-value>()` functions for easily setting individual configuration
   * values.
   *
   * Note that when using this function, all settings in the given configuration are
   * used and thus overwrite any individual settings changed with a prior
   * `set<config-value>()` call.
   *
   * All values from the passed configuration will be copied as part of this operation.
   */
  async setConfiguration(n) {
    const t = this._config.customAvatar;
    return this._config = n.copy(), t !== this._config.customAvatar && await this._doSetCustomAvatar(this._config.customAvatar), this._borderDirty = !0, this._backgroundDirty = !0, this._avatarDirty = !0, this._onConfigurationChanged();
  }
  /** Returns a copy of the current floorplan configuration. */
  getConfiguration() {
    return this._config.copy();
  }
  /** Gets the [[NodeId]] of the current storey. */
  getCurrentFloorNodeId() {
    return this._currentFloorInfo !== null ? this._currentFloorInfo.floorNode : null;
  }
  /** Gets the [[NodeId]] of the floorplan avatar. */
  getAvatarNodeId() {
    return this._avatarNode;
  }
  /** Returns `true` if the given point is inside the floorplan overlay and `false` otherwise. */
  insideOverlay(n) {
    const t = this._getOverlaySizeInPixels(), e = this._getOverlayOffsetInPixels();
    return n.x >= e.x && n.y >= e.y && n.x <= e.x + t.x && n.y <= e.y + t.y;
  }
  /**
   *  Activate the floorplan overlay.
   */
  async activate() {
    await this._sync.push(() => this._activate());
  }
  /**
   *  Deactivate the floorplan overlay. Once explicitly deactivated via this call, auto-activation
   *  will be suppressed for any new model that is loaded. Auto-activation can be reenabled by
   *  calling [[setAutoActivate]].
   */
  async deactivate() {
    await this._sync.push(() => this._deactivate());
  }
  /**
   * The avatar node needs to be deleted any time we are making changes to the mesh,
   * such as switching to a custom avatar or fixed avatar scale.
   */
  async _deleteAvatarNode() {
    if (this._avatarNode !== null) {
      try {
        this._modelStructure.allowNodeDeletion(this._avatarNode), await this._model.deleteNode(this._avatarNode);
      } catch (n) {
        console.log(`Problem deleting existing avatar: ${n.message}`);
      }
      this._avatarNode = null;
    }
  }
  /** Perform the steps needed to set a custom avatar. */
  async _doSetCustomAvatar(n) {
    await this._deleteAvatarNode(), this._config.customAvatar = n;
  }
  /** Call after something in the configuration has changed. Will update all visuals accordingly */
  async _onConfigurationChanged() {
    return this._config.zoomLevel = kr(this._config.zoomLevel, 0.1, 10), this._config.avatarScale = kr(this._config.avatarScale, 0.1, 10), this._config.backgroundOpacity = kr(this._config.backgroundOpacity, 0, 1), this._config.borderOpacity = kr(this._config.borderOpacity, 0, 1), this._config.avatarOpacity = kr(this._config.avatarOpacity, 0, 1), this._isModelLoaded && this._active === oi.Inactive && this._config.autoActivate === Xs.Bim ? this._onModelLoaded() : (this._isOverlayVisible && (this._isOverlayVisible = !1, await this._setupOverlay()), this._doCameraUpdate());
  }
  /** Sets the best floorplan for the given world position */
  async _setFloorplanFromPosition(n) {
    return this._setFloorplanSync.push(() => this._doSetFloorplanFromPosition(n));
  }
  /** Sets what floor the floorplan displays based on position */
  async _doSetFloorplanFromPosition(n) {
    let t = null;
    const e = [];
    for (const s of this._floorInfosArray)
      dm(n, s.bounds) && e.push(s);
    if (t = await (async (s) => {
      const r = await this._performDownwardSelection(n);
      for (const o of r) {
        const a = o.getNodeId(), l = this._model.getNodeParent(a);
        if (l === null)
          continue;
        const c = this._viewer.model.getNodeGenericType(l);
        if (c !== null) {
          if (Kn._ifcSpaceTypes.has(c)) {
            const h = await this._viewer.model.getNodesBounding([l]);
            if (!Lc(n, h))
              continue;
            for (const p of s)
              if (p.spaceNodes.indexOf(l) !== -1)
                return p;
          } else if (Kn._ifcFloorTypes.has(c)) {
            for (const h of s)
              if (h.slabNodes.indexOf(l) !== -1)
                return h;
          }
        }
      }
      return null;
    })(e), t === null) {
      for (const s of this._floorInfosArray)
        if (Lc(n, s.bounds)) {
          t = s;
          break;
        }
    }
    if (t !== null && (this._currentFloorInfo = t, this._floorplanNode === null || this._floorplanNode !== t.floorplanNode))
      return this._setFloorplanFromFloorNode(t.floorNode);
  }
  /** This function performs a downward selection and sorts the results by the top of their boundings */
  async _performDownwardSelection(n) {
    const t = new Ie();
    t.respectVisibility = !1, t.oneEntityPerTypePerInstance = !0;
    const e = new Vn(n, new d(0, 0, -1)), i = await this._viewer.view.pickAllFromRay(e, t), s = /* @__PURE__ */ new Map();
    for (const o of i) {
      const a = o.getNodeId(), l = await this._model.getNodesBounding([a]);
      s.set(a, l.max.z);
    }
    const r = (o, a) => {
      const l = s.get(o.getNodeId()), c = s.get(a.getNodeId());
      return l === void 0 || c === void 0 ? -1 : c - l;
    };
    return i.sort(r);
  }
  /**
   *  Will set the active state appropriately and kick off activation processing
   */
  async _activate() {
    this._active === oi.Inactive && (this._active = oi.Activating, await this._doUpdateActivation());
  }
  /**
   *  Deactivation will remove camera callbacks, hide the overlay, delete floornodes, and any other necessary cleanup
   */
  async _deactivate() {
    this._active !== oi.Inactive && (this._active = oi.Inactive, this._isCallbacksSet && (this._isCallbacksSet = !1, this._viewer.unsetCallbacks({
      camera: this._onCameraUpdateFunc,
      frameDrawn: this._onFrameDrawnFunc,
      transitionEnd: this._onCameraUpdateFunc
    })), this._isOverlayVisible = !1, await this._overlayManager.setVisibility(Vt.Floorplan, this._isOverlayVisible), this._borderNode && (await this._model.deleteNode(this._borderNode), this._borderNode = null), this._backgroundNode && (await this._model.deleteNode(this._backgroundNode), this._backgroundNode = null), await this._deleteAllFloorplans());
  }
  /**  This will be called anytime a model has loaded... first model, second model, etc. */
  async _onModelLoaded() {
    await this._sync.push(() => this._doOnModelLoaded());
  }
  /**
   * When a model is loaded, the active state will be examined and possibly modified here based on the incoming model.
   */
  async _doOnModelLoaded() {
    console.assert(this._isModelLoaded, "Model not loaded as expected");
    const n = this._model.getNodesByGenericType(this._genericStoreyType), t = n && n.size > 0;
    if (!t) {
      await this._deactivate();
      return;
    }
    this._active === oi.Inactive ? t && this._config.autoActivate === Xs.Bim && (this._active = oi.Activating) : this._active === oi.Active && (this._active = oi.Activating), this._active === oi.Activating && await this._doUpdateActivation();
  }
  /**
   *  This will activate the floorplan visuals if conditions allow.
   */
  async _doUpdateActivation() {
    this._active !== oi.Activating || !this._isSceneReady || !this._isModelLoaded || (this._active = oi.Active, this._isOverlayVisible || await this._setupOverlay(), await this._onProcessIfc(), this._isCallbacksSet || (this._isCallbacksSet = !0, this._viewer.setCallbacks({
      camera: this._onCameraUpdateFunc,
      frameDrawn: this._onFrameDrawnFunc,
      transitionEnd: this._onCameraUpdateFunc
    })));
  }
  /**
   *  Deletes all floorplan infos including generated nodes
   */
  async _deleteAllFloorplans() {
    const n = this._floorInfosArray.slice();
    this._floorInfos.clear(), this._floorInfosArray.length = 0, this._floorplanNode = null, this._currentFloorInfo = null;
    for (const t of n)
      t.floorplanNode && await this._model.deleteNode(t.floorplanNode);
  }
  /** Hides the currently active floorplan */
  async _hideActiveFloorplan() {
    this._floorplanNode !== null && (await this._hideOverlayNode(this._floorplanNode), this._floorplanNode = null, this._currentFloorInfo = null);
  }
  /**
   *  Call when IFC information is available from the model tree. Note that this call can happen multiple
   *  times within a session, thus it must be tolerant of existing data vs new data.
   */
  async _onProcessIfc() {
    console.assert(this._active === oi.Active), await this._gatherFloorInfos(), await this._doCameraUpdate();
  }
  /**
   */
  _hasFloorInfo(n) {
    return this._floorInfos.has(n);
  }
  /**
   */
  _getFloorInfo(n) {
    const t = this._floorInfos.get(n);
    return t === void 0 ? null : t;
  }
  /**
   * Creates floorplan related information from a floor node
   */
  async _createFloorInfo(n) {
    const t = new Array();
    this._gatherDescendentIfcNodes(n, Kn._ifcFloorTypes, t);
    const e = new Array();
    this._gatherDescendentIfcNodes(n, Kn._ifcSpaceTypes, e);
    const i = new Array();
    if (this._gatherDescendentIfcNodes(
      n,
      Kn._ifcFloorplanCreationTypes,
      i
    ), i.length === 0)
      return null;
    const s = await this._model.getNodesBounding(i, {
      bodyInstance: !0,
      pmiBody: !1,
      viewFrame: !1,
      tightBounding: this._tightBoundings
    }), r = new mm(
      n,
      s,
      t,
      e,
      i
    );
    return this._floorInfos.set(n, r), this._floorInfosArray.push(r), r;
  }
  /**
   *  Find the root floor nodes within the model.
   */
  async _gatherFloorInfos() {
    const n = this._model.getNodesByGenericType(Kn._genericStoreyType);
    if (n === null || n.size === 0) {
      await this._deactivate();
      return;
    }
    for (const t of us(n))
      this._hasFloorInfo(t) || await this._createFloorInfo(t);
    this._floorInfos.size === 0 && await this._deactivate();
  }
  /**
   * Gathers all descendent nodes that have IFC types matching the given IFC types
   */
  _gatherDescendentIfcNodes(n, t, e) {
    const i = this._model.getNodeChildren(n);
    for (const s of i) {
      const r = this._model.getNodeGenericType(s);
      r !== null && t.has(r) && e.push(s), this._gatherDescendentIfcNodes(s, t, e);
    }
  }
  /**
   * Creates a floorplan mesh from a FloorInfo object and returns the NodeId of the resulting mesh.
   * Note: This does not attach the created floorplan mesh to the FloorInfo param. That must be done after.
   */
  async _createFloorplanFromFloorInfo(n) {
    const t = this._model._gatherInstanceIncsFromNodeIds(
      n.floorplanMeshCreationNodes
    ), e = await this._engine.createFloorplanMesh(t), i = e[0], s = e[1];
    return this._modelStructure.createMeshInstance(
      i,
      s,
      "floorplan",
      null,
      !0,
      !0,
      !1
    );
  }
  /** We need to handle a canvas size updates, so use the frame-drawn callback */
  async _onFrameDrawn() {
    const n = this._viewer.view.getCanvasSize();
    n.equals(this._canvasSize) || (this._canvasSize = n.copy(), this._isOverlayVisible && (this._isOverlayVisible = !1, await this._setupOverlay()));
  }
  /** Updates the overlay camera based on current state */
  async _doCameraUpdate() {
    if (this.isActive()) {
      this._floorLock || await this._setFloorplanFromPosition(this._viewer.view.getCamera().getPosition());
      try {
        this._viewer.pauseRendering(), await this._updateOverlay();
      } finally {
        this._viewer.resumeRendering();
      }
    }
  }
  /**
   * Returns `true` if the [[FloorplanManager]] is fully active.
   */
  isActive() {
    return this._active === oi.Active;
  }
  /** Call anytime something in the floorplan overlay might need to change. */
  async _updateOverlay() {
    if (!this.isActive())
      return;
    const n = this._viewer.view.getCamera(), t = n.getPosition();
    let e = d.subtract(n.getTarget(), t);
    e.z = 0, e.normalize(), (isNaN(e.x) || e.length() === 0) && (e = new d(0, 1, 0)), await this._updateOverlayCamera(t, e), await this._updateOverlayNodes(t, e);
  }
  /**
   * Call anytime something in the floorplan overlay might need to change.
   */
  async _updateOverlayNodes(n, t) {
    const e = this._model, i = this._config, s = this._model.getNodeUnitMultiplier(this._model.getAbsoluteRootNode()) * 304.8, r = this._getOverlaySizeInPixels(), o = r.x / r.y, a = s * i.overlayFeetPerPixel / i.zoomLevel, l = a / o;
    let c = a * r.x, h = c / o;
    if (!i.trackCameraEnabled) {
      const C = this._getFixedCameraSize(o);
      C !== null && (c = C.x, h = C.y);
    }
    const u = new Q().setTranslationComponent(
      n.x,
      n.y,
      Kn._avatarZ
    ), p = s * i.avatarScale, m = new Q().setScaleComponent(p, p, p), g = new Q();
    g.m[0] = t.y, g.m[1] = -t.x, g.m[2] = 0, g.m[4] = t.x, g.m[5] = t.y, g.m[6] = 0, g.m[8] = 0, g.m[9] = 0, g.m[10] = 1, await this._viewer.model.setNodeMatrix(
      this._avatarNode,
      Nc([u, g, m])
    ), this._avatarDirty && (i.customAvatar === null && (e.setNodesFaceColor([this._avatarNode], i.avatarColor), e.setNodesLineColor([this._avatarNode], i.avatarOutlineColor), e.setNodesOpacity([this._avatarNode], i.avatarOpacity)), this._avatarDirty = !1), this._borderDirty && (e.setNodesLineColor([this._borderNode], i.borderColor), e.setNodesOpacity([this._borderNode], i.borderOpacity), this._borderDirty = !1), this._backgroundDirty && (e.setNodesFaceColor([this._backgroundNode], i.backgroundColor), e.setNodesOpacity([this._backgroundNode], i.backgroundOpacity), this._backgroundDirty = !1);
    const _ = c - a, y = h - l, b = new Q().setScaleComponent(_, y, 1), w = new Q();
    if (!this._config.trackCameraEnabled && this._currentFloorInfo !== null) {
      const C = this._currentFloorInfo.bounds.center();
      w.setTranslationComponent(C.x, C.y, 0);
    } else
      w.setTranslationComponent(n.x, n.y, 0);
    const v = this._config.floorplanOrientation === Vr.AvatarUp ? Nc([w, g, b]) : Q.multiply(b, w);
    await this._viewer.model.setNodeMatrix(this._borderNode, v), await this._viewer.model.setNodeMatrix(this._backgroundNode, v);
  }
  /**
   * Moves the camera such that the avatar will appear at the provided point on the overlay.
   * This is only available when the floorplan is not tracking the camera.
   * @param point Point in canvas within overlay
   */
  snapAvatarToPoint(n) {
    if (this._currentFloorInfo === null || !this.insideOverlay(n))
      return;
    if (this._config.trackCameraEnabled) {
      console.log(
        "FP: snapAvatarToPoint: currently only supported when trackCameraEnabled is false"
      );
      return;
    }
    const t = this._getOverlaySizeInPixels(), e = this._getOverlayOffsetInPixels(), i = new E(n.x - e.x, n.y - e.y), s = this._currentFloorInfo.bounds, r = s.extents(), o = r.x / r.y, a = t.x / t.y, l = this._viewer.view.getCamera(), c = l.getPosition(), h = l.getTarget();
    let u = new Q();
    if (this._config.floorplanOrientation !== Vr.NorthUp) {
      const b = d.subtract(h, c), w = new d(b.x, b.y, 0).normalize(), v = new d(0, 1, 0), C = new d(-1, 0, 0), k = Yn(C, w) > 90 ? new d(0, 0, -1) : new d(0, 0, 1), Y = Yn(v, w);
      u = Q.createFromOffAxisRotation(k, Y);
    }
    let p, m;
    a > o ? (p = r.y / t.y, m = new E(
      s.center().x - r.y / 2 * a,
      s.center().y + r.y / 2
    )) : (p = r.x / t.x, m = new E(
      s.center().x - r.x / 2,
      s.center().y + r.x / 2 / a
    ));
    let g = new d(
      i.x * p + m.x,
      m.y - i.y * p,
      c.z
    );
    g = u.transform(g);
    const _ = d.subtract(h, c), y = d.add(g, _);
    l.setPosition(g), l.setTarget(y), l.setProjection(te.Perspective), this._viewer.view.setCamera(l);
  }
  /** Figure out the pixel size of the overlay window */
  _getOverlaySizeInPixels() {
    const n = new Fs(
      this._config.overlaySize.x,
      this._config.overlayWidthUnit,
      this._config.overlaySize.y,
      this._config.overlayHeightUnit
    );
    return this._viewer.overlayManager._toPixelPoint(n);
  }
  /** Get overlay offset in pixels */
  _getOverlayOffsetInPixels() {
    const n = this._overlayManager.getViewportPixelOffsetInCanvas(
      Vt.Floorplan
    );
    return n === null ? E.zero() : n;
  }
  _getFixedCameraSize(n) {
    if (this._currentFloorInfo !== null) {
      const t = this._currentFloorInfo.bounds.extents();
      return t.x / t.y > n ? new E(t.x, t.x / n) : new E(t.y * n, t.y);
    }
    return null;
  }
  /** Updates the camera settings for the overlay. Only update if the floorplan has changed?  */
  async _updateOverlayCamera(n, t) {
    const e = this._config, i = this._getOverlaySizeInPixels(), s = i.x / i.y;
    let a = this._model.getNodeUnitMultiplier(this._model.getAbsoluteRootNode()) * 304.8 * e.overlayFeetPerPixel / e.zoomLevel * i.x, l = a / s;
    if (!e.trackCameraEnabled) {
      const h = this._getFixedCameraSize(s);
      h !== null && (a = h.x, l = h.y);
    }
    const c = new ci();
    if (c.setWidth(a), c.setHeight(l), !this._config.trackCameraEnabled && this._currentFloorInfo !== null) {
      const h = this._currentFloorInfo.bounds.center();
      c.setTarget(new d(h.x, h.y, 0)), c.setPosition(new d(h.x, h.y, 10));
    } else
      c.setTarget(new d(n.x, n.y, 0)), c.setPosition(new d(n.x, n.y, 10));
    e.floorplanOrientation === Vr.AvatarUp ? c.setUp(t) : e.floorplanOrientation === Vr.NorthUp && c.setUp(new d(0, 1, 0)), await this._overlayManager.setCamera(Vt.Floorplan, c);
  }
  /**
   * Sets the current floorplan based on the floorNode.
   *
   * @param floorNode A IFC Story node.
   */
  async _setFloorplanFromFloorNode(n) {
    await this._hideActiveFloorplan();
    const t = this._hasFloorInfo(n) ? this._getFloorInfo(n) : await this._createFloorInfo(n);
    if (t !== null) {
      if (t.floorplanNode === null) {
        const e = await this._createFloorplanFromFloorInfo(t), i = new Q();
        await this._model.setNodeMatrix(e, i, !0), await this._overlayManager.addNodes(Vt.Floorplan, [e]), t.floorplanNode = e, this._floorplanNode = e, this._currentFloorInfo = t, await this._showOverlayNode(e);
      } else
        this._floorplanNode = t.floorplanNode, this._currentFloorInfo = t, await this._showOverlayNode(t.floorplanNode);
      await this._updateOverlay();
    }
  }
  /**
   *  Creates the floorplan overlay
   */
  async _setupOverlay() {
    const n = this._config;
    console.assert(this.isActive());
    const t = this._overlayManager;
    this._isOverlayVisible = !0, await t.setViewport(
      Vt.Floorplan,
      n.overlayAnchor,
      n.overlayOffset.x,
      n.overlayOffsetXUnit,
      n.overlayOffset.y,
      n.overlayOffsetYUnit,
      n.overlaySize.x,
      n.overlayWidthUnit,
      n.overlaySize.y,
      n.overlayHeightUnit
    ), await t.setVisibility(Vt.Floorplan, this._isOverlayVisible), this._avatarNode || (this._avatarNode = this._config.customAvatar = this._config.customAvatar ?? await this._createAvatar(), this._modelStructure.preventNodeDeletion(this._avatarNode), await this._overlayManager.addNodes(Vt.Floorplan, [this._avatarNode])), this._borderNode || (this._borderNode = await this._create2dBox(!0, !1, Kn._borderZ), await this._overlayManager.addNodes(Vt.Floorplan, [this._borderNode]), this._borderDirty = !0), this._backgroundNode || (this._backgroundNode = await this._create2dBox(!1, !0, Kn._backgroundZ), await this._overlayManager.addNodes(Vt.Floorplan, [this._backgroundNode]), this._backgroundDirty = !0), await this._updateOverlay();
  }
  /** Nodes within the the overlay displays aren't honoring their visibility settings. This is a workaround
   *  until that problem is fixed. Since the floorplan is a top-down view, we can just move "hidden" nodes
   *  far enough out of the camera view so they aren't rendered.
   */
  async _hideOverlayNode(n) {
    const t = new Q();
    t.setTranslationComponent(1e30, 0, 0), await this._model.setNodeMatrix(n, t, !0);
  }
  /** See _hideOverlayNode for workaround description */
  async _showOverlayNode(n) {
    await this._model.setNodeMatrix(n, new Q(), !0);
  }
  /** Creates a simple node to show the camera-position as an avatar on the overlay */
  async _createAvatar() {
    const n = this._config.fixedAvatarScale ? 1e4 : 1, t = 1.2 / n, e = 1.5 / n, i = -1.1 / n, s = [
      0,
      e,
      0,
      -t,
      -e,
      0,
      0,
      i,
      0,
      0,
      e,
      0,
      0,
      i,
      0,
      t,
      -e,
      0
    ], r = [
      -t,
      -e,
      0,
      0,
      e,
      0,
      t,
      -e,
      0,
      0,
      i,
      0,
      -t,
      -e,
      0
    ], o = new Hi();
    o.setBackfacesEnabled(!1), o.addFaces(s, void 0, void 0, void 0), o.addPolyline(r, void 0);
    const a = await this._viewer.model.createMesh(o), l = new bn(a), c = (this._config.fixedAvatarScale ? St.SuppressCameraScale : St.None) | St.ExcludeBounding;
    return l.setCreationFlags(c), await this._viewer.model.createMeshInstance(
      l,
      null,
      !0,
      !0
    );
  }
  /** Create a 2d line based box. Used for the overlay border & background */
  async _create2dBox(n, t, e) {
    const a = new Hi();
    if (n) {
      const u = [
        -0.5,
        -0.5,
        e,
        -0.5,
        0.5,
        e,
        0.5,
        0.5,
        e,
        0.5,
        -0.5,
        e,
        -0.5,
        -0.5,
        e
      ];
      a.addPolyline(u, void 0);
    }
    if (t) {
      const u = [
        0.5,
        -0.5,
        e,
        0.5,
        0.5,
        e,
        -0.5,
        0.5,
        e,
        -0.5,
        0.5,
        e,
        -0.5,
        -0.5,
        e,
        0.5,
        -0.5,
        e
      ], p = [
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1
      ];
      a.addFaces(u, p), a.setBackfacesEnabled(!1);
    }
    const l = await this._viewer.model.createMesh(a), c = new bn(l);
    return c.setCreationFlags(
      St.ExcludeBounding | St.DoNotReset
    ), await this._viewer.model.createMeshInstance(c, null, !0, !0);
  }
};
let ys = Kn;
ys._genericStoreyType = "IFCBUILDINGSTOREY";
ys._ifcFloorTypes = /* @__PURE__ */ new Set(["IFCSLAB"]);
ys._ifcSpaceTypes = /* @__PURE__ */ new Set(["IFCSPACE"]);
ys._ifcFloorplanCreationTypes = /* @__PURE__ */ new Set([
  "IFCWALL",
  "IFCWALLSTANDARDCASE",
  "IFCCURTAINWALL",
  "IFCSLAB",
  "IFCCOLUMN"
]);
ys._backgroundZ = -1;
ys._avatarZ = 1;
ys._borderZ = 2;
const U0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ActiveState: oi,
  FloorInfo: mm,
  FloorplanAutoActivation: Xs,
  FloorplanConfig: Wa,
  FloorplanManager: ys,
  clamp: kr,
  isPointInBox: dm,
  isPointInBoxOnlyZ: Lc,
  multiplyMatrices: Nc
}, Symbol.toStringTag, { value: "Module" }));
class zl {
  constructor() {
    this._date = /* @__PURE__ */ new Date(), this._handled = !1;
  }
  /**
   * Gets the handled state of the event
   * @returns whether the event has been handled
   */
  getHandled() {
    return this._handled;
  }
  /**
   * Sets the handled state of the event. When an event has been handled it will not propagate any further
   * @param handled Indicates whether this event has been handled.
   */
  setHandled(t) {
    this._handled = t;
  }
  /**
   * Gets the Date this event occurred
   * @returns the event Date
   */
  getDate() {
    return this._date;
  }
}
class Xc extends zl {
  /** @hidden */
  constructor(t, e, i) {
    super(), this._keyCode = t, this._eventType = i;
  }
  /**
   * gets the key code
   * @returns the key code of the event
   */
  getKeyCode() {
    return this._keyCode;
  }
  /**
   * gets the event type
   * @returns the type of key event
   */
  getEventType() {
    return this._eventType;
  }
}
class Ph extends zl {
  /** @hidden */
  constructor(t, e, i, s) {
    super(), this._position = new E(t, e), this._modifiers = i, this._inputType = s;
  }
  /**
   * gets the window position of the mouse pointer for this event
   * @returns the mouse position for this event
   */
  getPosition() {
    return this._position.copy();
  }
  /**
   * gets the state of the shift key
   * @returns whether the shift key was down when this event was generated
   */
  shiftDown() {
    return (this._modifiers & ye.Shift) === ye.Shift;
  }
  /**
   * gets the state of the alt key
   * @returns whether the alt key was down when this event was generated
   */
  altDown() {
    return (this._modifiers & ye.Alt) === ye.Alt;
  }
  /**
   * gets the state of the control key
   * @returns whether the control key was down when this event was generated
   */
  controlDown() {
    return (this._modifiers & ye.Control) === ye.Control;
  }
  /**
   * gets the state of the command key
   * @returns whether the command key was down when this event was generated
   */
  commandDown() {
    return (this._modifiers & ye.Command) === ye.Command;
  }
  /**
   * gets the event type
   * @returns the type of mouse event
   */
  getEventType() {
    return this._inputType;
  }
  /**
   * gets the event modifiers
   * @returns bitwise combination of KeyModifiers
   */
  getModifiers() {
    return this._modifiers;
  }
}
class Qn extends Ph {
  /**
   * Mouse Event class
   * @param positionX X window position of the mouse
   * @param positionY Y window position of the mouse
   * @param button mouse button associated with this event
   * @param buttons mouse buttons currently pressed with this event
   * @param modifiers bitwise collection of values from KeyModifiers enum
   * @param inputType the type of the event
   */
  constructor(t, e, i, s, r, o) {
    super(t, e, r, o), this._button = i, this._buttons = s;
  }
  /**
   * gets the mouse button associated with this event
   * @returns the mouse button for this event
   */
  getButton() {
    return this._button;
  }
  /**
   * gets the mouse buttons currently pressed with this event
   * @returns the mouse buttons currently pressed for this event
   */
  getButtons() {
    return this._buttons;
  }
}
class fm extends Ph {
  /**
   * Mousewheel Event class
   * @param positionX X window position of the mouse
   * @param positionY Y window position of the mouse
   * @param wheelDelta the direction the mouse wheel moved
   * @param buttons mouse buttons currently pressed with this event
   * @param modifiers bitwise collection of values from KeyModifiers enum
   * @param inputType the type of the event
   * @hidden
   */
  constructor(t, e, i, s, r, o) {
    super(t, e, r, o), this._wheelDelta = i, this._buttons = s;
  }
  /**
   * Gets the wheel delta for this event. A positive value indicates that the wheel was scrolled Up, while a negative value indicated the wheel was scrolled down.
   * @returns Wheel dela value
   */
  getWheelDelta() {
    return this._wheelDelta;
  }
  /**
   * gets the mouse buttons currently pressed with this event
   * @returns the mouse buttons currently pressed for this event
   */
  getButtons() {
    return this._buttons;
  }
}
var ls = /* @__PURE__ */ ((n) => (n[n.Dec = 0] = "Dec", n[n.Inc = 1] = "Inc", n))(ls || {});
function Fc(n, t) {
  if (t.getNodeType(n) === At.BodyInstance) {
    let e = n;
    for (; e !== null; ) {
      if (t.getNodeGenericId(e) !== null)
        return e;
      e = t.getNodeParent(e);
    }
  }
  return n;
}
class Ml {
  constructor(t, e, i) {
    this.faceItem = t, this.lineItem = e, this.pointItem = i;
  }
  /**
   * Returns the most relevant selection item for the provided selection mask.
   * The priority used by this method is points -> lines -> faces.
   * For example, if your selection mask was Faces | Lines and this item contained and all fields were populated, this method would return its lineItem.
   * @param mask a selection mask used to indicate the relevancy of the item to retrieve.
   * @returns the most relevant selection item if one exists.  If no relevant item is found, null is returned.
   */
  fetchMostRelevant(t) {
    return this.pointItem !== null && t & Xt.Point ? this.pointItem : this.lineItem !== null && t & Xt.Line ? this.lineItem : this.faceItem !== null && t & Xt.Face ? this.faceItem : null;
  }
}
class Pa {
  /** @hidden */
  constructor(t, e, i, s, r, o, a) {
    this._position = t.copy(), this._normal = e.copy(), this._elementIndex = i, this._elementBits = r, this._bounding = o.copy(), this._overlayIndex = s, this._isProximityFace = a;
  }
  /**
   * Returns whether or not this face entity was selected by proximity or was instead selected dead-on.
   * @returns True if this face entity was selected by proximity and false otherwise.
   */
  isProximityFace() {
    return this._isProximityFace;
  }
  /**
   * Returns whether or not this face entity is capping geometry or not.
   * @returns True if this face entity is capping geometry and false otherwise.
   */
  isCappingGeometry() {
    return this._elementIndex === -1;
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      position: this._position.toJson(),
      normal: this._normal.toJson(),
      cadFaceIndex: this._elementIndex,
      cadFaceBits: this._elementBits,
      bounding: this._bounding.toJson(),
      overlayIndex: this._overlayIndex,
      isProximityFace: this._isProximityFace
    };
  }
  /**
   * Creates a new [[FaceEntity]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t) {
    const e = t, i = d.fromJson(e.position), s = d.fromJson(e.normal), r = ni.fromJson(e.bounding), o = e.overlayIndex, a = e.isProximityFace === !0;
    return new Pa(
      i,
      s,
      e.cadFaceIndex,
      o,
      e.cadFaceBits,
      r,
      a
    );
  }
  /**
   * Gets the world space position of the selection point.
   * @returns World space position of the selection point if it can be determined.
   */
  getPosition() {
    return this._position.copy();
  }
  /**
   * Gets the face normal for the selection Point.
   * @returns Face normal for the selection position if it can be determined.
   */
  getNormal() {
    return this._normal.copy();
  }
  /**
   * Gets the cad face index for the selection Point.
   * @returns The index for the cad face.
   */
  getCadFaceIndex() {
    return this._elementIndex;
  }
  /**
   * Gets the cad face bits for the selection Point.
   * @returns The bits set on the cad face.
   */
  getCadFaceBits() {
    return this._elementBits;
  }
  /**
   * Gets the bounding box for the face entity
   * @returns Bounding box for the face entity
   */
  getBounding() {
    return this._bounding.copy();
  }
  /**
   * @returns The index of the overlay the entity belongs to.
   */
  overlayIndex() {
    return this._overlayIndex;
  }
}
class wo {
  constructor(t) {
    this._handle = t;
  }
}
class Ga {
  /** @hidden */
  constructor(t, e, i, s, r, o, a) {
    if (this._lineSegmentVertices = [], this._elementIndex = t, this._elementBits = a, this._position = e.copy(), this._bounding = r.copy(), this._overlayIndex = o, i) {
      if (s >= 0) {
        const l = 3 * s;
        this._bestLineSegmentVertexIndex = new d(
          i[l],
          i[l + 1],
          i[l + 2]
        );
      }
      this._lineSegmentVertices.push(
        new d(i[0], i[1], i[2])
      );
      for (let l = 3; l < i.length; l += 6)
        this._lineSegmentVertices.push(
          new d(i[l], i[l + 1], i[l + 2])
        );
    }
  }
  isCappingGeometry() {
    return this._elementIndex < 0;
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    const t = [];
    for (const e of this._lineSegmentVertices)
      t.push(e.toJson());
    return {
      lineId: this._elementIndex,
      lineBits: this._elementBits,
      position: this._position.toJson(),
      linePoints: t,
      bounding: this._bounding.copy(),
      overlayIndex: this._overlayIndex
    };
  }
  /**
   * Creates a new [[LineEntity]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t) {
    const e = t, i = d.fromJson(e.position), s = ni.fromJson(e.bounding), r = e.overlayIndex, o = new Ga(e.lineId, i, null, -1, s, r, 0);
    for (const a of e.linePoints) {
      const l = d.fromJson(a);
      o._lineSegmentVertices.push(l);
    }
    return o;
  }
  /**
   * Gets the line identifier
   * @returns the identifier of the line that was selected
   */
  getLineId() {
    return this._elementIndex;
  }
  /**
   * Gets the closest point on the selected line
   * @returns the closest point on the line
   */
  getPosition() {
    return this._position.copy();
  }
  getPoints() {
    return this._lineSegmentVertices;
  }
  /**
   * Returns the vertex of the line that is closest to the selection
   * point.
   *
   * Clipped vertices are skipped. If the vertex is occluded, then
   * `null` is returned.
   */
  getBestVertex() {
    return this._bestLineSegmentVertexIndex ? this._bestLineSegmentVertexIndex.copy() : null;
  }
  /**
   * Gets the kine bits for the selection Point.
   * @returns The bits set on the line/edge.
   */
  getLineBits() {
    return this._elementBits;
  }
  /**
   * Gets the bounding box for the line entity
   * @returns Bounding box for the line entity
   */
  getBounding() {
    return this._bounding.copy();
  }
  /**
   * @returns The index of the overlay the entity belongs to.
   */
  overlayIndex() {
    return this._overlayIndex;
  }
}
class _m {
  constructor() {
    this.none = 0, this.face = 0, this.line = 0, this.point = 0, this.part = 0;
  }
  update(t, e) {
    switch (t.getSelectionType()) {
      case pi.None:
        e === ls.Dec ? --this.none : ++this.none;
        break;
      case pi.Face:
        e === ls.Dec ? --this.face : ++this.face;
        break;
      case pi.Line:
        e === ls.Dec ? --this.line : ++this.line;
        break;
      case pi.Point:
        e === ls.Dec ? --this.point : ++this.point;
        break;
      case pi.Part:
        e === ls.Dec ? --this.part : ++this.part;
        break;
    }
  }
  sum() {
    return this.none + this.face + this.line + this.point + this.part;
  }
}
class Ya {
  /** @hidden */
  constructor(t, e, i, s) {
    this._position = t.copy(), this._elementIndex = e, this._overlayIndex = i, this._elementBits = s;
  }
  /**
   * Creates a new [[PointEntity]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t) {
    const e = t, i = d.fromJson(e.position), s = e.overlayIndex;
    return new Ya(i, e.pointId, e.pointBits, s);
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      pointId: this._elementIndex,
      pointBits: this._elementBits,
      position: this._position.toJson(),
      overlayIndex: this._overlayIndex
    };
  }
  /**
   * Gets the world space position of the selection point.
   * @returns World space position of the selection point if it can be determined.
   */
  getPosition() {
    return this._position.copy();
  }
  /**
   * Gets the cad bits for the selection Point.
   * @returns The bits set on the point.
   */
  getPointBits() {
    return this._elementBits;
  }
  /**
   * Gets the point identifier
   * @returns the identifier of the point that was selected
   */
  getPointId() {
    return this._elementIndex;
  }
  /**
   * @returns The index of the overlay the entity belongs to.
   */
  overlayIndex() {
    return this._overlayIndex;
  }
}
class de {
  /** @hidden */
  constructor(t = null, e = null, i = null, s = null, r = null) {
    this._nodeId = t, this._inclusionKey = e, this._faceEntity = i, this._lineEntity = s, this._pointEntity = r;
  }
  static create(t, e, i, s, r) {
    return new de(t, e, i, s, r);
  }
  getSelectionType() {
    return this._nodeId === null ? pi.None : this._faceEntity !== null ? pi.Face : this._lineEntity !== null ? pi.Line : this._pointEntity !== null ? pi.Point : pi.Part;
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      nodeId: this._nodeId,
      includeId: this._inclusionKey,
      faceEntity: this._faceEntity ? this._faceEntity.toJson() : null,
      lineEntity: this._lineEntity ? this._lineEntity.toJson() : null,
      pointEntity: this._pointEntity ? this._pointEntity.toJson() : null
    };
  }
  /** @hidden */
  static _fromJson(t) {
    const e = t;
    return new de(
      e.nodeId,
      e.includeId,
      e.faceEntity ? Pa.fromJson(e.faceEntity) : null,
      e.lineEntity ? Ga.fromJson(e.lineEntity) : null,
      e.pointEntity ? Ya.fromJson(e.pointEntity) : null
    );
  }
  /**
   * Gets the face entity for this selection.
   * @returns the face entity if one was selected, otherwise null
   */
  getFaceEntity() {
    return this._faceEntity;
  }
  /**
   * Gets the line entity for this selection.
   * @returns the line entity if one was selected, otherwise null
   */
  getLineEntity() {
    return this._lineEntity;
  }
  /**
   * Gets the point entity for this selection.
   * @returns the point entity if one was selected, otherwise null
   */
  getPointEntity() {
    return this._pointEntity;
  }
  /**
   * Gets the part id for this selection.
   * @returns the part id associated with this selection item
   */
  getNodeId() {
    return this._nodeId ?? jd;
  }
  /**
   * Gets the include id for this selection.
   * @returns the inclusion key associated with this selection item
   */
  getInclusionKey() {
    return this._inclusionKey;
  }
  /**
   * Convenience method for getting the world space position of the selection point.
   * [[SelectionItem]]s with a type of [[SelectionType.Part]] will not have a position and null will be returned.
   * @returns World space position of the selection point if it can be determined.
   */
  getPosition() {
    return this._faceEntity !== null ? this._faceEntity.getPosition() : this._lineEntity !== null ? this._lineEntity.getPosition() : this._pointEntity !== null ? this._pointEntity.getPosition() : null;
  }
  /**
   * Gets the overlay index for this selection.
   * @returns the overlay index associated with this selection item
   */
  overlayIndex() {
    return this._faceEntity ? this._faceEntity.overlayIndex() : this._lineEntity ? this._lineEntity.overlayIndex() : this._pointEntity ? this._pointEntity.overlayIndex() : null;
  }
  /** @hidden */
  _setNodeId(t) {
    this._nodeId = t;
  }
  /**
   * Determines if two selection items are equal.
   * @param selectionItem The selection item to test against.
   * @returns whether or not the two items are equal.
   */
  equals(t) {
    return this._nodeId !== t._nodeId || this.getSelectionType() !== t.getSelectionType() ? !1 : this._faceEntity && t._faceEntity ? this._faceEntity.getCadFaceIndex() === t._faceEntity.getCadFaceIndex() : this._lineEntity && t._lineEntity ? this._lineEntity.getLineId() === t._lineEntity.getLineId() : this._pointEntity && t._pointEntity ? this._pointEntity.getPointId() === t._pointEntity.getPointId() : !0;
  }
  /** @hidden */
  _hash(t) {
    let e = this._nodeId !== null ? this._nodeId.toString(36) : "";
    return t || (e += `;${this.getSelectionType()};`, this._faceEntity && (e += this._faceEntity.getCadFaceIndex().toString(36)), e += ";", this._lineEntity && (e += this._lineEntity.getLineId().toString(36)), e += ";", this._pointEntity && (e += this._pointEntity.getPointId().toString(36))), e;
  }
  /**
   * @returns true if the object has the fields required for an [[EntitySelectionItem]].
   * This function can be used as a TypeScript [type guard](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards).
   */
  isEntitySelection() {
    return this._faceEntity !== null || this._lineEntity !== null || this._pointEntity !== null;
  }
  /**
   * @returns true if the object has the fields required for a [[NodeSelectionItem]].
   * This function can be used as a TypeScript [type guard](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards).
   */
  isNodeSelection() {
    return this._nodeId !== null;
  }
  /**
   * @returns true if the object has the fields required for a [[NodeEntitySelectionItem]].
   * This function can be used as a TypeScript [type guard](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards).
   */
  isNodeEntitySelection() {
    return this._nodeId !== null && this.isEntitySelection();
  }
  /**
   * @returns true if the object has the fields required for a [[FaceSelectionItem]].
   * This function can be used as a TypeScript [type guard](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards).
   */
  isFaceSelection() {
    return this._nodeId !== null && this._faceEntity !== null;
  }
  /**
   * @returns true if the object has the fields required for a [[LineSelectionItem]].
   * This function can be used as a TypeScript [type guard](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards).
   */
  isLineSelection() {
    return this._nodeId !== null && this._lineEntity !== null;
  }
  /**
   * @returns true if the object has the fields required for a [[PointSelectionItem]].
   * This function can be used as a TypeScript [type guard](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards).
   */
  isPointSelection() {
    return this._nodeId !== null && this._pointEntity !== null;
  }
}
class ym {
  constructor(t) {
    this.futureItemHash = null, this.pastItemHash = t;
  }
}
class Bl {
  /** @hidden */
  constructor(t, e, i, s, r) {
    this._selectedItemsPruned = /* @__PURE__ */ new Map(), this._selectedItemsFull = /* @__PURE__ */ new Map(), this._selectedNodeCounts = /* @__PURE__ */ new Map(), this._temporalLinks = /* @__PURE__ */ new Map(), this._oldestItemHash = null, this._newestItemHash = null, this._selectedLayers = /* @__PURE__ */ new Set(), this._selectedTypes = /* @__PURE__ */ new Set(), this._nodeSelectionColor = new it(255, 255, 0), this._nodeSelectionOutlineColor = new it(255, 255, 0), this._elementSelectionColor = it.red(), this._elementSelectionOutlineColor = it.red(), this._nodeHighlightMode = Ln.HighlightAndOutline, this._nodeElementHighlightMode = Ln.HighlightAndOutline, this._highlightNodeSelection = !0, this._highlightFaceElementSelection = !0, this._highlightLineElementSelection = !0, this._highlightPointElementSelection = !0, this._selectParentIfSelected = !0, this._pruneSelectionDescendants = !0, this._ignoreEntityWhenTogglingChildSelection = !0, this._singleEntityToggleMode = !1, this._suppressImplicitRemovalCallback = !1, this._selectionFilter = null, this._incrementalBlacklistedInstanceNodes = /* @__PURE__ */ new Set(), this._engine = e, this._view = i, this._model = s, this._modelStructure = r, this._callbackManager = t, this._callbackManager.bind({
      _subtreeLoaded: (o) => {
        for (const a of o)
          this._onSubtreeLoaded(a);
        return Promise.resolve();
      }
    });
  }
  /** * @hidden */
  _init() {
    this._updateHighlightingMode(), this._engine.setHighlightColorizeCompression(0.7);
  }
  /**
   * This allows manipulating the selected NodeId.
   * To reset the filter, set it to null.
   * @param selectionFilter function that manipulates the selected NodeId.
   */
  setSelectionFilter(t) {
    this._selectionFilter = t;
  }
  /**
   * @returns [[SelectionFilter]] function or null if none is set.
   */
  getSelectionFilter() {
    return this._selectionFilter;
  }
  /**
   * Enables / disables descendant pruning and clears the current selection set.  When enabled, a parent and child will not be present in the same selection set.  This behavior is enabled by default.
   */
  setPruneSelectionDescendants(t) {
    this._pruneSelectionDescendants = t, this.clear();
  }
  /**
   * Gets whether descendant pruning is enabled.
   * See also: [[setPruneSelectionDescendants]]
   */
  getPruneSelectionDescendants() {
    return this._pruneSelectionDescendants;
  }
  /**
   * Enables / disables automatic parent selection.  When enabled, if a selected part is selected again, its parent will be selected.  This behavior is enabled by default.
   */
  setSelectParentIfSelected(t) {
    this._selectParentIfSelected = t;
  }
  /**
   * Gets whether automatic parent selection is enabled.
   * See also: [[setSelectParentIfSelected]]
   */
  getSelectParentIfSelected() {
    return this._selectParentIfSelected;
  }
  /**
   * Enables / disables ignore entity when toggling child selection mode.
   *
   * When enabled, a [[NodeSelectionItem]] that has a selected ancestor may only be toggled if it does not contain an entity selection.
   * A selection item without an entity selection is usually generated from selecting a node via a model tree control.
   * A selection item containing an entity selection is usually generated as a result of a viewport picking operation.
   *
   * This behavior is enabled by default.
   * See Also: [[toggle]]
   */
  setIgnoreEntityWhenTogglingChildSelection(t) {
    this._ignoreEntityWhenTogglingChildSelection = t;
  }
  /**
   * Gets whether ignore entity when toggling child selection mode is enabled.
   * See also: [[setIgnoreEntityWhenTogglingChildSelection]]
   */
  getIgnoreEntityWhenTogglingChildSelection() {
    return this._ignoreEntityWhenTogglingChildSelection;
  }
  /**
   * Enables / disables single entity toggle mode.
   *
   * When enabled, limits the selection set to containing only one entity selection for each node id.
   * Toggling with an entity selection that has the same node id as a [[NodeSelectionItem]]
   * already in the selection set will remove that item from the selection set.
   *
   * This behavior is disabled by default.
   * See Also: [[toggle]]
   */
  setSingleEntityToggleModeEnabled(t) {
    this._singleEntityToggleMode = t, this.clear();
  }
  /**
   * Gets whether single entity toggle mode is enabled.
   * See also: [[setSingleEntityToggleModeEnabled]]
   */
  getSingleEntityToggleModeEnabled() {
    return this._singleEntityToggleMode;
  }
  /**
   * Sets whether to generate selectionArray callbacks with implicitly removed nodes.
   *
   * For example, consider the case where you have a parent node that has a multiple child nodes.
   * Normally, if the parent begins selected and then a child is removed from the selection set
   * there will be two selectionArray callbacks generated. The first will for the removal of the
   * parent node. The second wil be for the addition of all of it's children except the one that was
   * initially removed.
   *
   * When this behavior is enabled only a single selectionArray callback will be generated for the
   * child node that was removed.
   *
   * This behavior is disabled by default.
   */
  setSuppressImplicitRemovalCallback(t) {
    this._suppressImplicitRemovalCallback = t;
  }
  /**
   * Gets whether implicit removal callbacks are being suppressed
   * See also: [[setSuppressImplicitRemovalCallback]]
   */
  getSuppressImplicitRemovalCallback() {
    return this._suppressImplicitRemovalCallback;
  }
  /**
   * Performs a selection operation from the given position on the canvas. The best candidate entity is selected.
   * This method triggers a selection event.
   * @param point The canvas position to select from.
   * @param config The configuration object used for this picking operation.
   * @param selectionMode The mode to use for this selection.
   * @returns Promise that resolves when this operation has completed.
   */
  async selectFromPoint(t, e, i = ai.Set) {
    const s = await this._view.pickFromPoint(t, e);
    this._onSelectionItem(s, i);
  }
  /**
   * Performs a selection operation from the given position on the canvas. All candidate entities are selected.
   * This method triggers a selection event.
   * @param point The canvas position to select from.
   * @param config The configuration object used for this picking operation.
   * @param selectionMode The mode to use for this selection.
   * @returns Promise that resolves when this operation has completed.
   */
  async selectAllFromPoint(t, e, i = ai.Set) {
    const s = await this._view.pickAllFromPoint(t, e);
    this._onSelectionItems(s, i);
  }
  /**
   * Performs a selection operation from the given world-space ray. The best candidate entity is selected.
   * This method triggers a selection event.
   * @param ray The world-space ray to perform the selection with.
   * @param config The configuration object used for this picking operation.
   * @param selectionMode The mode to use for this selection.
   * @returns Promise that resolves when this operation has completed.
   */
  async selectFromRay(t, e, i = ai.Set) {
    const s = await this._view.pickFromRay(t, e);
    this._onSelectionItem(s, i);
  }
  /**
   * Performs a selection operation from the given world-space ray. All candidate entities are selected.
   * This method triggers a selection event.
   * @param ray The world-space ray to perform the selection with.
   * @param config The configuration object used for this picking operation.
   * @param selectionMode The mode to use for this selection.
   * @returns Promise that resolves when this operation has completed.
   */
  async selectAllFromRay(t, e, i = ai.Set) {
    const s = await this._view.pickAllFromRay(t, e);
    this._onSelectionItems(s, i);
  }
  _onSelectionItem(t, e) {
    t.isNodeEntitySelection() ? this._processSelection(t, e) : this._triggerNullSelection();
  }
  _onSelectionItems(t, e) {
    if (e === ai.Set && this.clear(!1), t.length === 0) {
      this._triggerNullSelection();
      return;
    }
    switch (e) {
      case ai.Add:
      case ai.Set:
        this.add(t);
        break;
      case ai.Toggle:
        for (const i of t)
          this.toggle(i);
        break;
      default:
        $n();
    }
  }
  /**
   * Creates a new and active selection context for the provided selection window.
   * @param areaCssMin The minimum coordinate in css pixel space for the selection window.
   * @param areaCssMax The maximum coordinate in css pixel space for the selection window.
   * @param config The configuration object used for this selection operation.
   * @returns The handle for the selection context.
   */
  beginScreenSelectByArea(t, e, i) {
    return this._view.beginScreenSelectByArea(t, e, i);
  }
  /**
   * Creates a new and active selection context for the provided selection ray.
   * The ray is created at the supplied ray origin and is cast into the scene.
   * Faces are selected if they lie along the ray.
   * Lines and points are selected if they lie within the ray's box radius.
   *
   * Note: Somewhat confusingly ray drill selection is actually a selection by volume.
   * The provided ray origin and radius are used to create a frustum to preform the selection.
   * This has some consequences. For example, the `SelectionResult`s returned by advancing a
   * ray drill selection will not have selection positions, since they were not selected at
   * a single point.
   * @param rayCssOrigin The coordinate in css pixel space for the selection ray's origin.
   * @param rayCssBoxRadius The radius around the ray in css pixel space used for line and point selection proximity.
   * @param config The configuration object used for this selection operation.
   * @returns The handle for the selection context.
   */
  beginRayDrillSelection(t, e, i) {
    return this._view.beginRayDrillSelection(t, e, i);
  }
  /**
   * Creates a new and active selection context for the provided selection volume.
   * The selection volume is a convex polyhedron defined by the bounded intersection of its half-spaces.
   * @param volumePlanes The planes used to define volume. A point p is inside the volume if and only if (plane.determineSide(p) == true) for all supplied planes.
   * @param heuristicOrigin A point used to compute distances against for ordering returned results. This is typically (but not necessarily) the center of the volume.
   * @param config The configuration object used for this selection operation.
   * @returns The handle for the selection context.
   */
  beginConvexPolyhedronSelection(t, e, i) {
    return this._view.beginConvexPolyhedronSelection(t, e, i);
  }
  /**
   * Creates a new and active selection context for the provided selection sphere.
   * @param sphereCenter The center of the selection sphere.
   * @param sphereRadius The radius of the selection sphere.
   * @param config The configuration object used for this selection operation.
   * @returns The handle for the selection context.
   */
  beginSphereSelection(t, e, i) {
    return this._view.beginSphereSelection(t, e, i);
  }
  /**
   * Deactivates and destroys the provided selection context.
   * @param handle The selection context to destroy.
   */
  endIncrementalSelection(t) {
    return this._callbackManager.trigger("incrementalSelectionEnd"), this._view.endIncrementalSelection(t), Promise.resolve();
  }
  /**
   * Adds the next batch of instances selected by the supplied selection
   * context to the selection set.
   *
   * @param handle The handle to an active area selection context.
   * @param predicate An optional function that returns `true` if a given
   * [[NodeSelectionItem]] should be added to the selection set. If
   * `false` is returned, the item will not be added.
   *
   * @returns `true` if there are possibly more items to select and
   * `false` if not.
   */
  async advanceIncrementalSelection(t, e = null) {
    let i = await this._view.advanceIncrementalSelection(t);
    if (i === null)
      return !1;
    if (e !== null) {
      const s = await Promise.all(i.map(e));
      i = i.filter((r, o) => s[o]);
    }
    return this.add(i), !0;
  }
  isSelected(t) {
    return this.contains(t) ? !0 : t.isNodeSelection() ? this._findAncestor(t) !== null : !1;
  }
  /**
   * Checks whether a node, or its parents, appear in the selection set or not.
   * Note: for the purposes of this function element selections on a node
   * are considered the same as node selection.
   * @param nodeId Node to check for
   * @returns `true` if the node or its parents appear in the selection set. `false` otherwise
   */
  isNodeSelected(t) {
    for (const i of this.getResults())
      if (i.getNodeId() === t)
        return !0;
    const e = de.create(t);
    return this._findAncestor(e) !== null;
  }
  contains(t) {
    return this._selectedItemsPruned.has(t._hash(this._singleEntityToggleMode));
  }
  /**
   * Checks if the parent of a selection item is in the selection set.
   * @param selectionItem
   * @returns parent selection item, or null if not found
   */
  containsParent(t) {
    return this._findAncestor(t);
  }
  _findAncestor(t) {
    if (this._selectedItemsPruned.size > 0)
      for (; ; ) {
        const e = this._model.getNodeParent(t.getNodeId());
        if (e === null)
          return null;
        t = de.create(e);
        const i = t._hash(this._singleEntityToggleMode);
        if (this._selectedItemsPruned.has(i))
          return t;
      }
    return null;
  }
  /**
   * Adds all items in a layer to the selection set.
   * @param layerName
   * @param selectionMode
   */
  selectLayer(t, e) {
    e === ai.Set && this.clear();
    const i = [], s = this._model.getLayerIdsFromName(t);
    if (s !== null)
      for (const o of s) {
        const a = this._model.getNodesFromLayer(o, !0);
        if (a !== null)
          for (const l of a)
            i.push(de.create(l));
      }
    const r = this._selectedLayers.has(t);
    e === ai.Toggle && r ? this.remove(i) : (this.add(i), this._selectedLayers.add(t));
  }
  /**
   * Gets all selected layers.
   */
  getSelectedLayers() {
    const t = [];
    return this._selectedLayers.forEach((e) => {
      t.push(e);
    }), t;
  }
  /**
   * Adds all items with an IFC type to the selection set.
   * @param genericType
   */
  selectType(t, e) {
    e === ai.Set && this.clear();
    const i = [], s = this._model.getNodesByGenericType(t);
    s !== null && s.forEach((o) => {
      i.push(de.create(o));
    });
    const r = this._selectedTypes.has(t);
    if (e === ai.Toggle && r)
      for (const o of i)
        this.remove(o);
    else
      this.add(i), this._selectedTypes.add(t);
  }
  /**
   * Gets all selected IFC types.
   */
  getSelectedTypes() {
    const t = [];
    return this._selectedTypes.forEach((e) => {
      t.push(e);
    }), t;
  }
  /**
   * Selects a node with the given Id.
   * @param nodeId nodeId of the node to select. Pass null to clear the selection.
   * @returns the selection type of this operation.
   */
  selectNode(t, e = ai.Set) {
    if (t !== null && this._modelStructure.isIdValid(t)) {
      const i = de.create(t);
      return this._processSelection(i, e), i.getSelectionType();
    } else
      return this._processSelection(null, e), pi.None;
  }
  _triggerNullSelection() {
    this._callbackManager.trigger("selectionArray", [], !1);
  }
  _isInAxisOverlay(t) {
    const i = t.getFaceEntity();
    if (i)
      return i.overlayIndex() === 1;
    const s = t.getLineEntity();
    if (s)
      return s.overlayIndex() === 1;
    const r = t.getPointEntity();
    return r ? r.overlayIndex() === 1 : !1;
  }
  _getNodeCounts(t) {
    const e = t.getNodeId();
    let i = this._selectedNodeCounts.get(e);
    return i || (i = new _m(), this._selectedNodeCounts.set(e, i)), i;
  }
  _addToFull(t, e) {
    for (; this._selectedItemsFull.set(e, t); ) {
      const i = this._model.getNodeParent(t.getNodeId());
      if (i === null)
        return;
      t = de.create(i), e = t._hash(this._singleEntityToggleMode);
    }
  }
  _addItems(t, e) {
    const i = t.length;
    if (i === 0)
      return;
    this._callbackManager.trigger("incrementalSelectionBatchBegin");
    const s = [];
    for (let r = 0; r < i; ++r) {
      const o = this._filterItem(t[r]);
      if (o !== null && this._addImpl(o, o._hash(this._singleEntityToggleMode))) {
        const a = new An(o);
        s.push(a);
      }
    }
    s.length === 0 ? this._triggerNullSelection() : e || this._callbackManager.trigger("selectionArray", s, !1), this._callbackManager.trigger("incrementalSelectionBatchEnd");
  }
  _addItem(t, e) {
    const i = this._filterItem(t);
    if (i !== null && this._addImpl(i, i._hash(this._singleEntityToggleMode))) {
      const s = new An(i);
      e || this._callbackManager.trigger("selectionArray", [s], !1);
    } else
      this._triggerNullSelection();
  }
  /**
   * Manually adds an item or array of items to the selection set.
   * Triggers a selection event.
   * @param itemOrItems A selectionItem or selectionItem array that will be added to the current selection set.
   * @param suppressCallback Optional boolean param to suppress the selectionArray callbacks calls to this generate.
   */
  add(t, e = !1) {
    if (t === null) {
      this._triggerNullSelection();
      return;
    }
    Array.isArray(t) ? this._addItems(t, e) : this._addItem(t, e);
  }
  _filterItem(t) {
    if (this._selectionFilter === null)
      return t;
    const e = t.getNodeId(), i = this._selectionFilter(e, this._model);
    return i === e ? t : i === null ? null : de.create(i);
  }
  _addImpl(t, e) {
    if (t.getSelectionType() === pi.None)
      return !1;
    if (this._isInAxisOverlay(t))
      return !0;
    if (this._selectedItemsPruned.has(e))
      return !1;
    if (this._pruneSelectionDescendants) {
      if (this._findAncestor(t) !== null)
        return !1;
      this._removeDescendants(t);
    }
    this._selectedItemsPruned.set(e, t), this._addToFull(t, e), this._getNodeCounts(t).update(t, ls.Inc);
    const i = this._newestItemHash;
    if (this._newestItemHash = e, this._oldestItemHash || (this._oldestItemHash = e), i !== null) {
      const r = this._temporalLinks.get(i);
      r && (r.futureItemHash = e);
    }
    const s = new ym(i);
    if (this._temporalLinks.set(e, s), this._updateItemHighlight(t, !0, !0), this._modelStructure.getType(t.getNodeId()) === At.Pmi) {
      const r = this._modelStructure.getPmiTopologyReferences(t.getNodeId());
      if (r !== null)
        for (const o of r) {
          const a = o.body.getRuntimeId(), l = o.faceIds;
          for (const h of l)
            this._model.setNodeFaceHighlighted(a, h, !0);
          const c = o.edgeIds;
          for (const h of c)
            this._model.setNodeLineHighlighted(a, h, !0);
        }
    }
    return !0;
  }
  _removeUpdateLayers(t) {
    if (this._selectedLayers.size > 0) {
      const e = t.getNodeId();
      if (e !== null) {
        const i = this._model.getNodeLayerId(e);
        if (i !== null) {
          const s = this._model.getLayerName(i);
          s !== null && this._selectedLayers.delete(s);
        }
      }
    }
  }
  _removeUpdateTypes(t) {
    if (this._selectedTypes.size > 0) {
      const e = t.getNodeId();
      if (e !== null) {
        const i = this._model.getNodeGenericType(e);
        i !== null && this._selectedTypes.delete(i);
      }
    }
  }
  _removeFromFull(t, e) {
    if (this._removeUpdateLayers(t), this._removeUpdateTypes(t), this._selectedItemsFull.delete(e)) {
      const i = this._model.getNodeChildren(t.getNodeId());
      for (const s of i) {
        const r = de.create(s);
        this._removeFromFull(r, r._hash(this._singleEntityToggleMode));
      }
    }
  }
  _removeItems(t, e) {
    const i = [];
    t.forEach((s) => {
      this._removeImpl(s, s._hash(this._singleEntityToggleMode)) && i.push(new An(s));
    }), e || this._callbackManager.trigger("selectionArray", i, !0);
  }
  _removeItem(t, e) {
    if (this._removeImpl(t, t._hash(this._singleEntityToggleMode))) {
      const i = new An(t);
      e || this._callbackManager.trigger("selectionArray", [i], !0);
    }
  }
  /**
   * Manually removes an item or an array of items from the selection set.
   * Triggers a selection event.
   * @param itemOrItems A selectionItem or an array of selection items that will be removed from the current selection set.
   * @param suppressCallback Optional boolean param to suppress the selectionArray callbacks calls to this generate.
   */
  remove(t, e = !1) {
    Array.isArray(t) ? this._removeItems(t, e) : this._removeItem(t, e);
  }
  /** hidden */
  _removeImpl(t, e) {
    if (this._singleEntityToggleMode) {
      const a = this._selectedItemsPruned.get(e);
      a && (t = a);
    }
    if (!this._selectedItemsPruned.delete(e))
      return !1;
    this._removeFromFull(t, e);
    const i = this._getNodeCounts(t);
    i.update(t, ls.Dec);
    const s = this._temporalLinks.get(e);
    if (s !== void 0) {
      if (this._temporalLinks.delete(e), s.pastItemHash !== null) {
        const a = this._temporalLinks.get(s.pastItemHash);
        a && (a.futureItemHash = s.futureItemHash);
      }
      if (s.futureItemHash !== null) {
        const a = this._temporalLinks.get(s.futureItemHash);
        a && (a.pastItemHash = s.pastItemHash);
      }
      this._oldestItemHash === e && (this._oldestItemHash = s.futureItemHash), this._newestItemHash === e && (this._newestItemHash = s.pastItemHash);
    }
    let r = !0;
    const o = !1;
    if (i.sum() === 0) {
      r = !1;
      const a = t.getNodeId();
      this._selectedNodeCounts.delete(a);
    }
    return this._updateItemHighlight(t, r, o), !0;
  }
  static _selectionItemIsFromModelBrowser(t) {
    return t.getFaceEntity() === null && t.getLineEntity() === null && t.getPointEntity() === null;
  }
  /**
   * Manually adds or removes an item from the selection set.
   * Triggers a selection event.
   * @param selectionItem A selectionItem that will be added or removed from the selection set.
   */
  toggle(t) {
    const e = this._filterItem(t);
    if (e === null)
      return;
    const i = this._findAncestor(e), s = e._hash(this._singleEntityToggleMode);
    if (i !== null) {
      if (Bl._selectionItemIsFromModelBrowser(t) ? this._removeImplicit(t, i, this._suppressImplicitRemovalCallback) : this._ignoreEntityWhenTogglingChildSelection || this._removeImplicit(
        de.create(e.getNodeId()),
        i,
        this._suppressImplicitRemovalCallback
      ), this._suppressImplicitRemovalCallback) {
        const r = new An(e);
        this._callbackManager.trigger("selectionArray", [r], !0);
      }
    } else if (this._selectedItemsPruned.has(s)) {
      if (this._removeImpl(e, s)) {
        const r = new An(t);
        this._callbackManager.trigger("selectionArray", [r], !0);
      }
    } else if (e !== null && this._addImpl(e, s)) {
      const r = new An(e);
      this._callbackManager.trigger("selectionArray", [r], !1);
    }
  }
  /**
   * Manually removes all currently selected items (if any) from the selection set and adds the supplied item.
   * Triggers a selection event.
   * @param selectionItem A selectionItem that will become the new selection item.
   */
  set(t) {
    this.clear(!1), this.add(t);
  }
  /**
   * Gets all current selection items.
   * @returns array of all selection items.
   */
  getResults() {
    const t = [];
    return this.each((e) => {
      t.push(e);
    }), t;
  }
  /**
   * Gets a selection at the specified index. The first selected item will be at index 0.
   * @param index index of selection item to get
   * @returns the selection result at the given index.
   */
  getResult(t) {
    const e = this.size();
    if (t < 0 || t >= e)
      return null;
    const i = e - t - 1;
    return t <= i ? this._getItemFromOldest(t) : this._getItemFromNewest(i);
  }
  _getItemFromOldest(t) {
    let e = this._oldestItemHash;
    for (; e; ) {
      if (t-- === 0)
        return this._selectedItemsPruned.get(e) || null;
      e = this._temporalLinks.get(e).futureItemHash;
    }
    return null;
  }
  _getItemFromNewest(t) {
    let e = this._newestItemHash;
    for (; e; ) {
      if (t-- === 0)
        return this._selectedItemsPruned.get(e) || null;
      e = this._temporalLinks.get(e).pastItemHash;
    }
    return null;
  }
  /**
   * Gets the least recent selection item.
   * @returns the least recently selected item (if any).
   */
  getFirst() {
    return this._oldestItemHash !== null && this._selectedItemsPruned.get(this._oldestItemHash) || null;
  }
  /**
   * Gets the most recent selection item.
   * @returns the most recently selected item (if any).
   */
  getLast() {
    return this._newestItemHash !== null && this._selectedItemsPruned.get(this._newestItemHash) || null;
  }
  /**
   * Gets the number of selection items.
   * @returns the number of selected items.
   */
  size() {
    return this._selectedItemsPruned.size;
  }
  /**
   * Iterates over all selection items.
   * The function passed in will be called once for every selection item and will receive the item as its parameter.
   * @param func a function to be called for every selection item.
   */
  each(t) {
    let e = this._oldestItemHash;
    for (; e; ) {
      const i = this._selectedItemsPruned.get(e);
      t(i), e = this._temporalLinks.get(e).futureItemHash;
    }
  }
  /**
   * Removes all items from the selection set.
   * @param triggerCallback triggers a null selection callback when true.
   */
  clear(t = !0) {
    this._selectedLayers.clear(), this._selectedTypes.clear(), this._clearHighlight(), this._selectedItemsPruned.clear(), this._selectedItemsFull.clear(), this._selectedNodeCounts.clear(), this._temporalLinks.clear(), this._oldestItemHash = null, this._newestItemHash = null, t && this._triggerNullSelection();
  }
  /**
   * Sets the color to be used when selecting nodes.
   * This method should not be called before the sceneReady callback has been triggered.
   * @param color the color to apply to the selected node.
   */
  setNodeSelectionColor(t) {
    return this._setNodeSelectionColor(t), Promise.resolve();
  }
  _setNodeSelectionColor(t) {
    this._nodeSelectionColor.assign(t), this._updateHighlightingMode();
  }
  /**
   * Gets the color to be used when selecting nodes.
   * @returns the color that is applied to a selected node.
   */
  getNodeSelectionColor() {
    return this._nodeSelectionColor.copy();
  }
  /**
   * Sets color for the node selection outline.
   * This method should not be called before the sceneReady callback has been triggered.
   * @param color the color to apply to the node selection outline.
   */
  setNodeSelectionOutlineColor(t) {
    return this._setNodeSelectionOutlineColor(t), Promise.resolve();
  }
  _setNodeSelectionOutlineColor(t) {
    this._nodeSelectionOutlineColor.assign(t), this._updateHighlightingMode();
  }
  /**
   * Gets the color to be used for outlining the node selection.
   * @returns the color for node selection outline.
   */
  getNodeSelectionOutlineColor() {
    return this._nodeSelectionOutlineColor.copy();
  }
  /**
   * Sets the color to use for node element selection.
   * This method should not be called before the sceneReady callback has been triggered.
   * @param color the color to apply to selected node elements.
   */
  setNodeElementSelectionColor(t) {
    return this._setNodeElementSelectionColor(t), Promise.resolve();
  }
  _setNodeElementSelectionColor(t) {
    this._elementSelectionColor.assign(t), this._updateHighlightingMode();
  }
  /**
   * Gets the color to use for face and line selection.
   * @returns the color used for face and line selection.
   */
  getNodeElementSelectionColor() {
    return this._elementSelectionColor.copy();
  }
  /**
   * Gets the color to use for outlining node element selection.
   * This method should not be called before the sceneReady callback has been triggered.
   * @param color the color used for outlining face and line selection.
   */
  setNodeElementSelectionOutlineColor(t) {
    return this._setNodeElementSelectionOutlineColor(t), Promise.resolve();
  }
  _setNodeElementSelectionOutlineColor(t) {
    this._elementSelectionOutlineColor.assign(t), this._updateHighlightingMode();
  }
  /**
   * Gets the color to use for outlining face and line selection.
   * @returns color the color used for outlining face and line selection.
   */
  getNodeElementSelectionOutlineColor() {
    return this._elementSelectionOutlineColor.copy();
  }
  /**
   * Gets whether face elements will be highlighted on selection.
   * @returns boolean the current value for face element selection highlighting.
   */
  getHighlightFaceElementSelection() {
    return this._highlightFaceElementSelection;
  }
  /**
   * Sets whether face elements should be highlighted when a selection occurs.
   * By default the system will automatically highlight face elements associated with a selection item.
   * @param highlightFaceElementSelection value indicating whether selected face elements should be highlighted.
   */
  setHighlightFaceElementSelection(t) {
    return this._highlightFaceElementSelection = t, this._updateHighlight(), Promise.resolve();
  }
  /**
   * Sets the highlighting mode for selected nodes. The default behavior is to highlight the node and render an overlay outline.
   * This method should not be called before the sceneReady callback has been triggered.
   * @param highlightMode the highlighting mode that will be applied to selected nodes.
   */
  setNodeSelectionHighlightMode(t) {
    return this._setNodeSelectionHighlightMode(t), Promise.resolve();
  }
  _setNodeSelectionHighlightMode(t) {
    this._nodeHighlightMode = t, this._updateHighlightingMode();
  }
  /**
   * Gets the highlighting mode for selected nodes.
   * @returns the current
   */
  getNodeSelectionHighlightMode() {
    return this._nodeHighlightMode;
  }
  /**
   * Sets the highlighting mode for selected node elements.
   * The default behavior is to highlight the node element and render an overlay outline.
   * This method should not be called before the sceneReady callback has been triggered.
   * @param highlightMode the highlighting mode that will be applied to selected nodes.
   */
  setNodeElementSelectionHighlightMode(t) {
    return this._setNodeElementSelectionHighlightMode(t), Promise.resolve();
  }
  _setNodeElementSelectionHighlightMode(t) {
    this._nodeElementHighlightMode = t, this._updateHighlightingMode();
  }
  getNodeElementSelectionHighlightMode() {
    return this._nodeElementHighlightMode;
  }
  /**
   * Sets whether nodes should be highlighted when a selection occurs.
   * By default, the system will automatically highlight the node associated with a selection item.
   * @param highlightNodeSelection value indicating whether selected nodes should be highlighted.
   */
  setHighlightNodeSelection(t) {
    return this._highlightNodeSelection = t, this._updateHighlight(), Promise.resolve();
  }
  /**
   * Gets whether nodes will be highlighted on selection.
   * @returns the current value for node selection highlighting.
   */
  getHighlightNodeSelection() {
    return this._highlightNodeSelection;
  }
  /**
   * Gets whether line elements will be highlighted on selection.
   * @returns boolean the current value for line element selection highlighting.
   */
  getHighlightLineElementSelection() {
    return this._highlightLineElementSelection;
  }
  /**
   * Gets whether point elements will be highlighted on selection.
   * @returns boolean the current value for point element selection highlighting.
   */
  getHighlightPointElementSelection() {
    return this._highlightPointElementSelection;
  }
  /**
   * Sets whether line elements should be highlighted when a selection occurs.
   * By default the system will automatically highlight line elements associated with a selection item.
   * @param highlightLineElementSelection value indicating whether selected line elements should be highlighted.
   */
  setHighlightLineElementSelection(t) {
    return this._highlightLineElementSelection = t, this._updateHighlight(), Promise.resolve();
  }
  /**
   * Sets whether point elements should be highlighted when a selection occurs.
   * By default the system will automatically highlight point elements associated with a selection item.
   * @param highlightPointElementSelection value indicating whether selected point elements should be highlighted.
   */
  setHighlightPointElementSelection(t) {
    return this._highlightPointElementSelection = t, this._updateHighlight(), Promise.resolve();
  }
  /**
   * Sets the pick tolerance in pixels for line and point picking.
   * If a line or point is within this pixel tolerance of the click point,
   * it will be prioritized over the face at the click position.
   *
   * The default value is 20.
   * @param Pick Tolerance value in pixels
   */
  setPickTolerance(t) {
    this._engine.setPickTolerance(t);
  }
  /**
   * Gets the pick tolerance in pixels for line and point picking.
   *
   * The default value is 20.
   * @returns number Pick tolerance value in pixels
   */
  getPickTolerance() {
    return this._engine.getPickTolerance();
  }
  /**
   * Exports selection objects so that they may be loaded back into the the system at a later time using loadSelectionData.
   * @returns exported selection data.
   */
  exportSelectionData() {
    const t = [], e = this.getResults();
    for (const i of e)
      t.push(i.toJson());
    return t;
  }
  /**
   * Loads serialized selection items exported using [[exportSelectionData]] back into the [[SelectionManager]].
   * The current selection will be cleared. A selection event will be triggered for each loaded item.
   * This method should not be called before the [[CallbackMap.modelStructureReady]] callback has been triggered.
   * @param data data to be imported in the form of a JavaScript object or JSON string
   */
  loadSelectionData(t) {
    if (this.clear(!1), typeof t == "string" && (t = JSON.parse(t), !Array.isArray(t)))
      throw new fn("Expected JSON depicting an Array.");
    const e = [];
    for (const i of t) {
      const s = de._fromJson(i);
      s.isNodeSelection() && e.push(s);
    }
    this.add(e);
  }
  _pathToParent(t, e) {
    const i = [];
    for (; !t.equals(e); ) {
      i.push(t);
      const s = this._model.getNodeParent(t.getNodeId());
      if (s === null)
        break;
      t = de.create(s);
    }
    return i;
  }
  _removeImplicit(t, e, i) {
    const s = this._pathToParent(t, e), r = (c) => {
      for (const h of s)
        if (c.equals(h))
          return !0;
      return !1;
    };
    let o = e;
    const a = [t], l = [];
    for (; s.length > 0; ) {
      a.push(o);
      const c = this._model.getNodeChildren(o.getNodeId());
      for (const h of c) {
        const u = de.create(h);
        r(u) || l.push(u);
      }
      o = s.pop();
    }
    console.assert(t === o), this.remove(a, i), this.add(l, i);
  }
  _removeDescendants(t) {
    const e = this._model.getNodeChildren(t.getNodeId());
    for (const i of e) {
      const s = de.create(i);
      this._removeDescendantsRecursive(s);
    }
  }
  _removeDescendantsRecursive(t) {
    const e = t._hash(this._singleEntityToggleMode);
    if (this._selectedItemsFull.delete(e)) {
      this._removeImpl(t, e);
      const i = this._model.getNodeChildren(t.getNodeId());
      for (const s of i) {
        const r = de.create(s);
        this._removeDescendantsRecursive(r);
      }
    }
  }
  _processSelection(t, e) {
    switch (e) {
      case ai.Add:
        this.add(t);
        break;
      case ai.Set:
        this.set(t);
        break;
      case ai.Toggle:
        t !== null && this.toggle(t);
        break;
    }
  }
  _clearHighlight() {
    this._selectedItemsPruned.size > 0 && this._engine.clearHighlight();
  }
  _updateHighlight() {
    this._clearHighlight(), this._selectedItemsPruned.forEach((t) => {
      t && this._updateItemHighlight(t, !0, !0);
    }), this._highlightNodeSelection && this._model.setNodesHighlighted([], !0);
  }
  _updateItemHighlight(t, e, i) {
    const s = t.getNodeId();
    if (this._highlightNodeSelection && this._model.setNodesHighlighted([s], e), this._model.getNodeType(s) !== At.Pmi) {
      const r = t.getFaceEntity();
      this._highlightFaceElementSelection && r !== null && !r.isCappingGeometry() && this._model.setNodeFaceHighlighted(s, r.getCadFaceIndex(), i);
      const o = t.getLineEntity();
      this._highlightLineElementSelection && o !== null && !o.isCappingGeometry() && this._model.setNodeLineHighlighted(s, o.getLineId(), i);
      const a = t.getPointEntity();
      this._highlightPointElementSelection && a !== null && this._model.setNodePointHighlighted(s, a.getPointId(), i);
    }
  }
  _updateHighlightingMode() {
    switch (this._nodeHighlightMode) {
      case Ln.HighlightOnly:
        this._engine.setNodeHighlightColor(this._nodeSelectionColor, null);
        break;
      case Ln.OutlineOnly:
        this._engine.setNodeHighlightColor(null, this._nodeSelectionOutlineColor);
        break;
      case Ln.HighlightAndOutline:
        this._engine.setNodeHighlightColor(
          this._nodeSelectionColor,
          this._nodeSelectionOutlineColor
        );
        break;
    }
    switch (this._nodeElementHighlightMode) {
      case Ln.HighlightOnly:
        this._engine.setElementHighlightColor(this._elementSelectionColor, null);
        break;
      case Ln.OutlineOnly: {
        this._nodeHighlightMode === Ln.OutlineOnly ? this._engine.setElementHighlightColor(null, this._elementSelectionOutlineColor) : this._engine.setElementHighlightColor(
          this._nodeSelectionColor,
          this._elementSelectionOutlineColor
        );
        break;
      }
      case Ln.HighlightAndOutline:
        this._engine.setElementHighlightColor(
          this._elementSelectionColor,
          this._elementSelectionOutlineColor
        );
        break;
    }
  }
  _onSubtreeLoaded(t) {
    const e = de.create(t);
    if (this.isSelected(e))
      return this._updateItemHighlight(e, !0, !0);
  }
}
const Q0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CompositeSelectionItem: Ml,
  FaceEntity: Pa,
  IncrementalSelectionId: wo,
  LineEntity: Ga,
  NodeCounts: _m,
  Op: ls,
  PointEntity: Ya,
  SelectionItem: de,
  SelectionManager: Bl,
  TemporalLink: ym,
  ifcSelectionFilter: Fc
}, Symbol.toStringTag, { value: "Module" }));
class An {
  /**
   * Creates a new NodeSelectionEvent
   * @hidden
   */
  constructor(t) {
    this._selection = t;
  }
  /**
   * Gets the result of the selection operator.
   * @returns the result of the selection
   */
  getType() {
    return this._selection ? this._selection.getSelectionType() : pi.None;
  }
  /**
   * Gets the selection object.
   * @returns Selection object containing detailed information about the selection
   */
  getSelection() {
    return this._selection;
  }
  /**
   * Creates a no-selection event.
   * @returns Selection event with result set to none.
   * @hidden
   */
  static _createNull() {
    return new An(de.create());
  }
}
class ll extends zl {
  /**
   * Touch Event class
   * @param id unique identifier for this touch
   * @param positionX X window position of the touch
   * @param positionY Y window position of the touch
   * @hidden
   */
  constructor(t, e, i, s, r) {
    super(), this._id = t, this._position = new E(e, i), this._buttons = s, this._inputType = r;
  }
  /**
   * gets the id this event
   * @returns the unique identifier for this touch
   */
  getId() {
    return this._id;
  }
  /**
   * gets the window position of the mouse pointer for this event
   * @returns the mouse position for this event
   */
  getPosition() {
    return this._position;
  }
  /**
   * gets the event type
   * @returns the type of touch event
   */
  getEventType() {
    return this._inputType;
  }
  /**
   * gets the mouse buttons currently pressed with this event
   * @returns the mouse buttons currently pressed for this event
   */
  getButtons() {
    return this._buttons;
  }
}
function O_(n) {
  switch (n) {
    case kt.MouseDown:
      return !0;
    case kt.MouseMove:
      return !0;
    case kt.MouseUp:
      return !0;
    case kt.Mousewheel:
      return !0;
    case kt.TouchStart:
      return !1;
    case kt.TouchMove:
      return !1;
    case kt.TouchEnd:
      return !1;
    case kt.KeyDown:
      return !1;
    case kt.KeyUp:
      return !1;
    case kt.ViewOrientationChange:
      return !1;
    default:
      return !1;
  }
}
const q0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  InputEvent: zl,
  KeyInputEvent: Xc,
  MouseInputEvent: Qn,
  MouseInputEventBase: Ph,
  MouseWheelInputEvent: fm,
  NodeSelectionEvent: An,
  TouchInputEvent: ll,
  isMouseEventType: O_
}, Symbol.toStringTag, { value: "Module" }));
class bm {
  constructor(t, e, i) {
    this._markupItems = /* @__PURE__ */ new Map(), this._activeView = null, this._selectedMarkup = null, this._pendingUpdateHandleTimer = new As(), this._pickTolerance = 0, this._callbackManager = t, this._domElements = e, this._markupRenderer = i;
  }
  shutdown() {
    this.setActiveView(null), this._markupItems.forEach((t) => {
      t.remove();
    }), this._markupItems.clear();
  }
  _updateLater(t) {
    this._pendingUpdateHandleTimer.isIdle(mi.BeforeAction) && this._pendingUpdateHandleTimer.set(0, () => {
      this.update();
    }), t !== null && this._pendingUpdateHandleTimer.waitForIdle(mi.AfterAction).then(() => {
      t.resolve();
    });
  }
  updateLater() {
    this._updateLater(null);
  }
  update() {
    this._pendingUpdateHandleTimer.clear(), this.renderMarkup(), this.renderActiveViewMarkup();
  }
  registerMarkupItem(t) {
    const e = Qi();
    return this._markupItems.set(e, t), e;
  }
  unregisterMarkupItem(t) {
    const e = this._markupItems.get(t);
    e && (e.remove && e.remove(), this._markupItems.delete(t));
  }
  getActiveView() {
    return this._activeView;
  }
  async setActiveView(t) {
    this._selectedMarkup && (this._selectedMarkup.onDeselect(), this._selectedMarkup = null);
    const e = this._activeView;
    if (this._activeView = t, e !== null && e !== t) {
      const i = e.getMarkup();
      for (const r of i)
        r.remove();
      const s = be();
      this._updateLater(s), await s, this._callbackManager.trigger("viewDeactivated", e);
    } else
      await this._pendingUpdateHandleTimer.waitForIdle(mi.AfterAction);
  }
  renderMarkup() {
    this._markupRenderer._setCanvas(this._domElements.getMarkupSvgElement()), this._markupRenderer._clear(), this._markupItems.forEach((t) => {
      t.draw();
    }), this._markupRenderer._finalize();
  }
  renderActiveViewMarkup() {
    if (this._markupRenderer._setCanvas(this._domElements.getRedlineSvgElement()), this._markupRenderer._clear(), !this._activeView)
      return;
    const t = this._activeView.getMarkup();
    for (const e of t)
      e.draw();
    this._markupRenderer._finalize();
  }
  getPickTolerance() {
    return this._pickTolerance;
  }
  setPickTolerance(t) {
    this._pickTolerance = t;
  }
  pick(t) {
    if (this._activeView) {
      const i = this._activeView.getMarkup();
      for (const s of i)
        if (s.hitWithTolerance(t, this._pickTolerance) || s.hit(t))
          return s;
    }
    let e = null;
    return this._markupItems.forEach((i) => {
      e === null && (i.hitWithTolerance(t, this._pickTolerance) || i.hit(t)) && (e = i);
    }), e;
  }
  select(t) {
    this._selectedMarkup && t !== this._selectedMarkup && this._selectedMarkup.onDeselect(), this._selectedMarkup = t, this._selectedMarkup && this._selectedMarkup.onSelect(), this.update();
  }
  getSelected() {
    return this._selectedMarkup;
  }
}
class Im {
  constructor(t, e) {
    this.markupView = t, this.itemResults = e;
  }
}
class ea {
  /** @hidden */
  constructor(t, e, i, s, r, o = null) {
    this._lineVisibility = !0, this._faceVisibility = !0, this._markupItems = /* @__PURE__ */ new Set(), this._sheetId = null, this._colorMap = /* @__PURE__ */ new Map(), this._snapshotImage = null, this._defaultVisibility = !0, this._visibilityExceptions = /* @__PURE__ */ new Set(), this._uniqueId = t, this._camera = i, this._name = e, this._explodeMagnitude = s, this._cuttingPlaneData = r, this._sheetId = o;
  }
  /**
   * Gets the camera of this view
   * @returns the camera of this view
   */
  getCamera() {
    return this._camera;
  }
  /**
   * Gets the sheet id for this view
   * @returns the id of the sheet for this view. If no view was active at the time of creation this function will return null.
   */
  getSheetId() {
    return this._sheetId;
  }
  /**
   * Gets the unique identifier of this view
   * @returns unique identifier of this view
   */
  getUniqueId() {
    return this._uniqueId;
  }
  /**
   * Gets the name of this view
   * @returns name of this view
   */
  getName() {
    return this._name;
  }
  /**
   * Sets the name for this view
   * @param name name to set
   */
  setName(t) {
    this._name = t;
  }
  /**
   * Gets line visibility setting for this view
   * @returns line visibility setting for this view
   */
  getLineVisibility() {
    return this._lineVisibility;
  }
  /**
   * Sets line visibility for this view
   * @param lineVisibility line visibility setting for this view
   */
  setLineVisibility(t) {
    this._lineVisibility = t;
  }
  /**
   * Gets face visibility setting for this view
   * @returns face visibility setting for this view
   */
  getFaceVisibility() {
    return this._faceVisibility;
  }
  /**
   * Sets face visibility for this view
   * @param faceVisibility face visibility setting for this view
   */
  setFaceVisibility(t) {
    this._faceVisibility = t;
  }
  /**
   * Adds a markup item to this view
   * @param markupItem the markup to be added to this view.
   */
  addMarkupItem(t) {
    this._markupItems.add(t);
  }
  /**
   * Gets an array of markup items associated with this view
   * @returns {boolean} face visibility setting for this view
   */
  getMarkup() {
    return us(this._markupItems);
  }
  /**
   * Removes a markup item from the view
   * @param markupItem the markup to be removed from this view.
   * @returns result of the removal operation
   */
  removeMarkup(t) {
    return t.remove(), this._markupItems.delete(t);
  }
  /**
   * @returns a JSON object with the cutting plane data associated with this view
   */
  getCuttingPlaneData() {
    return this._cuttingPlaneData;
  }
  /**
   * Takes a JSON cutting plane data object and associates it with this view
   * @param cuttingPlaneData
   */
  setCuttingPlaneData(t) {
    this._cuttingPlaneData = t;
  }
  /**
   * @returns the explode value associated with this view
   */
  getExplodeMagnitude() {
    return this._explodeMagnitude;
  }
  /**
   * Takes an explode magnitude and associates it with this view
   */
  setExplodeMagnitude(t) {
    this._explodeMagnitude = t;
  }
  /**
   * @returns A color map associating NodeIds to Colors.
   */
  getColorMap() {
    return this._colorMap;
  }
  /**
   * Takes a color map associating NodeIds to Colors and associates it with this view.
   * @param colorMap
   */
  setColorMap(t) {
    this._colorMap = t;
  }
  getDefaultVisibility() {
    return this._defaultVisibility;
  }
  setDefaultVisibility(t) {
    this._defaultVisibility = t;
  }
  getVisibilityExceptions() {
    return this._visibilityExceptions;
  }
  setVisibilityExceptions(t) {
    this._visibilityExceptions = t;
  }
  getSnapshotImage() {
    return this._snapshotImage;
  }
  setSnapshotImage(t) {
    this._snapshotImage = t;
  }
  _handleLoadMarkupItem(t) {
    return t instanceof _s ? (this.addMarkupItem(t), !0) : !1;
  }
  /** @hidden */
  static async _fromJson(t, e) {
    const i = t, s = ci.fromJson(i.camera);
    let r;
    if (i.hasOwnProperty("sheetId") && i.sheetId) {
      const p = parseInt(t.sheetId, 10);
      isNaN(p) || (r = p);
    }
    const o = new ea(
      i.uniqueId,
      i.name,
      s,
      i.explodeMagnitude,
      i.cuttingData,
      r
    );
    if (o.setLineVisibility(i.lineVisibility), o.setFaceVisibility(i.faceVisibility), i.defaultVisibility !== void 0 && i.visibilityExceptions !== void 0) {
      o.setDefaultVisibility(i.defaultVisibility);
      const p = /* @__PURE__ */ new Set();
      i.visibilityExceptions.forEach((m) => {
        p.add(m);
      }), o.setVisibilityExceptions(p);
    }
    const a = /* @__PURE__ */ new Map(), l = i.colors;
    if (Array.isArray(l))
      for (const p of l) {
        const m = p[0], g = it.fromJson(p[1]);
        a.set(m, g);
      }
    o.setColorMap(a);
    const c = [];
    console.assert(Array.isArray(i.markup));
    for (const p of i.markup) {
      const m = mh(p.className);
      if (m) {
        const g = m(p, e);
        g instanceof Promise ? c.push(
          g.then((_) => o._handleLoadMarkupItem(_))
        ) : c.push(Promise.resolve(o._handleLoadMarkupItem(g)));
      }
    }
    const h = i.imageSrc;
    if (h !== void 0 && h.length > 0) {
      const p = new Image();
      p.src = h, o.setSnapshotImage(p);
    }
    const u = await Promise.all(c);
    return new Im(o, u);
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    const t = {
      uniqueId: this._uniqueId,
      name: this._name,
      camera: this._camera.toJson(),
      cuttingData: this._cuttingPlaneData,
      explodeMagnitude: this._explodeMagnitude,
      lineVisibility: this._lineVisibility,
      faceVisibility: this._faceVisibility,
      markup: [],
      sheetId: this._sheetId,
      defaultVisibility: this._defaultVisibility,
      visibilityExceptions: [],
      colors: [],
      imageSrc: ""
    };
    return this._markupItems.forEach((e) => {
      const i = e.toJson();
      i.className = e.getClassName(), t.markup.push(i);
    }), this._visibilityExceptions.forEach((e) => {
      t.visibilityExceptions.push(e);
    }), this._colorMap.forEach((e, i) => {
      t.colors.push([i, e.toJson()]);
    }), this._snapshotImage !== null && (t.imageSrc = this._snapshotImage.src), t;
  }
}
const A_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  RedlineItem: to
}, Symbol.toStringTag, { value: "Module" }));
class Wi extends Ma {
  /**
   * Creates a new Line Shape
   * @param p1 Optional first point on the line. If omitted, default value of (0,0) is used.
   * @param p2 Optional second point on the line. If omitted, default value of (0,0) is used.
   * @returns new Line object.
   */
  constructor(t, e) {
    super(), t ? this._p1 = t.copy() : this._p1 = E.zero(), e ? this._p2 = e.copy() : this._p2 = E.zero();
  }
  /**
   * Sets the points that define the line segment
   * @param p1 first point of the line segment
   * @param p2 second point of the line segment
   */
  set(t, e) {
    this._p1.assign(t), this._p2.assign(e);
  }
  /**
   * Gets the first point of the line segment
   * @returns the first point of the line segment
   */
  getP1() {
    return this._p1.copy();
  }
  /**
   * Sets the first point of the line segment
   * @param p1 first point of the line segment
   */
  setP1(t) {
    this._p1.assign(t);
  }
  /**
   * Gets the second point of the line segment
   * @returns the second point of the line segment
   */
  getP2() {
    return this._p2;
  }
  /**
   * sets the first point of the line segment
   * @param p2 second point of the line segment
   */
  setP2(t) {
    this._p2.assign(t);
  }
}
class wm {
  constructor(t, e) {
    this.p1 = t.copy(), this.p2 = e.copy();
  }
}
class D_ extends Ma {
  constructor() {
    super(...arguments), this._lines = [];
  }
  /**
   * Adds a line segment to the collection
   * @param p1 first point of the line segment
   * @param p2 second point of the line segment
   */
  addLine(t, e) {
    this._lines.push(new wm(t, e));
  }
  /**
   * Gets the lines in the collection
   */
  getLines() {
    return this._lines;
  }
  /**
   * Removes all line segments from this collection
   */
  clear() {
    this._lines = [];
  }
}
class vm extends yr {
  constructor() {
    super(...arguments), this._points = [];
  }
  /**
   * Removes all points from this polygon
   */
  clearPoints() {
    this._points = [];
  }
  /**
   * Gets the points in this polyline
   * @returns the points in this polygon
   */
  getPoints() {
    return this._points;
  }
  /**
   * Adds a point to the polygon
   * @param point the point to add to the polygon
   */
  pushPoint(t) {
    this._points.push(t.copy());
  }
}
class z_ extends yr {
  constructor() {
    super(...arguments), this._polygons = [];
  }
  /**
   * Removes all polygons from the collection
   */
  clear() {
    this._polygons = [];
  }
  /**
   * Creates a new array of points that represent a polygon. Add Point2 objects to the array to construct the polygon
   * @returns new array which represents a polygon.
   */
  createPolygon() {
    const t = [];
    return this._polygons.push(t), t;
  }
  /**
   * @returns the polylines in this collection
   */
  getPolygons() {
    return this._polygons;
  }
}
class Jl extends yr {
  /** @hidden */
  constructor() {
    super(), this._fontFamily = null, this._fontSize = 12, this.setStrokeWidth(0);
  }
  /** @hidden */
  _assign(t) {
    super._assign(t), this._fontFamily = t._fontFamily, this._fontSize = t._fontSize;
  }
  /**
   * Gets the font family for this text
   * @returns the font family
   */
  getFontFamily() {
    return this._fontFamily;
  }
  /**
   * Sets the font family this shape
   * @param fontFamily font family to use for this text
   */
  setFontFamily(t) {
    this._fontFamily = t;
  }
  /**
   * Sets the font size for this text
   * @param fontSize size to use for this text
   */
  setFontSize(t) {
    this._fontSize = t;
  }
  /**
   * Gets the font size for this text
   * @returns the font size
   */
  getFontSize() {
    return this._fontSize;
  }
}
class B_ extends Jl {
  /**
   * Creates a new markup text item.
   * @param text the text associated with this item.
   * @param position the screen space point of the top left of the text string.
   */
  constructor(t, e) {
    super(), this._position = E.zero(), this._text = "", e && (this._position = e.copy()), t && this.setText(t);
  }
  /** @hidden */
  _assign(t) {
    super._assign(t), this._text = t._text, this._position.assign(t._position);
  }
  /**
   * Sets the text position
   * @returns the top left position to render text from
   */
  setPosition(t) {
    this._position.assign(t);
  }
  /**
   * Gets the text position
   * @returns the text position
   */
  getPosition() {
    return this._position;
  }
  /**
   * Sets the text content
   * @param text the text to render
   */
  setText(t) {
    this._text = t;
  }
  /**
   * Gets the text content
   * @returns the text content
   */
  getText() {
    return this._text;
  }
}
class Gh {
  constructor(t, e) {
    this.text = t, this.position = e.copy();
  }
}
class Sm extends Jl {
  constructor() {
    super(...arguments), this._textStrings = [];
  }
  /**
   * Removes all text strings from this collection
   */
  clear() {
    this._textStrings = [];
  }
  /**
   * Adds a string to the collection
   * @param text the text to render
   * @param position the top left position of the text
   */
  addString(t, e) {
    this._textStrings.push(new Gh(t, e));
  }
  /**
   * Gets the strings in the collection
   */
  getStrings() {
    return this._textStrings;
  }
}
class Yh {
  /** @hidden */
  constructor() {
    this._padding = 5, this._text = new Jl(), this._box = new Kl(), this._box.setFillOpacity(0), this._box.setFillColor(it.white());
  }
  /** @hidden */
  _assign(t) {
    this._text._assign(t._text), this._box._assign(t._box), this._padding = t._padding;
  }
  /**
   * Gets the Text portion of the TextBox. Use the methods on this object to modify the appearance of the text string
   * @returns the text markup object
   */
  getTextPortion() {
    return this._text;
  }
  /**
   * Gets the Box portion of the TextBox. Use the methods on this object to modify the appearance of the rectangle around the text string
   * @returns the rectangle markup object.
   */
  getBoxPortion() {
    return this._box;
  }
  /**
   * Gets the Pixel distance between the text and outer rectangle
   * @returns the padding value.
   */
  getPadding() {
    return this._padding;
  }
  /**
   * Sets the Pixel distance between the text and outer rectangle
   * @param padding the padding value.
   */
  setPadding(t) {
    this._padding = t;
  }
}
class eo extends Yh {
  /**
   * Creates a new TextBox Markup Shape.
   * @param position the screen space point of the top left of the box. Default value is (0,0).
   * @param text the text string for the box. Default value is empty string.
   */
  constructor(t, e) {
    super(), this._position = E.zero(), this._textStr = "", t && this._position.assign(t), e && (this._textStr = e);
  }
  /** @hidden */
  _assign(t) {
    super._assign(t), this._position.assign(t._position);
  }
  /**
   * Gets the position in screen space of the top-left corner of the TextBox rectangle
   * @returns the TextBox position
   */
  getPosition() {
    return this._position.copy();
  }
  /**
   * Sets the position in screen space of the top-left corner of the TextBox rectangle
   * @param position the TextBox position
   */
  setPosition(t) {
    this._position.assign(t);
  }
  /**
   * Gets the text string for this box
   * @returns the text string
   */
  getTextString() {
    return this._textStr;
  }
  /**
   * Sets the text string for this box
   * @param text the text string
   */
  setTextString(t) {
    this._textStr = t;
  }
}
class J_ extends Yh {
  constructor() {
    super(...arguments), this._textStrings = [];
  }
  /**
   * Removes all text strings from this collection
   */
  clear() {
    this._textStrings = [];
  }
  /**
   * Adds a string to the collection
   * @param text the text to render
   * @param position the top left position of the text
   */
  addString(t, e) {
    this._textStrings.push(new Gh(t, e));
  }
  /**
   * Gets the strings in the collection
   */
  getStrings() {
    return this._textStrings;
  }
}
const j_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Circle: qn,
  CircleCollection: Mh,
  EndcapShape: Ma,
  EndcapType: ii,
  FilledShape: yr,
  Line: Wi,
  LineCollection: D_,
  Polygon: vm,
  PolygonCollection: z_,
  Polyline: br,
  PolylineCollection: L_,
  Rectangle: Ol,
  RectangleBase: Kl,
  RectangleCollection: X_,
  StrokedShape: kh,
  Text: B_,
  TextBox: eo,
  TextBoxBase: Yh,
  TextBoxCollection: J_,
  TextCollection: Sm,
  TextMarkupBase: Jl,
  _MarkupCircleData: hm,
  _MarkupLineData: wm,
  _MarkupRectangleData: um,
  _MarkupTextData: Gh
}, Symbol.toStringTag, { value: "Module" })), Bi = "http://www.w3.org/2000/svg";
function Br(n) {
  return `rgb(${n.r}, ${n.g}, ${n.b})`;
}
function Kc(n) {
  let t = "";
  for (let e = 0; e < n.length; e++)
    e && (t += " "), t += `${n[e].x},${n[e].y}`;
  return t;
}
function Oc(n, t) {
  const e = n * 1.1, i = new E(e, 0), s = new E(e, n), r = new E(0, n / 2), o = document.createElementNS(Bi, "marker");
  o.id = Qi(), o.markerWidth.baseVal.value = e, o.markerHeight.baseVal.value = n, o.setOrientToAuto(), o.refY.baseVal.value = n / 2;
  const a = `M${i.x},${i.y} L${s.x},${s.y} L${r.x},${r.y} Z`, l = document.createElementNS(Bi, "path");
  return l.setAttribute("d", a), l.setAttributeNS(null, "fill", Br(t)), o.appendChild(l), o;
}
function Ac(n, t) {
  const e = n * 1.1, i = E.zero(), s = new E(0, n), r = new E(e, n / 2), o = document.createElementNS(Bi, "marker");
  o.id = Qi(), o.markerWidth.baseVal.value = e, o.markerHeight.baseVal.value = n, o.setOrientToAuto(), o.refY.baseVal.value = n / 2, o.refX.baseVal.value = n;
  const a = `M${i.x},${i.y} L${s.x},${s.y} L${r.x},${r.y} Z`, l = document.createElementNS(Bi, "path");
  return l.setAttribute("d", a), l.setAttributeNS(null, "fill", Br(t)), o.appendChild(l), o;
}
function Dc(n, t, e, i) {
  const s = e / 2, r = Br(i), o = document.createElementNS(Bi, "circle");
  return o.setAttributeNS(null, "cx", n.x.toString()), o.setAttributeNS(null, "cy", n.y.toString()), o.setAttributeNS(null, "r", s.toString()), o.setAttributeNS(null, "fill", r), t > 0 && (o.setAttributeNS(null, "stroke-width", t.toString()), o.setAttributeNS(null, "stroke", r)), o;
}
class xm {
  constructor() {
    this._svgCanvas = null, this._svgDefsElement = null, this._svgElements = [], this._svgTextElements = [];
  }
  _setCanvas(t) {
    this._svgCanvas = t, this._svgDefsElement = document.createElementNS(Bi, "defs"), this._svgCanvas.appendChild(this._svgDefsElement);
  }
  _clear() {
    if (this._svgCanvas === null || this._svgDefsElement === null)
      throw new Mt("canvas not set");
    for (; this._svgCanvas.firstChild; )
      this._svgCanvas.removeChild(this._svgCanvas.firstChild);
    for (this._svgElements = [], this._svgTextElements = []; this._svgDefsElement.firstChild; )
      this._svgDefsElement.removeChild(this._svgDefsElement.firstChild);
    this._svgCanvas.appendChild(this._svgDefsElement);
  }
  _finalize() {
    if (this._svgCanvas === null)
      throw new Mt("canvas not set");
    for (const t of this._svgElements)
      this._svgCanvas.appendChild(t);
    for (const t of this._svgTextElements)
      this._svgCanvas.appendChild(t);
  }
  drawCircle(t) {
    return this._addCircleNode(t.getCenter(), t.getRadius(), t);
  }
  drawCircles(t) {
    const e = t.getCircles(), i = [];
    for (const s of e) {
      const r = this._addCircleNode(s.center, s.radius, t);
      i.push(r);
    }
    return i;
  }
  drawLine(t) {
    return this._addLineElement(t.getP1(), t.getP2(), t);
  }
  drawLines(t) {
    const e = t.getLines(), i = [];
    for (const s of e) {
      const r = this._addLineElement(s.p1, s.p2, t);
      i.push(r);
    }
    return i;
  }
  drawText(t) {
    return this._addTextElement(t.getText(), t.getPosition(), t);
  }
  drawTexts(t) {
    const e = t.getStrings(), i = [];
    for (const s of e) {
      const r = this._addTextElement(s.text, s.position, t);
      i.push(r);
    }
    return i;
  }
  measureText(t, e) {
    if (this._svgCanvas === null)
      throw new Mt("canvas not set");
    const i = this._createTextElement(t, E.zero(), e);
    this._svgCanvas.appendChild(i);
    const s = i.getBoundingClientRect(), r = new E(s.width, s.height);
    return this._svgCanvas.removeChild(i), r;
  }
  measureTextBox(t) {
    const e = this.measureText(t.getTextString(), t.getTextPortion());
    return e.x += 2 * t.getBoxPortion().getStrokeWidth(), e.y += 2 * t.getBoxPortion().getStrokeWidth(), e.x += 2 * t.getPadding(), e.y += 2 * t.getPadding(), e;
  }
  drawPolyline(t) {
    return this._addPolylineElement(t.getPoints(), t);
  }
  drawPolylines(t) {
    const e = t.getPolylines(), i = [];
    for (const s of e) {
      const r = this._addPolylineElement(s, t);
      i.push(r);
    }
    return i;
  }
  drawPolygon(t) {
    return this._addPolygonElement(t.getPoints(), t);
  }
  drawPolygons(t) {
    const e = t.getPolygons(), i = [];
    for (const s of e) {
      const r = this._addPolygonElement(s, t);
      i.push(r);
    }
    return i;
  }
  drawRectangle(t) {
    return this._addRectangleElement(t.getPosition(), t.getSize(), t);
  }
  drawRectangles(t) {
    const e = t.getRectangles(), i = [];
    for (const s of e) {
      const r = this._addRectangleElement(s.position, s.size, t);
      i.push(r);
    }
    return i;
  }
  drawTextBox(t) {
    return this._addTextBoxElement(t.getTextString(), t.getPosition(), t);
  }
  drawTextBoxes(t) {
    const e = t.getStrings(), i = [];
    for (const s of e) {
      const r = this._addTextBoxElement(s.text, s.position, t);
      i.push(r);
    }
    return i;
  }
  _addTextBoxElement(t, e, i) {
    const s = this.measureText(t, i.getTextPortion());
    s.x += 2 * i.getPadding(), s.y += 2 * i.getPadding();
    const r = [], o = this._addRectangleElement(
      e,
      s,
      i.getBoxPortion(),
      !0
    );
    r.push(o);
    const a = e.copy();
    a.x += i.getPadding(), a.y += i.getPadding() / 2 + i.getBoxPortion().getStrokeWidth();
    const l = this._addTextElement(t, a, i.getTextPortion());
    return r.push(l), r;
  }
  _renderEndcaps(t, e, i, s) {
    if (this._svgDefsElement === null)
      throw new Mt("canvas not set");
    if (i.getStartEndcapType() === ii.Arrowhead) {
      let r;
      i.getEndcapsInverted() ? (r = Ac(
        i.getStartEndcapSize(),
        i.getStartEndcapColor()
      ), r.refX.baseVal.value = i.getStartEndcapSize()) : r = Oc(
        i.getStartEndcapSize(),
        i.getStartEndcapColor()
      ), s.style.markerStart = `url(#${r.id})`, this._svgDefsElement.appendChild(r);
    } else if (i.getStartEndcapType() === ii.Circle) {
      const r = Dc(
        t,
        i.getStrokeWidth(),
        i.getStartEndcapSize(),
        i.getStartEndcapColor()
      );
      this._addSVGElement(r);
    }
    if (i.getEndEndcapType() === ii.Arrowhead) {
      let r;
      i.getEndcapsInverted() ? r = Oc(i.getEndEndcapSize(), i.getEndEndcapColor()) : r = Ac(i.getEndEndcapSize(), i.getEndEndcapColor()), s.style.markerEnd = `url(#${r.id})`, this._svgDefsElement.appendChild(r);
    } else if (i.getEndEndcapType() === ii.Circle) {
      const r = Dc(
        e,
        i.getStrokeWidth(),
        i.getEndEndcapSize(),
        i.getEndEndcapColor()
      );
      this._addSVGElement(r);
    }
  }
  _createTextElement(t, e, i) {
    const s = document.createElementNS(Bi, "text"), r = t.split(`
`);
    for (const a of r) {
      const l = document.createElementNS(Bi, "tspan");
      l.textContent = a, l.setAttributeNS(null, "x", `${e.x}`), l.setAttributeNS(null, "dy", "1.2em"), s.appendChild(l);
    }
    const o = i.getFontFamily();
    return o && s.setAttributeNS(null, "font-family", o), s.setAttributeNS(null, "font-size", i.getFontSize().toString()), s.setAttributeNS(null, "x", `${e.x}`), s.setAttributeNS(null, "y", `${e.y}`), this._setGenericFillAttributes(s, i), this._setGenericStrokeAttributes(s, i), s;
  }
  _addTextElement(t, e, i) {
    const s = this._createTextElement(t, e, i);
    return this._addSVGTextItemElement(s), s;
  }
  _addRectangleElement(t, e, i, s = !1) {
    const r = document.createElementNS(Bi, "rect");
    r.setAttributeNS(null, "x", t.x.toString()), r.setAttributeNS(null, "y", t.y.toString()), r.setAttributeNS(null, "width", e.x.toString()), r.setAttributeNS(null, "height", e.y.toString());
    const o = i.getBorderRadius();
    return o > 0 && (r.setAttributeNS(null, "rx", o.toString()), r.setAttributeNS(null, "ry", o.toString())), this._setGenericFillAttributes(r, i), this._setGenericStrokeAttributes(r, i), s ? this._addSVGTextItemElement(r) : this._addSVGElement(r), r;
  }
  _addLineElement(t, e, i) {
    const s = document.createElementNS(Bi, "line");
    return s.setAttributeNS(null, "x1", t.x.toString()), s.setAttributeNS(null, "y1", t.y.toString()), s.setAttributeNS(null, "x2", e.x.toString()), s.setAttributeNS(null, "y2", e.y.toString()), this._setGenericStrokeAttributes(s, i), this._addSVGElement(s), this._renderEndcaps(t, e, i, s), s;
  }
  _addPolygonElement(t, e) {
    const i = Kc(t), s = document.createElementNS(Bi, "polygon");
    return s.setAttributeNS(null, "points", i), this._setGenericStrokeAttributes(s, e), this._setGenericFillAttributes(s, e), this._addSVGElement(s), s;
  }
  _addPolylineElement(t, e) {
    const i = Kc(t), s = document.createElementNS(Bi, "polyline");
    return s.setAttributeNS(null, "points", i), s.setAttributeNS(null, "fill", "none"), this._renderEndcaps(t[0], t[t.length - 1], e, s), this._setGenericStrokeAttributes(s, e), this._addSVGElement(s), s;
  }
  _addCircleNode(t, e, i) {
    const s = document.createElementNS(Bi, "circle");
    return s.setAttributeNS(null, "cx", t.x.toString()), s.setAttributeNS(null, "cy", t.y.toString()), s.setAttributeNS(null, "r", e.toString()), this._setGenericFillAttributes(s, i), this._setGenericStrokeAttributes(s, i), this._addSVGElement(s), s;
  }
  _setGenericFillAttributes(t, e) {
    t.setAttributeNS(null, "fill", Br(e.getFillColor())), t.setAttributeNS(null, "fill-opacity", e.getFillOpacity().toString());
  }
  _setGenericStrokeAttributes(t, e) {
    t.setAttributeNS(null, "stroke", Br(e.getStrokeColor())), t.setAttributeNS(null, "stroke-width", e.getStrokeWidth().toString());
  }
  _addSVGTextItemElement(t) {
    this._svgTextElements.push(t);
  }
  _addSVGElement(t) {
    this._svgElements.push(t);
  }
}
const H_ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  SVGMarkupRenderer: xm,
  createCircleMarker: Dc,
  createEndArrowMarker: Ac,
  createStartArrowMarker: Oc,
  svgColorRgbString: Br,
  svgNamespace: Bi,
  svgPointString: Kc
}, Symbol.toStringTag, { value: "Module" })), $0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Line: K_,
  MarkupItem: _s,
  MarkupItemManager: bm,
  MarkupView: ea,
  Redline: A_,
  Shapes: j_,
  Svg: H_,
  _MarkupViewConstruction: Im
}, Symbol.toStringTag, { value: "Module" })), Zm = 45, Cm = -45, km = 150, Mm = 30;
function Wm(n) {
  Mr(n, Ot.Forward, Ot.Backward), Mr(n, Ot.Left, Ot.Right), Mr(n, Ot.Up, Ot.Down), Mr(n, Ot.RotateLeft, Ot.RotateRight), Mr(n, Ot.TiltUp, Ot.TiltDown);
}
function Mr(n, t, e) {
  n.has(t) && n.has(e) && (n.delete(t), n.delete(e));
}
function zc(n, t, e) {
  return Math.max(Math.min(n, e), t);
}
function Pm(n) {
  const t = n.getViewAxes().upVector;
  return console.assert(t.isAxis()), d.scale(t, -1);
}
function Vh(n, t) {
  const e = new Ie(Xt.Face);
  return e.bimMask = n, e.ignoreOverlays = !0, t !== null && (e.maxWorldDistance = t), e;
}
async function Bc(n, t, e, i) {
  const s = new Vn(t, e), r = Vh(ei.Floor, i), o = await n.pickFromRay(s, r);
  return o.isFaceSelection() ? o.getPosition() : null;
}
async function Gm(n, t, e, i) {
  const s = new Vn(t, e.copy().normalize()), r = Vh(ei.Wall, i), o = await n.pickFromRay(s, r);
  return o.isFaceSelection() ? o : null;
}
class U_ {
  constructor() {
    this._action = new fs(!0), this._latestPromise = null, this._timestamp = 0;
  }
  isIdle() {
    return this._latestPromise === null && this._action.isIdle();
  }
  /**
   * Returned promise can reject if future calls are made. This is by design.
   */
  set(t) {
    const e = ++this._timestamp;
    this._latestPromise !== null && this._latestPromise.reject(void 0);
    const i = be();
    return this._latestPromise = i, this._action.clear(), this._action.waitForIdle().then(() => {
      e === this._timestamp && this._action.set(() => {
        if (e !== this._timestamp)
          return;
        i === this._latestPromise && (this._latestPromise = null), typeof t == "function" && (t = ji.create(t));
        let s;
        try {
          s = t.get();
        } catch (r) {
          return this._advance(i, !0, r);
        }
        return s === void 0 ? this._advance(i, !1, null) : s.then(
          () => this._advance(i, !1, null),
          (r) => this._advance(i, !0, r)
        );
      });
    }), i;
  }
  _advance(t, e, i) {
    t === this._latestPromise && (this._latestPromise = null), e ? t.reject(i) : t.resolve();
  }
}
class Jc {
  constructor(t, e) {
    this._button = t, this._modifier = e;
  }
  getButton() {
    return this._button;
  }
  getModifier() {
    return this._modifier;
  }
}
class Se {
  /** @hidden */
  constructor(t) {
    this._ptFirst = E.zero(), this._ptPrevious = E.zero(), this._ptCurrent = E.zero(), this._dragging = !1, this._dragCount = 0, this._primaryTouchId = null, this._mapping = [], this._buttonModifierActive = !1, this._doubleClickInterval = 200, this._firstMouseDownTime = null, this._isDoubleClick = !1, this._viewer = t;
  }
  /** @hidden */
  onDoubleClick(t) {
  }
  /** @hidden */
  onMouseDown(t) {
    if (this._firstMouseDownTime ? Date.now() - this._firstMouseDownTime < this._doubleClickInterval ? (this._isDoubleClick = !0, this._firstMouseDownTime = null) : this._firstMouseDownTime = Date.now() : (this._firstMouseDownTime = Date.now(), this._isDoubleClick = !1), this._isDoubleClick)
      this.onDoubleClick(t);
    else {
      if (this._buttonModifierActive = this.checkMapping(t), this._buttonModifierActive) {
        const e = t.getPosition();
        this._ptFirst.assign(e), this._ptPrevious.assign(e), this._ptCurrent.assign(e);
      }
      this._dragging = !0;
    }
  }
  /** @hidden */
  onMouseMove(t) {
    this.isActive() && (this._ptPrevious.assign(this._ptCurrent), this._ptCurrent.assign(t.getPosition()), this._dragging && (this._ptCurrent.equals(this._ptPrevious) || (++this._dragCount, this._dragCount === 1 && this._viewer.trigger("beginInteraction"))));
  }
  /** @hidden */
  onMouseUp(t) {
    this._buttonModifierActive && this.stopInteraction(), this._dragging = !1, this._dragCount = 0;
  }
  /** @hidden */
  stopInteraction() {
    this._viewer.trigger("endInteraction"), this._dragging = !1, this._dragCount = 0, this._buttonModifierActive = !1;
  }
  /** @hidden */
  isDragging() {
    return this._dragging;
  }
  /** @hidden */
  isActive() {
    return (this._buttonModifierActive || this._primaryTouchId !== null) && !this._isDoubleClick && !this._viewer.getContextMenuStatus();
  }
  /** @hidden */
  onTouchStart(t) {
    if (this._primaryTouchId === null) {
      this._primaryTouchId = t.getId();
      const e = t.getPosition(), i = new Qn(
        e.x,
        e.y,
        Kt.None,
        t.getButtons(),
        ye.None,
        Gn.Down
      );
      this.onMouseDown(i);
    }
    t.setHandled(this.setHandled());
  }
  /** @hidden */
  async onTouchMove(t) {
    if (this._primaryTouchId === t.getId()) {
      const e = t.getPosition(), i = new Qn(
        e.x,
        e.y,
        Kt.None,
        t.getButtons(),
        ye.None,
        Gn.Move
      );
      await this.onMouseMove(i);
    }
    return t.setHandled(this.setHandled()), Promise.resolve();
  }
  /** @hidden */
  onTouchEnd(t) {
    if (this._primaryTouchId === t.getId()) {
      const e = t.getPosition(), i = new Qn(
        e.x,
        e.y,
        Kt.None,
        t.getButtons(),
        ye.None,
        Gn.Up
      );
      this.onMouseUp(i), this._primaryTouchId = null;
    }
    t.setHandled(this.setHandled());
  }
  /**
   * Adds a button and key modifier mapping for the operator. If no mapping is provided, all combinations are considered valid.
   * All mappings require a mouse button, but a key modifier is optional.
   * @param button
   * @param modifier
   */
  addMapping(t, e = ye.None) {
    this._mapping.push(new Jc(t, e));
  }
  /**
   * Clears any button and key modifier mappings for the operator.
   */
  clearMapping() {
    this._mapping = [];
  }
  /**
   * Sets the button and key modifier mapping for the operator.
   * @param button
   * @param modifier
   */
  setMapping(t, e = ye.None) {
    this._mapping = [], this._mapping.push(new Jc(t, e));
  }
  /** @hidden */
  checkMapping(t) {
    if (this._mapping.length === 0)
      return !0;
    for (const e of this._mapping)
      if (e.getButton() === t.getButton() && e.getModifier() === t.getModifiers())
        return !0;
    return !1;
  }
  /** @hidden */
  setHandled() {
    return !1;
  }
  /** @hidden */
  onDeactivate() {
    const t = this.stopInteraction();
    return this._primaryTouchId = null, t;
  }
}
class Va {
  constructor(t, e) {
    this._mode = t, this._impl = new ey(e);
  }
  /**
   * Creates a new `IncrementalSelection` object that can be used to perform incremental selections.
   *
   * @param mode Controls whether or not selections are performed using the [[View]] or the [[SelectionManager]].
   * @param viewer The `WebViewer` of the scene.
   * @param createSelectionPredicate This callback is used to create a selection predicate. Return null to not filter selection results.
   * @returns The created `IncrementalSelection` object.
   */
  static create(t, e) {
    return new Va(t, e);
  }
  performSelection(t, e, i) {
    const s = this._impl.viewer;
    let r;
    return this._mode === "View" ? (r = s.view, i === void 0 && (i = [])) : (this._mode, r = s.selectionManager), e === void 0 && (e = null), this._impl.performSelection(r, t, e, i);
  }
  /**
   * Returns whether or not this object has an active selection in progress.
   * @returns `true` if active and `false` if idle.
   */
  isIdle() {
    return this._impl.isIdle();
  }
  /**
   * Used to wait for this object to become idle.
   * @returns A promise that resolves when this becomes idle.
   */
  waitForIdle() {
    return this._impl.waitForIdle();
  }
  /**
   * Stops the selection.
   * @returns A `Promise` that resolves when completed.
   */
  stopSelection() {
    return this._impl.stopSelection();
  }
  /**
   * Stops and clears the selection.
   * @returns A `Promise` that resolves when completed.
   */
  clearSelection() {
    return this._impl.clearSelection();
  }
}
function Q_(n) {
  return "areaCssMin" in n;
}
function q_(n) {
  return "rayCssBoxRadius" in n;
}
function $_(n) {
  return "volumePlanes" in n;
}
function ty(n) {
  return "sphereRadius" in n;
}
class ey {
  constructor(t) {
    this._killHandles = [], this._activeSelectionCount = 0, this._inactivityPromise = null, this.viewer = t;
  }
  isIdle() {
    return this._activeSelectionCount === 0;
  }
  async waitForIdle() {
    return this._activeSelectionCount === 0 ? (console.assert(this._inactivityPromise === null), Promise.resolve()) : (this._inactivityPromise === null && (this._inactivityPromise = be()), this._inactivityPromise);
  }
  async stopSelection() {
    console.assert(this._killHandles.length === this._activeSelectionCount);
    const t = [];
    for (const e of this._killHandles)
      t.push(e());
    return zt(t);
  }
  async clearSelection() {
    const t = this.viewer.selectionManager;
    t.clear(), await this.stopSelection(), t.clear();
  }
  async _advanceBySelectionManager(t, e) {
    return this.viewer.selectionManager.advanceIncrementalSelection(t, e);
  }
  async _advanceByView(t, e, i) {
    let r = await this.viewer.view.advanceIncrementalSelection(t);
    if (r === null)
      return !1;
    if (e) {
      const o = await Promise.all(r.map(e));
      r = r.filter((a, l) => o[l]);
    }
    for (const o of r)
      i.push(o);
    return !0;
  }
  _wrapBeginSelection(t, e) {
    return Q_(e) ? t.beginScreenSelectByArea(
      e.areaCssMin,
      e.areaCssMax,
      e.pickConfig
    ) : q_(e) ? t.beginRayDrillSelection(
      e.rayCssOrigin,
      e.rayCssBoxRadius,
      e.pickConfig
    ) : $_(e) ? t.beginConvexPolyhedronSelection(
      e.volumePlanes,
      e.heuristicOrigin,
      e.pickConfig
    ) : ty(e) ? t.beginSphereSelection(
      e.sphereCenter,
      e.sphereRadius,
      e.pickConfig
    ) : $n();
  }
  async performSelection(t, e, i, s) {
    return s === void 0 ? this._performSelection(t, e, i, null) : (await this._performSelection(t, e, i, s), s);
  }
  async _performSelection(t, e, i, s) {
    const r = this._wrapBeginSelection(t, e);
    if (r === null)
      return;
    ++this._activeSelectionCount;
    const o = this.viewer.selectionManager, a = s === null;
    let l = !1;
    const c = ji.create(async () => {
      l = !0;
      try {
        const u = await r;
        a ? await o.endIncrementalSelection(u) : await this.viewer.view.endIncrementalSelection(u);
      } finally {
        const u = this._killHandles.indexOf(h);
        console.assert(u >= 0), this._killHandles.splice(u, 1), --this._activeSelectionCount, this._activeSelectionCount === 0 && this._inactivityPromise !== null && (this._inactivityPromise.resolve(), this._inactivityPromise = null);
      }
    }), h = () => c.get();
    this._killHandles.push(h);
    try {
      const u = await r;
      let p = !0;
      for (; p && !l; )
        a ? p = await this._advanceBySelectionManager(u, i) : p = await this._advanceByView(u, i, s), p && !l && await Ll(1);
    } finally {
      await h();
    }
  }
}
class Ym {
  constructor(t) {
    this._nearbyDoors = /* @__PURE__ */ new Set(), this._viewer = t;
  }
  _performSphereSelection(t, e, i) {
    const s = Va.create("View", this._viewer), r = new Dl(Xt.Face);
    return r.bimMask = i, r.onlyStreamedInstances = !0, r.ignoreUnrequestedInstances = !0, s.performSelection({
      pickConfig: r,
      sphereCenter: t,
      sphereRadius: e
    });
  }
  async updateNearbyDoors(t, e, i) {
    const s = await this._performSphereSelection(
      t,
      e,
      ei.Door
    ), r = /* @__PURE__ */ new Set();
    for (const u of s) {
      const p = u.getNodeId();
      r.add(p);
    }
    const o = Ic(r, this._nearbyDoors), a = Ic(this._nearbyDoors, r), l = us(o), c = us(a), h = this._viewer.model;
    h.setNodesOpacity(l, i), h.resetNodesOpacity(c), this._nearbyDoors = r;
  }
  forgetNearbyDoors() {
    const t = us(this._nearbyDoors);
    this._nearbyDoors.clear(), this._viewer.model.resetNodesOpacity(t);
  }
}
class Th extends Se {
  /** @hidden */
  constructor(t) {
    super(t), this._elevationSpeed = 0, this._rotationSpeed = 0, this._viewAngle = 90, this._zoomDistance = 0, this._walkDistance = 0, this._tilt = 0, this._majorAxis = Ht.X, this._maxExtents = 0, this._walkActive = !1, this._activeWalk = new fs(!0), this._bimModeEnabled = !1, this._synchronizedToggleBimMode = new U_(), this._initialInteractiveDrawLimitIncreaseStatus = !0, this._logical = {
      floor: {
        ...Zl
      },
      wall: {
        ...Cl
      },
      door: {
        ...kl
      }
    }, this._effective = {
      floor: {
        ...Zl
      },
      wall: {
        ...Cl
      },
      door: {
        ...kl
      }
    }, this._doorCache = new Ym(t), this._downAxis = new d(0, -1, 0), t.setCallbacks({
      subtreeLoaded: (e, i) => {
        i === ps.LoadModel && this._updateSceneFloor();
      }
    });
  }
  _updateSceneFloor() {
    this._downAxis = Pm(this._viewer.model);
  }
  isBimModeEnabled() {
    return this._bimModeEnabled;
  }
  async _enableBimMode() {
    this._bimModeEnabled = !0, this._effective.floor = this._scaleAgainstModelUnit(this._logical.floor), this._effective.wall = this._scaleAgainstModelUnit(this._logical.wall), this._effective.door = this._scaleAgainstModelUnit(this._logical.door), this._updateSceneFloor(), await this._applyGravity(), await this._updateNearbyDoors();
  }
  _disableBimMode() {
    this._bimModeEnabled = !1, this._doorCache.forgetNearbyDoors();
  }
  /**
   * Enables BIM mode, which includes collision detection
   */
  enableBimMode() {
    return this._synchronizedToggleBimMode.set(async () => {
      await this._enableBimMode();
    });
  }
  /**
   * Disables BIM mode, which includes collision detection
   */
  disableBimMode() {
    return this._synchronizedToggleBimMode.set(() => {
      this._disableBimMode();
    });
  }
  /**
   * Toggles BIM mode, deactivating it if it's activated and activating it if it's deactivated
   */
  toggleBimMode() {
    return this._synchronizedToggleBimMode.set(() => this._bimModeEnabled ? this._disableBimMode() : this._enableBimMode());
  }
  /** @hidden */
  async onActivate() {
    this._viewer.view.setProjectionMode(te.Perspective);
    const t = this._viewer.view;
    if (this._initialInteractiveDrawLimitIncreaseStatus = await t.getInteractiveDrawLimitIncreaseEnabled(), t.setInteractiveDrawLimitIncreaseEnabled(!1), this._calculateInitialPosition(), this._maxExtents === 0 && await this.resetDefaultWalkSpeeds(), this._bimModeEnabled && await this._updateNearbyDoors(), this._viewer.floorplanManager.getConfiguration().autoActivate === Xs.BimWalk) {
      const i = this._viewer.model.getNodesByGenericType("IFCBUILDINGSTOREY");
      i && i.size > 0 && await this._viewer.floorplanManager.activate();
    }
  }
  /** @hidden */
  async onDeactivate() {
    if (this._viewer.view.setInteractiveDrawLimitIncreaseEnabled(
      this._initialInteractiveDrawLimitIncreaseStatus
    ), this._doorCache.forgetNearbyDoors(), this._viewer.floorplanManager.getConfiguration().autoActivate === Xs.BimWalk) {
      const e = this._viewer.model.getNodesByGenericType("IFCBUILDINGSTOREY");
      e && e.size > 0 && await this._viewer.floorplanManager.deactivate();
    }
    super.onDeactivate();
  }
  /**
   * Sets the walk, rotate, and mouse look speeds to the default values.
   */
  async resetDefaultWalkSpeeds() {
    this._rotationSpeed = 40, this._viewAngle = 90;
    const e = (await this._viewer.model.getLooseBounding()).extents();
    this._maxExtents = Math.max(e.x, e.y, e.z), this._walkDistance = this._maxExtents / 15, this._elevationSpeed = this._maxExtents / 10, this._zoomDistance = this._maxExtents / 30;
  }
  /**
   * Gets the floor distance config used by BIM mode.
   * See also: [[enableBimMode]].
   */
  getBimFloorConfig() {
    return { ...this._logical.floor };
  }
  /**
   * Sets the floor distance config used by BIM mode.
   * See also: [[enableBimMode]].
   */
  setBimFloorConfig(t) {
    this._logical.floor = { ...t }, this._effective.floor = this._scaleAgainstModelUnit(this._logical.floor);
  }
  /**
   * Gets the wall distance config used by BIM mode.
   * See also: [[enableBimMode]].
   */
  getBimWallConfig() {
    return { ...this._logical.wall };
  }
  /**
   * Sets the wall distance config used by BIM mode.
   * See also: [[enableBimMode]].
   */
  setBimWallConfig(t) {
    this._logical.wall = { ...t }, this._effective.wall = this._scaleAgainstModelUnit(this._logical.wall);
  }
  /**
   * Gets the door distance config used by BIM mode.
   * See also: [[enableBimMode]].
   */
  getBimDoorConfig() {
    return { ...this._logical.door };
  }
  /**
   * Sets the door distance config used by BIM mode.
   */
  setBimDoorConfig(t) {
    this._logical.door = { ...t }, this._effective.door = this._scaleAgainstModelUnit(this._logical.door);
  }
  _scaleAgainstModelUnit(t) {
    const e = this._viewer.model, i = 1 / e.getNodeUnitMultiplier(e.getAbsoluteRootNode());
    t = { ...t };
    const s = Object.keys(t);
    for (const r of s)
      typeof t[r] == "number" && (t[r] *= i);
    return t;
  }
  /** @hidden */
  onMouseDown(t) {
    super.onMouseDown(t);
  }
  /** @hidden */
  onMouseMove(t) {
    super.onMouseMove(t);
  }
  /** @hidden */
  onMouseUp(t) {
    super.onMouseUp(t);
  }
  /** @hidden */
  async _applyGravity() {
    const t = this._viewer.view, e = t.getCamera();
    let i = e.getPosition(), s = await Bc(
      t,
      i,
      this._downAxis,
      this._effective.floor.maxFallDistance
    );
    if (s === null && (i = d.subtract(
      i,
      d.scale(this._downAxis, this._effective.floor.avatarOffset)
    ), s = await Bc(
      t,
      i,
      this._downAxis,
      this._effective.floor.maxFallDistance
    ), s === null))
      return;
    const r = new d(0, 0, this._effective.floor.avatarOffset), o = d.add(s, r), a = d.subtract(o, i), l = a.length();
    l > this._effective.floor.negligibleClimbHeight && Yn(a, this._downAxis) > 90 && l > this._effective.floor.maxClimbHeight || this._applyWalkDelta(e, a);
  }
  /** @hidden */
  _updateNearbyDoors() {
    const e = this._viewer.view.getCamera().getPosition(), i = 0.5;
    return this._doorCache.updateNearbyDoors(
      e,
      this._effective.door.transparencyRange,
      i
    );
  }
  _updateCamera(t) {
    this._resetPosition(t), this._updateCameraTilt(t), this._updateCameraViewAngle(t), this._viewer.view.setCamera(t);
  }
  /** @hidden */
  _applyWalkDelta(t, e) {
    t.dolly(d.scale(e, -1)), this._updateCamera(t);
  }
  /** @hidden */
  async _applyWalkDeltaWithCollisionCheck(t, e, i) {
    const s = t.getPosition(), o = Q.createFromOffAxisRotation(i, 90).transform(e), l = Q.createFromOffAxisRotation(i, -90).transform(e), c = this._testWallCollision(
      s,
      o,
      this._effective.wall.avatarOffset
    ), h = this._testWallCollision(
      s,
      l,
      this._effective.wall.avatarOffset
    ), u = this._testWallCollision(
      s,
      e,
      e.length() + this._effective.wall.avatarOffset
    ), [p, m] = await Promise.all([
      c,
      h
    ]);
    if (p !== null || m !== null) {
      const _ = (y) => {
        if (y !== null) {
          const b = y.getFaceEntity().getNormal();
          return Yn(b, e) > 90;
        }
        return !1;
      };
      if (_(p) || _(m))
        return;
    }
    const g = await u;
    if (g !== null) {
      const _ = e.length(), y = d.scale(e, 1 / _), w = d.subtract(g.getPosition(), s).length() - this._effective.wall.avatarOffset, v = Math.min(_, w);
      e = d.scale(y, v);
    }
    this._applyWalkDelta(t, e);
  }
  _testWallCollision(t, e, i) {
    return Gm(this._viewer.view, t, e, i);
  }
  _walkBackward(t, e) {
    const s = this._viewer.view.getCamera();
    this._resetPosition(s);
    const r = s.getTarget(), o = s.getPosition(), a = s.getUp(), c = d.subtract(o, r).normalize().copy().scale(t);
    return e ? this._applyWalkDeltaWithCollisionCheck(s, c, a) : this._applyWalkDelta(s, c);
  }
  _walkForward(t, e) {
    return this._walkBackward(-t, e);
  }
  _walkLeft(t, e) {
    const s = this._viewer.view.getCamera();
    this._resetPosition(s);
    const r = s.getTarget(), o = s.getPosition(), a = s.getUp(), l = d.subtract(r, o).normalize(), h = d.cross(a, l).normalize().copy().scale(t);
    return e ? this._applyWalkDeltaWithCollisionCheck(s, h, a) : this._applyWalkDelta(s, h);
  }
  _walkRight(t, e) {
    return this._walkLeft(-t, e);
  }
  walkBackward(t) {
    return this._walkBackward(t, !1);
  }
  walkForward(t) {
    return this._walkForward(t, !1);
  }
  walkLeft(t) {
    return this._walkLeft(t, !1);
  }
  walkRight(t) {
    return this._walkRight(t, !1);
  }
  walkBackwardWithCollision(t) {
    return this._walkBackward(t, !0);
  }
  walkForwardWithCollision(t) {
    return this._walkForward(t, !0);
  }
  walkLeftWithCollision(t) {
    return this._walkLeft(t, !0);
  }
  walkRightWithCollision(t) {
    return this._walkRight(t, !0);
  }
  walkDown(t) {
    const i = this._viewer.view.getCamera();
    this._resetPosition(i);
    const s = i.getUp().normalize().scale(t);
    this._applyWalkDelta(i, s);
  }
  walkUp(t) {
    this.walkDown(-t);
  }
  rotateRight(t) {
    const i = this._viewer.view.getCamera();
    this._resetPosition(i);
    const s = i.getTarget(), r = i.getPosition(), a = d.subtract(r, s).length(), l = d.subtract(s, r).normalize(), c = cs(t), h = Math.tan(c), p = d.subtract(i.getTarget(), i.getPosition()).length() * h, m = d.cross(l, i.getUp()).scale(p);
    let g = s.copy().add(m);
    const _ = d.subtract(g, r).normalize().scale(a);
    g = d.add(r, _), i.setTarget(g), this._updateCamera(i);
  }
  rotateLeft(t) {
    this.rotateRight(-t);
  }
  tiltDown(t) {
    this.setTilt(this._tilt + t);
    const i = this._viewer.view.getCamera();
    this._resetPosition(i), this._updateCamera(i);
  }
  tiltUp(t) {
    this.tiltDown(-t);
  }
  /** @hidden */
  _calculateInitialPosition() {
    const e = this._viewer.view.getCamera();
    this._calculateMajorAxis(e), this.setTilt(this._calculateInitialTilt(e)), this._resetPosition(e), this._updateCamera(e);
  }
  _updateCameraViewAngle(t) {
    const e = cs(this._viewAngle), i = Math.tan(e / 2), r = d.subtract(t.getTarget(), t.getPosition()).length() * i;
    t.setWidth(r), t.setHeight(r);
  }
  _updateCameraTilt(t) {
    const e = t.getPosition(), i = t.getTarget(), s = t.getUp().normalize(), r = d.subtract(i, e).normalize(), o = d.cross(s, r).normalize(), a = d.distance(i, e);
    Q.createFromOffAxisRotation(o, this._tilt).transform(r, r), t.setTarget(d.add(e, r.scale(a)));
  }
  _calculateInitialTilt(t) {
    const e = t.getTarget(), i = t.getPosition(), s = d.subtract(e, i), r = s.length();
    this._majorAxis === Ht.X ? s.x = 0 : this._majorAxis === Ht.Y ? s.y = 0 : this._majorAxis === Ht.Z && (s.z = 0);
    const o = s.length();
    return Math.acos(o / r) * (180 / Math.PI);
  }
  /** @hidden */
  _resetPosition(t) {
    this._calculateMajorAxis(t);
    const e = t.getPosition(), i = t.getTarget(), s = d.subtract(i, e);
    let r = s.length();
    switch (this.getWalkSpeed() > 0 && (r = this.getWalkSpeed()), this._majorAxis) {
      case Ht.X:
        s.set(0, s.y, s.z), t.setUp(new d(1, 0, 0));
        break;
      case Ht.Y:
        s.set(s.x, 0, s.z), t.setUp(new d(0, 1, 0));
        break;
      case Ht.Z:
        s.set(s.x, s.y, 0), t.setUp(new d(0, 0, 1));
        break;
    }
    s.normalize().scale(r), t.setTarget(d.add(e, s));
  }
  /** @hidden */
  _calculateMajorAxis(t) {
    const e = t.getUp(), i = Math.abs(e.x), s = Math.abs(e.y), r = Math.abs(e.z);
    r >= i && r >= s ? this._majorAxis = Ht.Z : s >= i && s >= r ? this._majorAxis = Ht.Y : this._majorAxis = Ht.X;
  }
  /**
   * Sets the speed to walk when using the mouse scroll wheel.
   * @param zoomSpeed distance for walking with the mouse scroll wheel.
   */
  setZoomSpeed(t) {
    this._zoomDistance = t;
  }
  /**
   * Gets the speed used when walking with the mouse scroll wheel.
   */
  getZoomSpeed() {
    return this._zoomDistance;
  }
  /**
   * Sets the tilt value. Values must be between -45 and 45 degrees.
   * @param tilt
   */
  setTilt(t) {
    this._tilt = zc(t, Cm, Zm);
    const e = this._viewer.view.getCamera();
    this._updateCamera(e);
  }
  /**
   * Gets the tilt value.
   */
  getTilt() {
    return this._tilt;
  }
  /**
   * Sets the view angle. Values must be between 30 and 150 degrees.
   * @param viewAngle
   */
  setViewAngle(t) {
    const e = zc(t, Mm, km);
    this._viewAngle !== e && (this._viewAngle = e, this._updateCamera(this._viewer.view.getCamera()));
  }
  /**
   * Gets the view angle.
   */
  getViewAngle() {
    return this._viewAngle;
  }
  /**
   * Sets the walkSpeed for walking forward, backwards, left, and right.
   * @param walkSpeed The camera will move by walkSpeed per second.
   */
  setWalkSpeed(t) {
    this._walkDistance = t;
  }
  /**
   * Gets the walkSpeed for walking forward, backwards, left, and right.
   */
  getWalkSpeed() {
    return this._walkDistance;
  }
  /**
   * Sets the elevation speed for moving the camera up and down.
   * @param elevationSpeed The camera will move by elevationSpeed per second.
   */
  setElevationSpeed(t) {
    this._elevationSpeed = t;
  }
  /**
   * Gets the elevation speed for moving the camera up and down.
   */
  getElevationSpeed() {
    return this._elevationSpeed;
  }
  /**
   * Sets the rotation speed for tilt and rotate.
   * @param rotationSpeed The camera will rotate by rotationSpeed degrees per second.
   */
  setRotationSpeed(t) {
    this._rotationSpeed = t;
  }
  /**
   * Gets the rotation speed for tilt and rotate.
   */
  getRotationSpeed() {
    return this._rotationSpeed;
  }
  /** @hidden */
  setWalkActive(t) {
    this._walkActive = t;
  }
  /**
   * Returns true if walking is currently active
   */
  getWalkActive() {
    return this._walkActive;
  }
  /**
   * Returns true if BIM mode is currently active
   */
  getBimModeEnabled() {
    return this._bimModeEnabled;
  }
  /**
   * Get major axis
   */
  getMajorAxis() {
    return this._majorAxis;
  }
  /** @hidden */
  getActiveWalk() {
    return this._activeWalk;
  }
}
class Wl extends Th {
  /** @hidden */
  constructor(t) {
    super(t), this._keyWalkMapping = /* @__PURE__ */ new Map(), this._keyUpMap = /* @__PURE__ */ new Map(), this._keyDownMap = /* @__PURE__ */ new Map(), this._mouseLookSpeed = 0, this._mouseLookEnabled = !0, this._previousWalkTime = 0, this._tickTimerId = null, t.setCallbacks({
      camera: (e) => {
        e.getProjection() !== te.Perspective && this._keyDownMap.clear();
      }
    }), this.addKeyMapping(Ut.a, Ot.Left), this.addKeyMapping(Ut.d, Ot.Right), this.addKeyMapping(Ut.w, Ot.Forward), this.addKeyMapping(Ut.s, Ot.Backward), this.addKeyMapping(Ut.q, Ot.RotateLeft), this.addKeyMapping(Ut.e, Ot.RotateRight), this.addKeyMapping(Ut.r, Ot.TiltUp), this.addKeyMapping(Ut.f, Ot.TiltDown), this.addKeyMapping(Ut.x, Ot.Up), this.addKeyMapping(Ut.c, Ot.Down), this.addKeyMapping(Ut.LeftArrow, Ot.Left), this.addKeyMapping(Ut.RightArrow, Ot.Right), this.addKeyMapping(Ut.UpArrow, Ot.Forward), this.addKeyMapping(Ut.DownArrow, Ot.Backward);
  }
  /**
   * Adds a key mapping for a walk direction.
   * @param key
   * @param walkDirection
   */
  addKeyMapping(t, e) {
    this._keyWalkMapping.set(t, e);
  }
  /**
   * Gets the walk direction key mapping.
   */
  getKeyMapping() {
    return Nl(this._keyWalkMapping);
  }
  /**
   * Clears all key mappings.
   */
  clearKeyMappings() {
    this._keyWalkMapping.clear();
  }
  /** @hidden */
  onMouseDown(t) {
    super.onMouseDown(t), this._viewer.focusInput(!0);
  }
  /** @hidden */
  onMouseMove(t) {
    if (super.onMouseMove(t), this._dragging && this._mouseLookEnabled) {
      this._viewer.view.setProjectionMode(te.Perspective);
      const e = window.screen.width, i = window.screen.height;
      t.setHandled(!0);
      const s = E.subtract(this._ptPrevious, this._ptCurrent);
      this.rotateLeft(s.x / e * this._mouseLookSpeed), this.tiltUp(s.y / i * this._mouseLookSpeed);
    }
  }
  /** @hidden */
  onMouseUp(t) {
    this._dragCount > 5 && t.setHandled(!0), super.onMouseUp(t);
  }
  /** @hidden */
  onMousewheel(t) {
    this._viewer.view.setProjectionMode(te.Perspective);
    const e = this._viewer.view, i = e.getCamera(), s = t.getPosition(), r = t.getWheelDelta();
    e.pickFromPoint(s, new Ie(Xt.Face)).then((o) => {
      const a = o.getPosition();
      if (o !== null && a !== null) {
        const c = d.subtract(
          i.getPosition(),
          a
        ).normalize().scale(this.getZoomSpeed() * r);
        this._applyWalkDelta(i, c);
      } else
        this.walkBackward(r * this.getWalkSpeed());
    });
  }
  /** @hidden */
  onKeyDown(t) {
    this._viewer.view.setProjectionMode(te.Perspective);
    const e = t.getKeyCode();
    e === Ut.v && this.toggleBimMode(), this._keyCodeActive(e) || (this._keyDownMap.set(e, t.getDate().getTime()), this._onKeyChange(e));
  }
  /** @hidden */
  onKeyUp(t) {
    const e = t.getKeyCode();
    this._keyUpMap.set(e, t.getDate().getTime()), this._onKeyChange(e);
  }
  _keyCodeActive(t) {
    const e = this._keyDownMap.get(t);
    if (e !== void 0) {
      const i = this._keyUpMap.get(t);
      if (i === void 0 || e > i)
        return !0;
    }
    return !1;
  }
  _onKeyChange(t) {
    this._keyCodeActive(t) && this._keyWalkMapping.has(t) && (this.getWalkActive() || (this._previousWalkTime = Date.now()), this._onTick());
  }
  /**
   * Sets the speed for mouse look.
   * @param mouseLookSpeed
   */
  setMouseLookSpeed(t) {
    this._mouseLookSpeed = t;
  }
  /**
   * Gets the mouse look speed.
   */
  getMouseLookSpeed() {
    return this._mouseLookSpeed;
  }
  /**
   * Sets whether the mouse look is enabled. If enabled, mouse move events will not continue down the operator stack.
   * @param mouseLookEnabled
   */
  setMouseLookEnabled(t) {
    this._mouseLookEnabled = t;
  }
  /**
   * Gets whether the mouse look is enabled. If enabled, mouse move events will not continue down the operator stack.
   */
  getMouseLookEnabled() {
    return this._mouseLookEnabled;
  }
  async resetDefaultWalkSpeeds() {
    return super.resetDefaultWalkSpeeds().then(() => {
      this._mouseLookSpeed = 300;
    });
  }
  _execWalkDirection(t, e, i) {
    const s = this.getWalkSpeed() * e;
    switch (t) {
      case Ot.Forward:
        return i ? this.walkForwardWithCollision(s) : this.walkForward(s);
      case Ot.Backward:
        return i ? this.walkBackwardWithCollision(s) : this.walkBackward(s);
      case Ot.Left:
        return i ? this.walkLeftWithCollision(s) : this.walkLeft(s);
      case Ot.Right:
        return i ? this.walkRightWithCollision(s) : this.walkRight(s);
      case Ot.Up:
        return this.walkUp(this.getElevationSpeed() * e);
      case Ot.Down:
        return this.walkDown(this.getElevationSpeed() * e);
      case Ot.RotateLeft:
        return this.rotateLeft(this.getRotationSpeed() * e);
      case Ot.RotateRight:
        return this.rotateRight(this.getRotationSpeed() * e);
      case Ot.TiltUp:
        return this.tiltUp(this.getRotationSpeed() * e);
      case Ot.TiltDown:
        return this.tiltDown(this.getRotationSpeed() * e);
      default:
        $n();
    }
  }
  _queueWalkDirections(t) {
    const e = /* @__PURE__ */ new Set();
    this._keyWalkMapping.forEach((s, r) => {
      this._keyCodeActive(r) && e.add(s);
    }), Wm(e);
    const i = us(e);
    if (i.sort(), i.length > 0) {
      this.setWalkActive(!0);
      const s = this.getBimModeEnabled();
      this.getActiveWalk().set(async () => {
        const r = new Po(1, !0);
        if (t > 0)
          for (const o of i)
            r.push(() => this._execWalkDirection(o, t, s));
        if (s && (!e.has(Ot.Up) && !e.has(Ot.Down) && r.push(async () => {
          await this._applyGravity();
        }), r.push(async () => {
          await this._updateNearbyDoors();
        })), !r.isIdle())
          return r.waitForIdle();
      });
    }
  }
  /** @hidden */
  _onTick() {
    const t = Date.now(), e = (t - this._previousWalkTime) / 1e3;
    this._previousWalkTime = t;
    const i = !this.getActiveWalk().isIdle();
    this.setWalkActive(i), this._queueWalkDirections(e), this._tickTimerId !== null && (cancelAnimationFrame(this._tickTimerId), this._tickTimerId = null), this.getWalkActive() && (this._tickTimerId = requestAnimationFrame(() => {
      this._onTick();
    }));
  }
}
class Vm {
  /**
   * Caches a stream of points generated in time by storing them in a wrapped array, from oldest to newest. When the wrap occurs, the oldest, earliest entries are overwritten
   * @param {number} maxPoints the maximum point stream size
   */
  constructor(t = 10) {
    this._count = 0, this._points = new Array(t), this._times = new Array(t);
  }
  /**
   * Clears the array of points
   */
  clear() {
    this._count = 0;
  }
  /**
   * Adds a point to the array of points, possibly overwriting the oldest one
   */
  add(t, e = Date.now()) {
    const i = this._count % this._points.length;
    this._points[i] === void 0 ? this._points[i] = t.copy() : this._points[i].assign(t), this._times[i] = e, this._count++;
  }
  /**
   * Gets the average offset from the first point specified between (now - offset) and now
   */
  getAverageOffsetWithinMilliseconds(t, e = Date.now()) {
    let i = -1;
    const s = E.zero(), r = Math.min(this._points.length, this._count);
    if (r > 0) {
      let o = 0;
      for (let a = 0; a < r; a++) {
        const l = (this._count - 1 - a) % this._points.length;
        if (e - this._times[l] > t)
          break;
        i = l, s.add(this._points[l]), o++;
      }
      o > 1 ? (s.subtract(this._points[i]), o--, s.scale(1 / o)) : (i = -1, s.set(0, 0));
    }
    return i >= 0 ? E.subtract(s, this._points[i]) : s;
  }
}
class Eh extends Se {
  /** @hidden */
  constructor(t, e) {
    super(t), this._cameraRotationMomentumEnabled = !1, this._isDown = !1, this._mouseDragged = !1, this._averagedMousePoints = new Vm(), this._averageTimeIntervalMilliseconds = 150, this._previousMouseMovePoint = E.zero(), this._mouseMovePoint = E.zero(), this._mouseMoveOffset = E.zero(), this._previousMouseMoveTime = null, this._mouseMoveTime = null, this._mouseMoveElapsedTimeSeconds = 0, this._rotationDegreesPerSecond = [0, 0], this._animationLastTickTime = 0, this._animationElapsedTimeSeconds = 0, this._animationIntervalResult = null, this._preferredAnimationIntervalMilliseconds = 16, this._momentum = 0, this._momentumLossPerSecond = 0, this._degreesPerPixel = 0.5, this._maxRotationMagnitudeScale = 8, this._initialSelectionPosition = null, this._cameraRotateFunction = e;
  }
  getCameraRotationMomentumEnabled() {
    return this._cameraRotationMomentumEnabled;
  }
  setCameraRotationMomentumEnabled(t) {
    t !== this._cameraRotationMomentumEnabled && (this._cameraRotationMomentumEnabled = t, t || this.stopAnimation());
  }
  isCurrentlyAnimating() {
    return this._cameraRotationMomentumEnabled && this.getMomentum() > 0;
  }
  /** @hidden */
  onDeactivate() {
    return super.onDeactivate();
  }
  /** @hidden */
  onViewOrientationChange() {
    this.stopAnimation();
  }
  supportsAnimation() {
    return !0;
  }
  /** @hidden */
  onMouseDown(t) {
    super.onMouseDown(t), this.isActive() && (this._initialSelectionPosition = t.getPosition(), this._isDown = !0, this.stopAnimation(), this._mouseDragged = !1, this._previousMouseMoveTime = Date.now(), this._mouseMoveTime = this._previousMouseMoveTime, this._mouseMovePoint.assign(this._initialSelectionPosition), this._previousMouseMovePoint.assign(this._mouseMovePoint), this._averagedMousePoints.clear(), this._averagedMousePoints.add(this._mouseMovePoint, this._mouseMoveTime));
  }
  /** @hidden */
  onMouseMove(t) {
    if (super.onMouseMove(t), this.isActive()) {
      if (!this._isDown)
        return;
      this._mouseDragged = !0, this._previousMouseMovePoint.assign(this._mouseMovePoint), this._mouseMovePoint.assign(t.getPosition()), this._mouseMoveOffset = E.subtract(this._mouseMovePoint, this._previousMouseMovePoint), this._previousMouseMoveTime = this._mouseMoveTime, this._mouseMoveTime = Date.now(), this._mouseMoveElapsedTimeSeconds = this._previousMouseMoveTime === null ? 0 : (this._mouseMoveTime - this._previousMouseMoveTime) / 1e3, this._averagedMousePoints.add(this._mouseMovePoint, this._mouseMoveTime);
      const e = this._getMouseMoveOffsetForRotation();
      this._rotateCamera(e);
    }
  }
  /** @hidden */
  onMouseUp(t) {
    if (this.isActive() && (this._isDown = !1, this._mouseDragged && this.getCameraRotationMomentumEnabled())) {
      this._mouseMoveOffset = this._averagedMousePoints.getAverageOffsetWithinMilliseconds(
        this._averageTimeIntervalMilliseconds
      );
      const e = this._getMouseMoveOffsetForRotation();
      if (e[0] !== 0 || e[1] !== 0) {
        for (let i = 0; i < 2; i++) {
          const s = Math.abs(e[i]) * this._maxRotationMagnitudeScale;
          this._rotationDegreesPerSecond[i] = e[i] / this._mouseMoveElapsedTimeSeconds, this._rotationDegreesPerSecond[i] < -s ? this._rotationDegreesPerSecond[i] = -s : this._rotationDegreesPerSecond[i] > s && (this._rotationDegreesPerSecond[i] = s);
        }
        this._momentum = 1, this._startAnimation();
      } else
        this._momentum = 0;
    }
    super.onMouseUp(t);
  }
  _rotateCamera(t) {
    this._cameraRotateFunction(t);
  }
  stopAnimation() {
    this._animationIntervalResult !== null && (clearInterval(this._animationIntervalResult), this._animationIntervalResult = null);
  }
  getMomentum() {
    return this._momentum;
  }
  /**
   * Sets proportion of momentum lost per second if camera rotation momentum is enabled. At 0
   * no momentum is lost and the camera will orbit indefinitely. Above 1 the camera will stop
   * orbiting within a second of release. Only values greater than or equal to 0 are accepted.
   * @param amountLost Proportion of momentum lost per second
   */
  setMomentumLossPerSecond(t) {
    t >= 0 && (this._momentumLossPerSecond = t);
  }
  getMomentumLossPerSecond() {
    return this._momentumLossPerSecond;
  }
  isAnimating() {
    return this._animationIntervalResult !== null;
  }
  _startAnimation() {
    this._animationIntervalResult === null && (this._animationLastTickTime = Date.now(), this._animationIntervalResult = window.setInterval(() => {
      this._onTick();
    }, this._preferredAnimationIntervalMilliseconds));
  }
  _getMouseMoveOffsetForRotation() {
    return [
      -this._mouseMoveOffset.x * this._degreesPerPixel,
      this._mouseMoveOffset.y * this._degreesPerPixel
    ];
  }
  _onTick() {
    const t = Date.now();
    this._animationElapsedTimeSeconds = (t - this._animationLastTickTime) / 1e3, this._animationLastTickTime = t;
    const e = [
      this._animationElapsedTimeSeconds * this._rotationDegreesPerSecond[0],
      this._animationElapsedTimeSeconds * this._rotationDegreesPerSecond[1]
    ];
    if (this._rotateCamera(e), this._momentumLossPerSecond > 0)
      if (this._momentum = Math.max(
        0,
        this._momentum - this._animationElapsedTimeSeconds * this._momentumLossPerSecond
      ), this._momentum > 0)
        for (let i = 0; i < this._rotationDegreesPerSecond.length; i++)
          this._rotationDegreesPerSecond[i] *= this._momentum;
      else {
        for (let i = 0; i < this._rotationDegreesPerSecond.length; i++)
          this._rotationDegreesPerSecond[i] = 0;
        this._rotateCamera(this._rotationDegreesPerSecond), this.stopAnimation();
      }
  }
}
class Tm extends _s {
  constructor(t, e, i) {
    super(), this._circle = new qn(), this._viewer = t, this._position = e, this._circle.setRadius(i);
  }
  draw() {
    if (this._circle) {
      const t = this._viewer.view.projectPoint(this._position);
      this._circle.setCenter(E.fromPoint3(t)), this._viewer.markupManager.getRenderer().drawCircle(this._circle);
    }
  }
}
class Rh extends Eh {
  /** @hidden */
  constructor(t) {
    super(t, (e) => {
      if (!this._viewer.sheetManager.isDrawingSheetActive())
        if (this._pickPosition !== null) {
          if (this._circleMarkupHandler === null) {
            const i = new Tm(
              this._viewer,
              this._pickPosition,
              this._circleRadius
            );
            this._circleMarkupHandler = this._viewer.markupManager.registerMarkup(i);
          }
          this._orbitByTurnTiltWithTarget(e, this._pickPosition);
        } else {
          const i = this._viewer.view.getCamera();
          switch (this._orbitFallbackMode) {
            default:
            case fo.CameraTarget:
              this._orbitByTurnTiltWithTarget(e, i.getTarget());
              break;
            case fo.ModelCenter:
              this._modelCenter && this._orbitByTurnTiltWithTarget(e, this._modelCenter);
              break;
            case fo.OrbitTarget:
              this._orbitByTurnTiltWithTarget(e, this._orbitTarget);
              break;
          }
        }
    }), this._orbitTarget = d.zero(), this._orbitFallbackMode = fo.ModelCenter, this._modelCenter = null, this._circleMarkupHandler = null, this._circleRadius = 3, this._updateCameraCenterAction = new fs(!1), this._updateCameraCenterTimer = new As(), this._primaryButton = Kt.Middle, this._pickPosition = null, this._bimOrbitEnabled = !1, this._viewer.setCallbacks({
      sceneReady: () => {
        this._updateModelCenter();
      },
      modelSwitched: () => {
        this._updateModelCenter();
      },
      visibilityChanged: () => {
        this._updateModelCenter();
      },
      _updateTransform: (e) => {
        e || this._updateModelCenter();
      },
      _geometryCreated: () => {
        this._updateModelCenter();
      },
      hwfParseComplete: () => {
        this._updateModelCenter();
      }
    });
  }
  _updateModelCenter(t = 50) {
    this._updateCameraCenterTimer.clear(), this._updateCameraCenterAction.set(async () => {
      const e = await this._viewer.model.getModelBounding(!0, !1);
      if (e.isDegenerate() && t > 0) {
        this._updateCameraCenterTimer.set(500, () => {
          this._updateModelCenter(t - 1);
        });
        return;
      }
      this._modelCenter = e.center();
    });
  }
  /** @hidden */
  async onMouseDown(t) {
    if (super.onMouseDown(t), this.isActive() && t.getButton() === this._primaryButton) {
      const e = await this._viewer.view.pickFromPoint(
        t.getPosition(),
        new Ie(Xt.Face)
      );
      e !== null && e.overlayIndex() === 0 ? (this._pickPosition = e.getPosition(), t.setHandled(!0)) : this._pickPosition = null;
    }
  }
  /** @hidden */
  onMouseUp(t) {
    super.onMouseUp(t), t.getButton() === this._primaryButton && (this._pickPosition = null), this._removeMarkup();
  }
  /** @hidden */
  onDeactivate() {
    const t = super.onDeactivate();
    return this._updateCameraCenterTimer.clear(), t;
  }
  /**
   * BIM orbit is intended to make orbiting building models easier.
   * It slows the rotation speed, clamps vertical rotation to 180 degrees, and restricts horizontal rotation to rotate around the vertical axis.
   * @param bimOrbitEnabled
   */
  setBimOrbitEnabled(t) {
    this._bimOrbitEnabled = t;
  }
  /**
   * Returns true if BIM orbit is enabled.
   */
  getBimOrbitEnabled() {
    return this._bimOrbitEnabled;
  }
  /** @hidden */
  _removeMarkup() {
    this._circleMarkupHandler !== null && (this._viewer.markupManager.unregisterMarkup(this._circleMarkupHandler), this._circleMarkupHandler = null);
  }
  _getClampedRotationMatrix(t, e, i, s) {
    const r = Q.createFromOffAxisRotation(t, e), o = d.zero();
    return r.transform(i, o), Vl(Math.asin(d.dot(s, o))) <= 0 ? new Q() : r;
  }
  _orbitByTurnTiltWithTarget(t, e) {
    const i = this._viewer.view, s = i.getCamera();
    let r = s.getPosition().subtract(e), o = s.getTarget().subtract(e), a = s.getUp().normalize();
    const l = d.subtract(o, r).normalize(), c = d.cross(a, l).normalize(), h = t[0], u = t[1];
    let p = new Q(), m = new Q();
    if (this._bimOrbitEnabled) {
      const _ = this._viewer.model.getViewAxes().upVector.copy();
      p = this._getClampedRotationMatrix(c, u, a, _), m = Q.createFromOffAxisRotation(_, h / 4);
      const y = m.transform(p.transform(r)), b = m.transform(p.transform(o)), w = m.transform(p.transform(d.add(r, a)));
      w.subtract(y), r = y, o = b, a = w;
    } else {
      p = Q.createFromOffAxisRotation(c, u), m = Q.createFromOffAxisRotation(a, h);
      const g = Q.multiply(m, p), _ = g.transform(r), y = g.transform(o), b = g.transform(d.add(r, a));
      b.subtract(_), r = _, o = y, a = b;
    }
    r.add(e), o.add(e), s.setPosition(r), s.setTarget(o), s.setUp(a), i.setCamera(s);
  }
  /**
   * Sets the fallback mode. This is used to specify whether to orbit
   * around a set target, the model center, or camera target.
   */
  setOrbitFallbackMode(t) {
    this._orbitFallbackMode = t;
  }
  /**
   * Gets the orbit fallback mode.
   * @returns orbit fallback mode
   */
  getOrbitFallbackMode() {
    return this._orbitFallbackMode;
  }
  /**
   * Sets the orbit target for the orbit fallback mode OrbitTarget.
   * @param orbitTarget
   */
  setOrbitTarget(t) {
    this._orbitTarget = t;
  }
  /**
   * Gets the orbit target point.
   * @returns orbit target
   */
  getOrbitTarget() {
    return this._orbitTarget;
  }
  /**
   * Sets the primary mouse button. When this button is pressed, we will orbit around the selected point on the model.
   * If there is no selected point, the orbit fallback mode will be used for orbit.
   * @param button
   */
  setPrimaryButton(t) {
    this._primaryButton = t;
  }
  /**
   * @returns the primary orbit button
   */
  getPrimaryButton() {
    return this._primaryButton;
  }
}
class Em extends Se {
  /** @hidden */
  constructor(t, e, i, s) {
    super(t), this._activeOperator = null, this._activeTouchCount = 0, this._touchMoveCount = 0, this._returnToOrbit = !1, this._bimNavigationEnabled = !1, this._orbitOperator = e, this._panOperator = i, this._zoomOperator = s;
  }
  /**
   * When BIM navigation is enabled, the following controls for orbit, pan, and zoom are set:
   * Left mouse button: orbit
   * Middle mouse wheel: zoom
   * Middle mouse button: pan
   * Right mouse button: zoom
   * @param bimNavigation
   */
  setBimNavigationEnabled(t) {
    this._bimNavigationEnabled = t;
    const e = this._orbitOperator, i = this._zoomOperator, s = this._panOperator;
    e.clearMapping(), i.clearMapping(), s.clearMapping(), e.setMapping(Kt.Left), e.setBimOrbitEnabled(t), i.setDollyZoomEnabled(t), t ? (e.setPrimaryButton(Kt.Left), i.setMapping(Kt.Right), s.setMapping(Kt.Middle), this._setBimCamera()) : (e.addMapping(Kt.Middle), e.setPrimaryButton(Kt.Middle), i.addMapping(Kt.Left, ye.Shift), s.addMapping(Kt.Right), s.addMapping(Kt.Left, ye.Control));
  }
  _setBimCamera() {
    const t = this._viewer.view.getCamera(), e = d.subtract(t.getPosition(), t.getTarget()).normalize(), s = this._viewer.model.getViewAxes().upVector.copy(), r = d.cross(e, s), o = d.cross(r, e);
    t.setUp(o), t.setProjection(te.Perspective), this._viewer.view.setCamera(t);
  }
  /**
   * Returns true if BIM navigation is enabled.
   */
  getBimNavigationEnabled() {
    return this._bimNavigationEnabled;
  }
  /** @hidden */
  onViewOrientationChange() {
    this._activeTouchCount = 0, this._returnToOrbit = !1;
  }
  /** @hidden */
  onMouseDown(t) {
    super.onMouseDown(t), this._setActiveOperatorForMouseInput(t), this._activeOperator && (this._bimNavigationEnabled && this._setBimCamera(), this._activeOperator.onMouseDown(t));
  }
  /** @hidden */
  onMouseMove(t) {
    super.onMouseMove(t), this._activeOperator && this._dragging && this._dragCount > 3 && this._activeOperator.onMouseMove(t);
  }
  /** @hidden */
  onMouseUp(t) {
    this._activeOperator && this._activeOperator.onMouseUp(t), this._activeOperator instanceof Rh || this._orbitOperator._removeMarkup(), super.onMouseUp(t);
  }
  /** @hidden */
  async onMousewheel(t) {
    await this._zoomOperator.onMousewheel(t);
  }
  /** @hidden */
  onTouchStart(t) {
    ++this._activeTouchCount, this._orbitOperator.onTouchStart(t), this._zoomOperator.onTouchStart(t), this._viewer.sheetManager.isDrawingSheetActive() && (this._panOperator.onTouchStart(t), this._orbitOperator.onDeactivate()), this._activeTouchCount === 1 && (this._primaryTouchId = t.getId()), this._activeTouchCount === 2 && (this._orbitOperator.onDeactivate(), this._panOperator.onTouchStart(t), this._zoomOperator.onTouchStart(t));
  }
  /** @hidden */
  async onTouchMove(t) {
    ++this._touchMoveCount, this._touchMoveCount > 5 && (this._returnToOrbit ? (this._orbitOperator.onTouchStart(t), this._returnToOrbit = !1) : this._activeTouchCount === 1 ? (await this._orbitOperator.onTouchMove(t), await this._zoomOperator.onTouchMove(t), await this._panOperator.onTouchMove(t)) : this._activeTouchCount === 2 && (await this._zoomOperator.onTouchMove(t), await this._panOperator.onTouchMove(t)));
  }
  /** @hidden */
  onTouchEnd(t) {
    this._activeTouchCount === 2 && (this._returnToOrbit = !0), this._zoomOperator.onTouchEnd(t), this._panOperator.onTouchEnd(t), this._orbitOperator.onTouchEnd(t), this._activeTouchCount > 0 && --this._activeTouchCount, this._activeTouchCount === 0 && (this._touchMoveCount = 0);
  }
  /** @hidden */
  stopInteraction() {
    const t = [];
    let e;
    return e = super.stopInteraction(), e !== void 0 && t.push(e), this._activeTouchCount = 0, this._touchMoveCount = 0, e = this._zoomOperator.onDeactivate(), e !== void 0 && t.push(e), e = this._panOperator.onDeactivate(), e !== void 0 && t.push(e), e = this._orbitOperator.onDeactivate(), e !== void 0 && t.push(e), zt(t);
  }
  _setActiveOperatorForMouseInput(t) {
    const e = this._orbitOperator, i = this._panOperator, s = this._zoomOperator;
    this._activeOperator = null, this._viewer.sheetManager.isDrawingSheetActive() ? this._activeOperator = i : e.checkMapping(t) ? this._activeOperator = e : s.checkMapping(t) ? this._activeOperator = s : i.checkMapping(t) && (this._activeOperator = i);
  }
  /** @hidden */
  onDeactivate() {
    super.onDeactivate(), this._orbitOperator.onDeactivate(), this._panOperator.onDeactivate(), this._zoomOperator.onDeactivate();
  }
}
class Rm extends Se {
  /** @hidden */
  constructor(t) {
    super(t), this._cameraPtPrevious = d.zero();
  }
  /** @hidden */
  onMouseDown(t) {
    if (super.onMouseDown(t), this.isActive() || this._viewer.sheetManager.isDrawingSheetActive()) {
      const e = this._viewer.view, s = e.getCamera().getCameraPlaneIntersectionPoint(t.getPosition(), e);
      s && this._cameraPtPrevious.assign(s);
    }
  }
  /** @hidden */
  onMouseMove(t) {
    if (super.onMouseMove(t), this.isActive() || this._viewer.sheetManager.isDrawingSheetActive()) {
      const e = this._viewer.view, i = e.getCamera(), s = i.getCameraPlaneIntersectionPoint(t.getPosition(), e);
      if (s) {
        const r = d.subtract(s, this._cameraPtPrevious);
        i.dolly(r), e.setCamera(i);
      }
    }
  }
}
class Nm extends Eh {
  /** @hidden */
  constructor(t) {
    super(t, (e) => {
      this._rotateAroundAxis(this._rotationAxis, e[0]);
    }), this._rotationAxis = new d(0, 0, 1), this._tiltAmount = 12;
  }
  _rotateAroundAxis(t, e) {
    const i = this._viewer.view, s = i.getCamera(), r = s.getPosition(), o = s.getUp().normalize(), a = s.getTarget(), l = Q.createFromOffAxisRotation(t, e), c = new Q().setTranslationComponent(-a.x, -a.y, -a.z), h = Q.multiply(c, l), u = new Q().setTranslationComponent(a.x, a.y, a.z);
    Q.multiply(h, u).transform(r, r), l.transform(o, o), o.normalize(), s.setPosition(r), s.setUp(o), i.setCamera(s);
  }
  /** @hidden */
  onMousewheel(t) {
    const e = t.getWheelDelta(), i = this._viewer.view.getCamera(), s = i.getUp().normalize(), r = d.subtract(i.getTarget(), i.getPosition()).normalize(), o = d.cross(s, r).normalize();
    e > 0 ? this._rotateAroundAxis(o, this._tiltAmount) : this._rotateAroundAxis(o, -this._tiltAmount);
  }
  _axisToPoint3(t) {
    let e = null;
    switch (t) {
      case Ht.X:
        e = new d(1, 0, 0);
        break;
      case Ht.Y:
        e = new d(0, 1, 0);
        break;
      case Ht.Z:
        e = new d(0, 0, 1);
        break;
    }
    return e;
  }
  /**
   * Sets the rotation axis.
   * @param axis [[Axis]] or [[Point3]] used to set the rotation axis.
   */
  setRotationAxis(t) {
    let e = null;
    return t instanceof d ? e = t : e = this._axisToPoint3(t), e !== null ? (this._rotationAxis.assign(e), !0) : !1;
  }
}
class Lm {
  /** @hidden */
  constructor(t, e, i) {
    this._keyboardWalkOperator = i, this._walkOperator = e, this._activeOperator = e, this._walkMode = _o.Mouse, this._active = !1;
  }
  /**
   * Sets the walk mode to Mouse or Keyboard.
   * @param walkMode
   */
  async setWalkMode(t) {
    this._walkMode !== t && (this._walkMode = t, t === _o.Keyboard ? (this._activeOperator = this._keyboardWalkOperator, this._active && (await this._walkOperator.onDeactivate(), await this._keyboardWalkOperator.onActivate())) : (this._activeOperator = this._walkOperator, this._active && (await this._keyboardWalkOperator.onDeactivate(), await this._walkOperator.onActivate())));
  }
  /**
   * Gets the walk mode.
   * @returns Keyboard or Mouse
   */
  getWalkMode() {
    return this._activeOperator instanceof Wl ? _o.Keyboard : _o.Mouse;
  }
  /** @hidden */
  onMouseDown(t) {
    this._activeOperator.onMouseDown(t);
  }
  /** @hidden */
  onMouseMove(t) {
    this._activeOperator.onMouseMove(t);
  }
  /** @hidden */
  onMouseUp(t) {
    this._activeOperator.onMouseUp(t);
  }
  /** @hidden */
  onMousewheel(t) {
    this._activeOperator.onMousewheel(t);
  }
  /** @hidden */
  onTouchStart(t) {
    this._activeOperator.onTouchStart(t);
  }
  /** @hidden */
  async onTouchMove(t) {
    await this._activeOperator.onTouchMove(t);
  }
  /** @hidden */
  onTouchEnd(t) {
    this._activeOperator.onTouchEnd(t);
  }
  /** @hidden */
  onKeyDown(t) {
    this._activeOperator.onKeyDown(t);
  }
  /** @hidden */
  onKeyUp(t) {
    this._activeOperator instanceof Wl && this._activeOperator.onKeyUp(t);
  }
  /** @hidden */
  onDeactivate() {
    return this._activeOperator.onDeactivate();
  }
  /** @hidden */
  onActivate() {
    return this._active = !0, this._activeOperator.onActivate();
  }
  /** @hidden */
  onViewOrientationChange() {
    this._active = !1;
  }
  /** @hidden */
  stopInteraction() {
    return this._activeOperator.stopInteraction();
  }
  /**
   * Sets BIM mode enables/disabled on both mouse and keyboard walk
   */
  async setBimModeEnabled(t) {
    const e = [];
    return t ? (e.push(this._keyboardWalkOperator.enableBimMode()), e.push(this._walkOperator.enableBimMode())) : (e.push(this._keyboardWalkOperator.disableBimMode()), e.push(this._walkOperator.disableBimMode())), Promise.all(e).then(() => {
    });
  }
  /**
   * Resets speeds to defaults on both mouse and keyboard walk
   */
  async resetDefaultWalkSpeeds() {
    return Promise.all([
      this._walkOperator.resetDefaultWalkSpeeds(),
      this._keyboardWalkOperator.resetDefaultWalkSpeeds()
    ]).then(() => {
    });
  }
  /**
   * Sets BIM floor config on both mouse and keyboard walk
   */
  setBimFloorConfig(t) {
    this._walkOperator.setBimFloorConfig(t), this._keyboardWalkOperator.setBimFloorConfig(t);
  }
  /**
   * Sets BIM wall config on both mouse and keyboard walk
   */
  setBimWallConfig(t) {
    this._walkOperator.setBimWallConfig(t), this._keyboardWalkOperator.setBimWallConfig(t);
  }
  /**
   * Sets BIM door config on both mouse and keyboard walk
   */
  setBimDoorConfig(t) {
    this._walkOperator.setBimDoorConfig(t), this._keyboardWalkOperator.setBimDoorConfig(t);
  }
  /**
   * Sets zoom speed on both mouse and keyboard walk
   */
  setZoomSpeed(t) {
    this._walkOperator.setZoomSpeed(t), this._keyboardWalkOperator.setZoomSpeed(t);
  }
  /**
   * Sets walk speed for both mouse and keyboard walk
   */
  setWalkSpeed(t) {
    this._walkOperator.setWalkSpeed(t), this._keyboardWalkOperator.setWalkSpeed(t);
  }
  /**
   * Sets elevation speed for both mouse and keyboard walk
   */
  setElevationSpeed(t) {
    this._walkOperator.setElevationSpeed(t), this._keyboardWalkOperator.setElevationSpeed(t);
  }
  /**
   * Sets rotation speed for both mouse and keyboard walk
   */
  setRotationSpeed(t) {
    this._walkOperator.setRotationSpeed(t), this._keyboardWalkOperator.setRotationSpeed(t);
  }
  /**
   * Sets view angle (FOV) for both mouse and keyboard walk operators
   */
  setViewAngle(t) {
    this._walkOperator.setViewAngle(t), this._keyboardWalkOperator.setViewAngle(t);
  }
}
class Xm extends Th {
  /** @hidden */
  constructor(t) {
    super(t), this._timerId = null, this._walkButton = Kt.None, this._previousTimestamp = 0, this._activeTouchCount = 0, this._maxDistance = 200;
  }
  /** @hidden */
  async onActivate() {
    await super.onActivate(), this._viewer.trigger("walkOperatorActivated");
  }
  /** @hidden */
  onKeyDown(t) {
    const e = t.getKeyCode(), i = this.getWalkSpeed();
    e === Ut.PgUp && this.setWalkSpeed(i * 1.2), e === Ut.PgDown && this.setWalkSpeed(i * 0.8), e === Ut.v && this.toggleBimMode();
  }
  /** @hidden */
  async onDeactivate() {
    const t = this._resetCameraTarget();
    return this.stopWalking(), await super.onDeactivate(), this._viewer.trigger("walkOperatorDeactivated"), t;
  }
  // This can resolve issues that arise if the user activates a CAD view while walking that may change the projection mode.
  _checkProjection() {
    const t = this._viewer.view;
    t.getProjectionMode() !== te.Perspective && (t.setProjectionMode(te.Perspective), this._calculateInitialPosition());
  }
  /** @hidden */
  onMouseDown(t) {
    super.onMouseDown(t), this._checkProjection(), this.isActive() && (this.stopWalking(), this.setWalkActive(!0), this._walkButton = t.getButton());
  }
  /** @hidden */
  onMouseMove(t) {
    super.onMouseMove(t), this.getWalkActive() && this._timerId === null && this.isActive() && (this._previousTimestamp = Date.now(), this._onTick());
  }
  /** @hidden */
  onMouseUp(t) {
    this.isActive() && this.stopWalking(), super.onMouseUp(t);
  }
  /** @hidden */
  onTouchStart(t) {
    super.onTouchStart(t), ++this._activeTouchCount, this._activeTouchCount === 1 ? this._walkButton = Kt.Left : this._activeTouchCount === 2 ? this._walkButton = Kt.Right : this._activeTouchCount === 3 && (this._walkButton = Kt.None);
  }
  /** @hidden */
  async onTouchMove(t) {
    if (this._activeTouchCount === 3 && this._primaryTouchId === t.getId()) {
      this._ptCurrent.assign(t.getPosition());
      const e = E.subtract(this._ptCurrent, this._ptPrevious);
      this._adjustTilt(e.y / 100 * 1.5);
    } else
      this._activeTouchCount < 3 && await super.onTouchMove(t);
    return Promise.resolve();
  }
  /** @hidden */
  onTouchEnd(t) {
    super.onTouchEnd(t), this._activeTouchCount > 0 && --this._activeTouchCount;
  }
  /** @hidden */
  onMousewheel(t) {
    this._checkProjection(), t.getWheelDelta() > 0 ? this._adjustTilt(3) : this._adjustTilt(-3);
  }
  /** @hidden */
  stopWalking() {
    this._timerId !== null && (cancelAnimationFrame(this._timerId), this._timerId = null), this.setWalkActive(!1);
  }
  /** @hidden */
  async _testWalk(t, e, i) {
    const s = new Qn(
      0,
      0,
      i,
      Ai.None,
      ye.None,
      Gn.Down
    ), r = new Qn(
      0,
      t,
      i,
      Ai.None,
      ye.None,
      Gn.Move
    ), o = new Qn(
      0,
      t,
      i,
      Ai.None,
      ye.None,
      Gn.Up
    );
    this.onMouseDown(s), this.onMouseMove(r), await Ll(e), this.onMouseUp(o);
  }
  /** @hidden */
  _onTick() {
    const t = Date.now(), e = (t - this._previousTimestamp) / 1e3;
    this._previousTimestamp = t;
    const i = this._viewer.view, s = E.subtract(this._ptCurrent, this._ptFirst), r = new E(
      Math.abs(s.x) / this._maxDistance,
      Math.abs(s.y) / this._maxDistance
    ), o = this.getRotationSpeed() * e * r.x, a = this.getWalkSpeed() * e * r.y, l = this.getElevationSpeed() * e * r.x, c = this.getElevationSpeed() * e * r.y;
    if (this._walkButton === Kt.Left) {
      if (s.x !== 0 && (s.x > 0 ? this.rotateRight(o) : s.x < 0 && this.rotateLeft(o)), s.y !== 0) {
        const h = i.getCamera();
        this._resetPosition(h);
        const u = h.getTarget(), p = h.getPosition(), m = d.subtract(u, p).normalize(), g = h.getUp();
        let _ = d.scale(m, a);
        s.y > 0 && (_ = _.negate()), this.setWalkActive(!0);
        const y = this.getBimModeEnabled();
        this.getActiveWalk().set(async () => {
          if (y)
            await this._applyWalkDeltaWithCollisionCheck(h, _, g), await this._applyGravity(), await this._updateNearbyDoors();
          else
            return this._applyWalkDelta(h, _);
        });
      }
    } else
      (this._walkButton === Kt.Right || this._walkButton === Kt.Middle) && (Math.abs(s.y) > 0 && (s.y > 0 ? this.walkUp(c) : this.walkDown(c)), Math.abs(s.x) > 0 && (s.x > 0 ? this.walkRight(l) : this.walkLeft(l)));
    this._timerId = requestAnimationFrame(() => {
      this._onTick();
    });
  }
  _adjustTilt(t) {
    const e = this._viewer.view;
    this.setTilt(this.getTilt() + t);
    const i = e.getCamera();
    this._resetPosition(i);
    const s = i.getTarget(), r = i.getPosition(), o = d.distance(s, r), a = i.getUp().normalize(), l = d.subtract(s, r).normalize(), c = d.cross(a, l).normalize();
    Q.createFromOffAxisRotation(c, this.getTilt()).transform(l, l), l.normalize().scale(o), i.setTarget(d.add(r, l)), e.setCamera(i);
  }
  async _resetCameraTarget() {
    const t = this._viewer.view, e = t.getCanvasSize(), i = new E(Math.round(e.x / 2), Math.round(e.y / 2)), s = new Ie(), r = await t.pickFromPoint(i, s);
    if (r.isEntitySelection()) {
      const o = t.getCamera();
      o.setTarget(r.getPosition()), t.updateCamera(o);
    }
  }
}
class fi extends _s {
  /** @hidden */
  constructor(t) {
    super(), this._stage = 0, this._finalized = !1, this._uniqueId = "", this._positions = [], this._name = "", this._measurementValue = 0, this._unitMultiplier = 1, this._textShape = new eo(), this._visibility = !0, this._positions = [], this._lineShapes = [], this._viewer = t;
  }
  /**
   * Gets the name of this measurement.
   * @returns the measurement name
   */
  getName() {
    return this._name;
  }
  /**
   * Sets the name of this measurement
   * @param name the name to set
   */
  setName(t) {
    this._name = t;
  }
  /** @hidden */
  _getStage() {
    return this._stage;
  }
  /** @hidden */
  _nextStage() {
    this._stage++;
  }
  /** @hidden */
  _setId(t) {
    this._uniqueId = t;
  }
  /** @hidden */
  _getId() {
    return this._uniqueId;
  }
  /** @hidden */
  adjust(t) {
  }
  /** @hidden */
  _isFinalized() {
    return this._finalized;
  }
  /** @hidden */
  update() {
  }
  /** @hidden */
  draw() {
    this.update();
  }
  setVisibility(t) {
    this._visibility = t, this.draw(), t ? this._viewer.trigger("measurementShown", this) : this._viewer.trigger("measurementHidden", this);
  }
  getVisibility() {
    return this._visibility;
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return {};
  }
  /**
   * Returns the unit agnostic value for this measurement.
   * In the case where this value represents distance, use [[getUnitMultiplier]] to determine the measurement units.
   * In other cases, this value will be the angle measurement in degrees.
   * @returns the measurement value
   */
  getMeasurementValue() {
    return this._measurementValue;
  }
  /**
   * Returns the unit multiplier incorporated into the measurement value.
   * This number is a multiplier of millimeters (for example inches will be `25.4`).
   * The default value is `1.0`.
   */
  getUnitMultiplier() {
    return this._unitMultiplier;
  }
  /**
   * Sets the measurement text that is rendered with this measurement.
   * @param measurementText the text to render with this measurement
   */
  setMeasurementText(t) {
    this._textShape.setTextString(t);
  }
  /**
   * Gets the text for this measurement. By default this will contain the measurement value and units for the model in the cases where the measurement is a distance.
   * In other cases it will contain the angle in degrees.
   */
  getMeasurementText() {
    return this._textShape.getTextString();
  }
  /**
   * Returns whether the measurement markup is valid. Override in subclasses when needed.
   */
  isMarkupValid() {
    return !0;
  }
  /** @hidden */
  _setMeasurementValue(t) {
    this._measurementValue = t / this._unitMultiplier, this.setMeasurementText(Eo(this._measurementValue, this._unitMultiplier)), this._viewer.trigger("measurementValueSet", this);
  }
  /** @hidden */
  static _serializePointArray(t) {
    const e = [];
    for (const i of t)
      e.push(i.toJson());
    return e;
  }
  /** @hidden */
  static _constructPointArray(t) {
    const e = [];
    for (const i of t) {
      const s = d.fromJson(i);
      e.push(s);
    }
    return e;
  }
}
class Nh extends fi {
  constructor(t, e) {
    super(t), this._rectangle = new Ol(), this._markupHandle = null, this._dim = new E(0, 0), this.initialPosition = new E(0, 0), this.currentPosition = new E(0, 0), this.min = new E(0, 0), this.max = new E(0, 0), this._name = "_RectangleMarkup", this._rectangle.setFillOpacity(0), this._rectangle.setStrokeColor(it.red()), this._constantStrokeColor = e;
  }
  draw() {
    this._viewer.markupManager.getRenderer().drawRectangle(this._rectangle);
  }
  updateCurrentPosition(t) {
    if (this.currentPosition.assign(t), this._constantStrokeColor || this._rectangle.setStrokeColor(
      this.initialPosition.x < this.currentPosition.x ? it.red() : it.blue()
    ), this.min.assign(this.initialPosition), this.max.assign(this.currentPosition), this.max.x < this.min.x) {
      const e = this.max.x;
      this.max.x = this.min.x, this.min.x = e;
    }
    if (this.max.y < this.min.y) {
      const e = this.max.y;
      this.max.y = this.min.y, this.min.y = e;
    }
    this._dim.assign(this.max), this._dim.subtract(this.min), this._updateRectangleVertices();
  }
  _updateRectangleVertices() {
    this._rectangle.setPosition(this.min), this._rectangle.setSize(this._dim);
  }
  activate(t) {
    this.initialPosition.assign(t), this.currentPosition.assign(t), this.min.assign(t), this.max.assign(t), this._dim.set(0, 0), this._rectangle.setStrokeWidth(1), this._updateRectangleVertices();
    const e = this._viewer.markupManager;
    this._markupHandle = e.registerMarkup(this);
  }
  deactivate() {
    this.initialPosition.set(0, 0), this.currentPosition.set(0, 0), this.min.set(0, 0), this.max.set(0, 0), this._dim.set(0, 0), this._rectangle.setStrokeWidth(0), this._updateRectangleVertices();
    const t = this._viewer.markupManager;
    this._markupHandle !== null && (t.unregisterMarkup(this._markupHandle), this._markupHandle = null), t.refreshMarkup();
  }
  isActive() {
    return this._markupHandle !== null;
  }
}
class Fm extends Se {
  /** @hidden */
  constructor(t) {
    super(t), this._rectangleMarkup = new Nh(t, !0), this._view = t.view, this._computeTarget = !1, this._preserveViewAngle = !0;
  }
  /**
   * When enabled, the camera target will be computed using selection while zooming.
   * This can provide a better zoom behavior in perspective projection mode,
   * but comes at the cost of performing a selection on the model during each zoom operation,
   * which may not be ideal for performance on large models.
   *
   * This setting is disabled by default.
   */
  setComputeTarget(t) {
    this._computeTarget = t;
  }
  /**
   * Returns whether a new camera target will be computed using selection.
   * See [[setComputeTarget]]
   */
  getComputeTarget() {
    return this._computeTarget;
  }
  /**
   * Sets whether to maintain a constant view angle while zooming. If
   * enabled, when zooming causes the camera's field of view to shrink or
   * grow, the camera's position will also be moved toward or away from
   * the target, respectively.
   *
   * This may prevent confusing camera behavior when perspective
   * projection is used or might be used. When using only orthographic
   * projection, it is better to disable this.
   *
   * If window zoom is being using in conjunction with mouse wheel zoom
   * this setting should be the same in both.
   *
   * This setting is enabled by default.
   */
  setPreserveViewAngle(t) {
    this._preserveViewAngle = t;
  }
  /**
   * Gets whether to maintain a constant view angle while zooming. See
   * [[setPreserveViewAngle]].
   */
  getPreserveViewAngle() {
    return this._preserveViewAngle;
  }
  adjustPositionToPlane(t, e) {
    const s = this._view.getCamera().getViewMatrix(this._viewer), r = s.transform(e), o = s.transform(t);
    r.z = o.z;
    const a = Q.inverse(s);
    return a === null ? null : a.transform(r);
  }
  computeNewField(t, e, i) {
    const s = E.add(t, E.scale(E.subtract(e, t), 0.5)), r = new E(e.x, s.y), o = new E(s.x, e.y), a = new E(t.x, s.y), l = new E(s.x, t.y), c = this._view.getCamera(), h = c.getCameraPlaneIntersectionPoint(r, this._view), u = c.getCameraPlaneIntersectionPoint(o, this._view), p = c.getCameraPlaneIntersectionPoint(a, this._view), m = c.getCameraPlaneIntersectionPoint(l, this._view);
    if (h === null || u === null || p === null || m === null)
      return null;
    const g = this.adjustPositionToPlane(i, h), _ = this.adjustPositionToPlane(i, u), y = this.adjustPositionToPlane(i, p), b = this.adjustPositionToPlane(i, m);
    if (g === null || _ === null || y === null || b === null)
      return null;
    const w = d.subtract(g, y), v = d.subtract(_, b);
    return [w.length(), v.length()];
  }
  async computeReasonableTarget(t, e) {
    const i = E.add(t, E.scale(E.subtract(e, t), 0.5)), s = await this._view.pickFromPoint(i, new Ie());
    if (s.getNodeId() !== null)
      return s.getPosition();
    {
      let r = 0;
      const o = d.zero(), a = await this._view.beginScreenSelectByArea(
        t,
        e,
        new Dl()
      );
      for (; ; ) {
        const h = await this._view.advanceIncrementalSelection(a);
        if (h === null)
          break;
        for (const u of h) {
          const p = u.getPosition();
          p !== null && (o.add(p), r++);
        }
      }
      let c = this._view.getCamera().getCameraPlaneIntersectionPoint(i, this._view);
      if (c === null)
        return null;
      if (r !== 0) {
        const h = d.scale(o, 1 / r);
        c = this.adjustPositionToPlane(h, c);
      }
      return c;
    }
  }
  async getCameraTarget(t, e) {
    if (this._computeTarget)
      return this.computeReasonableTarget(t, e);
    const i = this._view.getCamera(), s = E.add(t, E.scale(E.subtract(e, t), 0.5));
    return i.getCameraPlaneIntersectionPoint(s, this._view);
  }
  async doZoom(t, e) {
    const i = this._view.getCamera(), s = i.copy(), r = i.getTarget(), o = await this.getCameraTarget(t, e);
    if (o === null)
      return;
    const a = this.computeNewField(t, e, o);
    if (a === null)
      return;
    const [l, c] = a, h = this._view.getCanvasSize(), u = new E(0, 0), p = d.distance(
      i.getCameraPlaneIntersectionPoint(h, this._view),
      i.getCameraPlaneIntersectionPoint(u, this._view)
    );
    s.setWidth(l), s.setHeight(c), s.setTarget(o), this._viewer.pauseRendering(() => {
      this._view.setCamera(s);
      const m = d.subtract(r, i.getPosition());
      let g;
      if (this._preserveViewAngle) {
        const _ = d.distance(
          s.getCameraPlaneIntersectionPoint(h, this._view),
          s.getCameraPlaneIntersectionPoint(u, this._view)
        ), y = m.length() / p;
        g = d.add(
          o,
          d.scale(m.negate().normalize(), y * _)
        );
      } else
        g = d.subtract(o, m);
      s.setPosition(g), this._view.setCamera(s);
    });
  }
  /** @hidden */
  onMouseDown(t) {
    super.onMouseDown(t), this.isActive() && (t.setHandled(!0), this._rectangleMarkup.isActive() && this._rectangleMarkup.deactivate(), this._rectangleMarkup.activate(t.getPosition()));
  }
  /** @hidden */
  onMouseMove(t) {
    super.onMouseMove(t), this.isActive() && this._rectangleMarkup.isActive() && (t.setHandled(!0), this._rectangleMarkup.updateCurrentPosition(t.getPosition()), this._viewer.markupManager.refreshMarkup());
  }
  /** @hidden */
  async onMouseUp(t) {
    if (this.isActive() && this._rectangleMarkup.isActive()) {
      const e = this._rectangleMarkup;
      if (e.updateCurrentPosition(t.getPosition()), E.subtract(e.max, e.min).length() <= 3) {
        e.deactivate();
        return;
      }
      t.setHandled(!0), await this.doZoom(e.min, e.max);
    }
    this._rectangleMarkup.isActive() && this._rectangleMarkup.deactivate(), super.onMouseUp(t);
  }
}
class Km extends Se {
  /** @hidden */
  constructor(t) {
    super(t), this._mouseMoveZoomDelta = 3, this._mouseWheelZoomDelta = 0.25, this._pinchZoomModifier = 2.5, this._zoomToMousePosition = !0, this._dollyZoomEnabled = !1, this._adjustCameraTarget = !1, this._preserveViewAngle = !0, this._mouseMoveZoomFactor = 1, this._mouseWheelZoomFactor = -1, this._secondaryTouchId = null, this._lastTouch1 = E.zero(), this._lastTouch2 = E.zero(), this._prevLen = 0;
  }
  /**
   * When true, scrolling up will zoom towards the model.
   * @param inverted
   */
  setMouseWheelZoomInverted(t) {
    t ? this._mouseWheelZoomFactor = -1 : this._mouseWheelZoomFactor = 1;
  }
  getMouseWheelZoomInverted() {
    return this._mouseWheelZoomFactor === -1;
  }
  /**
   * When true, moving the mouse up will zoom towards the model.
   * @param inverted
   */
  setMouseMoveZoomInverted(t) {
    t ? this._mouseMoveZoomFactor = -1 : this._mouseMoveZoomFactor = 1;
  }
  getMouseMoveZoomInverted() {
    return this._mouseMoveZoomFactor === -1;
  }
  /**
   * Sets the delta to zoom when moving the mouse
   * @param delta
   */
  setMouseMoveZoomDelta(t) {
    this._mouseMoveZoomDelta = t;
  }
  /**
   * Gets the mouse move zoom delta
   * @returns number
   */
  getMouseMoveZoomDelta() {
    return this._mouseMoveZoomDelta;
  }
  /**
   * Sets the delta to zoom when scrolling
   * @param delta
   */
  setMouseWheelZoomDelta(t) {
    this._mouseWheelZoomDelta = t;
  }
  /**
   * Gets the scrollwheel zoom delta
   * @returns number
   */
  getMouseWheelZoomDelta() {
    return this._mouseWheelZoomDelta;
  }
  /**
   * When set, the zoom will be towards the mouse position. When not set, the zoom will be from the center of the screen.
   * @param zoom
   */
  setZoomToMousePosition(t) {
    this._zoomToMousePosition = t;
  }
  /**
   * @returns boolean When true, the zoom will be towards the mouse position. When false, the zoom will be towards the center of the screen.
   */
  getZoomToMousePosition() {
    return this._zoomToMousePosition;
  }
  /**
   * When dolly zoom is enabled, the camera position will move towards the camera target when zooming.
   * @moveCameraPositon
   */
  setDollyZoomEnabled(t) {
    this._dollyZoomEnabled = t;
  }
  /**
   * Returns true if dolly zoom is enabled.
   */
  getDollyZoomEnabled() {
    return this._dollyZoomEnabled;
  }
  /**
   * When enabled, the camera target will be updated to the selection position while zooming.
   * This can provide a better zoom behavior in perspective projection mode,
   * but comes at the cost of performing a selection on the model during each mouse scroll,
   * which may not be ideal for performance on large models.
   *
   * This setting is disabled by default.
   */
  setMouseWheelAdjustCameraTarget(t) {
    this._adjustCameraTarget = t;
  }
  /**
   * Returns whether the camera target will be updated to the selection
   * position while zooming. See [[setMouseWheelAdjustCameraTarget]].
   */
  getMouseWheelAdjustCameraTarget() {
    return this._adjustCameraTarget;
  }
  /**
   * Sets whether to maintain a constant view angle while zooming. If
   * enabled, when zooming causes the camera's field of view to shrink or
   * grow, the camera's position will also be moved toward or away from
   * the target, respectively.
   *
   * This may prevent confusing camera behavior when perspective
   * projection is used or might be used. When using only orthographic
   * projection, it is better to disable this.
   *
   * If mouse wheel zoom is being using in conjunction with window zoom
   * this setting should be the same in both.
   *
   * This setting is enabled by default.
   */
  setPreserveViewAngle(t) {
    this._preserveViewAngle = t;
  }
  /**
   * Gets whether to maintain a constant view angle while zooming. See
   * [[setPreserveViewAngle]].
   */
  getPreserveViewAngle() {
    return this._preserveViewAngle;
  }
  /** @hidden */
  async onMouseMove(t) {
    if (super.onMouseMove(t), this.isDragging() && this.isActive()) {
      const e = this._viewer.view, i = e.pointToWindowPosition(this._ptCurrent), s = e.pointToWindowPosition(this._ptPrevious), r = i.y - s.y, o = i.x - s.x, a = this._mouseMoveZoomDelta * this._mouseMoveZoomFactor * (r - o);
      this._dollyZoomEnabled ? await this._dollyZoom(a, void 0, void 0, !0) : await this._doZoom(a);
    }
  }
  /** @hidden */
  async onMousewheel(t) {
    const e = this._mouseWheelZoomDelta * this._mouseWheelZoomFactor * t.getWheelDelta();
    this._dollyZoomEnabled ? await this._dollyZoom(-e, void 0, t.getPosition()) : await this._doZoom(e, void 0, t.getPosition());
  }
  /** @hidden */
  onTouchStart(t) {
    const e = this._viewer.view;
    this._primaryTouchId === null ? (this._primaryTouchId = t.getId(), this._lastTouch1.assign(e.pointToWindowPosition(t.getPosition()))) : this._secondaryTouchId === null && (this._secondaryTouchId = t.getId(), this._lastTouch2.assign(e.pointToWindowPosition(t.getPosition()))), this._primaryTouchId !== null && this._secondaryTouchId !== null && (this._prevLen = E.subtract(this._lastTouch2, this._lastTouch1).length(), this._dragging = !0);
  }
  /** @hidden */
  onTouchMove(t) {
    const e = this._viewer.view, i = t.getId(), s = t.getPosition();
    if (i === this._primaryTouchId ? this._lastTouch1.assign(e.pointToWindowPosition(s)) : i === this._secondaryTouchId && this._lastTouch2.assign(e.pointToWindowPosition(s)), this._dragging && (i === this._primaryTouchId || i === this._secondaryTouchId)) {
      const r = E.subtract(this._lastTouch2, this._lastTouch1).length(), a = 1 / (1 - (this._prevLen - r) * this._pinchZoomModifier);
      this._zoomHelper(a, this._viewer.view.getCamera()), this._prevLen = r;
    }
    return Promise.resolve();
  }
  /** @hidden */
  onTouchEnd(t) {
    const e = t.getId();
    this._primaryTouchId === e ? this._primaryTouchId = null : this._secondaryTouchId === e && (this._secondaryTouchId = null), this._dragging = !1;
  }
  /** @hidden */
  onDeactivate() {
    this._primaryTouchId = null, this._secondaryTouchId = null;
  }
  _updateCameraViewAngle(t) {
    const e = cs(90), i = Math.tan(e / 2), r = d.subtract(t.getTarget(), t.getPosition()).length() * i;
    return t.setWidth(r), t.setHeight(r), t;
  }
  async _dollyZoom(t, e = this._viewer.view.getCamera(), i, s = !1) {
    const r = this._viewer.view;
    e.setProjection(te.Perspective);
    const o = e.getPosition(), a = e.getTarget();
    if (i) {
      const h = (await this._viewer.model.getModelBounding(!1, !1, !1)).extents().length() / 100, p = (await this._viewer.view.pickFromPoint(i, new Ie())).getPosition();
      if (p !== null) {
        const g = d.subtract(a, o), _ = d.subtract(p, o), y = d.add(o, g.scale(d.dot(g, _) / d.dot(g, g)));
        e.setTarget(y);
      }
      let m = d.subtract(e.getTarget(), o);
      t > 0 && m.length() < h && e.setTarget(
        d.add(
          a,
          m.copy().normalize().scale(h * 2)
        )
      ), m = d.subtract(e.getTarget(), o), e.setPosition(d.add(o, m.copy().scale(t / 10)));
    } else {
      const l = d.subtract(a, o).scale(t / 10);
      e.setPosition(d.add(o, l)), s && e.setTarget(d.add(a, l));
    }
    e = this._updateCameraViewAngle(e), this._viewer.pauseRendering(() => {
      if (i) {
        const l = e.getCameraPlaneIntersectionPoint(
          i,
          this._viewer.view
        );
        r.setCamera(e);
        const c = e.getCameraPlaneIntersectionPoint(
          i,
          this._viewer.view
        );
        l !== null && c !== null && e.dolly(d.subtract(c, l));
      }
      r.setCamera(e);
    });
  }
  async _doZoom(t, e = this._viewer.view.getCamera(), i) {
    const s = this._viewer.view, r = Math.max(1 / (1 - t), 1e-3);
    if (i && this._zoomToMousePosition) {
      if (this._adjustCameraTarget) {
        const o = await this._viewer.view.pickFromPoint(i, new Ie());
        if (o !== void 0 && o.isEntitySelection()) {
          const a = e.getPosition().subtract(e.getTarget()), l = d.subtract(e.getTarget(), e.getPosition()), c = d.subtract(o.getPosition(), e.getPosition()), h = e.getPosition().add(l.scale(d.dot(l, c) / d.dot(l, l)));
          e.setTarget(h), e.setPosition(d.add(h, a));
        }
      }
      this._viewer.pauseRendering(() => {
        const o = e.getCameraPlaneIntersectionPoint(
          i,
          this._viewer.view
        );
        this._zoomHelper(r, e);
        const a = e.getCameraPlaneIntersectionPoint(
          i,
          this._viewer.view
        );
        o !== null && a !== null && e.dolly(d.subtract(a, o)), s.setCamera(e);
      });
    } else
      this._zoomHelper(r, e);
  }
  _zoomHelper(t, e) {
    const i = this._viewer.view;
    if (e.setWidth(e.getWidth() * t), e.setHeight(e.getHeight() * t), this._preserveViewAngle && !this._viewer.sheetManager.isDrawingSheetActive()) {
      const s = e.getPosition(), r = e.getTarget(), o = d.subtract(r, s).scale(t), a = d.subtract(r, o);
      e.setPosition(a);
    }
    i.setCamera(e);
  }
}
const iy = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CameraKeyboardWalkOperator: Wl,
  CameraNavigationOperator: Em,
  CameraOrbitBaseOperator: Eh,
  CameraOrbitOperator: Rh,
  CameraPanOperator: Rm,
  CameraTurntableOperator: Nm,
  CameraWalkBaseOperator: Th,
  CameraWalkModeOperator: Lm,
  CameraWalkOperator: Xm,
  CameraWindowZoomOperator: Fm,
  CameraZoomOperator: Km,
  DoorCache: Ym,
  MAX_ANGLE: km,
  MAX_TILT: Zm,
  MIN_ANGLE: Mm,
  MIN_TILT: Cm,
  OrbitMarkup: Tm,
  TimedPoints: Vm,
  applyGravity: Bc,
  buildCollisionRayConfig: Vh,
  clamp: zc,
  getDownAxis: Pm,
  normalizeDirections: Wm,
  removeOpposing: Mr,
  testWallCollision: Gm
}, Symbol.toStringTag, { value: "Module" }));
var tn = /* @__PURE__ */ ((n) => (n[n.NoPointsSelected = 0] = "NoPointsSelected", n[n.OnePointSelected = 1] = "OnePointSelected", n[n.TwoPointsSelected = 2] = "TwoPointsSelected", n))(tn || {}), Tr = /* @__PURE__ */ ((n) => (n[n.First = 0] = "First", n[n.Last = 1] = "Last", n[n.Midpoint = 2] = "Midpoint", n))(Tr || {}), Er = /* @__PURE__ */ ((n) => (n[n.First = 0] = "First", n[n.Last = 1] = "Last", n[n.Midpoint = 2] = "Midpoint", n))(Er || {});
function cl(n, t) {
  const e = new jn(t.x, t.y, t.z, 1), i = new jn(0, 0, 0, 0);
  n.view.getFullCameraMatrix().transform4(e, i);
  const s = 1 / i.w, r = new E(i.x * s, i.y * s), { x: o, y: a } = n.view.getCanvasSize();
  return r.x = 0.5 * o * (r.x + 1), r.y = 0.5 * a * (r.y + 1), r.x = Math.max(0, Math.min(r.x, o)), r.y = a - Math.max(0, Math.min(r.y, a)), r;
}
const jc = class extends fi {
  constructor(n) {
    super(n), this._firstNode = null, this._firstPointShape = new qn(), this._secondPointShape = new qn(), this._arrowsInvert = !1, this._measurePoint1 = null, this._measurePoint2 = null, this._leaderPoint1 = null, this._leaderPoint2 = null, this._textPoint = null, this._name = "MeasureBodyBodyDistance", this._lineShapes = [];
    for (let t = 0; t < 6; t++)
      this._lineShapes.push(new Wi()), this._lineShapes[t].setStrokeColor(this._viewer.measureManager.getMeasurementColor()), this._lineShapes[t].setEndEndcapColor(this._viewer.measureManager.getMeasurementColor()), this._lineShapes[t].setStartEndcapColor(this._viewer.measureManager.getMeasurementColor());
    this._viewer = n, this.initCircle(this._firstPointShape), this.initCircle(this._secondPointShape), this._textShape = new eo(), this._textShape.getBoxPortion().setFillOpacity(1), this._textShape.getBoxPortion().setFillColor(new it(255, 255, 255));
  }
  initCircle(n) {
    n.setRadius(2.5), n.setFillColor(this._viewer.measureManager.getMeasurementColor());
  }
  setUnitMultiplier(n) {
    this._unitMultiplier = n;
  }
  setFirstNode(n) {
    this._stage = 1, this._firstNode = n;
  }
  getFirstNode() {
    return this._firstNode;
  }
  async setSecondNode(n) {
    if (this._firstNode === null)
      return;
    this._stage = 2;
    const t = await this._viewer.model.computeMinimumBodyBodyDistance(
      this._firstNode,
      n
    );
    this._measurePoint1 = t.pos1.copy(), this._measurePoint2 = t.pos2.copy(), this._textPoint = t.pos2.copy(), this._setMeasurementValue(t.distance);
  }
  _getStage() {
    return this._stage;
  }
  finalize() {
    this._stage++;
  }
  // adjusts the position of the measurement just before it's finalized
  adjust(n) {
    if (super.adjust(n), this._stage < 2)
      return;
    const t = this._viewer.view.raycastFromPoint(n);
    if (t === null || this._measurePoint1 === null || this._measurePoint2 === null || this._textPoint == null)
      return;
    let e = new d(1, 0, 0);
    this._measurePoint2.equals(this._measurePoint1) || (e = d.subtract(this._measurePoint2, this._measurePoint1));
    const s = this._viewer.view.getCamera().getUp(), r = d.cross(t.direction, s).normalize(), o = new d(
      (this._measurePoint1.x + this._measurePoint2.x) / 2,
      (this._measurePoint1.y + this._measurePoint2.y) / 2,
      (this._measurePoint1.z + this._measurePoint2.z) / 2
    ), a = new d(o.x + s.x, o.y + s.y, o.z + s.z), l = new d(
      o.x + r.x,
      o.y + r.y,
      o.z + r.z
    ), c = new d(
      t.origin.x + t.direction.x * 1e6,
      t.origin.y + t.direction.y * 1e6,
      t.origin.z + t.direction.z * 1e6
    );
    let h = new d(0, 0, 0);
    Ts(
      t.origin,
      c,
      o,
      a,
      l,
      h
    ), this._textPoint.assign(h);
    let u = new d(0, 0, 0);
    Math.abs(e.x) <= Math.abs(e.y) && Math.abs(e.x) <= Math.abs(e.z) ? u = new d(1, 0, 0) : Math.abs(e.y) <= Math.abs(e.x) && Math.abs(e.y) <= Math.abs(e.z) ? u = new d(0, 1, 0) : u = new d(0, 0, 1);
    const p = d.cross(u, e), m = d.cross(p, e);
    p.set(
      this._measurePoint1.x + p.x,
      this._measurePoint1.y + p.y,
      this._measurePoint1.z + p.z
    ), m.set(
      this._measurePoint1.x + m.x,
      this._measurePoint1.y + m.y,
      this._measurePoint1.z + m.z
    );
    const g = new d(
      h.x + e.x * 1e4,
      h.y + e.y * 1e4,
      h.z + e.z * 1e4
    ), _ = new d(
      h.x - e.x * 1e4,
      h.y - e.y * 1e4,
      h.z - e.z * 1e4
    ), y = Ts(
      g,
      _,
      this._measurePoint1,
      p,
      m,
      h
    ), b = !isNaN(h.x) && !isNaN(h.y) && !isNaN(h.z);
    (!y || !b) && (h = this._measurePoint2.copy());
    const w = d.subtract(h, this._measurePoint1);
    this._leaderPoint1 = new d(
      this._measurePoint1.x + w.x,
      this._measurePoint1.y + w.y,
      this._measurePoint1.z + w.z
    ), this._leaderPoint2 = new d(
      this._measurePoint2.x + w.x,
      this._measurePoint2.y + w.y,
      this._measurePoint2.z + w.z
    ), this._updateArrowsInverted(), this._viewer.markupManager.refreshMarkup();
  }
  _updateArrowsInverted() {
    if (this._leaderPoint1 === null || this._leaderPoint2 === null || this._textPoint === null)
      return;
    const n = new d(
      (this._leaderPoint1.x + this._leaderPoint2.x) / 2,
      (this._leaderPoint1.y + this._leaderPoint2.y) / 2,
      (this._leaderPoint1.z + this._leaderPoint2.z) / 2
    ), t = d.subtract(this._leaderPoint2, this._leaderPoint1);
    d.subtract(this._textPoint, n).length() * 2 > t.length() ? this._arrowsInvert = !0 : this._arrowsInvert = !1;
  }
  // Called as part of drawing the markup. Sets line positions and determines if the markup is in view
  update() {
    if (super.update(), this._stage <= 1)
      return;
    const n = this._viewer.view;
    this._behindView = !1;
    const t = (a) => {
      if (a === null)
        return E.zero();
      const l = n.projectPoint(a);
      return l.z <= 0 && (this._behindView = !0), E.fromPoint3(l);
    }, e = t(this._measurePoint1), i = t(this._measurePoint2), s = t(this._textPoint), r = t(this._leaderPoint1), o = t(this._leaderPoint2);
    this._firstPointShape.setCenter(e), this._textShape && this._textShape.setPosition(s), this._secondPointShape.setCenter(i), this._lineShapes[0].set(e, i), this._lineShapes[1].set(r, o), this._lineShapes[2].set(e, r), this._lineShapes[3].set(i, o), this._lineShapes[4].set(r, s), this._lineShapes[5].set(r, o), this._lineShapes[5].setEndcapType(ii.Arrowhead), this._lineShapes[5].setStartEndcapType(ii.Arrowhead), this._lineShapes[5].setEndcapsInverted(this._arrowsInvert);
  }
  draw() {
    if (!this._visibility || this._viewer.explodeManager.getMagnitude() !== 0 || (this.update(), this._behindView))
      return;
    const n = this._viewer.markupManager.getRenderer();
    if (this._stage === 2 || this._stage === 3) {
      n.drawCircle(this._firstPointShape), n.drawCircle(this._secondPointShape);
      for (const t of this._lineShapes)
        n.drawLine(t);
      n.drawTextBox(this._textShape);
    }
  }
  // serialization methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      name: this._name,
      measurePoint1: this._measurePoint1,
      measurePoint2: this._measurePoint2,
      leaderPoint1: this._leaderPoint1,
      leaderPoint2: this._leaderPoint2,
      textPoint: this._textPoint,
      text: this._textShape.getTextString(),
      measurementValue: this._measurementValue,
      unitMultiplier: this._unitMultiplier,
      className: this.getClassName()
    };
  }
  /**
   * Creates a new [[MeasureBodyBodyDistanceMarkup]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(n, t) {
    const e = n, i = new jc(t);
    return i._name = e.name, i._measurePoint1 = d.fromJson(e.measurePoint1), i._measurePoint2 = d.fromJson(e.measurePoint2), i._textPoint = d.fromJson(e.textPoint), i._textShape.setTextString(e.text), i._leaderPoint1 = d.fromJson(e.leaderPoint1), i._leaderPoint2 = d.fromJson(e.leaderPoint2), i._measurementValue = e.measurementValue, i._unitMultiplier = e.unitMultiplier || 1, i._updateArrowsInverted(), i._stage = 2, i;
  }
  getClassName() {
    return jc.className;
  }
};
let ia = jc;
ia.className = "Communicator.Markup.Measure.MeasureBodyBodyDistanceMarkup";
Ui(
  ia.className,
  ia.fromJson
);
class Om extends Se {
  constructor(t, e) {
    super(t), this._moveSelectionAction = new fs(!0), this._currentMoveHighlight = null, this._currentSelectHighlight = null, this._markup = null, this._measureManager = e;
  }
  _unsetCurrentMoveHighlight() {
    this._currentMoveHighlight !== null && (this._viewer.model.setNodesHighlighted([this._currentMoveHighlight.getNodeId()], !1), this._currentMoveHighlight = null);
  }
  _unsetCurrentSelectionHighlight() {
    this._currentSelectHighlight !== null && (this._viewer.model.setNodesHighlighted([this._currentSelectHighlight.getNodeId()], !1), this._currentSelectHighlight = null);
  }
  async _performMoveSelection(t) {
    const e = this._viewer.view, i = this._viewer.model, s = await e.pickFromPoint(t, new Ie());
    if (s.overlayIndex() !== 0 || !s.isNodeSelection()) {
      this._unsetCurrentMoveHighlight();
      return;
    }
    const r = s.getNodeId();
    if (!(r === null || i.getNodeType(r) !== At.BodyInstance)) {
      if (this._markup) {
        const o = this._markup.getFirstNode();
        if (o !== null && r === o)
          return;
      }
      this._currentMoveHighlight !== null ? s.equals(this._currentMoveHighlight) ? s.getSelectionType() === pi.None && this._unsetCurrentMoveHighlight() : (this._unsetCurrentMoveHighlight(), this._currentMoveHighlight = s, i.setNodesHighlighted([r], !0)) : (this._currentMoveHighlight = s, i.setNodesHighlighted([r], !0));
    }
  }
  async _performUpSelection(t) {
    const e = this._viewer.view, i = this._viewer.model, s = await e.pickFromPoint(t, new Ie());
    if (s.overlayIndex())
      return;
    if (this._markup && this._markup._getStage() === 1 && this._viewer.trigger("measurementBegin"), this._markup && this._markup._getStage() > 1) {
      const o = this._markup;
      this._markup = null, o.finalize(), this._measureManager.finalizeMeasurement(o);
      return;
    }
    const r = s.getNodeId();
    r !== null && i.getNodeType(r) === At.BodyInstance && (!this._markup || this._markup._getStage() <= 1) && (this._unsetCurrentMoveHighlight(), this._markup ? (this._unsetCurrentSelectionHighlight(), await this._markup.setSecondNode(r), this._markup.adjust(t)) : (this._markup = new ia(this._viewer), this._markup.setUnitMultiplier(i.getNodeUnitMultiplier(r)), this._markup.setFirstNode(r), s.isNodeSelection() && (this._unsetCurrentSelectionHighlight(), this._currentSelectHighlight = s, this._viewer.model.setNodesHighlighted([r], !0)), this._measureManager.addMeasurement(this._markup)));
  }
  /** @hidden */
  onMouseMove(t) {
    super.onMouseMove(t);
    const e = t.getPosition();
    (!this._markup || this._markup._getStage() <= 1) && this._moveSelectionAction.set(() => this._performMoveSelection(e)), this._viewer.markupManager.refreshMarkup(), this._markup !== null && this._markup._getStage() > 0 && this._markup.adjust(e);
  }
  async _onMouseUpImpl(t) {
    if (!this.isActive())
      return;
    const e = this._primaryTouchId !== null && this._markup !== null && this._markup._getStage() > 1;
    if (!(this._dragCount < 3 || e))
      return;
    const i = t.getPosition();
    await this._performUpSelection(i);
  }
  /** @hidden */
  async onMouseUp(t) {
    await this._onMouseUpImpl(t), super.onMouseUp(t);
  }
  /** @hidden */
  setDraggingEnabled(t) {
    this._dragging = t;
  }
  /** @hidden */
  onKeyUp(t) {
  }
  /** @hidden */
  onKeyDown(t) {
    t.getKeyCode() === Ut.Escape && (this._markup !== null ? (this._measureManager.removeMeasurement(this._markup), this._markup = null) : this._measureManager.removeLastMeasurement());
  }
  /** @hidden */
  setHandled() {
    return this._markup !== null && this._markup._getStage() > 1;
  }
  /** @hidden */
  onDeactivate() {
    super.onDeactivate(), this._unsetCurrentMoveHighlight(), this._markup !== null && (this._measureManager.removeMeasurement(this._markup), this._markup = null);
  }
}
const Am = class extends fi {
  /** @hidden */
  constructor(n) {
    super(n), this._lineEdgeShape = new br(), this._linePositions = [], this._name = "MeasureLength", this._positions = [], this._lineShapes = [], this._lineEdgeShape.setStrokeWidth(4), this._lineEdgeShape.setStrokeColor(n.measureManager.getMeasurementEdgeColor());
  }
  setLineGeometry(n) {
    this._linePositions = n, this._stage = 1;
  }
  setMeasurementEdgeColor(n) {
    this._lineEdgeShape.setStrokeColor(n);
  }
  reset() {
    this._stage = 0;
  }
  adjust(n) {
    super.adjust(n);
  }
  draw() {
  }
  getLineEdgeShape() {
    return this._lineEdgeShape;
  }
  //serialization methods
  getClassName() {
    return Am.className;
  }
};
let jl = Am;
jl.className = "Communicator.Markup.Measure.MeasureLengthMarkup";
const Hc = class extends jl {
  constructor(n, t, e, i) {
    super(n), this._circlePoints = [], this._radius = 0, this._surfaceCenter = d.zero(), this._circlePlane = new je(), this._arrowsInvert = !1, this._name = "MeasureCircleEdgeLength", this._lineProperties = t, this._matrix = e.copy(), this._unitMultiplier = i, this._textShape.getBoxPortion().setFillOpacity(1), this._textShape.getBoxPortion().setFillColor(new it(255, 255, 255));
    const r = n.measureManager.getMeasurementColor();
    for (let o = 0; o < 5; o++)
      this._lineShapes.push(new Wi()), this._lineShapes[o].setStrokeColor(r), this._lineShapes[o].setEndEndcapColor(r), this._lineShapes[o].setStartEndcapColor(r);
  }
  createCircleData() {
    ng(
      this._circlePoints,
      this._lineProperties.origin,
      this._lineProperties.radius,
      32,
      this._lineProperties.normal
    ), this._matrix.transformArray(this._circlePoints, this._circlePoints), this._positions[0] = this._circlePoints[0].copy(), this._positions[1] = this._circlePoints[16].copy();
    const n = new d(this._lineProperties.radius, 0, 0), t = new d(0, 0, 0);
    this._matrix.transform(n, n), this._matrix.transform(t, t);
    let e = d.subtract(t, n);
    this._radius = e.length(), e = d.subtract(this._positions[1], this._positions[0]), this._positions[4] = this._positions[1].copy(), this._surfaceCenter = this._matrix.transform(this._lineProperties.origin);
    const i = new d(
      this._circlePoints[0].x,
      this._circlePoints[0].y,
      this._circlePoints[0].z
    ), s = new d(
      this._circlePoints[1].x,
      this._circlePoints[1].y,
      this._circlePoints[1].z
    );
    this._circlePlane = je.createFromPoints(i, s, this._surfaceCenter);
  }
  setLineGeometry(n) {
    if (super.setLineGeometry(n), this._positions[0] = this._linePositions[0], this._positions[0].equals(this._positions[this._positions.length - 1])) {
      const t = Math.floor(this._positions.length / 2);
      this._positions[1] = this._positions[t];
    } else
      this._positions[1] = this._linePositions[this._linePositions.length - 1];
    this._positions[1] = this._linePositions[this._linePositions.length - 1], this._positions[2] = this._linePositions[1].copy(), this.createCircleData(), this._setMeasurementValue(this._radius);
  }
  adjust(n) {
    super.adjust(n);
    const t = this._viewer.view.raycastFromPoint(n);
    if (t === null)
      return;
    const e = this._surfaceCenter, i = this._circlePlane;
    let s = i.rayIntersection(t);
    if (s === null) {
      const l = d.add(e, t.direction.copy().scale(-2 * this._radius)), h = je.createFromPointAndNormal(l, t.direction).rayIntersection(t);
      console.assert(h !== null);
      const u = new Vn(h, i.normal);
      s = i.rayIntersection(u), s === null && (s = i.rayIntersection(u.negate()));
    }
    s === null && (console.assert(!1), s = e.copy());
    const r = d.subtract(s, e).normalize().scale(this._radius), o = d.add(e, r), a = d.subtract(e, r);
    this._positions[0] = o, this._positions[1] = a, this._positions[2] = o.copy(), this._positions[3] = a.copy(), this._positions[4] = s.copy(), this._positions[5] = this._surfaceCenter.copy(), this._updateArrowsInverted(), this._viewer.markupManager.refreshMarkup();
  }
  _updateArrowsInverted() {
    const n = new d(
      (this._positions[4].x + this._positions[5].x) / 2,
      (this._positions[4].y + this._positions[5].y) / 2,
      (this._positions[4].z + this._positions[5].z) / 2
    ), t = d.subtract(this._positions[5], this._positions[4]), e = d.subtract(this._positions[2], n);
    this._arrowsInvert = e.length() * 2 > t.length();
  }
  update() {
    super.update();
    const n = this._viewer.view;
    if (this._stage > 0) {
      this._lineEdgeShape.clearPoints();
      for (const t of this._linePositions) {
        const e = E.fromPoint3(n.projectPoint(t));
        this._lineEdgeShape.pushPoint(e);
      }
    }
    if (this._stage > 1) {
      const t = new Array(6);
      for (let e = 0; e < this._positions.length; e++)
        t[e] = E.fromPoint3(n.projectPoint(this._positions[e]));
      this._textShape && this._textShape.setPosition(t[4]), this._lineShapes[0].set(t[5], t[2]), this._lineShapes[1].set(t[5], t[4]), this._lineShapes[0].setEndcapType(ii.Arrowhead), this._lineShapes[0].setStartEndcapType(ii.None), this._lineShapes[0].setEndcapsInverted(this._arrowsInvert);
    }
  }
  draw() {
    if (this._visibility && this._viewer.explodeManager.getMagnitude() === 0) {
      this.update();
      const t = this._viewer.markupManager.getRenderer();
      switch (this._stage) {
        case 1:
          t.drawPolyline(this._lineEdgeShape);
          break;
        case 2:
        case 3:
          for (let e = 0; e < 2; e++)
            t.drawLine(this._lineShapes[e]);
          t.drawTextBox(this._textShape), t.drawPolyline(this._lineEdgeShape);
          break;
      }
    }
  }
  // serialization methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    const n = fi._serializePointArray(this._linePositions), t = fi._serializePointArray(this._positions);
    return {
      matrix: this._matrix.toJson(),
      lineOrigin: this._lineProperties.origin,
      lineRadius: this._lineProperties.radius,
      lineNormal: this._lineProperties.normal,
      linePositions: n,
      positions: t,
      text: this._textShape.getTextString(),
      measurementValue: this._measurementValue,
      unitMultiplier: this._unitMultiplier,
      className: this.getClassName()
    };
  }
  /**
   * Creates a new [[MeasureCircleEdgeLengthMarkup]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(n, t) {
    const e = n, i = Q.fromJson(e.matrix), s = e.lineRadius, r = d.fromJson(e.lineOrigin), o = d.fromJson(e.lineNormal), a = new qr(s, r, o), l = e.unitMultiplier || 1, c = new Hc(
      t,
      a,
      i,
      l
    ), h = fi._constructPointArray(e.linePositions), u = fi._constructPointArray(e.positions);
    return c.setLineGeometry(h), c._positions = u, c._textShape.setTextString(e.text), c._stage = 3, c._measurementValue = e.measurementValue, c;
  }
  getClassName() {
    return Hc.className;
  }
};
let na = Hc;
na.className = "Communicator.Markup.Measure.MeasureCircleEdgeLengthMarkupMeasureMarkup";
Ui(
  na.className,
  na.fromJson
);
const Uc = class extends jl {
  /** @hidden */
  constructor(n, t, e, i) {
    super(n), this._lineProperties = null, this._worldSpaceLength = 0, this._arrowsInvert = !1, this._name = "MeasureStraightEdgeLength", this._lineProperties = t, this._matrix = e.copy(), this._matrix.setTranslationComponent(0, 0, 0), this._unitMultiplier = i;
    const r = this._viewer.measureManager.getMeasurementColor();
    for (let a = 0; a < 5; a++) {
      const l = new Wi();
      l.setStrokeColor(r), l.setEndEndcapColor(r), l.setStartEndcapColor(r), this._lineShapes.push(l);
    }
    const o = this._textShape.getBoxPortion();
    o.setFillOpacity(1), o.setFillColor(new it(255, 255, 255));
  }
  /** @hidden */
  setLineGeometry(n) {
    super.setLineGeometry(n), this._positions[0] = this._linePositions[0], this._positions[2] = this._linePositions[0].copy(), this._positions[1] = this._linePositions[this._linePositions.length - 1];
    let t;
    if (this._lineProperties !== null && this._lineProperties.length !== -1) {
      const e = new d(this._lineProperties.length, 0, 0);
      this._matrix.transform(e, e), this._worldSpaceLength = e.length(), t = this._worldSpaceLength;
    } else
      t = d.subtract(this._positions[1], this._positions[0]).length();
    this._setMeasurementValue(t);
  }
  /** @hidden */
  adjust(n) {
    super.adjust(n);
    const t = this._viewer.view, e = t.raycastFromPoint(n);
    if (e === null)
      return;
    const i = this._positions[0], s = this._positions[1];
    let r = new d(1, 0, 0);
    s.equals(i) || (r = d.subtract(s, i));
    const a = t.getCamera().getUp(), l = d.cross(e.direction, a).normalize(), c = d.add(i, s).scale(0.5), h = d.add(c, a), u = d.add(c, l), p = d.add(d.scale(e.direction, 1e6), e.origin), m = new d(0, 0, 0);
    Ts(e.origin, p, c, h, u, m), this._positions[2].assign(m);
    let g = new d(0, 0, 0);
    Math.abs(r.x) <= Math.abs(r.y) && Math.abs(r.x) <= Math.abs(r.z) ? g = new d(1, 0, 0) : Math.abs(r.y) <= Math.abs(r.x) && Math.abs(r.y) <= Math.abs(r.z) ? g = new d(0, 1, 0) : g = new d(0, 0, 1);
    const _ = d.cross(g, r), y = d.cross(_, r);
    _.add(i), y.add(i);
    const b = d.add(d.scale(r, 1e4), m), w = d.add(d.scale(r, -1e4), m);
    Ts(b, w, i, _, y, m);
    const v = d.subtract(m, i);
    this._positions[3] = d.add(i, v), this._positions[4] = d.add(s, v), this._updateArrowsInverted(), this._viewer.markupManager.refreshMarkup();
  }
  _updateArrowsInverted() {
    const n = d.add(this._positions[3], this._positions[4]).scale(0.5), t = d.subtract(this._positions[4], this._positions[3]), e = d.subtract(this._positions[2], n);
    this._arrowsInvert = 2 * e.squaredLength() > t.squaredLength();
  }
  /** @hidden */
  update() {
    super.update();
    const n = this._viewer.view;
    if (this._behindView = !1, this._stage > 0) {
      this._lineEdgeShape.clearPoints();
      const t = Array(this._linePositions.length);
      for (let e = 0; e < this._linePositions.length; e++)
        t[e] = n.projectPoint(this._linePositions[e]), t[e].z <= 0 && (this._behindView = !0), this._lineEdgeShape.pushPoint(E.fromPoint3(t[e]));
    }
    if (this._stage > 1) {
      const t = new Array(6), e = Array(6);
      for (let i = 0; i < this._positions.length; i++)
        e[i] = n.projectPoint(this._positions[i]), e[i].z <= 0 && (this._behindView = !0), t[i] = E.fromPoint3(e[i]);
      this._textShape && this._textShape.setPosition(t[2]), this._lineShapes[0].set(t[3], t[4]), this._lineShapes[1].set(t[0], t[3]), this._lineShapes[2].set(t[1], t[4]), this._lineShapes[3].set(t[3], t[2]), this._lineShapes[4].set(t[3], t[4]), this._lineShapes[4].setEndcapType(ii.Arrowhead), this._lineShapes[4].setStartEndcapType(ii.Arrowhead), this._lineShapes[4].setEndcapsInverted(this._arrowsInvert);
    }
  }
  /** @hidden */
  draw() {
    if (this._visibility && this._viewer.explodeManager.getMagnitude() === 0 && (this.update(), !this._behindView)) {
      const n = this._viewer.markupManager.getRenderer();
      switch (this._stage) {
        case 1:
          n.drawPolyline(this._lineEdgeShape);
          break;
        case 2:
        case 3:
          for (const t of this._lineShapes)
            n.drawLine(t);
          n.drawTextBox(this._textShape), n.drawPolyline(this._lineEdgeShape);
          break;
      }
    }
  }
  // serialization methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      name: this._name,
      measurePoint1: this._positions[0].copy(),
      measurePoint2: this._positions[1].copy(),
      leaderPoint1: this._positions[3].copy(),
      leaderPoint2: this._positions[4].copy(),
      textPoint: this._positions[2].copy(),
      text: this._textShape.getTextString(),
      measurementValue: this._measurementValue,
      unitMultiplier: this._unitMultiplier,
      className: this.getClassName(),
      matrix: this._matrix.toJson()
    };
  }
  /**
   * Creates a new [[MeasureStraightEdgeLengthMarkup]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(n, t) {
    const e = n, i = Q.fromJson(e.matrix), s = e.unitMultiplier || 1, r = new Uc(t, null, i, s);
    return r._name = e.name, r._positions[0] = d.fromJson(e.measurePoint1), r._positions[1] = d.fromJson(e.measurePoint2), r._positions[2] = d.fromJson(e.textPoint), r._textShape.setTextString(e.text), r._positions[3] = d.fromJson(e.leaderPoint1), r._positions[4] = d.fromJson(e.leaderPoint2), r._measurementValue = e.measurementValue, r._updateArrowsInverted(), r._stage = 2, r;
  }
  getClassName() {
    return Uc.className;
  }
};
let Pl = Uc;
Pl.className = "Communicator.Markup.Measure.MeasureStraightEdgeLengthMarkup";
class Dm extends Se {
  /** @hidden */
  constructor(t, e) {
    super(t), this._pickConfig = new Ie(Xt.Line), this._moveSelectionAction = new fs(!0), this._lengthMarkup = null, this._edgeMarkup = null, this._measureManager = e, this._pickConfig.restrictLinesAndPointsToSelectedFaceInstances = !1;
  }
  /** @hidden */
  onActivate() {
    this._edgeMarkup === null && (this._edgeMarkup = new Pl(this._viewer, null, new Q(), 1));
  }
  _unregisterEdgeMarkup() {
    if (this._edgeMarkup === null)
      return;
    const t = this._edgeMarkup._getId();
    t !== "" && (this._viewer.markupManager.unregisterMarkup(t), this._edgeMarkup._setId(""));
  }
  _registerEdgeMarkup() {
    this._edgeMarkup !== null && (this._unregisterEdgeMarkup(), this._edgeMarkup._setId(this._viewer.markupManager.registerMarkup(this._edgeMarkup)));
  }
  _resetEdgeMarkup() {
    this._edgeMarkup !== null && (this._unregisterEdgeMarkup(), this._edgeMarkup.reset());
  }
  async _performMoveSelection(t, e) {
    const s = await this._viewer.view.pickFromPoint(t, this._pickConfig), r = s.getNodeId(), o = s.getLineEntity();
    r && o && !o.isCappingGeometry() && s.overlayIndex() === 0 && await this._viewer.model.isLineMeasurable(r, o.getLineId()) ? (e.setLineGeometry(o.getPoints()), this._registerEdgeMarkup()) : this._resetEdgeMarkup();
  }
  async _performUpSelection(t) {
    const e = this._viewer.view, i = this._viewer.model, s = await e.pickFromPoint(t, this._pickConfig);
    if (s.overlayIndex())
      return;
    if (this._lengthMarkup && this._lengthMarkup._getStage() === 2) {
      const h = this._lengthMarkup;
      this._lengthMarkup = null, h._nextStage(), this._measureManager.finalizeMeasurement(h);
      return;
    }
    if (this._lengthMarkup || !s.isLineSelection())
      return;
    const r = s.getNodeId();
    if (!r)
      return;
    const o = s.getLineEntity();
    if (!await this._viewer.model.isLineMeasurable(r, o.getLineId()))
      return;
    const l = i.getNodeUnitMultiplier(r), c = await i.getEdgeProperty(r, o.getLineId());
    if (this._viewer.trigger("measurementBegin"), !!c) {
      if (c instanceof ma || c instanceof Es) {
        const h = i.getNodeNetMatrix(r);
        this._lengthMarkup = new Pl(
          this._viewer,
          c,
          h,
          l
        ), this._measureManager.addMeasurement(this._lengthMarkup), this._lengthMarkup.setLineGeometry(o.getPoints()), this._lengthMarkup._nextStage(), this._lengthMarkup.adjust(t);
      } else if (c instanceof qr) {
        const h = i.getNodeNetMatrix(r);
        this._lengthMarkup = new na(
          this._viewer,
          c,
          h,
          l
        ), this._measureManager.addMeasurement(this._lengthMarkup), this._lengthMarkup.setLineGeometry(o.getPoints()), this._lengthMarkup._nextStage(), this._lengthMarkup.adjust(t);
      }
      this._lengthMarkup._getStage() === 2 && this._viewer.trigger("measurementValueSet", this._lengthMarkup);
    }
  }
  /** @hidden */
  onMouseMove(t) {
    super.onMouseMove(t);
    const e = this._edgeMarkup;
    if (e === null)
      return;
    e.setMeasurementEdgeColor(this._viewer.measureManager.getMeasurementEdgeColor());
    const i = t.getPosition();
    this.isDragging() && this._primaryTouchId === null ? this._resetEdgeMarkup() : (this._lengthMarkup === null && this._moveSelectionAction.set(() => this._performMoveSelection(i, e)), this._viewer.markupManager.refreshMarkup(), this._lengthMarkup !== null && this._lengthMarkup._getStage() > 0 && this._lengthMarkup.adjust(i));
  }
  async _onMouseUpImpl(t) {
    if (!this.isActive())
      return;
    const e = this._primaryTouchId !== null && this._lengthMarkup !== null;
    if (!(this._dragCount < 3 || e))
      return;
    const i = t.getPosition();
    await this._performUpSelection(i);
  }
  /** @hidden */
  onMouseUp(t) {
    this._onMouseUpImpl(t), super.onMouseUp(t);
  }
  /** @hidden */
  setDraggingEnabled(t) {
    this._dragging = t;
  }
  /** @hidden */
  onKeyUp(t) {
  }
  /** @hidden */
  onKeyDown(t) {
    t.getKeyCode() === Ut.Escape && (this._lengthMarkup !== null ? (this._measureManager.removeMeasurement(this._lengthMarkup), this._lengthMarkup = null) : this._measureManager.removeLastMeasurement(), this._edgeMarkup !== null && this._resetEdgeMarkup());
  }
  /** @hidden */
  setHandled() {
    return this._lengthMarkup !== null;
  }
  /** @hidden */
  onDeactivate() {
    this._lengthMarkup !== null && (this._measureManager.removeMeasurement(this._lengthMarkup), this._lengthMarkup = null), this._edgeMarkup !== null && this._resetEdgeMarkup();
  }
}
const fu = 30, Qc = class extends fi {
  constructor(n) {
    super(n), this._faceSelection = [], this._arcArray = [], this._lineGeometryShape = new br(), this.planeIntersectionLine = [], this._pointOnLine = d.zero(), this._clickpointOriginal2 = d.zero(), this._clickpointOriginal1 = d.zero(), this._plane1 = new je(), this._plane2 = new je(), this._secondPoint = d.zero(), this._firstPoint = d.zero(), this._textPos = d.zero(), this._intermediatePoint = d.zero(), this._textAnchorPoint = d.zero(), this._angle = 0, this._useAuthoredNormals = !0, this._name = "MeasureFaceFaceAngle";
    const e = this._viewer.measureManager.getMeasurementColor();
    this._lineGeometryShape.setStrokeWidth(2), this._lineGeometryShape.setStrokeColor(e), this._lineGeometryShape.setEndEndcapColor(e), this._lineGeometryShape.setStartEndcapColor(e), this._textShape = new eo(), this._textShape.getBoxPortion().setFillOpacity(1), this._textShape.getBoxPortion().setFillColor(new it(255, 255, 255));
    for (let i = 0; i < 5; i++)
      this._lineShapes.push(new Wi()), this._lineShapes[i].setStrokeColor(e), this._lineShapes[i].setEndEndcapColor(e), this._lineShapes[i].setStartEndcapColor(e);
  }
  async _getNormalAndPositionFromSelection(n, t, e) {
    const i = n.getNodeId(), s = n.getFaceEntity().getCadFaceIndex();
    e.assign(n.getPosition().copy()), t.assign(n.getFaceEntity().getNormal());
    const r = await this._viewer.model.getFaceProperty(i, s);
    if (this._useAuthoredNormals && r !== null && r instanceof Re) {
      const a = this._viewer.model.getNodeNetMatrix(i).normalMatrix();
      a !== null && a.transform(r.normal, t);
    }
  }
  getFirstSelection() {
    return this._faceSelection[0];
  }
  async setFirstFace(n) {
    const t = n.getNodeId(), e = n.getFaceEntity().getCadFaceIndex();
    this._viewer.model.setNodeFaceColor(t, e, new it(255, 0, 0)), this._faceSelection.push(n);
    const i = d.zero(), s = d.zero();
    await this._getNormalAndPositionFromSelection(n, i, s), this._firstPoint = s.copy(), this._plane1.setFromPointAndNormal(this._firstPoint, i), this._clickpointOriginal1 = n.getPosition().copy(), this._stage++;
  }
  async setSecondFace(n) {
    const t = n.getNodeId(), e = n.getFaceEntity().getCadFaceIndex();
    this._faceSelection[1] = n, this._viewer.model.setNodeFaceColor(t, e, new it(255, 0, 0));
    const i = d.zero(), s = d.zero();
    if (await this._getNormalAndPositionFromSelection(n, s, i), this._secondPoint = i.copy(), this._plane2.setFromPointAndNormal(this._secondPoint, s), this.planeIntersectionLine[0] = new d(0, 0, 0), this.planeIntersectionLine[1] = new d(0, 0, 0), eg(
      this._plane1,
      this._firstPoint,
      this._plane2,
      this._secondPoint,
      this.planeIntersectionLine[0],
      this.planeIntersectionLine[1]
    ) !== 2)
      return !1;
    const o = d.subtract(this.planeIntersectionLine[1], this.planeIntersectionLine[0]);
    o.normalize(), this.planeIntersectionLine[0].set(
      this.planeIntersectionLine[0].x - o.x * 100,
      this.planeIntersectionLine[0].y - o.y * 100,
      this.planeIntersectionLine[0].z - o.z * 100
    ), this.planeIntersectionLine[1].set(
      this.planeIntersectionLine[1].x + o.x * 100,
      this.planeIntersectionLine[1].y + o.y * 100,
      this.planeIntersectionLine[1].z + o.z * 100
    ), ss(
      this._secondPoint,
      this.planeIntersectionLine[0],
      this.planeIntersectionLine[1],
      this._pointOnLine
    );
    const a = new d(0, 0, 0), l = new d(0, 0, 0);
    a.set(
      this._firstPoint.x + o.x,
      this._firstPoint.y + o.y,
      this._firstPoint.z + o.z
    ), ss(this._pointOnLine, this._firstPoint, a, l), this._firstPoint = l.copy(), this._clickpointOriginal2 = n.getPosition().copy();
    const c = new Q(), h = d.subtract(this._secondPoint, this._pointOnLine), u = h.length(), p = d.subtract(this._firstPoint, this._pointOnLine);
    if (p.normalize(), this._intermediatePoint.set(
      this._pointOnLine.x + p.x * u,
      this._pointOnLine.y + p.y * u,
      this._pointOnLine.z + p.z * u
    ), this._angle = Yn(h, p), this._angle === 0)
      return !1;
    this._measurementValue = this._angle, this._textShape.setTextString(`${this._measurementValue.toFixed(2)}°`), this._viewer.trigger("measurementValueSet", this), this._textPos = this._pointOnLine.copy();
    let m = !1, g = new d(0, 0, 0);
    const _ = new d(0, 0, 0);
    lo(o, 1, c), c.transform(h, _), g.set(_.x + this._pointOnLine.x, _.y + this._pointOnLine.y, _.z + this._pointOnLine.z), g = d.subtract(g, this._firstPoint);
    const y = g.length();
    return lo(o, -1, c), c.transform(h, _), g.set(_.x + this._pointOnLine.x, _.y + this._pointOnLine.y, _.z + this._pointOnLine.z), d.subtract(g, this._firstPoint), g.length() < y && (m = !0), this._arcArray = yc(
      o,
      m ? -this._angle : this._angle,
      this._pointOnLine,
      h,
      fu
    ), this._stage++, !0;
  }
  adjust(n) {
    if (super.adjust(n), this._stage <= 1)
      return;
    const t = this._viewer.view.raycastFromPoint(n);
    if (t === null)
      return;
    const e = new d(
      t.origin.x + t.direction.x * 1e6,
      t.origin.y + t.direction.y * 1e6,
      t.origin.z + t.direction.z * 1e6
    ), i = new d(0, 0, 0);
    Ts(
      t.origin,
      e,
      this._pointOnLine,
      this._firstPoint,
      this._secondPoint,
      i
    ), this._textPos = i.copy();
    let s = new d(0, 0, 0);
    s = d.subtract(i, this._pointOnLine);
    const r = s.length();
    s = d.subtract(this._secondPoint, this._pointOnLine), s.normalize(), this._secondPoint.set(
      this._pointOnLine.x + s.x * r,
      this._pointOnLine.y + s.y * r,
      this._pointOnLine.z + s.z * r
    );
    const o = d.subtract(this.planeIntersectionLine[1], this.planeIntersectionLine[0]);
    o.normalize();
    const a = new Q(), l = d.subtract(this._secondPoint, this._pointOnLine), c = l.length(), h = d.subtract(this._firstPoint, this._pointOnLine);
    h.normalize(), this._intermediatePoint.set(
      this._pointOnLine.x + h.x * c,
      this._pointOnLine.y + h.y * c,
      this._pointOnLine.z + h.z * c
    );
    let u = !1, p = new d(0, 0, 0);
    const m = new d(0, 0, 0);
    lo(o, 1, a), a.transform(l, m), p.set(m.x + this._pointOnLine.x, m.y + this._pointOnLine.y, m.z + this._pointOnLine.z), p = d.subtract(p, this._firstPoint);
    const g = p.length();
    lo(o, -1, a), a.transform(l, m), p.set(m.x + this._pointOnLine.x, m.y + this._pointOnLine.y, m.z + this._pointOnLine.z), p = d.subtract(p, this._firstPoint), p.length() < g && (u = !0), this._arcArray = yc(
      o,
      u ? -this._angle : this._angle,
      this._pointOnLine,
      l,
      fu
    );
    let y;
    const b = this._viewer.view.projectPoint(this._textPos);
    for (const w of this._arcArray) {
      const v = this._viewer.view.projectPoint(w), k = new d(
        b.x - v.x,
        b.y - v.y,
        b.z - v.z
      ).length();
      (y === void 0 || y > k) && (y = k);
    }
    if (y === void 0 || y <= 20)
      this._textAnchorPoint = this._textPos;
    else {
      const w = this._viewer.view.projectPoint(this._intermediatePoint), v = this._viewer.view.projectPoint(this._secondPoint), C = new d(
        w.x - b.x,
        w.y - b.y,
        w.z - b.z
      ), k = new d(
        v.x - b.x,
        v.y - b.y,
        v.z - b.z
      ), Y = C.length(), P = k.length();
      Y < P ? this._textAnchorPoint = this._intermediatePoint : this._textAnchorPoint = this._secondPoint;
    }
  }
  _nextStage() {
    this._stage++, this._stage > 2 && (this._finalized = !0, this.cleanup());
  }
  cleanup() {
    const n = (t) => {
      const e = this._faceSelection[t];
      this._viewer.model.unsetNodeFaceColor(
        e.getNodeId(),
        e.getFaceEntity().getCadFaceIndex()
      );
    };
    this._stage >= 2 && n(1), this._stage >= 1 && n(0);
  }
  update() {
    super.update();
    const n = this._viewer.view;
    if (this._stage > 1) {
      this._lineGeometryShape.clearPoints();
      for (const i of this._arcArray)
        this._lineGeometryShape.pushPoint(E.fromPoint3(n.projectPoint(i)));
      this._lineGeometryShape.setEndcapType(ii.Arrowhead), this._lineGeometryShape.setStartEndcapType(ii.Arrowhead), this._lineGeometryShape.setEndEndcapSize(5), this._lineGeometryShape.setStartEndcapSize(5);
      const t = new Array(10);
      t[0] = n.projectPoint(this._textPos), t[1] = n.projectPoint(this._firstPoint), t[2] = n.projectPoint(this._clickpointOriginal1), t[3] = n.projectPoint(this._secondPoint), t[4] = n.projectPoint(this._clickpointOriginal2), t[5] = n.projectPoint(this._intermediatePoint), t[6] = n.projectPoint(this._textAnchorPoint), this._behindView = !1;
      const e = new Array(10);
      for (let i = 0; i <= 6; i++)
        t[i].z <= 0 && (this._behindView = !0), e[i] = E.fromPoint3(t[i]);
      this._textShape && this._textShape.setPosition(e[0]), this._lineShapes[0].set(e[1], e[2]), this._lineShapes[1].set(e[1], e[5]), this._lineShapes[2].set(e[3], e[4]), this._lineShapes[3].set(e[6], e[0]);
    }
  }
  draw() {
    const n = this._viewer.explodeManager.getMagnitude() !== 0;
    if (!(!this._visibility || n) && (this.update(), !this._behindView && this._stage >= 2 && this._stage <= 4)) {
      const t = this._viewer.markupManager.getRenderer();
      for (let e = 0; e < 4; e++)
        t.drawLine(this._lineShapes[e]);
      t.drawTextBox(this._textShape), t.drawPolyline(this._lineGeometryShape);
    }
  }
  /**
   * Sets whether created markup will use authored normals or use selection results to calculate angles
   * @param use
   */
  setUseAuthoredNormals(n) {
    this._useAuthoredNormals = n;
  }
  /**
   * Gets whether created markup will use authored normals or use selection results to calculate angles
   */
  getUseAuthoredNormals() {
    return this._useAuthoredNormals;
  }
  // selection methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    const n = [];
    for (const t of this._arcArray) {
      const e = t.toJson();
      n.push(e);
    }
    return {
      text: this._textShape.getTextString(),
      textPos: this._textPos.toJson(),
      arcArray: n,
      firstPoint: this._firstPoint.toJson(),
      clickpointOriginal1: this._clickpointOriginal1.toJson(),
      secondPoint: this._secondPoint.toJson(),
      clickpointOriginal2: this._clickpointOriginal2.toJson(),
      intermediatePoint: this._intermediatePoint.toJson(),
      textAnchorPoint: this._textAnchorPoint.toJson(),
      measurementValue: this._measurementValue,
      className: this.getClassName()
    };
  }
  /**
   * Creates a new [[MeasureFaceFaceAngleMarkup]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(n, t) {
    const e = n, i = new Qc(t);
    for (const s of e.arcArray) {
      const r = d.fromJson(s);
      i._arcArray.push(r);
    }
    return i._textShape.setTextString(e.text), i._textPos.assign(d.fromJson(e.textPos)), i._firstPoint.assign(d.fromJson(e.firstPoint)), i._clickpointOriginal1 = d.fromJson(e.clickpointOriginal1), i._secondPoint.assign(d.fromJson(e.secondPoint)), i._clickpointOriginal2 = d.fromJson(e.clickpointOriginal2), i._intermediatePoint.assign(d.fromJson(e.intermediatePoint)), i._textAnchorPoint.assign(d.fromJson(e.textAnchorPoint)), i._measurementValue = e.measurementValue, i._stage = 3, i;
  }
  // serialization methods
  getClassName() {
    return Qc.className;
  }
};
let sa = Qc;
sa.className = "Communicator.Markup.Measure.MeasureFaceFaceAngleMarkup";
Ui(sa.className, sa.fromJson);
async function hc(n, t) {
  if (t.getSelectionType() !== pi.None) {
    const e = t.getNodeId(), i = t.getFaceEntity();
    return await n.isFaceMeasurable(e, i.getCadFaceIndex()) ? (i.getCadFaceBits() & kd.SelectionBitsFacePlanar) !== 0 : !1;
  }
  return !1;
}
class zm extends Se {
  constructor(t, e) {
    super(t), this._moveSelectionAction = new fs(!0), this._currentHighlight = null, this._markup = null, this._useAuthoredNormals = !0, this._measureManager = e;
  }
  _unsetCurrentHighlight() {
    this._currentHighlight !== null && (this._viewer.model.unsetNodeFaceColor(
      this._currentHighlight.getNodeId(),
      this._currentHighlight.getFaceEntity().getCadFaceIndex()
    ), this._currentHighlight = null);
  }
  async _performMoveSelection(t) {
    const e = this._viewer.view, i = this._viewer.model, s = await e.pickFromPoint(t, new Ie());
    if (s.overlayIndex() !== 0 || !s.isFaceSelection())
      return;
    const r = s.getNodeId(), o = s.getFaceEntity();
    if (i.getNodeType(s.getNodeId()) === At.BodyInstance) {
      if (this._markup) {
        const a = this._markup.getFirstSelection();
        if (r === a.getNodeId()) {
          const l = a.getFaceEntity().getCadFaceIndex(), c = o.getCadFaceIndex();
          if (l === c)
            return;
        }
      }
      this._currentHighlight !== null ? s.equals(this._currentHighlight) ? s.getSelectionType() === pi.None && this._unsetCurrentHighlight() : (this._unsetCurrentHighlight(), await hc(i, s) && (this._currentHighlight = s, i.setNodeFaceColor(r, o.getCadFaceIndex(), it.yellow()))) : this._currentHighlight === null && await hc(i, s) && (this._currentHighlight = s, i.setNodeFaceColor(r, o.getCadFaceIndex(), it.yellow()));
    }
  }
  async _performUpSelection(t) {
    const e = this._viewer.view, i = this._viewer.model, s = await e.pickFromPoint(t, new Ie());
    if (s.overlayIndex())
      return;
    if (this._markup && this._markup._getStage() > 1) {
      if (this._viewer.trigger("measurementBegin"), this._markup._nextStage(), this._markup._isFinalized()) {
        const a = this._markup;
        this._markup = null, this._measureManager.finalizeMeasurement(a);
      }
      return;
    }
    if (!s.isFaceSelection() || !(i.getNodeType(s.getNodeId()) === At.BodyInstance && (!this._markup || this._markup._getStage() <= 1)) || !await hc(i, s))
      return;
    const r = s.getFaceEntity();
    await i.getFaceProperty(
      s.getNodeId(),
      r.getCadFaceIndex()
    ) instanceof Re && (this._unsetCurrentHighlight(), this._markup === null ? (this._markup = new sa(this._viewer), this._markup.setUseAuthoredNormals(this._useAuthoredNormals), await this._markup.setFirstFace(s), this._measureManager.addMeasurement(this._markup)) : await this._markup.setSecondFace(s) && this._markup.adjust(t));
  }
  /** @hidden */
  onMouseMove(t) {
    super.onMouseMove(t);
    const e = t.getPosition();
    (!this._markup || this._markup._getStage() <= 1) && this._performMoveSelection(e), this._viewer.markupManager.refreshMarkup(), this._markup !== null && this._markup._getStage() > 0 && this._markup.adjust(e);
  }
  _onMouseUpImpl(t) {
    if (!this.isActive())
      return;
    const e = this._primaryTouchId !== null && this._markup !== null && this._markup._getStage() > 1;
    if (!(this._dragCount < 3 || e))
      return;
    const i = t.getPosition();
    this._moveSelectionAction.set(() => this._performUpSelection(i));
  }
  /** @hidden */
  onMouseUp(t) {
    this._onMouseUpImpl(t), super.onMouseUp(t);
  }
  /** @hidden */
  setDraggingEnabled(t) {
    this._dragging = t;
  }
  /** @hidden */
  onKeyUp(t) {
  }
  /** @hidden */
  onKeyDown(t) {
    t.getKeyCode() === Ut.Escape && (this._markup !== null ? (this._markup.cleanup(), this._measureManager.removeMeasurement(this._markup), this._markup = null) : this._measureManager.removeLastMeasurement());
  }
  /** @hidden */
  setHandled() {
    return this._markup !== null && this._markup._getStage() > 1;
  }
  /** @hidden */
  onDeactivate() {
    this._unsetCurrentHighlight(), this._markup !== null && (this._measureManager.removeMeasurement(this._markup), this._markup.cleanup(), this._markup = null);
  }
  /**
   * Sets whether created markup will use authored normals or use selection results to calculate angles
   * @param use
   */
  setUseAuthoredNormals(t) {
    this._useAuthoredNormals = t;
  }
  /**
   * Gets whether created markup will use authored normals or use selection results to calculate angles
   */
  getUseAuthoredNormals() {
    return this._useAuthoredNormals;
  }
}
const vo = class extends fi {
  constructor(n) {
    super(n), this._faceSelection = [], this._line1PreviewShape1 = new Wi(), this._line1PreviewShape2 = new Wi(), this._line2PreviewShape1 = new Wi(), this._line2PreviewShape2 = new Wi(), this._matrix1 = new Q(), this._matrix2 = new Q(), this._lineGeometryShape = new br(), this._parallelFaces = !1, this._triangulatedDistance = !0, this._pointsOnSameRay = !1, this._arrowsInvert = !1, this._faceData = [], this._distance = 0, this._surfaceCenter = [d.zero(), d.zero()], this._surfaceAxis1 = [d.zero(), d.zero()], this._surfaceAxis2 = [d.zero(), d.zero()], this._cylinderAxisInfinite1 = [d.zero(), d.zero()], this._cylinderAxisInfinite2 = [d.zero(), d.zero()], this._secondPointInitial = d.zero(), this._firstPointHelper = d.zero(), this._secondPointHelper = d.zero(), this._secondPoint = d.zero(), this._firstPoint = d.zero(), this._textPos = d.zero(), this._name = "MeasureFaceFaceDistance", this._lineGeometryShape.setStrokeWidth(2), this._lineGeometryShape.setStrokeColor(this._viewer.measureManager.getMeasurementColor()), this._textShape = new eo(), this._textShape.getBoxPortion().setFillOpacity(1), this._textShape.getBoxPortion().setFillColor(new it(255, 255, 255));
    const e = this._viewer.measureManager.getMeasurementColor();
    for (let i = 0; i < 5; i++)
      this._lineShapes.push(new Wi()), this._lineShapes[i].setStrokeColor(e), this._lineShapes[i].setEndEndcapColor(e), this._lineShapes[i].setStartEndcapColor(e);
  }
  setUnitMultiplier(n) {
    this._unitMultiplier = n;
  }
  setFirstFace(n, t, e, i) {
    const s = n.getNodeId(), r = n.getFaceEntity(), o = n.getPosition();
    if (this._matrix1 = e.copy(), this._viewer.model.setNodeFaceColor(s, r.getCadFaceIndex(), new it(255, 0, 0)), this._faceSelection[0] = n, this._firstPoint = o.copy(), this._faceData[0] = t, this._faceData[0] instanceof Re) {
      const a = this._faceData[0], l = new d(
        a.origin.x + a.normal.x,
        a.origin.y + a.normal.y,
        a.origin.z + a.normal.z
      );
      this._matrix1.transform(l, this._surfaceAxis1[0]), this._matrix1.transform(a.origin, this._surfaceCenter[0]);
    } else
      this._faceData[0] instanceof Ce && this.createCylinderData(this._faceData[0], e, i);
    this._stage++;
  }
  getFirstSelection() {
    return this._faceSelection[0] || null;
  }
  getFirstFaceData() {
    return this._faceData[0] || null;
  }
  cleanup() {
    const n = this._viewer.model;
    this._stage >= 2 && n.unsetNodeFaceColor(
      this._faceSelection[1].getNodeId(),
      this._faceSelection[1].getFaceEntity().getCadFaceIndex()
    ), this._stage >= 1 && n.unsetNodeFaceColor(
      this._faceSelection[0].getNodeId(),
      this._faceSelection[0].getFaceEntity().getCadFaceIndex()
    );
  }
  createCylinderData(n, t, e) {
    const s = d.subtract(e.max, e.min).length() / 4, r = new d(
      n.origin.x + n.normal.x * 1e4,
      n.origin.y + n.normal.y * 1e4,
      n.origin.z + n.normal.z * 1e4
    ), o = new d(
      n.origin.x - n.normal.x * 1e4,
      n.origin.y - n.normal.y * 1e4,
      n.origin.z - n.normal.z * 1e4
    ), a = new d(0, 0, 0);
    ss(n.origin, r, o, a), this._surfaceCenter[this._stage] = new d(0, 0, 0), t.transform(a, this._surfaceCenter[this._stage]);
    const l = new d(
      a.x + n.normal.x,
      a.y + n.normal.y,
      a.z + n.normal.z
    );
    this._surfaceAxis1[this._stage] = new d(0, 0, 0), t.transform(l, this._surfaceAxis1[this._stage]), l.set(
      a.x - n.normal.x,
      a.y - n.normal.y,
      a.z - n.normal.z
    ), this._surfaceAxis2[this._stage] = new d(0, 0, 0), t.transform(l, this._surfaceAxis2[this._stage]);
    let c = new d(0, 0, 0);
    c = this._surfaceAxis1[this._stage].copy(), c = d.subtract(c, this._surfaceCenter[this._stage]), c.normalize(), this._surfaceAxis1[this._stage].set(
      this._surfaceCenter[this._stage].x + c.x * s,
      this._surfaceCenter[this._stage].y + c.y * s,
      this._surfaceCenter[this._stage].z + c.z * s
    ), this._surfaceAxis2[this._stage].set(
      this._surfaceCenter[this._stage].x - c.x * s,
      this._surfaceCenter[this._stage].y - c.y * s,
      this._surfaceCenter[this._stage].z - c.z * s
    ), this._cylinderAxisInfinite1[this._stage] = new d(
      this._surfaceCenter[this._stage].x + c.x * s * 1e3,
      this._surfaceCenter[this._stage].y + c.y * s * 1e3,
      this._surfaceCenter[this._stage].z + c.z * s * 1e3
    ), this._cylinderAxisInfinite2[this._stage] = new d(
      this._surfaceCenter[this._stage].x - c.x * s * 1e3,
      this._surfaceCenter[this._stage].y - c.y * s * 1e3,
      this._surfaceCenter[this._stage].z - c.z * s * 1e3
    );
  }
  async setSecondFace(n, t, e, i, s) {
    const r = this._faceSelection[0], o = this._faceData[0];
    if (r === void 0 || o === void 0)
      throw new Mt("setSecondFace() called before setFirstFace()");
    if (e instanceof Re) {
      const l = o, c = new d(
        l.origin.x + l.normal.x,
        l.origin.y + l.normal.y,
        l.origin.z + l.normal.z
      );
      this._matrix1.transform(c, this._surfaceAxis1[0]), this._matrix1.transform(l.origin, this._surfaceCenter[0]);
    } else if (e instanceof Ce)
      this.createCylinderData(e, i, s);
    else
      return;
    const a = await this._viewer.model.computeMinimumFaceFaceDistance(
      r.getNodeId(),
      r.getFaceEntity().getCadFaceIndex(),
      t.getNodeId(),
      t.getFaceEntity().getCadFaceIndex()
    );
    if (a.distance !== 0) {
      if (this._matrix2 = i.copy(), this._secondPoint = t.getPosition().copy(), this._secondPointInitial = new d(
        this._firstPoint.x,
        this._firstPoint.y,
        this._firstPoint.z
      ), o instanceof Re && e instanceof Re) {
        const l = e, c = new d(
          l.origin.x + l.normal.x,
          l.origin.y + l.normal.y,
          l.origin.z + l.normal.z
        );
        this._matrix2.transform(c, this._surfaceAxis1[1]), this._matrix2.transform(l.origin, this._surfaceCenter[1]);
        const h = new d(
          this._surfaceAxis1[0].x - this._surfaceCenter[0].x,
          this._surfaceAxis1[0].y - this._surfaceCenter[0].y,
          this._surfaceAxis1[0].z - this._surfaceCenter[0].z
        ), u = new d(
          this._surfaceAxis1[1].x - this._surfaceCenter[1].x,
          this._surfaceAxis1[1].y - this._surfaceCenter[1].y,
          this._surfaceAxis1[1].z - this._surfaceCenter[1].z
        );
        h.normalize(), u.normalize();
        const p = new d(-h.x, -h.y, -h.z);
        if (h.equalsWithTolerance(u, 1e-5) || p.equalsWithTolerance(u, 1e-5)) {
          this._secondPointHelper = new d(
            this._secondPoint.x,
            this._secondPoint.y,
            this._secondPoint.z
          ), this._firstPointHelper = new d(
            this._firstPoint.x,
            this._firstPoint.y,
            this._firstPoint.z
          );
          const m = new je();
          m.setFromPointAndNormal(this._surfaceCenter[0], h);
          const g = new je();
          g.setFromPointAndNormal(this._surfaceCenter[1], u);
          const _ = new d(
            this._firstPoint.x + h.x,
            this._firstPoint.y + h.y,
            this._firstPoint.z + h.z
          );
          if (Ju(r.getPosition(), _, g, this._secondPoint), p.equalsWithTolerance(u, 1e-5)) {
            const Y = new d(-h.x, -h.y, -h.z);
            m.setFromPointAndNormal(this._surfaceCenter[0], Y);
          }
          const y = Math.abs(g.d - m.d) / m.normal.length();
          this._distance = y, this._setMeasurementValue(this._distance), this._parallelFaces = !0, this._triangulatedDistance = !1;
          const b = new d(0, 1, 0), w = d.subtract(this._secondPoint, this._firstPoint);
          let v = new d(0, 0, 0);
          v = d.subtract(this._secondPointHelper, this._firstPoint);
          const C = Yn(b, w), k = Yn(b, v);
          this._textPos.assign(this._secondPoint), C - k < 0.1 && C - k > -0.1 && (this._pointsOnSameRay = !0);
        } else
          this._firstPoint.assign(a.pos1), this._secondPoint.assign(a.pos2), this._textPos.assign(a.pos2), this._distance = a.distance, this._setMeasurementValue(this._distance);
      } else if (o instanceof Ce && e instanceof Ce) {
        const l = new d(
          this._surfaceAxis1[0].x - this._surfaceCenter[0].x,
          this._surfaceAxis1[0].y - this._surfaceCenter[0].y,
          this._surfaceAxis1[0].z - this._surfaceCenter[0].z
        ), c = new d(
          this._surfaceAxis1[1].x - this._surfaceCenter[1].x,
          this._surfaceAxis1[1].y - this._surfaceCenter[1].y,
          this._surfaceAxis1[1].z - this._surfaceCenter[1].z
        );
        l.normalize(), c.normalize();
        const h = new d(-l.x, -l.y, -l.z);
        if (l.equalsWithTolerance(c, 1e-5) || h.equalsWithTolerance(c, 1e-5)) {
          const u = new d(0, 0, 0);
          ss(
            this._firstPoint,
            this._cylinderAxisInfinite1[0],
            this._cylinderAxisInfinite2[0],
            u
          ), this._firstPoint = u.copy();
          let p = new d(this._firstPoint.x, this._firstPoint.y, this._firstPoint.z);
          p = d.subtract(p, this._surfaceCenter[0]), p.set(0, 0, 0), ss(
            this._firstPoint,
            this._cylinderAxisInfinite1[1],
            this._cylinderAxisInfinite2[1],
            u
          ), this._secondPoint = u.copy();
          const m = d.subtract(this._secondPoint, this._firstPoint).length();
          if (m < 1e-7)
            return;
          this._triangulatedDistance = !1, this._textPos.assign(this._secondPoint), this._setMeasurementValue(m);
        } else {
          if (this._distance = sg(
            this._cylinderAxisInfinite1[0],
            this._cylinderAxisInfinite2[0],
            this._cylinderAxisInfinite1[1],
            this._cylinderAxisInfinite2[1],
            this._firstPoint,
            this._secondPoint
          ), this._distance < 1e-7)
            return;
          this._textPos.assign(this._firstPoint), this._setMeasurementValue(this._distance);
        }
      } else if (o instanceof Ce && e instanceof Re) {
        const l = new d(
          this._surfaceAxis1[0].x - this._surfaceCenter[0].x,
          this._surfaceAxis1[0].y - this._surfaceCenter[0].y,
          this._surfaceAxis1[0].z - this._surfaceCenter[0].z
        ).normalize(), c = await this._viewer.model.computeMinimumFaceLineDistance(
          t.getNodeId(),
          t.getFaceEntity().getCadFaceIndex(),
          new Vn(this._surfaceCenter[0], l)
        );
        if (this._distance = c.distance, this._distance < 1e-7)
          return;
        this._firstPoint.assign(c.pos1), this._secondPoint.assign(c.pos2), this._textPos.assign(c.pos2), this._secondPointHelper = new d(
          this._secondPoint.x,
          this._secondPoint.y,
          this._secondPoint.z
        ), this._firstPointHelper = new d(
          this._firstPoint.x,
          this._firstPoint.y,
          this._firstPoint.z
        ), this._viewer.model.setNodeFaceColor(
          t.getNodeId(),
          t.getFaceEntity().getCadFaceIndex(),
          new it(255, 0, 0)
        ), this._faceData[1] = e, this._faceSelection[1] = t, this._stage++, this.adjust(n), this._setMeasurementValue(this._distance);
      } else if (o instanceof Re && e instanceof Ce) {
        const l = new d(
          this._surfaceAxis1[1].x - this._surfaceCenter[1].x,
          this._surfaceAxis1[1].y - this._surfaceCenter[1].y,
          this._surfaceAxis1[1].z - this._surfaceCenter[1].z
        ).normalize(), c = await this._viewer.model.computeMinimumFaceLineDistance(
          r.getNodeId(),
          r.getFaceEntity().getCadFaceIndex(),
          new Vn(this._surfaceCenter[1], l)
        );
        if (this._distance = c.distance, this._distance < 1e-7)
          return;
        this._firstPoint.assign(c.pos1), this._secondPoint.assign(c.pos2), this._textPos.assign(c.pos2), this._secondPointHelper = new d(
          this._secondPoint.x,
          this._secondPoint.y,
          this._secondPoint.z
        ), this._firstPointHelper = new d(
          this._firstPoint.x,
          this._firstPoint.y,
          this._firstPoint.z
        ), this._viewer.model.setNodeFaceColor(
          t.getNodeId(),
          t.getFaceEntity().getCadFaceIndex(),
          new it(255, 0, 0)
        ), this._faceData[1] = e, this._faceSelection[1] = t, this._stage++, this.adjust(n), this._setMeasurementValue(this._distance);
      } else {
        if (this._firstPoint.assign(a.pos1), this._secondPoint.assign(a.pos2), this._textPos.assign(a.pos2), this._distance = a.distance, this._distance < 1e-7)
          return;
        this._setMeasurementValue(this._distance);
      }
      this._viewer.model.setNodeFaceColor(
        t.getNodeId(),
        t.getFaceEntity().getCadFaceIndex(),
        new it(255, 0, 0)
      ), this._faceData[1] = e, this._faceSelection[1] = t, this._stage++, this.adjust(n);
    }
  }
  adjust(n) {
    if (super.adjust(n), this._stage <= 1)
      return;
    const t = this._viewer.view.raycastFromPoint(n);
    if (t === null)
      return;
    const e = new d(
      t.origin.x + t.direction.x * 1e6,
      t.origin.y + t.direction.y * 1e6,
      t.origin.z + t.direction.z * 1e6
    ), i = Bu(t.direction);
    let s = new d(0, 0, 0);
    s = d.cross(t.direction, i), s.normalize();
    let r = new d(
      (this._firstPoint.x + this._secondPoint.x) / 2,
      (this._firstPoint.y + this._secondPoint.y) / 2,
      (this._firstPoint.z + this._secondPoint.z) / 2
    );
    r = this._textPos.copy(), i.set(r.x + i.x, r.y + i.y, r.z + i.z), s.set(r.x + s.x, r.y + s.y, r.z + s.z);
    const o = new d(0, 0, 0);
    if (Ts(t.origin, e, r, i, s, o), this._stage === 2)
      ss(o, this._firstPoint, this._secondPoint, this._textPos);
    else if (this._parallelFaces || this._triangulatedDistance) {
      const a = new d(0, 0, 0), l = this._faceData[0] instanceof Ce || this._faceData[1] instanceof Ce, c = this._faceData[0] instanceof Re || this._faceData[1] instanceof Re;
      if (!this._pointsOnSameRay) {
        l && c ? ss(o, this._secondPoint, this._secondPointInitial, a) : ss(o, this._secondPoint, this._secondPointHelper, a);
        let h = new d(0, 0, 0);
        h = d.subtract(a, this._secondPoint), this._secondPoint = a.copy(), this._firstPoint.set(
          this._firstPoint.x + h.x,
          this._firstPoint.y + h.y,
          this._firstPoint.z + h.z
        ), this._textPos.set(
          this._textPos.x + h.x,
          this._textPos.y + h.y,
          this._textPos.z + h.z
        );
      }
    } else {
      const a = new d(0, 0, 0);
      ss(
        o,
        this._cylinderAxisInfinite1[1],
        this._cylinderAxisInfinite2[1],
        a
      );
      const l = d.subtract(a, this._secondPoint);
      this._secondPoint = a.copy(), this._firstPoint.set(
        this._firstPoint.x + l.x,
        this._firstPoint.y + l.y,
        this._firstPoint.z + l.z
      ), this._textPos.set(
        this._textPos.x + l.x,
        this._textPos.y + l.y,
        this._textPos.z + l.z
      );
    }
    this._updateArrowsInverted(), this._viewer.markupManager.refreshMarkup();
  }
  _updateArrowsInverted() {
    const n = new d(
      (this._firstPoint.x + this._secondPoint.x) / 2,
      (this._firstPoint.y + this._secondPoint.y) / 2,
      (this._firstPoint.z + this._secondPoint.z) / 2
    ), t = d.subtract(this._secondPoint, this._firstPoint);
    d.subtract(this._textPos, n).length() * 2 > t.length() ? this._arrowsInvert = !0 : this._arrowsInvert = !1;
  }
  _nextStage() {
    this._stage++, (this._stage > 3 || this._stage > 2 && this._triangulatedDistance) && (this._finalized = !0, this.cleanup());
  }
  /** @hidden */
  update() {
    super.update();
    const n = this._viewer.view;
    if (this._behindView = !1, this._stage === 0)
      return;
    const t = new Array(10), e = [];
    for (let i = 0; i < 10; i++)
      e.push(new d(0, 0, 0));
    this._faceData[0] instanceof Ce && (e[0] = n.projectPoint(this._surfaceCenter[0]), e[1] = n.projectPoint(this._surfaceAxis1[0]), e[2] = n.projectPoint(this._surfaceAxis2[0]), t[0] = E.fromPoint3(e[0]), t[1] = E.fromPoint3(e[1]), t[2] = E.fromPoint3(e[2]), this._line1PreviewShape1.set(t[0], t[1]), this._line1PreviewShape2.set(t[0], t[2])), this._stage > 1 && this._faceData[1] instanceof Ce && (e[0] = n.projectPoint(this._surfaceCenter[1]), e[1] = n.projectPoint(this._surfaceAxis1[1]), e[2] = n.projectPoint(this._surfaceAxis2[1]), t[0] = E.fromPoint3(e[0]), t[1] = E.fromPoint3(e[1]), t[2] = E.fromPoint3(e[2]), this._line2PreviewShape1.set(t[0], t[1]), this._line2PreviewShape2.set(t[0], t[2])), this._stage > 1 && (e[0] = n.projectPoint(this._textPos), e[1] = n.projectPoint(this._firstPoint), e[2] = n.projectPoint(this._secondPoint), t[0] = E.fromPoint3(e[0]), t[1] = E.fromPoint3(e[1]), t[2] = E.fromPoint3(e[2]), this._textShape && this._textShape.setPosition(t[0]), this._lineShapes[0].setEndcapType(ii.Arrowhead), this._lineShapes[0].setStartEndcapType(ii.Arrowhead), this._lineShapes[0].setEndcapsInverted(this._arrowsInvert), this._lineShapes[0].set(t[1], t[2]), e[3] = n.projectPoint(this._firstPointHelper), e[4] = n.projectPoint(this._secondPointHelper), t[3] = E.fromPoint3(e[3]), t[4] = E.fromPoint3(e[4]), this._lineShapes[1].set(t[2], t[4]), this._lineShapes[2].set(t[1], t[3]), this._lineShapes[3].set(t[1], t[0]));
    for (let i = 0; i < 6; i++)
      e[i].z < 0 && (this._behindView = !0);
  }
  draw() {
    if (this._visibility && this._viewer.explodeManager.getMagnitude() === 0 && (this.update(), !this._behindView)) {
      const n = this._faceData[0] instanceof Ce || this._faceData[1] instanceof Ce, t = this._faceData[0] instanceof Re || this._faceData[1] instanceof Re, e = this._viewer.markupManager.getRenderer();
      switch (this._stage) {
        case 1:
          this._faceData[0] instanceof Ce && (e.drawLine(this._line1PreviewShape1), e.drawLine(this._line1PreviewShape2));
          break;
        case 2:
        case 3:
        case 4:
          this._faceData[0] instanceof Ce && (e.drawLine(this._line1PreviewShape1), e.drawLine(this._line1PreviewShape2)), this._faceData[1] instanceof Ce && (e.drawLine(this._line2PreviewShape1), e.drawLine(this._line2PreviewShape2)), n && t ? (e.drawLine(this._lineShapes[0]), e.drawLine(this._lineShapes[1]), e.drawLine(this._lineShapes[2]), e.drawLine(this._lineShapes[3]), e.drawTextBox(this._textShape)) : (e.drawLine(this._lineShapes[0]), this._parallelFaces && (e.drawLine(this._lineShapes[1]), e.drawLine(this._lineShapes[2])), e.drawLine(this._lineShapes[3]), e.drawTextBox(this._textShape));
          break;
      }
    }
  }
  //serialization methods
  static _serializeFaceProp(n) {
    return n instanceof Ce ? {
      type: "CylinderElement",
      origin: n.origin.toJson(),
      normal: n.normal.toJson(),
      radius: n.radius
    } : n instanceof Re ? {
      type: "PlaneElement",
      origin: n.origin.toJson(),
      normal: n.normal.toJson()
    } : null;
  }
  static _constructFaceProp(n) {
    if (n.type === "CylinderElement") {
      const t = d.fromJson(n.origin), e = d.fromJson(n.normal), i = n.radius;
      return new Ce(i, t, e);
    } else if (n.type === "PlaneElement") {
      const t = d.fromJson(n.origin), e = d.fromJson(n.normal);
      return new Re(t, e);
    } else
      return null;
  }
  // serialization methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    const n = [];
    for (const s of this._faceData)
      n.push(vo._serializeFaceProp(s));
    const t = [];
    for (const s of this._surfaceCenter)
      t.push(s.toJson());
    const e = [];
    for (const s of this._surfaceAxis1)
      e.push(s.toJson());
    const i = [];
    for (const s of this._surfaceAxis2)
      i.push(s.toJson());
    return {
      text: this._textShape.getTextString(),
      textPos: this._textPos.toJson(),
      firstPoint: this._firstPoint.toJson(),
      secondPoint: this._secondPoint.toJson(),
      firstPointHelper: this._firstPointHelper.toJson(),
      secondPointHelper: this._secondPointHelper.toJson(),
      secondPointInitial: this._secondPointInitial.toJson(),
      measurementValue: this._measurementValue,
      unitMultiplier: this._unitMultiplier,
      parallelFaces: this._parallelFaces,
      faceData: n,
      surfaceCenter: t,
      surfaceAxis1: e,
      surfaceAxis2: i,
      name: this.getName(),
      className: this.getClassName()
    };
  }
  /**
   * Creates a new [[MeasureFaceFaceDistanceMarkup]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(n, t) {
    const e = n, i = new vo(t);
    i.setName(e.name), i._textShape.setTextString(e.text), i._textPos.assign(d.fromJson(e.textPos)), i._firstPoint.assign(d.fromJson(e.firstPoint)), i._firstPointHelper.assign(d.fromJson(e.firstPointHelper)), i._secondPoint.assign(d.fromJson(e.secondPoint)), i._secondPointHelper.assign(d.fromJson(e.secondPointHelper)), e.secondPointInitial !== void 0 && i._secondPointInitial.assign(d.fromJson(e.secondPointInitial)), console.assert(Array.isArray(e.faceData));
    for (const s of e.faceData) {
      const r = vo._constructFaceProp(s);
      console.assert(r !== null), i._faceData.push(r);
    }
    return i._surfaceCenter[0].assign(e.surfaceCenter[0]), i._surfaceCenter[1].assign(e.surfaceCenter[1]), i._surfaceAxis1[0].assign(e.surfaceAxis1[0]), i._surfaceAxis1[1].assign(e.surfaceAxis1[1]), i._surfaceAxis2[0].assign(e.surfaceAxis2[0]), i._surfaceAxis2[1].assign(e.surfaceAxis2[1]), i._stage = 4, i._parallelFaces = e.parallelFaces, i._measurementValue = e.measurementValue, i._unitMultiplier = e.unitMultiplier || 1, i;
  }
  getClassName() {
    return vo.className;
  }
};
let ra = vo;
ra.className = "Communicator.Markup.Measure.MeasureFaceFaceDistanceMarkup";
Ui(
  ra.className,
  ra.fromJson
);
class Bm extends Se {
  constructor(t, e) {
    super(t), this._moveSelectionAction = new fs(!0), this._currentHighlight = null, this._markup = null, this._measureManager = e;
  }
  _unsetCurrentHighlight() {
    this._currentHighlight !== null && (this._viewer.model.unsetNodeFaceColor(
      this._currentHighlight.getNodeId(),
      this._currentHighlight.getFaceEntity().getCadFaceIndex()
    ), this._currentHighlight = null);
  }
  async _performMoveSelection(t) {
    const e = this._viewer.view, i = this._viewer.model, s = await e.pickFromPoint(t, new Ie());
    if (s.overlayIndex() !== 0 || !s.isFaceSelection())
      return;
    const r = s.getNodeId(), o = s.getFaceEntity();
    if (i.getNodeType(r) === At.BodyInstance) {
      if (this._markup) {
        const a = this._markup.getFirstSelection();
        if (a !== null && r === a.getNodeId() && o.getCadFaceIndex() === a.getFaceEntity().getCadFaceIndex())
          return;
      }
      this._currentHighlight !== null ? s.equals(this._currentHighlight) ? s.getSelectionType() === pi.None && this._unsetCurrentHighlight() : (this._unsetCurrentHighlight(), await i.isFaceMeasurable(r, o.getCadFaceIndex()) && (this._currentHighlight = s, i.setNodeFaceColor(r, o.getCadFaceIndex(), it.yellow()))) : await i.isFaceMeasurable(r, o.getCadFaceIndex()) && (this._currentHighlight = s, i.setNodeFaceColor(r, o.getCadFaceIndex(), it.yellow()));
    }
  }
  async _performUpSelection(t) {
    const e = this._viewer.view, i = this._viewer.model, s = await e.pickFromPoint(t, new Ie());
    if (s.overlayIndex())
      return;
    if (this._markup && this._markup._getStage() > 1) {
      if (this._viewer.trigger("measurementBegin"), this._markup._nextStage(), this._markup._isFinalized()) {
        const h = this._markup;
        this._markup = null, this._measureManager.finalizeMeasurement(h);
      }
      return;
    }
    if (!s.isFaceSelection())
      return;
    const r = s.getNodeId(), o = s.getFaceEntity();
    if (!await i.isFaceMeasurable(r, o.getCadFaceIndex()) || !(i.getNodeType(r) === At.BodyInstance && (!this._markup || this._markup._getStage() <= 1)))
      return;
    const l = await i.getFaceProperty(r, o.getCadFaceIndex());
    if (!l)
      return;
    const c = i.getNodeNetMatrix(r);
    if (this._unsetCurrentHighlight(), l instanceof Re || l instanceof Ce) {
      const h = await i.getNodesBounding([r]);
      this._markup ? await this._markup.setSecondFace(t, s, l, c, h) : (this._markup = new ra(this._viewer), this._markup.setUnitMultiplier(i.getNodeUnitMultiplier(r)), this._markup.setFirstFace(s, l, c, h), this._measureManager.addMeasurement(this._markup));
    }
  }
  /** @hidden */
  onMouseMove(t) {
    super.onMouseMove(t);
    const e = t.getPosition();
    (!this._markup || this._markup._getStage() <= 1) && this._moveSelectionAction.set(() => this._performMoveSelection(e)), this._viewer.markupManager.refreshMarkup(), this._markup !== null && this._markup._getStage() > 0 && this._markup.adjust(e);
  }
  async _onMouseUpImpl(t) {
    if (!this.isActive())
      return;
    const e = this._primaryTouchId !== null && this._markup !== null && this._markup._getStage() > 1;
    if (!(this._dragCount < 3 || e))
      return;
    const i = t.getPosition();
    await this._performUpSelection(i);
  }
  /** @hidden */
  onMouseUp(t) {
    this._onMouseUpImpl(t), super.onMouseUp(t);
  }
  /** @hidden */
  setDraggingEnabled(t) {
    this._dragging = t;
  }
  /** @hidden */
  onKeyUp(t) {
  }
  /** @hidden */
  onKeyDown(t) {
    t.getKeyCode() === Ut.Escape && (this._markup !== null ? (this._markup.cleanup(), this._measureManager.removeMeasurement(this._markup), this._markup = null) : this._measureManager.removeLastMeasurement());
  }
  /** @hidden */
  setHandled() {
    return this._markup !== null && this._markup._getStage() > 1;
  }
  /** @hidden */
  onDeactivate() {
    super.onDeactivate(), this._unsetCurrentHighlight(), this._markup !== null && (this._measureManager.removeMeasurement(this._markup), this._markup.cleanup(), this._markup = null);
  }
}
const qc = class extends fi {
  constructor(n) {
    super(n), this._anchorLinePoint = null, this._firstLinePoint = null, this._secondLinePoint = null, this._selectionPosition = null, this._lineGeometryShape = new br(), this._viewer = n, this._name = "MeasureLineLineAngle", this._lineGeometryShape.setStrokeWidth(2), this._lineGeometryShape.setStrokeColor(this._viewer.measureManager.getMeasurementColor()), this._lineGeometryShape.setEndcapType(ii.Arrowhead), this._lineGeometryShape.setStartEndcapType(ii.Arrowhead), this._lineGeometryShape.setEndEndcapSize(5), this._lineGeometryShape.setStartEndcapSize(5), this._lineGeometryShape.setEndEndcapColor(this._viewer.measureManager.getMeasurementColor()), this._lineGeometryShape.setStartEndcapColor(this._viewer.measureManager.getMeasurementColor()), this._textShape.getBoxPortion().setFillOpacity(1), this._textShape.getBoxPortion().setFillColor(it.white());
  }
  addPoint(n) {
    if (this._finalized)
      return !1;
    if (this._anchorLinePoint === null)
      this._anchorLinePoint = n.copy(), this._stage = 1;
    else if (this._firstLinePoint === null) {
      if (n.equals(this._anchorLinePoint))
        return !1;
      this._firstLinePoint = n.copy(), this._stage = 2;
    } else {
      if (n.equals(this._anchorLinePoint) || n.equals(this._firstLinePoint))
        return !1;
      const t = d.subtract(this._firstLinePoint, this._anchorLinePoint), e = d.subtract(n, this._anchorLinePoint), i = Yn(t, e);
      if (i === 0 || i === 180)
        return !1;
      this._secondLinePoint = n.copy(), this.setMeasurementText(`${i.toFixed(2)}°`), this._measurementValue = i, this._finalized = !0, this._stage = 3;
    }
    return this.draw(), !0;
  }
  setSelectionPosition(n) {
    this._selectionPosition = n;
  }
  getLineGeometryShape() {
    return this._lineGeometryShape;
  }
  _drawPreviewLine(n, t) {
    const e = this._viewer.markupManager.getRenderer(), i = this._viewer.view, s = E.fromPoint3(i.projectPoint(n)), r = E.fromPoint3(i.projectPoint(t)), o = new Wi(s, r);
    e.drawLine(o);
  }
  _drawAngleMarkup(n, t, e) {
    const i = this._viewer.markupManager.getRenderer(), s = this._viewer.view, r = d.subtract(t, n), o = d.subtract(e, n), a = d.cross(r, o).normalize(), l = Yn(r, o);
    if (l !== 0 && l !== 180 && !isNaN(l)) {
      const y = yc(a, -l, n, o, 30);
      this._lineGeometryShape.clearPoints();
      for (const b of y)
        this._lineGeometryShape.pushPoint(E.fromPoint3(s.projectPoint(b)));
      i.drawPolyline(this._lineGeometryShape);
    }
    const c = o.length(), h = d.add(
      n,
      r.copy().normalize().scale(c)
    ), u = E.fromPoint3(s.projectPoint(n)), p = E.fromPoint3(s.projectPoint(h)), m = E.fromPoint3(s.projectPoint(e)), g = new Wi(u, p);
    i.drawLine(g);
    const _ = new Wi(u, m);
    i.drawLine(_), this._textShape.setPosition(p), this._finalized ? this._textShape.setTextString(this.getMeasurementText()) : isNaN(l) ? this._textShape.setTextString("0°") : this._textShape.setTextString(`${l.toFixed(2)}°`), i.drawTextBox(this._textShape);
  }
  draw() {
    if (!(!this._visibility || this._anchorLinePoint === null || this._viewer.view.projectPoint(this._anchorLinePoint).z <= 0)) {
      if (this._stage === 1) {
        if (this._selectionPosition === null)
          return;
        this._drawPreviewLine(this._anchorLinePoint, this._selectionPosition);
      } else if (this._stage === 2) {
        if (this._firstLinePoint === null || this._selectionPosition === null)
          return;
        this._drawAngleMarkup(this._anchorLinePoint, this._firstLinePoint, this._selectionPosition);
      } else if (this._stage === 3) {
        if (this._firstLinePoint == null || this._secondLinePoint == null)
          return;
        this._drawAngleMarkup(this._anchorLinePoint, this._firstLinePoint, this._secondLinePoint);
      }
    }
  }
  // serialization methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      name: this._name,
      anchorPoint: this._anchorLinePoint.copy(),
      firstPoint: this._firstLinePoint.copy(),
      secondPoint: this._secondLinePoint.copy(),
      measurementValue: this._measurementValue,
      measurementText: this.getMeasurementText(),
      className: this.getClassName()
    };
  }
  /**
   * Creates a new [[MeasurePointPointDistanceMarkup]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(n, t) {
    const e = n, i = new qc(t);
    return i._name = e.name, i._anchorLinePoint = d.fromJson(e.anchorPoint), i._firstLinePoint = d.fromJson(e.firstPoint), i._secondLinePoint = d.fromJson(e.secondPoint), i._measurementValue = e.measurementValue, i.setMeasurementText(e.measurementText), i._finalized = !0, i._stage = 3, i;
  }
  getClassName() {
    return qc.className;
  }
};
let oa = qc;
oa.className = "Communicator.Markup.Measure.MeasureLineLineAngleMarkup";
Ui(oa.className, oa.fromJson);
class Lh extends fi {
  constructor(t) {
    super(t), this._cursorSprite = new qn(), this._name = "CursorMarkup";
    const e = t.measureManager.getMeasurementColor();
    this._cursorSprite.setFillColor(e), this._cursorSprite.setStrokeColor(e), this._cursorSprite.setRadius(0), this._markupId = t.markupManager.registerMarkup(this);
  }
  draw() {
    this._viewer.markupManager.getRenderer().drawCircle(this._cursorSprite);
  }
  enable(t) {
    this._cursorSprite.setRadius(t ? 2.5 : 0);
  }
  isEnabled() {
    return this._cursorSprite.getRadius() > 0;
  }
  setPosition(t) {
    this._cursorSprite.setCenter(t);
  }
  destroy() {
    this._viewer.markupManager.unregisterMarkup(this._markupId);
  }
}
class Jm {
  constructor(t, e, i) {
    this.worldPosition = t, this.screenPosition = e, this.selectionItem = i;
  }
}
class Ta {
  constructor(t) {
    this._cursorMarkup = null, this._updateCursorSpriteAction = new fs(!0), this._viewer = t, this.snappingConfig = {
      enabled: !0,
      preferVertices: !0
    };
  }
  async getSelectionCursorPoints(t, e, i) {
    const s = new Ie(e ? Xt.All : Xt.Face);
    e && (s.enableProximityFaces = !0, s.restrictLinesAndPointsToSelectedFaceInstances = !1);
    const r = await this._viewer.view.pickFromPoint(t, s);
    if (r.overlayIndex() !== 0)
      return null;
    let o = r.getPosition(), a = t;
    if (this.snappingConfig.enabled) {
      const l = r.getLineEntity(), c = r.getPointEntity(), h = r.getFaceEntity();
      if (l || c || h) {
        let u = null;
        l !== null ? u = this._getLineSnapPoint(l, e, i) : c !== null ? u = c.getPosition() : h !== null && h.isProximityFace() && (u = h.getPosition()), u !== null && (o = u, a = cl(this._viewer, o));
      }
    }
    return new Jm(o, a, r);
  }
  updateCursorSprite(t, e, i) {
    this._updateCursorSpriteAction.set(() => this._updateCursorSpriteImpl(t, e, i));
  }
  async _updateCursorSpriteImpl(t, e, i) {
    if (this._cursorMarkup !== null)
      if (e) {
        const s = await this.getSelectionCursorPoints(
          t,
          e,
          i
        );
        s !== null ? (this._cursorMarkup.setPosition(s.screenPosition), this.activateCursorSprite(!0)) : this.activateCursorSprite(!1);
      } else
        this._cursorMarkup.setPosition(t);
  }
  draw() {
    this._cursorMarkup !== null && this._cursorMarkup.draw();
  }
  activateCursorSprite(t) {
    this._cursorMarkup !== null && this._cursorMarkup.enable(t);
  }
  /**
   * Finds the best point to use for the given lineEntity given the snapping behavior and settings.
   */
  _getLineSnapPoint(t, e, i) {
    const s = this.snappingConfig.preferVertices ? t.getBestVertex() : null;
    if (s !== null)
      return s;
    const r = t.getPosition();
    if (!e || i == null)
      return r;
    const o = t.getPoints(), a = 1e-10, l = (() => {
      for (let b = 0; b < o.length - 1; b++)
        if (og(o[b], o[b + 1], r, a))
          return b;
      return 0;
    })(), c = o[l], h = o[l + 1];
    if (c === void 0 || h === void 0)
      return r;
    const u = rg(c, h, i), p = cl(this._viewer, u), m = cl(this._viewer, r), g = E.subtract(
      p,
      m
    ).squaredLength(), _ = this._viewer.selectionManager.getPickTolerance(), y = _ * _;
    return g <= y ? u : r;
  }
  _clearCursorMarkup() {
    this._cursorMarkup !== null && (this._cursorMarkup.destroy(), this._cursorMarkup = null);
  }
  onOperatorActivate() {
    this._clearCursorMarkup(), this._cursorMarkup = new Lh(this._viewer), this._viewer.sheetManager.isDrawingSheetActive() && this._viewer.sheetManager.setBackgroundSelectionEnabled(!0);
  }
  onOperatorDeactivate() {
    this._clearCursorMarkup(), this._viewer.sheetManager.isDrawingSheetActive() && this._viewer.sheetManager.setBackgroundSelectionEnabled(!1);
  }
}
class jm extends Se {
  constructor(t, e) {
    super(t), this._markupItem = null, this._cameraInteractionActive = !1, this._measureManager = e, this._cursor = new Ta(this._viewer), this._viewer.setCallbacks({
      beginInteraction: () => {
        this._onBeginInteraction();
      },
      endInteraction: () => {
        this._onEndInteraction();
      }
    });
  }
  _onBeginInteraction() {
    this._cameraInteractionActive = !0, this._cursor.activateCursorSprite(!1);
  }
  _onEndInteraction() {
    this._cameraInteractionActive = !1;
  }
  /**
   * Determine if the given mouse event should cause snapping.
   * This is influenced by the snap configuration enabled value.
   */
  _useSnapping(t) {
    return this._cursor.snappingConfig.enabled && !t.altDown();
  }
  async _addPoint(t, e) {
    const i = await this._cursor.getSelectionCursorPoints(t, e, null);
    if (!(i === null || i.worldPosition === null) && (this._markupItem === null && (this._markupItem = new oa(this._viewer), this._measureManager.addMeasurement(this._markupItem), this._viewer.trigger("measurementBegin")), this._markupItem.addPoint(i.worldPosition), this._markupItem._isFinalized())) {
      const s = this._markupItem;
      this._markupItem = null, this._measureManager.finalizeMeasurement(s);
    }
  }
  async _updateMarkupSelectionPosition(t, e) {
    if (this._markupItem === null)
      return;
    const i = await this._cursor.getSelectionCursorPoints(t, e, null);
    i !== null && this._markupItem.setSelectionPosition(i.worldPosition);
  }
  async onMouseMove(t) {
    if (super.onMouseMove(t), this._cameraInteractionActive)
      return;
    const e = t.getPosition(), i = this._useSnapping(t);
    this._cursor.updateCursorSprite(e, i, null), await this._updateMarkupSelectionPosition(e, i), this._viewer.markupManager.refreshMarkup();
  }
  async onMouseUp(t) {
    if (!this.isActive())
      return;
    const e = t.getPosition();
    this._ptFirst.equals(e) && await this._addPoint(e, this._useSnapping(t)), super.onMouseUp(t);
  }
  onKeyDown(t) {
    t.getKeyCode() === Ut.Escape && this._clearMeasurement();
  }
  _clearMeasurement() {
    this._markupItem !== null ? (this._measureManager.removeMeasurement(this._markupItem), this._markupItem = null) : this._measureManager.removeLastMeasurement();
  }
  setHandled() {
    return this._markupItem !== null && this._markupItem._getStage() > 1;
  }
  onActivate() {
    this._cursor.onOperatorActivate();
  }
  onDeactivate() {
    this._cursor.onOperatorDeactivate(), this._markupItem !== null && (this._measureManager.removeMeasurement(this._markupItem), this._markupItem = null);
  }
}
const $c = class extends fi {
  constructor(n) {
    super(n), this._firstPointShape = new qn(), this._secondPointShape = new qn(), this._arrowsInvert = !1, this._name = "MeasurePointPointDistance", this._lineShapes = [];
    for (let t = 0; t < 6; t++)
      this._lineShapes.push(new Wi()), this._lineShapes[t].setStrokeColor(this._viewer.measureManager.getMeasurementColor()), this._lineShapes[t].setEndEndcapColor(this._viewer.measureManager.getMeasurementColor()), this._lineShapes[t].setStartEndcapColor(this._viewer.measureManager.getMeasurementColor());
    this._viewer = n, this.initCircle(this._firstPointShape), this.initCircle(this._secondPointShape), this._textShape = new eo(), this._textShape.getBoxPortion().setFillOpacity(1), this._textShape.getBoxPortion().setFillColor(new it(255, 255, 255));
  }
  initCircle(n) {
    n.setRadius(2.5), n.setFillColor(this._viewer.measureManager.getMeasurementColor());
  }
  setUnitMultiplier(n) {
    this._unitMultiplier = n;
  }
  setFirstPointPosition(n) {
    this._stage = 1, this._positions[0] = n.copy();
  }
  setSecondPointPosition(n) {
    this._stage = 2, this._positions[1] = n.copy(), this._positions[2] = n.copy(), this._setMeasurementValue(d.subtract(this._positions[1], this._positions[0]).length());
  }
  _getStage() {
    return this._stage;
  }
  finalize() {
    this._stage++;
  }
  getFirstPointPosition() {
    return this._positions[0];
  }
  getSecondPointPosition() {
    return this._positions[1];
  }
  adjust(n) {
    super.adjust(n);
    const t = this._viewer.view.raycastFromPoint(n);
    if (t === null)
      return;
    const e = this._positions[0], i = this._positions[1];
    let s = new d(1, 0, 0);
    i.equals(e) || (s = d.subtract(i, e));
    const o = this._viewer.view.getCamera().getUp(), a = d.cross(t.direction, o).normalize(), l = new d(
      (e.x + i.x) / 2,
      (e.y + i.y) / 2,
      (e.z + i.z) / 2
    ), c = new d(l.x + o.x, l.y + o.y, l.z + o.z), h = new d(
      l.x + a.x,
      l.y + a.y,
      l.z + a.z
    ), u = new d(
      t.origin.x + t.direction.x * 1e6,
      t.origin.y + t.direction.y * 1e6,
      t.origin.z + t.direction.z * 1e6
    );
    let p = new d(0, 0, 0);
    Ts(
      t.origin,
      u,
      l,
      c,
      h,
      p
    ), this._positions[2].assign(p);
    let m = new d(0, 0, 0);
    Math.abs(s.x) <= Math.abs(s.y) && Math.abs(s.x) <= Math.abs(s.z) ? m = new d(1, 0, 0) : Math.abs(s.y) <= Math.abs(s.x) && Math.abs(s.y) <= Math.abs(s.z) ? m = new d(0, 1, 0) : m = new d(0, 0, 1);
    const g = d.cross(m, s), _ = d.cross(g, s);
    g.set(
      e.x + g.x,
      e.y + g.y,
      e.z + g.z
    ), _.set(
      e.x + _.x,
      e.y + _.y,
      e.z + _.z
    );
    const y = new d(
      p.x + s.x * 1e4,
      p.y + s.y * 1e4,
      p.z + s.z * 1e4
    ), b = new d(
      p.x - s.x * 1e4,
      p.y - s.y * 1e4,
      p.z - s.z * 1e4
    ), w = Ts(
      y,
      b,
      e,
      g,
      _,
      p
    ), v = !isNaN(p.x) && !isNaN(p.y) && !isNaN(p.z);
    (!w || !v) && (p = i.copy());
    const C = d.subtract(p, e);
    this._positions[3] = new d(
      e.x + C.x,
      e.y + C.y,
      e.z + C.z
    ), this._positions[4] = new d(
      i.x + C.x,
      i.y + C.y,
      i.z + C.z
    ), this._updateArrowsInverted(), this._viewer.markupManager.refreshMarkup();
  }
  _updateArrowsInverted() {
    const n = new d(
      (this._positions[3].x + this._positions[4].x) / 2,
      (this._positions[3].y + this._positions[4].y) / 2,
      (this._positions[3].z + this._positions[4].z) / 2
    ), t = d.subtract(this._positions[4], this._positions[3]);
    d.subtract(this._positions[2], n).length() * 2 > t.length() ? this._arrowsInvert = !0 : this._arrowsInvert = !1;
  }
  update() {
    super.update();
    const n = this._viewer.view, t = new Array(6);
    if (this._stage > 0) {
      this._behindView = !1;
      for (let e = 0; e < this._positions.length; e++)
        n.projectPoint(this._positions[e]).z <= 0 && (this._behindView = !0), t[e] = E.fromPoint3(n.projectPoint(this._positions[e]));
      this._firstPointShape.setCenter(t[0]);
    }
    this._stage > 1 && (this._textShape && this._textShape.setPosition(t[2]), this._secondPointShape.setCenter(t[1]), this._lineShapes[0].set(t[0], t[1]), this._lineShapes[1].set(t[3], t[4]), this._lineShapes[2].set(t[0], t[3]), this._lineShapes[3].set(t[1], t[4]), this._lineShapes[4].set(t[3], t[2]), this._lineShapes[5].set(t[3], t[4]), this._lineShapes[5].setEndcapType(ii.Arrowhead), this._lineShapes[5].setStartEndcapType(ii.Arrowhead), this._lineShapes[5].setEndcapsInverted(this._arrowsInvert));
  }
  draw() {
    if (this._visibility && this._viewer.explodeManager.getMagnitude() === 0 && (this.update(), !this._behindView)) {
      const n = this._viewer.markupManager.getRenderer();
      switch (this._stage) {
        case 1:
          n.drawCircle(this._firstPointShape);
          break;
        case 2:
        case 3:
          n.drawCircle(this._firstPointShape), n.drawCircle(this._secondPointShape);
          for (const t of this._lineShapes)
            n.drawLine(t);
          n.drawTextBox(this._textShape);
          break;
      }
    }
  }
  // serialization methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      name: this._name,
      measurePoint1: this._positions[0].copy(),
      measurePoint2: this._positions[1].copy(),
      leaderPoint1: this._positions[3].copy(),
      leaderPoint2: this._positions[4].copy(),
      textPoint: this._positions[2].copy(),
      text: this._textShape.getTextString(),
      measurementValue: this._measurementValue,
      unitMultiplier: this._unitMultiplier,
      className: this.getClassName()
    };
  }
  /**
   * Creates a new [[MeasurePointPointDistanceMarkup]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(n, t) {
    const e = n, i = new $c(t);
    return i._name = e.name, i._positions[0] = d.fromJson(e.measurePoint1), i._positions[1] = d.fromJson(e.measurePoint2), i._positions[2] = d.fromJson(e.textPoint), i._textShape.setTextString(e.text), i._positions[3] = d.fromJson(e.leaderPoint1), i._positions[4] = d.fromJson(e.leaderPoint2), i._measurementValue = e.measurementValue, i._unitMultiplier = e.unitMultiplier || 1, i._updateArrowsInverted(), i._stage = 2, i;
  }
  getClassName() {
    return $c.className;
  }
  /**
   * Returns whether the measurement markup is valid.
   */
  isMarkupValid() {
    return this._positions.length >= 5;
  }
};
let aa = $c;
aa.className = "Communicator.Markup.Measure.MeasurePointPointDistanceMarkup";
Ui(
  aa.className,
  aa.fromJson
);
class Hm extends Se {
  /** @hidden */
  constructor(t, e) {
    super(t), this._measureMarkup = null, this._cameraInteractionActive = !1, this._viewer = t, this._measureManager = e, this._cursor = new Ta(this._viewer), this._viewer.setCallbacks({
      beginInteraction: () => {
        this._onBeginInteraction();
      },
      endInteraction: () => {
        this._onEndInteraction();
      }
    });
  }
  _onBeginInteraction() {
    this._cameraInteractionActive = !0, this._cursor.activateCursorSprite(!1);
  }
  _onEndInteraction() {
    this._cameraInteractionActive = !1;
  }
  _getStage() {
    return this._measureMarkup === null ? tn.NoPointsSelected : this._measureMarkup._getStage();
  }
  _draw() {
    let t = !1;
    this._getStage() < tn.TwoPointsSelected && (this._cursor.draw(), t = !0), this._measureMarkup !== null && (this._measureMarkup.draw(), t = !0), t && this._viewer.markupManager.refreshMarkup();
  }
  async _finalizeMeasurement(t, e) {
    const i = this._measureMarkup;
    if (i === null) {
      console.assert(!1);
      return;
    }
    const s = new Ie(e ? Xt.All : Xt.Face);
    (await this._viewer.view.pickFromPoint(t, s)).overlayIndex() || (i.finalize(), this._measureMarkup = null, this._measureManager.finalizeMeasurement(i));
  }
  // Gets the first picked position or null if one is not selected.  This is used as a hint when updating the cursor for snapping.
  _getFirstPickPosition() {
    let t = null;
    return this._measureMarkup !== null && this._getStage() >= tn.OnePointSelected && (t = this._measureMarkup.getFirstPointPosition()), t;
  }
  async _updateMeasurementPoints(t, e) {
    const i = this._getStage();
    console.assert(i < tn.TwoPointsSelected), this._viewer.trigger("measurementBegin");
    const s = this._getFirstPickPosition(), r = await this._cursor.getSelectionCursorPoints(
      t,
      e,
      s
    );
    if (r === null || r.worldPosition === null) {
      this._cursor.activateCursorSprite(!1);
      return;
    }
    this._cursor.activateCursorSprite(!0), this._measureMarkup === null && (this._measureMarkup = new aa(this._viewer), this._measureManager.addMeasurement(this._measureMarkup));
    const o = r.worldPosition.copy();
    if (this._viewer.sheetManager.isDrawingSheetActive() && (o.z = 0), i === tn.NoPointsSelected)
      this._measureMarkup.setFirstPointPosition(o), this._measureMarkup.setUnitMultiplier(
        r.selectionItem.isNodeSelection() ? this._viewer.model.getNodeUnitMultiplier(r.selectionItem.getNodeId()) : 1
      );
    else if (i === tn.OnePointSelected) {
      const a = this._getFirstPickPosition();
      r.worldPosition.equalsWithTolerance(a, 1e-7) || (this._measureMarkup.setSecondPointPosition(o), this._measureMarkup.adjust(r.screenPosition));
    }
  }
  /**
   * Determine if the given mouse event should cause snapping. This is influenced by
   * the snap configuration enabled value.
   */
  _useSnapping(t) {
    return this._cursor.snappingConfig.enabled && !t.altDown();
  }
  /** @hidden */
  onMouseMove(t) {
    super.onMouseMove(t);
    const e = this._getStage();
    if (e < tn.TwoPointsSelected) {
      if (!this._cameraInteractionActive) {
        const i = t.getPosition(), s = this._getFirstPickPosition();
        this._cursor.updateCursorSprite(
          i,
          this._useSnapping(t),
          s
        );
      }
    } else
      e === tn.TwoPointsSelected && (this._measureMarkup.adjust(t.getPosition()), t.setHandled(!0));
    this._draw();
  }
  /** @hidden */
  async onMouseUp(t) {
    if (this.isActive()) {
      const e = this._getStage(), i = this._primaryTouchId !== null && this._measureMarkup !== null && e > tn.OnePointSelected;
      if (this._dragCount < 3 || i) {
        const s = this._useSnapping(t), r = t.getPosition();
        e <= tn.OnePointSelected ? await this._updateMeasurementPoints(r, s) : await this._finalizeMeasurement(r, s);
      }
    }
    super.onMouseUp(t);
  }
  /** @hidden */
  onKeyUp(t) {
  }
  _clearMeasurement() {
    this._measureMarkup !== null ? (this._measureManager.removeMeasurement(this._measureMarkup), this._measureMarkup = null) : this._measureManager.removeLastMeasurement();
  }
  /** @hidden */
  onKeyDown(t) {
    t.getKeyCode() === Ut.Escape && this._clearMeasurement();
  }
  /** @hidden */
  setHandled() {
    return this._getStage() > tn.OnePointSelected;
  }
  /** @hidden */
  onActivate() {
    this._cursor.onOperatorActivate();
  }
  /** @hidden */
  onDeactivate() {
    this._cursor.onOperatorDeactivate(), this._measureMarkup !== null && (this._measureManager.removeMeasurement(this._measureMarkup), this._measureMarkup = null);
  }
}
const th = class extends fi {
  constructor(n) {
    super(n), this._initialPoint = new qn(), this._leaderLine = new Wi(), this._endpoints = new Mh(), this._textboxCorners = [
      E.zero(),
      E.zero(),
      E.zero(),
      E.zero()
    ], this._polygon = new vm(), this._plane = null, this.textPosition = d.zero(), this.leaderPosition = d.zero(), this.pointRadius = 2.5, this._viewer = n;
    const t = this._viewer.measureManager.getMeasurementColor();
    this._initialPoint.setFillColor(t), this._initialPoint.setStrokeColor(t), this._leaderLine.setStrokeColor(t), this._endpoints.setFillColor(t), this._endpoints.setStrokeColor(t), this._endpoints.setFillOpacity(1), this._textShape.getBoxPortion().setFillOpacity(1), this._textShape.getBoxPortion().setFillColor(it.white()), this._polygon.setFillColor(t), this._polygon.setFillOpacity(0.4);
  }
  _calculateArea() {
    const n = this._positions.length;
    if (n < 3)
      return 0;
    const t = new Float32Array(n * 3);
    for (let l = 0; l < n; l++) {
      const c = this._positions[l];
      t[3 * l] = c.x, t[3 * l + 1] = c.y, t[3 * l + 2] = c.z;
    }
    const e = d.subtract(this._positions[1], this._positions[0]), i = d.subtract(this._positions[2], this._positions[0]), s = d.cross(e, i), r = this._viewer.model.triangulatePolygon(t, s);
    let o = 0;
    const a = r.length / 3 / 3;
    for (let l = 0; l < a; l++) {
      const c = l * 3 * 3, h = [];
      for (let _ = 0; _ < 3; _++) {
        const y = r[c + _ * 3], b = r[c + _ * 3 + 1], w = r[c + _ * 3 + 2];
        h[_] = new d(y, b, w);
      }
      const u = d.subtract(h[1], h[0]).length(), p = d.subtract(h[2], h[0]).length(), m = d.subtract(h[2], h[1]).length(), g = 0.25 * Math.sqrt(
        (u + p + m) * (-u + p + m) * (u - p + m) * (u + p - m)
      );
      o += g;
    }
    return o;
  }
  /**
   * Adds a point to the point list and updates the calculated polygon area.
   * Only points that are coplanar will be added.
   * Returns a bool representing if the point was accepted or not
   */
  addPoint(n) {
    if (this._positions.length >= 3 && (this._plane === null && (this._plane = je.createFromPoints(
      this._positions[0],
      this._positions[1],
      this._positions[2]
    )), Math.abs(this._plane.distanceToPoint(n)) > 1e-4))
      return !1;
    this._positions.length === 2 && (this._plane = je.createFromPoints(this._positions[0], this._positions[1], n)), this._positions.push(n.copy());
    const t = this._calculateArea(), e = this.getUnitMultiplier(), i = `${Eo(t, e)}²`;
    return this._setMeasurementValue(t), this.setMeasurementText(i), !0;
  }
  getPoints() {
    return this._positions;
  }
  getLast() {
    return this._positions.length === 0 ? null : this._positions[this._positions.length - 1].copy();
  }
  // finalizes the measurement
  finalize() {
    if (this._positions.length > 2) {
      const n = this._calculateArea(), t = this.getUnitMultiplier(), e = `${Eo(n, t)}²`;
      this._setMeasurementValue(n), this.setMeasurementText(e);
    }
    this._finalized = !0;
  }
  setUnitMultiplier(n) {
    this._unitMultiplier = n;
  }
  isValid() {
    return this._positions.length > 2;
  }
  getMeasurementText() {
    return this._textShape.getTextString();
  }
  /** Calculates the screen position for each point in the polygon */
  _updateProjectedPoints() {
    const n = [];
    this._behindView = !1;
    for (const t of this._positions) {
      const e = this._viewer.view.projectPoint(t);
      e.z <= 0 && (this._behindView = !0), n.push(E.fromPoint3(e));
    }
    return n;
  }
  _updateTextBoxCorners() {
    const n = this._viewer.markupManager.getRenderer().measureTextBox(this._textShape), t = this._textShape.getPosition();
    this._textboxCorners[0].assign(t), this._textboxCorners[1].set(t.x + n.x, t.y), this._textboxCorners[2].set(t.x + n.x, t.y + n.y), this._textboxCorners[3].set(t.x, t.y + n.y);
  }
  /** Finds and returns the closest corner of the text box.  Used as the endpoint of the leader line. */
  _calculateLeaderEndpoint(n) {
    this._updateTextBoxCorners();
    const t = E.zero();
    let e = Number.MAX_VALUE;
    for (const i of this._textboxCorners) {
      const s = E.distance(n, i);
      s < e && (t.assign(i), e = s);
    }
    return t;
  }
  draw() {
    if (!this._visibility)
      return;
    const n = this._updateProjectedPoints();
    if (this._behindView || n.length === 0)
      return;
    const t = this._viewer.markupManager.getRenderer();
    if (n.length === 1)
      this._initialPoint.set(n[0], this.pointRadius), t.drawCircle(this._initialPoint);
    else {
      this._polygon.clearPoints();
      for (const r of n)
        this._polygon.pushPoint(r);
      this._finalized && this._polygon.pushPoint(n[0]);
      const e = E.fromPoint3(this._viewer.view.projectPoint(this.textPosition));
      this._textShape.setPosition(e), t.drawPolygon(this._polygon);
      const i = E.fromPoint3(this._viewer.view.projectPoint(this.leaderPosition)), s = this._calculateLeaderEndpoint(i);
      this._leaderLine.setP1(i), this._leaderLine.setP2(s), t.drawLine(this._leaderLine), t.drawTextBox(this._textShape), this._endpoints.clear(), this._endpoints.addCircle(n[0], this.pointRadius), this._endpoints.addCircle(n[n.length - 1], this.pointRadius), t.drawCircles(this._endpoints);
    }
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    const n = [];
    for (const t of this._positions)
      n.push(t.toJson());
    return {
      name: this._name,
      points: n,
      textPoint: this.textPosition.toJson(),
      leaderPoint: this.leaderPosition.toJson(),
      measurementValue: this._measurementValue,
      unitMultiplier: this._unitMultiplier,
      text: this._textShape.getTextString(),
      className: this.getClassName()
    };
  }
  /**
   * Creates a new [[MeasurePolygonAreaMarkup]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(n, t) {
    const e = n, i = new th(t);
    return i._name = e.name, i._positions = fi._constructPointArray(e.points), i.textPosition = d.fromJson(e.textPoint), i.leaderPosition = d.fromJson(e.leaderPoint), i._measurementValue = e.measurementValue, i._unitMultiplier = e.unitMultiplier || 1, i._textShape.setTextString(e.text), i._finalized = !0, i;
  }
  /** This measurement only allows clicking on the text box portion of the markup. */
  hit(n) {
    const t = this._viewer.markupManager.getRenderer().measureTextBox(this._textShape), e = this._textShape.getPosition();
    return !(n.x < e.x || n.x > e.x + t.x || n.y < e.y || n.y > e.y + t.y);
  }
  getClassName() {
    return th.className;
  }
};
let la = th;
la.className = "Communicator.Markup.Measure.MeasurePolygonAreaMarkup";
Ui(la.className, la.fromJson);
class Um extends Se {
  /** @hidden */
  constructor(t, e) {
    super(t), this._markupItem = null, this._cameraInteractionActive = !1, this._textShapeOffset = new E(10, -25), this._anchor = Tr.Last, this._dragPlane = null, this._measureManager = e, this._cursor = new Ta(this._viewer), this._viewer.setCallbacks({
      beginInteraction: () => {
        this._onBeginInteraction();
      },
      endInteraction: () => {
        this._onEndInteraction();
      }
    });
  }
  /** @hidden */
  getMarkupItem() {
    return this._markupItem;
  }
  /** Sets the anchor type that will be set for markups created by this operator. */
  setAnchor(t) {
    this._anchor = t;
  }
  /**
   * Determine if the given mouse event should cause snapping. This is influenced by
   * the snap configuration enabled value.
   */
  _useSnapping(t) {
    return this._cursor.snappingConfig.enabled && !t.altDown();
  }
  _getLastSelectedPoint() {
    return this._markupItem ? this._markupItem.getLast() : null;
  }
  _createNewMarkupItem(t) {
    this._markupItem = new la(this._viewer), this._markupItem.setUnitMultiplier(
      t.selectionItem.isNodeSelection() ? this._viewer.model.getNodeUnitMultiplier(t.selectionItem.getNodeId()) : 1
    ), this._markupItem.setName("MeasurePolygonAreaMarkup"), this._measureManager.addMeasurement(this._markupItem), this._markupItem.addPoint(t.worldPosition);
  }
  _updateMarkupItem(t, e) {
    if (this._markupItem === null || e.worldPosition == null)
      return;
    const i = this._markupItem.getPoints(), s = E.fromPoint3(this._viewer.view.projectPoint(i[0]));
    E.distance(s, t) < this._markupItem.pointRadius ? i.length > 2 && this._finalizeMeasurement() : this._markupItem.addPoint(e.worldPosition) && this._updateAnchor(t, e.worldPosition);
  }
  // Updates the cursor display and the measurement markup item based on a pointer position.
  async _updateMeasurementItem(t, e) {
    const i = this._getLastSelectedPoint(), s = await this._cursor.getSelectionCursorPoints(
      t,
      e,
      i
    );
    if (s === null || s.worldPosition === null) {
      this._cursor.activateCursorSprite(!1);
      return;
    } else
      this._cursor.activateCursorSprite(!0);
    this._markupItem === null ? this._createNewMarkupItem(s) : this._updateMarkupItem(t, s);
  }
  _isDraggingText() {
    return this._dragPlane !== null;
  }
  /** @hidden */
  onMouseDown(t) {
    if (super.onMouseDown(t), this._markupItem)
      return;
    const e = t.getPosition();
    this._pickExisting(e) && (this._dragPlane = this._calculateSelectionPlane(this._markupItem.leaderPosition), t.setHandled(!0));
  }
  /** @hidden */
  onMouseMove(t) {
    if (super.onMouseMove(t), this._isDraggingText())
      this._dragMarkupText(t), t.setHandled(!0);
    else if (!this._cameraInteractionActive) {
      const e = this._getLastSelectedPoint();
      this._cursor.updateCursorSprite(
        t.getPosition(),
        this._useSnapping(t),
        e
      ), this._draw();
    }
  }
  /** @hidden */
  async onMouseUp(t) {
    if (!this.isActive())
      return;
    const e = t.getPosition();
    if (this._isDraggingText())
      this._markupItem = null, this._dragPlane = null;
    else if (this._ptFirst.equals(e)) {
      const i = this._useSnapping(t), s = e;
      await this._updateMeasurementItem(s, i);
    }
    super.onMouseUp(t);
  }
  /** @hidden */
  onDoubleClick(t) {
    this._finalizeMeasurement();
  }
  _dragMarkupText(t) {
    if (this._markupItem === null || this._dragPlane === null)
      return;
    const e = this._viewer.view.raycastFromPoint(t.getPosition());
    this._dragPlane.intersectsRay(e, this._markupItem.textPosition), this._draw();
  }
  _finalizeMeasurement() {
    if (this._markupItem)
      if (this._markupItem.isValid()) {
        const t = this._markupItem;
        this._markupItem = null, t.finalize(), this._measureManager.finalizeMeasurement(t);
      } else
        this._clearMeasurement();
  }
  _updateAnchor(t, e) {
    if (!this._markupItem)
      return;
    const i = this._markupItem.getPoints();
    if (i.length !== 1)
      switch (this._anchor) {
        case Tr.Last:
          this._calculateAnchorPos(t, e);
          break;
        case Tr.First: {
          if (i.length !== 2)
            return;
          const s = this._viewer.view.projectPoint(i[0]);
          this._calculateAnchorPos(E.fromPoint3(s), i[0]);
          break;
        }
        case Tr.Midpoint: {
          let s;
          const r = this._markupItem.getMeasurementValue() / 2;
          let o = 0;
          for (let l = 1; l < i.length; l++) {
            const c = d.subtract(i[l], i[l - 1]), h = c.length(), u = o + h;
            if (u > r) {
              const m = (r - o) / h;
              c.scale(m), s = d.add(i[l - 1], c);
              break;
            }
            o = u;
          }
          const a = this._viewer.view.projectPoint(s);
          this._calculateAnchorPos(E.fromPoint3(a), s);
          break;
        }
      }
  }
  _calculateSelectionPlane(t) {
    const e = this._viewer.view.getCamera(), i = d.subtract(e.getPosition(), t);
    return i.normalize(), je.createFromPointAndNormal(t, i);
  }
  _calculateAnchorPos(t, e) {
    const i = this._viewer.view.getCamera();
    d.subtract(i.getPosition(), e).normalize();
    const r = this._calculateSelectionPlane(e), o = this._viewer.view.raycastFromPoint(
      E.add(t, this._textShapeOffset)
    );
    o && (r.intersectsRay(o, this._markupItem.textPosition), this._markupItem.leaderPosition.assign(e));
  }
  // Cancels the currently measurement being created or removes the last created measurement
  _clearMeasurement() {
    this._markupItem !== null ? (this._measureManager.removeMeasurement(this._markupItem), this._markupItem = null) : this._measureManager.removeLastMeasurement();
  }
  _draw() {
    this._viewer.markupManager.refreshMarkup();
  }
  _pickExisting(t) {
    const e = this._viewer.markupManager.pickMarkupItem(t);
    return e && e.getClassName() === "Communicator.MeasurePolygonAreaMarkup" ? (this._markupItem = e, !0) : !1;
  }
  /** @hidden */
  onActivate() {
    this._cursor.onOperatorActivate();
  }
  /** @hidden */
  onDeactivate() {
    this._cursor.onOperatorDeactivate();
  }
  /** @hidden */
  onKeyDown(t) {
    t.getKeyCode() === Ut.Escape && this._clearMeasurement();
  }
  _onBeginInteraction() {
    this._cameraInteractionActive = !0, this._cursor.activateCursorSprite(!1);
  }
  _onEndInteraction() {
    this._cameraInteractionActive = !1;
  }
}
const eh = class extends fi {
  constructor(n) {
    super(n), this._polyline = new br(), this._initialPoint = new qn(), this._leaderLine = new Wi(), this._endpoints = new Mh(), this._textboxCorners = [
      E.zero(),
      E.zero(),
      E.zero(),
      E.zero()
    ], this.textPosition = d.zero(), this.leaderPosition = d.zero(), this.isLoop = !1, this.pointRadius = 2.5, this._viewer = n;
    const t = this._viewer.measureManager.getMeasurementColor();
    this._initialPoint.setFillColor(t), this._initialPoint.setStrokeColor(t), this._polyline.setStrokeColor(t), this._polyline.setStrokeWidth(2), this._leaderLine.setStrokeColor(t), this._endpoints.setFillColor(t), this._endpoints.setStrokeColor(t), this._endpoints.setFillOpacity(1), this._textShape.getBoxPortion().setFillOpacity(1), this._textShape.getBoxPortion().setFillColor(it.white());
  }
  /** Adds a point to the pointlist and updates the calculated polyline distance */
  addPoint(n) {
    if (this._positions.push(n.copy()), this._positions.length > 1) {
      const t = d.subtract(
        this._positions[this._positions.length - 1],
        this._positions[this._positions.length - 2]
      ).length();
      this._setMeasurementValue(this._measurementValue + t);
    }
  }
  getPoints() {
    return this._positions;
  }
  getlast() {
    return this._positions.length === 0 ? null : this._positions[this._positions.length - 1].copy();
  }
  // finalizes the measurement and sets the final distance if the polyline is a loop
  finalize() {
    if (this.isLoop && this._positions.length > 2) {
      const n = d.subtract(
        this._positions[this._positions.length - 1],
        this._positions[0]
      ).length();
      this._setMeasurementValue(this._measurementValue + n);
    }
    this._finalized = !0;
  }
  setUnitMultiplier(n) {
    this._unitMultiplier = n;
  }
  isValid() {
    return this._positions.length > 1;
  }
  getMeasurementText() {
    return this._textShape.getTextString();
  }
  /** Calculates the screen position for each point in the polyline */
  _updateProjectedPoints() {
    const n = [];
    this._behindView = !1, this._behindView = !1;
    for (const t of this._positions) {
      const e = this._viewer.view.projectPoint(t);
      e.z <= 0 && (this._behindView = !0), n.push(E.fromPoint3(e));
    }
    return n;
  }
  _updateTextBoxCorners() {
    const n = this._viewer.markupManager.getRenderer().measureTextBox(this._textShape), t = this._textShape.getPosition();
    this._textboxCorners[0].assign(t), this._textboxCorners[1].set(t.x + n.x, t.y), this._textboxCorners[2].set(t.x + n.x, t.y + n.y), this._textboxCorners[3].set(t.x, t.y + n.y);
  }
  /** Finds and returns the closest corner of the text box.  Used as the endpoint of the leader line. */
  _calculateLeaderEndpoint(n) {
    this._updateTextBoxCorners();
    const t = E.zero();
    let e = Number.MAX_VALUE;
    for (const i of this._textboxCorners) {
      const s = E.distance(n, i);
      s < e && (t.assign(i), e = s);
    }
    return t;
  }
  draw() {
    if (!this._visibility)
      return;
    const n = this._updateProjectedPoints();
    if (this._behindView || n.length === 0)
      return;
    const t = this._viewer.markupManager.getRenderer();
    if (n.length === 1)
      this._initialPoint.set(n[0], this.pointRadius), t.drawCircle(this._initialPoint);
    else {
      this._polyline.clearPoints();
      for (const r of n)
        this._polyline.pushPoint(r);
      this._finalized && this.isLoop && this._polyline.pushPoint(n[0]);
      const e = E.fromPoint3(this._viewer.view.projectPoint(this.textPosition));
      this._textShape.setPosition(e), t.drawPolyline(this._polyline);
      const i = E.fromPoint3(this._viewer.view.projectPoint(this.leaderPosition)), s = this._calculateLeaderEndpoint(i);
      this._leaderLine.setP1(i), this._leaderLine.setP2(s), t.drawLine(this._leaderLine), t.drawTextBox(this._textShape), this._endpoints.clear(), this.isLoop || (this._endpoints.addCircle(n[0], this.pointRadius), this._endpoints.addCircle(n[n.length - 1], this.pointRadius), t.drawCircles(this._endpoints));
    }
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    const n = [];
    for (const t of this._positions)
      n.push(t.toJson());
    return {
      name: this._name,
      points: n,
      textPoint: this.textPosition.toJson(),
      leaderPoint: this.leaderPosition.toJson(),
      measurementValue: this._measurementValue,
      unitMultiplier: this._unitMultiplier,
      isLoop: this.isLoop,
      text: this._textShape.getTextString(),
      className: this.getClassName()
    };
  }
  /**
   * Creates a new [[MeasurePolylineDistanceMarkup]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(n, t) {
    const e = n, i = new eh(t);
    return i._name = e.name, i._positions = fi._constructPointArray(e.points), i.textPosition = d.fromJson(e.textPoint), i.leaderPosition = d.fromJson(e.leaderPoint), i.isLoop = e.isLoop, i._measurementValue = e.measurementValue, i._unitMultiplier = e.unitMultiplier || 1, i._textShape.setTextString(e.text), i._finalized = !0, i;
  }
  /** This measurement only allows clicking on the text box portion of the markup. */
  hit(n) {
    const t = this._viewer.markupManager.getRenderer().measureTextBox(this._textShape), e = this._textShape.getPosition();
    return !(n.x < e.x || n.x > e.x + t.x || n.y < e.y || n.y > e.y + t.y);
  }
  getClassName() {
    return eh.className;
  }
};
let ca = eh;
ca.className = "Communicator.Markup.Measure.MeasurePolylineDistanceMarkup";
Ui(
  ca.className,
  ca.fromJson
);
class Qm extends Se {
  /** @hidden */
  constructor(t, e) {
    super(t), this._markupItem = null, this._cameraInteractionActive = !1, this._textShapeOffset = new E(10, -25), this._anchor = Er.Last, this._dragPlane = null, this._measureManager = e, this._cursor = new Ta(this._viewer), this._viewer.setCallbacks({
      beginInteraction: () => {
        this._onBeginInteraction();
      },
      endInteraction: () => {
        this._onEndInteraction();
      }
    });
  }
  /** @hidden */
  getMarkupItem() {
    return this._markupItem;
  }
  /** Sets the anchor type that will be set for markups created by this operator. */
  setAnchor(t) {
    this._anchor = t;
  }
  /**
   * Determine if the given mouse event should cause snapping. This is influenced by
   * the snap configuration enabled value.
   */
  _useSnapping(t) {
    return this._cursor.snappingConfig.enabled && !t.altDown();
  }
  _getLastSelectedPoint() {
    return this._markupItem ? this._markupItem.getlast() : null;
  }
  _createNewMarkupItem(t) {
    this._markupItem = new ca(this._viewer), this._markupItem.setUnitMultiplier(
      t.selectionItem.isNodeSelection() ? this._viewer.model.getNodeUnitMultiplier(t.selectionItem.getNodeId()) : 1
    ), this._markupItem.setName("MeasurePolylineDistanceMarkup"), this._measureManager.addMeasurement(this._markupItem), this._markupItem.addPoint(t.worldPosition);
  }
  _updateMarkupItem(t, e) {
    if (this._markupItem === null || e.worldPosition == null)
      return;
    const i = this._markupItem.getPoints(), s = E.fromPoint3(this._viewer.view.projectPoint(i[0]));
    E.distance(s, t) < this._markupItem.pointRadius ? i.length > 2 && (this._markupItem.isLoop = !0, this._finalizeMeasurement()) : (this._markupItem.addPoint(e.worldPosition), this._updateAnchor(t, e.worldPosition));
  }
  // Updates the cursor display and the measurement markup item based on a pointer position.
  async _updateMeasurementItem(t, e) {
    const i = this._getLastSelectedPoint(), s = await this._cursor.getSelectionCursorPoints(
      t,
      e,
      i
    );
    if (s === null || s.worldPosition === null) {
      this._cursor.activateCursorSprite(!1);
      return;
    } else
      this._cursor.activateCursorSprite(!0);
    this._markupItem === null ? this._createNewMarkupItem(s) : this._updateMarkupItem(t, s);
  }
  _isDraggingText() {
    return this._dragPlane !== null;
  }
  /** @hidden */
  onMouseDown(t) {
    if (super.onMouseDown(t), this._markupItem)
      return;
    const e = t.getPosition();
    this._pickExisting(e) && (this._dragPlane = this._calculateSelectionPlane(this._markupItem.leaderPosition), t.setHandled(!0));
  }
  /** @hidden */
  onMouseMove(t) {
    if (super.onMouseMove(t), this._isDraggingText())
      this._dragMarkupText(t), t.setHandled(!0);
    else if (!this._cameraInteractionActive) {
      const e = this._getLastSelectedPoint();
      this._cursor.updateCursorSprite(
        t.getPosition(),
        this._useSnapping(t),
        e
      ), this._draw();
    }
  }
  /** @hidden */
  async onMouseUp(t) {
    if (!this.isActive())
      return;
    const e = t.getPosition();
    if (this._isDraggingText())
      this._markupItem = null, this._dragPlane = null;
    else if (this._ptFirst.equals(e)) {
      const i = this._useSnapping(t), s = e;
      await this._updateMeasurementItem(s, i);
    }
    super.onMouseUp(t);
  }
  /** @hidden */
  onDoubleClick(t) {
    this._finalizeMeasurement();
  }
  _dragMarkupText(t) {
    if (this._markupItem === null || this._dragPlane === null)
      return;
    const e = this._viewer.view.raycastFromPoint(t.getPosition());
    this._dragPlane.intersectsRay(e, this._markupItem.textPosition), this._draw();
  }
  _finalizeMeasurement() {
    if (this._markupItem)
      if (this._markupItem.isValid()) {
        const t = this._markupItem;
        this._markupItem = null, t.finalize(), this._measureManager.finalizeMeasurement(t);
      } else
        this._clearMeasurement();
  }
  _updateAnchor(t, e) {
    if (!this._markupItem)
      return;
    const i = this._markupItem.getPoints();
    if (i.length !== 1)
      switch (this._anchor) {
        case Er.Last:
          this._calculateAnchorPos(t, e);
          break;
        case Er.First: {
          if (i.length !== 2)
            return;
          const s = this._viewer.view.projectPoint(i[0]);
          this._calculateAnchorPos(E.fromPoint3(s), i[0]);
          break;
        }
        case Er.Midpoint: {
          let s;
          const r = this._markupItem.getMeasurementValue() / 2;
          let o = 0;
          for (let l = 1; l < i.length; l++) {
            const c = d.subtract(i[l], i[l - 1]), h = c.length(), u = o + h;
            if (u > r) {
              const m = (r - o) / h;
              c.scale(m), s = d.add(i[l - 1], c);
              break;
            }
            o = u;
          }
          const a = this._viewer.view.projectPoint(s);
          this._calculateAnchorPos(E.fromPoint3(a), s);
          break;
        }
      }
  }
  _calculateSelectionPlane(t) {
    const e = this._viewer.view.getCamera(), i = d.subtract(e.getPosition(), t);
    return i.normalize(), je.createFromPointAndNormal(t, i);
  }
  _calculateAnchorPos(t, e) {
    const i = this._viewer.view.getCamera();
    d.subtract(i.getPosition(), e).normalize();
    const r = this._calculateSelectionPlane(e), o = this._viewer.view.raycastFromPoint(
      E.add(t, this._textShapeOffset)
    );
    o && (r.intersectsRay(o, this._markupItem.textPosition), this._markupItem.leaderPosition.assign(e));
  }
  // Cancels the currently measurement being created or removes the last created measurement
  _clearMeasurement() {
    this._markupItem !== null ? (this._measureManager.removeMeasurement(this._markupItem), this._markupItem = null) : this._measureManager.removeLastMeasurement();
  }
  _draw() {
    this._viewer.markupManager.refreshMarkup();
  }
  _pickExisting(t) {
    const e = this._viewer.markupManager.pickMarkupItem(t);
    return e && e.getClassName() === "Communicator.MeasurePolylineDistanceMarkup" ? (this._markupItem = e, !0) : !1;
  }
  /** @hidden */
  onActivate() {
    this._cursor.onOperatorActivate();
  }
  /** @hidden */
  onDeactivate() {
    this._cursor.onOperatorDeactivate();
  }
  /** @hidden */
  onKeyDown(t) {
    t.getKeyCode() === Ut.Escape && this._clearMeasurement();
  }
  _onBeginInteraction() {
    this._cameraInteractionActive = !0, this._cursor.activateCursorSprite(!1);
  }
  _onEndInteraction() {
    this._cameraInteractionActive = !1;
  }
}
const ny = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  MeasureBodyBodyDistanceOperator: Om,
  MeasureEdgeLengthOperator: Dm,
  MeasureFaceFaceAngleOperator: zm,
  MeasureFaceFaceDistanceOperator: Bm,
  MeasureLineLineAngleOperator: jm,
  MeasurePointPointDistanceOperator: Hm,
  MeasurePolygonAreaAnchor: Tr,
  MeasurePolygonAreaOperator: Um,
  MeasurePolylineDistanceAnchor: Er,
  MeasurePolylineDistanceOperator: Qm,
  PointCursor: Ta,
  SelectionPoints: Jm,
  Stage: tn,
  worldPointToScreenPoint: cl
}, Symbol.toStringTag, { value: "Module" })), sy = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  MeasureBodyBodyDistanceMarkup: ia,
  MeasureCircleEdgeLengthMarkup: na,
  MeasureFaceFaceAngleMarkup: sa,
  MeasureFaceFaceDistanceMarkup: ra,
  MeasureLengthMarkup: jl,
  MeasureLineLineAngleMarkup: oa,
  MeasureMarkup: fi,
  MeasurePointPointDistanceMarkup: aa,
  MeasurePolygonAreaMarkup: la,
  MeasurePolylineDistanceMarkup: ca,
  MeasureStraightEdgeLengthMarkup: Pl
}, Symbol.toStringTag, { value: "Module" })), hl = class extends _s {
  constructor(n, t, e, i, s) {
    super(), this._uniqueId = Qi(), this._noteElementId = null, this._position = d.zero(), this._text = "", this._color = it.white(), this._sphereRadius = 0.03, this._deleted = !1, this._active = !1, this._callbacks = null, this._viewer = n, this._noteTextManager = t, this._selectionPosition = e, this._selectionNormal = i, this._partId = s, this._noteTextManager.addNote(this), this._init();
  }
  async _init() {
    const n = this._createPinTransformationMatrix(
      this._selectionPosition,
      this._selectionNormal
    ), [t, e] = await Promise.all([
      this._createPinStemInstance(n),
      this._createPinSphereInstance(n)
    ]);
    this._stemInstanceId = t, this._sphereInstanceId = e, await this._restore(!1), this._callbacks = {
      visibilityChanged: () => {
        this._matchPartVisibility();
      }
    }, this._viewer.setCallbacks(this._callbacks), this._viewer.trigger("noteTextCreated", this);
  }
  _matchPartVisibility() {
    if (this._sphereInstanceId === void 0 || this._stemInstanceId === void 0)
      return;
    const n = this._viewer.model, t = n.getNodeVisibility(this._partId), e = n.getNodeVisibility(this._sphereInstanceId);
    t !== e && !this._noteTextManager.getExplodeActive() && n.setNodesVisibility([this._stemInstanceId, this._sphereInstanceId], t);
    const i = this._noteTextManager.getActiveItem();
    i !== null && i.getStemInstanceId() === this._stemInstanceId && !t && this.hide();
  }
  async updatePosition() {
    if (this._sphereInstanceId === void 0)
      return;
    const n = await this._viewer.model.getNodeRealBounding(this._sphereInstanceId);
    this._pinBoundingBox = n, this._position = this._pinBoundingBox.center(), this.setText(this._text);
  }
  async _restore(n) {
    this._noteTextManager.setActiveItemHandle(this._viewer.markupManager.registerMarkup(this)), this._noteTextManager.setActiveItem(this), this._show(n), this._updateColor(), await this.draw();
  }
  async restore() {
    return this._restore(!0);
  }
  setText(n) {
    this._text = n, this._noteTextManager.getNoteTextElement().setText(n);
  }
  saveTextValue() {
    this._text = this._noteTextManager.getNoteTextElement().getText();
  }
  async draw() {
    if (this._deleted || !this._active)
      return;
    this._behindView = !1, await this.updatePosition();
    const n = this._viewer.view.projectPoint(this._position);
    if (n.z <= 0 && (this._behindView = !0), this._behindView)
      this._noteElementId !== null && document.getElementById(this._noteElementId) !== null && (this._viewer.markupManager.removeMarkupElement(this._noteElementId), this._noteElementId = null);
    else {
      const t = new E(n.x, n.y), e = this._noteTextManager.getNoteTextElement();
      e.setPosition(t), this._noteElementId === null && (this._noteElementId = this._viewer.markupManager.addMarkupElement(
        e.getHtmlContainer()
      ));
    }
  }
  hit(n) {
    return this.hitWithTolerance(n, 0);
  }
  hitWithTolerance(n, t) {
    if (!this._active)
      return !1;
    const e = this._noteTextManager.getNoteTextElement(), i = e.getPosition(), s = e.getSize();
    return Uu(n, i, s, t);
  }
  getClassName() {
    return hl.className;
  }
  getUniqueId() {
    return this._uniqueId;
  }
  getSphereInstanceId() {
    return this._sphereInstanceId;
  }
  getStemInstanceId() {
    return this._stemInstanceId;
  }
  onSelect() {
    this._noteTextManager.getNoteTextElement().focus();
  }
  onDeselect() {
    this._noteTextManager.getNoteTextElement().blur();
  }
  hide() {
    const n = this._noteTextManager.getNoteTextElement();
    n.hide(), this.setText(n.getText()), this._noteTextManager.setActiveItem(null), this._active = !1, this._viewer.trigger("noteTextHidden", this);
  }
  _show(n) {
    this._noteTextManager.getNoteTextElement().show(this), this._active = !0, n && this._viewer.trigger("noteTextShown", this);
  }
  show() {
    this._show(!0);
  }
  async remove() {
    if (this.getRemoved() === !0)
      return;
    this._callbacks !== null && (this._viewer.unsetCallbacks(this._callbacks), this._callbacks = null);
    const n = this._viewer.model, t = [];
    this._stemInstanceId !== void 0 && t.push(n.deleteMeshInstances([this._stemInstanceId])), this._sphereInstanceId !== void 0 && t.push(n.deleteMeshInstances([this._sphereInstanceId])), this.hide(), this._noteTextManager.removeNote(this), this._deleted = !0, await zt(t), super.remove();
  }
  getRemoved() {
    return this._deleted;
  }
  setColor(n) {
    return this._color = n, this._updateColor(), Promise.resolve();
  }
  getColor() {
    return this._color;
  }
  getPartId() {
    return this._partId;
  }
  _updateColor() {
    this._sphereInstanceId !== void 0 && this._viewer.model.setNodesFaceColor([this._sphereInstanceId], this._color);
  }
  // pin methods
  _createPinTransformationMatrix(n, t) {
    let e = 0, i = t.x;
    Math.abs(t.y) < Math.abs(i) && (i = t.y, e = 1), Math.abs(t.z) < Math.abs(i) && (e = 2);
    const s = [0, 0, 0];
    s[e] = 1;
    const r = d.createFromArray(s), o = d.cross(t, r).normalize(), a = d.cross(t, o);
    let l = new Q();
    return l.m = [
      t.x,
      t.y,
      t.z,
      0,
      o.x,
      o.y,
      o.z,
      0,
      a.x,
      a.y,
      a.z,
      0,
      0,
      0,
      0,
      1
    ], l = Q.multiply(
      l,
      new Q().setScaleComponent(this._sphereRadius, this._sphereRadius, this._sphereRadius)
    ), l.setTranslationComponent(n.x, n.y, n.z), l;
  }
  async _createPinStemInstance(n) {
    const t = this._noteTextManager.getPinStemMeshId();
    if (t === null)
      throw new Mt("stem mesh hasn't been created yet");
    const e = new bn(
      t,
      n,
      "pin-stem-instance",
      void 0,
      it.black()
    );
    e.setOpacity(1);
    const i = St.SuppressCameraScale | St.DoNotCut | St.DoNotExplode | St.DoNotXRay | St.ExcludeBounding | St.OverrideSceneVisibility | St.AlwaysDraw;
    return e.setCreationFlags(i), this._viewer.model.createMeshInstance(e, void 0, !0, !0);
  }
  async _createPinSphereInstance(n) {
    const t = this._noteTextManager.getPinSphereMeshId();
    if (t === null)
      throw new Mt("sphere mesh hasn't been created yet");
    const e = new bn(
      t,
      n,
      "pin-sphere-instance",
      it.white(),
      void 0
    );
    e.setOpacity(1);
    const i = St.SuppressCameraScale | St.DoNotCut | St.DoNotExplode | St.DoNotXRay | St.ExcludeBounding | St.OverrideSceneVisibility | St.AlwaysDraw;
    return e.setCreationFlags(i), this._viewer.model.createMeshInstance(e, void 0, !0, !0);
  }
  // Serialization methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      uniqueId: this._uniqueId,
      className: this.getClassName(),
      selectionPosition: this._selectionPosition.toJson(),
      selectionNormal: this._selectionNormal.toJson(),
      text: this._text,
      color: this._color,
      partId: this._partId
    };
  }
  static _fromJson(n, t, e) {
    const i = n;
    if (!e.findById(i.uniqueId)) {
      const s = d.fromJson(i.selectionPosition), r = d.fromJson(i.selectionNormal), o = i.partId, a = new hl(
        t,
        e,
        s,
        r,
        o
      );
      return a._uniqueId = i.uniqueId, a.setText(i.text), a.setColor(it.fromJson(i.color)), a;
    }
    return null;
  }
  /**
   * Creates a new [[NoteText]] from an object given by [[toJson]].
   * @param An object given by [[toJson]].
   * @returns The prepared object.
   */
  static async fromJson(n, t, e) {
    return hl._fromJson(n, t, e);
  }
};
let Jr = hl;
Jr.className = "Communicator.Markup.Note.NoteText";
Ui(Jr.className, Jr.fromJson);
class qm {
  constructor() {
    this._positionOffset = E.zero(), this._position = E.zero(), this._activeNoteText = null, this._createTextBox();
  }
  _createTextBox() {
    this._container = document.createElement("div"), this._container.className = "noteTextElement", this._textArea = document.createElement("textarea"), this._textArea.oninput = () => {
      this._activeNoteText !== null && this._activeNoteText.saveTextValue();
    }, this._container.appendChild(this._textArea);
    const t = ["blue", "red", "green", "white", "black"];
    let e = 7;
    t.forEach((s) => {
      const r = document.createElement("button");
      r.className = `noteButton color ${s}`, r.style.top = `${e}px`, e += 25, r.id = `${s}_button`;
      let o;
      switch (s) {
        case "blue":
          o = it.blue();
          break;
        case "red":
          o = it.red();
          break;
        case "green":
          o = it.green();
          break;
        case "white":
          o = it.white();
          break;
        case "black":
          o = it.black();
          break;
        default:
          o = it.white();
          break;
      }
      r.onmousedown = () => {
        this._activeNoteText !== null && this._activeNoteText.setColor(o);
      }, this._container.appendChild(r);
    });
    const i = document.createElement("button");
    i.className = "noteButton trash", i.style.top = `${e}px`, i.onmousedown = async () => {
      this._activeNoteText !== null && await this._activeNoteText.remove();
    }, this._container.appendChild(i);
  }
  /**
   * Sets the corner offset position of the HTML container.
   * @param positionOffset
   */
  setPositionOffset(t) {
    this._positionOffset = t;
  }
  /**
   * @returns the current HTML container offset position.
   */
  getPositionOffset() {
    return this._positionOffset.copy();
  }
  /**
   * Sets the position of the HTML container, taking into account the position offset.
   * @param position
   */
  setPosition(t) {
    this._position = E.add(t, this._positionOffset), this._container.style.left = `${this._position.x}px`, this._container.style.top = `${this._position.y}px`;
  }
  /**
   * @returns the position of the HTML container, taking into account the position offset.
   */
  getPosition() {
    return this._position.copy();
  }
  /**
   * Sets the text in the HTML container text area.
   * @param text
   */
  setText(t) {
    const e = this._container.querySelector("textarea");
    e !== null && (e.value = t);
  }
  /**
   * @returns the current text in the HTML container text area.
   */
  getText() {
    const t = this._container.querySelector("textarea");
    return t !== null ? t.value : "";
  }
  /**
   * Sets the size of the HTML container.
   * @param size
   */
  setSize(t) {
    this._container.style.width = `${t.x}px`, this._container.style.height = `${t.y}px`;
  }
  /**
   * @returns the size of the HTML container.
   */
  getSize() {
    const t = this._container.getBoundingClientRect();
    return new E(t.width, t.height);
  }
  /**
   * Puts the cursor focus in the HTML container text area.
   */
  focus() {
    this._textArea.focus(), this._textArea.style.pointerEvents = "auto";
  }
  /**
   * Removes the cursor focus from the HTML container text area.
   */
  blur() {
    this._container.blur();
  }
  /**
   * Hides the HTML container.
   */
  hide() {
    this._container.style.visibility = "hidden", this._activeNoteText = null;
  }
  /**
   * Sets the active NoteText and shows the HTML container.
   * @param noteText
   */
  show(t) {
    this._container.style.visibility = "visible", this._activeNoteText = t;
  }
  /**
   * @returns the HTML container element.
   */
  getHtmlContainer() {
    return this._container;
  }
  /**
   * Sets the HTML container element.
   * @param container
   */
  setHtmlContainer(t) {
    this._container = t;
  }
}
class Hl {
  /**
   * @returns JSON Array containing markup data.
   */
  exportMarkup() {
    return [];
  }
  /**
   * Loads JSON markup data
   * @param jsonData JSON Array containing markup data.
   */
  loadData(t) {
    return Promise.resolve([]);
  }
}
const qs = class extends Hl {
  constructor(n) {
    super(), this._pinSphereMeshId = null, this._pinStemMeshId = null, this._noteTextList = [], this._activeItemHandle = null, this._activeItem = null, this._explodeActive = !1, this._isolateActive = !1, this._stemLength = 2, this._sphereIterations = 2, this._viewer = n, this._noteTextElement = new qm(), this._noteTextElement.setPositionOffset(new E(12, -24));
    const t = {
      sceneReady: async () => {
        await this._init();
      }
    };
    this._viewer.setCallbacks(t);
  }
  async _init() {
    qs._globalPinSphereMeshData === null && (qs._globalPinSphereMeshData = this._createPinSphereMeshData()), qs._globalPinStemMeshData === null && (qs._globalPinStemMeshData = this._createPinStemMeshData());
    const n = this._viewer.model, t = n.createMesh(qs._globalPinSphereMeshData), e = n.createMesh(qs._globalPinStemMeshData), i = await Promise.all([t, e]);
    this._pinSphereMeshId = i[0], this._pinStemMeshId = i[1];
  }
  _createPinStemMeshData() {
    const n = new Hi();
    return n.addPolyline([0, 0, 0, this._stemLength, 0, 0]), n;
  }
  _createPinSphereMeshData() {
    const n = (1 + Math.sqrt(5)) / 2, t = Math.sqrt(10 + 2 * Math.sqrt(5)) / (4 * n), e = t / 2, i = t / (2 * n), s = [];
    s[0] = new d(-i, e, 0), s[1] = new d(i, e, 0), s[2] = new d(-i, -e, 0), s[3] = new d(i, -e, 0), s[4] = new d(0, -i, e), s[5] = new d(0, i, e), s[6] = new d(0, -i, -e), s[7] = new d(0, i, -e), s[8] = new d(e, 0, -i), s[9] = new d(e, 0, i), s[10] = new d(-e, 0, -i), s[11] = new d(-e, 0, i);
    for (const h of s)
      h.normalize();
    let r = [
      [0, 11, 5],
      [0, 5, 1],
      [0, 1, 7],
      [0, 7, 10],
      [0, 10, 11],
      [1, 5, 9],
      [5, 11, 4],
      [11, 10, 2],
      [10, 7, 6],
      [7, 1, 8],
      [3, 9, 4],
      [3, 4, 2],
      [3, 2, 6],
      [3, 6, 8],
      [3, 8, 9],
      [4, 9, 5],
      [2, 4, 11],
      [6, 2, 10],
      [8, 6, 7],
      [9, 8, 1]
    ], o = 12;
    for (let h = 0; h < this._sphereIterations; h++) {
      const u = [];
      r.map((p) => {
        const m = s[p[0]], g = s[p[1]], _ = s[p[2]];
        s[o++] = new d(m.x + g.x, m.y + g.y, m.z + g.z).scale(0.5).normalize(), s[o++] = new d(g.x + _.x, g.y + _.y, g.z + _.z).scale(0.5).normalize(), s[o++] = new d(_.x + m.x, _.y + m.y, _.z + m.z).scale(0.5).normalize(), u.push([p[0], o - 3, o - 1]), u.push([o - 3, o - 2, o - 1]), u.push([o - 3, p[1], o - 2]), u.push([o - 2, p[2], o - 1]);
      }), r = u;
    }
    const a = [], l = [];
    for (const h of r)
      for (let u = 0; u < 3; u++) {
        const p = h[u], m = s[p];
        a.push(m.x + this._stemLength + 1), a.push(m.y), a.push(m.z);
        const g = m.normalize();
        l.push(g.x), l.push(g.y), l.push(g.z);
      }
    const c = new Hi();
    return c.addFaces(a, l), c.setFaceWinding(yn.CounterClockwise), c;
  }
  /**
   * Retrieves the mesh id of the stem of the note pin, if there is one
   * @returns MeshId of the note pin stem, or null if there is none
   */
  getPinStemMeshId() {
    return this._pinStemMeshId;
  }
  /**
   * Retrieves the mesh id of the spherical head of the note pin, if there is one
   * @returns MeshId of the note pin sphere, or null if there is none
   */
  getPinSphereMeshId() {
    return this._pinSphereMeshId;
  }
  /**
   * Retrieves the note text element
   * @returns note text element
   */
  getNoteTextElement() {
    return this._noteTextElement;
  }
  /**
   * Sets the note text element
   * @param noteTextElement
   */
  setNoteTextElement(n) {
    this._noteTextElement.hide(), this._noteTextElement = n;
  }
  /**
   * Gets an array of all NoteText items that have been added to the manager
   * @returns array of all NoteText items
   */
  getNoteTextList() {
    return this._noteTextList;
  }
  /**
   * Adds a note and makes it active
   * @param note NoteText to be added to the manager
   */
  addNote(n) {
    this._noteTextList.push(n), this._activeItem = n;
  }
  /**
   * Removes a note from the manager
   * @param note NoteText to be removed from the manager
   */
  removeNote(n) {
    const t = this._noteTextList.indexOf(n);
    this._noteTextList.splice(t, 1);
  }
  /**
   * Updates note pin visibility based on manager state (namely the current explode state)
   */
  async updatePinVisibility() {
    if (this._noteTextList.length > 0) {
      const n = [];
      for (const e of this._noteTextList) {
        const i = e.getSphereInstanceId(), s = e.getStemInstanceId();
        i !== void 0 && n.push(i), s !== void 0 && n.push(s);
      }
      const t = this._viewer.model.setNodesVisibility(n, !this._explodeActive);
      return this._explodeActive && this._noteTextElement.hide(), t;
    }
  }
  /**
   * Sets manager explode state based on explosion magnitude. Active explosion hides note pins
   * @param magnitude Explosion magnitude
   */
  explode(n) {
    return this._explodeActive = n > 0, this.updatePinVisibility();
  }
  /**
   * Gets managers explosion state. Active explosion hides note pins
   */
  getExplodeActive() {
    return this._explodeActive;
  }
  /**
   * Sets whether an isolate is currently active or not
   * @param isolateActive
   */
  setIsolateActive(n) {
    this._isolateActive = n;
  }
  /**
   * Gets whether an isolate is currently active or not
   * @returns isolate status
   */
  getIsolateActive() {
    return this._isolateActive;
  }
  /**
   * Get the currently active note text
   * @returns Currently active note text
   */
  getActiveItem() {
    return this._activeItem;
  }
  /**
   * Sets a new currently active note text
   * @param activeItem note text to be marked as currently active
   */
  setActiveItem(n) {
    this._activeItem = n;
  }
  /**
   * Get the active handle string, such as the one returned by [[MarkupManager.registerMarkup]]
   * @returns Active handle string
   */
  getActiveItemHandle() {
    return this._activeItemHandle;
  }
  /**
   * Set the active handle string, should be provided by [[MarkupManager.registerMarkup]]
   * @param activeItemHandle Active handle string
   */
  setActiveItemHandle(n) {
    this._activeItemHandle = n;
  }
  /**
   * Attempts to set the active note to the one associated with the
   * pins elected by the provided [[SelectionItem]]
   * @param selection SelectionItem to attempt to find note from
   */
  selectPin(n) {
    this._activeItem && this._activeItem.hide();
    const t = n.getNodeId();
    if (t !== null) {
      const e = this._getNoteTextFromNodeId(t);
      if (e !== null)
        return e.restore(), !0;
    }
    return !1;
  }
  /**
   * Checks if a nodeId is part of a note pin
   * @param nodeId NodeId to be checked
   */
  checkPinInstance(n) {
    return this._getNoteTextFromNodeId(n) !== null;
  }
  _getNoteTextFromNodeId(n) {
    for (const t of this._noteTextList)
      if (t.getSphereInstanceId() === n || t.getStemInstanceId() === n)
        return t;
    return null;
  }
  /**
   * Checks if a UUID is associated with any existing notes
   * @param id UUID to check
   */
  findById(n) {
    for (const t of this._noteTextList)
      if (n === t.getUniqueId())
        return !0;
    return !1;
  }
  /**
   * Loads notes from an iterable of JSON data like that returned by [[exportMarkup]]
   * @param notes JSON note data iterable
   */
  loadData(n) {
    const t = [];
    for (const e of n) {
      const i = Jr.fromJson(e, this._viewer, this).then((s) => s !== null);
      t.push(i);
    }
    return Promise.all(t);
  }
  /**
   * Exports note texts to an array of JSON Objects that can be restored via [[loadData]]
   * @returns Array of JSON objects representing notes
   */
  exportMarkup() {
    const n = [];
    for (const t of this._noteTextList)
      n.push(t.toJson());
    return n;
  }
};
let Ul = qs;
Ul._globalPinSphereMeshData = null;
Ul._globalPinStemMeshData = null;
const ry = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  NoteText: Jr,
  NoteTextElement: qm,
  NoteTextManager: Ul
}, Symbol.toStringTag, { value: "Module" }));
class So {
  constructor(t, e, i, s, r, o) {
    this.vector = e, this.matrix = i, this.nodeId = s, this.position = t, this.handleType = r, this.translation = d.zero(), this.groupId = o;
  }
}
class $m {
  constructor() {
    this.axis = null, this.plane = null, this.viewPlane = null, this.rotate = null;
  }
}
const $t = class extends _s {
  constructor(n) {
    super(), this._meshIds = new $m(), this._scaleModifier = 1, this._id = 0, this._handleData = /* @__PURE__ */ new Map(), this._translationFromInitialHandlePosition = d.zero(), this._groupIdRotationMatrix = /* @__PURE__ */ new Map(), this._viewer = n, this._callbacks = {
      camera: () => {
        this._updateCamera();
      },
      _assemblyTreeReady: async () => {
        this._updateViewport(), this._hideOverlay();
        const t = this._createMeshId(this._getAxisMeshData()).then((r) => {
          this._meshIds.axis = r;
        }), e = this._createMeshId(this._getPlaneMeshData()).then((r) => {
          this._meshIds.plane = r;
        }), i = this._createMeshId(this._getViewPlaneMeshData()).then((r) => {
          this._meshIds.viewPlane = r;
        }), s = this._createMeshId(this._getRotateMeshData()).then((r) => {
          this._meshIds.rotate = r;
        });
        await Promise.all([t, e, i, s]);
      },
      modelSwitchStart: () => {
        this.removeHandles();
      }
    }, this._viewer.setCallbacks(this._callbacks);
  }
  remove() {
    this._callbacks !== null && (this._viewer.unsetCallbacks(this._callbacks), this._callbacks = null), super.remove();
  }
  _getAxisMeshData() {
    return fh(
      $t._cylinderRadius,
      $t._segmentCount,
      $t._cylinderHeight,
      $t._coneBaseRadius,
      $t._capHeight,
      $t._taperHeight
    );
  }
  _getPlaneMeshData() {
    const n = new d($t._planeOffset, 0, $t._planeOffset), t = new d(
      $t._planeOffset + $t._planeLength,
      0,
      $t._planeOffset
    ), e = new d(
      $t._planeOffset + $t._planeLength,
      0,
      $t._planeOffset + $t._planeLength
    ), i = new d(
      $t._planeOffset,
      0,
      $t._planeOffset + $t._planeLength
    ), s = [
      n.x,
      n.y,
      n.z,
      t.x,
      t.y,
      t.z,
      e.x,
      e.y,
      e.z,
      n.x,
      n.y,
      n.z,
      e.x,
      e.y,
      e.z,
      i.x,
      i.y,
      i.z
    ], r = new d(0, -1, 0), o = [
      r.x,
      r.y,
      r.z,
      r.x,
      r.y,
      r.z,
      r.x,
      r.y,
      r.z,
      r.x,
      r.y,
      r.z,
      r.x,
      r.y,
      r.z,
      r.x,
      r.y,
      r.z
    ], a = new Hi();
    return a.addFaces(s, o), a.setBackfacesEnabled(!0), a.addPolyline([n.x, n.y, n.z, t.x, t.y, t.z]), a.addPolyline([t.x, t.y, t.z, e.x, e.y, e.z]), a.addPolyline([e.x, e.y, e.z, i.x, i.y, i.z]), a.addPolyline([i.x, i.y, i.z, n.x, n.y, n.z]), a;
  }
  _getViewPlaneMeshData() {
    return xd();
  }
  _getRotateMeshData(n = 35, t = 12, e = 0.5) {
    const i = n * Math.PI / 180, s = 0.1, r = 0.5 * i, o = [];
    for (let h = -r; h <= r; h += s) {
      const u = Math.sin(h) * t, p = Math.cos(h) * t;
      o.push(p), o.push(0), o.push(u);
    }
    const a = new d(0, 0, 1), c = Cd(o, a, 10, e);
    return c.setBackfacesEnabled(!0), c;
  }
  async setAxisMeshData(n) {
    if (this._meshIds.axis === null) {
      const t = await this._createMeshId(n);
      this._meshIds.axis = t;
    } else
      return this._viewer.model.replaceMesh(this._meshIds.axis, n);
  }
  async setPlaneMeshData(n) {
    if (this._meshIds.plane === null) {
      const t = await this._createMeshId(n);
      this._meshIds.plane = t;
    } else
      return this._viewer.model.replaceMesh(this._meshIds.plane, n);
  }
  async setViewPlaneMeshData(n) {
    if (this._meshIds.viewPlane === null) {
      const t = await this._createMeshId(n);
      this._meshIds.viewPlane = t;
    } else
      return this._viewer.model.replaceMesh(this._meshIds.viewPlane, n);
  }
  async setRotateMeshData(n) {
    if (this._meshIds.rotate === null) {
      const t = await this._createMeshId(n);
      this._meshIds.rotate = t;
    } else
      return this._viewer.model.replaceMesh(this._meshIds.rotate, n);
  }
  /**
   * Gets the associated overlay id
   */
  getOverlayId() {
    return Vt.Handles;
  }
  _hideOverlay() {
    this._viewer.overlayManager.setVisibility(Vt.Handles, !1);
  }
  hideOverlay() {
    return this._hideOverlay(), Promise.resolve();
  }
  _showOverlay() {
    this._viewer.overlayManager.setVisibility(Vt.Handles, !0), this._updateCamera();
  }
  showOverlay() {
    return this._showOverlay(), Promise.resolve();
  }
  _updateViewport() {
    this._viewer.overlayManager.setViewport(
      Vt.Handles,
      Jt.UpperLeftCorner,
      0,
      Bt.ProportionOfCanvas,
      0,
      Bt.ProportionOfCanvas,
      1,
      Bt.ProportionOfCanvas,
      1,
      Bt.ProportionOfCanvas
    );
  }
  updateViewport() {
    return this._updateViewport(), Promise.resolve();
  }
  async addHandles(n, t, e) {
    this._scaleModifier = t, this._translationFromInitialHandlePosition.assign(d.zero()), await this.createDefaultHandles(n, e), this._showOverlay();
  }
  _updateCamera() {
    this._viewer.overlayManager.setCamera(
      Vt.Handles,
      this._viewer.view.getCamera()
    );
  }
  getVector(n) {
    const t = this._handleData.get(n);
    if (t !== void 0) {
      const e = t.vector;
      if (e !== null)
        return e.copy();
    }
    return null;
  }
  getHandleType(n) {
    const t = this._handleData.get(n);
    return t === void 0 ? null : t.handleType;
  }
  getHandleGroupId(n) {
    const t = this._handleData.get(n);
    return t === void 0 ? $t.defaultGroupId : t.groupId;
  }
  getPosition(n) {
    const t = this._handleData.get(n);
    if (t) {
      const e = t.translation.copy();
      return t.position.copy().add(this._translationFromInitialHandlePosition).add(e);
    } else
      return null;
  }
  getHandleNodeIds(n = null) {
    let t = [];
    return this._handleData.forEach((e, i) => {
      t.push([i, e]);
    }), n !== null && (t = t.filter((e) => e[1].groupId === n)), t.map((e) => e[0]);
  }
  async removeHandles(n = null) {
    const t = this.getHandleNodeIds(n);
    n === null ? (this._handleData.clear(), this._groupIdRotationMatrix.clear()) : (t.forEach((e) => {
      this._handleData.delete(e);
    }), this._groupIdRotationMatrix.delete(n)), this._handleData.size === 0 && (this._id = 0, this._hideOverlay()), await this._viewer.model.deleteMeshInstances(t);
  }
  isEmpty() {
    return this._handleData.size === 0;
  }
  async createDefaultHandles(n, t) {
    const e = [];
    e.push(this.addViewPlaneHandle(n, $t._viewPlaneColor, t)), e.push(
      this.addAxisTranslationHandle(
        n,
        new d(1, 0, 0),
        $t._xColor,
        null,
        t
      )
    ), e.push(
      this.addAxisTranslationHandle(
        n,
        new d(0, 1, 0),
        $t._yColor,
        null,
        t
      )
    ), e.push(
      this.addAxisTranslationHandle(
        n,
        new d(0, 0, 1),
        $t._zColor,
        null,
        t
      )
    ), e.push(
      this.addPlaneTranslationHandle(
        n,
        new d(1, 0, 0),
        $t._zColor,
        it.black(),
        new d(0, -1, 0),
        t
      )
    ), e.push(
      this.addPlaneTranslationHandle(
        n,
        new d(0, 1, 0),
        $t._xColor,
        it.black(),
        new d(0, 0, -1),
        t
      )
    ), e.push(
      this.addPlaneTranslationHandle(
        n,
        new d(0, 0, 1),
        $t._yColor,
        it.black(),
        new d(-1, 0, 0),
        t
      )
    ), e.push(
      this.addRotateHandle(
        n,
        new d(1, 0, 0),
        $t._zColor,
        new d(0, -1, 0),
        t
      )
    ), e.push(
      this.addRotateHandle(
        n,
        new d(0, 1, 0),
        $t._xColor,
        new d(0, 0, -1),
        t
      )
    ), e.push(
      this.addRotateHandle(
        n,
        new d(0, 0, 1),
        $t._yColor,
        new d(-1, 0, 0),
        t
      )
    ), await Promise.all(e);
  }
  async _createMeshId(n) {
    return await this._viewer.model.createMesh(n, { doNotDelete: !0 });
  }
  async addAxisTranslationHandle(n, t, e, i, s) {
    this._meshIds.axis === null && (this._meshIds.axis = await this._createMeshId(this._getAxisMeshData()));
    const r = `handle-axis-translation-${this._id++}`, o = this._getRotationMatrixFromVector(t, i), a = await this._createMeshInstance(
      this._meshIds.axis,
      r,
      e,
      null,
      n.copy(),
      o.copy()
    );
    return this._handleData.set(
      a,
      new So(
        n.copy(),
        t.copy(),
        o.copy(),
        a,
        Bn.Axis,
        s
      )
    ), a;
  }
  async addViewPlaneHandle(n, t, e) {
    this._meshIds.viewPlane === null && (this._meshIds.viewPlane = await this._createMeshId(this._getViewPlaneMeshData()));
    const i = await this._createMeshInstance(
      this._meshIds.viewPlane,
      "handle-sphere-instance",
      t,
      null,
      n,
      new Q()
    );
    return this._handleData.set(
      i,
      new So(n.copy(), null, new Q(), i, Bn.ViewPlane, e)
    ), i;
  }
  async addPlaneTranslationHandle(n, t, e, i, s, r) {
    this._meshIds.plane === null && (this._meshIds.plane = await this._createMeshId(this._getPlaneMeshData()));
    const o = `handle-plane-translation-${this._id++}`, a = this._getRotationMatrixFromVector(t, s), l = await this._createMeshInstance(
      this._meshIds.plane,
      o,
      e,
      i,
      n,
      a
    );
    return this._handleData.set(
      l,
      new So(
        n.copy(),
        t.copy(),
        a.copy(),
        l,
        Bn.Plane,
        r
      )
    ), l;
  }
  async addRotateHandle(n, t, e, i, s) {
    this._meshIds.rotate === null && (this._meshIds.rotate = await this._createMeshId(this._getRotateMeshData()));
    const r = `handle-rotate-${this._id++}`, o = this._getRotationMatrixFromVector(t, i), a = await this._createMeshInstance(
      this._meshIds.rotate,
      r,
      e,
      null,
      n,
      o
    );
    return this._handleData.set(
      a,
      new So(
        n.copy(),
        t.copy(),
        o.copy(),
        a,
        Bn.Rotate,
        s
      )
    ), a;
  }
  _getRotationMatrixFromVector(n, t) {
    t || (t = new d(1, 0, 0), d.cross(t, n).squaredLength() < 1e-3 && (t = new d(0, 1, 0)));
    const e = d.cross(t, n).normalize(), i = d.cross(e, n).normalize();
    n.normalize();
    const s = new Q();
    return s.m[0] = e.x, s.m[1] = e.y, s.m[2] = e.z, s.m[3] = 0, s.m[4] = n.x, s.m[5] = n.y, s.m[6] = n.z, s.m[7] = 0, s.m[8] = i.x, s.m[9] = i.y, s.m[10] = i.z, s.m[11] = 0, s.m[12] = 0, s.m[13] = 0, s.m[14] = 0, s.m[15] = 1, s;
  }
  async _createMeshInstance(n, t, e, i, s, r) {
    let o = this._createTransformationMatrix(s, new Q());
    o = Q.multiply(r, o);
    const a = new bn(
      n,
      o,
      t,
      e ?? void 0,
      i ?? void 0
    );
    return a.setOpacity(1), a.setCreationFlags(
      St.SuppressCameraScale | St.DoNotCut | St.DoNotExplode | St.ExcludeBounding | St.DoNotXRay | St.OverrideSceneVisibility | St.AlwaysDraw
    ), a.setOverlayIndex(Vt.Handles), this._viewer.model.createMeshInstance(a, void 0, !0, !0);
  }
  _createTransformationMatrix(n, t) {
    const e = $t._defaultScale * this._scaleModifier;
    let i = new Q().setScaleComponent(e, e, e);
    return i = Q.multiply(i, t), i.setTranslationComponent(n.x, n.y, n.z), i;
  }
  _getHandlePosition(n) {
    let t = null;
    return this._handleData.forEach((e) => {
      e.groupId === n && (t = e.position.copy());
    }), t;
  }
  getGroupIdRotationMatrix(n) {
    const t = this._groupIdRotationMatrix.get(n);
    return t === void 0 ? new Q() : t.copy();
  }
  async updatePosition(n, t, e, i, s) {
    const r = this._viewer.model, o = [], a = /* @__PURE__ */ new Map(), l = this._getHandlePosition(i);
    l !== null && (this._handleData.forEach((c, h) => {
      const u = c.groupId, p = s.get(u) !== void 0;
      if (!(u === i) && !p)
        return;
      const g = c.position.copy();
      g.add(n.copy());
      const _ = c.translation.copy();
      g.add(_);
      const y = Q.multiply(
        this.getGroupIdRotationMatrix(u),
        t
      ), b = Q.multiply(c.matrix, y);
      if (p) {
        const v = d.subtract(g, l);
        t.transform(v, g), g.add(l);
      }
      const w = this._createTransformationMatrix(g, b);
      e && (c.position.assign(g), a.set(
        u,
        Q.multiply(this.getGroupIdRotationMatrix(u), t)
      )), o.push(r.setNodeMatrix(h, w));
    }), a.forEach((c, h) => {
      this._groupIdRotationMatrix.set(h, c.copy());
    }), await Promise.all(o));
  }
  resetTranslation() {
    this._translationFromInitialHandlePosition && (this._handleData.forEach((n) => {
      n.translation.add(this._translationFromInitialHandlePosition);
    }), this._translationFromInitialHandlePosition.assign(d.zero()));
  }
  getTranslation() {
    return this._translationFromInitialHandlePosition;
  }
};
let _i = $t;
_i.className = "Communicator.Markup.HandleMarkup";
_i.defaultGroupId = -1;
_i._defaultScale = 0.02;
_i._cylinderRadius = 0.5;
_i._coneBaseRadius = 0.9;
_i._cylinderHeight = 7;
_i._capHeight = 1.2;
_i._taperHeight = 0.2;
_i._segmentCount = 20;
_i._planeOffset = 1;
_i._planeLength = 2.5;
_i._xColor = new it(168, 56, 59);
_i._yColor = new it(96, 166, 50);
_i._zColor = new it(41, 81, 185);
_i._viewPlaneColor = it.white();
const oy = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CursorMarkup: Lh,
  HandleData: So,
  HandleMarkup: _i,
  HandleMeshIds: $m,
  Measure: sy,
  Note: ry,
  Redline: F_
}, Symbol.toStringTag, { value: "Module" }));
class Ea extends Se {
  /** @hidden */
  constructor(t) {
    super(t), this._activeRedlineItem = null, this._newRedlineItem = null, this._viewer = t;
  }
  // Interface method for derived operators to implement
  /** @hidden */
  createRedlineItem(t) {
    return null;
  }
  // Interface method for derived operators to implement
  /** @hidden */
  updateRedlineItem(t) {
  }
  // Interface method for derived operators to implement
  /** @hidden */
  finalizeRedlineItem(t) {
    return null;
  }
  // Default behavior for redline operators
  /** @hidden */
  onMouseDown(t) {
    super.onMouseDown(t), this.isActive() && ((t.getButton() === Kt.Left || this._primaryTouchId !== null) && this._redlineOperatorStart(), t.setHandled(!0));
  }
  /** @hidden */
  onMouseMove(t) {
    super.onMouseMove(t), this.isActive() && (this._redlineOperatorMove(), t.setHandled(!0));
  }
  /** @hidden */
  onMouseUp(t) {
    this.isActive() && ((t.getButton() === Kt.Left || this._primaryTouchId !== null) && this._redlineOperatorEnd(), t.setHandled(!0)), super.onMouseUp(t);
  }
  /** @hidden */
  onMousewheel(t) {
    t.setHandled(!0);
  }
  /** @hidden */
  setDraggingEnabled(t) {
    this._dragging = t;
  }
  /** @hidden */
  setHandled() {
    return !0;
  }
  _isRedlineItem(t) {
    return Object.getPrototypeOf(t) instanceof to;
  }
  /** @hidden */
  onKeyUp(t) {
    const e = t.getKeyCode();
    if (e === Ut.Backspace || e === Ut.Delete) {
      const i = this._viewer.markupManager, s = i.getSelectedMarkup(), r = i.getActiveMarkupView();
      s !== null && this._isRedlineItem(s) && r !== null && (r.removeMarkup(s), i.selectMarkup(null));
    }
  }
  _removeRedlineTextIfInvalid(t) {
    const e = t;
    if (!e.isValid()) {
      const i = this._viewer.markupManager.getActiveMarkupView();
      i !== null && (i.removeMarkup(e), this._viewer.trigger("redlineDeleted", e)), e.remove();
    }
  }
  // Generic behavior to handle dragging of redline
  _redlineOperatorStart() {
    const t = this._viewer.markupManager, e = t.pickMarkupItem(this._ptFirst), i = t.getSelectedMarkup();
    e ? (this._activeRedlineItem = e, this._dragging && this._activeRedlineItem.onDragStart(this._ptFirst) && t.refreshMarkup()) : (i != null && i.onDeselect(), t.selectMarkup(null), this._markupIsTextArea(i) ? this._removeRedlineTextIfInvalid(i) : this._newRedlineItem = this.createRedlineItem(this._ptFirst));
  }
  _redlineOperatorMove() {
    this._activeRedlineItem ? this._dragging && this._activeRedlineItem.onDragMove(this._ptCurrent) && this._viewer.markupManager.refreshMarkup() : this.updateRedlineItem(this._ptCurrent);
  }
  _redlineOperatorEnd() {
    const t = this._viewer.markupManager;
    if (this._activeRedlineItem)
      this._ptFirst.equals(this._ptCurrent) ? t.selectMarkup(this._activeRedlineItem) : (this._viewer.trigger("redlineUpdated", this._activeRedlineItem), this._dragging && this._activeRedlineItem.onDragEnd(this._ptCurrent) && t.refreshMarkup());
    else if (this._newRedlineItem) {
      const e = this.finalizeRedlineItem(this._ptCurrent);
      e && this._attachNewMarkupToView(e);
    }
    this._activeRedlineItem = null, this._newRedlineItem = null;
  }
  async _attachNewMarkupToView(t) {
    const e = this._viewer, i = e.model, s = e.markupManager;
    let r = s.getActiveMarkupView(), o = !1;
    if (r === null) {
      const a = i.getAbsoluteRootNode(), l = await i.getVisibilityState(a), c = await i.getNodeColorMap(i.getAbsoluteRootNode(), vt.Faces), h = s.createMarkupView(void 0, !1, l, c, null);
      r = s.getMarkupView(h), o = !0;
    }
    r !== null && (r.addMarkupItem(t), s.selectMarkup(t)), o && r !== null && this._viewer.trigger("viewCreated", r), this._viewer.trigger("redlineCreated", t);
  }
  _markupIsTextArea(t) {
    return t ? t.getClassName() === Ls.className : !1;
  }
}
class tp extends Ea {
  /** @hidden */
  constructor(t) {
    super(t), this._redlineCircle = null, this._previewHandle = null, this._centerSet = !1;
  }
  /** @hidden */
  createRedlineItem(t) {
    const e = this._viewer.view;
    this._redlineCircle = new gr(this._viewer), this._previewHandle = this._viewer.markupManager.registerMarkup(this._redlineCircle);
    const i = e.getCamera().getCameraPlaneIntersectionPoint(t, e);
    return i !== null && (this._centerSet = !0, this._redlineCircle.setCenter(i), this._redlineCircle.setRadiusPoint(i)), this._redlineCircle;
  }
  /** @hidden */
  updateRedlineItem(t) {
    const e = this._viewer.view;
    if (this._redlineCircle) {
      const i = e.getCamera().getCameraPlaneIntersectionPoint(t, e);
      i !== null && (this._centerSet || (this._centerSet = !0, this._redlineCircle.setCenter(i)), this._redlineCircle.setRadiusPoint(i), this._viewer.markupManager.refreshMarkup());
    }
  }
  /** @hidden */
  finalizeRedlineItem(t) {
    const e = this._viewer.markupManager;
    let i = null;
    return this._redlineCircle && (this._redlineCircle.isValid() && (i = this._redlineCircle), this._redlineCircle = null, this._previewHandle !== null && (e.unregisterMarkup(this._previewHandle), this._previewHandle = null), e.refreshMarkup()), i;
  }
}
class ep extends Ea {
  /** @hidden */
  constructor(t) {
    super(t), this._redlinePolyline = null, this._previewHandle = null;
  }
  /** @hidden */
  createRedlineItem(t) {
    const e = this._viewer.view;
    this._redlinePolyline = new Ar(this._viewer), this._previewHandle = this._viewer.markupManager.registerMarkup(this._redlinePolyline);
    const i = e.getCamera().getCameraPlaneIntersectionPoint(t, e);
    return i !== null && this._redlinePolyline.addPoint(i), this._redlinePolyline;
  }
  /** @hidden */
  updateRedlineItem(t) {
    if (this._redlinePolyline) {
      const e = this._viewer.view, i = e.getCamera().getCameraPlaneIntersectionPoint(t, e);
      i !== null && (this._redlinePolyline.addPoint(i), this._viewer.markupManager.refreshMarkup());
    }
  }
  /** @hidden */
  finalizeRedlineItem(t) {
    const e = this._viewer.markupManager;
    let i = null;
    return this._redlinePolyline && (this._redlinePolyline.isValid() && (i = this._redlinePolyline), this._redlinePolyline = null, this._previewHandle !== null && (e.unregisterMarkup(this._previewHandle), this._previewHandle = null), e.refreshMarkup()), i;
  }
}
class ip extends Ea {
  /** @hidden */
  constructor(t) {
    super(t), this._redlineRectangle = null, this._previewHandle = null;
  }
  /** @hidden */
  createRedlineItem(t) {
    const e = this._viewer.view, i = e.getCamera().getCameraPlaneIntersectionPoint(t, e);
    return this._redlineRectangle = new fr(this._viewer), i !== null && (this._redlineRectangle.setPoint1(i), this._redlineRectangle.setPoint2(i)), this._previewHandle = this._viewer.markupManager.registerMarkup(this._redlineRectangle), this._redlineRectangle;
  }
  /** @hidden */
  updateRedlineItem(t) {
    if (this._redlineRectangle) {
      const e = this._viewer.view, i = e.getCamera().getCameraPlaneIntersectionPoint(t, e);
      i !== null && this._redlineRectangle.setPoint2(i), this._viewer.markupManager.refreshMarkup();
    }
  }
  /** @hidden */
  finalizeRedlineItem(t) {
    let e = null;
    if (this._redlineRectangle && this._previewHandle) {
      const i = this._viewer.markupManager;
      this._redlineRectangle.isValid() && (e = this._redlineRectangle), i.unregisterMarkup(this._previewHandle), this._previewHandle = null, this._redlineRectangle = null, i.refreshMarkup();
    }
    return e;
  }
}
class np extends Ea {
  /** @hidden */
  constructor(t) {
    super(t), this._redlineText = null;
  }
  /** @hidden */
  createRedlineItem(t) {
    return this._redlineText = new Ls(this._viewer), this._redlineText;
  }
  /** @hidden */
  finalizeRedlineItem(t) {
    if (this._redlineText === null)
      return null;
    const e = this._viewer.view, i = this._redlineText, s = e.getCamera().getCameraPlaneIntersectionPoint(t, e);
    return s !== null && i.setPosition(s), this._redlineText = null, i;
  }
}
const ay = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  RedlineCircleOperator: tp,
  RedlineOperator: Ea,
  RedlinePolylineOperator: ep,
  RedlineRectangleOperator: ip,
  RedlineTextOperator: np
}, Symbol.toStringTag, { value: "Module" }));
class sp extends Se {
  /** @hidden */
  constructor(t) {
    super(t), this._forceEffectiveSceneVisibilityMask = Xt.None, this._rectangleMarkup = new Nh(t, !1), this._incrementalSelection = Va.create("SelectionManager", t), t.setCallbacks({
      _resetAssemblyTreeBegin: async () => (await this.clearSelection(), this.waitForIdle())
    });
  }
  /**
   * Gets the mask used for forcing effective scene visibility during selection.
   */
  getForceEffectiveSceneVisibilityMask() {
    return this._forceEffectiveSceneVisibilityMask;
  }
  /**
   * Sets the mask used for forcing effective scene visibility during selection.
   */
  setForceEffectiveSceneVisibilityMask(t) {
    this._forceEffectiveSceneVisibilityMask = t;
  }
  hasActiveSelection() {
    return !this._incrementalSelection.isIdle();
  }
  async waitForIdle() {
    return this._incrementalSelection.waitForIdle();
  }
  async clearSelection() {
    return this._incrementalSelection.clearSelection();
  }
  _allowSelection(t, e) {
    return !(t.x === e.x || t.y === e.y);
  }
  _createBeginConfig(t, e, i) {
    const s = new Dl();
    return s.forceEffectiveSceneVisibilityMask = this._forceEffectiveSceneVisibilityMask, s.ignoreCuttingSections = !1, s.ignoreUnrequestedInstances = !0, i && (s.mustBeFullyContained = !0), {
      pickConfig: s,
      areaCssMin: t,
      areaCssMax: e
    };
  }
  async _performSelection(t) {
    const e = this._rectangleMarkup.min.copy(), i = this._rectangleMarkup.max.copy(), s = this._rectangleMarkup.initialPosition.x < this._rectangleMarkup.currentPosition.x;
    if (t && await this.clearSelection(), !this._allowSelection(e, i))
      return;
    const r = this._createBeginConfig(e, i, s);
    try {
      return await this._incrementalSelection.performSelection(r);
    } catch (o) {
      if (!(o instanceof as))
        throw o;
    }
  }
  ///////////////////////////////////////////////////////////////////////////////////
  /** @hidden */
  setHandled() {
    return !0;
  }
  /** @hidden */
  onKeyUp(t) {
    t.getKeyCode() === Ut.Escape && this.clearSelection();
  }
  /** @hidden */
  onMouseDown(t) {
    super.onMouseDown(t), this.isActive() && (t.setHandled(!0), this._rectangleMarkup.isActive() && this._rectangleMarkup.deactivate(), this._rectangleMarkup.activate(t.getPosition()));
  }
  /** @hidden */
  onMouseMove(t) {
    super.onMouseMove(t), this.isActive() && this._rectangleMarkup.isActive() && (t.setHandled(!0), this._rectangleMarkup.updateCurrentPosition(t.getPosition()), this._viewer.markupManager.refreshMarkup());
  }
  /** @hidden */
  onMouseUp(t) {
    if (this.isActive() && this._rectangleMarkup.isActive()) {
      t.setHandled(!0), this._rectangleMarkup.updateCurrentPosition(t.getPosition());
      const e = !t.controlDown();
      this._performSelection(e);
    }
    this._rectangleMarkup.isActive() && this._rectangleMarkup.deactivate(), super.onMouseUp(t);
  }
}
class rp extends Se {
  /** @hidden */
  constructor(t) {
    super(t), this._axisTriad = t.view.getAxisTriad(), this._pickConfig = new Ie(Xt.Face), this._pickConfig.restrictToOverlays = !0;
  }
  /** @hidden */
  async onMouseUp(t) {
    if (this._axisTriad.getEnabled() && E.subtract(this._ptFirst, this._ptCurrent).squaredLength() < 25 && this._axisTriad.insideOverlay(t.getPosition())) {
      const e = await this._viewer.view.pickFromPoint(this._ptFirst, this._pickConfig);
      await this._axisTriad.onClickSelection(e);
    }
    super.onMouseUp(t);
  }
}
class op {
  constructor(t, e, i, s, r) {
    this.section = t, this.node = e, this.planeIndex = i, this.plane = s, this.selectionPosition = r, this.origPlaneD = s.d;
  }
}
class ap extends Se {
  constructor(t, e) {
    super(t), this._context = null, this._cuttingManager = e;
  }
  async onMouseDown(t) {
    super.onMouseDown(t), this._context === null && this.isActive() && this._cuttingManager.hasActiveCuttingSection() && (await this._startSelection(t), t.setHandled(this._context !== null));
  }
  async onMouseMove(t) {
    super.onMouseMove(t);
    const e = this._context;
    this.isActive() && e !== null && (t.setHandled(!0), await this._updatePlane(t.getPosition(), e, !1), this._viewer.trigger("cuttingPlaneDrag", e.section, e.planeIndex));
  }
  async _updatePlane(t, e, i) {
    const s = e.selectionPosition, r = e.plane.normal.copy().add(e.selectionPosition), o = this._viewer.view.unprojectPoint(t, 0), a = this._viewer.view.unprojectPoint(t, 0.5);
    if (o !== null && a !== null) {
      const l = ju(s, r, o, a);
      if (l !== null) {
        const c = d.subtract(l, e.selectionPosition), h = d.dot(c, e.plane.normal) < 0 ? c.length() : -c.length();
        e.plane.d = e.origPlaneD + h;
        const u = e.plane.normal.copy().scale(-h), p = new Q().setTranslationComponent(u.x, u.y, u.z);
        await e.section.updatePlane(
          e.planeIndex,
          e.plane,
          p,
          i,
          !1
        );
      }
      this._cuttingManager.delayCapping();
    }
  }
  async onMouseUp(t) {
    const e = this._context;
    this.isActive() && e !== null && (t.setHandled(!0), await this._updatePlane(t.getPosition(), e, !0), this._viewer.trigger("cuttingPlaneDragEnd", e.section, e.planeIndex)), this._context = null, super.onMouseUp(t);
  }
  setHandled() {
    return this.isActive() && this._context !== null;
  }
  /**
   * Perform the selection operation. If successful, the cutting plane context will be properly
   * setup, otherwise the cutting plane context will be null.
   */
  async _startSelection(t) {
    this._context = null;
    const e = t.getPosition(), i = Xt.Face | Xt.Line, s = new Ie(i);
    s.ignoreCappingGeometry = !0, s.forceEffectiveSceneVisibilityMask = Xt.Face;
    const o = (await this._viewer.view.compositePickFromPoint(e, s)).fetchMostRelevant(i);
    if (o === null)
      return;
    const a = o.getNodeId(), l = this._cuttingManager.getCuttingSectionFromNodeId(a);
    if (l !== null) {
      const c = l.getPlaneIndexByNodeId(a);
      this._context = new op(
        l,
        a,
        c,
        l.getPlane(c),
        o.getPosition()
      ), this._cuttingManager.delayCapping(), this._viewer.trigger("cuttingPlaneDragStart", l, c);
    }
  }
}
class lp extends Se {
  /** @hidden */
  constructor(t) {
    super(t), this._draggingAvatar = !1, this._restrictToAvatar = !0, this._floorLocked = !1, this._manager = t.floorplanManager;
  }
  /** @hidden */
  async onMouseDown(t) {
    if (super.onMouseDown(t), !this._manager.isActive())
      return;
    const e = t.getPosition();
    let i;
    if (!this._restrictToAvatar)
      i = this._manager.insideOverlay(e);
    else {
      const s = new Ie();
      s.restrictToOverlays = !0, i = (await this._viewer.view.pickFromPoint(e, s)).getNodeId() === this._manager.getAvatarNodeId();
    }
    i && (this._draggingAvatar = !0, this._floorLocked = this._manager.getFloorLock(), await this._manager.setFloorLock(!0), this._manager.snapAvatarToPoint(e), t.setHandled(!0));
  }
  /** @hidden */
  async onMouseUp(t) {
    super.onMouseUp(t), this._draggingAvatar && await this._manager.setFloorLock(this._floorLocked), this._draggingAvatar = !1;
  }
  /** @hidden */
  onMouseMove(t) {
    if (super.onMouseMove(t), !!this._manager.isActive() && this._draggingAvatar) {
      t.setHandled(!0);
      const e = t.getPosition();
      this._manager.insideOverlay(e) && this._manager.snapAvatarToPoint(e);
    }
  }
  /**
   * Set whether or not dragging is restricted to the avatar. If true the operator will only function if
   * the selection begins on the avatar
   */
  restrictToAvatar(t) {
    this._restrictToAvatar = t;
  }
}
class cp extends Se {
  constructor(t) {
    super(t), this._draggingHandle = !1, this._newRotationMatrix = new Q(), this._translation = d.zero(), this._newTranslation = d.zero(), this._nodeIdGroupMap = /* @__PURE__ */ new Map(), this._groupIdCount = 0, this._activeChildrenGroupIds = /* @__PURE__ */ new Map(), this._initialLocalNodeMatrices = [], this._newLocalNodeMatrices = [], this._trackedPoints = [], this._trackedPointsPositions = [], this._trackedPointCount = 0, this._previousContextClick = !1, this._overlayIndex = null, this._activeHandleNodeId = null, this._handleEventType = ws.Translate, this._highlightedHandleId = null, this._handleSize = 1, this._explodeActive = !1, this._measureActive = !1, this._settingMatrixInProgress = !1, this._handleMarkup = new _i(t), this._pickConfig = new Ie(Xt.Face), this._pickConfig.restrictToOverlays = !0, t.setCallbacks({
      explode: (e) => {
        this._explodeActive = e > 0, this._explodeActive && this.removeHandles();
      },
      measurementBegin: () => {
        this._measureActive = !0, this.removeHandles();
      },
      measurementCreated: () => {
        this._measureActive = !1;
      },
      measurementDeleted: () => {
        this._measureActive = !1;
      }
    });
  }
  /**
   * Sets the mesh data for axis handles.
   * @param meshData
   */
  setAxisMeshData(t) {
    return this._handleMarkup.setAxisMeshData(t);
  }
  /**
   * Sets the mesh data for plane handles.
   * @param meshData
   */
  setPlaneMeshData(t) {
    return this._handleMarkup.setPlaneMeshData(t);
  }
  /**
   * Sets the mesh data for view plane handles.
   * @param meshData
   */
  setViewPlaneMeshData(t) {
    return this._handleMarkup.setViewPlaneMeshData(t);
  }
  /**
   * Sets the mesh data for rotation handles.
   * @param meshData
   */
  setRotateMeshData(t) {
    return this._handleMarkup.setRotateMeshData(t);
  }
  /**
   * Add a point to the tracked points list. When the handle moves, these points will update in world space.
   * @param point
   * @returns point index
   */
  addTrackedPoint(t) {
    const e = this._trackedPointCount;
    return this._trackedPoints[e] = t.copy(), this._trackedPointsPositions[e] = t.copy(), ++this._trackedPointCount, e;
  }
  /**
   * Gets the tracked point list.
   */
  getTrackedPoints() {
    return this._trackedPointsPositions;
  }
  /**
   * Clear the list of tracked points.
   */
  clearTrackedPoints() {
    this._trackedPoints.length = 0, this._trackedPointsPositions.length = 0, this._trackedPointCount = 0;
  }
  /**
   * Returns a boolean value indicating if handles are available to be added to the scene
   * If there is an active explode, active measure, or the model is a 2d drawing.
   * this will be false.
   */
  isEnabled() {
    return !this._explodeActive && !this._measureActive && !this._viewer.sheetManager.isDrawingSheetActive();
  }
  _guardEnabled() {
    if (!this.isEnabled()) {
      const t = (() => this._explodeActive ? "Handles are not enabled when the model is exploded" : this._measureActive ? "Handles are not enabled while a measurement is in progress." : this._viewer.sheetManager.isDrawingSheetActive() ? "Handles are not enabled for 2d drawings." : "Handles are not enabled.")();
      throw new Mt(t);
    }
  }
  /**
   * Takes a scale value to change the handle size with 1 representing the default size
   * @param size
   */
  setHandleSize(t) {
    this._handleSize = t;
  }
  /**
   * Adds all handles into the scene, oriented along the primary axes
   * @param nodeIds corresponding to the parts that will move with the handles
   * @param position world space coordinates the the handle position
   */
  async addHandles(t, e = null, i = null) {
    if (this._previousContextClick = !1, this._guardEnabled(), !e) {
      const r = await this._viewer.model.getNodesBounding(t);
      return this.addHandles(t, r.center());
    }
    const s = this._findGroupId(t);
    return i === null && (i = s !== null ? s : this.generateGroupId()), this._nodeIdGroupMap.set(i, t), s !== null && await this._handleMarkup.removeHandles(i), this._handleMarkup.addHandles(e, this._handleSize, i);
  }
  /**
   * Returns the group id associated to the given group of node ids, returns null if does not exist
   * @param nodeIds
   */
  _findGroupId(t) {
    let e = null;
    return this._nodeIdGroupMap.forEach((i, s) => {
      i.length === t.length && i.every((r) => t.indexOf(r) !== -1) && (e = s);
    }), e;
  }
  /**
   * This will generate a unique id to associate a group of handles with a group of NodeIds.
   */
  generateGroupId() {
    return this._groupIdCount++;
  }
  _massageGroupId(t) {
    return t ?? _i.defaultGroupId;
  }
  /**
   * Adds a handle that moves along an axis.
   * @param position center of the handle.
   * @param axis axis to move along
   * @param color color of the handle geometry
   * @param positionNormal optional vector to control the orientation of the handle geometry.
   * @param groupId optional parameter to associate this handle with a group of NodeIds
   */
  async addAxisTranslationHandle(t, e, i, s = null, r = null) {
    return this._previousContextClick = !1, this._guardEnabled(), this._handleMarkup.addAxisTranslationHandle(
      t,
      e,
      i,
      s,
      this._massageGroupId(r)
    );
  }
  /**
   * Adds a handle that rotates around an axis
   * @param position center of the handle.
   * @param axis axis to rotate around
   * @param color color of the handle geometry
   * @param positionNormal optional vector to control the orientation of the handle geometry.
   * @param groupId optional parameter to associate this handle with a group of NodeIds
   */
  async addAxisRotationHandle(t, e, i, s = null, r = null) {
    return this._previousContextClick = !1, this._guardEnabled(), this._handleMarkup.addRotateHandle(
      t,
      e,
      i,
      s,
      this._massageGroupId(r)
    );
  }
  /**
   * Adds a handle that restricts movement to a plane.
   * @param position center of the handle.
   * @param normal normal of the plane
   * @param faceColor face color of the handle geometry
   * @param lineColor outline color of the handle geometry
   * @param positionNormal optional vector to control the orientation of the handle geometry.
   * @param groupId optional parameter to associate this handle with a group of NodeIds
   */
  async addPlaneTranslationHandle(t, e, i, s, r = null, o = null) {
    return this._previousContextClick = !1, this._guardEnabled(), this._handleMarkup.addPlaneTranslationHandle(
      t,
      e,
      i,
      s,
      r,
      this._massageGroupId(o)
    );
  }
  /**
   * Adds a handle that restricts movement to the viewplane.
   * @param position center of the handle
   * @param color geometry color
   * @param groupId optional parameter to associate this handle with a group of NodeIds
   */
  async addViewPlaneTranslationHandle(t, e, i = null) {
    return this._previousContextClick = !1, this._guardEnabled(), this._handleMarkup.addViewPlaneHandle(t, e, this._massageGroupId(i));
  }
  /**
   * Sets the NodeIds that any handles in the scene will move.
   * @param nodeIds
   * @param groupId optional parameter that associates a group of NodeIds with a group of handles.
   */
  setNodeIds(t, e = null) {
    this._nodeIdGroupMap.set(this._massageGroupId(e), t);
  }
  /**
   * Gets the NodeIds that the handles in the scene will move.
   * @param groupId optional paramater that specifies if the NodeIds to retrieve are part of a group.
   */
  getNodeIds(t = null) {
    const e = this._nodeIdGroupMap.get(this._massageGroupId(t));
    return e === void 0 ? [] : e.slice();
  }
  /**
   * Shows any handles that have been added to the scene.
   */
  showHandles() {
    this._handleMarkup.showOverlay();
  }
  /**
   * Updates the current handle position.
   * @param translation additional translation
   * @param rotation additional rotation
   * @param finalizePosition keep translation and rotation. If true, added translation and rotation
   * will not reset the next time the position is updated.
   */
  updatePosition(t, e, i, s = null) {
    return this._handleMarkup.updatePosition(
      t,
      e,
      i,
      this._massageGroupId(s),
      this._activeChildrenGroupIds
    );
  }
  /**
   * @returns the current handle position or null if not currently active.
   */
  getPosition() {
    const t = this._handleMarkup.getHandleNodeIds();
    if (t.length > 0) {
      const e = this._handleMarkup.getPosition(t[0]);
      if (e !== null)
        return e.copy();
    }
    return null;
  }
  /**
   * Removes all handles from the scene.
   */
  removeHandles() {
    return this._newRotationMatrix = new Q(), this._translation = d.zero(), this._highlightedHandleId = null, this._nodeIdGroupMap.clear(), this._groupIdCount = 0, this._handleMarkup.removeHandles();
  }
  /**
   * @returns the total translation applied to the handles.
   */
  getTranslation() {
    return this._translation;
  }
  _initLocalNodeMatrices(t) {
    const e = this._viewer.model;
    this._initialLocalNodeMatrices = [];
    for (const i of t)
      this._initialLocalNodeMatrices.push(e.getNodeMatrix(i));
  }
  _getHandleEventType(t) {
    return this._handleMarkup.getHandleType(t) === Bn.Rotate ? ws.Rotate : ws.Translate;
  }
  async _rotate(t, e, i, s) {
    if (!this._draggingHandle || this._settingMatrixInProgress)
      return;
    const r = this.getNodeIds(s);
    await this._genericTransform(
      t,
      e,
      d.zero(),
      i,
      r,
      s
    ), this._viewer.trigger(
      "handleEvent",
      ws.Rotate,
      r,
      this._initialLocalNodeMatrices,
      this._newLocalNodeMatrices
    );
  }
  async _translate(t, e, i) {
    if (!this._draggingHandle || this._settingMatrixInProgress)
      return;
    const s = this.getNodeIds(i);
    await this._genericTransform(d.zero(), 0, t, e, s, i), this._viewer.trigger(
      "handleEvent",
      ws.Translate,
      s,
      this._initialLocalNodeMatrices,
      this._newLocalNodeMatrices
    );
  }
  async _genericTransform(t, e, i, s, r, o) {
    this._settingMatrixInProgress = !0;
    const a = this._viewer.model;
    let l = new Q();
    this._newTranslation = i, t.squaredLength() > 0 && (l = this._getRotationMatrix(t, d.zero(), e), this._newRotationMatrix = l.copy());
    const c = [];
    c.push(this.updatePosition(this._newTranslation, this._newRotationMatrix, !1, o)), this._newLocalNodeMatrices = [];
    for (let u = 0; u < r.length; u++) {
      const p = this._newTranslation.copy(), m = r[u];
      let g = this._initialLocalNodeMatrices[u].copy();
      const _ = t.copy(), y = s.copy();
      let b;
      const w = a.getNodeParent(m);
      if (w !== null) {
        b = a.getNodeNetMatrix(w);
        const v = Q.inverse(b);
        v !== null && (v.transform(y, y), v.setTranslationComponent(0, 0, 0), v.transform(_, _), v.transform(p, p));
      } else
        b = null;
      t.squaredLength() > 0 && (l = this._getRotationMatrix(
        _,
        y,
        b && b.upperLeft3x3Determinant() < 0 ? -e : e
      ), g = Q.multiply(g, l)), g.setTranslationComponent(
        g.m[12] + p.x,
        g.m[13] + p.y,
        g.m[14] + p.z
      ), c.push(a.setNodeMatrix(m, g)), this._newLocalNodeMatrices.push(g);
    }
    const h = this._newRotationMatrix.copy();
    h.setTranslationComponent(i.x, i.y, i.z);
    for (let u = 0; u < this._trackedPoints.length; ++u) {
      const p = this._trackedPoints[u].copy(), m = d.subtract(p, s);
      h.transform(m, m);
      const g = d.add(m, s);
      this._trackedPointsPositions[u] = g;
    }
    await zt(c), this._settingMatrixInProgress = !1;
  }
  /** @hidden */
  async _testRotate(t, e, i = null) {
    i = this._massageGroupId(i);
    const s = this._getActiveNodeIdByGroupId(i);
    if (s !== null) {
      const r = this._handleMarkup.getPosition(s);
      if (r === null)
        return;
      this._startDragging(s, ws.Rotate), await this._rotate(t, e, r, i), await this._stopDragging();
    }
  }
  /** @hidden */
  async _testTranslate(t, e = null) {
    e = this._massageGroupId(e);
    const i = this._getActiveNodeIdByGroupId(e);
    i !== null && (this._startDragging(i, ws.Translate), await this._translate(t, d.zero(), e), await this._stopDragging());
  }
  _getActiveNodeIdByGroupId(t) {
    const e = this._handleMarkup.getHandleNodeIds();
    for (let i = 0; i < e.length; ++i) {
      const s = e[i];
      if (this._handleMarkup.getHandleGroupId(s) === t)
        return s;
    }
    return null;
  }
  _startDragging(t, e) {
    this._activeHandleNodeId = t, this._handleEventType = e;
    const i = this._handleMarkup.getHandleGroupId(t), s = this.getNodeIds(i), r = /* @__PURE__ */ new Map();
    this._nodeIdGroupMap.forEach((o, a) => {
      a !== i && o.forEach((l) => {
        let c = this._viewer.model.getNodeParent(l);
        for (; c !== null; ) {
          if (s.indexOf(c) !== -1) {
            r.set(a, l);
            break;
          }
          c = this._viewer.model.getNodeParent(c);
        }
      });
    }), this._activeChildrenGroupIds = r, s.length > 0 && (this._initLocalNodeMatrices(s), this._viewer.trigger(
      "handleEventStart",
      this._handleEventType,
      s,
      this._initialLocalNodeMatrices
    ), this._draggingHandle = !0);
  }
  async _stopDragging() {
    if (this._draggingHandle = !1, this._activeHandleNodeId !== null) {
      const t = this._handleMarkup.getHandleGroupId(this._activeHandleNodeId);
      await this.updatePosition(this._newTranslation, this._newRotationMatrix, !0, t);
      const e = this.getNodeIds(t);
      this._activeHandleNodeId = null, this._activeChildrenGroupIds.clear(), this._viewer.trigger(
        "handleEventEnd",
        this._handleEventType,
        e,
        this._initialLocalNodeMatrices,
        this._newLocalNodeMatrices
      ), this._newRotationMatrix = new Q(), this._handleMarkup.resetTranslation(), this._translation.add(this._newTranslation), this._newTranslation = d.zero(), this._trackedPoints = this._trackedPointsPositions.slice();
    }
  }
  /** @hidden */
  async onMouseDown(t) {
    super.onMouseDown(t), this._overlayIndex = null;
    const e = await this._viewer.view.pickFromPoint(t.getPosition(), this._pickConfig);
    if (e.isNodeEntitySelection()) {
      const i = e.getNodeId(), s = this._viewer.model.getNodeName(i);
      if (s !== null && s.slice(0, 7) === "handle-") {
        t.setHandled(!0);
        const r = this._getHandleEventType(i);
        this._startDragging(i, r);
      }
    }
  }
  _onHandleDrag() {
    if (this._activeHandleNodeId === null)
      return;
    const e = this._viewer.view.getCamera();
    let i = 0, s = d.zero(), r = d.zero();
    const o = this._handleMarkup.getHandleType(this._activeHandleNodeId), a = this._handleMarkup.getVector(this._activeHandleNodeId), l = this._handleMarkup.getPosition(this._activeHandleNodeId);
    if (o === null || l === null)
      return;
    const c = this._handleMarkup.getHandleGroupId(this._activeHandleNodeId);
    switch (o) {
      case Bn.Axis:
        a !== null && (r = this._getTranslationComponent(
          l,
          a,
          0,
          c
        ), this._translate(r, l, c));
        break;
      case Bn.Plane:
        a !== null && (r = this._getTranslationComponent(
          l,
          a,
          1,
          c
        ), this._translate(r, l, c));
        break;
      case Bn.ViewPlane:
        {
          const h = e.getTarget(), u = e.getPosition(), p = d.subtract(u, h).normalize();
          r = this._getTranslationComponent(
            l,
            p,
            2,
            c
          ), this._translate(r, l, c);
        }
        break;
      case Bn.Rotate:
        a !== null && (s = a, this._handleMarkup.getGroupIdRotationMatrix(c).copy().setTranslationComponent(0, 0, 0).transform(s, s), i = this._getRotationAngle(l, s), this._rotate(s, i, l, c));
        break;
      default:
        $n();
    }
  }
  /** @hidden */
  async onMouseMove(t) {
    if (super.onMouseMove(t), this._draggingHandle && this._activeHandleNodeId !== null)
      this._onHandleDrag();
    else {
      const e = await this._viewer.view.pickFromPoint(
        t.getPosition(),
        this._pickConfig
      );
      await this._highlightHandle(e);
    }
  }
  /** @hidden */
  onMouseUp(t) {
    !this._draggingHandle && this._dragCount < 3 && t.getButton() !== Kt.Right && !this._previousContextClick && !this._viewer.getContextMenuStatus() && (this._overlayIndex === 0 || this._overlayIndex === null) && this.removeHandles(), this._previousContextClick = t.getButton() === Kt.Right || this._viewer.getContextMenuStatus(), this._draggingHandle && this._stopDragging(), super.onMouseUp(t);
  }
  /** @hidden */
  setHandled() {
    return this._draggingHandle;
  }
  _getClosestPoint(t, e, i) {
    const s = t.copy(), r = t.copy().add(e), o = this._viewer.view.unprojectPoint(i, 0), a = this._viewer.view.unprojectPoint(i, 0.5);
    return o !== null && a !== null ? ju(s, r, o, a) : null;
  }
  _getTranslationComponent(t, e, i, s) {
    i !== 2 && this._handleMarkup.getGroupIdRotationMatrix(s).copy().setTranslationComponent(0, 0, 0).transform(e, e);
    let r = null, o = null;
    return i === 1 || i === 2 ? (r = this._getPlaneIntersectionPoint(t, e, this._ptFirst), r !== null && (o = this._getPlaneIntersectionPoint(r, e, this._ptCurrent))) : i === 0 && (r = this._getClosestPoint(t, e, this._ptFirst), r !== null && (o = this._getClosestPoint(r, e, this._ptCurrent))), o !== null && r !== null ? d.subtract(o, r) : d.zero();
  }
  async _clearHighlightedHandle() {
    this._highlightedHandleId !== null && (await this._viewer.model.unsetNodesFaceColor([this._highlightedHandleId]), this._highlightedHandleId = null);
  }
  async _highlightHandle(t) {
    if (t.isNodeEntitySelection() && t.overlayIndex() === Vt.Handles) {
      const e = this._viewer.model, i = e.getNodeName(t.getNodeId());
      if (i !== null && i.slice(0, 7) === "handle-") {
        const s = t.getNodeId();
        if (this._highlightedHandleId === s)
          return;
        await this._clearHighlightedHandle(), this._highlightedHandleId = s, e.setNodesFaceColor([this._highlightedHandleId], it.green());
        return;
      }
    }
    return this._clearHighlightedHandle();
  }
  _getPlaneIntersectionPoint(t, e, i) {
    const s = this._viewer.view.unprojectPoint(i, 0), r = this._viewer.view.unprojectPoint(i, 0.5);
    if (s === null || r === null)
      return null;
    const o = new Vn(s, r.copy().subtract(s)), a = je.createFromPointAndNormal(t, e), l = d.zero();
    return a.intersectsRay(o, l) ? l : null;
  }
  _getRotationAngle(t, e) {
    console.assert(t !== null);
    const i = this._getPlaneIntersectionPoint(
      t,
      e,
      this._ptFirst
    ), s = this._getPlaneIntersectionPoint(
      t,
      e,
      this._ptCurrent
    );
    if (i === null || s === null)
      return 0;
    const r = d.subtract(i, t).normalize(), o = d.subtract(s, t).normalize(), a = d.dot(r, o);
    let l = Math.acos(a) * 180 / Math.PI;
    return d.dot(d.cross(r, o), e) < 0 && (l = -l), l;
  }
  _getRotationMatrix(t, e, i) {
    const s = new Q().setTranslationComponent(
      -e.x,
      -e.y,
      -e.z
    ), r = Q.createFromOffAxisRotation(t, i), o = new Q().setTranslationComponent(
      e.x,
      e.y,
      e.z
    );
    return Q.multiply(
      Q.multiply(s, r),
      o
    );
  }
}
class hp extends Se {
  /** @hidden */
  constructor(t) {
    super(t), this._navCube = t.view.getNavCube(), this._pickConfig = new Ie(Xt.Face), this._pickConfig.restrictToOverlays = !0;
  }
  /** @hidden */
  async onMouseMove(t) {
    super.onMouseMove(t);
    const e = t.getPosition(), i = this._dragging && this._dragCount > 1;
    if (this._navCube.getEnabled() && !i && this._navCube.insideOverlay(e)) {
      const s = await this._viewer.view.pickFromPoint(e, this._pickConfig);
      this._navCube.onMoveSelection(s);
    }
  }
  /** @hidden */
  async onMouseUp(t) {
    if (this._navCube.getEnabled() && E.subtract(this._ptFirst, this._ptCurrent).squaredLength() < 25) {
      const e = await this._viewer.view.pickFromPoint(this._ptFirst, this._pickConfig);
      await this._navCube.onClickSelection(e);
    }
    super.onMouseUp(t);
  }
}
class up extends Se {
  /** @hidden */
  constructor(t, e) {
    super(t), this._insertNoteButton = Kt.Left, this._callbackFlag = !1, this._noteTextManager = e;
  }
  /** @hidden */
  onMouseDown(t) {
    super.onMouseDown(t), this.isActive() && (this._callbackFlag || (this._viewer.setCallbacks({
      explode: async (e) => {
        await this._noteTextManager.explode(e);
      }
    }), this._callbackFlag = !0), this._dragging = !1);
  }
  /** @hidden */
  onMouseUp(t) {
    if (this.isActive()) {
      const e = new Ie(Xt.Face);
      (this._ptFirst.equals(this._ptCurrent) && t.getButton() === this._insertNoteButton || this._primaryTouchId !== null) && this._viewer.view.pickFromPoint(t.getPosition(), e).then((i) => {
        if (!this._noteTextManager.selectPin(i) && !this._noteTextManager.getExplodeActive() && !this._noteTextManager.getIsolateActive() && i.overlayIndex() === 0) {
          if (i.isFaceSelection())
            return new Jr(
              this._viewer,
              this._noteTextManager,
              i.getPosition(),
              i.getFaceEntity().getNormal(),
              i.getNodeId()
            );
          t.setHandled(!0);
        }
        return null;
      });
    }
    super.onMouseUp(t);
  }
  /**
   * @returns a NoteTextElement that can be used to configure the NoteText HTML container.
   */
  getNoteTextElement() {
    return this._noteTextManager.getNoteTextElement();
  }
  /**
   * @param noteTextElement
   */
  setNoteTextElement(t) {
    this._noteTextManager.setNoteTextElement(t);
  }
  /**
   * Returns true if the nodeId is the id of a note pin instance.
   * @param nodeId
   */
  checkPinInstance(t) {
    return this._noteTextManager.checkPinInstance(t) !== null;
  }
}
class dp extends Se {
  /** @hidden */
  constructor(t) {
    super(t), this._selectionButton = Kt.Left, this._ignoreTransparency = !1, this._forceEffectiveSceneVisibilityMask = Xt.None, this._incrementalSelection = Va.create("SelectionManager", t), t.setCallbacks({
      _resetAssemblyTreeBegin: async () => (await this.clearSelection(), this.waitForIdle()),
      selectionArray: (e) => {
        e.length === 0 && this._incrementalSelection.stopSelection();
      }
    });
  }
  /**
   * Gets the mask used for forcing effective scene visibility during selection.
   */
  getForceEffectiveSceneVisibilityMask() {
    return this._forceEffectiveSceneVisibilityMask;
  }
  /**
   * Sets the mask used for forcing effective scene visibility during selection.
   */
  setForceEffectiveSceneVisibilityMask(t) {
    this._forceEffectiveSceneVisibilityMask = t;
  }
  setIgnoreTransparency(t) {
    this._ignoreTransparency = t;
  }
  getIgnoreTransparency() {
    return this._ignoreTransparency;
  }
  hasActiveSelection() {
    return !this._incrementalSelection.isIdle();
  }
  async waitForIdle() {
    return this._incrementalSelection.waitForIdle();
  }
  async clearSelection() {
    return this._incrementalSelection.clearSelection();
  }
  _createBeginConfig(t) {
    const e = new Dl();
    return e.forceEffectiveSceneVisibilityMask = this._forceEffectiveSceneVisibilityMask, e.ignoreUnrequestedInstances = !0, {
      pickConfig: e,
      rayCssOrigin: t,
      rayCssBoxRadius: 10
    };
  }
  async _selectionPredicate(t) {
    const e = this._viewer.model, i = t.getNodeId();
    if (i === null)
      return !1;
    const [s] = await e.getNodesHaveTransparency([i]);
    return !s;
  }
  async _performSelection(t) {
    const e = this._createBeginConfig(t), i = this._ignoreTransparency ? (s) => this._selectionPredicate(s) : null;
    return this._incrementalSelection.performSelection(e, i);
  }
  ///////////////////////////////////////////////////////////////////////////////////
  /** @hidden */
  setHandled() {
    return !0;
  }
  /** @hidden */
  onKeyUp(t) {
    t.getKeyCode() === Ut.Escape && this.clearSelection();
  }
  /** @hidden */
  onMouseUp(t) {
    this.isActive() && (async () => (t.getButton() === this._selectionButton || this._primaryTouchId !== null) && E.subtract(this._ptFirst, this._ptCurrent).squaredLength() < 25 && (t.controlDown() || await this.clearSelection(), await this._performSelection(t.getPosition())))(), super.onMouseUp(t);
  }
}
class mp extends Se {
  /** @hidden */
  constructor(t, e) {
    super(t), this._selectionButton = Kt.Left, this._pickConfig = new Ie(Xt.Face | Xt.Line), this._forceEffectiveSceneVisibilityMask = null, this._doubleClickFitWorld = !0, this._noteTextManager = e;
  }
  /** Sets the [[PickConfig]] that will be passed to [[View.pickFromPoint]]. */
  setPickConfig(t) {
    this._pickConfig = t.copy();
  }
  /** Returns the [[PickConfig]] that will be passed to [[View.pickFromPoint]]. */
  getPickConfig() {
    return this._pickConfig.copy();
  }
  /**
   * Gets the button used for selection.
   * @returns Button
   */
  getSelectionButton() {
    return this._selectionButton;
  }
  /**
   * Sets the button used for selection
   * @param button
   */
  setSelectionButton(t) {
    this._selectionButton = t;
  }
  /** @hidden */
  onKeyUp(t) {
    t.getKeyCode() === Ut.Escape && this._viewer.selectionManager.clear();
  }
  /** @hidden */
  onMouseUp(t) {
    if (this.isActive() && E.subtract(this._ptFirst, this._ptCurrent).length() < 5 && (t.getButton() === this._selectionButton || this._primaryTouchId !== null)) {
      const i = this._viewer.view;
      let s = this._pickConfig;
      this._forceEffectiveSceneVisibilityMask !== null && (s = s.copy(), s.forceEffectiveSceneVisibilityMask = this._forceEffectiveSceneVisibilityMask), i.pickFromPoint(this._ptCurrent, s).then((r) => {
        const a = this._viewer.cuttingManager.getCuttingSectionFromNodeId(r.getNodeId()) !== null, l = this._noteTextManager.selectPin(r), c = this._viewer.markupManager.pickMarkupItem(this._ptCurrent);
        c instanceof Ls && this._viewer.markupManager.selectMarkup(c), !l && !a && c === null && (r.isNodeSelection() ? this._processSelectionClick(t, r) : this._isDoubleClick || this._viewer.selectionManager.clear());
      });
    }
    super.onMouseUp(t);
  }
  /** @hidden */
  async onDoubleClick() {
    if (this._doubleClickFitWorld)
      return this._viewer.view.fitWorld();
  }
  /**
   * When enabled, a double click will fit the view to the model bounding box.
   * @param doubleClickFitWorld
   */
  setDoubleClickFitWorldEnabled(t) {
    this._doubleClickFitWorld = t;
  }
  // helper function to get the parent selection item if the part is already selected
  _getSelectionOrParentIfSelected(t) {
    const e = this._viewer.selectionManager;
    if (!e.getSelectParentIfSelected())
      return t;
    const i = this._viewer.model, s = t.getNodeId();
    if (!i.isNodeLoaded(s) || i.getNodeType(s) === At.PmiBody)
      return t;
    const o = e.containsParent(t);
    if (o !== null) {
      const a = de.create(i.getNodeParent(o.getNodeId()));
      return a.isNodeSelection() ? a : t;
    } else if (e.contains(t)) {
      const a = de.create(i.getNodeParent(s));
      return a.isNodeSelection() ? a : t;
    } else
      return t;
  }
  _processSelectionClick(t, e) {
    const i = e.overlayIndex();
    if (i !== 0 && i !== null)
      return;
    const s = this._viewer.selectionManager;
    if (t.controlDown() || t.commandDown())
      s.toggle(e);
    else {
      const r = this._getSelectionOrParentIfSelected(e);
      s.set(r);
    }
  }
}
const ly = `/**
 * @license 3DconnexionJS
 *
 * Copyright (c) 2013-2020 3Dconnexion. All rights reserved.
 * License:
 *   This file is licensed under the terms of the "3Dconnexion
 *   Software Development Kit" license agreement:
 *   http://www.3dconnexion.com/service/software-developer/licence-agreement.html
 *   All rights not expressly granted by 3Dconnexion are reserved.
 *
 * $Revision: 17564 $
 */
var when, CryptoJS, AUTOBAHNJS_VERSION, global;
var _3Dconnexion = function (n) {
  'use strict';
  this.version = '0.6.1';
  this.client = n;
  this.session = null;
  this.defport = 8181;
  this.connected = !1;
  this.connexion = null;
  this._3dcontroller = null;
  this.viewport = null;
  this.host = '127.51.68.120';
  this.nlRpcUri = null;
  this.nlResourceUri = null;
  this._EVENT_TYPEID_RPC = 0;
  this.V3DK_FIT = 31;
  this.V3DK_MENU = 30;
  this.fnUpdate = {
    motion: this.onMotion.bind(this),
    'events.keyPress': this.onKeyPress.bind(this),
    'events.keyRelease': this.onKeyRelease.bind(this),
  };
  this.clientFnRead = {
    'view.affine': n.getViewMatrix,
    'view.constructionPlane': n.getConstructionPlane,
    'view.extents': n.getViewExtents,
    'view.fov': n.getFov,
    'view.frustum': n.getViewFrustum,
    'view.perspective': n.getPerspective,
    'view.target': n.getViewTarget,
    'view.rotatable': n.getViewRotatable,
    'model.extents': n.getModelExtents,
    'pivot.position': n.getPivotPosition,
    'hit.lookat': n.getLookAt,
    'selection.affine': n.getSelectionAffine,
    'selection.empty': n.getSelectionEmpty,
    'selection.extents': n.getSelectionExtents,
    'pointer.position': n.getPointerPosition,
    coordinateSystem: n.getCoordinateSystem,
    'views.front': n.getFrontView,
    'frame.timingSource': n.getFrameTimingSource,
    'frame.time': n.getFrameTime,
  };
  this.clientFnUpdate = {
    motion: n.setMoving,
    transaction: n.setTransaction,
    'view.affine': n.setViewMatrix,
    'view.extents': n.setViewExtents,
    'view.fov': n.setFov,
    'view.target': n.setTarget,
    'commands.activeCommand': n.setActiveCommand,
    'pivot.position': n.setPivotPosition,
    'pivot.visible': n.setPivotVisible,
    'hit.lookfrom': n.setLookFrom,
    'hit.direction': n.setLookDirection,
    'hit.aperture': n.setLookAperture,
    'hit.selectionOnly': n.setSelectionOnly,
    'selection.affine': n.setSelectionAffine,
    'events.keyPress': n.setKeyPress,
    'events.keyRelease': n.setKeyRelease,
    'settings.changed': n.setSettingsChanged,
  };
  this.debug = !1;
  window.hasOwnProperty('_3DCONNEXION_DEBUG') && (this.debug = window._3DCONNEXION_DEBUG);
  this.blur = this.blur.bind(this);
  this.focus = this.focus.bind(this);
};
typeof module == 'object' && (module.exports = _3Dconnexion);
_3Dconnexion.prototype = { constructor: _3Dconnexion };
Object.freeze((_3Dconnexion.nlOptions = { none: 0, rowMajorOrder: 2 }));
_3Dconnexion.prototype.connect = function () {
  'use strict';
  var n = this,
    e = this.client,
    u = 1,
    t = new XMLHttpRequest(),
    f,
    r,
    i;
  if (!e.onConnect) throw 'onConnect handler required!';
  i = 'https://' + n.host + ':' + n.defport + '/3dconnexion/nlproxy';
  t.onreadystatechange = function () {
    if (t.readyState === 4 && t.status === 200) {
      n.debug && console.log(t.responseText);
      n.nlRpcUri = 'wss://' + n.host + '/3dconnexion#';
      n.nlResourceUri = 'wss://' + n.host + '/3dconnexion';
      try {
        f = JSON.parse(t.responseText).port;
        r = 'wss://' + n.host + ':' + f;
        n.debug && console.log('Connecting to ' + r + ' ...');
        window.hasOwnProperty('AUTOBAHN_DEBUG') &&
          window.AUTOBAHN_DEBUG &&
          window.ab.debug(!0, !0, !0);
        window.ab.connect(
          r,
          function (t) {
            n.session = t;
            n.connected = !0;
            n.debug && console.log('Connected!');
            t.prefix('3dx_rpc', n.nlRpcUri);
            t.prefix('3dconnexion', n.nlResourceUri);
            t.prefix('self', window.location.href);
            n.client.onConnect();
          },
          function (t, i) {
            if (n.client.onDisconnect !== undefined) n.client.onDisconnect(i);
            n.delete3dmouse();
            n.connected = !1;
            n.session = null;
            n.debug && console.log('Socket closed!', i);
          },
          { maxRetries: 3, retryDelay: 500 }
        );
      } catch (i) {
        console.error(i);
      }
    }
  };
  t.onerror = function () {
    n.debug && console.log('_3Dconnexion.connect: No response from local 3dmouse server ' + i);
  };
  t.ontimeout = function () {
    n.debug && console.log('_3Dconnexion.connect: Timeout querying local 3dmouse server ' + i);
  };
  try {
    t.open('GET', i, !0);
    t.setRequestHeader('Accept', 'application/json; charset=utf-8');
    t.msCaching = 'disabled';
    t.timeout = 0;
    t.send();
  } catch (o) {
    u = 0;
    console.error(o.toString());
  }
  return u;
};
_3Dconnexion.prototype.create3dmouse = function (n, t, i) {
  'use strict';
  i = typeof i != 'undefined' ? i : _3Dconnexion.nlOptions.none;
  var r = this;
  r.viewport = n;
  r.debug && console.log('create3dmouse ' + r.viewport.id);
  r.viewport.addEventListener('focus', r.focus);
  r.viewport.addEventListener('blur', r.blur);
  r.session.call('3dx_rpc:create', '3dconnexion:3dmouse', r.version).then(
    function (n) {
      r.connexion = n.connexion;
      var u = {
        version: parseFloat(r.version),
        name: t,
        rowMajorOrder: (i & _3Dconnexion.nlOptions.rowMajorOrder) != 0,
      };
      r.session.call('3dx_rpc:create', '3dconnexion:3dcontroller', r.connexion, u).then(
        function (n) {
          r._3dcontroller = n.instance;
          r.session.subscribe('3dconnexion:3dcontroller/' + r._3dcontroller, r.onEvent.bind(r));
          document.hasFocus() &&
            (document.activeElement === document.body || document.activeElement === null
              ? (r.viewport.focus(), window === r.viewport && r.focus())
              : r.viewport.contains(document.activeElement) &&
                (r.focus(), r.debug && console.log('self.viewport has focus')));
          r.client.on3dmouseCreated && r.client.on3dmouseCreated();
        },
        function (n) {
          console.log('3dx_rpc:create 3dconnexion:3dcontroller ' + n);
        }
      );
    },
    function (n) {
      console.log('3dx_rpc:create ' + n);
    }
  );
};
_3Dconnexion.prototype.blur = function () {
  'use strict';
  var n = this;
  n.debug && console.log('blur on ');
  n.session && n._3dcontroller && n.update3dcontroller({ focus: !1 });
};
_3Dconnexion.prototype.focus = function () {
  'use strict';
  var n = this;
  n.debug && console.log('focus on ');
  n.session && n._3dcontroller && n.update3dcontroller({ focus: !0 });
};
_3Dconnexion.prototype.onKeyPress = function (n) {
  'use strict';
  var t = this;
  t.debug && console.log('onKeyPress ' + n);
};
_3Dconnexion.prototype.onKeyRelease = function (n) {
  'use strict';
  var t = this;
  t.debug && console.log('onKeyRelease ' + n);
};
_3Dconnexion.prototype.onMotion = function (n) {
  'use strict';
  var t = this;
  n === !0
    ? t.client.onStartMotion !== undefined && t.client.onStartMotion()
    : t.client.onStopMotion !== undefined && t.client.onStopMotion();
};
_3Dconnexion.prototype.onEvent = function (n, t) {
  'use strict';
  var i = this,
    f = null,
    r = null,
    u = null;
  if ((i.debug && (console.log(n), console.log(t)), t[0] === window.ab._MESSAGE_TYPEID_CALL)) {
    if (t[2] === 'self:read')
      if (((r = i.clientFnRead[t[4]]), r !== undefined)) f = r.bind(i.client)();
      else {
        u = [
          window.ab._MESSAGE_TYPEID_CALL_ERROR,
          t[1],
          t[2] + '#generic',
          t[4] + ' unknown property',
        ];
        i.session._send(u);
        return;
      }
    else if (t[2] === 'self:update')
      if (((r = i.fnUpdate[t[4]]), r !== undefined)) f = r(t[5]);
      else if (((r = i.clientFnUpdate[t[4]]), r !== undefined)) f = r.bind(i.client)(t[5]);
      else {
        u = [
          window.ab._MESSAGE_TYPEID_CALL_ERROR,
          t[1],
          t[2] + '#generic',
          t[4] + ' unknown property',
        ];
        i.session._send(u);
        return;
      }
    else {
      u = [window.ab._MESSAGE_TYPEID_CALL_ERROR, t[1], t[2] + '#generic', 'unknown procedure'];
      i.session._send(u);
      return;
    }
    u = [window.ab._MESSAGE_TYPEID_CALL_RESULT, t[1], f];
    i.session._send(u);
  }
};
_3Dconnexion.prototype.read3dcontroller = function (n, t) {
  'use strict';
  var i = this;
  i.debug && console.log('read3dcontroller ' + i._3dcontroller);
  try {
    i.session.call('3dx_rpc:read', '3dconnexion:3dcontroller/' + i._3dcontroller, n).then(
      function (n) {
        t && t(n);
      },
      function (t) {
        console.log('3dx_rpc:read 3dconnexion:3dcontroller/' + i._3dcontroller + ' ' + n + ' ' + t);
      }
    );
  } catch (r) {
    console.error(r);
  }
};
_3Dconnexion.prototype.update3dcontroller = function (n) {
  'use strict';
  var t = this;
  t.debug && console.log('update3dmouse ' + t._3dcontroller);
  try {
    if (!t._3dcontroller) throw 'exception 3dx_rpc:update: 3dcontroller not initialized';
    t.session.call('3dx_rpc:update', '3dconnexion:3dcontroller/' + t._3dcontroller, n).then(
      function () {
        return;
      },
      function (n) {
        console.log('3dx_rpc:update 3dconnexion:3dcontroller/' + t._3dcontroller + ' ' + n);
      }
    );
  } catch (i) {
    console.error(i);
  }
};
_3Dconnexion.prototype.delete3dmouse = function () {
  'use strict';
  var n = this,
    t = n.connexion;
  n.debug && console.log('delete3dmouse ');
  n.connexion = null;
  n._3dcontroller = null;
  n.viewport !== null &&
    (n.viewport.removeEventListener('focus', n.focus),
    n.viewport.removeEventListener('blur', n.blur));
  n.session &&
    n.session.call('3dx_rpc:delete', '3dconnexion:3dmouse/' + t).then(
      function () {
        n.debug && console.log('deleted connexion ' + t);
      },
      function (n) {
        console.log('3dx_rpc:delete ' + t + ' ' + n);
      }
    );
};
Object.freeze(
  (_3Dconnexion.SiActionNodeType_t = {
    SI_ACTIONSET_NODE: 0,
    SI_CATEGORY_NODE: 1,
    SI_ACTION_NODE: 2,
  })
);
_3Dconnexion.ActionNode = function (n, t, i) {
  return (this.id = n), (this.label = t || n), (this.type = i), this;
};
_3Dconnexion.ActionNode.prototype = {
  constructor: _3Dconnexion.ActionNode,
  id: { value: null, enumerable: !0 },
  label: { value: null, writable: !0, enumerable: !0 },
  type: { value: null, enumerable: !0 },
};
_3Dconnexion.Action = function (n, t, i) {
  return (
    _3Dconnexion.ActionNode.call(this, n, t, _3Dconnexion.SiActionNodeType_t.SI_ACTION_NODE),
    (this.description = i || ''),
    this
  );
};
_3Dconnexion.Action.prototype = Object.create(_3Dconnexion.ActionNode.prototype, {
  constructor: { value: _3Dconnexion.Action },
  description: { value: '', writable: !0, enumerable: !0 },
});
_3Dconnexion.ActionTreeNode = function () {
  return (this.nodes = []), this;
};
_3Dconnexion.ActionTreeNode.prototype = Object.create(_3Dconnexion.ActionNode.prototype, {
  constructor: { value: _3Dconnexion.ActionTreeNode },
  nodes: { value: null, writable: !0, enumerable: !0 },
  push: {
    value: function (n) {
      return this.nodes.push(n), n;
    },
  },
});
_3Dconnexion.ActionSet = function (n, t) {
  return (
    _3Dconnexion.ActionNode.call(this, n, t, _3Dconnexion.SiActionNodeType_t.SI_ACTIONSET_NODE),
    _3Dconnexion.ActionTreeNode.call(this),
    this
  );
};
_3Dconnexion.ActionSet.prototype = Object.create(_3Dconnexion.ActionTreeNode.prototype, {
  constructor: { value: _3Dconnexion.ActionSet },
});
_3Dconnexion.Category = function (n, t) {
  return (
    _3Dconnexion.ActionNode.call(this, n, t, _3Dconnexion.SiActionNodeType_t.SI_CATEGORY_NODE),
    _3Dconnexion.ActionTreeNode.call(this),
    this
  );
};
_3Dconnexion.Category.prototype = Object.create(_3Dconnexion.ActionTreeNode.prototype, {
  constructor: { value: _3Dconnexion.Category },
});
_3Dconnexion.ActionTree = function () {
  return (this.nodes = []), this;
};
_3Dconnexion.ActionTree.prototype = Object.create(null, {
  constructor: { value: _3Dconnexion.ActionTree },
  nodes: { value: null, writable: !0, enumerable: !0 },
  push: {
    value: function (n) {
      return this.nodes.push(n), n;
    },
  },
});
_3Dconnexion.ImageItem = function () {};
Object.freeze(
  (_3Dconnexion.SiImageType_t = {
    e_none: 0,
    e_image_file: 1,
    e_resource_file: 2,
    e_image: 3,
  })
);
_3Dconnexion.ImageItem.prototype = {
  constructor: _3Dconnexion.ImageItem,
  id: { value: '', writable: !0 },
  type: { value: 'e_none', enumerable: !0 },
};
_3Dconnexion.ImageItem.fromImage = function (n, t) {
  var i = new _3Dconnexion.ImageItem();
  return Object.defineProperties(i, {
    id: { value: t || '', writable: !0, enumerable: !0 },
    type: { value: _3Dconnexion.SiImageType_t.e_image, enumerable: !0 },
    index: { value: 0, writable: !0, enumerable: !0 },
    data: {
      value: _3Dconnexion.ImageItem.base64FromArrayBuffer(n),
      enumerable: !0,
    },
    status: { value: 200 },
  });
};
_3Dconnexion.ImageItem.fromURL = function (n, t) {
  var r = new _3Dconnexion.ImageItem(),
    i;
  return (
    Object.defineProperties(r, {
      id: { value: t || '', writable: !0, enumerable: !0 },
      type: { value: _3Dconnexion.SiImageType_t.e_image, enumerable: !0 },
      index: { value: 0, writable: !0, enumerable: !0 },
      buffer: { value: null, writable: !0 },
      data: {
        get: function () {
          return this.buffer;
        },
        set: function (n) {
          r.buffer = n;
          r.onload();
        },
        enumerable: !0,
      },
      status: { value: 100, writable: !0 },
      onload: { value: function () {}, writable: !0 },
    }),
    (i = new XMLHttpRequest()),
    i.overrideMimeType('text/plain; charset=x-user-defined'),
    i.open('GET', n, !0),
    (i.responseType = 'arraybuffer'),
    (i.onload = function () {
      if (((r.status = i.status), i.status === 200 && i.response !== null)) {
        r.data = _3Dconnexion.ImageItem.base64FromArrayBuffer(i.response);
        return;
      }
      r.status = 404;
      r.data = null;
    }),
    (i.onerror = function () {
      r.status = i.status;
      r.data = null;
    }),
    i.send(null),
    r
  );
};
_3Dconnexion.ImageItem.base64FromArrayBuffer = function (n) {
  for (
    var u = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
      t = new Uint8Array(n),
      e = t.length % 3,
      f = t.length - e,
      i = '',
      r = 0;
    r < f;
    r += 3
  )
    (i += u[t[r] >> 2]),
      (i += u[((t[r] & 3) << 4) | (t[r + 1] >> 4)]),
      (i += u[((t[r + 1] & 15) << 2) | (t[r + 2] >> 6)]),
      (i += u[t[r + 2] & 63]);
  return (
    e !== 0 &&
      ((i += u[t[f] >> 2]),
      e === 2
        ? ((i += u[((t[f] & 3) << 4) | (t[f + 1] >> 4)]),
          (i += u[(t[f + 1] & 15) << 2]),
          (i += '='))
        : ((i += u[(t[f] & 3) << 4]), (i += '=='))),
    i
  );
};
_3Dconnexion.ImageCache = function () {
  this.images = [];
  this.outstanding_requests = 0;
};
_3Dconnexion.ImageCache.prototype = {
  constructor: _3Dconnexion.ImageCache,
  images: { value: null, writable: !0, enumerable: !0 },
  outstanding_requests: { value: 0, writable: !0 },
  push: function (n) {
    var t = this;
    if (n.status === 100)
      ++t.outstanding_requests,
        (n.onload = function () {
          var n = this,
            i;
          n.onload = function () {};
          n.status !== 200 && ((i = t.images.indexOf(n)), i > -1 && t.images.splice(i, 1));
          --t.outstanding_requests;
          t.outstanding_requests === 0 && t.onload();
        }.bind(n));
    else if (n.data === null) return;
    t.images.push(n);
  },
  onload: function () {},
};
/** @license AutobahnJS - http://autobahn.ws
 *
 * Copyright (C) 2011-2014 Tavendo GmbH.
 * Licensed under the MIT License.
 * See license text at http://www.opensource.org/licenses/mit-license.php
 *
 * AutobahnJS includes code from:
 *
 * when - http://cujojs.com
 *
 * (c) copyright B Cavalier & J Hann
 * Licensed under the MIT License at:
 * http://www.opensource.org/licenses/mit-license.php
 *
 * Crypto-JS - http://code.google.com/p/crypto-js/
 *
 * (c) 2009-2012 by Jeff Mott. All rights reserved.
 * Licensed under the New BSD License at:
 * http://code.google.com/p/crypto-js/wiki/License
 *
 * console-normalizer - https://github.com/Zenovations/console-normalizer
 *
 * (c) 2012 by Zenovations.
 * Licensed under the MIT License at:
 * http://www.opensource.org/licenses/mit-license.php
 *
 */
(function (n) {
  n ||
    (n = window.console =
      {
        log: function () {},
        info: function () {},
        warn: function () {},
        error: function () {},
      });
  Function.prototype.bind ||
    (Function.prototype.bind = function (n) {
      var t = this,
        i = Array.prototype.slice.call(arguments, 1);
      return function () {
        return t.apply(n, Array.prototype.concat.apply(i, arguments));
      };
    });
  typeof n.log == 'object' &&
    ((n.log = Function.prototype.call.bind(n.log, n)),
    (n.info = Function.prototype.call.bind(n.info, n)),
    (n.warn = Function.prototype.call.bind(n.warn, n)),
    (n.error = Function.prototype.call.bind(n.error, n)));
  'group' in n ||
    (n.group = function (t) {
      n.info('\\n--- ' + t + ' ---\\n');
    });
  'groupEnd' in n ||
    (n.groupEnd = function () {
      n.log('\\n');
    });
  'time' in n ||
    (function () {
      var t = {};
      n.time = function (n) {
        t[n] = new Date().getTime();
      };
      n.timeEnd = function (i) {
        var r = new Date().getTime(),
          u = i in t ? r - t[i] : 0;
        n.info(i + ': ' + u + 'ms');
      };
    })();
})(window.console);
/** @license MIT License (c) copyright 2011-2013 original author or authors */
when = (function (n) {
  'use strict';
  function t(n, t, i, r) {
    return at(n).then(t, i, r);
  }
  function e(n) {
    return new f(n, h.PromiseStatus && h.PromiseStatus());
  }
  function f(n, t) {
    function c() {
      return f ? f.inspect() : ii();
    }
    function l(n, t, r, u, e) {
      function o(i) {
        i._when(n, t, r, u, e);
      }
      i
        ? i.push(o)
        : y(function () {
            o(f);
          });
    }
    function o(n) {
      if (i) {
        var r = i;
        i = u;
        y(function () {
          f = pt(e, n);
          t && bt(f, t);
          w(r, f);
        });
      }
    }
    function s(n) {
      o(new r(n));
    }
    function a(n) {
      if (i) {
        var t = i;
        y(function () {
          w(t, new b(n));
        });
      }
    }
    var e,
      f,
      i = [];
    e = this;
    this._status = t;
    this.inspect = c;
    this._when = l;
    try {
      n(o, s, a);
    } catch (h) {
      s(h);
    }
  }
  function at(n) {
    return n instanceof f ? n : o(n);
  }
  function o(n) {
    return e(function (t) {
      t(n);
    });
  }
  function vt(n) {
    return t(n, function (n) {
      return new r(n);
    });
  }
  function yt() {
    function f(u, f, e) {
      n.resolve = n.resolver.resolve = function (n) {
        return t ? o(n) : ((t = !0), u(n), i);
      };
      n.reject = n.resolver.reject = function (n) {
        return t ? o(new r(n)) : ((t = !0), f(n), i);
      };
      n.notify = n.resolver.notify = function (n) {
        return e(n), n;
      };
    }
    var n, i, t;
    return (
      (n = {
        promise: u,
        resolve: u,
        reject: u,
        notify: u,
        resolver: { resolve: u, reject: u, notify: u },
      }),
      (n.promise = i = e(f)),
      n
    );
  }
  function w(n, t) {
    for (var i = 0; i < n.length; i++) n[i](t);
  }
  function pt(n, t) {
    if (t === n) return new r(new TypeError());
    if (t instanceof f) return t;
    try {
      var i = t === Object(t) && t.then;
      return typeof i == 'function' ? wt(i, t) : new c(t);
    } catch (u) {
      return new r(u);
    }
  }
  function wt(n, t) {
    return e(function (i, r) {
      d(n, t, i, r);
    });
  }
  function c(n) {
    this.value = n;
  }
  function r(n) {
    this.value = n;
  }
  function b(n) {
    this.value = n;
  }
  function bt(n, t) {
    function i() {
      t.fulfilled();
    }
    function r(n) {
      t.rejected(n);
    }
    n.then(i, r);
  }
  function rt(n) {
    return n && typeof n.then == 'function';
  }
  function ut(n, i, r, u, f) {
    return t(n, function (n) {
      function o(r, u, f) {
        function y(n) {
          c(n);
        }
        function w(n) {
          h(n);
        }
        var o, v, s, a, h, c, l, e;
        if (
          ((l = n.length >>> 0),
          (o = Math.max(0, Math.min(i, l))),
          (s = []),
          (v = l - o + 1),
          (a = []),
          o)
        )
          for (
            c = function (n) {
              a.push(n);
              --v || ((h = c = p), u(a));
            },
              h = function (n) {
                s.push(n);
                --o || ((h = c = p), r(s));
              },
              e = 0;
            e < l;
            ++e
          )
            e in n && t(n[e], w, y, f);
        else r(s);
      }
      return e(o).then(r, u, f);
    });
  }
  function kt(n, t, i, r) {
    function u(n) {
      return t ? t(n[0]) : n[0];
    }
    return ut(n, 1, u, i, r);
  }
  function ft(n, t, i, r) {
    return l(n, p).then(t, i, r);
  }
  function dt() {
    return l(arguments, p);
  }
  function gt(n) {
    return l(n, et, ot);
  }
  function ni(n, t) {
    return l(n, t);
  }
  function l(n, i, r) {
    return t(n, function (n) {
      function u(u, f, e) {
        function l(n, o) {
          t(n, i, r).then(
            function (n) {
              s[o] = n;
              --h || u(s);
            },
            f,
            e
          );
        }
        var s, c, h, o;
        if (((h = c = n.length >>> 0), (s = []), !h)) {
          u(s);
          return;
        }
        for (o = 0; o < c; o++) o in n ? l(n[o], o) : --h;
      }
      return new f(u);
    });
  }
  function ti(n, i) {
    var r = d(k, arguments, 1);
    return t(n, function (n) {
      var u;
      return (
        (u = n.length),
        (r[0] = function (n, r, f) {
          return t(n, function (n) {
            return t(r, function (t) {
              return i(n, t, f, u);
            });
          });
        }),
        st.apply(n, r)
      );
    });
  }
  function et(n) {
    return { state: 'fulfilled', value: n };
  }
  function ot(n) {
    return { state: 'rejected', reason: n };
  }
  function ii() {
    return { state: 'pending' };
  }
  function y(n) {
    v.push(n) === 1 && s(lt);
  }
  function lt() {
    w(v);
    v = [];
  }
  function p(n) {
    return n;
  }
  function ri(n) {
    typeof h.reportUnhandled == 'function'
      ? h.reportUnhandled()
      : y(function () {
          throw n;
        });
    throw n;
  }
  t.promise = e;
  t.resolve = o;
  t.reject = vt;
  t.defer = yt;
  t.join = dt;
  t.all = ft;
  t.map = ni;
  t.reduce = ti;
  t.settle = gt;
  t.any = kt;
  t.some = ut;
  t.isPromise = rt;
  t.isPromiseLike = rt;
  i = f.prototype;
  i.then = function (n, t, i) {
    var r = this;
    return new f(function (u, f, e) {
      r._when(u, e, n, t, i);
    }, this._status && this._status.observed());
  };
  i['catch'] = i.otherwise = function (n) {
    return this.then(u, n);
  };
  i['finally'] = i.ensure = function (n) {
    function t() {
      return o(n());
    }
    return typeof n == 'function' ? this.then(t, t)['yield'](this) : this;
  };
  i.done = function (n, t) {
    this.then(n, t)['catch'](ri);
  };
  i['yield'] = function (n) {
    return this.then(function () {
      return n;
    });
  };
  i.tap = function (n) {
    return this.then(n)['yield'](this);
  };
  i.spread = function (n) {
    return this.then(function (t) {
      return ft(t, function (t) {
        return n.apply(u, t);
      });
    });
  };
  i.always = function (n, t) {
    return this.then(n, n, t);
  };
  a =
    Object.create ||
    function (n) {
      function t() {}
      return (t.prototype = n), new t();
    };
  c.prototype = a(i);
  c.prototype.inspect = function () {
    return et(this.value);
  };
  c.prototype._when = function (n, t, i) {
    try {
      n(typeof i == 'function' ? i(this.value) : this.value);
    } catch (u) {
      n(new r(u));
    }
  };
  r.prototype = a(i);
  r.prototype.inspect = function () {
    return ot(this.value);
  };
  r.prototype._when = function (n, t, i, u) {
    try {
      n(typeof u == 'function' ? u(this.value) : this);
    } catch (f) {
      n(new r(f));
    }
  };
  b.prototype = a(i);
  b.prototype._when = function (n, t, i, r, u) {
    try {
      t(typeof u == 'function' ? u(this.value) : this.value);
    } catch (f) {
      t(f);
    }
  };
  var i, a, st, k, d, s, v, g, nt, tt, h, ht, it, ct, u;
  if (
    ((it = n),
    (v = []),
    (h = typeof console != 'undefined' ? console : t),
    typeof process == 'object' && process.nextTick)
  )
    s = process.nextTick;
  else if (
    (ct =
      (typeof MutationObserver == 'function' && MutationObserver) ||
      (typeof WebKitMutationObserver == 'function' && WebKitMutationObserver))
  )
    s = (function (n, t, i) {
      var r = n.createElement('div');
      return (
        new t(i).observe(r, { attributes: !0 }),
        function () {
          r.setAttribute('x', 'x');
        }
      );
    })(document, ct, lt);
  else
    try {
      s = it('vertx').runOnLoop || it('vertx').runOnContext;
    } catch (ui) {
      ht = setTimeout;
      s = function (n) {
        ht(n, 0);
      };
    }
  return (
    (g = Function.prototype),
    (nt = g.call),
    (d = g.bind
      ? nt.bind(nt)
      : function (n, t) {
          return n.apply(t, k.call(arguments, 2));
        }),
    (tt = []),
    (k = tt.slice),
    (st =
      tt.reduce ||
      function (n) {
        var i, u, r, f, t;
        if (((t = 0), (i = Object(this)), (f = i.length >>> 0), (u = arguments), u.length <= 1))
          for (;;) {
            if (t in i) {
              r = i[t++];
              break;
            }
            if (++t >= f) throw new TypeError();
          }
        else r = u[1];
        for (; t < f; ++t) t in i && (r = n(r, i[t], t, i));
        return r;
      }),
    t
  );
})();
(CryptoJS =
  CryptoJS ||
  (function (n, t) {
    var u = {},
      f = (u.lib = {}),
      i = (f.Base = (function () {
        function n() {}
        return {
          extend: function (t) {
            n.prototype = this;
            var i = new n();
            return (
              t && i.mixIn(t),
              i.hasOwnProperty('init') ||
                (i.init = function () {
                  i.$super.init.apply(this, arguments);
                }),
              (i.init.prototype = i),
              (i.$super = this),
              i
            );
          },
          create: function () {
            var n = this.extend();
            return n.init.apply(n, arguments), n;
          },
          init: function () {},
          mixIn: function (n) {
            for (var t in n) n.hasOwnProperty(t) && (this[t] = n[t]);
            n.hasOwnProperty('toString') && (this.toString = n.toString);
          },
          clone: function () {
            return this.init.prototype.extend(this);
          },
        };
      })()),
      r = (f.WordArray = i.extend({
        init: function (n, i) {
          n = this.words = n || [];
          this.sigBytes = i != t ? i : n.length * 4;
        },
        toString: function (n) {
          return (n || h).stringify(this);
        },
        concat: function (n) {
          var i = this.words,
            r = n.words,
            u = this.sigBytes,
            f = n.sigBytes,
            e,
            t;
          if ((this.clamp(), u % 4))
            for (t = 0; t < f; t++)
              (e = (r[t >>> 2] >>> (24 - (t % 4) * 8)) & 255),
                (i[(u + t) >>> 2] |= e << (24 - ((u + t) % 4) * 8));
          else if (r.length > 65535) for (t = 0; t < f; t += 4) i[(u + t) >>> 2] = r[t >>> 2];
          else i.push.apply(i, r);
          return (this.sigBytes += f), this;
        },
        clamp: function () {
          var i = this.words,
            t = this.sigBytes;
          i[t >>> 2] &= 4294967295 << (32 - (t % 4) * 8);
          i.length = n.ceil(t / 4);
        },
        clone: function () {
          var n = i.clone.call(this);
          return (n.words = this.words.slice(0)), n;
        },
        random: function (t) {
          for (var i = [], u = 0; u < t; u += 4) i.push((n.random() * 4294967296) | 0);
          return new r.init(i, t);
        },
      })),
      e = (u.enc = {}),
      h = (e.Hex = {
        stringify: function (n) {
          for (var r, u = n.words, f = n.sigBytes, i = [], t = 0; t < f; t++)
            (r = (u[t >>> 2] >>> (24 - (t % 4) * 8)) & 255),
              i.push((r >>> 4).toString(16)),
              i.push((r & 15).toString(16));
          return i.join('');
        },
        parse: function (n) {
          for (var i = n.length, u = [], t = 0; t < i; t += 2)
            u[t >>> 3] |= parseInt(n.substr(t, 2), 16) << (24 - (t % 8) * 4);
          return new r.init(u, i / 2);
        },
      }),
      o = (e.Latin1 = {
        stringify: function (n) {
          for (var r, u = n.words, f = n.sigBytes, i = [], t = 0; t < f; t++)
            (r = (u[t >>> 2] >>> (24 - (t % 4) * 8)) & 255), i.push(String.fromCharCode(r));
          return i.join('');
        },
        parse: function (n) {
          for (var i = n.length, u = [], t = 0; t < i; t++)
            u[t >>> 2] |= (n.charCodeAt(t) & 255) << (24 - (t % 4) * 8);
          return new r.init(u, i);
        },
      }),
      c = (e.Utf8 = {
        stringify: function (n) {
          try {
            return decodeURIComponent(escape(o.stringify(n)));
          } catch (t) {
            throw new Error('Malformed UTF-8 data');
          }
        },
        parse: function (n) {
          return o.parse(unescape(encodeURIComponent(n)));
        },
      }),
      s = (f.BufferedBlockAlgorithm = i.extend({
        reset: function () {
          this._data = new r.init();
          this._nDataBytes = 0;
        },
        _append: function (n) {
          typeof n == 'string' && (n = c.parse(n));
          this._data.concat(n);
          this._nDataBytes += n.sigBytes;
        },
        _process: function (t) {
          var e = this._data,
            h = e.words,
            c = e.sigBytes,
            o = this.blockSize,
            a = o * 4,
            u = c / a,
            i,
            s,
            f,
            l;
          if (
            ((u = t ? n.ceil(u) : n.max((u | 0) - this._minBufferSize, 0)),
            (i = u * o),
            (s = n.min(i * 4, c)),
            i)
          ) {
            for (f = 0; f < i; f += o) this._doProcessBlock(h, f);
            l = h.splice(0, i);
            e.sigBytes -= s;
          }
          return new r.init(l, s);
        },
        clone: function () {
          var n = i.clone.call(this);
          return (n._data = this._data.clone()), n;
        },
        _minBufferSize: 0,
      })),
      a = (f.Hasher = s.extend({
        cfg: i.extend(),
        init: function (n) {
          this.cfg = this.cfg.extend(n);
          this.reset();
        },
        reset: function () {
          s.reset.call(this);
          this._doReset();
        },
        update: function (n) {
          return this._append(n), this._process(), this;
        },
        finalize: function (n) {
          n && this._append(n);
          return this._doFinalize();
        },
        blockSize: 16,
        _createHelper: function (n) {
          return function (t, i) {
            return new n.init(i).finalize(t);
          };
        },
        _createHmacHelper: function (n) {
          return function (t, i) {
            return new l.HMAC.init(n, i).finalize(t);
          };
        },
      })),
      l = (u.algo = {});
    return u;
  })(Math)),
  (function () {
    var n = CryptoJS,
      t = n.lib,
      i = t.WordArray,
      r = n.enc,
      u = (r.Base64 = {
        stringify: function (n) {
          var u = n.words,
            e = n.sigBytes,
            o = this._map,
            i,
            t,
            r,
            f;
          for (n.clamp(), i = [], t = 0; t < e; t += 3) {
            var s = (u[t >>> 2] >>> (24 - (t % 4) * 8)) & 255,
              h = (u[(t + 1) >>> 2] >>> (24 - ((t + 1) % 4) * 8)) & 255,
              c = (u[(t + 2) >>> 2] >>> (24 - ((t + 2) % 4) * 8)) & 255,
              l = (s << 16) | (h << 8) | c;
            for (r = 0; r < 4 && t + r * 0.75 < e; r++)
              i.push(o.charAt((l >>> (6 * (3 - r))) & 63));
          }
          if (((f = o.charAt(64)), f)) while (i.length % 4) i.push(f);
          return i.join('');
        },
        parse: function (n) {
          var o = n.length,
            u = this._map,
            s = u.charAt(64),
            f,
            e,
            r,
            t,
            h,
            c;
          for (s && ((f = n.indexOf(s)), f != -1 && (o = f)), e = [], r = 0, t = 0; t < o; t++)
            t % 4 &&
              ((h = u.indexOf(n.charAt(t - 1)) << ((t % 4) * 2)),
              (c = u.indexOf(n.charAt(t)) >>> (6 - (t % 4) * 2)),
              (e[r >>> 2] |= (h | c) << (24 - (r % 4) * 8)),
              r++);
          return i.create(e, r);
        },
        _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',
      });
  })(),
  (function () {
    var n = CryptoJS,
      t = n.lib,
      i = t.Base,
      r = n.enc,
      u = r.Utf8,
      f = n.algo,
      e = (f.HMAC = i.extend({
        init: function (n, t) {
          var r, f, i;
          n = this._hasher = new n.init();
          typeof t == 'string' && (t = u.parse(t));
          r = n.blockSize;
          f = r * 4;
          t.sigBytes > f && (t = n.finalize(t));
          t.clamp();
          var e = (this._oKey = t.clone()),
            o = (this._iKey = t.clone()),
            s = e.words,
            h = o.words;
          for (i = 0; i < r; i++) (s[i] ^= 1549556828), (h[i] ^= 909522486);
          e.sigBytes = o.sigBytes = f;
          this.reset();
        },
        reset: function () {
          var n = this._hasher;
          n.reset();
          n.update(this._iKey);
        },
        update: function (n) {
          return this._hasher.update(n), this;
        },
        finalize: function (n) {
          var t = this._hasher,
            i = t.finalize(n);
          return t.reset(), t.finalize(this._oKey.clone().concat(i));
        },
      }));
  })(),
  (function (n) {
    var i = CryptoJS,
      f = i.lib,
      s = f.WordArray,
      r = f.Hasher,
      h = i.algo,
      e = [],
      o = [],
      t,
      u;
    (function () {
      function u(t) {
        for (var r = n.sqrt(t), i = 2; i <= r; i++) if (!(t % i)) return !1;
        return !0;
      }
      function r(n) {
        return ((n - (n | 0)) * 4294967296) | 0;
      }
      for (var i = 2, t = 0; t < 64; )
        u(i) && (t < 8 && (e[t] = r(n.pow(i, 1 / 2))), (o[t] = r(n.pow(i, 1 / 3))), t++), i++;
    })();
    t = [];
    u = h.SHA256 = r.extend({
      _doReset: function () {
        this._hash = new s.init(e.slice(0));
      },
      _doProcessBlock: function (n, i) {
        for (
          var r = this._hash.words,
            f = r[0],
            s = r[1],
            h = r[2],
            y = r[3],
            e = r[4],
            a = r[5],
            v = r[6],
            p = r[7],
            u = 0;
          u < 64;
          u++
        ) {
          if (u < 16) t[u] = n[i + u] | 0;
          else {
            var c = t[u - 15],
              b = ((c << 25) | (c >>> 7)) ^ ((c << 14) | (c >>> 18)) ^ (c >>> 3),
              l = t[u - 2],
              k = ((l << 15) | (l >>> 17)) ^ ((l << 13) | (l >>> 19)) ^ (l >>> 10);
            t[u] = b + t[u - 7] + k + t[u - 16];
          }
          var d = (e & a) ^ (~e & v),
            g = (f & s) ^ (f & h) ^ (s & h),
            nt = ((f << 30) | (f >>> 2)) ^ ((f << 19) | (f >>> 13)) ^ ((f << 10) | (f >>> 22)),
            tt = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7) | (e >>> 25)),
            w = p + tt + d + o[u] + t[u],
            it = nt + g;
          p = v;
          v = a;
          a = e;
          e = (y + w) | 0;
          y = h;
          h = s;
          s = f;
          f = (w + it) | 0;
        }
        r[0] = (r[0] + f) | 0;
        r[1] = (r[1] + s) | 0;
        r[2] = (r[2] + h) | 0;
        r[3] = (r[3] + y) | 0;
        r[4] = (r[4] + e) | 0;
        r[5] = (r[5] + a) | 0;
        r[6] = (r[6] + v) | 0;
        r[7] = (r[7] + p) | 0;
      },
      _doFinalize: function () {
        var r = this._data,
          t = r.words,
          u = this._nDataBytes * 8,
          i = r.sigBytes * 8;
        return (
          (t[i >>> 5] |= 128 << (24 - (i % 32))),
          (t[(((i + 64) >>> 9) << 4) + 14] = n.floor(u / 4294967296)),
          (t[(((i + 64) >>> 9) << 4) + 15] = u),
          (r.sigBytes = t.length * 4),
          this._process(),
          this._hash
        );
      },
      clone: function () {
        var n = r.clone.call(this);
        return (n._hash = this._hash.clone()), n;
      },
    });
    i.SHA256 = r._createHelper(u);
    i.HmacSHA256 = r._createHmacHelper(u);
  })(Math),
  (function () {
    var n = CryptoJS,
      i = n.lib,
      r = i.Base,
      u = i.WordArray,
      t = n.algo,
      f = t.SHA1,
      e = t.HMAC,
      o = (t.PBKDF2 = r.extend({
        cfg: r.extend({ keySize: 4, hasher: f, iterations: 1 }),
        init: function (n) {
          this.cfg = this.cfg.extend(n);
        },
        compute: function (n, t) {
          for (
            var s = this.cfg,
              r = e.create(s.hasher, n),
              f = u.create(),
              l = u.create([1]),
              p = f.words,
              w = l.words,
              a = s.keySize,
              b = s.iterations,
              o,
              c,
              y,
              i;
            p.length < a;

          ) {
            o = r.update(t).finalize(l);
            r.reset();
            var v = o.words,
              k = v.length,
              h = o;
            for (c = 1; c < b; c++)
              for (h = r.finalize(h), r.reset(), y = h.words, i = 0; i < k; i++) v[i] ^= y[i];
            f.concat(o);
            w[0]++;
          }
          return (f.sigBytes = a * 4), f;
        },
      }));
    n.PBKDF2 = function (n, t, i) {
      return o.create(i).compute(n, t);
    };
  })();
/** @license MIT License (c) 2011-2013 Copyright Tavendo GmbH. */
AUTOBAHNJS_VERSION = '0.8.2.1';
(global = this),
  (function (n, t) {
    n.ab = t(n, n.when);
  })(global, function (n, t) {
    'use strict';
    var i = {};
    return (
      (i._version = AUTOBAHNJS_VERSION),
      (function () {
        Array.prototype.indexOf ||
          (Array.prototype.indexOf = function (n) {
            var u, r, t, i;
            if (this === null) throw new TypeError();
            if (
              ((u = new Object(this)), (r = u.length >>> 0), r === 0) ||
              ((t = 0),
              arguments.length > 0 &&
                ((t = Number(arguments[1])),
                t !== t
                  ? (t = 0)
                  : t !== 0 &&
                    t !== Infinity &&
                    t !== -Infinity &&
                    (t = (t > 0 || -1) * Math.floor(Math.abs(t)))),
              t >= r)
            )
              return -1;
            for (i = t >= 0 ? t : Math.max(r - Math.abs(t), 0); i < r; i++)
              if (i in u && u[i] === n) return i;
            return -1;
          });
        Array.prototype.forEach ||
          (Array.prototype.forEach = function (n, t) {
            var u, i, r, f, e;
            if (this === null) throw new TypeError(' this is null or not defined');
            if (
              ((r = new Object(this)),
              (f = r.length >>> 0),
              {}.toString.call(n) !== '[object Function]')
            )
              throw new TypeError(n + ' is not a function');
            for (t && (u = t), i = 0; i < f; ) i in r && ((e = r[i]), n.call(u, e, i, r)), i++;
          });
      })(),
      (i._sliceUserAgent = function (n, t, i) {
        var s = [],
          r = navigator.userAgent,
          h = r.indexOf(n),
          f = r.indexOf(t, h),
          e,
          o,
          u;
        for (
          f < 0 && (f = r.length), e = r.slice(h, f).split(i), o = e[1].split('.'), u = 0;
          u < o.length;
          ++u
        )
          s.push(parseInt(o[u], 10));
        return { name: e[0], version: s };
      }),
      (i.getBrowser = function () {
        var n = navigator.userAgent;
        return n.indexOf('Chrome') > -1
          ? i._sliceUserAgent('Chrome', ' ', '/')
          : n.indexOf('Safari') > -1
          ? i._sliceUserAgent('Safari', ' ', '/')
          : n.indexOf('Firefox') > -1
          ? i._sliceUserAgent('Firefox', ' ', '/')
          : n.indexOf('MSIE') > -1
          ? i._sliceUserAgent('MSIE', ';', ' ')
          : null;
      }),
      (i.getServerUrl = function (t, i) {
        if (n.location.protocol === 'file:') return i ? i : 'ws://127.0.0.1/ws';
        var r = n.location.protocol === 'https:' ? 'wss://' : 'ws://',
          u = n.location.port !== '' ? ':' + n.location.port : '',
          f = t ? t : 'ws';
        return r + n.location.hostname + u + '/' + f;
      }),
      (i.browserNotSupportedMessage = 'Browser does not support WebSockets (RFC6455)'),
      (i.deriveKey = function (n, t) {
        if (t && t.salt) {
          var i = t.salt,
            r = t.keylen || 32,
            u = t.iterations || 1e4,
            f = CryptoJS.PBKDF2(n, i, {
              keySize: r / 4,
              iterations: u,
              hasher: CryptoJS.algo.SHA256,
            });
          return f.toString(CryptoJS.enc.Base64);
        }
        return n;
      }),
      (i._idchars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'),
      (i._idlen = 16),
      (i._subprotocol = 'wamp'),
      (i._newid = function () {
        for (var n = '', t = 0; t < i._idlen; t += 1)
          n += i._idchars.charAt(Math.floor(Math.random() * i._idchars.length));
        return n;
      }),
      (i._newidFast = function () {
        return Math.random().toString(36);
      }),
      (i.log = function () {
        if (arguments.length > 1) {
          console.group('Log Item');
          for (var n = 0; n < arguments.length; n += 1) console.log(arguments[n]);
          console.groupEnd();
        } else console.log(arguments[0]);
      }),
      (i._debugrpc = !1),
      (i._debugpubsub = !1),
      (i._debugws = !1),
      (i._debugconnect = !1),
      (i.debug = function (t, r, u) {
        if ('console' in n)
          (i._debugrpc = t), (i._debugpubsub = t), (i._debugws = r), (i._debugconnect = u);
        else throw 'browser does not support console object';
      }),
      (i.version = function () {
        return i._version;
      }),
      (i.PrefixMap = function () {
        var n = this;
        n._index = {};
        n._rindex = {};
      }),
      (i.PrefixMap.prototype.get = function (n) {
        var t = this;
        return t._index[n];
      }),
      (i.PrefixMap.prototype.set = function (n, t) {
        var i = this;
        i._index[n] = t;
        i._rindex[t] = n;
      }),
      (i.PrefixMap.prototype.setDefault = function (n) {
        var t = this;
        t._index[''] = n;
        t._rindex[n] = '';
      }),
      (i.PrefixMap.prototype.remove = function (n) {
        var t = this,
          i = t._index[n];
        i && (delete t._index[n], delete t._rindex[i]);
      }),
      (i.PrefixMap.prototype.resolve = function (n, t) {
        var u = this,
          i = n.indexOf(':'),
          r;
        return i >= 0 && ((r = n.substring(0, i)), u._index[r])
          ? u._index[r] + n.substring(i + 1)
          : t === !0
          ? n
          : null;
      }),
      (i.PrefixMap.prototype.shrink = function (n, t) {
        for (var u, r, f = this, i = n.length; i > 0; i -= 1)
          if (((u = n.substring(0, i)), (r = f._rindex[u]), r)) return r + ':' + n.substring(i);
        return t === !0 ? n : null;
      }),
      (i._MESSAGE_TYPEID_WELCOME = 0),
      (i._MESSAGE_TYPEID_PREFIX = 1),
      (i._MESSAGE_TYPEID_CALL = 2),
      (i._MESSAGE_TYPEID_CALL_RESULT = 3),
      (i._MESSAGE_TYPEID_CALL_ERROR = 4),
      (i._MESSAGE_TYPEID_SUBSCRIBE = 5),
      (i._MESSAGE_TYPEID_UNSUBSCRIBE = 6),
      (i._MESSAGE_TYPEID_PUBLISH = 7),
      (i._MESSAGE_TYPEID_EVENT = 8),
      (i.CONNECTION_CLOSED = 0),
      (i.CONNECTION_LOST = 1),
      (i.CONNECTION_RETRIES_EXCEEDED = 2),
      (i.CONNECTION_UNREACHABLE = 3),
      (i.CONNECTION_UNSUPPORTED = 4),
      (i.CONNECTION_UNREACHABLE_SCHEDULED_RECONNECT = 5),
      (i.CONNECTION_LOST_SCHEDULED_RECONNECT = 6),
      (i.Deferred = t.defer),
      (i._construct = function (t, i) {
        return 'WebSocket' in n
          ? i
            ? new WebSocket(t, i)
            : new WebSocket(t)
          : 'MozWebSocket' in n
          ? i
            ? new MozWebSocket(t, i)
            : new MozWebSocket(t)
          : null;
      }),
      (i.Session = function (n, t, r, u) {
        var f = this;
        if (
          ((f._wsuri = n),
          (f._options = u),
          (f._websocket_onopen = t),
          (f._websocket_onclose = r),
          (f._websocket = null),
          (f._websocket_connected = !1),
          (f._session_id = null),
          (f._wamp_version = null),
          (f._server = null),
          (f._calls = {}),
          (f._subscriptions = {}),
          (f._prefixes = new i.PrefixMap()),
          (f._txcnt = 0),
          (f._rxcnt = 0),
          (f._websocket =
            f._options && f._options.skipSubprotocolAnnounce
              ? i._construct(f._wsuri)
              : i._construct(f._wsuri, [i._subprotocol])),
          !f._websocket)
        ) {
          if (r !== undefined) {
            r(i.CONNECTION_UNSUPPORTED);
            return;
          }
          throw i.browserNotSupportedMessage;
        }
        f._websocket.onmessage = function (n) {
          var t, r, h, e, c, s, v, y, p, w;
          if (
            (i._debugws &&
              ((f._rxcnt += 1),
              console.group('WS Receive'),
              console.info(f._wsuri + '  [' + f._session_id + ']'),
              console.log(f._rxcnt),
              console.log(n.data),
              console.groupEnd()),
            (t = JSON.parse(n.data)),
            t[1] in f._calls)
          ) {
            if (t[0] === i._MESSAGE_TYPEID_CALL_RESULT) {
              if (((r = f._calls[t[1]]), (h = t[2]), i._debugrpc && r._ab_callobj !== undefined)) {
                for (
                  console.group('WAMP Call', r._ab_callobj[2]),
                    console.timeEnd(r._ab_tid),
                    console.group('Arguments'),
                    e = 3;
                  e < r._ab_callobj.length;
                  e += 1
                )
                  if (((c = r._ab_callobj[e]), c !== undefined)) console.log(c);
                  else break;
                console.groupEnd();
                console.group('Result');
                console.log(h);
                console.groupEnd();
                console.groupEnd();
              }
              r.resolve(h);
            } else if (t[0] === i._MESSAGE_TYPEID_CALL_ERROR) {
              var u = f._calls[t[1]],
                l = t[2],
                a = t[3],
                o = t[4];
              if (i._debugrpc && u._ab_callobj !== undefined) {
                for (
                  console.group('WAMP Call', u._ab_callobj[2]),
                    console.timeEnd(u._ab_tid),
                    console.group('Arguments'),
                    s = 3;
                  s < u._ab_callobj.length;
                  s += 1
                )
                  if (((v = u._ab_callobj[s]), v !== undefined)) console.log(v);
                  else break;
                console.groupEnd();
                console.group('Error');
                console.log(l);
                console.log(a);
                o !== undefined && console.log(o);
                console.groupEnd();
                console.groupEnd();
              }
              o !== undefined
                ? u.reject({ uri: l, desc: a, detail: o })
                : u.reject({ uri: l, desc: a });
            }
            delete f._calls[t[1]];
          } else if (t[0] === i._MESSAGE_TYPEID_EVENT)
            (y = f._prefixes.resolve(t[1], !0)),
              y in f._subscriptions &&
                ((p = t[1]),
                (w = t[2]),
                i._debugpubsub &&
                  (console.group('WAMP Event'),
                  console.info(f._wsuri + '  [' + f._session_id + ']'),
                  console.log(p),
                  console.log(w),
                  console.groupEnd()),
                f._subscriptions[y].forEach(function (n) {
                  n(p, w);
                }));
          else if (t[0] === i._MESSAGE_TYPEID_WELCOME)
            if (f._session_id === null)
              (f._session_id = t[1]),
                (f._wamp_version = t[2]),
                (f._server = t[3]),
                (i._debugrpc || i._debugpubsub) &&
                  (console.group('WAMP Welcome'),
                  console.info(f._wsuri + '  [' + f._session_id + ']'),
                  console.log(f._wamp_version),
                  console.log(f._server),
                  console.groupEnd()),
                f._websocket_onopen !== null && f._websocket_onopen();
            else throw 'protocol error (welcome message received more than once)';
        };
        f._websocket.onopen = function () {
          if (f._websocket.protocol !== i._subprotocol)
            if (typeof f._websocket.protocol == 'undefined')
              i._debugws &&
                (console.group('WS Warning'),
                console.info(f._wsuri),
                console.log(
                  'WebSocket object has no protocol attribute: WAMP subprotocol check skipped!'
                ),
                console.groupEnd());
            else if (f._options && f._options.skipSubprotocolCheck)
              i._debugws &&
                (console.group('WS Warning'),
                console.info(f._wsuri),
                console.log(
                  'Server does not speak WAMP, but subprotocol check disabled by option!'
                ),
                console.log(f._websocket.protocol),
                console.groupEnd());
            else {
              f._websocket.close(1e3, 'server does not speak WAMP');
              throw "server does not speak WAMP (but '" + f._websocket.protocol + "' !)";
            }
          i._debugws &&
            (console.group('WAMP Connect'),
            console.info(f._wsuri),
            console.log(f._websocket.protocol),
            console.groupEnd());
          f._websocket_connected = !0;
        };
        f._websocket.onerror = function () {};
        f._websocket.onclose = function (n) {
          i._debugws &&
            (f._websocket_connected
              ? console.log(
                  'Autobahn connection to ' +
                    f._wsuri +
                    ' lost (code ' +
                    n.code +
                    ", reason '" +
                    n.reason +
                    "', wasClean " +
                    n.wasClean +
                    ').'
                )
              : console.log(
                  'Autobahn could not connect to ' +
                    f._wsuri +
                    ' (code ' +
                    n.code +
                    ", reason '" +
                    n.reason +
                    "', wasClean " +
                    n.wasClean +
                    ').'
                ));
          f._websocket_onclose !== undefined &&
            (f._websocket_connected
              ? n.wasClean
                ? f._websocket_onclose(i.CONNECTION_CLOSED, 'WS-' + n.code + ': ' + n.reason)
                : f._websocket_onclose(i.CONNECTION_LOST)
              : f._websocket_onclose(i.CONNECTION_UNREACHABLE));
          f._websocket_connected = !1;
          f._wsuri = null;
          f._websocket_onopen = null;
          f._websocket_onclose = null;
          f._websocket = null;
        };
        f.log = function () {
          f._options && 'sessionIdent' in f._options
            ? console.group(
                "WAMP Session '" + f._options.sessionIdent + "' [" + f._session_id + ']'
              )
            : console.group('WAMP Session [' + f._session_id + ']');
          for (var n = 0; n < arguments.length; ++n) console.log(arguments[n]);
          console.groupEnd();
        };
      }),
      (i.Session.prototype._send = function (t) {
        var r = this,
          u;
        if (!r._websocket_connected) throw 'Autobahn not connected';
        switch (!0) {
          case n.Prototype && typeof top.root.__prototype_deleted == 'undefined':
          case typeof t.toJSON == 'function':
            u = t.toJSON();
            break;
          default:
            u = JSON.stringify(t);
        }
        r._websocket.send(u);
        r._txcnt += 1;
        i._debugws &&
          (console.group('WS Send'),
          console.info(r._wsuri + '  [' + r._session_id + ']'),
          console.log(r._txcnt),
          console.log(u),
          console.groupEnd());
      }),
      (i.Session.prototype.close = function () {
        var n = this;
        n._websocket_connected && n._websocket.close();
      }),
      (i.Session.prototype.sessionid = function () {
        var n = this;
        return n._session_id;
      }),
      (i.Session.prototype.wsuri = function () {
        var n = this;
        return n._wsuri;
      }),
      (i.Session.prototype.shrink = function (n, t) {
        var i = this;
        return t === undefined && (t = !0), i._prefixes.shrink(n, t);
      }),
      (i.Session.prototype.resolve = function (n, t) {
        var i = this;
        return t === undefined && (t = !0), i._prefixes.resolve(n, t);
      }),
      (i.Session.prototype.prefix = function (n, t) {
        var r = this,
          u;
        r._prefixes.set(n, t);
        (i._debugrpc || i._debugpubsub) &&
          (console.group('WAMP Prefix'),
          console.info(r._wsuri + '  [' + r._session_id + ']'),
          console.log(n),
          console.log(t),
          console.groupEnd());
        u = [i._MESSAGE_TYPEID_PREFIX, n, t];
        r._send(u);
      }),
      (i.Session.prototype.call = function () {
        for (var t = this, n = new i.Deferred(), r, e, u, f; ; )
          if (((r = i._newidFast()), !(r in t._calls))) break;
        for (
          t._calls[r] = n,
            e = t._prefixes.shrink(arguments[0], !0),
            u = [i._MESSAGE_TYPEID_CALL, r, e],
            f = 1;
          f < arguments.length;
          f += 1
        )
          u.push(arguments[f]);
        return (
          t._send(u),
          i._debugrpc &&
            ((n._ab_callobj = u),
            (n._ab_tid = t._wsuri + '  [' + t._session_id + '][' + r + ']'),
            console.time(n._ab_tid),
            console.info()),
          n.promise.then ? n.promise : n
        );
      }),
      (i.Session.prototype.subscribe = function (n, t) {
        var r = this,
          u = r._prefixes.resolve(n, !0),
          f,
          e;
        if (
          (u in r._subscriptions ||
            (i._debugpubsub &&
              (console.group('WAMP Subscribe'),
              console.info(r._wsuri + '  [' + r._session_id + ']'),
              console.log(n),
              console.log(t),
              console.groupEnd()),
            (f = [i._MESSAGE_TYPEID_SUBSCRIBE, n]),
            r._send(f),
            (r._subscriptions[u] = [])),
          (e = r._subscriptions[u].indexOf(t)),
          e === -1)
        )
          r._subscriptions[u].push(t);
        else throw 'callback ' + t + ' already subscribed for topic ' + u;
      }),
      (i.Session.prototype.unsubscribe = function (n, t) {
        var r = this,
          u = r._prefixes.resolve(n, !0),
          f,
          e,
          o;
        if (u in r._subscriptions) {
          if (t !== undefined)
            if (((e = r._subscriptions[u].indexOf(t)), e !== -1))
              (f = t), r._subscriptions[u].splice(e, 1);
            else throw 'no callback ' + t + ' subscribed on topic ' + u;
          else (f = r._subscriptions[u].slice()), (r._subscriptions[u] = []);
          r._subscriptions[u].length === 0 &&
            (delete r._subscriptions[u],
            i._debugpubsub &&
              (console.group('WAMP Unsubscribe'),
              console.info(r._wsuri + '  [' + r._session_id + ']'),
              console.log(n),
              console.log(f),
              console.groupEnd()),
            (o = [i._MESSAGE_TYPEID_UNSUBSCRIBE, n]),
            r._send(o));
        } else throw 'not subscribed to topic ' + u;
      }),
      (i.Session.prototype.publish = function () {
        var o = this,
          t = arguments[0],
          r = arguments[1],
          f = null,
          n = null,
          e = null,
          u = null;
        if (arguments.length > 3) {
          if (!(arguments[2] instanceof Array)) throw 'invalid argument type(s)';
          if (!(arguments[3] instanceof Array)) throw 'invalid argument type(s)';
          n = arguments[2];
          e = arguments[3];
          u = [i._MESSAGE_TYPEID_PUBLISH, t, r, n, e];
        } else if (arguments.length > 2)
          if (typeof arguments[2] == 'boolean')
            (f = arguments[2]), (u = [i._MESSAGE_TYPEID_PUBLISH, t, r, f]);
          else if (arguments[2] instanceof Array)
            (n = arguments[2]), (u = [i._MESSAGE_TYPEID_PUBLISH, t, r, n]);
          else throw 'invalid argument type(s)';
        else u = [i._MESSAGE_TYPEID_PUBLISH, t, r];
        i._debugpubsub &&
          (console.group('WAMP Publish'),
          console.info(o._wsuri + '  [' + o._session_id + ']'),
          console.log(t),
          console.log(r),
          f !== null
            ? console.log(f)
            : n !== null && (console.log(n), e !== null && console.log(e)),
          console.groupEnd());
        o._send(u);
      }),
      (i.Session.prototype.authreq = function (n, t) {
        return this.call('http://api.wamp.ws/procedure#authreq', n, t);
      }),
      (i.Session.prototype.authsign = function (n, t) {
        return t || (t = ''), CryptoJS.HmacSHA256(n, t).toString(CryptoJS.enc.Base64);
      }),
      (i.Session.prototype.auth = function (n) {
        return this.call('http://api.wamp.ws/procedure#auth', n);
      }),
      (i._connect = function (t) {
        var r = new i.Session(
          t.wsuri,
          function () {
            t.connects += 1;
            t.retryCount = 0;
            t.onConnect(r);
          },
          function (r, u) {
            var f = null;
            switch (r) {
              case i.CONNECTION_CLOSED:
                t.onHangup(r, 'Connection was closed properly [' + u + ']');
                break;
              case i.CONNECTION_UNSUPPORTED:
                t.onHangup(r, 'Browser does not support WebSocket.');
                break;
              case i.CONNECTION_UNREACHABLE:
                if (((t.retryCount += 1), t.connects === 0))
                  t.onHangup(r, 'Connection could not be established.');
                else if (t.retryCount <= t.options.maxRetries)
                  if (
                    ((f = t.onHangup(
                      i.CONNECTION_UNREACHABLE_SCHEDULED_RECONNECT,
                      'Connection unreachable - scheduled reconnect to occur in ' +
                        t.options.retryDelay / 1e3 +
                        ' second(s) - attempt ' +
                        t.retryCount +
                        ' of ' +
                        t.options.maxRetries +
                        '.',
                      {
                        delay: t.options.retryDelay,
                        retries: t.retryCount,
                        maxretries: t.options.maxRetries,
                      }
                    )),
                    f)
                  ) {
                    i._debugconnect &&
                      console.log('Connection unreachable - retrying stopped by app');
                    t.onHangup(
                      i.CONNECTION_RETRIES_EXCEEDED,
                      'Number of connection retries exceeded.'
                    );
                  } else
                    i._debugconnect &&
                      console.log('Connection unreachable - retrying (' + t.retryCount + ') ..'),
                      n.setTimeout(function () {
                        i._connect(t);
                      }, t.options.retryDelay);
                else
                  t.onHangup(
                    i.CONNECTION_RETRIES_EXCEEDED,
                    'Number of connection retries exceeded.'
                  );
                break;
              case i.CONNECTION_LOST:
                if (((t.retryCount += 1), t.retryCount <= t.options.maxRetries))
                  if (
                    ((f = t.onHangup(
                      i.CONNECTION_LOST_SCHEDULED_RECONNECT,
                      'Connection lost - scheduled ' +
                        t.retryCount +
                        'th reconnect to occur in ' +
                        t.options.retryDelay / 1e3 +
                        ' second(s).',
                      {
                        delay: t.options.retryDelay,
                        retries: t.retryCount,
                        maxretries: t.options.maxRetries,
                      }
                    )),
                    f)
                  ) {
                    i._debugconnect && console.log('Connection lost - retrying stopped by app');
                    t.onHangup(i.CONNECTION_RETRIES_EXCEEDED, 'Connection lost.');
                  } else
                    i._debugconnect &&
                      console.log('Connection lost - retrying (' + t.retryCount + ') ..'),
                      n.setTimeout(function () {
                        i._connect(t);
                      }, t.options.retryDelay);
                else t.onHangup(i.CONNECTION_RETRIES_EXCEEDED, 'Connection lost.');
                break;
              default:
                throw 'unhandled close code in ab._connect';
            }
          },
          t.options
        );
      }),
      (i.connect = function (n, t, r, u) {
        var f = {};
        if (
          ((f.wsuri = n),
          (f.options = u ? u : {}),
          f.options.retryDelay === undefined && (f.options.retryDelay = 5e3),
          f.options.maxRetries === undefined && (f.options.maxRetries = 10),
          f.options.skipSubprotocolCheck === undefined && (f.options.skipSubprotocolCheck = !1),
          f.options.skipSubprotocolAnnounce === undefined &&
            (f.options.skipSubprotocolAnnounce = !1),
          t)
        )
          f.onConnect = t;
        else throw 'onConnect handler required!';
        f.onHangup = r
          ? r
          : function (n, t, r) {
              i._debugconnect && console.log(n, t, r);
            };
        f.connects = 0;
        f.retryCount = 0;
        i._connect(f);
      }),
      (i.launch = function (n, t, r) {
        i.connect(
          n.wsuri,
          function (r) {
            n.appkey && n.appkey !== ''
              ? r.authreq(n.appkey, n.appextra).then(function (u) {
                  var f = null,
                    e;
                  typeof n.appsecret == 'function'
                    ? (f = n.appsecret(u))
                    : ((e = i.deriveKey(n.appsecret, JSON.parse(u).authextra)),
                      (f = r.authsign(u, e)));
                  r.auth(f).then(function () {
                    t ? t(r) : i._debugconnect && r.log('Session opened.');
                  }, r.log);
                }, r.log)
              : r.authreq().then(function () {
                  r.auth().then(function () {
                    t ? t(r) : i._debugconnect && r.log('Session opened.');
                  }, r.log);
                }, r.log);
          },
          function (n, t, u) {
            r ? r(n, t, u) : i._debugconnect && i.log('Session closed.', n, t, u);
          },
          n.sessionConfig
        );
      }),
      i
    );
  });
ab._UA_FIREFOX = new RegExp('.*Firefox/([0-9+]*).*');
ab._UA_CHROME = new RegExp('.*Chrome/([0-9+]*).*');
ab._UA_CHROMEFRAME = new RegExp('.*chromeframe/([0-9]*).*');
ab._UA_WEBKIT = new RegExp('.*AppleWebKit/([0-9+.]*)w*.*');
ab._UA_WEBOS = new RegExp('.*webOS/([0-9+.]*)w*.*');
ab._matchRegex = function (n, t) {
  var i = t.exec(n);
  return i ? i[1] : i;
};
ab.lookupWsSupport = function () {
  var n = navigator.userAgent,
    t;
  return n.indexOf('MSIE') > -1
    ? n.indexOf('MSIE 10') > -1
      ? [!0, !0, !0]
      : n.indexOf('chromeframe') > -1
      ? ((t = parseInt(ab._matchRegex(n, ab._UA_CHROMEFRAME))), t >= 14)
        ? [!0, !1, !0]
        : [!1, !1, !1]
      : n.indexOf('MSIE 8') > -1 || n.indexOf('MSIE 9') > -1
      ? [!0, !0, !0]
      : [!1, !1, !1]
    : n.indexOf('Firefox') > -1
    ? ((t = parseInt(ab._matchRegex(n, ab._UA_FIREFOX))), t)
      ? t >= 7
        ? [!0, !1, !0]
        : t >= 3
        ? [!0, !0, !0]
        : [!1, !1, !0]
      : [!1, !1, !0]
    : n.indexOf('Safari') > -1 && n.indexOf('Chrome') == -1
    ? ((t = ab._matchRegex(n, ab._UA_WEBKIT)), t)
      ? n.indexOf('Windows') > -1 && t == '534+'
        ? [!0, !1, !0]
        : n.indexOf('Macintosh') > -1 &&
          ((t = t.replace('+', '').split('.')),
          (parseInt(t[0]) == 535 && parseInt(t[1]) >= 24) || parseInt(t[0]) > 535)
        ? [!0, !1, !0]
        : n.indexOf('webOS') > -1
        ? ((t = ab._matchRegex(n, ab._UA_WEBOS).split('.')), parseInt(t[0]) == 2)
          ? [!1, !0, !0]
          : [!1, !1, !1]
        : [!0, !0, !0]
      : [!1, !1, !1]
    : n.indexOf('Chrome') > -1
    ? ((t = parseInt(ab._matchRegex(n, ab._UA_CHROME))), t)
      ? t >= 14
        ? [!0, !1, !0]
        : t >= 4
        ? [!0, !0, !0]
        : [!1, !1, !0]
      : [!1, !1, !1]
    : n.indexOf('Android') > -1
    ? n.indexOf('Firefox') > -1
      ? [!0, !1, !0]
      : n.indexOf('CrMo') > -1
      ? [!0, !1, !0]
      : n.indexOf('Opera') > -1
      ? [!1, !1, !0]
      : n.indexOf('CrMo') > -1
      ? [!0, !0, !0]
      : [!1, !1, !1]
    : n.indexOf('iPhone') > -1 || n.indexOf('iPad') > -1 || n.indexOf('iPod') > -1
    ? [!1, !1, !0]
    : [!1, !1, !1];
};
`;
window.eval(ly);
class pp extends Se {
  constructor(t) {
    super(t), this._modelBounding = new ni(), this._selectionBounding = new ni(), this._pivot = d.zero(), this._hitRayOrigin = null, this._hitRayDirection = null, this._hitRayAperture = 0, this._hitRaySelectionOnly = !1, this._hitRaySelectionItem = null, this._client = {
      onConnect: () => {
        if (this._connexion === null)
          return;
        const e = this._viewer.getViewElement();
        e.addEventListener("focusin", () => {
          this._connexion !== null && this._connexion.update3dcontroller({ focus: !0 });
        }), e.addEventListener("focusout", () => {
          this._connexion !== null && this._connexion.update3dcontroller({ focus: !1 });
        }), this._connexion.create3dmouse(e, "WebViewer");
      },
      on3dmouseCreated: () => {
        this._3dMouseInitialized = !0, this._connexion !== null && (this._updateModelBounding(), this._connexion.update3dcontroller({ focus: !0 }));
      },
      onDisconnect: (e) => {
        console.log(`3Dconnexion NL-Server disconnected ${e}`);
      },
      getCoordinateSystem: () => [
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        1
      ],
      getConstructionPlane: () => null,
      getFov: () => {
        const e = this._viewer.view.getCamera(), i = e.getWidth(), s = d.subtract(e.getTarget(), e.getPosition()).length();
        return Vl(2 * Math.atan(i / (2 * s)));
      },
      setFov: (e) => {
        const i = this._viewer.view.getCamera(), s = cs(e), r = Math.tan(s / 2), a = d.subtract(i.getTarget(), i.getPosition()).length() * r, l = i.getHeight() / i.getWidth();
        i.setWidth(a), i.setHeight(a * l), this._viewer.view.setCamera(i);
      },
      getPerspective: () => this._viewer.view.getCamera().getProjection() === te.Perspective,
      getViewExtents: () => {
        const e = this._viewer.view.getCamera(), i = e.getPosition(), s = e.getTarget(), r = e.getWidth() / 2, o = e.getHeight() / 2, a = d.subtract(i, s), l = e.getNearLimit(), c = a.z / l;
        return [-r, -o, c, r, o, l];
      },
      setViewExtents: (e) => {
        const i = new E(e[0], e[4]), s = new E(e[3], e[4]), r = new E(e[3], e[1]), o = E.distance(i, s), a = E.distance(s, r), l = this._viewer.view.getCamera();
        l.setWidth(o), l.setHeight(a), this._viewer.view.setCamera(l);
      },
      getViewFrustum: () => {
        const e = this._viewer.view.getCamera(), i = e.getWidth(), s = d.subtract(e.getTarget(), e.getPosition()).length(), r = 2 * Math.atan(i / (2 * s)), o = e.getWidth() / e.getHeight(), a = e.getNearLimit(), l = Math.tan(r * 0.5) * a, c = -l, h = o * c, u = o * l, p = d.distance(e.getPosition(), e.getTarget());
        return [h, u, c, l, a, p];
      },
      getViewMatrix: () => {
        const e = this._viewer.view.getCamera(), i = e.getUp().normalize(), s = d.subtract(e.getTarget(), e.getPosition()).normalize(), r = d.cross(s, i).normalize(), o = e.getPosition();
        return [
          r.x,
          r.y,
          r.z,
          0,
          i.x,
          i.y,
          i.z,
          0,
          -s.x,
          -s.y,
          -s.z,
          0,
          o.x,
          o.y,
          o.z,
          1
        ];
      },
      setViewMatrix: (e) => {
        const i = this._viewer.view.getCamera(), s = new d(e[4], e[5], e[6]), r = new d(-e[8], -e[9], -e[10]), o = new d(e[12], e[13], e[14]), a = d.subtract(i.getPosition(), i.getTarget()).length(), l = o.copy().add(r.copy().scale(a));
        i.setTarget(l), i.setPosition(o), i.setUp(s), this._viewer.view.setCamera(i);
      },
      getViewRotatable: () => !this._viewer.model.isDrawing(),
      getViewTarget: () => {
        const e = this._viewer.view.getCamera().getTarget();
        return [e.x, e.y, e.z];
      },
      getFrontView: () => [
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        1
      ],
      getPivotPosition: () => [this._pivot.x, this._pivot.y, this._pivot.z],
      setPivotPosition: (e) => {
        this._pivot = d.createFromArray(e);
      },
      setPivotVisible: (e) => {
        this._pivotMarkup.enable(e);
      },
      getPointerPosition: () => {
        const e = this._viewer.view.unprojectPoint(this._ptCurrent, 0);
        return e === null ? [0, 0, 0] : [e.x, e.y, e.z];
      },
      getModelExtents: () => [
        this._modelBounding.min.x,
        this._modelBounding.min.y,
        this._modelBounding.min.z,
        this._modelBounding.max.x,
        this._modelBounding.max.y,
        this._modelBounding.max.z
      ],
      setLookFrom: (e) => {
        this._hitRayOrigin = d.createFromArray(e), this._updateHitTest();
      },
      setLookDirection: (e) => {
        this._hitRayDirection = d.createFromArray(e);
      },
      setLookAperture: (e) => {
        this._hitRayAperture = e;
      },
      setSelectionOnly: (e) => {
        this._hitRaySelectionOnly = e, this._updateHitTest();
      },
      getLookAt: () => {
        if (this._hitRaySelectionItem === null)
          return null;
        const e = this._hitRaySelectionItem.getPosition();
        return e === null ? null : [e.x, e.y, e.z];
      },
      getSelectionEmpty: () => this._viewer.selectionManager.getFirst() === null,
      getSelectionExtents: () => [
        this._selectionBounding.min.x,
        this._selectionBounding.min.y,
        this._selectionBounding.min.z,
        this._selectionBounding.max.x,
        this._selectionBounding.max.y,
        this._selectionBounding.max.z
      ]
    }, this._connexion = null, this._3dMouseInitialized = !1, this._pivotMarkup = new Lh(t), this._viewer.setCallbacks({
      modelStructureReady: () => {
        this._updateModelBounding();
      },
      subtreeLoaded: () => {
        this._updateModelBounding();
      },
      subtreeDeleted: () => {
        this._updateModelBounding();
      },
      selectionArray: () => {
        this._updateSelectionBounding();
      },
      frameDrawn: () => {
        let e = this._viewer.view.projectPoint(this._pivot);
        if (this._hitRaySelectionItem !== null) {
          const s = this._hitRaySelectionItem.getPosition();
          s !== null && (e = s);
        }
        const i = new E(e.x, e.y);
        this._pivotMarkup.setPosition(i), this._pivotMarkup.draw();
      }
    });
  }
  async _updateModelBounding() {
    if (this._connexion === null || !this._3dMouseInitialized)
      return;
    this._modelBounding = await this._viewer.model.getModelBounding(!0, !0);
    const t = this._modelBounding.center();
    this._connexion.update3dcontroller({
      pivot: {
        position: [t.x, t.y, t.z]
      }
    }), this._pivot = t;
  }
  async _updateSelectionBounding() {
    if (this._connexion === null || !this._3dMouseInitialized)
      return;
    const t = this._viewer.selectionManager.getResults().map((e) => e.getNodeId());
    if (t.length === 0) {
      this._selectionBounding = new ni();
      return;
    }
    this._selectionBounding = await this._viewer.model.getNodesBounding(t);
  }
  async _updateHitTest() {
    this._hitRayAperture;
    const t = this._viewer;
    if (this._hitRayOrigin === null || this._hitRayDirection === null)
      return;
    const e = new Vn(this._hitRayOrigin, this._hitRayDirection), i = new Ie(), s = await t.view.pickFromRay(e, i), r = s.getNodeId();
    if (r === null) {
      this._hitRaySelectionItem = null;
      return;
    }
    if (this._hitRaySelectionOnly && !t.selectionManager.isNodeSelected(r)) {
      this._hitRaySelectionItem = null;
      return;
    }
    this._hitRaySelectionItem = s;
  }
  /**
   * Connect to the space mouse. To be successful, this method
   * should be called in the sceneReady callback. If you want to
   * connect at a later time, the canvas where the mouse is
   * to be used must have focus.
   *
   * Note: If this is called but the 3d connexion software is not running,
   * a connection error will be shown in the console.
   */
  connect() {
    this._connexion = new _3Dconnexion(this._client), this._connexion.connect();
  }
}
const tI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AreaSelectionOperator: sp,
  AxisTriadOperator: rp,
  ButtonModifier: Jc,
  Camera: iy,
  CuttingPlaneOperator: ap,
  CuttingPlaneOperatorContext: op,
  FloorplanOperator: lp,
  HandleOperator: cp,
  Markup: oy,
  Measure: ny,
  NavCubeOperator: hp,
  NoteOperator: up,
  OperatorBase: Se,
  RayDrillSelectionOperator: dp,
  Redline: ay,
  SelectionOperator: mp,
  SelectionRectangleMarkup: Nh,
  SpaceMouseOperator: pp
}, Symbol.toStringTag, { value: "Module" }));
var ih = /* @__PURE__ */ ((n) => (n[n.Cutoff = 476837158203125e-21] = "Cutoff", n))(ih || {});
class _u {
  constructor() {
    this.plane = new je(), this.referenceGeometry = null, this.meshId = null, this.instanceNodeId = null, this.color = it.createFromFloat(0.65, 0.65, 0.65), this.lineColor = it.black(), this.opacity = 0.35, this.matrix = new Q();
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return {
      plane: {
        normal: this.plane.normal,
        d: this.plane.d
      },
      referenceGeometry: this.referenceGeometry
    };
  }
  fromJson(t) {
    const e = Fo(t), i = e.plane;
    this.plane = new je();
    const s = i.normal;
    this.plane.normal = new d(s.x, s.y, s.z), this.plane.d = i.d;
    const r = e.referenceGeometry;
    if (Array.isArray(r))
      for (let o = 0; o < r.length; ++o)
        r[o] = d.fromJson(r[o]);
    this.referenceGeometry = r;
  }
  getMatrix() {
    return this.matrix.copy();
  }
  setMatrix(t) {
    this.matrix = t.copy();
  }
  setReferenceGeometry(t) {
    if (t) {
      this.referenceGeometry = [];
      for (const e of t)
        this.referenceGeometry.push(e.copy());
    } else
      this.referenceGeometry = null;
  }
  getReferenceGeometry() {
    if (this.referenceGeometry) {
      const t = [];
      for (const e of this.referenceGeometry)
        t.push(e.copy());
      return t;
    } else
      return null;
  }
  createMeshData() {
    const t = this.referenceGeometry;
    if (t === null)
      return null;
    const e = new Hi(), i = [], s = [];
    i.push(t[0].x, t[0].y, t[0].z), i.push(t[1].x, t[1].y, t[1].z), i.push(t[3].x, t[3].y, t[3].z), i.push(t[1].x, t[1].y, t[1].z), i.push(t[2].x, t[2].y, t[2].z), i.push(t[3].x, t[3].y, t[3].z);
    const o = je.createFromPoints(t[0], t[1], t[2]).normal;
    for (let a = 0; a < 6; a++)
      s.push(o.x, o.y, o.z);
    return e.addFaces(i, s), e.addPolyline([t[0].x, t[0].y, t[0].z, t[1].x, t[1].y, t[1].z]), e.addPolyline([t[1].x, t[1].y, t[1].z, t[2].x, t[2].y, t[2].z]), e.addPolyline([t[2].x, t[2].y, t[2].z, t[3].x, t[3].y, t[3].z]), e.addPolyline([t[3].x, t[3].y, t[3].z, t[0].x, t[0].y, t[0].z]), e;
  }
}
class cy {
  /** @hidden */
  constructor(t, e, i, s, r) {
    this._cuttingPlanes = [], this._isActive = !1, this._viewer = t, this._model = e, this._callbackManager = i, this._cuttingManager = s, this._engine = r;
  }
  /**
   * Adds a plane to the cutting section.
   * @param plane The plane to be used for cutting.
   * @param referenceGeometry An optional list of four points representing a quad to be used as reference geometry for the cutting plane. Pass null to use no reference geometry for this cutting plane.
   */
  async addPlane(t, e = null) {
    const i = this._engine.getCuttingSectionLimits();
    if (this._cuttingPlanes.length >= i.maxCuttingPlanesPerSection)
      return !1;
    const s = new _u();
    return s.plane = t.copy(), s.setReferenceGeometry(e), this._cuttingPlanes.push(s), this._isActive && (await this._resetCuttingPlane(s), await this._engine.updateCuttingSection(this)), !0;
  }
  /**
   * Sets a plane currently in the cutting section at a given index.
   * @param index The index of the cutting plane to replace.
   * @param plane The plane to be used for cutting.
   * @param referenceGeometry a list of four points representing a quad to be used as reference geometry for the cutting plane. Pass null to use no reference geometry for this cutting plane.
   */
  async setPlane(t, e, i = null) {
    const s = this._cuttingPlanes[t];
    if (s !== void 0 && (s.plane = e.copy(), s.setReferenceGeometry(i), this._isActive))
      return await this._resetCuttingPlane(s), this._engine.updateCuttingSection(this);
  }
  /**
   * Updates the position of a cutting plane and stand-in geometry if present.
   * @param index The index of the cutting plane.
   * @param plane The plane to use for cutting.
   * @param geometryMatrix A matrix that is multiplied by the previous position matrix to update the geometry position.
   * @param finalizePosition If true, sets the result of the geometry matrix multiplication as the new position matrix.
   * @param resetTranslation If true, uses the provided geometry matrix for the geometry position.
   */
  async updatePlane(t, e, i = new Q(), s = !1, r = !1) {
    const o = this._cuttingPlanes[t];
    if (o !== void 0 && (o.plane = e.copy(), this._isActive))
      if (o.instanceNodeId !== null) {
        this._engine.pauseRendering();
        let a = o.getMatrix();
        r && (a = new Q());
        const l = Q.multiply(a, i);
        s && o.setMatrix(l), await Promise.all([
          this._model.setNodeMatrix(o.instanceNodeId, l),
          this._engine.updateCuttingSection(this)
        ]), this._engine.resumeRendering();
      } else
        return this._engine.updateCuttingSection(this);
  }
  /**
   * Removes the cutting plane at the specified index.
   * @param index The index of the cutting plane to remove.
   */
  removePlane(t) {
    const e = [], i = this._cuttingPlanes[t];
    return i !== void 0 && (i.meshId !== null && i.instanceNodeId !== null && e.push(this._destroyMeshes([i.meshId], [i.instanceNodeId])), this._cuttingPlanes.splice(t, 1)), this._isActive && e.push(this._engine.updateCuttingSection(this)), zt(e);
  }
  /**
   * Gets the plane for the item at the given index. In the case of an invalid index, null will be returned.
   * @param index The index of the cutting plane.
   * @returns Plane that is used for cutting at the given index or null.
   */
  getPlane(t) {
    const e = this._cuttingPlanes[t];
    return e !== void 0 ? e.plane.copy() : null;
  }
  /**
   * Gets the [[NodeId]] for the reference geometry for the cutting plane at the given index.
   * In the case of an invalid index or a cutting plane with no reference geometry, null will be returned.
   * @param index the index of the cutting plane.
   * @returns [[NodeId]] of the reference geometry for the cutting plane at the given index or null.
   */
  getNodeId(t) {
    const e = this._cuttingPlanes[t];
    return e !== void 0 ? e.instanceNodeId : null;
  }
  /**
   * Gets the reference geometry for the item at the given index. In the case of an invalid index, null will be returned
   * @param index The index of the cutting plane.
   * @returns A list of four points representing a quad to be used as reference geometry for the cutting plane, or null if there is no reference geometry.
   */
  getReferenceGeometry(t) {
    const e = this._cuttingPlanes[t];
    return e !== void 0 ? e.getReferenceGeometry() : null;
  }
  /**
   * Gets the index of a plane for the corresponding node id. In the case of an invalid id, null will be returned.
   * @param id The [[NodeId]] for the plane reference geometry.
   * @returns The index of a plane associated with the provided [[NodeId]], or null if no plane is found.
   */
  getPlaneIndexByNodeId(t) {
    for (let e = 0; e < this._cuttingPlanes.length; e++)
      if (this._cuttingPlanes[e].instanceNodeId === t)
        return e;
    return null;
  }
  /**
   * Gets the opacity for the plane at the given index.
   * @param index The index of the cutting plane.
   */
  getPlaneOpacity(t) {
    const e = this._cuttingPlanes[t];
    if (e)
      return e.opacity;
  }
  /**
   * Sets the opacity for the plane at the given index.
   *
   * Equivalent to `section.applyPlaneOpacity(index, opacity)`
   *
   * @param index The index of the cutting plane.
   * @param opacity A number between 0 and 1.
   */
  setPlaneOpacity(t, e) {
    this.applyPlaneOpacity(t, e);
  }
  /**
   * Apply the opacity factor to the plane.
   *
   * @param index The index of the cutting plane.
   * @param opacity The value used to change the opacity if needed
   */
  applyPlaneOpacity(t, e) {
    const i = this._cuttingPlanes[t];
    i !== void 0 && (e && (i.opacity = e), i.instanceNodeId !== null && this._model.setNodesOpacity([i.instanceNodeId], i.opacity));
  }
  /**
   * Reapply the opacity of the cutting planes to the engine
   * This function must be explicitly called after _resetOpacity has been emitted by the engine
   */
  resetPlanesOpacity() {
    this._cuttingPlanes.forEach((t, e) => {
      this.applyPlaneOpacity(e);
    });
  }
  /**
   * Sets the color for all planes in the cutting section
   * @param color Color to set
   * @returns Promise that resolves when the operation has completed.
   */
  setColor(t) {
    const e = [];
    for (const i of this._cuttingPlanes)
      i.color.assign(t), i.instanceNodeId !== null && e.push(i.instanceNodeId);
    return this._model.setNodesFaceColor(e, t), Promise.resolve();
  }
  /**
   * Sets the opacity for all planes in the cutting section
   * @param opacity opacity to set
   */
  setOpacity(t) {
    const e = [];
    for (const i of this._cuttingPlanes)
      i.opacity = t, i.instanceNodeId !== null && e.push(i.instanceNodeId);
    this._model.setNodesOpacity(e, t);
  }
  /**
   * Gets the number of planes in this cutting secton.
   * @returns the number of planes in this cutting section
   */
  getCount() {
    return this._cuttingPlanes.length;
  }
  /**
   * Removes all planes from this cutting section. This will also deactivate the cutting section.
   */
  async clear() {
    await this.deactivate(), this._cuttingPlanes.length = 0;
  }
  /**
   * Activates a cutting section for use. A cutting section must have at least one plane to be activated.
   * @returns a promise if the cutting section was activated.
   */
  async activate() {
    if (!this._isActive) {
      if (this._isActive = !0, this._cuttingPlanes.length > 0) {
        this._cuttingManager.hasActiveCuttingSection() || this._engine.setDefaultDepthRange(0, 1 - ih.Cutoff);
        const t = [], e = [];
        for (const i of this._cuttingPlanes)
          t.push(
            this._createCuttingPlaneGeometry(i).then((s) => {
              s !== null && e.push(s);
            })
          );
        await zt(t), this._initCuttingPlanesByNodeId(e);
      }
      return this._engine.addCuttingSection(this);
    }
  }
  /**
   * Removes a cutting section from use.
   */
  async deactivate() {
    if (this._isActive) {
      this._isActive = !1;
      const t = [];
      return t.push(this._destroyGeometry()), t.push(this._engine.removeCuttingSection(this)), this._cuttingManager.hasActiveCuttingSection() || this._engine.setDefaultDepthRange(0, 1), zt(t);
    }
  }
  /**
   * Gets whether a cutting section is active
   * @returns boolean value indicating whether this cutting section is active
   */
  isActive() {
    return this._isActive;
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    const t = [];
    for (let e = 0; e < this._cuttingPlanes.length; e++)
      t[e] = this._cuttingPlanes[e].toJson();
    return {
      planes: t
    };
  }
  async fromJson(t) {
    await this.clear();
    const i = Fo(t).planes;
    for (const s of i) {
      const r = new _u();
      r.fromJson(s), this._cuttingPlanes.push(r);
    }
    return this.activate();
  }
  _initCuttingPlanesByNodeId(t) {
    this._model.setInstanceModifier(Fe.DoNotCut, t, !0), this._model.setInstanceModifier(Fe.DoNotExplode, t, !0), this._cuttingManager.getStandinGeometryPickable() || this._model.setInstanceModifier(Fe.DoNotSelect, t, !0);
  }
  _destroyGeometry() {
    const t = [], e = [];
    for (const i of this._cuttingPlanes)
      i.meshId !== null && t.push(i.meshId), i.instanceNodeId !== null && e.push(i.instanceNodeId), i.meshId = null, i.instanceNodeId = null;
    return this._destroyMeshes(t, e);
  }
  /** @hidden */
  _getInstanceNodeIds() {
    const t = [];
    for (const e of this._cuttingPlanes) {
      const i = e.instanceNodeId;
      i !== null && t.push(i);
    }
    return t;
  }
  async _resetCuttingPlane(t) {
    if (t.meshId !== null && t.instanceNodeId !== null) {
      const e = this._destroyMeshes([t.meshId], [t.instanceNodeId]);
      return t.meshId = null, t.instanceNodeId = null, await e, this._createInstanceGeometry(t);
    } else if (t.referenceGeometry !== null)
      return this._createInstanceGeometry(t);
  }
  async _createInstanceGeometry(t) {
    const e = [], i = await this._createCuttingPlaneGeometry(t);
    i !== null && e.push(i), this._initCuttingPlanesByNodeId(e);
  }
  async _destroyMeshes(t, e) {
    const i = [];
    i.push(this._model.deleteMeshInstances(e)), i.push(this._model.deleteMeshes(t)), await zt(i);
    for (const s of e)
      this._viewer.selectionManager._incrementalBlacklistedInstanceNodes.delete(s);
  }
  async _createCuttingPlaneGeometry(t) {
    const e = t.createMeshData();
    if (e === null)
      return null;
    e.setBackfacesEnabled(!0);
    const i = await this._model.createMesh(e);
    t.meshId = i;
    const s = St.OverrideSceneVisibility | St.ExcludeBounding | St.DoNotXRay, r = t.plane.copy(), o = r.normal.copy().scale(-r.d), a = new Q().setTranslationComponent(o.x, o.y, o.z);
    t.setMatrix(a.copy());
    const l = new bn(
      i,
      a,
      null,
      t.color,
      null,
      null,
      s
    );
    l.setLineColor(t.lineColor), this._engine.pauseRendering();
    const c = await this._model.createMeshInstance(l, void 0, !0, !0);
    return t.instanceNodeId = c, this._viewer.selectionManager._incrementalBlacklistedInstanceNodes.add(c), this._model.setDepthRange([c], ih.Cutoff, 1), this._model.setNodesOpacity([c], t.opacity), this._engine.resumeRendering(), c;
  }
}
const Ki = class {
  /** @hidden */
  constructor(n) {
    this._position = new Fs(0, Bt.Pixels, 0, Bt.Pixels), this._viewportSize = new Fs(
      0.2,
      Bt.MinimumProportionOfCanvas,
      0.2,
      Bt.MinimumProportionOfCanvas
    ), this._anchor = Jt.LowerLeftCorner, this._instanceKeys = [], this._enabled = !1, this._sceneReadyCompleted = be(), this._geometryCreated = !1, this._viewer = n, this._viewer.setCallbacks({
      sceneReady: async () => {
        this._createViewport(), this._updateVisibility(), await this._createGeometry(), this._sceneReadyCompleted.resolve();
      },
      _assemblyTreeReady: async () => {
        await this._sceneReadyCompleted;
        const t = this._viewer.model;
        for (const e of this._instanceKeys) {
          const i = t._getNodeFromInstanceInc(!0, ve.Local, e, !0);
          t._preventNodeDeletion(i);
        }
      },
      _firstAttachment: async () => {
        await this._onCameraUpdate(), this._updateVisibility();
      },
      overlayViewportSet: (t) => {
        t === Vt.AxisTriad && this._onViewportSet();
      }
    });
  }
  /**
   * Sets the color of one axis on this [[AxisTriad]]
   * @param axis The axis that will change color
   * @param color The color to set
   */
  async setAxisColor(n, t) {
    await this._sceneReadyCompleted;
    let e, i;
    switch (n) {
      case Ht.X:
        e = this._instanceKeys[0], i = this._instanceKeys[3];
        break;
      case Ht.Y:
        e = this._instanceKeys[1], i = this._instanceKeys[4];
        break;
      case Ht.Z:
        e = this._instanceKeys[2], i = this._instanceKeys[5];
        break;
      default:
        return;
    }
    const s = this._getScEngine();
    s.setPartColor([ve.Local, e], vt.Faces, t), s.setPartColor([ve.Local, i], vt.Lines, t);
  }
  /**
   * Sets the anchor position for this [[AxisTriad]].
   * @param anchor The anchor position.
   * @returns A promise that resolves on completion.
   */
  async setAnchor(n) {
    return this._anchor = n, await this._sceneReadyCompleted, this._updateViewport();
  }
  /**
   * Gets the anchor position for this [[AxisTriad]].
   * Default position is in the lower left corner.
   * @returns The overlay anchor value of the triad.
   */
  getAnchor() {
    return this._anchor;
  }
  /**
   * Enables this [[AxisTriad]].
   * @returns A promise that resolves on completion.
   */
  enable() {
    return this._enabled = !0, this._updateVisibility(), Promise.resolve();
  }
  /**
   * Disables this [[AxisTriad]].
   * @returns A promise that resolves on completion.
   */
  disable() {
    return this._enabled = !1, this._updateVisibility(), Promise.resolve();
  }
  /**
   * Updates the visibility of this [[AxisTriad]] based on the enabled status.
   * @returns A promise that resolves on completion.
   */
  _updateVisibility() {
    this._enabled ? this._showOverlay() : this._hideOverlay();
  }
  /**
   * Hides the overlay window.
   * @returns A promise that resolves on completion.
   */
  _hideOverlay() {
    this._viewer.overlayManager.setVisibility(Vt.AxisTriad, !1);
  }
  /**
   * Shows the overlay window.
   * @returns A promise that resolves on completion.
   */
  _showOverlay() {
    this._viewer.overlayManager.setVisibility(Vt.AxisTriad, !0);
  }
  /**
   * Gets the current state of this [[AxisTriad]].
   * @returns `true` if enabled and `false` otherwise.
   */
  getEnabled() {
    return this._enabled;
  }
  /**
   * Gets the overlay id. This id should be considered reserved and not be used by client applications.
   * @returns The overlay id used by this [[AxisTriad]].
   */
  getOverlayId() {
    return Vt.AxisTriad;
  }
  _updateViewport() {
    this._viewer.overlayManager.setViewport(
      Vt.AxisTriad,
      this._anchor,
      this._position.x,
      Bt.Pixels,
      this._position.y,
      Bt.Pixels,
      this._viewportSize.x,
      this._viewportSize.xUnit,
      this._viewportSize.y,
      this._viewportSize.yUnit
    );
  }
  _createViewport() {
    const n = this._viewer.overlayManager;
    this._updateViewport();
    const t = new ci();
    t.setPosition(new d(0, 0, 10)), t.setTarget(d.zero()), t.setUp(new d(0, 1, 0)), t.setWidth(Ki._fieldSize), t.setHeight(Ki._fieldSize), t.setProjection(te.Orthographic), n.setCamera(Vt.AxisTriad, t);
  }
  _onViewportSet() {
    const n = this._viewer.overlayManager, t = n._getViewportPosition(Vt.AxisTriad), e = n._getViewportSize(Vt.AxisTriad), i = n.getViewportAnchor(Vt.AxisTriad);
    t === null || e === null || i === null || (this._position = t, this._viewportSize = e, this._anchor = i);
  }
  async _createGeometry() {
    if (this._geometryCreated)
      return;
    const n = [
      this._createAxis(Ki._xRotMatrix, 0, Ki._xColor),
      this._createAxis(Ki._yRotMatrix, 1, Ki._yColor),
      this._createAxis(Ki._zRotMatrix, 2, Ki._zColor),
      this._createAxisLabel(Ht.X, Ki._xColor, 3),
      this._createAxisLabel(Ht.Y, Ki._yColor, 4),
      this._createAxisLabel(Ht.Z, Ki._zColor, 5)
    ], t = await Promise.all(n);
    this._onCameraUpdate();
    const e = [];
    for (const s of t)
      e.push(ve.Local, s);
    this._getScEngine().setPartVisibility(e, !0, !0), this._createGeomCallbacks(), this._geometryCreated = !0;
  }
  _createGeomCallbacks() {
    this._viewer.setCallbacks({
      camera: () => {
        this._onCameraUpdate();
      }
    });
  }
  /** @hidden */
  _geometryHasBeenCreated() {
    return this._geometryCreated;
  }
  /**
   * Determines whether or not a point is inside the axis triad overlay
   * @param mousePos
   * @returns Boolean indicating whether the provided point is inside the axis triad overlay
   */
  insideOverlay(n) {
    const t = this._viewer.overlayManager._toPixelPoint(this._viewportSize), e = this._getOverlayOffset();
    return n.x >= e.x && n.y >= e.y && n.x <= e.x + t.x && n.y <= e.y + t.y;
  }
  /** @hidden */
  _getOverlayOffset() {
    const n = this._viewer.overlayManager._toPixelPoint(this._viewportSize);
    return this._viewer.overlayManager._getOverlayOffset(this._anchor, n);
  }
  /** @hidden */
  _getViewportSize() {
    return this._viewportSize;
  }
  /** @hidden */
  _getViewportPixelSize() {
    return this._viewer.overlayManager._toPixelPoint(this._viewportSize);
  }
  /**
   * Checks if a selection is part of the axis triad, and return the corresponding axis.
   * @param selectionItem selection item to check.
   * @returns Axis if selected, null otherwise.
   */
  getSelectionAxis(n) {
    if (console.assert(this._enabled), n === null || !n.isFaceSelection() || n.overlayIndex() !== Vt.AxisTriad)
      return null;
    const t = this._viewer.model, e = n.getNodeId(), i = t._gatherInstanceIncsFromNodeIds([e], bt.BodyInstance);
    if (i.length !== 2 || i[0] !== ve.Local)
      return null;
    const s = i[1];
    for (let r = 0; r < this._instanceKeys.length; ++r)
      if (this._instanceKeys[r] === s)
        switch (r % 3) {
          case 0:
            return Ht.X;
          case 1:
            return Ht.Y;
          case 2:
            return Ht.Z;
        }
    return null;
  }
  /**
   * Called when the axis triad is clicked. Realigns the view along the axis selected by `selection`
   * or does nothing if no axis is selected.
   * @param selection
   */
  async onClickSelection(n) {
    const t = this.getSelectionAxis(n);
    if (t === null)
      return;
    const e = this._viewer.model, i = this._viewer.view;
    let s;
    switch (t) {
      case Ht.X:
        s = ho.EyeX_UpY;
        break;
      case Ht.Y:
        s = ho.EyeY_UpZ;
        break;
      case Ht.Z:
        s = ho.EyeZ_UpX;
        break;
    }
    const r = await e.getModelBounding(!0, !1), o = i.getCamera();
    let a = this._alignedFitBounding(s, !1, !1, r);
    o.equals(a) && (a = this._alignedFitBounding(s, !0, !1, r)), await i._setCameraPromise(a, Ni);
    const l = this._viewer.model.getAbsoluteRootNode();
    if (this._viewer.model.getNodeChildren(l).length === 0)
      return this._viewer._getScEngine().markCameraAsEmpty();
  }
  _getScEngine() {
    return this._viewer._getScEngine();
  }
  async _createInstance(n, t, e, i, s, r) {
    const o = await this._viewer.model.createMesh(n), a = new bn(o);
    a.setCreationFlags(
      r | St.DoNotCut | St.DoNotExplode | St.ExcludeBounding | St.Invisible
    ), a.setOverlayIndex(Vt.AxisTriad), a.setFaceColor(e), a.setLineColor(i), a.setMatrix(s);
    const h = (await this._getScEngine().createMeshInstance(a))[1];
    return this._instanceKeys[t] = h, h;
  }
  _createAxis(n, t, e) {
    const i = fh(
      dn.CylinderRadius,
      dn.SegmentCount,
      dn.StemHeight,
      dn.ConeBaseRadius,
      dn.CapHeight,
      dn.TaperHeight
    );
    return this._createInstance(
      i,
      t,
      e,
      it.black(),
      n,
      St.None
    );
  }
  _createAxisLabel(n, t, e) {
    const i = new Hi();
    i.setFaceWinding(yn.Clockwise);
    const s = 0.5 * dn.LetterWidth, r = 0.5 * dn.LetterHeight, o = dn.StemHeight + dn.CapHeight + dn.LetterOffsetPos, a = new Q();
    return n === Ht.X ? (i.addPolyline([s, r, 0, -s, -r, 0]), i.addPolyline([-s, r, 0, s, -r, 0]), a.setTranslationComponent(o, 0, 0)) : n === Ht.Y ? (i.addPolyline([-s, r, 0, 0, 0, 0]), i.addPolyline([0, 0, 0, s, r, 0]), i.addPolyline([0, 0, 0, 0, -1.25 * r, 0]), a.setTranslationComponent(0, o, 0)) : n === Ht.Z && (i.addPolyline([-s, r, 0, s, r, 0]), i.addPolyline([s, r, 0, -s, -r, 0]), i.addPolyline([-s, -r, 0, s, -r, 0]), a.setTranslationComponent(0, 0, o)), this._createInstance(
      i,
      e,
      it.black(),
      t,
      a,
      St.ScreenOriented
    );
  }
  _onCameraUpdate() {
    const n = new ci(), t = this._viewer.view.getCamera();
    n.setPosition(
      t.getPosition().subtract(t.getTarget()).normalize()
    ), n.setTarget(d.zero()), n.setUp(t.getUp()), n.setProjection(te.Orthographic), n.setWidth(Ki._fieldSize), n.setHeight(Ki._fieldSize), this._viewer.overlayManager.setCamera(Vt.AxisTriad, n);
  }
  _alignedFitBounding(n, t, e, i) {
    const s = d.subtract(i.max, i.min).length(), r = d.add(d.scale(i.min, 0.5), d.scale(i.max, 0.5)), o = new d(r.x, r.y, r.z + s), a = d.subtract(r, o);
    let l = -a.length();
    const c = e ? -1 : 1;
    let h, u;
    n === ho.None ? (h = a, u = new d(0, c, 0), t && h.negate()) : (t && (l = -l), n & Qa.X ? h = new d(l, 0, 0) : n & Qa.Y ? h = new d(0, l, 0) : (console.assert((n & Qa.Z) !== 0), h = new d(0, 0, l)), n & qa.X ? u = new d(c, 0, 0) : n & qa.Y ? u = new d(0, c, 0) : (console.assert((n & qa.Z) !== 0), u = new d(0, 0, c)));
    const p = d.subtract(r, h), m = this._viewer.view.getCamera();
    return ci.create(
      p,
      r,
      u,
      m.getProjection(),
      s,
      s,
      m.getNearLimit()
    );
  }
};
let Ds = Ki;
Ds._xRotMatrix = Q.createFromOffAxisRotation(new d(0, 0, 1), -90);
Ds._yRotMatrix = new Q();
Ds._zRotMatrix = Q.createFromOffAxisRotation(new d(1, 0, 0), 90);
Ds._xColor = new it(168, 56, 59);
Ds._yColor = new it(96, 166, 50);
Ds._zColor = new it(41, 81, 185);
Ds._fieldSize = 8;
class hy {
  /** @hidden */
  constructor(t, e, i, s) {
    this._cuttingSections = [], this._isInit = !1, this._standinGeometryPickable = !0, this._cappingFaceColor = it.createFromFloat(0.5, 0.5, 0.5), this._cappingLineColor = it.createFromFloat(0.5, 0.5, 0.5), this._cappingIdleCallbackEnabled = !1, this._cappingIdlePromise = null, this._conservativeIsCappingIdle = !1, this._viewer = t, this._model = e, this._callbackManager = i, this._engine = s, t.setCallbacks({
      cappingIdle: (r) => {
        this._conservativeIsCappingIdle = r, r && this._cappingIdlePromise !== null && (this._cappingIdlePromise.resolve(), this._cappingIdlePromise = null);
      },
      _resetAssemblyTreeBegin: () => (this._cappingIdlePromise !== null && (this._cappingIdlePromise.reject(new Mt("Model became reset.")), this._cappingIdlePromise = null), Promise.resolve()),
      _resetOpacity: () => {
        this._cuttingSections.forEach((r) => r.resetPlanesOpacity());
      }
    });
  }
  /**
   * generates reference geometry for a cutting plane.
   * @param axis axis for reference geometry.
   * @param modelBounding modelBounding for geometry size.
   */
  createReferenceGeometryFromAxis(t, e) {
    const i = [];
    switch (t) {
      case Ht.X:
        i.push(new d(0, e.max.y, e.min.z)), i.push(new d(0, e.max.y, e.max.z)), i.push(new d(0, e.min.y, e.max.z)), i.push(new d(0, e.min.y, e.min.z));
        break;
      case Ht.Y:
        i.push(new d(e.min.x, 0, e.min.z)), i.push(new d(e.max.x, 0, e.min.z)), i.push(new d(e.max.x, 0, e.max.z)), i.push(new d(e.min.x, 0, e.max.z));
        break;
      case Ht.Z:
        i.push(new d(e.min.x, e.max.y, 0)), i.push(new d(e.max.x, e.max.y, 0)), i.push(new d(e.max.x, e.min.y, 0)), i.push(new d(e.min.x, e.min.y, 0));
        break;
    }
    return i;
  }
  /**
   * Uses a selection normal and position to create reference geometry for a cutting plane.
   * @param normal face normal.
   * @param position face position.
   * @param modelBounding model bounding for geometry size.
   */
  createReferenceGeometryFromFaceNormal(t, e, i) {
    const s = [], r = new je().setFromPointAndNormal(e, t).d, o = e.copy().add(d.scale(t, r)), a = i.center(), l = d.add(
      a,
      d.scale(t, d.dot(t, d.subtract(o, a)))
    ), c = i.extents().length() / 2, h = d.subtract(l, o), u = d.cross(t, h), p = h.copy().scale(-1), m = u.copy().scale(-1), g = d.add(h, u).normalize().scale(c).add(l), _ = d.add(p, u).normalize().scale(c).add(l), y = d.add(p, m).normalize().scale(c).add(l), b = d.add(h, m).normalize().scale(c).add(l);
    return s.push(g), s.push(_), s.push(y), s.push(b), s;
  }
  /**
   * Activates all cutting sections, and restores any planes contained to the scene.
   */
  activateCuttingSections() {
    const t = [];
    for (const e of this._cuttingSections)
      t.push(e.activate());
    return zt(t);
  }
  /**
   * Deactivates all cutting sections.
   * Cutting planes are not removed from section and can be restored using [[activateCuttingSections]]
   */
  deactivateAllCuttingSections() {
    const t = [];
    for (const e of this._cuttingSections)
      t.push(e.deactivate());
    return zt(t);
  }
  /**
   * Clears all cutting sections.
   * This causes all cutting sections to be deactivated and all their cutting planes removed.
   */
  clearAllCuttingSections() {
    const t = [];
    for (const e of this._cuttingSections)
      t.push(e.clear());
    return zt(t);
  }
  /**
   * Sets the color for all cutting plane reference geometry.
   * @param color
   */
  setCuttingPlaneColor(t) {
    for (const e of this._cuttingSections)
      e.setColor(t);
    return Promise.resolve();
  }
  /**
   * Sets the color to be used for capping geometry faces. If null is passed in as the color object, no capping face will be shown.
   * @param color color to use for capping geometry faces.
   */
  setCappingFaceColor(t) {
    return this._cappingFaceColor = t ? t.copy() : null, this._engine.setCappingFaceColor(this._cappingFaceColor), Promise.resolve();
  }
  /**
   * Gets the color used for capping geometry faces.
   * @returns color used for capping geometry faces.
   */
  getCappingFaceColor() {
    return this._cappingFaceColor ? this._cappingFaceColor.copy() : null;
  }
  /**
   * Sets the color to be used for capping geometry lines. If null is passed in as the color object, no capping line will be shown.
   * @param color color to use for capping geometry lines.
   */
  setCappingLineColor(t) {
    return this._cappingLineColor = t ? t.copy() : null, this._engine.setCappingLineColor(this._cappingLineColor), Promise.resolve();
  }
  /**
   * Gets the color used for capping geometry lines.
   * @returns color used for capping geometry lines.
   */
  getCappingLineColor() {
    return this._cappingLineColor ? this._cappingLineColor.copy() : null;
  }
  /**
   * Gets a cutting section by index. Cutting sections are created automatically by the system and may be queried at any point during or after the sceneReady callback has been triggered.
   * @returns the cutting section for the given index.
   */
  getCuttingSection(t) {
    return this._isInit && t < this._cuttingSections.length ? this._cuttingSections[t] : null;
  }
  /**
   * Gets the total number of planes supported by each cutting section.
   * Cutting planes contained in the same cutting section will work together (an object is only cut if all cutting planes in a section would cut it).
   * Cutting planes in separate cutting sections do not work together when cutting (an object is cut if any one of the cutting sections would cut it).
   * @returns the number of planes each cutting section may contain.
   */
  getCuttingSectionCapacity() {
    return this._cuttingLimits !== void 0 ? this._cuttingLimits.maxCuttingPlanesPerSection : 0;
  }
  /**
   * Gets the total number of cutting sections supported by the system.
   * @returns the number of cutting sections supported by the system.
   */
  getCuttingSectionCount() {
    return this._cuttingLimits !== void 0 ? this._cuttingLimits.maxCuttingSections : 0;
  }
  /**
   * Gets the cutting section containing the cutting plane with the given node ID. If the supplied node ID is not contained by any cutting section null will be returned.
   * @param nodeId a node ID for cutting plane stand-in geometry.
   * @returns the CuttingSection that contains the plane with the given node id or null if none contain it.
   */
  getCuttingSectionFromNodeId(t) {
    if (t !== null) {
      for (const e of this._cuttingSections)
        if (e._getInstanceNodeIds().indexOf(t) >= 0)
          return e;
    }
    return null;
  }
  /**
   * Gets all nodes that have capping drawn for them.
   * @returns an array of node IDs that have capping drawn for them
   */
  async getNodesWithCapping() {
    const t = await this._engine.getCappedInstances(), e = [];
    for (let i = 0; i < t.length - 1; i += 2) {
      const s = this._model._getNodeFromInstanceInc(
        !1,
        t[i],
        t[i + 1],
        !1
      );
      e.push(s);
    }
    return e;
  }
  /**
   * Sets whether stand-in geometry for cutting sections should be pickable.
   * If this option is set to false, picking rays will pass though stand-in geometry for cutting planes.
   * The default value is not pickable.
   * @param pickable boolean value indicating whether stand-in geometry should be pickable in the scene.
   */
  setStandinGeometryPickable(t) {
    this._standinGeometryPickable = t;
    const e = this._gatherStandinGeometryIds();
    return this._model.setInstanceModifier(Fe.DoNotSelect, e, !t), Promise.resolve();
  }
  /**
   * Gets whether stand-in geometry for cutting sections is pickable.
   * @returns boolean value indicating whether stand-in geometry for cutting sections is pickable.
   */
  getStandinGeometryPickable() {
    return this._standinGeometryPickable;
  }
  /** @hidden */
  _setStandinGeometryVisible(t) {
    const e = this._gatherStandinGeometryIds(), i = this._model._gatherInstanceIncsFromNodeIds(e);
    this._engine.pauseRendering(() => {
      this._engine.setPartVisibility(i, t, !1);
    });
  }
  /**
   * Sets the delay used by delayCapping() in milliseconds.
   * @param delayInMilliseconds The delay amount.
   */
  setCappingDelay(t) {
    this._engine.setCappingDelay(t);
  }
  /**
   * Delays capping processing by a fixed time interval.
   */
  delayCapping() {
    this._engine.delayCapping();
  }
  /**
   * Enables or disables activation of "cappingIdle" callback event.
   * @param enable Enables or disables activation of "cappingIdle" callback event.
   * @returns A promise returning whether or not capping generation was idle when this call resolves.
   */
  enableCappingIdleCallback(t) {
    return t !== this._cappingIdleCallbackEnabled && (this._cappingIdleCallbackEnabled = t, this._conservativeIsCappingIdle = !1, !t && this._cappingIdlePromise !== null && (this._cappingIdlePromise.reject(
      new Mt("Capping idle callback became disabled.")
    ), this._cappingIdlePromise = null)), this._engine.enableCappingIdleCallback(t);
  }
  async waitForCappingIdle() {
    if (!this._cappingIdleCallbackEnabled)
      throw console.assert(this._cappingIdlePromise === null), new Mt("Capping idle callback is not enabled.");
    if (!this._conservativeIsCappingIdle)
      return this._cappingIdlePromise === null && (this._cappingIdlePromise = be()), this._cappingIdlePromise;
  }
  /**
   * Sets whether capping geometry will show.
   * The default value is true.
   * @param cappingGeometryVisibility
   */
  setCappingGeometryVisibility(t) {
    return this._engine.setCappingGeometryVisibility(t), Promise.resolve();
  }
  /**
   * Gets whether capping geometry will show
   * @returns boolean value indicating whether capping geometry will show
   */
  getCappingGeometryVisibility() {
    return this._engine.getCappingGeometryVisibility();
  }
  /**
   * @returns the number of active cutting sections.
   */
  getActiveCuttingSectionCount() {
    let t = 0;
    if (this._cuttingLimits)
      for (let e = 0; e < this._cuttingLimits.maxCuttingSections; e++) {
        const i = this.getCuttingSection(e);
        i != null && i.isActive() && (t += i.getCount());
      }
    return t;
  }
  /** @hidden */
  _init() {
    if (!this._isInit) {
      this._cuttingLimits = this._engine.getCuttingSectionLimits();
      for (let t = 0; t < this._cuttingLimits.maxCuttingSections; t++) {
        const e = new cy(
          this._viewer,
          this._model,
          this._callbackManager,
          this,
          this._engine
        );
        this._cuttingSections.push(e);
      }
      this._isInit = !0;
    }
  }
  /** @hidden */
  _isInitialized() {
    return this._isInit;
  }
  /**
   * Updates all cutting plane geometry.
   */
  refreshPlaneGeometry() {
    const t = [];
    for (const e of this._cuttingSections)
      for (let i = 0; i < e.getCount(); i++) {
        const s = e.getPlane(i);
        s !== null && t.push(e.updatePlane(i, s, new Q(), !1, !1));
      }
    return zt(t);
  }
  /**
   * @returns true if there is an active cutting section.
   */
  hasActiveCuttingSection() {
    if (this._cuttingLimits)
      for (let t = 0; t < this._cuttingLimits.maxCuttingSections; t++) {
        const e = this.getCuttingSection(t);
        if (e !== null && e.isActive())
          return !0;
      }
    return !1;
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    const t = [];
    for (let e = 0; e < this._cuttingSections.length; e++)
      t[e] = this._cuttingSections[e].toJson();
    return {
      cuttingSections: t,
      cappingGeometryVisibility: this.getCappingGeometryVisibility(),
      cappingFaceColor: this.getCappingFaceColor(),
      cappingLineColor: this.getCappingLineColor(),
      pickable: this.getStandinGeometryPickable()
    };
  }
  /**
   * Removes any cutting planes in the scene, and restores cutting planes from a json object.
   * @param json
   */
  async fromJson(t) {
    const e = Fo(t), i = [], s = e.cuttingSections;
    for (let r = 0; r < s.length; r++) {
      const o = s[r], a = this._cuttingSections[r];
      i.push(a.fromJson(o));
    }
    this.setStandinGeometryPickable(e.pickable), i.push(this.setCappingGeometryVisibility(e.cappingGeometryVisibility)), i.push(this.setCappingFaceColor(it.fromJson(e.cappingFaceColor))), i.push(this.setCappingLineColor(it.fromJson(e.cappingLineColor))), await Promise.all(i), this._callbackManager.trigger("cuttingSectionsLoaded");
  }
  _gatherStandinGeometryIds() {
    const t = [];
    for (const e of this._cuttingSections) {
      const i = e._getInstanceNodeIds();
      for (const s of i)
        t.push(s);
    }
    return t;
  }
}
class uy {
  /** @hidden */
  constructor(t, e, i) {
    this._explodeActive = !1, this._explodeMagnitude = 0, this._model = t, this._engine = e, i.bind({
      _modelSwitched: async () => {
        this.stop();
      }
    });
  }
  /**
   * Starts an explode operation. This will cancel any currently active explode operation.
   * @param nodeIds an array of NodeId for the parts that should be exploded. If this parameter is omitted or is an empty array, the entire model will be considered for explosion.
   * @param explosionVector the vector to use for the center of the explosion.
   * @returns a promise that resolves when this operation is complete.
   */
  start(t, e) {
    return this.getActive() ? (this.stop(), this._doExplode(t, e)) : this._doExplode(t, e);
  }
  /**
   * Sets the explosion magnitude if there is an active explosion operation.
   * A value of 1.0 indicates that the distance between a part's exploded center, and exploded center will be double.
   * @param magnitude the magnitude for the explosion.
   * @returns a promise that resolves when this operation is complete.
   */
  async setMagnitude(t) {
    if (t > 0 && !this._explodeActive ? await this.start() : t === 0 && this._explodeActive && this.stop(), this._explodeActive)
      return this._explodeMagnitude = t, this._engine.setExplodeMagnitude(t);
  }
  /**
   * Terminates any active explode operation.
   * @returns a promise that resolves when this operation is complete.
   */
  stop() {
    return this._engine.stopExplode(), this._explodeMagnitude = 0, this._explodeActive = !1, this._engine.setExplodeMagnitude(0), Promise.resolve();
  }
  /**
   * Gets the current explode magnitude. This will always return 0 when there is no active explode operation.
   * @returns the current explode magnitude.
   */
  getMagnitude() {
    return this._explodeMagnitude;
  }
  /**
   * Indicates whether there is a currently active explode operation.
   * @returns boolean value indicating if there is an active explode operation.
   */
  getActive() {
    return this._explodeActive;
  }
  async _doExplode(t, e) {
    this._explodeActive = !0;
    let i;
    if (t !== void 0 && t.length > 0 ? i = this._model._gatherInstanceIncsFromNodeIds(t) : i = [], e)
      this._engine.startExplode(i, e);
    else {
      const s = await this._model.getModelBounding(!0, !1);
      this._engine.startExplode(i, s.center());
    }
  }
}
class dy {
  /**
   * @param type The light's type. See [[type]].
   * @param space The space in which a light is defined. See [[space]]
   * @param position The light's position. See [[position]].
   * @param color The light's color. See [[color]].
   */
  constructor(t, e, i, s) {
    this.type = t, this.space = e, this.position = i, this.color = s;
  }
}
class my extends Hl {
  /** @hidden */
  constructor(t, e) {
    super(), this._markupArray = [], this._viewer = t, this._callbackManager = e, this._callbackManager.bind({
      modelSwitched: () => {
        this.removeAllLines();
      }
    });
  }
  /**
   * Adds a new Line to the Line Manager
   * @param lineItem LineMarkup Object that will be added
   */
  async addLine(t) {
    this._markupArray.push(t), await t.updateLine(), this._callbackManager.trigger("lineCreated", t);
  }
  /**
   * Removes an existing line item.
   * @param lineItem the line item to remove.
   */
  async removeLine(t) {
    for (let e = 0; e < this._markupArray.length; e++)
      this._markupArray[e].getId() === t.getId() && (await t.removeLine(), this._markupArray.splice(e, 1), this._callbackManager.trigger("lineDeleted", t));
  }
  /**
   * Removes all line items.
   */
  removeAllLines() {
    const t = [];
    for (let e = this._markupArray.length - 1; e >= 0; e--) {
      const i = this._markupArray[e];
      t.push(
        i.removeLine().then(() => {
          this._callbackManager.trigger("lineDeleted", i);
        })
      ), this._markupArray.splice(e, 1);
    }
    return zt(t);
  }
  /**
   * Return an array of line items.
   * @returns array of all line items.
   */
  getAllLines() {
    return this._markupArray.slice(0);
  }
  /**
   * Removes the most recently added line item.
   */
  async removeLastLine() {
    this._markupArray.length > 0 && await this.removeLine(this._markupArray[this._markupArray.length - 1]);
  }
  /**
   * Gets a line markup item associated with a node id.
   * @param id
   */
  getLineByNodeId(t) {
    for (const e of this._markupArray) {
      const i = e.getNodeId();
      if (i !== null && i === t)
        return e;
    }
    return null;
  }
  /**
   * @returns JSON Array with line markup
   */
  exportMarkup() {
    const t = [];
    for (const e of this._markupArray)
      t.push(e.toJson());
    return t;
  }
  async _handleLoadLine(t) {
    return t instanceof Dr ? (await this.addLine(t), this._callbackManager.trigger("lineLoaded", t), !0) : !1;
  }
  /**
   * Loads JSON markup data
   * @param lineData
   * @param viewer
   */
  loadData(t) {
    const e = [];
    for (const i of t) {
      if (!i.hasOwnProperty("className"))
        continue;
      const s = mh(i.className);
      if (s) {
        const r = s(i, this._viewer);
        r instanceof Promise ? e.push(
          r.then((o) => this._handleLoadLine(o))
        ) : e.push(this._handleLoadLine(r));
      }
    }
    return Promise.all(e);
  }
}
class py extends Hl {
  constructor(t, e, i, s, r, o) {
    super(), this._markupViews = /* @__PURE__ */ new Map(), this._defaultViewCounter = 1, this._markupItemManager = e, this._callbackManager = i, this._explodeManager = s, this._cuttingManager = r, this._viewer = t, this._sheetManager = o, this._initEvents();
  }
  _initEvents() {
    this._callbackManager.bind({
      modelSwitchStart: () => {
        this._markupItemManager.shutdown();
      }
    });
  }
  getView(t) {
    const e = this._markupViews.get(t);
    return e !== void 0 ? e : null;
  }
  getViewKeys() {
    const t = [];
    return this._markupViews.forEach((e, i) => {
      t.push(i);
    }), t;
  }
  async loadData(t) {
    const e = [];
    for (const i of t) {
      const s = ea._fromJson(i, this._viewer).then((r) => {
        if (!r.itemResults.every(Boolean))
          return !1;
        const o = r.markupView, a = o.getUniqueId();
        return this._markupViews.has(a) ? !1 : (this._markupViews.set(a, o), this._callbackManager.trigger("viewLoaded", o), !0);
      });
      e.push(s);
    }
    return Promise.all(e);
  }
  exportMarkup() {
    const t = [];
    return this._markupViews.forEach((e) => {
      t.push(e.toJson());
    }), t;
  }
  createView(t = this._createDefaultViewName(), e = !0, i = null, s = null, r = null, o = null) {
    const a = this._viewer.view, l = Qi(), c = new ea(
      l,
      t,
      a.getCamera(),
      this._explodeManager.getMagnitude(),
      this._cuttingManager.toJson(),
      i
    );
    return this._markupViews.set(l, c), c.setLineVisibility(a.getLineVisibility()), c.setFaceVisibility(a.getFaceVisibility()), s !== null && (c.setDefaultVisibility(s.defaultVisibility), c.setVisibilityExceptions(s.visibilityExceptions)), r !== null && c.setColorMap(r), o !== null && c.setSnapshotImage(o), this._markupItemManager.setActiveView(c), e && this._callbackManager.trigger("viewCreated", c), c;
  }
  async _activateSheet(t) {
    if (t !== null)
      return this._sheetManager.setActiveSheetId(t, !0, !1);
  }
  async _activateViewImpl(t, e) {
    await this._activateSheet(t.getSheetId());
    const i = this._viewer.view;
    i.setFaceVisibility(t.getFaceVisibility()), i.setLineVisibility(t.getLineVisibility()), e > 0 ? (await this._markupItemManager.setActiveView(null), await i._setCameraPromise(t.getCamera(), e)) : i.setCamera(t.getCamera()), await this._setActiveView(t);
  }
  _activateView(t, e) {
    const i = this._markupViews.get(t);
    if (i !== void 0) {
      const s = this._activateViewImpl(i, e);
      return os(!0, s);
    } else
      return os(!1, Promise.resolve());
  }
  async activateView(t, e = Ni) {
    return this._activateView(t, e);
  }
  /** This is a helper for `activateView`. */
  async _setActiveView(t) {
    if (this._viewer.model.isDrawing())
      if (t.getSheetId() === null)
        await this._viewer.sheetManager.deactivateSheets(!0, !0);
      else {
        const e = t.getVisibilityExceptions(), i = t.getDefaultVisibility();
        if (e.size > 0 && i) {
          const s = [];
          e.forEach((r) => {
            s.push(r);
          }), await this._viewer.model.setNodesVisibility(s, !1);
        }
      }
    else {
      const e = t.getDefaultVisibility(), i = t.getVisibilityExceptions();
      await this._viewer.model.setBodyNodesVisibility(
        this._viewer.model.getAbsoluteRootNode(),
        (s) => i.has(s) ? !e : e
      );
    }
    await this._markupItemManager.setActiveView(t), await this._cuttingManager.fromJson(t.getCuttingPlaneData()), await this._viewer.model.setNodesColors(t.getColorMap()), await this._explodeManager.setMagnitude(t.getExplodeMagnitude());
  }
  deleteView(t) {
    const e = this._markupViews.get(t);
    return e !== void 0 ? (this._callbackManager.trigger("viewDeleted", e), e === this._markupItemManager.getActiveView() && this._markupItemManager.setActiveView(null), this._markupViews.delete(t), !0) : !1;
  }
  _createDefaultViewName() {
    return `View ${this._defaultViewCounter++}`;
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this.exportMarkup();
  }
}
class gy {
  /** @hidden */
  constructor(t, e, i, s, r, o, a) {
    this._markupTypeMap = /* @__PURE__ */ new Map(), this._domElements = t, this._callbackManager = s, this._viewer = a, this._sheetManager = r, this._sheetManager.setMarkupManager(this), this._noteTextManager = o, this._renderer = new xm(), this._itemManager = new bm(
      this._callbackManager,
      this._domElements,
      this._renderer
    ), this._viewManager = new py(
      this._viewer,
      this._itemManager,
      this._callbackManager,
      a.explodeManager,
      a.cuttingManager,
      this._sheetManager
    ), this._measurementManager = e, this._lineManager = i;
  }
  /**
   * Registers a MarkupTypeManager to add markup to exported data.
   * @param markupTypeManager
   */
  registerMarkupTypeManager(t, e) {
    this._markupTypeMap.set(t, e);
  }
  /**
   * Creates a new view based on the current camera, line, and face visibility values.
   * @param name optional name for the view. If omitted or null, the system will generate a default name
   * @param triggerEvent optional parameter indicating whether a [[CallbackMap.viewCreated]] event should be triggered. This parameter defaults to true
   * @param visibilityState optional parameter
   * @returns Unique identifier for the new view
   */
  createMarkupView(t, e = !0, i = null, s = null, r = null) {
    const o = this._viewer.sheetManager.getActiveSheetId();
    return this._viewManager.createView(
      t,
      e,
      o,
      i,
      s,
      r
    ).getUniqueId();
  }
  /**
   * Gets a [[MarkupView]] object from the viewer.
   * @param uniqueId the handle for the view object to retreive
   * @returns [[MarkupView]] object for the corresponding ID or null if no view was found
   */
  getMarkupView(t) {
    return this._viewManager.getView(t);
  }
  /**
   * @returns an array of string keys for all markup views
   */
  getMarkupViewKeys() {
    return this._viewManager.getViewKeys();
  }
  /**
   * Activates a [[MarkupView]].
   * @param uniqueId the handle for the [[MarkupView]] object to activate
   * @param duration the time in milliseconds for the transition to this view
   */
  async activateMarkupViewWithPromise(t, e = Ni) {
    return this._viewManager.activateView(t, e);
  }
  /**
   * Returns the currently active [[MarkupView]].
   * @returns [[MarkupView]] object for the currently active view, or null if no view is active
   */
  getActiveMarkupView() {
    return this._itemManager.getActiveView();
  }
  /**
   * Deletes a [[MarkupView]] object.
   * @param uniqueId the handle for the view object to delete
   * @returns true if a [[MarkupView]] with the supplied uniqueId was deleted, false otherwise
   */
  deleteMarkupView(t) {
    return this._viewManager.deleteView(t);
  }
  /**
   * Registers a [[MarkupItem]] to be rendered with the 3D view.
   * @param markupItem the item to register
   * @returns unique handle to this [[MarkupItem]].
   */
  registerMarkup(t) {
    const e = this._itemManager.registerMarkupItem(t);
    return this.updateLater(), e;
  }
  /**
   * Unregisters a [[MarkupItem]]. It will no longer be rendered with the 3D view.
   * @param uniqueId unique handle to the object that was returned from [[registerMarkup]]
   */
  unregisterMarkup(t) {
    this._itemManager.unregisterMarkupItem(t), this.updateLater();
  }
  /**
   * Add an HTML element to the markup element layer. The element will have its ID set to a system generated unique identifier.
   * @param element the HTML Element to add
   * @returns system generated unique identifier which is the id of the passed in object
   */
  addMarkupElement(t) {
    const e = Qi();
    return t.id = e, this._domElements.getRedlineElement().appendChild(t), e;
  }
  /**
   * Removes a markup element from the markup element layer
   * @param uniqueId unique handle to the object that was returned from [[registerMarkup]]
   */
  removeMarkupElement(t) {
    const e = this._domElements.getRedlineElement();
    for (let i = 0; i < e.children.length; i++) {
      const s = e.children.item(i);
      s !== null && s.id === t && e.removeChild(s);
    }
  }
  /**
   * Redraws the markup without rendering the scene. Useful when markup is added or removed but the scene is not affected.
   */
  refreshMarkup() {
    this.updateLater();
  }
  updateLater() {
    this._itemManager.updateLater();
  }
  /**
   * Picks a [[MarkupItem]]. Tests scene based and markup attached to the active view (if any)
   * @param point position to pick against
   * @returns [[MarkupItem]] that was selected or null if none was picked
   */
  pickMarkupItem(t) {
    return this._itemManager.pick(t);
  }
  /**
   * Gets the pick tolerance in pixels for picking a [[MarkupItem]]
   * @returns Current tolerance
   */
  getPickTolerance() {
    return this._itemManager.getPickTolerance();
  }
  /**
   * Sets the pick tolerance in pixels for picking a [[MarkupItem]]
   * @param tolerance The new tolerance
   */
  setPickTolerance(t) {
    return this._itemManager.setPickTolerance(t);
  }
  /**
   * Selects a [[MarkupItem]]. Pass null to clear the selection.
   * @param markupItem The [[MarkupItem]] to select.
   */
  selectMarkup(t) {
    this._itemManager.select(t);
  }
  /**
   * Returns the currently selected [[MarkupItem]], or null if nothing is currently selected
   * @returns selected [[MarkupItem]]
   */
  getSelectedMarkup() {
    return this._itemManager.getSelected();
  }
  /**
   * export markup from the viewer
   * @returns Serialized markup objects
   */
  exportMarkup() {
    const t = {
      views: this._viewManager.exportMarkup(),
      notes: this._noteTextManager.exportMarkup(),
      measurement: this._measurementManager.exportMarkup(),
      lines: this._lineManager.exportMarkup()
    };
    return this._markupTypeMap.forEach((e, i) => {
      t[i] = e.exportMarkup();
    }), t;
  }
  /**
   * Loads markup data into the viewer.
   * @param data markup data to be loaded into the viewer
   */
  async loadMarkupData(t) {
    return typeof t == "string" && (t = JSON.parse(t)), this._loadMarkupData(t);
  }
  async _loadMarkupData(t) {
    const e = [];
    if (t.hasOwnProperty("views")) {
      const i = this._viewManager.loadData(t.views).then((s) => s.every(Boolean));
      e.push(i);
    }
    if (t.hasOwnProperty("notes")) {
      const i = this._noteTextManager.loadData(t.notes).then((s) => s.every(Boolean));
      e.push(i);
    }
    if (t.hasOwnProperty("measurement")) {
      const i = this._measurementManager.loadData(t.measurement).then((s) => s.every(Boolean));
      e.push(i);
    }
    if (t.hasOwnProperty("lines")) {
      const i = this._lineManager.loadData(t.lines).then((s) => s.every(Boolean));
      e.push(i);
    }
    return this._markupTypeMap.forEach((i, s) => {
      if (t.hasOwnProperty(s)) {
        const r = i.loadData(t[s]).then((o) => o.every(Boolean));
        e.push(r);
      }
    }), Promise.all(e).then((i) => i.every(Boolean));
  }
  /**
   * Returns a the interface to the [[MarkupRenderer]].
   * @returns [[MarkupRenderer]] interface
   */
  getRenderer() {
    return this._renderer;
  }
  /** @hidden */
  _shutdown() {
    this._itemManager.shutdown(), this._renderer._clear();
  }
  /** @hidden */
  _update() {
    this._itemManager.update();
  }
  /** @hidden */
  async _setActiveMarkupView(t) {
    return this._itemManager.setActiveView(t);
  }
  /** @hidden */
  _getItemManager() {
    return this._itemManager;
  }
}
class fy extends Hl {
  /** @hidden */
  constructor(t, e) {
    super(), this._markupArray = [], this._color = new it(0, 0, 0), this._edgeColor = new it(0, 0, 0), this._viewer = t, this._callbackManager = e, this._callbackManager.bind({
      modelSwitched: () => {
        this.removeAllMeasurements();
      }
    });
  }
  /**
   * Adds a new Measurement to the Measure Manager
   * @param measurementItem MeasureMarkup Object that will be added
   */
  addMeasurement(t) {
    this._markupArray.push(t);
    const e = this._viewer.markupManager.registerMarkup(t);
    return t._setId(e), e;
  }
  /**
   * Triggers a measurementCreated callback
   * @param measureItem
   * @param triggerEvent boolean trigger a callback event
   */
  finalizeMeasurement(t) {
    this._callbackManager.trigger("measurementCreated", t);
  }
  /**
   * Removes an existing measurement item.
   * @param measurementItem the measurement item to remove.
   */
  removeMeasurement(t) {
    for (let e = 0; e < this._markupArray.length; e++)
      if (this._markupArray[e]._getId() === t._getId()) {
        this._markupArray.splice(e, 1), this._viewer.markupManager.unregisterMarkup(t._getId()), this._callbackManager.trigger("measurementDeleted", t);
        break;
      }
  }
  /**
   * Removes all measurement items.
   */
  removeAllMeasurements() {
    for (let t = this._markupArray.length - 1; t >= 0; t--) {
      const e = this._markupArray[t];
      this._viewer.markupManager.unregisterMarkup(e._getId()), this._markupArray.splice(t, 1), this._callbackManager.trigger("measurementDeleted", e);
    }
  }
  /**
   * Return an array of measurement items.
   * @returns array of all measurement items.
   */
  getAllMeasurements() {
    return this._markupArray.slice(0);
  }
  /**
   * Removes the most recently added measurement item.
   */
  removeLastMeasurement() {
    this._markupArray.length > 0 && this.removeMeasurement(this._markupArray[this._markupArray.length - 1]);
  }
  /**
   * Sets the current measurement color.
   * @param color the measurement color to set.
   */
  setMeasurementColor(t) {
    this._color.assign(t);
  }
  /**
   * Gets the current measurement color.
   * @returns color current measurement color.
   */
  getMeasurementColor() {
    return this._color.copy();
  }
  /**
   * Sets the current measurement edge color.
   * @param color the measurement edge color to set.
   */
  setMeasurementEdgeColor(t) {
    this._edgeColor.assign(t);
  }
  /**
   * Gets the current measurement edge color.
   * @returns color current measurement edge color.
   */
  getMeasurementEdgeColor() {
    return this._edgeColor.copy();
  }
  /**
   * @returns JSON Array with measurement markup
   */
  exportMarkup() {
    const t = [];
    for (const e of this._markupArray)
      e != null && e.isMarkupValid() && t.push(e.toJson());
    return t;
  }
  _handleLoadMeasurement(t) {
    return t instanceof fi ? (this.addMeasurement(t), this._callbackManager.trigger("measurementLoaded", t), !0) : !1;
  }
  /**
   * Loads JSON markup data
   * @param measurementData
   * @param viewer
   */
  loadData(t) {
    const e = [];
    for (const i of t) {
      if (!i.hasOwnProperty("className"))
        continue;
      const s = mh(i.className);
      if (s) {
        const r = s(i, this._viewer);
        r instanceof Promise ? e.push(
          r.then((o) => this._handleLoadMeasurement(o))
        ) : e.push(Promise.resolve(this._handleLoadMeasurement(r)));
      }
    }
    return Promise.all(e);
  }
}
const nh = class {
  /** @hidden */
  constructor(n) {
    this._position = new Fs(0, Bt.Pixels, 0, Bt.Pixels), this._viewportSize = new Fs(
      0.2,
      Bt.MinimumProportionOfCanvas,
      0.2,
      Bt.MinimumProportionOfCanvas
    ), this._anchor = Jt.UpperRightCorner, this._dimension = 3, this._fieldSize = 8, this._instanceKeys = [], this._enabled = !1, this._textImageId = null, this._selectionFaceColor = new it(76, 186, 240), this._outlineColor = new it(17, 94, 133), this._lastSelectedNodes = [], this._nodeIds = [], this._adjacentFaces = [], this._preserveModelUp = !0, this._cameraRotation = 0, this._lastOrientation = null, this._lastCamera = null, this._lastFaceIndex = null, this._textWidths = [], this._sceneReadyCompleted = be(), this._texturesReady = !1, this._geometryCreated = !1, this._viewer = n, this._fontSize = 25, this._fontInfo = `${this._fontSize}px Arial`, this._textureSize = 512, this._viewer.setCallbacks({
      sceneReady: () => {
        (async () => (this._createViewport(), this._updateVisibility(), await this._createGeometry(), this._sceneReadyCompleted.resolve()))();
      },
      _assemblyTreeReady: async () => (await this._sceneReadyCompleted, this._setTextures()),
      _firstAttachment: async () => {
        this._onCameraUpdate(), this._updateVisibility();
      },
      camera: () => {
        this._onCameraUpdate();
      },
      overlayViewportSet: (t) => {
        t === Vt.NavCube && this._onViewportSet();
      },
      transitionEnd: () => {
        this._onCameraUpdate();
      },
      viewAxes: () => {
        this._updateOrientationMatrices();
      },
      _resetOpacity: () => {
        this._viewer.model.setNodesOpacity(this._nodeIds.slice(1), 0);
      },
      viewOrientation: (t) => {
        this._lastOrientation = t, this._cameraRotation = 0, this._lastCamera = this._viewer.view.getCamera();
      }
    });
  }
  /**
   * Sets the anchor position for the NavCube.
   * @param anchor the anchor position.
   */
  async setAnchor(n) {
    return this._anchor = n, await this._sceneReadyCompleted, this._updateViewport();
  }
  /**
   * Gets the anchor position for the NavCube. Default position is in the UpperRightCorner, see [[OverlayAnchor]] for more details.
   */
  getAnchor() {
    return this._anchor;
  }
  /**
   * Enables the NavCube.
   */
  enable() {
    return this._enabled = !0, this._updateVisibility(), Promise.resolve();
  }
  /**
   * Disables the NavCube.
   */
  disable() {
    return this._enabled = !1, this._updateVisibility(), Promise.resolve();
  }
  /**
   * Determines if model up or camera up will the preserved when navigating with the NavCube.
   * If model up is preserved, navigation with the NavCube will keep the model upright all the time.
   * If camera up is preserved, navigation with the NavCube will attempt to preserve the current up direction of
   * the camera as much as possible.
   * Defaults to `true`.
   * @param preserve If true, model up is preserved. Otherwise, camera up is preserved.
   */
  setPreserveModelUp(n) {
    this._preserveModelUp = n;
  }
  /**
   * Gets the NavCube preserveModelUp state.
   * @returns true if model up is preserved, false if camera up is preserved.
   */
  getPreserveModelUp() {
    return this._preserveModelUp;
  }
  /**
   * Sets the visibility for the NavCube based on the enabled and textures state.
   */
  _updateVisibility() {
    this._enabled && this._texturesReady ? this._showOverlay() : this._hideOverlay();
  }
  /**
   * Hides the overlay window
   */
  _hideOverlay() {
    this._viewer.overlayManager.setVisibility(Vt.NavCube, !1);
  }
  /**
   * Shows the overlay window
   */
  _showOverlay() {
    this._viewer.overlayManager.setVisibility(Vt.NavCube, !0);
  }
  /**
   * Gets whether the NavCube is currently enabled.
   */
  getEnabled() {
    return this._enabled;
  }
  /**
   * Gets the associated overlay id.
   */
  getOverlayId() {
    return Vt.NavCube;
  }
  async _setTextures() {
    if (!this._textImageId || this._nodeIds.length > 0 || this._instanceKeys.length <= 0)
      return;
    const n = this._viewer.model;
    for (const t of this._instanceKeys) {
      const e = n._getNodeFromInstanceInc(!0, ve.Local, t, !0);
      this._nodeIds.push(e), n._preventNodeDeletion(e);
    }
    n.setNodesOpacity(this._nodeIds.slice(1), 0), await n.setNodesTexture([this._nodeIds[0]], {
      imageId: this._textImageId
    }), this._texturesReady = !0, this._updateVisibility();
  }
  _updateViewport() {
    this._viewer.overlayManager.setViewport(
      Vt.NavCube,
      this._anchor,
      this._position.x,
      Bt.Pixels,
      this._position.y,
      Bt.Pixels,
      this._viewportSize.x,
      this._viewportSize.xUnit,
      this._viewportSize.y,
      this._viewportSize.yUnit
    );
  }
  _createViewport() {
    const n = this._viewer.overlayManager;
    this._updateViewport();
    const t = new ci();
    t.setPosition(new d(0, 0, 10)), t.setTarget(d.zero()), t.setUp(new d(0, 1, 0)), t.setWidth(this._fieldSize), t.setHeight(this._fieldSize), t.setProjection(te.Orthographic), n.setCamera(Vt.NavCube, t);
  }
  _onViewportSet() {
    const n = this._viewer.overlayManager, t = n._getViewportPosition(Vt.NavCube), e = n._getViewportSize(Vt.NavCube), i = n.getViewportAnchor(Vt.NavCube);
    t === null || e === null || i === null || (this._position = t, this._viewportSize = e, this._anchor = i);
  }
  async _createGeometry() {
    if (this._geometryCreated)
      return;
    const n = this._initializeTextures();
    let t = 0;
    const e = [];
    e.push(this._createCube(t++, this._dimension));
    const i = [];
    i.push(this._makeRotationMatrixX(-0.5 * Math.PI)), i.push(this._makeRotationMatrixX(0.5 * Math.PI)), i.push(this._makeRotationMatrixY(0.5 * Math.PI)), i.push(this._makeRotationMatrixY(-0.5 * Math.PI)), i.push(this._makeRotationMatrixZ(0.5 * Math.PI)), i.push(this._makeRotationMatrixZ(-0.5 * Math.PI));
    const s = this._dimension / 4, r = this._dimension / 2, o = -0.01, a = [], l = new d(0, 0, 0);
    let c = new d(0, 0, 0), h = new d(0, 0, 0);
    for (let _ = 0; _ < i.length; _++) {
      const y = this._dimension, b = i[_];
      let w = !1;
      _ === i.length - 1 && (w = !0, l.z += this._dimension + 0.02), c = new d(
        0.5 * y - s,
        -0.5 * y + s,
        -0.5 * y + o
      ), h = new d(c.x + s, c.y - s, c.z), e.push(
        this._createSelectionFace(
          t++,
          c,
          h,
          b,
          w,
          l,
          a
        )
      ), c = new d(-0.5 * y, -0.5 * y + s, -0.5 * y + o), h = new d(c.x + s, c.y - s, c.z), e.push(
        this._createSelectionFace(
          t++,
          c,
          h,
          b,
          w,
          l,
          a
        )
      ), c = new d(-0.5 * y, 0.5 * y, -0.5 * y + o), h = new d(c.x + s, c.y - s, c.z), e.push(
        this._createSelectionFace(
          t++,
          c,
          h,
          b,
          w,
          l,
          a
        )
      ), c = new d(0.5 * y - s, 0.5 * y, -0.5 * y + o), h = new d(c.x + s, c.y - s, c.z), e.push(
        this._createSelectionFace(
          t++,
          c,
          h,
          b,
          w,
          l,
          a
        )
      ), c = new d(-0.5 * y + s, 0.5 * y, -0.5 * y + o), h = new d(c.x + r, c.y - s, c.z), e.push(
        this._createSelectionFace(
          t++,
          c,
          h,
          b,
          w,
          l,
          a
        )
      ), c = new d(
        -0.5 * y + s,
        -0.5 * y + s,
        -0.5 * y + o
      ), h = new d(c.x + r, c.y - s, c.z), e.push(
        this._createSelectionFace(
          t++,
          c,
          h,
          b,
          w,
          l,
          a
        )
      ), c = new d(-0.5 * y, 0.5 * y - s, -0.5 * y + o), h = new d(c.x + s, c.y - r, c.z), e.push(
        this._createSelectionFace(
          t++,
          c,
          h,
          b,
          w,
          l,
          a
        )
      ), c = new d(0.5 * y - s, 0.5 * y - s, -0.5 * y + o), h = new d(c.x + s, c.y - r, c.z), e.push(
        this._createSelectionFace(
          t++,
          c,
          h,
          b,
          w,
          l,
          a
        )
      ), c = new d(
        -0.5 * y + s,
        0.5 * y - s,
        -0.5 * y + o
      ), h = new d(c.x + r, c.y - r, c.z), e.push(
        this._createSelectionFace(
          t++,
          c,
          h,
          b,
          w,
          l,
          a
        )
      );
    }
    const u = 9;
    for (let _ = 0; _ < a.length; _++) {
      const y = Math.floor(_ / u), b = [], w = a[_];
      for (let v = 0; v < w.length; v += 2) {
        const C = w[v], k = w[v + 1];
        for (let Y = 0; Y < a.length; Y++) {
          if (Math.floor(Y / u) === y)
            continue;
          const L = a[Y];
          for (let R = 0; R < L.length; R += 2) {
            const D = L[R], J = L[R + 1];
            this._isSameEdge(C, k, D, J) && b.push(Y);
          }
        }
      }
      this._adjacentFaces.push(b);
    }
    const p = await Promise.all(e);
    this._updateOrientationMatrices(), this._onCameraUpdate();
    const m = [];
    for (const _ of p)
      m.push(ve.Local, _);
    return this._getScEngine().setPartVisibility(m, !0, !0), this._geometryCreated = !0, n;
  }
  _createTexture(n, t) {
    const i = n.getImageData(0, 0, t, t).data, s = new ArrayBuffer(t * t * 3), r = new Uint8Array(s);
    let o = 0;
    for (let l = 0; l < i.length; l += 4)
      r[o] = i[l], r[o + 1] = i[l], r[o + 2] = i[l], o += 3;
    return this._viewer.model.createImage({
      format: Oi.Rgb24,
      data: r,
      width: this._textureSize,
      height: this._textureSize
    });
  }
  /** @hidden */
  _geometryHasBeenCreated() {
    return this._geometryCreated;
  }
  /**
   * Determines whether or not a point is inside the NavCube overlay.
   * @param mousePos
   * @returns Boolean indicating whether the provided point is inside the NavCube overlay
   */
  insideOverlay(n) {
    const t = this._viewer.overlayManager._toPixelPoint(this._viewportSize), e = this._getOverlayOffset();
    return n.x >= e.x && n.y >= e.y && n.x <= e.x + t.x && n.y <= e.y + t.y;
  }
  /** @hidden */
  _getOverlayOffset() {
    const n = this._viewer.overlayManager._toPixelPoint(this._viewportSize);
    return this._viewer.overlayManager._getOverlayOffset(this._anchor, n);
  }
  /** @hidden */
  _getViewportSize() {
    return this._viewportSize;
  }
  /** @hidden */
  _getViewportPixelSize() {
    return this._viewer.overlayManager._toPixelPoint(this._viewportSize);
  }
  /** @hidden */
  _onNoSelection() {
    this._enabled && this._lastSelectedNodes.length > 0 && (this._viewer.model.setNodesOpacity(this._lastSelectedNodes, 0), this._lastSelectedNodes.length = 0);
  }
  /**
   * Called when the NavCube is clicked. Realigns the view to the side/edge/corner
   * selected by `selection`, or rotates the view 90 degrees if the selection matches
   * the current view orientation, or does nothing if no side is selected.
   * @param selection
   */
  async onClickSelection(n) {
    if (console.assert(this._enabled), n === null || !n.isFaceSelection() || n.overlayIndex() !== Vt.NavCube) {
      this._onNoSelection();
      return;
    }
    const t = this._getFaceIndexFromNodeId(n.getNodeId());
    t < this._nodeIds.length && t > 0 && await this._setViewOrientation(t);
  }
  /**
   * Called when the NavCube is "moused over". Displays face/edge/corner that will be selected.
   * @param selection
   */
  onMoveSelection(n) {
    if (console.assert(this._enabled), n === null || !n.isFaceSelection() || n.overlayIndex() !== Vt.NavCube) {
      this._onNoSelection();
      return;
    }
    const t = n.getNodeId(), e = this._getFaceIndexFromNodeId(t) - 1;
    e >= 0 && t !== this._nodeIds[0] && this._viewer.pauseRendering(() => {
      const i = this._viewer.model;
      i.setNodesOpacity(this._lastSelectedNodes, 0), this._lastSelectedNodes.length = 0, this._lastSelectedNodes.push(t), console.assert(e < this._adjacentFaces.length);
      const s = this._adjacentFaces[e];
      for (const r of s) {
        const o = r + 1, a = this._getNodeIdFromFaceIndex(o);
        this._lastSelectedNodes.push(a);
      }
      i.setNodesOpacity(this._lastSelectedNodes, 1);
    });
  }
  /**
   * Returns the corresponding view orientation for each node index.
   * If the node indexes change in the future, this will need to be updated.
   */
  _getViewOrientationFromFaceIndex(n) {
    let t = et.Front;
    switch (n) {
      case 1:
        t = et.LeftBottomBack;
        break;
      case 2:
        t = et.LeftBottomFront;
        break;
      case 3:
        t = et.LeftTopFront;
        break;
      case 4:
        t = et.LeftTopBack;
        break;
      case 5:
        t = et.LeftTop;
        break;
      case 6:
        t = et.LeftBottom;
        break;
      case 7:
        t = et.LeftFront;
        break;
      case 8:
        t = et.LeftBack;
        break;
      case 9:
        t = et.Left;
        break;
      case 10:
        t = et.RightTopBack;
        break;
      case 11:
        t = et.RightTopFront;
        break;
      case 12:
        t = et.RightBottomFront;
        break;
      case 13:
        t = et.RightBottomBack;
        break;
      case 14:
        t = et.RightBottom;
        break;
      case 15:
        t = et.RightTop;
        break;
      case 16:
        t = et.RightFront;
        break;
      case 17:
        t = et.RightBack;
        break;
      case 18:
        t = et.Right;
        break;
      case 19:
        t = et.BackTopRight;
        break;
      case 20:
        t = et.BackBottomRight;
        break;
      case 21:
        t = et.BackBottomLeft;
        break;
      case 22:
        t = et.BackTopLeft;
        break;
      case 23:
        t = et.BackLeft;
        break;
      case 24:
        t = et.BackRight;
        break;
      case 25:
        t = et.BackBottom;
        break;
      case 26:
        t = et.BackTop;
        break;
      case 27:
        t = et.Back;
        break;
      case 28:
        t = et.FrontBottomRight;
        break;
      case 29:
        t = et.FrontTopRight;
        break;
      case 30:
        t = et.FrontTopLeft;
        break;
      case 31:
        t = et.FrontBottomLeft;
        break;
      case 32:
        t = et.FrontLeft;
        break;
      case 33:
        t = et.FrontRight;
        break;
      case 34:
        t = et.FrontTop;
        break;
      case 35:
        t = et.FrontBottom;
        break;
      case 36:
        t = et.Front;
        break;
      case 37:
        t = et.BottomRightFront;
        break;
      case 38:
        t = et.BottomLeftFront;
        break;
      case 39:
        t = et.BottomLeftBack;
        break;
      case 40:
        t = et.BottomRightBack;
        break;
      case 41:
        t = et.BottomBack;
        break;
      case 42:
        t = et.BottomFront;
        break;
      case 43:
        t = et.BottomLeft;
        break;
      case 44:
        t = et.BottomRight;
        break;
      case 45:
        t = et.Bottom;
        break;
      case 46:
        t = et.TopLeftBack;
        break;
      case 47:
        t = et.TopRightBack;
        break;
      case 48:
        t = et.TopRightFront;
        break;
      case 49:
        t = et.TopLeftFront;
        break;
      case 50:
        t = et.TopFront;
        break;
      case 51:
        t = et.TopBack;
        break;
      case 52:
        t = et.TopRight;
        break;
      case 53:
        t = et.TopLeft;
        break;
      case 54:
        t = et.Top;
        break;
      default:
        t = et.Front;
    }
    return t;
  }
  async _setViewOrientation(n) {
    const t = this._viewer.view, e = this._getViewOrientationFromFaceIndex(n), i = await t.getViewOrientationCamera(
      e,
      void 0,
      this._preserveModelUp
    );
    let s = !1;
    console.assert(n - 1 >= 0), console.assert(n - 1 < this._adjacentFaces.length);
    const r = this._adjacentFaces[n - 1];
    for (const c of r)
      if (c + 1 === this._lastFaceIndex) {
        s = !0;
        break;
      }
    this._lastFaceIndex = n;
    const o = this._lastCamera !== null && this._lastCamera.equals(t.getCamera());
    if ((this._lastOrientation === e || s) && o ? this._cameraRotation = this._preserveModelUp ? (this._cameraRotation + 90) % 360 : 90 : this._cameraRotation = 0, this._lastOrientation = e, this._cameraRotation > 0) {
      const c = d.subtract(i.getPosition(), i.getTarget()).normalize(), h = Q.createFromOffAxisRotation(c, this._cameraRotation), u = i.getUp();
      h.transform(u, u), i.setUp(u);
    }
    await t.fitWorld(Ni, i);
    const l = this._viewer.model.getAbsoluteRootNode();
    if (this._viewer.model.getNodeChildren(l).length === 0)
      return this._getScEngine().markCameraAsEmpty();
    this._lastCamera = t.getCamera();
  }
  _getScEngine() {
    return this._viewer._getScEngine();
  }
  async _createInstance(n, t) {
    const e = await this._viewer.model.createMesh(n), i = new bn(e);
    i.setCreationFlags(
      St.DoNotCut | St.DoNotExplode | St.ExcludeBounding | St.DoNotLight | St.Invisible
    ), i.setOverlayIndex(Vt.NavCube);
    const o = (await this._getScEngine().createMeshInstance(i))[1];
    return this._instanceKeys[t] = o, o;
  }
  _createCube(n, t) {
    const e = [], i = [], s = [], r = [];
    let o = this._textWidths[0];
    for (const v of this._textWidths)
      v > o && (o = v);
    o += 10, e.push(new d(0.5 * t, 0.5 * t, 0.5 * t)), e.push(new d(-0.5 * t, 0.5 * t, -0.5 * t)), e.push(new d(-0.5 * t, 0.5 * t, 0.5 * t)), e.push(new d(0.5 * t, 0.5 * t, -0.5 * t)), e.push(new d(-0.5 * t, 0.5 * t, -0.5 * t)), e.push(new d(0.5 * t, 0.5 * t, 0.5 * t)), i.push(new d(0, 1, 0)), i.push(new d(0, 1, 0)), i.push(new d(0, 1, 0)), i.push(new d(0, 1, 0)), i.push(new d(0, 1, 0)), i.push(new d(0, 1, 0));
    const a = 60;
    let l = 22 / this._textureSize, c = (22 + a) / this._textureSize;
    l = 1 - l, c = 1 - c;
    let h = (o - this._textWidths[0]) / 2, u = -(h / this._textureSize), p = (this._textWidths[0] + h) / this._textureSize;
    s.push(new E(u, l)), s.push(new E(p, c)), s.push(new E(p, l)), s.push(new E(u, c)), s.push(new E(p, c)), s.push(new E(u, l)), r.push(new d(-0.5 * t, 0.5 * t, -0.5 * t)), r.push(new d(0.5 * t, 0.5 * t, -0.5 * t)), r.push(new d(0.5 * t, 0.5 * t, -0.5 * t)), r.push(new d(0.5 * t, 0.5 * t, 0.5 * t)), r.push(new d(0.5 * t, 0.5 * t, 0.5 * t)), r.push(new d(-0.5 * t, 0.5 * t, 0.5 * t)), r.push(new d(-0.5 * t, 0.5 * t, 0.5 * t)), r.push(new d(-0.5 * t, 0.5 * t, -0.5 * t)), e.push(new d(-0.5 * t, -0.5 * t, 0.5 * t)), e.push(new d(-0.5 * t, -0.5 * t, -0.5 * t)), e.push(new d(0.5 * t, -0.5 * t, 0.5 * t)), e.push(new d(0.5 * t, -0.5 * t, 0.5 * t)), e.push(new d(-0.5 * t, -0.5 * t, -0.5 * t)), e.push(new d(0.5 * t, -0.5 * t, -0.5 * t)), i.push(new d(0, -1, 0)), i.push(new d(0, -1, 0)), i.push(new d(0, -1, 0)), i.push(new d(0, -1, 0)), i.push(new d(0, -1, 0)), i.push(new d(0, -1, 0)), l -= a / this._textureSize, c -= a / this._textureSize, h = (o - this._textWidths[1]) / 2, u = -(h / this._textureSize), p = (this._textWidths[1] + h) / this._textureSize, s.push(new E(u, l)), s.push(new E(u, c)), s.push(new E(p, l)), s.push(new E(p, l)), s.push(new E(u, c)), s.push(new E(p, c)), r.push(new d(-0.5 * t, -0.5 * t, -0.5 * t)), r.push(new d(0.5 * t, -0.5 * t, -0.5 * t)), r.push(new d(0.5 * t, -0.5 * t, -0.5 * t)), r.push(new d(0.5 * t, -0.5 * t, 0.5 * t)), r.push(new d(0.5 * t, -0.5 * t, 0.5 * t)), r.push(new d(-0.5 * t, -0.5 * t, 0.5 * t)), r.push(new d(-0.5 * t, -0.5 * t, 0.5 * t)), r.push(new d(-0.5 * t, -0.5 * t, -0.5 * t)), e.push(new d(-0.5 * t, 0.5 * t, 0.5 * t)), e.push(new d(-0.5 * t, 0.5 * t, -0.5 * t)), e.push(new d(-0.5 * t, -0.5 * t, -0.5 * t)), e.push(new d(-0.5 * t, 0.5 * t, 0.5 * t)), e.push(new d(-0.5 * t, -0.5 * t, -0.5 * t)), e.push(new d(-0.5 * t, -0.5 * t, 0.5 * t)), i.push(new d(-1, 0, 0)), i.push(new d(-1, 0, 0)), i.push(new d(-1, 0, 0)), i.push(new d(-1, 0, 0)), i.push(new d(-1, 0, 0)), i.push(new d(-1, 0, 0)), l -= a / this._textureSize, c -= a / this._textureSize, h = (o - this._textWidths[2]) / 2, u = -(h / this._textureSize), p = (this._textWidths[2] + h) / this._textureSize, s.push(new E(u, l)), s.push(new E(u, c)), s.push(new E(p, c)), s.push(new E(u, l)), s.push(new E(p, c)), s.push(new E(p, l)), r.push(new d(-0.5 * t, 0.5 * t, -0.5 * t)), r.push(new d(-0.5 * t, 0.5 * t, 0.5 * t)), r.push(new d(-0.5 * t, 0.5 * t, 0.5 * t)), r.push(new d(-0.5 * t, -0.5 * t, 0.5 * t)), r.push(new d(-0.5 * t, -0.5 * t, 0.5 * t)), r.push(new d(-0.5 * t, -0.5 * t, -0.5 * t)), r.push(new d(-0.5 * t, -0.5 * t, -0.5 * t)), r.push(new d(-0.5 * t, 0.5 * t, -0.5 * t)), e.push(new d(0.5 * t, 0.5 * t, 0.5 * t)), e.push(new d(0.5 * t, -0.5 * t, -0.5 * t)), e.push(new d(0.5 * t, 0.5 * t, -0.5 * t)), e.push(new d(0.5 * t, 0.5 * t, 0.5 * t)), e.push(new d(0.5 * t, -0.5 * t, 0.5 * t)), e.push(new d(0.5 * t, -0.5 * t, -0.5 * t)), i.push(new d(1, 0, 0)), i.push(new d(1, 0, 0)), i.push(new d(1, 0, 0)), i.push(new d(1, 0, 0)), i.push(new d(1, 0, 0)), i.push(new d(1, 0, 0)), l -= a / this._textureSize, c -= a / this._textureSize, h = (o - this._textWidths[3]) / 2, u = -(h / this._textureSize), p = (this._textWidths[3] + h) / this._textureSize, s.push(new E(p, l)), s.push(new E(u, c)), s.push(new E(p, c)), s.push(new E(p, l)), s.push(new E(u, l)), s.push(new E(u, c)), r.push(new d(0.5 * t, 0.5 * t, -0.5 * t)), r.push(new d(0.5 * t, 0.5 * t, 0.5 * t)), r.push(new d(0.5 * t, 0.5 * t, 0.5 * t)), r.push(new d(0.5 * t, -0.5 * t, 0.5 * t)), r.push(new d(0.5 * t, -0.5 * t, 0.5 * t)), r.push(new d(0.5 * t, -0.5 * t, -0.5 * t)), r.push(new d(0.5 * t, -0.5 * t, -0.5 * t)), r.push(new d(0.5 * t, 0.5 * t, -0.5 * t)), e.push(new d(0.5 * t, -0.5 * t, -0.5 * t)), e.push(new d(-0.5 * t, -0.5 * t, -0.5 * t)), e.push(new d(-0.5 * t, 0.5 * t, -0.5 * t)), e.push(new d(0.5 * t, 0.5 * t, -0.5 * t)), e.push(new d(0.5 * t, -0.5 * t, -0.5 * t)), e.push(new d(-0.5 * t, 0.5 * t, -0.5 * t)), i.push(new d(0, 0, -1)), i.push(new d(0, 0, -1)), i.push(new d(0, 0, -1)), i.push(new d(0, 0, -1)), i.push(new d(0, 0, -1)), i.push(new d(0, 0, -1)), l -= a / this._textureSize, c -= a / this._textureSize, h = (o - this._textWidths[4]) / 2, u = -(h / this._textureSize), p = (this._textWidths[4] + h) / this._textureSize, s.push(new E(u, l)), s.push(new E(u, c)), s.push(new E(p, c)), s.push(new E(p, l)), s.push(new E(u, l)), s.push(new E(p, c)), e.push(new d(-0.5 * t, 0.5 * t, 0.5 * t)), e.push(new d(-0.5 * t, -0.5 * t, 0.5 * t)), e.push(new d(0.5 * t, -0.5 * t, 0.5 * t)), e.push(new d(-0.5 * t, 0.5 * t, 0.5 * t)), e.push(new d(0.5 * t, -0.5 * t, 0.5 * t)), e.push(new d(0.5 * t, 0.5 * t, 0.5 * t)), i.push(new d(0, 0, 1)), i.push(new d(0, 0, 1)), i.push(new d(0, 0, 1)), i.push(new d(0, 0, 1)), i.push(new d(0, 0, 1)), i.push(new d(0, 0, 1)), l -= a / this._textureSize, c -= a / this._textureSize, h = (o - this._textWidths[5]) / 2, u = -(h / this._textureSize), p = (this._textWidths[5] + h) / this._textureSize, s.push(new E(u, c)), s.push(new E(p, c)), s.push(new E(p, l)), s.push(new E(u, c)), s.push(new E(p, l)), s.push(new E(u, l));
    const m = new Hi();
    m.setFaceWinding(yn.CounterClockwise);
    let g = [], _ = [], y = [], b = 0;
    for (let v = 0; v < e.length; v++) {
      const C = e[v];
      g.push(C.x), g.push(C.y), g.push(C.z);
      const k = i[v];
      _.push(k.x), _.push(k.y), _.push(k.z);
      const Y = s[v];
      if (y.push(Y.x), y.push(Y.y), g.length >= 18) {
        const L = [
          // y
          [0, 255, 0, 255],
          [0, 255, 0, 255],
          // x
          [255, 0, 0, 255],
          [255, 0, 0, 255],
          // z
          [0, 0, 255, 255],
          [0, 0, 255, 255]
        ][b], R = [];
        for (let D = 0; D < 6; D++)
          R.push(L[0]), R.push(L[1]), R.push(L[2]), R.push(L[3]);
        m.addFaces(g, _, new Uint8Array(R), y), g = [], _ = [], y = [], ++b;
      }
    }
    g = [];
    const w = new Uint8Array(4 * r.length);
    for (let v = 0; v < r.length; v++) {
      const C = r[v];
      g.push(C.x), g.push(C.y), g.push(C.z);
      const k = 4 * v;
      w[k] = this._outlineColor.r, w[k + 1] = this._outlineColor.g, w[k + 2] = this._outlineColor.b, w[k + 3] = 255;
    }
    return m.addPolyline(g, w), this._createInstance(m, n);
  }
  _onCameraUpdate() {
    const n = new ci(), t = this._viewer.view.getCamera();
    n.setPosition(
      t.getPosition().subtract(t.getTarget()).normalize()
    ), n.setTarget(d.zero()), n.setUp(t.getUp()), n.setProjection(te.Orthographic), n.setWidth(this._fieldSize), n.setHeight(this._fieldSize), this._viewer.overlayManager.setCamera(Vt.NavCube, n);
  }
  _updateOrientationMatrices() {
    const t = this._viewer.model.getViewAxes(), e = t.upVector.copy(), i = t.frontVector.copy(), s = d.cross(e, i.copy().scale(-1)), r = new Q();
    r.m[0] = -i.x, r.m[1] = -i.y, r.m[2] = -i.z, r.m[4] = s.x, r.m[5] = s.y, r.m[6] = s.z, r.m[8] = e.x, r.m[9] = e.y, r.m[10] = e.z;
    const o = this._getScEngine(), a = [];
    for (const l of this._instanceKeys)
      a.push(ve.Local, l);
    o.setInstancesMatrix(a, r);
  }
  _createSelectionFace(n, t, e, i, s, r, o) {
    const a = new Hi();
    a.setFaceWinding(yn.CounterClockwise);
    const l = [];
    this._createQuad(t, e, l, i, r, s);
    let c = [], h = [], u = [];
    for (const _ of l)
      c.push(_.x), c.push(_.y), c.push(_.z), h.push(0), h.push(0), h.push(-1), u.push(this._selectionFaceColor.r), u.push(this._selectionFaceColor.g), u.push(this._selectionFaceColor.b), u.push(128);
    const p = [], m = [
      this._outlineColor.r,
      this._outlineColor.g,
      this._outlineColor.b,
      255,
      this._outlineColor.r,
      this._outlineColor.g,
      this._outlineColor.b,
      255
    ];
    a.addFaces(c, h, new Uint8Array(u)), c = [], h = [], u = [];
    let g = [];
    return s ? (g.push(l[4].x, l[4].y, l[4].z), g.push(l[5].x, l[5].y, l[5].z)) : (g.push(l[0].x, l[0].y, l[0].z), g.push(l[1].x, l[1].y, l[1].z)), a.addPolyline(g, new Uint8Array(m)), p.push(
      new d(g[0], g[1], g[2]),
      new d(g[3], g[4], g[5])
    ), g = [], g.push(l[1].x, l[1].y, l[1].z), g.push(l[2].x, l[2].y, l[2].z), a.addPolyline(g, new Uint8Array(m)), p.push(
      new d(g[0], g[1], g[2]),
      new d(g[3], g[4], g[5])
    ), g = [], g.push(l[3].x, l[3].y, l[3].z), g.push(l[4].x, l[4].y, l[4].z), a.addPolyline(g, new Uint8Array(m)), p.push(
      new d(g[0], g[1], g[2]),
      new d(g[3], g[4], g[5])
    ), g = [], s ? (g.push(l[3].x, l[3].y, l[3].z), g.push(l[2].x, l[2].y, l[2].z)) : (g.push(l[5].x, l[5].y, l[5].z), g.push(l[3].x, l[3].y, l[3].z)), a.addPolyline(g, new Uint8Array(m)), p.push(
      new d(g[0], g[1], g[2]),
      new d(g[3], g[4], g[5])
    ), g = [], o.push(p), this._createInstance(a, n);
  }
  _createQuad(n, t, e, i, s, r = !1) {
    const o = new d(n.x, n.y, n.z), a = new d(t.x, t.y, t.z);
    s && (o.x += s.x, o.y += s.y, o.z += s.z, a.x += s.x, a.y += s.y, a.z += s.z);
    const l = e.length;
    let c = new d(a.x, a.y, o.z), h = i.transform(c);
    if (e.push(h), c = new d(o.x, a.y, o.z), h = i.transform(c), e.push(h), c = new d(o.x, o.y, o.z), h = i.transform(c), e.push(h), c = new d(a.x, o.y, o.z), h = i.transform(c), e.push(h), c = new d(a.x, a.y, o.z), h = i.transform(c), e.push(h), c = new d(o.x, o.y, o.z), h = i.transform(c), e.push(h), r)
      for (let u = 0; u < 3; u++) {
        const p = l + u, m = e[l + u], g = new d(m.x, m.y, m.z), _ = l + (6 - u - 1);
        e[p].x = e[_].x, e[p].y = e[_].y, e[p].z = e[_].z, e[_].x = g.x, e[_].y = g.y, e[_].z = g.z;
      }
  }
  _makeRotationMatrixX(n) {
    const t = Math.cos(n), e = Math.sin(n), i = new Q();
    return i.m[5] = t, i.m[6] = -e, i.m[9] = e, i.m[10] = t, i;
  }
  _makeRotationMatrixY(n) {
    const t = Math.cos(n), e = Math.sin(n), i = new Q();
    return i.m[0] = t, i.m[2] = e, i.m[8] = -e, i.m[10] = t, i;
  }
  _makeRotationMatrixZ(n) {
    const t = Math.cos(n), e = Math.sin(n), i = new Q();
    return i.m[0] = t, i.m[1] = -e, i.m[4] = e, i.m[5] = t, i;
  }
  _getFaceIndexFromNodeId(n) {
    for (let t = 0; t < this._nodeIds.length; t++)
      if (this._nodeIds[t] === n)
        return t;
    return -1;
  }
  _getNodeIdFromFaceIndex(n) {
    return this._nodeIds[n];
  }
  _isSameEdge(n, t, e, i) {
    const s = d.subtract(n, e).squaredLength() + d.subtract(t, i).squaredLength(), r = d.subtract(t, e).squaredLength() + d.subtract(n, i).squaredLength();
    return Math.min(s, r) < 0.03;
  }
  async _initializeTextures() {
    const n = document.createElement("canvas");
    n.width = this._textureSize, n.height = this._textureSize;
    const t = n.getContext("2d"), e = 2 * (this._fontSize + 5);
    t.beginPath(), t.rect(0, 0, this._textureSize, this._textureSize), t.fillStyle = "gray", t.fill(), t.fillStyle = "black", t.font = this._fontInfo;
    for (let s = 0; s < nh._faceTexts.length; s++) {
      const r = nh._faceTexts[s];
      t.fillText(r, 0, e * (s + 1));
      const o = t.measureText(r);
      this._textWidths.push(o.width);
    }
    const i = await this._createTexture(t, this._textureSize);
    this._textImageId = i;
  }
};
let gp = nh;
gp._faceTexts = [
  "LEFT",
  "RIGHT",
  "FRONT",
  "BACK",
  "BOTTOM",
  "TOP"
];
class _y {
  /** @hidden */
  constructor(t) {
    this._operatorStack = [], this._operators = /* @__PURE__ */ new Map(), this._customOperatorIdCount = 0, this._customOperatorIdIndex = 1e4, this._mergeableEvents = [
      kt.MouseMove,
      kt.Mousewheel,
      kt.TouchMove,
      kt.KeyUp,
      kt.KeyDown
    ], this._eventSequencePromise = Promise.resolve(), this._events = [], this._viewer = t, this._viewer.setCallbacks({
      _resetAssemblyTreeBegin: async () => {
        const e = [];
        return this._operators.forEach((i, s) => {
          let r;
          r = this._deactivateOperator(s), r !== void 0 && e.push(r), r = this._activateOperator(s), r !== void 0 && e.push(r);
        }), zt(e);
      }
    });
  }
  /** @hidden */
  _shutdown() {
    for (; this.pop() !== void 0; )
      ;
  }
  /** @hidden */
  _registerOperator(t, e) {
    this._operators.set(t, e);
  }
  /**
   * Registers a custom operator
   * @param operator
   * @returns operatorId
   */
  registerCustomOperator(t) {
    const e = this._customOperatorIdIndex + this._customOperatorIdCount++;
    return this._operators.set(e, t), e;
  }
  /**
   * Removes a custom operator from the registered operator list.
   * @param operatorId
   */
  unregisterCustomOperator(t) {
    t >= this._customOperatorIdIndex && this._operators.delete(t);
  }
  /**
   * Replaces the operator that the specified id refers to. Returns a boolean indicating success or failure.
   * @param previousOperatorId operator id for the operator to be replaced.
   * @param newOperatorId operator id for the new operator.
   */
  replaceOperator(t, e) {
    const i = this.getOperator(e);
    return i !== null ? (this._operators.set(t, i), !0) : !1;
  }
  /**
   * Returns the index of an operator on the stack
   * @param operatorId
   * @returns operator index or -1 if not found
   */
  indexOf(t) {
    for (let e = this.size() - 1; e >= 0; e--)
      if (this._operatorStack[e] === t)
        return e;
    return -1;
  }
  /**
   * Adds an operator on the stack if it's not already on the stack
   * @param operatorId id of the operator to add to the stack
   * @returns boolean indicating success or failure
   */
  push(t) {
    return this._isValid(t) && !this._contains(t) ? (this._operatorStack.push(t), this._activateOperator(t), !0) : !1;
  }
  /**
   * Sets a position on the stack to an operator if it's not already on the stack
   * If there is already an operator in that position, it is replaced.
   * @param operatorId id of the operator to add to the stack
   * @param position position on the stack to assign
   * @returns boolean indicating success or failure
   */
  set(t, e) {
    const i = this._operatorStack[e];
    return t === i ? !1 : this._isValid(t) && !this._contains(t) ? (this._deactivateOperator(i), this._activateOperator(t), this._operatorStack[e] = t, !0) : !1;
  }
  /**
   * Removes an operator from the top of the stack
   * @returns the operator id
   */
  pop() {
    const t = this._operatorStack.pop();
    return t !== void 0 && this._deactivateOperator(t), t;
  }
  /**
   * Removes an operator from the stack
   * @param operatorId id of the operator to remove from the stack
   */
  remove(t) {
    const e = this.indexOf(t);
    e !== -1 && (this._operatorStack.splice(e, 1), this._deactivateOperator(t));
  }
  /**
   * @returns the operator id at the top of the stack
   */
  peek() {
    return this.size() > 0 ? this._operatorStack[this.size() - 1] : Et.Invalid;
  }
  /**
   * Removes all operators from the stack
   */
  clear() {
    for (let t = this.size() - 1; t >= 0; t--)
      this.pop();
  }
  /**
   * @returns the operator stack size
   */
  size() {
    return this._operatorStack.length;
  }
  getOperator(t) {
    return this._operators.get(t) ?? null;
  }
  async _injectEvent(t, e) {
    for (let i = this.size() - 1; i >= 0; i--) {
      const s = this._operators.get(this._operatorStack[i]);
      if (s !== void 0)
        try {
          switch (e) {
            case kt.KeyDown:
              s.onKeyDown && await s.onKeyDown(t);
              break;
            case kt.KeyUp:
              s.onKeyUp && await s.onKeyUp(t);
              break;
            case kt.MouseDown:
              s.onMouseDown && await s.onMouseDown(t);
              break;
            case kt.MouseMove:
              s.onMouseMove && await s.onMouseMove(t);
              break;
            case kt.MouseUp:
              s.onMouseUp && await s.onMouseUp(t);
              break;
            case kt.Mousewheel:
              s.onMousewheel && await s.onMousewheel(t);
              break;
            case kt.TouchStart:
              s.onTouchStart && await s.onTouchStart(t);
              break;
            case kt.TouchMove:
              s.onTouchMove && await s.onTouchMove(t);
              break;
            case kt.TouchEnd:
              s.onTouchEnd && await s.onTouchEnd(t);
              break;
            case kt.ViewOrientationChange:
              s.onViewOrientationChange && await s.onViewOrientationChange();
              break;
            default:
              $n(e);
          }
        } catch (r) {
          r instanceof Ms || console.log(r);
        }
      if (t.getHandled()) {
        (e === kt.MouseUp || e === kt.TouchEnd) && await this._stopInteraction();
        break;
      }
    }
  }
  async injectEvent(t, e) {
    return this._addOrMergeEventToQueue(t, e), this._eventSequencePromise = this._eventSequencePromise.then(async () => {
      await this._injectNextEvent();
    }), this._eventSequencePromise;
  }
  _addOrMergeEventToQueue(t, e) {
    let i = !1;
    if (this._mergeableEvents.indexOf(e) !== -1)
      for (let s = 0; s < this._events.length; s++) {
        const r = this._events[s];
        if (e === r.eventType && !((e === kt.KeyDown || e === kt.KeyUp) && t.getKeyCode() !== r.event.getKeyCode()) && !(e === kt.TouchMove && t.getId() !== r.event.getId())) {
          r.event = t, i = !0;
          break;
        }
      }
    i || this._events.push({ event: t, eventType: e });
  }
  async _injectNextEvent() {
    const t = this._events.shift();
    t !== void 0 && await this._injectEvent(t.event, t.eventType);
  }
  async _stopInteraction() {
    const t = [];
    for (let e = this.size() - 1; e >= 0; e--) {
      const i = this._operators.get(this._operatorStack[e]);
      if (i != null && i.stopInteraction) {
        const s = i.stopInteraction();
        s !== void 0 && t.push(s);
      }
    }
    return zt(t);
  }
  /** @hidden */
  _injectViewOrientationChangeEvent() {
    for (let t = this.size() - 1; t >= 0; t--) {
      const e = this._operators.get(this._operatorStack[t]);
      e != null && e.onViewOrientationChange && e.onViewOrientationChange();
    }
  }
  _isValid(t) {
    return this._operators.has(t) || t === Et.None;
  }
  _contains(t) {
    return this.indexOf(t) !== -1;
  }
  _activateOperator(t) {
    const e = this._operators.get(t);
    if (e != null && e.onActivate)
      return e.onActivate();
  }
  _deactivateOperator(t) {
    const e = this._operators.get(t);
    if (e != null && e.onDeactivate)
      return e.onDeactivate();
  }
}
class yy {
  /* @hidden */
  constructor(t, e, i, s) {
    this._activeSheetId = null, this._backgroundSheetMeshId = null, this._sheetIds = [null, null, null], this._backgroundSheetEnabled = !1, this._backgroundSelectionEnabled = !1, this._backgroundColor = new it(180, 180, 180), this._sheetColor = it.white(), this._sheetShadowColor = new it(75, 75, 75), this._viewer = t, this._engine = e, this._callbackManager = i;
    const r = async () => {
      if (!this._viewer.model.isDrawing())
        return;
      const o = this._viewer.sheetManager.getActiveSheetId();
      if (o == null) {
        await this.deactivateSheets(!1);
        const a = this.getSheetIds();
        this.get3DNodes().length === 0 && a.length > 0 && await this.setActiveSheetId(a[0], !0, !0);
      } else
        await this._activateSheetId(o, !0, !0);
    };
    this._viewer.setCallbacks({
      _modelStructureHeaderParsed: async () => {
        if (this._viewer.model.isDrawing() && !s)
          return this.setBackgroundSheetEnabled(!0);
      },
      _firstModelLoaded: async () => {
        await r();
      },
      _resetAssemblyTreeBegin: async () => {
        await this.setBackgroundSheetEnabled(!1), await this.setBackgroundSelectionEnabled(!1), this._activeSheetId = null, this._backgroundSheetMeshId = null;
        const o = this._viewer.view, a = o.getBackgroundColor();
        o.setBackgroundColor(a.top, a.bottom);
      },
      _resetDrawing: async () => {
        await r();
      }
    });
  }
  /**
   * @returns an array of 2D [[SheetId]]s.
   */
  getSheetIds() {
    const t = this._viewer.model, e = (s) => {
      let r = [];
      const o = t.getNodeChildren(s);
      for (const a of o)
        r = r.concat(e(a));
      return t.getNodeType(s) === At.DrawingSheet && r.push(s), r;
    }, i = t.getAbsoluteRootNode();
    return e(i);
  }
  /**
   * Returns Ids of sheet nodes which contain 3D data.
   */
  get3DNodes() {
    const t = this._viewer.model, e = t.getAbsoluteRootNode(), i = t.getNodeChildren(e), s = t.getNodeChildren(i[0]), r = t.getNodeChildren(s[0]), o = [];
    for (const a of r)
      t.getNodeType(a) !== At.DrawingSheet && o.push(a);
    return o;
  }
  /**
   * Deactivate sheets and only display 3D content
   * @param triggerCallback triggers a "sheetDeactivated" callback if true
   * @param ignoreFitNodes camera will not fit nodes if true
   * @returns promise that resolves when the operation has completed
   */
  async deactivateSheets(t = !0, e = !1) {
    this._activeSheetId = null, this._viewer.pauseRendering();
    const i = this.get3DNodes(), s = e ? !1 : i.length > 0;
    await this._viewer.view.isolateNodes(i, 0, s), await this._refreshBackgroundSheets();
    const r = this._viewer.view, o = r.getBackgroundColor();
    r.setBackgroundColor(o.top, o.bottom), this._viewer.resumeRendering(), t && this._callbackManager.trigger("sheetDeactivated");
  }
  /**
   * Sets the id of the current active sheet
   * @param activeSheetId id of the sheet which will be activated.
   * @param isolateNodes indicates whether the nodes in the sheet should be isolated
   * @param fitNodes indicates whether a fit world should be performed after isolating the nodes.  Note: This parameter has no effect if `isolateNodes` is `false`.
   * @returns promise that resolves when the operation has completed
   */
  async setActiveSheetId(t, e = !0, i = !0) {
    this._activeSheetId !== t && (this._activeSheetId = t, await this._activateSheetId(t, e, i));
  }
  async _activateSheetId(t, e, i) {
    await this._markupManager._setActiveMarkupView(null), e && (this._viewer.pauseRendering(), await this._viewer.view.isolateNodes([t], 0, i), await this._refreshBackgroundSheets(), this._viewer.resumeRendering()), this._callbackManager.trigger("sheetActivated", this._activeSheetId);
  }
  /**
   * @returns gets the id of the current active sheet. null if none has been set.
   */
  getActiveSheetId() {
    return this._activeSheetId;
  }
  /**
   * @returns true if a drawing sheet is activated, false otherwise
   */
  isDrawingSheetActive() {
    return this._viewer.model.isDrawing() && this._activeSheetId !== null;
  }
  /** @hidden */
  setMarkupManager(t) {
    this._markupManager = t;
  }
  async _createBackgroundSheetMesh() {
    const t = [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      1,
      1,
      0
    ], e = [
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      1
    ], i = new Hi();
    return i.addFaces(t, e), i.setBackfacesEnabled(!0), this._viewer.model.createMesh(i);
  }
  _createBackgroundSheetMatrix(t, e) {
    const i = t.min, s = t.max, r = this._viewer.view.getCamera(), o = r.getPosition(), a = r.getTarget(), l = d.subtract(a, o);
    let c = s.x - i.x, h = s.y - i.y;
    const u = Math.max(0.1 * c, 0.1 * (s.z - i.z)), p = i.x + 0.5 * c, m = i.y + 0.5 * h, g = 0.05, _ = Math.max(c * g, h * g);
    c += _, h += _;
    let y = p - 0.5 * c, b = m - 0.5 * h, w = l.z > 0 ? s.z + u : i.z - u;
    if (e) {
      const C = r.getUp();
      let k = 0.3 * _;
      y += k, C.y > 0 && (k = -k), b += k, w += l.z > 0 ? u : -u;
    }
    const v = new Q();
    return v.setTranslationComponent(y, b, w), v.setScaleComponent(c, h, 1), v;
  }
  async _createBackgroundSheetInstance(t, e, i, s, r, o) {
    let a = St.DoNotExplode | St.DoNotCut | St.OverrideSceneVisibility | St.DoNotLight | St.DoNotOutlineHighlight | St.AlwaysDraw | St.ExcludeBounding;
    o || (a |= St.DoNotSelect);
    const l = new bn(
      t,
      i,
      e,
      s,
      null,
      null,
      a
    ), c = await this._viewer.model.createMeshInstance(l, null, !1, !0);
    return this._viewer.model.setNodesOpacity([c], r), c;
  }
  /**
   * Deletes background sheets described by sheetTypes, but only if they exist.
   * @param sheetTypes An array with the sheets to delete. Omitting will delete all sheets.
   */
  async _deleteBackgroundSheetInstances(t = [
    0,
    2,
    1
    /* Shadow */
  ]) {
    const e = [];
    for (const i of t) {
      const s = this._sheetIds[i];
      s !== null && (this._sheetIds[i] = null, e.push(s));
    }
    if (e.length > 0)
      return this._viewer.model.deleteMeshInstances(e);
  }
  /**
   *  Creates the sheet-type into our array, or if the sheet already exists updates the necessary state values
   */
  async _createOrUpdateSheet(t, e, i, s, r, o) {
    const a = this._viewer.model;
    if (this._sheetIds[t] === null)
      return this._sheetIds[t] = await this._createBackgroundSheetInstance(
        this._backgroundSheetMeshId,
        e,
        i,
        s,
        r,
        o
      ), Promise.resolve();
    {
      const l = this._sheetIds[t];
      return a.setNodesFaceColor([l], s), a.setNodesOpacity([l], r), o !== null && a.setInstanceModifier(Fe.DoNotSelect, [l], !o), a.setNodeMatrix(l, i, !0);
    }
  }
  /**
   * Refreshes the background sheets used for 2D drawings.
   */
  async _refreshBackgroundSheets() {
    const t = this._viewer.model;
    if (!this.isDrawingSheetActive())
      return this._backgroundSelectionEnabled = !1, this._deleteBackgroundSheetInstances();
    this._backgroundSheetMeshId === null && (this._backgroundSheetMeshId = await this._createBackgroundSheetMesh());
    const e = await t.getModelBounding(!0, !1), i = this._createBackgroundSheetMatrix(e, !1), s = [];
    if (this._backgroundSelectionEnabled ? await this._createOrUpdateSheet(
      2,
      "2d_drawing_background_selection_sheet",
      i,
      it.black(),
      0,
      !0
    ) : s.push(
      2
      /* Selection */
    ), this._engine.setBackgroundGradient(this._backgroundColor, this._backgroundColor), this._backgroundSheetEnabled) {
      const r = this._createBackgroundSheetMatrix(e, !0);
      await this._createOrUpdateSheet(
        0,
        "2d_drawing_background_sheet",
        i,
        this._sheetColor,
        1,
        !1
      ), await this._createOrUpdateSheet(
        1,
        "2d_drawing_background_shadow_sheet",
        r,
        this._sheetShadowColor,
        1,
        !1
      );
    } else
      s.push(
        0,
        1
        /* Shadow */
      );
    if (s.length > 0)
      return this._deleteBackgroundSheetInstances(s);
  }
  /**
   * Sets custom sheet colors.
   * @param backgroundColor viewer background color.
   * @param sheetColor sheet background color.
   * @param sheetShadowColor sheet shadow effect color.
   */
  setSheetColors(t, e, i) {
    return this._backgroundColor = t.copy(), this._sheetColor = e.copy(), this._sheetShadowColor = i.copy(), this._refreshBackgroundSheets();
  }
  /**
   * Gets the sheet Background Color.
   */
  getSheetBackgroundColor() {
    return this._backgroundColor;
  }
  /**
   * Gets the Sheet Color.
   */
  getSheetColor() {
    return this._sheetColor;
  }
  /**
   * Gets the Sheet Shadow Color.
   */
  getSheetShadowColor() {
    return this._sheetShadowColor;
  }
  /**
   * Enables or disables the background sheet used for 2D drawings.
   */
  async setBackgroundSheetEnabled(t) {
    t !== this._backgroundSheetEnabled && (this._backgroundSheetEnabled = t, this._viewer.pauseRendering(), await this._refreshBackgroundSheets(), this._viewer.resumeRendering());
  }
  /**
   * Gets the current state of the background sheet.
   * @returns `true` if enabled and `false` otherwise.
   */
  getBackgroundSheetEnabled() {
    return this._backgroundSheetEnabled;
  }
  /**
   * Sets whether the background for 2D drawings is selectable. By default it is not.
   * 2D drawings have an invisible selection plane with a single face. Note that this setting
   * is unaffected by the background-sheet enable setting.
   */
  async setBackgroundSelectionEnabled(t) {
    this.isDrawingSheetActive() || (t = !1), t !== this._backgroundSelectionEnabled && (this._backgroundSelectionEnabled = t, this._viewer.pauseRendering(), await this._refreshBackgroundSheets(), this._viewer.resumeRendering());
  }
  /** Gets the current state of the background sheet.
   * @returns `true` if enabled and `false` otherwise.
   */
  getBackgroundSelectionEnabled() {
    return this._backgroundSelectionEnabled;
  }
  /**
   * Enables a visual comparison of two drawing sheets. The nodes specified
   * by `sheetId1` are filled with one color, the nodes specified by
   * `sheetId2` with another color, and overlapping areas are filled
   * with a third color.
   *
   * See [[endSheetComparison]], [[View.startComparison]].
   *
   * @param sheetId1 the drawing sheet to compare against `sheetId2`
   * @param sheetId2 the drawing sheet to compare against `sheetId1`
   * @param config settings controlling the behavior of the comparison
   */
  async startComparison(t, e, i) {
    const s = this._viewer.view;
    s.startComparison([t], [e], i), await this.setActiveSheetId(t, !1, !1), await s.isolateNodes([t, e], 0, !0), await this._refreshBackgroundSheets();
  }
  /**
   * Disables a visual comparison of two drawing sheets enabled by
   * [[startSheetComparison]]. The `Promise` returned by that function
   * should be waited upon before calling [[endSheetComparison]].
   */
  async endComparison() {
    this._activeSheetId !== null && (await this.setActiveSheetId(this._activeSheetId, !0, !1), this._viewer.view.endComparison());
  }
}
class by {
  /**
   * Creates a new SnapshotConfig object.
   */
  constructor(t = 0, e = 0, i = To.All) {
    this.width = t, this.height = e, this.layers = i;
  }
}
class yu {
  constructor() {
    this.svgXmlPrologEnabled = !0, this.svgBackgroundCssColor = "", this.silhouettesEnabled = !0, this.linesDrawModelLinesEnabled = !0, this.linesStrokeWidth = 20, this.linesCssColor = "#000000", this.linesClipProximityToPlane = 5.5, this.linesClipZNudgeFactor = 5.5, this.polygonsForceDrawCssColor = "", this.logProgress = !1, this.logDiagnostics = !1;
  }
}
class fp {
  constructor(t, e) {
    this.top = t, this.bottom = e;
  }
}
class Iy {
  static calculate(t, e, i, s) {
    let r;
    const o = 2 / (e + 2 * i + s);
    return t <= e ? r = this._PA(t, o, e) : t >= e && t <= e + i ? r = this._PA(t, o, e) : r = this._PC(t, o, e, i, s), r = Math.min(r, 1), r;
  }
  static _PA(t, e, i) {
    return t * t * 0.5 * e / i;
  }
  static _PB(t, e, i) {
    return this._PA(i, e, i) + (t - i) * e;
  }
  static _PC(t, e, i, s, r) {
    return this._PB(i + s, e, i) + (t - (i + s)) * e * (1 - 0.5 * (t - (i + s)) / r);
  }
}
class wy {
  constructor(t, e, i, s, r) {
    this._completeCallback = null, this._startTime = null, this._progress = 0, this._positionMoveDelta = null, this._targetMoveDelta = null, this._interpolationUsesRotation = !1, this._beginQuaternion = null, this._endQuaternion = null, this._viewVectorLength = 0, this._viewVectorLengthDelta = 0, this._fieldWidthDelta = 0, this._fieldHeightDelta = 0, this._beginCam = t.copy(), this._endCam = e.copy();
    const o = d.subtract(
      this._endCam.getTarget(),
      this._endCam.getPosition()
    ).normalize(), a = this._endCam.getUp().normalize(), l = d.cross(a, o), c = d.cross(o, l);
    this._endCam.setUp(c.normalize()), this._completeCallback = s, this._duration = i, this._view = r;
  }
  isComplete() {
    return this._progress >= 1;
  }
  getCallback() {
    return this._completeCallback;
  }
  stop() {
  }
  start() {
    this._startTime = Date.now(), this._progress = 0, this._init(), this._view.getProjectionMode() !== this._endCam.getProjection() && this._view.setProjectionMode(this._endCam.getProjection());
  }
  update() {
    if (this._startTime === null)
      return;
    let e = (Date.now() - this._startTime) / this._duration;
    e = Math.min(e, 1), e = Math.max(e, 0), e = Iy.calculate(e, 0.49, 0.02, 0.49), e = Math.min(e, 1), e = Math.max(e, 0);
    const i = d.scale(this._positionMoveDelta, e), s = d.scale(this._targetMoveDelta, e), r = this._beginCam.getUp();
    let o = d.add(this._beginCam.getPosition(), i);
    const a = d.add(this._beginCam.getTarget(), s), l = this._beginCam.getWidth() + e * this._fieldWidthDelta, c = this._beginCam.getHeight() + e * this._fieldHeightDelta;
    if (this._interpolationUsesRotation) {
      const u = this._viewVectorLength + this._viewVectorLengthDelta * e, p = Ti.interpolate(this._beginQuaternion, this._endQuaternion, e), m = Ti.toMatrix(p);
      o = new d(
        a.x - m.m[8] * u,
        a.y - m.m[9] * u,
        a.z - m.m[10] * u
      ), r.set(m.m[4], m.m[5], m.m[6]);
    }
    const h = ci.create(
      o,
      a,
      r,
      this._endCam.getProjection(),
      l,
      c,
      this._endCam.getNearLimit()
    );
    this._view.setCamera(h), this._progress = e, this._progress >= 1 && this._view.setCamera(this._endCam);
  }
  /**
   * Returns the transpose of the camera's view matrix without the
   * translation component and with the x- and z- axes flipped.
   *
   * Reproduced here because the public version is deprecated.
   */
  getMatrixFromCamera(t) {
    const e = d.subtract(t.getTarget(), t.getPosition()).normalize(), i = t.getUp().normalize(), s = d.cross(i, e), r = d.cross(e, s);
    return Q.createFromBasis(s, r, e);
  }
  _init() {
    const t = d.subtract(
      this._beginCam.getTarget(),
      this._beginCam.getPosition()
    ), e = d.subtract(this._endCam.getTarget(), this._endCam.getPosition()), i = t.length(), s = e.length() - i;
    t.normalize(), e.normalize();
    const r = d.subtract(t, e), o = d.subtract(this._endCam.getUp(), this._beginCam.getUp());
    let a = !0;
    r.length() < 1e-4 && o.length() < 1e-4 && (a = !1);
    let l = null, c = null;
    if (a) {
      const h = this.getMatrixFromCamera(this._beginCam), u = this.getMatrixFromCamera(this._endCam);
      l = Ti.createFromMatrix(h), c = Ti.createFromMatrix(u);
      const p = Ti.subtract(l, c).magnitudeSquared();
      Ti.add(l, c).magnitudeSquared() < p && c.negate();
    }
    this._interpolationUsesRotation = a, this._beginQuaternion = l, this._endQuaternion = c, this._viewVectorLength = i, this._viewVectorLengthDelta = s, this._positionMoveDelta = d.subtract(
      this._endCam.getPosition(),
      this._beginCam.getPosition()
    ), this._targetMoveDelta = d.subtract(this._endCam.getTarget(), this._beginCam.getTarget()), this._fieldWidthDelta = this._endCam.getWidth() - this._beginCam.getWidth(), this._fieldHeightDelta = this._endCam.getHeight() - this._beginCam.getHeight();
  }
}
class vy {
  constructor() {
    this._obscuredLineColor = it.black(), this._obscuredLineOpacity = 0.2, this._visibleLineColor = it.black(), this._visibleLineOpacity = 1, this._backgroundColorTop = it.white(), this._backgroundColorBottom = it.white();
  }
  /**
   * Returns the `Color` used for rendering obscured lines.
   * @returns The color used for obscured lines.
   */
  getObscuredLineColor() {
    return this._obscuredLineColor.copy();
  }
  /**
   * Sets the `Color` used for rendering obscured lines.
   * @param color The color used for obscured lines.
   */
  setObscuredLineColor(t) {
    this._obscuredLineColor.assign(t);
  }
  /**
   * Returns the opacity used for rendering obscured lines.
   * @returns The opacity used for obscured lines.
   */
  getObscuredLineOpacity() {
    return this._obscuredLineOpacity;
  }
  /**
   * Sets the opacity used for rendering obscured lines.
   * @param opacity The opacity used for obscured lines.
   */
  setObscuredLineOpacity(t) {
    0 <= t && t <= 1 && (this._obscuredLineOpacity = t);
  }
  /**
   * Gets the `Color` used for rendering visible lines.
   * @returns The color used for visible lines.
   */
  getVisibleLineColor() {
    return this._visibleLineColor.copy();
  }
  /**
   * Sets the `Color` used for rendering visible lines.
   * @param color The color used for visible lines.
   */
  setVisibleLineColor(t) {
    this._visibleLineColor.assign(t);
  }
  /**
   * Gets the opacity used for rendering visible lines.
   * @returns The opacity used for visible lines.
   */
  getVisibleLineOpacity() {
    return this._visibleLineOpacity;
  }
  /**
   * Sets the opacity used for rendering visible lines.
   * @param opacity The opacity used for visible lines.
   */
  setVisibleLineOpacity(t) {
    0 <= t && t <= 1 && (this._visibleLineOpacity = t);
  }
  /**
   * Gets the colors used for the background in hidden line rendering.
   * @returns The background colors used for hidden line.
   */
  getBackgroundColor() {
    const t = this._backgroundColorTop !== null ? this._backgroundColorTop.copy() : null, e = this._backgroundColorBottom !== null ? this._backgroundColorBottom.copy() : null;
    return new fp(t, e);
  }
  /**
   * Sets the background color in hidden line rendering to a gradient interpolating from the top to bottom color.
   * For a solid color, the top and bottom color should have the same values.
   * To enable a transparent background, pass null to the parameters of this function.
   *
   * @param top the top color for the the background gradient, null for transparent.
   * @param bottom the bottom color for the the background gradient, null for transparent.
   */
  setBackgroundColor(t = null, e = null) {
    this._backgroundColorTop = t !== null ? t.copy() : null, this._backgroundColorBottom = e !== null ? e.copy() : null;
  }
}
class Sy {
  /** @hidden */
  constructor(t, e, i, s, r, o, a, l) {
    this._backfacesVisible = !1, this._initialCamera = null, this._lineVisibility = !0, this._faceVisibility = !0, this._boundingCalculationIgnoresInvisible = !0, this._backgroundColorTop = null, this._backgroundColorBottom = null, this._drawMode = xn.WireframeOnShaded, this._ambientOcclusionEnabled = !1, this._ambientOcclusionRadius = 0.03, this._antiAliasingMode = Hd.SMAA, this._lightingEnabled = !0, this._ambientLightColor = it.black(), this._massageExtremeCameras = !0, this._bloomEnabled = !1, this._bloomThreshold = 0, this._bloomThresholdRampWidth = 0, this._bloomIntensityScale = 0, this._bloomLayers = [], this._simpleShadowEnabled = !1, this._simpleReflectionEnabled = !1, this._silhouetteEnabled = !1, this._hardEdgesEnabled = !1, this._imageBasedLightingEnabled = !0, this._lineJitterEnabled = !1, this._hiddenLineSettings = new vy(), this._projectionMode = te.Orthographic, this._drawStrategy = $d.FixedFramerate;
    const c = t.getCreationParameters();
    this._viewer = t, this._engine = e, this._callbackManager = i, this._interpolationManager = r, this._eventDispatcher = s, this._model = t.model, this._statistics = o, this._navCube = a, this._axisTriad = l, this._determineInitialAxes = Zr(c.calculateDefaultViewAxes, !0), this._initEvents();
  }
  _initEvents() {
    this._callbackManager.bind({
      _resetAssemblyTreeBegin: async () => {
        this._initialCamera = null;
      },
      _firstAttachment: async (t) => {
        if (t === Di.Direct)
          return this._massageInitialCamera(!1);
      },
      _firstModelLoaded: (t, e) => e ? Promise.resolve() : this._massageInitialCamera(!1),
      _modelSwitched: async (t) => {
        if (!t)
          return await this._massageInitialCamera(!1), this._setInitialView(0);
      },
      hwfParseComplete: () => this._massageInitialCamera(!0),
      _modelStructureHeaderParsed: async () => {
        if (this._viewer.sheetManager.isDrawingSheetActive())
          return this._model.setViewAxes(new d(0, 0, 1), new d(0, 1, 0)), this.setViewOrientation(et.Front, 0);
      },
      _sessionStarted: async () => {
        this.setBloomIntensityScale(1), this.setBloomThreshold(0.65), this.setBloomThresholdRampWidth(0.1), this.setBloomLayers([
          {
            intensity: 0.5,
            blurSamples: 5,
            blurInterval: [1 / 400, mn.ProportionOfHeight]
          },
          {
            intensity: 0.5,
            blurSamples: 5,
            blurInterval: [1 / 200, mn.ProportionOfHeight]
          },
          {
            intensity: 0.5,
            blurSamples: 9,
            blurInterval: [1 / 100, mn.ProportionOfHeight]
          },
          {
            intensity: 1,
            blurSamples: 9,
            blurInterval: [1 / 50, mn.ProportionOfHeight]
          },
          {
            intensity: 2,
            blurSamples: 11,
            blurInterval: [1 / 25, mn.ProportionOfHeight]
          }
        ]), this.setGroundPlane({
          normal: new d(0, 0, 1),
          followViewAxes: !0
        }), this.setSimpleShadowColor(it.black()), this.setSimpleShadowOpacity(0.65), this.setSimpleShadowResolution(512), this.setSimpleShadowBlurSamples(5), this.setSimpleShadowBlurInterval(1), this.setSimpleShadowInteractiveUpdateEnabled(), this.setSimpleReflectionOpacity(0.65), this.setSimpleReflectionFadeAngle(10), this.setSimpleReflectionBlurSamples(9), this.setSimpleReflectionBlurInterval(1, mn.Pixels), this.setSimpleReflectionAttenuation(
          0,
          1,
          Gc.ProportionOfBoundingHeight
        ), this.setSilhouetteColor(it.black()), this.setSilhouetteOpacity(1), this.setSilhouetteThreshold(0.05), this.setSilhouetteThresholdRampWidth(0.025), this.setHardEdgeColor(it.black()), this.setHardEdgeOpacity(1), this.setHardEdgeThreshold(30), this.setHardEdgeThresholdRampWidth(20), this.setImageBasedLightingIntensity(1), this.setImageBasedLightingOrientation({
          matrix: new Q(),
          followViewAxes: !0
        }), this.setGoochBlue(0.55), this.setGoochYellow(0.3), this.setGoochBaseColorProminence(0.25), this.setGoochLuminanceShiftStrength(0.5), this.setLineJitterInstanceCount(4), this.setLineJitterFrequency(5), this.setLineJitterRadius(5e-3), this.setToonShadingBandCount(3), this.setToonShadingSpecularFactor(1);
      },
      viewAxes: (t, e) => {
        this._updateGroundPlane(t, e), this._updateImageBasedLightingOrientation(t, e);
      }
    });
  }
  async _massageInitialCamera(t) {
    this._initialCamera === null && (this._initialCamera = await this._engine.getCameraPromise(), this._projectionMode = this._initialCamera.getProjection(), this._determineInitialAxes && !this._viewer.sheetManager.isDrawingSheetActive() && !this._model.viewAxesHaveBeenSet() && this._determineViewAxes(this._initialCamera), t && (await this.fitWorld(), this._initialCamera = this.getCamera()));
  }
  /**
   * Sets the line visibility for the view.
   * @param lineVisibility indicates whether to draw lines.
   */
  setLineVisibility(t) {
    return this._setLineVisibility(t), Promise.resolve();
  }
  _setLineVisibility(t) {
    t !== this._lineVisibility && (this._lineVisibility = t, this._engine.setLineVisibility(t));
  }
  /**
   * Gets the line visibility for the view.
   * @returns whether lines are currently being drawn.
   */
  getLineVisibility() {
    return this._lineVisibility;
  }
  /**
   * Sets the face visibility for the view.
   * @param faceVisibility indicates whether to draw faces.
   */
  setFaceVisibility(t) {
    return this._setFaceVisibility(t), Promise.resolve();
  }
  _setFaceVisibility(t) {
    return t !== this._faceVisibility && (this._faceVisibility = t, this._engine.setFaceVisibility(t)), Promise.resolve();
  }
  /**
   * Gets the face visibility for the view.
   * @returns whether faces are currently being drawn.
   */
  getFaceVisibility() {
    return this._faceVisibility;
  }
  /**
   * Sets the projection mode.
   * @param projection the projection mode to set.
   */
  setProjectionMode(t) {
    this._projectionMode !== t && (this._projectionMode = t, this._engine.isInit() && this._engine.setProjection(t), this._eventDispatcher.injectViewOrientationChangeEvent());
  }
  /**
   * Gets the projection mode.
   * @returns The current projection mode.
   */
  getProjectionMode() {
    return this._projectionMode;
  }
  /**
   * Gets the draw strategy.
   * @returns The current draw strategy.
   */
  getDrawStrategy() {
    return this._drawStrategy;
  }
  /**
   * Gets the view matrix.
   * @returns The current view matrix.
   */
  getViewMatrix() {
    return this._engine.getViewMatrix();
  }
  /**
   * Gets the projection matrix.
   * @returns The current projection matrix.
   */
  getProjectionMatrix() {
    return this._engine.getProjectionMatrix();
  }
  /**
   * This is equivalent to (projectionMatrix * viewMatrix).
   * @returns The current full camera matrix.
   */
  getFullCameraMatrix() {
    return this._engine.getFullCameraMatrix();
  }
  /**
   * Creates a ray based on a viewport position.
   * @param point The (X, Y) viewport position.
   * @returns The ray if it was generated, otherwise null.
   */
  raycastFromPoint(t) {
    const e = this.getCanvasSize(), i = this._engine.getViewMatrix(), s = this._engine.getProjectionMatrix(), r = new d(t.x, e.y - t.y, 0), o = this._unproject(r, s, i, e);
    if (o === null)
      return null;
    r.z = 0.5;
    const a = this._unproject(r, s, i, e);
    if (a === null)
      return null;
    const l = d.subtract(a, o).normalize();
    return new Vn(o, l);
  }
  /**
   * @param source
   * @param projectionMatrix
   * @param viewMatrix
   * @param viewSize
   */
  _unproject(t, e, i, s) {
    const r = Q.multiply(i, e), o = Q.inverse(r);
    if (o === null)
      return null;
    const a = new jn(t.x, t.y, t.z, 1);
    a.x = a.x / s.x, a.y = a.y / s.y, a.x = a.x * 2 - 1, a.y = a.y * 2 - 1, a.z = a.z * 2 - 1;
    const l = o.transform4(a);
    return l.w === 0 ? null : (l.scale(1 / l.w), new d(l.x, l.y, l.z));
  }
  _rectifySelectionItem(t) {
    const e = t.getInclusionKey(), i = t.getNodeId(), s = this._model._getNodeFromInstanceInc(!1, e, i, !0);
    t._setNodeId(s);
  }
  // TODO:
  // Mark this as hidden and rename to have an underscore?
  // Or is it too late? It wouldn't be a bad thing
  // to expose this functionality as public.
  /** @hidden */
  isOutsideCanvasArea(t) {
    const e = this.getCanvasSize();
    return t.x < 0 || t.y < 0 || t.x >= e.x || t.y >= e.y;
  }
  /**
   * Performs a picking operation from the given position on the canvas. The best candidate entity is be returned.
   * This method does not trigger a selection event.
   * This method will reject if the point is outside the canvas area.
   * @param point Canvas position to pick from.
   * @param config The configuration object used for this picking operation.
   * @returns An object containing the result of the picking operation.
   */
  async pickFromPoint(t, e) {
    if (this.isOutsideCanvasArea(t))
      throw new Ms();
    const i = await this._engine.pickFromScreen(
      t,
      e,
      this._viewer.sheetManager.isDrawingSheetActive()
    );
    return i ? (this._rectifySelectionItem(i), i) : de.create();
  }
  /**
   * Performs a picking operation from the given position on the canvas. All candidate entities are returned.
   * This method does not trigger a selection event.
   * This method will reject if the point is outside the canvas area.
   * @param point Canvas position to pick from.
   * @param config The configuration object used for this picking operation.
   * @returns An object containing the result of the picking operation.
   */
  async pickAllFromPoint(t, e) {
    if (this.isOutsideCanvasArea(t))
      throw new Ms();
    const i = await this._engine.pickAllFromScreen(
      t,
      e,
      this._viewer.sheetManager.isDrawingSheetActive()
    );
    for (const s of i)
      this._rectifySelectionItem(s);
    return i;
  }
  /**
   * Performs a composite picking operation.  This operation will return all candidate Node entities according to the PickConfig.
   * @param point Canvas position to pick from.
   * @param config The configuration object used for this picking operation.
   * @returns An object containing the result of the picking operation.
   */
  async compositePickFromPoint(t, e) {
    if (this.isOutsideCanvasArea(t))
      throw new Ms();
    const { faceItem: i, lineItem: s, pointItem: r } = await this._engine.compositePickFromScreen(
      t,
      e,
      this._viewer.sheetManager.isDrawingSheetActive()
    ), o = new Ml(i, s, r);
    return o.faceItem !== null && this._rectifySelectionItem(o.faceItem), o.lineItem !== null && this._rectifySelectionItem(o.lineItem), o.pointItem !== null && this._rectifySelectionItem(o.pointItem), new Ml(
      o.faceItem,
      o.lineItem,
      o.pointItem
    );
  }
  /**
   * Performs a selection operation from the given world-space ray. The best candidate entity is be returned.
   * This method does not trigger a selection event.
   * @param ray The world-space ray to perform the selection with.
   * @param config The configuration object used for this picking operation.
   * @param selectionMode The mode to use for this selection.
   * @returns An object containing the result of the picking operation.
   */
  async pickFromRay(t, e) {
    const i = await this._engine.pickFromRay(t, e);
    return i ? (this._rectifySelectionItem(i), i) : de.create();
  }
  /**
   * Performs a selection operation from the given world-space ray. All candidate entities are returned.
   * This method does not trigger a selection event.
   * @param ray The world-space ray to perform the selection with.
   * @param config The configuration object used for this picking operation.
   * @param selectionMode The mode to use for this selection.
   * @returns An object containing the result of the picking operation.
   */
  async pickAllFromRay(t, e) {
    const i = await this._engine.pickAllFromRay(t, e);
    for (const s of i)
      this._rectifySelectionItem(s);
    return i;
  }
  /**
   * Creates a new and active selection context for the provided selection window.
   * @param areaCssMin The minimum coodinate in CSS pixel space for the selection window.
   * @param areaCssMax The maximum coodinate in CSS pixel space for the selection window.
   * @param config The configuration object used for this selection operation.
   * @returns The handle for the selection context.
   */
  async beginScreenSelectByArea(t, e, i) {
    if (this.isOutsideCanvasArea(t) || this.isOutsideCanvasArea(e))
      throw new Ms();
    return this._engine.beginScreenAreaSelection(t, e, i);
  }
  /**
   * Creates a new and active selection context for the provided selection ray.
   * The ray is created at the supplied ray origin and is cast into the scene.
   * Faces are selected if they lie along the ray.
   * Lines and points are selected if they lie within the ray's box radius.
   *
   * Note: Somewhat confusingly ray drill selection is actually a selection by volume.
   * The provided ray origin and radius are used to create a frustum to preform the selection.
   * This has some consequences. For example, the `SelectionResult`s returned by advancing a
   * ray drill selection will not have selection positions, since they were not selected at
   * a single point.
   * @param rayCssOrigin The coordinate in CSS pixel space for the selection ray's origin.
   * @param rayCssBoxRadius The radius around the ray in CSS pixel space used for line and point selection proximity.
   * @param config The configuration object used for this selection operation.
   * @returns The handle for the selection context.
   */
  async beginRayDrillSelection(t, e, i) {
    if (this.isOutsideCanvasArea(t))
      throw new Ms();
    return this._engine.beginRayDrillSelection(t, e, i);
  }
  /**
   * Creates a new and active selection context for the provided selection volume.
   * The selection volume is a convex polyhedron defined by the bounded intersection of its half-spaces.
   * @param volumePlanes The planes used to define volume. A point p is inside the volume if and only if (plane.determineSide(p) == true) for all supplied planes.
   * @param heuristicOrigin A point used to compute distances against for prioritizing returned results. This is typically (but not necessarily) the center of the volume.
   * @param config The configuration object used for this selection operation.
   * @returns The handle for the selection context.
   */
  async beginConvexPolyhedronSelection(t, e, i) {
    return this._engine.beginConvexPolyhedronSelection(t, e, i);
  }
  /**
   * Creates a new and active selection context for the provided selection sphere.
   * @param sphereCenter The center of the selection sphere.
   * @param sphereRadius The radius of the selection sphere.
   * @param config The configuration object used for this selection operation.
   * @returns The handle for the selection context.
   */
  async beginSphereSelection(t, e, i) {
    const s = Or(t);
    return this._engine.beginSphereSelection(s, e, i);
  }
  /**
   * Deactivates and destroys the provided selection context.
   * @param handle The selection context to destroy.
   */
  endIncrementalSelection(t) {
    return this._endIncrementalSelection(t), Promise.resolve();
  }
  _endIncrementalSelection(t) {
    this._engine.endIncrementalSelection(t);
  }
  /**
   * Returns the next batch of geometry selected by the supplied selection context.
   * @param handle The handle to an active area selection context.
   * @returns Returns selected items. If the resulting list is null then there are no more items to select.
   */
  async advanceIncrementalSelection(t) {
    try {
      const e = await this._engine.advanceIncrementalSelection(t);
      if (e === null)
        return null;
      const i = this._viewer.selectionManager, s = [];
      for (const r of e) {
        this._rectifySelectionItem(r);
        const o = r, a = o.getNodeId();
        if (!a)
          continue;
        i._incrementalBlacklistedInstanceNodes.has(a) || s.push(o);
      }
      return s;
    } catch (e) {
      throw e.scFunction === "advanceVolumeSelection" ? new as() : e;
    }
  }
  /**
   * Projects a 3d world space point to a 3d screen space point.
   * @param point world space point to be projected.
   * @param camera if a camera is provided, its projection and view matrix will be used.
   * @returns point projected into 3d screen space.
   */
  projectPoint(t, e) {
    let i, s;
    e !== void 0 ? (i = e.getProjectionMatrix(this._viewer), s = e.getViewMatrix(this._viewer)) : (i = this._engine.getSynchedProjectionMatrix(), s = this._engine.getSynchedViewMatrix());
    const r = this.getCanvasSize(), o = this._project(t, i, s, r);
    return o.y = r.y - o.y, o;
  }
  /**
   * @param source
   * @param projectionMatrix
   * @param viewMatrix
   * @param viewSize
   */
  _project(t, e, i, s) {
    const r = new jn(t.x, t.y, t.z, 1);
    i.transform4(r, r), e.transform4(r, r);
    const o = r.w <= 0, a = r.w;
    return r.w <= 0 && (r.w = 1e-3), r.scale(1 / r.w), r.x = r.x * 0.5 + 0.5, r.y = r.y * 0.5 + 0.5, r.z = r.z * 0.5 + 0.5, r.x = r.x * s.x, r.y = r.y * s.y, o && (r.z = a), new d(r.x, r.y, r.z);
  }
  /**
   * Unprojects a 2d screen space point to a 3d world space point.
   * @param point 2d screen space
   * @param z z value, default 0
   * @returns point world space point
   */
  unprojectPoint(t, e) {
    const i = this.getCanvasSize(), s = this.getProjectionMatrix(), r = this.getViewMatrix(), o = new d(t.x, i.y - t.y, e);
    return this._unproject(o, s, r, i);
  }
  /**
   * Creates a normalized window position in the range of (-1, 1) for a given point in window space.
   * @returns the normalized window position
   */
  pointToWindowPosition(t) {
    const e = this._engine.getCanvasSize();
    return new E(t.x / e.x * 2 - 1, 1 - t.y / e.y * 2);
  }
  /**
   * Sets the camera that will be used for the initial camera view.
   * @param camera
   */
  setInitialCamera(t) {
    this._initialCamera = t.copy();
  }
  /**
   * Sets the current camera
   * @param camera the camera to set
   * @param duration camera transition time in milliseconds
   */
  setCamera(t, e = 0) {
    return t === null ? !1 : this._setCameraImpl(t, e).unsafeValue;
  }
  /** @hidden */
  _setCameraPromise(t, e) {
    return this._setCameraImpl(t, e).readyPromise;
  }
  _setCameraImpl(t, e) {
    if (e > 0)
      return this._interpolateCamera(t, e);
    if (this._engine.isInit()) {
      const i = t.getProjection();
      this._projectionMode !== i && this.setProjectionMode(i), this._engine.setCamera(t);
      let s;
      return this._markupManager ? s = this._markupManager._setActiveMarkupView(null) : s = Promise.resolve(), this._callbackManager.trigger("camera", t), os(!0, s);
    } else
      return os(!1, Promise.resolve());
  }
  _interpolateCamera(t, e) {
    if (this._engine.isInit()) {
      const i = this.getCamera();
      if (i.equals(t))
        return this._markupManager && this._markupManager._update(), os(!1, Promise.resolve());
      {
        this._callbackManager.trigger("transitionBegin", e);
        const s = be(), r = () => {
          this._eventDispatcher.injectViewOrientationChangeEvent(), this._callbackManager.trigger("transitionEnd"), s.resolve();
        };
        return this._interpolationManager.start(
          new wy(i, t, e, r, this)
        ), os(!0, s);
      }
    } else
      return os(!1, Promise.resolve());
  }
  /**
   * Updates camera properties individually. This method should be used to incrementally update camera properties individually.
   * @param camera the camera to set.
   * @returns updated camera object.
   */
  updateCamera(t) {
    return t = this._engine.updateCamera(t), this._callbackManager.trigger("camera", t), t;
  }
  /**
   * Resets the camera to the initial view of the model when first loaded.
   * @param duration the amount of time in milliseconds that the camera transition between the current and initial view should take.
   */
  resetCamera(t = Ni) {
    return this._setInitialView(t);
  }
  /**
   * Gets the current camera
   * @returns the current camera
   */
  getCamera() {
    if (this._engine.isInit())
      return this._engine.getCamera();
    throw new Mt("getCamera() called before sceneReady");
  }
  /**
   * Returns a camera set to a ViewOrientation
   * @param orientation The desired view orientation for the camera.
   * @param bounding Optional bounding to fit the camera about. If not supplied, the model bounding will be used.
   */
  async getViewOrientationCamera(t, e, i = !0) {
    const s = this.getCamera(), r = s.getUp().copy().normalize(), o = this._model.getViewAxes(), a = o.upVector.copy(), l = o.frontVector.copy();
    e === void 0 ? e = await this._model.getModelBounding(
      this._boundingCalculationIgnoresInvisible,
      !1
    ) : this._fitCameraToBounding(s, e);
    const c = e.center();
    let h = c.copy();
    const u = c.copy(), p = d.subtract(s.getPosition(), s.getTarget()).length(), m = d.subtract(s.getPosition(), c).length();
    let g = new d(0, 0, 1), _ = new d(-1, 0, 0);
    a !== null && (g = a.copy()), l !== null && (_ = l.copy());
    const y = _.copy().scale(-1), b = _.copy(), w = g.copy(), v = g.copy().scale(-1), C = d.cross(w, y), k = C.copy().scale(-1), Y = (D) => {
      const J = d.subtract(u, D);
      let G = g;
      const X = Yn(J, g);
      (X === 0 || X === 180) && (G = _);
      const Z = d.cross(J, G), W = Z.copy().negate(), st = d.cross(J, Z), j = st.copy().negate(), gt = [Z, W, st, j];
      let U = 1 / 0, ht = Z;
      for (const z of gt) {
        const O = Yn(r, z);
        O <= U && (U = O, ht = z);
      }
      return ht.normalize();
    };
    let P = null;
    switch (t) {
      case et.Front:
        h = d.add(u, b);
        break;
      case et.Back:
        h = d.add(u, y);
        break;
      case et.Left:
        h = d.add(u, C);
        break;
      case et.Right:
        h = d.add(u, k);
        break;
      case et.Bottom:
        h = d.add(u, v), P = y.copy();
        break;
      case et.Top:
        h = d.add(u, w), P = y.copy();
        break;
      case et.FrontTop:
      case et.TopFront:
        h = d.add(u, d.add(b, w)), P = d.add(y, w).normalize();
        break;
      case et.FrontTopLeft:
      case et.LeftTopFront:
      case et.TopLeftFront:
        h = d.add(u, d.add(b, d.add(C, w))), P = d.add(y, d.add(k, w)).normalize();
        break;
      case et.Iso:
      case et.FrontTopRight:
      case et.RightTopFront:
      case et.TopRightFront:
        h = d.add(u, d.add(b, d.add(k, w))), P = d.add(y, d.add(C, w)).normalize();
        break;
      case et.FrontLeft:
      case et.LeftFront:
        h = d.add(u, d.add(b, C));
        break;
      case et.FrontRight:
      case et.RightFront:
        h = d.add(u, d.add(b, k));
        break;
      case et.FrontBottom:
      case et.BottomFront:
        h = d.add(u, d.add(b, v)), P = d.add(b, w).normalize();
        break;
      case et.FrontBottomLeft:
      case et.LeftBottomFront:
      case et.BottomLeftFront:
        h = d.add(u, d.add(b, d.add(C, v))), P = d.add(b, d.add(C, w)).normalize();
        break;
      case et.FrontBottomRight:
      case et.RightBottomFront:
      case et.BottomRightFront:
        h = d.add(u, d.add(b, d.add(k, v))), P = d.add(b, d.add(k, w)).normalize();
        break;
      case et.BackTop:
      case et.TopBack:
        h = d.add(u, d.add(y, w)), P = d.add(b, w).normalize();
        break;
      case et.BackTopLeft:
      case et.LeftTopBack:
      case et.TopLeftBack:
        h = d.add(u, d.add(y, d.add(C, w))), P = d.add(b, d.add(k, w)).normalize();
        break;
      case et.BackTopRight:
      case et.RightTopBack:
      case et.TopRightBack:
        h = d.add(u, d.add(y, d.add(k, w))), P = d.add(b, d.add(C, w)).normalize();
        break;
      case et.BackLeft:
      case et.LeftBack:
        h = d.add(u, d.add(y, C));
        break;
      case et.BackRight:
      case et.RightBack:
        h = d.add(u, d.add(y, k));
        break;
      case et.BackBottom:
      case et.BottomBack:
        h = d.add(u, d.add(y, v)), P = d.add(y, w).normalize();
        break;
      case et.BackBottomLeft:
      case et.LeftBottomBack:
      case et.BottomLeftBack:
        h = d.add(u, d.add(y, d.add(C, v))), P = d.add(y, d.add(C, w)).normalize();
        break;
      case et.BackBottomRight:
      case et.RightBottomBack:
      case et.BottomRightBack:
        h = d.add(u, d.add(y, d.add(k, v))), P = d.add(y, d.add(k, w)).normalize();
        break;
      case et.LeftBottom:
      case et.BottomLeft:
        h = d.add(u, d.add(C, v)), P = d.add(C, w).normalize();
        break;
      case et.LeftTop:
      case et.TopLeft:
        h = d.add(u, d.add(C, w)), P = d.add(k, w).normalize();
        break;
      case et.RightBottom:
      case et.BottomRight:
        h = d.add(u, d.add(k, v)), P = d.add(k, w).normalize();
        break;
      case et.RightTop:
      case et.TopRight:
        h = d.add(u, d.add(k, w)), P = d.add(C, w).normalize();
        break;
      default:
        $n();
    }
    i || (P = Y(h)), P === null && (P = g);
    const L = d.add(
      d.subtract(h, c).normalize().scale(m),
      c
    ), R = d.add(
      d.subtract(h, c).normalize().scale(m - p),
      c
    );
    return s.setPosition(L), s.setTarget(R), s.setUp(P), s;
  }
  /**
   * Sets the view to a standard orientation.
   * @param orientation The desired view orientation for the camera.
   * @param duration The number of milliseconds used to transition to the new camera.
   * @param bounding Optional bounding to fit the camera about. If not supplied, the model bounding will be used.
   * @param preserveModelUp Indicates whether the camera up will be set according to model up or current camera.
   */
  async setViewOrientation(t, e = Ni, i, s = !0) {
    const r = await this.getViewOrientationCamera(t, i, s);
    i === void 0 ? await this.fitWorld(e, r) : await this.fitBounding(i, e, r), this._callbackManager.trigger("viewOrientation", t);
  }
  /**
   * Centers the camera on a specified node id.
   * @param nodeId
   * @param duration the number of milliseconds to transition to the new camera.
   */
  async centerCameraOnNode(t, e = 0, i = this.getCamera()) {
    const r = (await this._model.getNodesBounding([t])).center(), o = i.getPosition(), a = i.getTarget(), l = d.subtract(a, r);
    if (o.subtract(l), i.setPosition(o), i.setTarget(r), e > 0)
      return this._setCameraPromise(i, e);
    this.setCamera(i);
  }
  /** @hidden */
  async _setInitialView(t) {
    if (!this._initialCamera)
      return this.fitWorld(t);
    if (t > 0)
      return this._setCameraPromise(this._initialCamera, t);
    this.setCamera(this._initialCamera), this._eventDispatcher.injectViewOrientationChangeEvent();
  }
  /**
   * Returns the size of the viewer canvas.
   * @returns the current size of the viewer canvas.
   */
  getCanvasSize() {
    return this._engine.getCanvasSize();
  }
  /**
   * @hidden
   * @param markupManager
   */
  _setMarkupManager(t) {
    this._markupManager = t;
  }
  /**
   * Sets the display for the default statistic overlay.
   * @param visible whether the default statistics overlay should be drawn.
   */
  async setStatisticsDisplayVisibility(t) {
    t ? await this._statistics.showDisplay() : this._statistics.hideDisplay();
  }
  /**
   * Returns the background colors of the canvas.
   * @returns the canvas background colors.
   */
  getBackgroundColor() {
    var i, s;
    const t = ((i = this._backgroundColorTop) == null ? void 0 : i.copy()) ?? null, e = ((s = this._backgroundColorBottom) == null ? void 0 : s.copy()) ?? null;
    return new fp(t, e);
  }
  /**
   * Sets the viewer background color to a gradient interpolating from the top to bottom color.
   * For a solid color, the top and bottom color should have the same values.
   * Background Transparency is only available with client-side rendering.
   * To re-enable a transparent background, pass null to the parameters of this function.
   *
   * When draw mode is set to {@link DrawMode.HiddenLine}, the background color is defined in {@link HiddenLineSettings HiddenLineSettings}.
   * See {@link HiddenLineSettings.setBackgroundColor HiddenLineSettings.setBackgroundColor}.
   * @param top the top color for the the background gradient.
   * @param bottom the bottom color for the the background gradient.
   * @returns a promise that resolves when the operation has completed.
   */
  setBackgroundColor(t = null, e = null) {
    return this._backgroundColorTop = t !== null ? t.copy() : null, this._backgroundColorBottom = e !== null ? e.copy() : null, this._drawMode !== xn.HiddenLine && !this._viewer.sheetManager.isDrawingSheetActive() && this._engine.setBackgroundGradient(this._backgroundColorTop, this._backgroundColorBottom), Promise.resolve();
  }
  /**
   * Hides all nodes except those specified. Also fits the camera to those nodes' bounding box.
   * @param nodeIds An array of the node IDs to be isolated.
   * @param duration Time in milliseconds for the camera transition to the new camera view.
   * @param fitNodes If true, then the view is fitted around the isolated nodes.
   * @param initiallyHiddenStayHidden Controls whether or not initially hidden geometries stay hidden. Default behavior is driven by [[setBehaviorInitiallyHidden]].
   */
  async isolateNodes(t, e = Ni, i = !0, s = null) {
    const r = this._model.getAbsoluteRootNode(), o = /* @__PURE__ */ new Map();
    o.set(r, !1);
    for (const a of t)
      o.set(a, !0);
    if (await this._model.setNodesVisibilities(o, s), i)
      return this.fitNodes(t, e);
  }
  /**
   * Fits the camera to the bounding box containing the node ids.
   * @param nodeIds Array of node ids to fit the camera.
   * @param duration Time in milliseconds for the camera transition to the new camera view.
   * @returns A promise that will be resolved once the transition is complete.
   */
  async fitNodes(t, e = Ni) {
    const i = await this._model.getNodesBounding(t);
    return this.fitBounding(i, e);
  }
  /**
   * Fits the view to the model bounding box.
   * @param duration the number of milliseconds to transition to the new camera.
   * @returns A promise that will be resolved once the transition is complete.
   */
  async fitWorld(t = 0, e) {
    e || (e = this.getCamera());
    const i = await this._model.getModelBounding(
      this._boundingCalculationIgnoresInvisible,
      !1
    );
    await this.fitBounding(i, t, e);
  }
  _fitCameraToBounding(t, e) {
    if (this._viewer.sheetManager.isDrawingSheetActive()) {
      const i = e.extents(), s = e.center(), r = new d(s.x, s.y, e.min.z + i.length());
      t.setProjection(te.Orthographic), t.setPosition(r), t.setTarget(s), t.setWidth(i.x * 1.25), t.setHeight(i.y * 1.25);
    } else {
      const s = e.extents().length();
      if (s !== 0) {
        const r = t.getWidth(), o = d.subtract(t.getPosition(), t.getTarget()), a = o.length(), l = s * a / r, c = e.center(), h = d.add(c, o.normalize().scale(l));
        t.setTarget(c), t.setPosition(h), t.setWidth(s), t.setHeight(s);
      } else {
        const r = d.subtract(t.getPosition(), t.getTarget()), o = e.center(), a = d.add(o, r);
        t.setTarget(o), t.setPosition(a);
      }
    }
  }
  /**
   * Fits the camera to the bounding box.
   * @param bounding bounding box to fit the camera.
   * @param duration Time in milliseconds for the camera transition to the new camera view.
   * @returns A promise that will be resolved once the transition is complete.
   */
  async fitBounding(t, e = Ni, i = this.getCamera()) {
    if (t) {
      if (t.isDegenerate() || this._fitCameraToBounding(i, t), e > 0)
        return this._setCameraPromise(i, e);
      this.setCamera(i);
    }
  }
  /**
   * Sets whether backfaces should be rendered in the scene.
   * @param visible Boolean value indicating whether backfaces should be rendered.
   * @returns Promise that is resolved when this operation has completed.
   */
  setBackfacesVisible(t) {
    return this._backfacesVisible = t, this._engine.setBackFacesVisible(t), Promise.resolve();
  }
  /**
   * Gets whether backfaces are being rendered in the scene.
   * @returns Boolean value indicating whether backfaces are being rendered in the scene.
   */
  getBackfacesVisible() {
    return this._backfacesVisible;
  }
  /**
   * Sets the drawing mode for the scene.
   * @param drawMode The drawing mode to set.
   */
  setDrawMode(t) {
    return this._setDrawMode(t), Promise.resolve();
  }
  _setDrawMode(t) {
    switch (this._drawMode = t, this._drawMode !== xn.HiddenLine && this.setBackgroundColor(this._backgroundColorTop, this._backgroundColorBottom), t) {
      case xn.Wireframe:
        this._engine.setDrawMode(Dn.Highlight), this._setLineVisibility(!0), this._setFaceVisibility(!1);
        break;
      case xn.Shaded:
        this._engine.setDrawMode(Dn.Highlight), this._setLineVisibility(!1), this._setFaceVisibility(!0);
        break;
      case xn.WireframeOnShaded:
        this._engine.setDrawMode(Dn.Highlight), this._setLineVisibility(!0), this._setFaceVisibility(!0);
        break;
      case xn.HiddenLine:
        {
          const e = this._hiddenLineSettings.getBackgroundColor();
          this._setLineVisibility(!0), this._setFaceVisibility(!0), this._engine.enableHiddenLineRendering(this._hiddenLineSettings), this._engine.setBackgroundGradient(e.top, e.bottom);
        }
        break;
      case xn.XRay:
        this._engine.setDrawMode(Dn.XRay), this._setLineVisibility(!0), this._setFaceVisibility(!0);
        break;
      case xn.Gooch:
        this._engine.setDrawMode(Dn.Gooch);
        break;
      case xn.Toon:
        this._setLineVisibility(!1), this._engine.setDrawMode(Dn.Toon);
    }
  }
  /**
   * @returns The current draw mode
   */
  getDrawMode() {
    return this._drawMode;
  }
  /**
   * Sets the anti-aliasing mode for the scene.
   * @param antiAliasingMode
   */
  setAntiAliasingMode(t) {
    return this._setAntiAliasingMode(t), Promise.resolve();
  }
  _setAntiAliasingMode(t) {
    this._antiAliasingMode = t, this._engine.setAntiAliasingMode(t);
  }
  /**
   * Gets the anti-aliasing mode for the scene. The Default value is AntiAliasingMode.SMAA
   * @returns the current anti-aliasing mode.
   */
  getAntiAliasingMode() {
    return this._antiAliasingMode;
  }
  /**
   * @returns a [[HiddenLineSettings]] object.
   */
  getHiddenLineSettings() {
    return this._hiddenLineSettings;
  }
  /**
   * Sets whether ambient occlusion is enabled
   * @param enabled sets whether ambient occlusion will be enabled
   */
  setAmbientOcclusionEnabled(t = !0) {
    return this._setAmbientOcclusionEnabled(t), Promise.resolve();
  }
  _setAmbientOcclusionEnabled(t = !0) {
    this._ambientOcclusionEnabled = t, this._engine.setAmbientOcclusionEnabled(t);
  }
  /**
   * @returns boolean value indicating whether ambient occlusion is enabled
   */
  getAmbientOcclusionEnabled() {
    return this._ambientOcclusionEnabled;
  }
  /**
   * Sets the ambient occlusion radius. This value represents the maximum screen-proportional distance between two points such that one will cast a shadow on the other.
   * @param radius the ambient occlusion radius.
   */
  setAmbientOcclusionRadius(t) {
    return this._setAmbientOcclusionRadius(t), Promise.resolve();
  }
  _setAmbientOcclusionRadius(t) {
    this._ambientOcclusionRadius = t, this._engine.setAmbientOcclusionRadius(t);
  }
  /**
   * @returns the ambient occlusion radius
   */
  getAmbientOcclusionRadius() {
    return this._ambientOcclusionRadius;
  }
  /**
   * Sets whether lighting is enabled. When disabled, material colors
   * are drawn at full intensity.
   *
   * See also [[InstanceModifier.DoNotLight]], [[clearLights]].
   */
  setLightingEnabled(t = !0) {
    return this._setLightingEnabled(t), Promise.resolve();
  }
  _setLightingEnabled(t = !0) {
    this._lightingEnabled = t, this._engine.setLightingEnabled(t);
  }
  /**
   * Returns whether lighting is enabled.
   *
   * See also [[setLightingEnabled]].
   */
  getLightingEnabled() {
    return this._lightingEnabled;
  }
  /**
   * Sets how transparent objects are blended.
   */
  setTransparencyMode(t) {
    this._engine.setTransparencyMode(t);
  }
  /**
   * Sets the opacity of unselected items in x-ray mode.
   * @param opacity a number between 0 and 1
   * @param element the type of element to which the opacity will apply.
   * If unspecified, the opacity will apply to all element types.
   */
  setXRayOpacity(t, e) {
    return this._setXRayOpacity(t, e), Promise.resolve();
  }
  _setXRayOpacity(t, e) {
    this._engine.setXRayOpacity(t, e);
  }
  /**
   * Sets how transparent (unselected) objects are blended in x-ray mode.
   */
  setXRayTransparencyMode(t) {
    return this._setXRayTransparencyMode(t), Promise.resolve();
  }
  _setXRayTransparencyMode(t) {
    this._engine.setXRayTransparencyMode(t);
  }
  /**
   * Sets the color applied to nodes in x-ray mode.
   * By default, the color is unset.
   *
   * See [[unsetXRayColor]].
   *
   * @param element the type of geometry to apply the color to
   * @param color the color to apply
   * @param group the category of nodes that will be affected.
   * If unspecified, [[XRayGroup.Selected]] will be used.
   */
  setXRayColor(t, e, i = ta.Selected) {
    return this._engine.setXRayColor(i, t, e), Promise.resolve();
  }
  /**
   * Unsets the color applied to selected items in x-ray mode.
   * Selected items will be displayed without overriding their colors.
   *
   * See [[setXRayColor]].
   *
   * @param element the type of geometry affected by the change
   * @param group the category of nodes that will be affected.
   * If unspecified, [[XRayGroup.Selected]] will be used.
   */
  unsetXRayColor(t, e = ta.Selected) {
    return this._engine.unsetXRayColor(e, t);
  }
  /**
   * Sets the value to use as the blue tone in Gooch shading.
   * @param blue the blue tone.  This value should be in the range [0,1]
   */
  setGoochBlue(t) {
    this._goochBlue = t, this._engine.setGoochBlue(t);
  }
  /**
   * Gets the value to use as the blue tone in Gooch shading.
   */
  getGoochBlue() {
    return this._goochBlue;
  }
  /**
   * Sets the prominence of the object's base color in Gooch shading.
   * @param prominence this scalar value determines the amount of the object's base color is applied to the final shaded color.
   */
  setGoochBaseColorProminence(t) {
    this._goochBaseColorProminence = t, this._engine.setGoochBaseColorProminence(t);
  }
  /**
   * Gets the prominence of the object's base color in Gooch shading.
   */
  getGoochBaseColorProminence() {
    return this._goochBaseColorProminence;
  }
  /**
   * Sets the value to use as the yellow tone in Gooch shading.
   * @param yellow the yellow tone. This value should be in the range [0,1]
   *
   */
  setGoochYellow(t) {
    this._goochYellow = t, this._engine.setGoochYellow(t);
  }
  /**
   * Gets the value to use as the yellow tone in Gooch shading.
   */
  getGoochYellow() {
    return this._goochYellow;
  }
  /**
   * Sets the number of discrete shading bands that will be used when toon shading is enabled.  Each band represents a shade between dark and light which will control the final color of the pixel based on its light intensity.  The default band count is 3.
   */
  setToonShadingBandCount(t) {
    this._toonBandCount = t, this._engine.setToonShadingBandCount(t);
  }
  /**
   * Gets the current number of discrete shading bands that will be used when toon shading is enabled.
   */
  getToonShadingBandCount() {
    return this._toonBandCount;
  }
  /**
   * Sets a scale factor which controls the size of specular highlights when toon shading is enabled.  The default value is 1.0.
   */
  setToonShadingSpecularFactor(t) {
    this._toonSpecularFactor = t, this._engine.setToonShadingSpecularFactor(t);
  }
  /**
   * Gets the current toon shading specular scale factor.
   */
  getToonShadingSpecularFactor() {
    return this._toonSpecularFactor;
  }
  /**
   * Sets the strength of the luminance shift in Gooch shading.
   * @param shiftStrength this scalar values determines the amount of luminance shift that is applied to the object's base color
   */
  setGoochLuminanceShiftStrength(t) {
    this._goochLuminanceShiftStrength = t, this._engine.setGoochLuminanceShiftStrength(t);
  }
  /**
   * Gets the strength of the luminance shift in Gooch shading.
   */
  getGoochLuminanceShiftStrength() {
    return this._goochLuminanceShiftStrength;
  }
  /**
   * Sets the diameter of rendered points. (default: 1, ScreenPixels) See [[PointSizeUnit]].
   */
  setPointSize(t, e) {
    return this._setPointSize(t, e), Promise.resolve();
  }
  _setPointSize(t, e) {
    this._engine.setPointSize(t, e);
  }
  /**
   * Gets the diameter of rendered points. See [[PointSizeUnit]].
   */
  getPointSize() {
    return this._engine.getPointSize();
  }
  /**
   * Controls the appearance of rendered points. (default: Square) See [[PointShape]].
   */
  setPointShape(t) {
    return this._setPointShape(t), Promise.resolve();
  }
  _setPointShape(t) {
    this._engine.setPointShape(t);
  }
  /**
   * Gets the PointShape. See [[PointShape]]
   */
  getPointShape() {
    return this._engine.getPointShape();
  }
  /**
   * Enables or disables eye-dome lighting for point clouds. (default: disabled)
   */
  setEyeDomeLightingEnabled(t = !0) {
    return this._setEyeDomeLightingEnabled(t), Promise.resolve();
  }
  _setEyeDomeLightingEnabled(t = !0) {
    this._engine.setEyeDomeLightingEnabled(t);
  }
  /**
   * @returns boolean value indicating if eye-dome lighting is enabled or disabled.
   */
  getEyeDomeLightingEnabled() {
    return this._engine.getEyeDomeLightingEnabled();
  }
  /**
   * Sets the diameter of the blur filter used in eye-dome lighting for point clouds.
   * Setting the value to 0 will disable blurring. (default: 7)
   */
  setEyeDomeLightingBlurSamples(t) {
    return this._setEyeDomeLightingBlurSamples(t), Promise.resolve();
  }
  _setEyeDomeLightingBlurSamples(t) {
    this._engine.setEyeDomeLightingBlurSamples(t);
  }
  /**
   * Returns the diameter of the blur filter used in eye-dome lighting for point clouds.
   * A value of 0 means that blurring is disabled.
   */
  getEyeDomeLightingBlurSamples() {
    return this._engine.getEyeDomeLightingBlurSamples();
  }
  /**
   * Sets the distance in pixels between samples taken by the blur filter used in eye-dome lighting
   * for point clouds. (default: 1)
   */
  setEyeDomeLightingBlurInterval(t) {
    return this._setEyeDomeLightingBlurInterval(t), Promise.resolve();
  }
  _setEyeDomeLightingBlurInterval(t) {
    this._engine.setEyeDomeLightingBlurInterval(t);
  }
  /**
   * Returns the distance in pixels between samples taken by the blur filter used in eye-dome lighting
   * for point clouds.
   */
  getEyeDomeLightingBlurInterval() {
    return this._engine.getEyeDomeLightingBlurInterval();
  }
  /**
   * Controls the maximum Z-distance between samples taken by the blur filter used in eye-dome
   * lighting for point clouds. The value is taken as a proportion of the screen size.
   * Decreasing the value will result in sharper edges, and increasing the value will result
   * in softer edges. (default: .03)
   */
  setEyeDomeLightingBlurEdgeDistance(t) {
    return this._setEyeDomeLightingBlurEdgeDistance(t), Promise.resolve();
  }
  _setEyeDomeLightingBlurEdgeDistance(t) {
    this._engine.setEyeDomeLightingBlurEdgeDistance(t);
  }
  /**
   * Returns a value that controls the maximum Z-distance between samples taken by
   * the blur filter used in eye-dome lighting for point clouds.
   * The value is a proportion of the screen size.
   */
  getEyeDomeLightingBlurEdgeDistance() {
    return this._engine.getEyeDomeLightingBlurEdgeDistance();
  }
  /**
   * Controls the shading contrast in eye-dome lighting for point clouds. The value is taken
   * as a number of pixels. Increasing the value will result in overall lighter shading, and
   * decreasing the value will result in overall darker shading. (default: 2)
   */
  setEyeDomeLightingShadingEdgeDistance(t) {
    return this._setEyeDomeLightingShadingEdgeDistance(t), Promise.resolve();
  }
  _setEyeDomeLightingShadingEdgeDistance(t) {
    this._engine.setEyeDomeLightingShadingEdgeDistance(t);
  }
  /**
   * Returns a value that controls the shading contrast in eye-dome lighting for point clouds.
   * The value is a number of pixels.
   */
  getEyeDomeLightingShadingEdgeDistance() {
    return this._engine.getEyeDomeLightingShadingEdgeDistance();
  }
  /**
   * Sets the opacity of the shading rendered by eye-dome lighting for point clouds. (default: 1)
   * @param value A number in the range [0,1].
   */
  setEyeDomeLightingOpacity(t) {
    return this._setEyeDomeLightingOpacity(t), Promise.resolve();
  }
  _setEyeDomeLightingOpacity(t) {
    this._engine.setEyeDomeLightingOpacity(t);
  }
  /**
   * Returns the opacity of the shading rendered by eye-dome lighting for point clouds.
   * The value is in the range [0,1].
   */
  getEyeDomeLightingOpacity() {
    return this._engine.getEyeDomeLightingOpacity();
  }
  /**
   * Sets whether or not bounding calculations by this View object ignores invisible geometry.
   */
  setBoundingCalculationIgnoresInvisible(t) {
    this._boundingCalculationIgnoresInvisible = t;
  }
  /**
   * @returns whether or not bounding calculations by this View object ignores invisible geometry.
   */
  getBoundingCalculationIgnoresInvisible() {
    return this._boundingCalculationIgnoresInvisible;
  }
  /**
   * Sets whether intermediate frames of an incremental draw will be displayed. (default: true)
   *
   * If false, the image will only be displayed once completely drawn, except immediately
   * after certain operations, such as setting the camera. To disable these exceptions,
   * call [[setInteractiveDrawDelay]] with a value of 0.
   */
  setDisplayIncompleteFrames(t) {
    return this._setDisplayIncompleteFrames(t), Promise.resolve();
  }
  _setDisplayIncompleteFrames(t) {
    this._engine.setDisplayIncompleteFrames(t);
  }
  /**
   * Sets whether to change cad view cameras with extreme values to functionally identical cameras with
   * better behavior. This should be disabled if it is important that cameras have their authored values
   * Default: true
   * @param value Whether to modify cameras
   */
  setMassageExtremeCameras(t) {
    this._massageExtremeCameras = t;
  }
  getMassageExtremeCameras() {
    return this._massageExtremeCameras;
  }
  /**
   * Sets how long after certain operations, such as setting the camera, to wait before
   * starting a redraw. This delay exists in order to prevent flicker during continuous
   * interaction. The initial value is 200ms.
   * @param value The delay in milliseconds
   */
  setInteractiveDrawDelay(t) {
    return this._setInteractiveDrawDelay(t), Promise.resolve();
  }
  _setInteractiveDrawDelay(t) {
    this._engine.setInteractiveDrawDelay(t);
  }
  /**
   * Sets whether or not the viewer will periodically attempt to increase the amount drawn during interaction.
   * Setting this to `false` may improve periodic framerate dips caused by such adjustments.
   * @param enable
   */
  setInteractiveDrawLimitIncreaseEnabled(t) {
    this._engine.setInteractiveDrawLimitIncreaseEnabled(t);
  }
  /**
   * Gets whether or not the viewer will periodically attempt to increase the amount drawn during interaction.
   * @return boolean value indicating whether this feature is enabled or not
   */
  getInteractiveDrawLimitIncreaseEnabled() {
    return this._engine.getInteractiveDrawLimitIncreaseEnabled();
  }
  getNavCube() {
    return this._navCube;
  }
  get navCube() {
    return this._navCube;
  }
  getAxisTriad() {
    return this._axisTriad;
  }
  get axisTriad() {
    return this._axisTriad;
  }
  _determineViewAxes(t) {
    const e = t.getUp().normalize(), i = d.subtract(t.getTarget(), t.getPosition()).normalize();
    let s = iu(e), r = iu(i);
    s === null && r === null ? (s = new d(0, 1, 0), r = new d(0, 0, 1)) : s === null ? r.y === 0 ? s = new d(0, 1, 0) : s = new d(0, 0, 1) : r === null && (s.z === 0 ? r = new d(0, 0, 1) : r = new d(0, 1, 0));
    try {
      this._model.setViewAxes(r, s);
    } catch {
    }
  }
  /**
   * Sets the color of the ambient light applied to the scene.
   * This is a constant source of light that affects every point
   * in the scene in the same way regardless of position
   * or surface normal.
   *
   * See also [[getAmbientLightColor]].
   */
  setAmbientLightColor(t) {
    this._ambientLightColor = t, this._engine.setAmbientLightColor(t);
  }
  /**
   * Gets the color of the ambient light applied to the scene.
   *
   * See also [[setAmbientLightColor]].
   */
  getAmbientLightColor() {
    return this._ambientLightColor;
  }
  /**
   * Get the list of light keys in the scene.
   * @returns The list of light keys in the scene.
   */
  getLightKeys() {
    return this._engine.getLightKeys();
  }
  /**
   * Get a Light given its key if it exists.
   * @param key The key of the light to get.
   * @returns A Light given its key if it exists.
   */
  getLight(t) {
    return this._engine.getLight(t);
  }
  /**
   * Removes all lights from the scene. When there are no lights,
   * material colors are drawn at full intensity. This has the same
   * visual effect as calling `setLightingEnabled(false)`.
   *
   * See also:
   *  - [[InstanceModifier.DoNotLight]]
   *  - [[setLightingEnabled]]
   */
  clearLights() {
    this._engine.clearLights();
  }
  /**
   * Adds a light to the scene. The returned promise may be rejected if
   * there are too many lights in the scene. See [[Light]].
   *
   * See also:
   *  - [[clearLights]]
   *  - [[removeLight]]
   *  - [[updateLight]]
   *  - [[setAmbientLightColor]]
   */
  addLight(t) {
    return this._engine.addLight(t);
  }
  /**
   * removes a light from the scene. See [[Light]].
   *
   * See also:
   *  - [[addLight]]
   *  - [[clearLights]]
   *  - [[updateLight]]
   */
  removeLight(t) {
    this._engine.removeLight(t);
  }
  /**
   * Updates a light in the scene. See [[Light]].
   *
   * See also:
   *  - [[addLight]]
   *  - [[clearLights]]
   *  - [[removeLight]]
   */
  updateLight(t, e) {
    this._engine.updateLight(t, e);
  }
  /**
   * Sets whether bloom is enabled.
   *
   * See [[getBloomEnabled]].
   */
  setBloomEnabled(t = !0) {
    this._engine.setBloomEnabled(t), this._bloomEnabled = t;
  }
  /**
   * Returns whether bloom is enabled.
   *
   * See [[setBloomEnabled]].
   */
  getBloomEnabled() {
    return this._bloomEnabled;
  }
  /**
   * Sets the minimum luminance value a pixel must have for it to
   * contribute to bloom. The value should be in the range `[0,1]`.
   *
   * See [[getBloomThreshold]], [[setBloomThresholdRampWidth]].
   */
  setBloomThreshold(t) {
    this._engine.setBloomThreshold(t), this._bloomThreshold = t;
  }
  /**
   * Returns the minimum luminance value a pixel must have for it to
   * contribute to bloom.
   *
   * See [[setBloomThreshold]], [[getBloomThresholdRampWidth]].
   */
  getBloomThreshold() {
    return this._bloomThreshold;
  }
  /**
   * Sets how much greater than the threshold set by [[setBloomThreshold]]
   * a pixel's luminance value must be before it contributes fully to
   * the bloom effect.
   *
   * If the pixel's luminance value does not exceed
   * the threshold by at least the amount set by this function,
   * the pixel's contribution will be diminished based on how close
   * its luminance value is to the threshold.
   *
   * See [[getBloomThresholdRampWidth]].
   */
  setBloomThresholdRampWidth(t) {
    this._engine.setBloomThresholdRampWidth(t), this._bloomThresholdRampWidth = t;
  }
  /**
   * Returns how much greater than the threshold set by [[setBloomThreshold]]
   * a pixel's luminance value must be before it contributes fully to
   * the bloom effect.
   *
   * See [[setBloomThresholdRampWidth]].
   */
  getBloomThresholdRampWidth() {
    return this._bloomThresholdRampWidth;
  }
  /**
   * Sets the intensity of the bloom effect. This value is multiplied
   * by the intensities of the individual layers set by [[setBloomLayers]].
   *
   * See [[getBloomIntensityScale]].
   */
  setBloomIntensityScale(t) {
    this._engine.setBloomIntensityScale(t), this._bloomIntensityScale = t;
  }
  /**
   * Gets the intensity of the bloom effect.
   *
   * See [[setBloomIntensityScale]].
   */
  getBloomIntensityScale() {
    return this._bloomIntensityScale;
  }
  /**
   * Sets the number of layers in the bloom effect and the layers'
   * attributes.
   *
   * The bloom effect is achieved by applying a luminance filter to the
   * source image, then progressively downsampling, blurring, and adding
   * the results together. The result of each downsample/blur operation is
   * fed into the next, which is executed at half the resolution of the
   * previous. The number of stages and the behavior of each stage
   * are controlled by this function.
   *
   * See [[BloomLayerInfo]], [[getBloomLayers]].
   */
  setBloomLayers(t) {
    const e = Fo(t);
    for (const i of e)
      i.intensity === void 0 && (i.intensity = 1), i.blurSamples === void 0 && (i.blurSamples = 9), i.blurInterval === void 0 && (i.blurInterval = [1, mn.Pixels]);
    this._engine.setBloomLayers(e), this._bloomLayers = e;
  }
  /**
   * Returns an array of objects describing each layer in the bloom
   * effect.
   *
   * See [[setBloomLayers]].
   */
  getBloomLayers() {
    return Fo(this._bloomLayers);
  }
  /**
   * Enables a visual comparison of two sets of nodes. The nodes specified
   * by `nodeIdSet1` are filled with one color, the nodes specified by
   * `nodeIdSet2` with another color, and overlapping areas are filled
   * with a third color.
   *
   * See [[endComparison]].
   *
   * @param nodeIdSet1 the nodes to compare against `nodeIdSet2`
   * @param nodeIdSet2 the nodes to compare against `nodeIdSet1`
   * @param config settings controlling the behavior of the comparison
   */
  startComparison(t, e, i) {
    const s = this._model._getModelStructure(), r = s.gatherInstanceIncsFromNodeIds(
      t,
      bt.All,
      ft.None
    ), o = s.gatherInstanceIncsFromNodeIds(
      e,
      bt.All,
      ft.None
    );
    this._engine.startComparison(r, o, i);
  }
  /**
   * Disables a visual comparison of two sets of nodes enabled by
   * [[startComparison]].
   */
  endComparison() {
    this._engine.endComparison();
  }
  /**
   * Enables or disables a full-scene shadow projected onto an
   * invisible ground plane.
   *
   * See also:
   *  - [[getSimpleShadowEnabled]]
   *  - [[setSimpleShadowColor]]
   *  - [[setSimpleShadowOpacity]]
   *  - [[setGroundPlane]]
   *  - [[setSimpleShadowResolution]]
   *  - [[setSimpleShadowInteractiveUpdateEnabled]]
   *
   * @param value Whether simple shadows should be enabled.
   */
  setSimpleShadowEnabled(t = !0) {
    this._simpleShadowEnabled = t, this._engine.setSimpleShadowEnabled(t);
  }
  /**
   * Returns whether simple shadows are enabled.
   *
   * See [[setSimpleShadowEnabled]].
   */
  getSimpleShadowEnabled() {
    return this._simpleShadowEnabled;
  }
  /**
   * Sets the color of simple shadows.
   *
   * See also:
   *  - [[getSimpleShadowColor]]
   *  - [[setSimpleShadowEnabled]]
   *
   * @param color The color to set.
   */
  setSimpleShadowColor(t) {
    this._simpleShadowColor = t.copy(), this._engine.setSimpleShadowColor(t);
  }
  /**
   * Returns the color of simple shadows.
   *
   * See also:
   *  - [[setSimpleShadowColor]]
   *  - [[setSimpleShadowEnabled]]
   */
  getSimpleShadowColor() {
    return this._simpleShadowColor.copy();
  }
  /**
   * Sets the opacity of simple shadows.
   *
   * See also:
   *  - [[getSimpleShadowOpacity]]
   *  - [[setSimpleShadowEnabled]]
   *
   * @param opacity The opacity to set.
   */
  setSimpleShadowOpacity(t) {
    this._simpleShadowOpacity = t, this._engine.setSimpleShadowOpacity(t);
  }
  /**
   * Returns the opacity of simple shadows.
   *
   * See also:
   *  - [[setSimpleShadowOpacity]]
   *  - [[setSimpleShadowEnabled]]
   */
  getSimpleShadowOpacity() {
    return this._simpleShadowOpacity;
  }
  /**
   * Defines the invisible ground plane onto which simple shadows
   * and reflections are projected.
   *
   * See also:
   *  - [[getGroundPlane]]
   *  - [[setSimpleShadowEnabled]]
   *  - [[setSimpleReflectionEnabled]]
   *
   * @param plane The plane to set.
   */
  setGroundPlane(t) {
    this._groundPlane = { ...t }, this._updateGroundPlane();
  }
  _updateGroundPlane(t, e) {
    if (!(this._groundPlane.followViewAxes && (t !== void 0 && e !== void 0 || this._model.viewAxesHaveBeenSet()))) {
      this._engine.setGroundPlane(this._groundPlane.normal, this._groundPlane.position);
      return;
    }
    if (t === void 0 || e === void 0) {
      const l = this._model.getViewAxes();
      t = l.frontVector, e = l.upVector;
    }
    const i = t.copy().negate(), s = e, r = d.cross(s, i), o = Q.createFromBasis(i, r, s), a = new d(0, 0, 0);
    o.transform(this._groundPlane.normal, a), this._engine.setGroundPlane(a, this._groundPlane.position);
  }
  /**
   * Returns information about the invisible ground plane onto which
   * simple shadows and reflections are projected.
   *
   * See also:
   *  - [[setGroundPlane]]
   */
  getGroundPlane() {
    return { ...this._groundPlane };
  }
  /**
   * Sets the width and height in pixels of the texture image into which
   * simple shadows are drawn.
   *
   * See also:
   *  - [[getSimpleShadowResolution]]
   *  - [[setSimpleShadowEnabled]]
   *
   * @param pixels The resolution to set.
   */
  setSimpleShadowResolution(t) {
    this._simpleShadowResolution = t, this._engine.setSimpleShadowResolution(t);
  }
  /**
   * Returns the width and height in pixels of the texture image
   * into which simple shadows are drawn.
   *
   * See also:
   *  - [[getSimpleShadowResolution]]
   *  - [[setSimpleShadowEnabled]]
   */
  getSimpleShadowResolution() {
    return this._simpleShadowResolution;
  }
  /**
   * Sets the diameter of the blur filter used for simple shadows.
   * Setting the value to `0` will disable blurring.
   *
   * See also:
   *  - [[getSimpleShadowBlurSamples]]
   *  - [[setSimpleShadowEnabled]]
   *
   * @param value The number of samples.
   */
  setSimpleShadowBlurSamples(t) {
    this._simpleShadowBlurSamples = t, this._engine.setSimpleShadowBlurSamples(t);
  }
  /**
   * Returns the diameter of the blur filter used for simple shadows.
   *
   * See also:
   *  - [[setSimpleShadowBlurSamples]]
   *  - [[setSimpleShadowEnabled]]
   */
  getSimpleShadowBlurSamples() {
    return this._simpleShadowBlurSamples;
  }
  /**
   * Sets the distance in pixels between samples taken by the blur filter
   * used for simple shadows.
   *
   * See also:
   *  - [[getSimpleShadowBlurInterval]]
   *  - [[setSimpleShadowEnabled]]
   *
   * @param value The interval to set.
   */
  setSimpleShadowBlurInterval(t) {
    this._simpleShadowBlurInterval = t, this._engine.setSimpleShadowBlurInterval(t);
  }
  /**
   * Returns the distance in pixels between samples taken by the blur
   * filter used for simple shadows.
   *
   * See also:
   *  - [[setSimpleShadowBlurInterval]]
   *  - [[setSimpleShadowEnabled]]
   */
  getSimpleShadowBlurInterval() {
    return this._simpleShadowBlurInterval;
  }
  /**
   * Enables or disables updates to simple shadows during user
   * interaction.
   *
   * See also:
   *  - [[getSimpleShadowInteractiveUpdateEnabled]]
   *  - [[setSimpleShadowEnabled]]
   */
  setSimpleShadowInteractiveUpdateEnabled(t = !0) {
    this._simpleShadowInteractiveUpdateEnabled = t, this._engine.setSimpleShadowInteractiveUpdateEnabled(t);
  }
  /**
   * Returns whether simple shadows will be updated during user
   * interaction.
   *
   * See also:
   *  - [[setSimpleShadowInteractiveUpdateEnabled]]
   *  - [[setSimpleShadowEnabled]]
   */
  getSimpleShadowInteractiveUpdateEnabled() {
    return this._simpleShadowInteractiveUpdateEnabled;
  }
  /**
   * Enables or disables silhouette edges.
   *
   * Silhouette edges are always enabled in hidden line mode.
   *
   * See also:
   * - [[getSilhouetteEnabled]]
   * - [[setSilhouetteColor]]
   * - [[setSilhouetteOpacity]]
   * - [[setSilhouetteThreshold]]
   * - [[setSilhouetteThresholdRampWidth]]
   *
   * @param value Whether silhouette edges should be enabled.
   */
  setSilhouetteEnabled(t = !0) {
    this._silhouetteEnabled = t, this._engine.setSilhouetteEnabled(t);
  }
  /**
   * Returns whether silhouette edges are enabled.
   *
   * Silhouette edges are always enabled in hidden line mode, regardless
   * of the return value.
   *
   * See [[setSilhouetteEnabled]].
   */
  getSilhouetteEnabled() {
    return this._silhouetteEnabled;
  }
  /**
   * Sets the color of silhouette edges.
   *
   * See also:
   * - [[getSilhouetteColor]]
   * - [[setSilhouetteEnabled]]
   *
   * @param value The color to set.
   */
  setSilhouetteColor(t) {
    this._silhouetteColor = t.copy(), this._engine.setSilhouetteColor(t);
  }
  /**
   * Returns the color of silhouette edges.
   *
   * See also:
   * - [[setSilhouetteColor]]
   * - [[setSilhouetteEnabled]]
   */
  getSilhouetteColor() {
    return this._silhouetteColor.copy();
  }
  /**
   * Sets the opacity of silhouette edges.
   *
   * See also:
   * - [[getSilhouetteOpacity]]
   * - [[setSilhouetteEnabled]]
   *
   * @param value The opacity to set.
   */
  setSilhouetteOpacity(t) {
    this._silhouetteOpacity = t, this._engine.setSilhouetteOpacity(t);
  }
  /**
   * Returns the opacity of silhouette edges.
   *
   * See also:
   * - [[setSilhouetteOpacity]]
   * - [[setSilhouetteEnabled]]
   */
  getSilhouetteOpacity() {
    return this._silhouetteOpacity;
  }
  /**
   * Sets the distance threshold for silhouette edges. This value
   * affects the minimum z-distance required between two pixels
   * for an edge to be drawn. A smaller value will result in more edges
   * being drawn on finer details.
   *
   * The value is a proportion of the canvas size and not a world-space
   * distance.
   *
   * See also:
   * - [[getSilhouetteThreshold]]
   * - [[setSilhouetteThresholdRampWidth]]
   * - [[setSilhouetteEnabled]]
   *
   * @param value The threshold to set.
   */
  setSilhouetteThreshold(t) {
    this._silhouetteThreshold = t, this._engine.setSilhouetteThreshold(t);
  }
  /**
   * Returns the distance threshold for silhouette edges. This value
   * affects the minimum z-distance required between two pixels
   * for an edge to be drawn. A smaller value will result in more edges
   * being drawn on finer details.
   *
   * The value is a proportion of the canvas size and not a world-space
   * distance.
   *
   * See also:
   * - [[setSilhouetteThreshold]]
   * - [[setSilhouetteThresholdRampWidth]]
   * - [[setSilhouetteEnabled]]
   *
   * @param value The threshold to set.
   */
  getSilhouetteThreshold() {
    return this._silhouetteThreshold;
  }
  /**
   * Controls how quickly edges fade as z-distance between pixels
   * decreases.
   *
   * This value is added to the one set by [[setSilhouetteThreshold]]
   * to create a secondary threshold. Distances greater than the
   * secondary threshold will result in edges with full opacity, and
   * distances between the two thresholds will result in edges with
   * reduced opacity.
   *
   * Setting this value to `0` will cause all edges to be drawn
   * at full opacity.
   *
   * See also:
   * - [[getSilhouetteThresholdRampWidth]]
   * - [[setSilhouetteEnabled]]
   */
  setSilhouetteThresholdRampWidth(t) {
    this._silhouetteThresholdRampWidth = t, this._engine.setSilhouetteThresholdRampWidth(t);
  }
  /**
   * Returns the value set by [[setSilhouetteThresholdRampWidth]].
   *
   * This value is added to the one set by [[setSilhouetteThreshold]]
   * to create a secondary threshold. Distances greater than the
   * secondary threshold will result in edges with full opacity, and
   * distances between the two thresholds will result in edges with
   * reduced opacity.
   *
   * A value of `0` means that all edges are drawn at full opacity.
   *
   * See also:
   * - [[setSilhouetteThresholdRampWidth]]
   * - [[setSilhouetteEnabled]]
   */
  getSilhouetteThresholdRampWidth() {
    return this._silhouetteThresholdRampWidth;
  }
  /**
   * Enables or disables hard edges. Hard edges are edges between two
   * faces whose normals diverge beyond a given angle.
   *
   * Hard edges are always enabled in hidden line mode.
   *
   * See also:
   * - [[getHardEdgesEnabled]]
   * - [[setHardEdgeColor]]
   * - [[setHardEdgeOpacity]]
   * - [[setHardEdgeThreshold]]
   * - [[setHardEdgeThresholdRampWidth]]
   *
   * @param value Whether hard edges should be enabled.
   */
  setHardEdgesEnabled(t = !0) {
    this._hardEdgesEnabled = t, this._engine.setHardEdgesEnabled(t);
  }
  /**
   * Returns whether hard edges are enabled. Hard edges are edges between
   * two faces whose normals diverge beyond a given angle.
   *
   * Hard edges are always enabled in hidden line mode, regardless of the
   * return value.
   *
   * See [[setHardEdgesEnabled]].
   */
  getHardEdgesEnabled() {
    return this._hardEdgesEnabled;
  }
  /**
   * Sets the color of hard edges.
   *
   * See also:
   * - [[getHardEdgeColor]]
   * - [[setHardEdgesEnabled]]
   *
   * @param value The color to set.
   */
  setHardEdgeColor(t) {
    this._hardEdgeColor = t.copy(), this._engine.setHardEdgeColor(t);
  }
  /**
   * Returns the color of hard edges.
   *
   * See also:
   * - [[setHardEdgeColor]]
   * - [[setHardEdgesEnabled]]
   */
  getHardEdgeColor() {
    return this._hardEdgeColor.copy();
  }
  /**
   * Sets the opacity of hard edges.
   *
   * See also:
   * - [[getHardEdgeOpacity]]
   * - [[setHardEdgesEnabled]]
   *
   * @param value The opacity to set.
   */
  setHardEdgeOpacity(t) {
    this._hardEdgeOpacity = t, this._engine.setHardEdgeOpacity(t);
  }
  /**
   * Returns the opacity of hard edges.
   *
   * See also:
   * - [[setHardEdgeOpacity]]
   * - [[setHardEdgesEnabled]]
   */
  getHardEdgeOpacity() {
    return this._hardEdgeOpacity;
  }
  /**
   * Sets the angle threshold for hard edges. Edges will be drawn between
   * two faces whose normals diverge beyond this angle.
   *
   * See also:
   * - [[getHardEdgeThreshold]]
   * - [[setHardEdgeThresholdRampWidth]]
   * - [[setHardEdgesEnabled]]
   *
   * @param degrees The threshold to set.
   */
  setHardEdgeThreshold(t) {
    this._hardEdgeThreshold = t, this._engine.setHardEdgeThreshold(t);
  }
  /**
   * Returns the angle threshold for hard edges. Edges will be drawn
   * between two faces whose normals diverge beyond this angle.
   *
   * See also:
   * - [[setHardEdgeThreshold]]
   * - [[setHardEdgeThresholdRampWidth]]
   * - [[setHardEdgesEnabled]]
   *
   * @param value The threshold to set.
   */
  getHardEdgeThreshold() {
    return this._hardEdgeThreshold;
  }
  /**
   * Controls how quickly edges fade as the angle between adjacent faces
   * decreases.
   *
   * This value is added to the one set by [[setHardEdgeThreshold]] to
   * create a secondary threshold. Angles greater than the secondary
   * threshold will result in edges with full opacity, and angles between
   * the two thresholds will result in edges with reduced opacity.
   *
   * Setting this value to `0` will cause all edges to be drawn at full
   * opacity.
   *
   * See also:
   * - [[getHardEdgeThresholdRampWidth]]
   * - [[setHardEdgesEnabled]]
   */
  setHardEdgeThresholdRampWidth(t) {
    this._hardEdgeThresholdRampWidth = t, this._engine.setHardEdgeThresholdRampWidth(t);
  }
  /**
   * Returns the value set by [[setHardEdgeThresholdRampWidth]].
   *
   * This value is added to the one set by [[setHardEdgeThreshold]] to
   * create a secondary threshold. Angles greater than the secondary
   * threshold will result in edges with full opacity, and angles between
   * the two thresholds will result in edges with reduced opacity.
   *
   * A value of `0` means that all edges are drawn at full opacity.
   *
   * See also:
   * - [[setHardEdgeThresholdRampWidth]]
   * - [[setHardEdgesEnabled]]
   */
  getHardEdgeThresholdRampWidth() {
    return this._hardEdgeThresholdRampWidth;
  }
  /**
   * Enables or disables simple reflections projected onto an
   * invisible ground plane.
   *
   * See also:
   * - [[getSimpleReflectionEnabled]]
   * - [[setSimpleReflectionOpacity]]
   * - [[setSimpleReflectionBlurSamples]]
   * - [[setSimpleReflectionBlurInterval]]
   * - [[setSimpleReflectionFadeAngle]]
   */
  setSimpleReflectionEnabled(t = !0) {
    this._simpleReflectionEnabled = t, this._engine.setSimpleReflectionEnabled(t);
  }
  /**
   * Returns whether simple reflections are enabled.
   *
   * See [[setSimpleReflectionEnabled]].
   */
  getSimpleReflectionEnabled() {
    return this._simpleReflectionEnabled;
  }
  /**
   * Sets the distance between samples taken by the blur filter used for
   * simple reflections.
   *
   * See also:
   *  - [[getSimpleReflectionBlurInterval]]
   *  - [[setSimpleReflectionEnabled]]
   *
   * @param value The interval to set.
   * @param unit The unit in which the `value` argument is specified.
   */
  setSimpleReflectionBlurInterval(t, e = mn.Pixels) {
    this._simpleReflectionBlurInterval = [t, e], this._engine.setSimpleReflectionBlurInterval(t, e);
  }
  /**
   * Returns the distance between samples taken by the blur filter used
   * for simple reflections.
   *
   * See also:
   *  - [[setSimpleReflectionBlurInterval]]
   *  - [[setSimpleReflectionEnabled]]
   */
  getSimpleReflectionBlurInterval() {
    return [this._simpleReflectionBlurInterval[0], this._simpleReflectionBlurInterval[1]];
  }
  /**
   * Sets the diameter of the blur filter used for simple reflections.
   * Setting the value less than or equal to `1` will disable blurring.
   *
   * See also:
   * - [[getSimpleReflectionBlurSamples]]
   * - [[setSimpleReflectionEnabled]]
   */
  setSimpleReflectionBlurSamples(t) {
    this._simpleReflectionBlurSamples = t, this._engine.setSimpleReflectionBlurSamples(t);
  }
  /**
   * Returns the diameter of the blur filter used for simple reflections.
   * A value less than or equal to `1` means that blurring is disabled.
   *
   * See also:
   * - [[setSimpleReflectionBlurSamples]]
   * - [[setSimpleReflectionEnabled]]
   */
  getSimpleReflectionBlurSamples() {
    return this._simpleReflectionBlurSamples;
  }
  /**
   * Sets the angle, in degrees, between the view vector and the ground
   * plane at which simple reflections begin to fade.
   *
   * Settings the value to `0` will disable the fading effect.
   *
   * Regardless of the value, simple reflections will not be drawn
   * if the camera is below the ground plane.
   *
   * See also:
   * - [[getSimpleReflectionFadeAngle]]
   * - [[setSimpleReflectionEnabled]]
   *
   * @param degrees The angle in degrees.
   */
  setSimpleReflectionFadeAngle(t) {
    this._simpleReflectionFadeAngle = t, this._engine.setSimpleReflectionFadeAngle(t);
  }
  /**
   * Returns the angle, in degrees, between the view vector and the ground
   * plane at which simple reflections begin to fade.
   *
   * A value to `0` means that the fading effect is disabled.
   *
   * Regardless of the value, simple reflections will not be drawn
   * if the camera is below the ground plane.
   *
   * See also:
   * - [[setSimpleReflectionFadeAngle]]
   * - [[setSimpleReflectionEnabled]]
   */
  getSimpleReflectionFadeAngle() {
    return this._simpleReflectionFadeAngle;
  }
  /**
   * Sets the opacity of simple reflections.
   *
   * See also:
   *  - [[getSimpleReflectionOpacity]]
   *  - [[setSimpleReflectionEnabled]]
   *
   * @param opacity The opacity to set.
   */
  setSimpleReflectionOpacity(t) {
    this._simpleReflectionOpacity = t, this._engine.setSimpleReflectionOpacity(t);
  }
  /**
   * Returns the opacity of simple reflections.
   *
   * See also:
   *  - [[setSimpleReflectionOpacity]]
   *  - [[setSimpleReflectionEnabled]]
   */
  getSimpleReflectionOpacity() {
    return this._simpleReflectionOpacity;
  }
  /**
   * Controls how objects drawn in simple reflections fade as they
   * move further from the ground plane.
   *
   * Attenuation begins at `nearDistance` and increases linearly
   * such that the model is not visible in the reflection beyond
   * `farDistance`.
   *
   * Attenuation is disabled if `farDistance` is less than or equal to
   * `nearDistance`.
   *
   * See also:
   *  - [[getSimpleReflectionAttenuation]]
   *  - [[setSimpleReflectionEnabled]]
   *
   * @param nearDistance The distance from the ground plane at which
   * objects begin to fade.
   * @param farDistance The distance from the ground plane at which
   * objects are completely faded.
   * @param unit The unit in which `nearDistance` and `farDistance` are
   * specified. If unspecified, [[SimpleReflectionAttenuationUnit.World]]
   * will be used.
   */
  setSimpleReflectionAttenuation(t, e, i = Gc.World) {
    this._simpleReflectionAttenuation = {
      nearDistance: t,
      farDistance: e,
      unit: i
    }, this._engine.setSimpleReflectionAttenuation(t, e, i);
  }
  /**
   * Returns properties that control how objects drawn in simple
   * reflections fade as they move further from the ground plane.
   *
   * Attenuation begins at `nearDistance` and increases linearly
   * such that the model is not visible in the reflection beyond
   * `farDistance`.
   *
   * Attenuation is disabled if `farDistance` is less than or equal to
   * `nearDistance`.
   *
   * See also:
   *  - [[setSimpleReflectionAttenuation]]
   *  - [[setSimpleReflectionEnabled]]
   *
   * @returns An object with the following properties:
   */
  // return type properties are listed by Typedoc
  getSimpleReflectionAttenuation() {
    return { ...this._simpleReflectionAttenuation };
  }
  /**
   * Tests whether the given points are visible by comparing them to
   * the depth buffer of the most-recently-drawn frame. Points that
   * are partially obscured by transparent objects are considered visible.
   *
   * If the test is to be run every time a frame is drawn,
   * [[setPointVisibilityTest]] should be used instead for proper
   * synchronization.
   *
   * @param points The points to test.
   * @returns A list of indices of the visible points.
   */
  testPointVisibility(t) {
    return this._engine.testPointVisibility(t);
  }
  /**
   * Sets a list of points whose visibility will be tested every time a
   * frame is drawn by comparing them to the frame's depth buffer. Points
   * that are partially obscured by transparent objects are considered
   * visible.
   *
   * The results are passed to the [[CallbackMap.frameDrawn]] callback so
   * that UI elements may be updated in sync with rendering.
   *
   * See also [[testPointVisibility]].
   *
   * @param points The points to test. An empty array will disable the test.
   */
  setPointVisibilityTest(t) {
    this._engine.setPointVisibilityTest(t);
  }
  /**
   * Sets whether image-based lighting is enabled for physically-based
   * materials.
   *
   * See also:
   * - [[getImageBasedLightingEnabled]]
   * - [[setImageBasedLightingIntensity]]
   * - [[setImageBasedLightingOrientation]]
   */
  setImageBasedLightingEnabled(t) {
    this._engine.setImageBasedLightingEnabled(t), this._imageBasedLightingEnabled = t;
  }
  /**
   * Returns whether image-based lighting is enabled for physically-based
   * materials.
   *
   * See also:
   * - [[setImageBasedLightingEnabled]]
   * - [[setImageBasedLightingIntensity]]
   * - [[setImageBasedLightingOrientation]]
   */
  getImageBasedLightingEnabled() {
    return this._imageBasedLightingEnabled;
  }
  /**
   * Sets the intensity (brightness) of image-based lighting applied to
   * physically-based materials.
   *
   * The default value is 1.
   *
   * See also:
   * - [[getImageBasedLightingIntensity]]
   * - [[setImageBasedLightingEnabled]]
   * - [[setImageBasedLightingOrientation]]
   */
  setImageBasedLightingIntensity(t) {
    this._engine.setImageBasedLightingIntensity(t), this._imageBasedLightingIntensity = t;
  }
  /**
   * Returns the intensity (brightness) of image-based lighting applied to
   * physically-based materials.
   *
   * The default value is 1.
   *
   * See also:
   * - [[setImageBasedLightingIntensity]]
   * - [[setImageBasedLightingEnabled]]
   * - [[setImageBasedLightingOrientation]]
   */
  getImageBasedLightingIntensity() {
    return this._imageBasedLightingIntensity;
  }
  _copyImageBasedLightingOrientation(t) {
    return { ...t, matrix: t.matrix.copy() };
  }
  /**
   * Sets the orientation of the image-based lighting environment applied
   * to physically-based materials.
   *
   * See also:
   * - [[getImageBasedLightingOrientation]]
   * - [[setImageBasedLightingEnabled]]
   * - [[setImageBasedLightingIntensity]]
   */
  setImageBasedLightingOrientation(t) {
    this._imageBasedLightingOrientation = this._copyImageBasedLightingOrientation(t), this._updateImageBasedLightingOrientation();
  }
  /**
   * Returns the orientation of the image-based lighting environment
   * applied to physically-based materials.
   *
   * See also:
   * - [[setImageBasedLightingOrientation]]
   * - [[setImageBasedLightingEnabled]]
   * - [[setImageBasedLightingIntensity]]
   */
  getImageBasedLightingOrientation() {
    return this._copyImageBasedLightingOrientation(this._imageBasedLightingOrientation);
  }
  _updateImageBasedLightingOrientation(t, e) {
    let i;
    if (this._imageBasedLightingOrientation.followViewAxes) {
      if (t === void 0 || e === void 0)
        if (this._model.viewAxesHaveBeenSet()) {
          const r = this._model.getViewAxes();
          t = r.frontVector, e = r.upVector;
        } else
          t = new d(0, 0, 1), e = new d(0, 1, 0);
      const s = Q.createFromBasis(
        d.cross(e, t),
        e,
        t
      );
      i = Q.multiply(this._imageBasedLightingOrientation.matrix, s);
    } else
      i = this._imageBasedLightingOrientation.matrix;
    this._engine.setImageBasedLightingMatrix(i);
  }
  /**
   * Sets the environment image used by image-based lighting applied to
   * physically-based materials.
   *
   * Passing `null` will cause the default environment image to be used.
   *
   * The image should be a cube map in KTX2 format with a space-separated
   * list of spherical harmonics coefficients stored under the "sh"
   * metadata key.
   *
   * A compatible image can be created from an equirectangular source
   * image (such as those found at [HDRI Haven](https://hdrihaven.com))
   * with the following process:
   *
   * - cmgen: https://github.com/google/filament
   * - ktx2ktx2, ktx2sc: https://github.com/KhronosGroup/KTX-Software/
   *
   * ```
   * cmgen -x out --format=ktx --size=256 in.hdr
   * ktx2ktx2 -o uncompressed.ktx2 out/out_ibl.ktx
   * ktxsc --zcmp 20 -o out.ktx2 uncompressed.ktx2
   * ```
   */
  setImageBasedLightingEnvironment(t) {
    t != null ? this._engine.setImageBasedLightingEnvironment(t) : this._engine.setImageBasedLightingEnvironmentToDefault();
  }
  /**
   * Sets whether line jitter is enabled.
   *
   * Line jitter makes lines look 'sketchy' by drawing them multiple times
   * with randomized offsets applied to the vertices.
   *
   * See also:
   * - [[getLineJitterEnabled]]
   * - [[setLineJitterInstanceCount]]
   * - [[setLineJitterRadius]]
   * - [[setLineJitterFrequency]]
   */
  setLineJitterEnabled(t = !0) {
    this._engine.setLineJitterEnabled(t), this._lineJitterEnabled = t;
  }
  /**
   * Returns whether line jitter is enabled.
   *
   * Line jitter makes lines look 'sketchy' by drawing them multiple times
   * with randomized offsets applied to the vertices.
   *
   * See also:
   * - [[setLineJitterEnabled]]
   * - [[getLineJitterInstanceCount]]
   * - [[getLineJitterRadius]]
   * - [[getLineJitterFrequency]]
   */
  getLineJitterEnabled() {
    return this._lineJitterEnabled;
  }
  /**
   * Sets the number of times lines are drawn when line jitter is enabled.
   * The default value is 4.
   *
   * Increasing this number can make the lines look more 'sketchy.'
   *
   * See also:
   * - [[setLineJitterEnabled]]
   * - [[getLineJitterInstanceCount]]
   * - [[setLineJitterRadius]]
   * - [[setLineJitterFrequency]]
   */
  setLineJitterInstanceCount(t) {
    this._engine.setLineJitterInstanceCount(t), this._lineJitterInstanceCount = t;
  }
  /**
   * Returns the number of times lines are drawn when line jitter is
   * enabled. The default value is 4.
   *
   * See also:
   * - [[getLineJitterEnabled]]
   * - [[setLineJitterInstanceCount]]
   * - [[getLineJitterRadius]]
   * - [[getLineJitterFrequency]]
   */
  getLineJitterInstanceCount() {
    return this._lineJitterInstanceCount;
  }
  /**
   * Sets the radius of the random offset applied to line vertices when
   * line jitter is enabled. The default value is 0.005.
   *
   * The value is specified as a proportion of the canvas height, where 1
   * means the full height of the canvas.
   *
   * See also:
   * - [[setLineJitterEnabled]]
   * - [[setLineJitterInstanceCount]]
   * - [[getLineJitterRadius]]
   * - [[setLineJitterFrequency]]
   */
  setLineJitterRadius(t) {
    this._engine.setLineJitterRadius(t), this._lineJitterRadius = t;
  }
  /**
   * Returns the radius of the random offset applied to line vertices when
   * line jitter is enabled. The default value is 0.005.
   *
   * The value is specified as a proportion of the canvas height, where 1
   * means the full height of the canvas.
   *
   * See also:
   * - [[getLineJitterEnabled]]
   * - [[getLineJitterInstanceCount]]
   * - [[setLineJitterRadius]]
   * - [[getLineJitterFrequency]]
   */
  getLineJitterRadius() {
    return this._lineJitterRadius;
  }
  /**
   * Sets the frequency of the noise used to offset line vertices when
   * line jitter is enabled. The default value is 5.
   *
   * Decreasing this value causes lines to appear smoother, while
   * increasing it causes lines to look more noisy.
   *
   * See also:
   * - [[setLineJitterEnabled]]
   * - [[setLineJitterInstanceCount]]
   * - [[setLineJitterRadius]]
   * - [[getLineJitterFrequency]]
   */
  setLineJitterFrequency(t) {
    this._engine.setLineJitterFrequency(t), this._lineJitterFrequency = t;
  }
  /**
   * Returns the frequency of the noise used to offset line vertices when
   * line jitter is enabled. The default value is 5.
   *
   * See also:
   * - [[getLineJitterEnabled]]
   * - [[getLineJitterInstanceCount]]
   * - [[getLineJitterRadius]]
   * - [[setLineJitterFrequency]]
   */
  getLineJitterFrequency() {
    return this._lineJitterFrequency;
  }
}
class Wr {
  constructor() {
    this._remappedModelKeys = /* @__PURE__ */ new Map(), this._remappedInclusionKeys = /* @__PURE__ */ new Map();
  }
  remapModel(t, e) {
    this._remappedModelKeys.set(e, t), this._remappedInclusionKeys.has(t) || this._remappedInclusionKeys.set(t, /* @__PURE__ */ new Map());
  }
  remapInclusion(t, e, i) {
    const s = this._remappedInclusionKeys.get(t);
    console.assert(s !== void 0), s.set(i, e);
  }
  getEffectiveModelKey(t) {
    const e = this._remappedModelKeys.get(t);
    return e !== void 0 ? e : t;
  }
  getEffectiveInclusionKey(t, e) {
    const i = this._remappedInclusionKeys.get(e);
    if (i !== void 0) {
      const s = i.get(t);
      if (s !== void 0)
        return s;
    }
    return t;
  }
}
async function xy(n) {
  const t = [], i = {
    enterProductOccurrence: (s) => {
      s.hasPendingExternalModels() && t.push(s);
    }
  };
  return await yi.walk(i, n, ft.None), t;
}
class Zy {
  constructor() {
    this._currentTime = 0, this._stopTime = 0;
  }
  stop() {
    this._stopTime = this._currentTime;
  }
  isTicking() {
    return this._refreshCurrentTime(), this._remainingDuration() > 0;
  }
  tickFor(t) {
    this._refreshCurrentTime(), !(this._remainingDuration() >= t) && (this._stopTime = this._currentTime + t);
  }
  _remainingDuration() {
    return this._stopTime - this._currentTime;
  }
  _refreshCurrentTime() {
    this._currentTime = Date.now();
  }
}
const Cy = 4294967296;
class ky {
  constructor() {
    this.prototypes = /* @__PURE__ */ new Map(), this.partDefinitions = /* @__PURE__ */ new Map();
  }
}
class My {
  constructor() {
    this.bodies = /* @__PURE__ */ new Map(), this.contexts = [];
  }
}
class Wy {
  constructor(t, e, i, s, r, o) {
    this._centralQueueClock = new Zy(), this._productOccurrences = /* @__PURE__ */ new Map(), this._pmis = /* @__PURE__ */ new Map(), this._cadViews = /* @__PURE__ */ new Map(), this._bodyInstances = /* @__PURE__ */ new Map(), this._pmiBodies = /* @__PURE__ */ new Map(), this._viewFrames = /* @__PURE__ */ new Map(), this._partDefinitions = /* @__PURE__ */ new Map(), this._representationItems = /* @__PURE__ */ new Map(), this._partToInstance = /* @__PURE__ */ new Map(), this._filters = [], this._layers = /* @__PURE__ */ new Map(), this._layersIds = /* @__PURE__ */ new Map(), this._nextLayerId = 0, this._genericTypeToNodes = /* @__PURE__ */ new Map(), this._genericIdToNodes = /* @__PURE__ */ new Map(), this._cadConfigurations = /* @__PURE__ */ new Set(), this._modelContents = /* @__PURE__ */ new Map(), this._inclusionContents = /* @__PURE__ */ new Map(), this._nodeDeletionBlackList = /* @__PURE__ */ new Set(), this._meshDeletionBlackList = /* @__PURE__ */ new Set(), this._dynamicNodeIdSeed = en, this._currentNodeIdOffset = 0, this._initialEmptyNodeIdOffsetObtained = !1, this._activeCadView = null, this._activeCadConfiguration = null, this._defaultCadConfiguration = null, this._defaultCadViewsByConfiguration = /* @__PURE__ */ new Map(), this._firstProductOccurrenceWithView = null, this._containsDrawings = !1, this._isMeasurable = !1, this._automaticMeasurementUnitScaling = !0, this._initiallyHiddenStayHidden = !0, this._nextLoadId = 0, this._activeLoadIds = /* @__PURE__ */ new Set(), this._requestedNodes = /* @__PURE__ */ new Map(), this._unnamedProductCount = 0, this._unnamedGroupCount = 0, this._unnamedDrawingSheetCount = 0, this._unnamedDrawingViewCount = 0, this._isInitialized = !1, this._seenExternalModel = !1, this._config = { ...t }, this._engine = e, this._callbackManager = i, this._cuttingManager = s, this._view = r, this._model = o, this._isScs = this._engine.getSessionType() === Oe.Scs, console.assert(!this._isScs || this._engine.getRendererType() === qo.Client);
  }
  initialize(t) {
    console.assert(this._rootLoadContext === void 0), console.assert(this._rootNode === void 0), console.assert(!this._isInitialized), this._isInitialized = !0, console.assert(this._centralQueue === void 0), this._centralQueue = new Ns(t.maxConcurrentAttachments(), !1), this._callbackManager.bind({
      _inputInteraction: (s, r) => {
        this._onUserInteraction(s, r);
      }
    }), this._rootLoadContext = new on(null, or, null);
    const e = new hi(
      new Wr(),
      lr.OfInitialEmptyModel,
      !1,
      Hn.Local,
      this._rootLoadContext
    );
    this._rootLoadContext.addAttachContext(e);
    const i = new xi(
      this,
      e,
      ve.Local,
      Ji.Local
    );
    e.addInclusionContext(i), this._rootNode = Yt.createDynamic(
      this,
      i,
      "Models",
      null,
      null,
      !0
    ), i.addProductOccurrence(this._rootNode), console.assert(this._rootNode.isAbsoluteRoot()), this.preventNodeDeletion(this._rootLoadContext), this.preventNodeDeletion(e), this.preventNodeDeletion(i), this.preventNodeDeletion(this._rootNode), this._rootNode.markLoaded();
  }
  isInitialized() {
    return this._isInitialized;
  }
  getRootNode() {
    return this._rootNode;
  }
  getAbstractScEngine() {
    return this._engine;
  }
  generateDynamicNodeId() {
    return --this._dynamicNodeIdSeed;
  }
  newNodeIdOffset() {
    if (!this._initialEmptyNodeIdOffsetObtained)
      return this._initialEmptyNodeIdOffsetObtained = !0, console.assert(this._currentNodeIdOffset === 0), 0;
    const t = this._currentNodeIdOffset;
    return this._currentNodeIdOffset += Cy, t;
  }
  /**
   * Please don't use me. This was kept for legacy reasons with Erwan's tree, which
   * had fundamental design problems with NodeIds (because they could conflict).
   */
  getLowestAvailableNodeId() {
    return this._currentNodeIdOffset;
  }
  tryParseHeader(t) {
    const e = _n.parseBinary(t);
    return e === null ? null : (this._containsDrawings = this._containsDrawings || e.isDrawing, this._isMeasurable = this._isMeasurable || e.isMeasurable, this._callbackManager.promiseTrigger("_modelStructureHeaderParsed", null, e).then(() => (this._callbackManager.trigger(
      "modelStructureHeaderParsed",
      e.originalFileName,
      e.originalFileType
    ), e)));
  }
  _isRegistered(t) {
    return this._productOccurrences.has(t) || this._pmis.has(t) || this._cadViews.has(t) || this._bodyInstances.has(t) || this._pmiBodies.has(t) || this._viewFrames.has(t) || this._partDefinitions.has(t) || this._representationItems.has(t);
  }
  registerProductOccurrence(t) {
    if (!t.isMissing()) {
      const e = t.getRuntimeId();
      console.assert(!this._isRegistered(e)), this._productOccurrences.set(e, t);
      const i = Qo(t);
      i !== null && this.registerGenericType(t, i);
      const s = t.getGenericId();
      s !== null && this.registerGenericGlobalId(t, s), t.isAConfigurationNode() && this._registerCadConfiguration(t), (t.isADrawingSheetNode() || t.isADrawingViewNode()) && (this._containsDrawings = !0);
    }
  }
  lookupProductOccurrence(t) {
    const e = this._productOccurrences.get(t);
    return e !== void 0 ? e : null;
  }
  registerPmi(t) {
    const e = t.getRuntimeId();
    console.assert(!this._isRegistered(e)), this._pmis.set(e, t);
  }
  lookupPmi(t) {
    const e = this._pmis.get(t);
    return e !== void 0 ? e : null;
  }
  registerCadView(t) {
    this._firstProductOccurrenceWithView === null && (this._firstProductOccurrenceWithView = t.getParent());
    const e = t.getRuntimeId();
    console.assert(!this._isRegistered(e)), this._cadViews.set(e, t), t.isDefaultView() && this._defaultCadViewsByConfiguration.set(this._firstProductOccurrenceWithView, t);
  }
  getFirstProductOccurrenceWithView() {
    return this._firstProductOccurrenceWithView;
  }
  lookupCadView(t) {
    const e = this._cadViews.get(t);
    return e !== void 0 ? e : null;
  }
  registerBodyInstance(t, e) {
    const i = t.getRuntimeId();
    console.assert(!this._isRegistered(i)), this._bodyInstances.set(i, t), this._registerAnyBodyByInstanceInc(t, e);
  }
  lookupBodyInstance(t) {
    const e = this._bodyInstances.get(t);
    return e !== void 0 ? e : null;
  }
  registerPmiBody(t, e) {
    const i = t.getRuntimeId();
    console.assert(!this._isRegistered(i)), this._pmiBodies.set(i, t), this._registerAnyBodyByInstanceInc(t, e);
  }
  lookupPmiBody(t) {
    const e = this._pmiBodies.get(t);
    return e !== void 0 ? e : null;
  }
  registerViewFrame(t, e) {
    const i = t.getRuntimeId();
    console.assert(!this._isRegistered(i)), this._viewFrames.set(i, t), this._registerAnyBodyByInstanceInc(t, e);
  }
  lookupViewFrame(t) {
    const e = this._viewFrames.get(t);
    return e !== void 0 ? e : null;
  }
  registerPartDefinition(t) {
    if (!t.isMissing()) {
      const e = t.getRuntimeId();
      console.assert(!this._isRegistered(e)), this._partDefinitions.set(e, t);
    }
  }
  lookupPartDefinition(t) {
    const e = this._partDefinitions.get(t);
    return e !== void 0 ? e : null;
  }
  registerRepresentationItem(t) {
    const e = t.getRuntimeId();
    console.assert(!this._isRegistered(e)), this._representationItems.set(e, t);
  }
  lookupRepresentationItem(t) {
    const e = this._representationItems.get(t);
    return e !== void 0 ? e : null;
  }
  lookupAnyBody(t) {
    return this.lookupBodyInstance(t) || this.lookupPmiBody(t) || this.lookupViewFrame(t);
  }
  lookupAnyTreeNode(t) {
    return this.lookupProductOccurrence(t) || this.lookupPmi(t) || this.lookupCadView(t) || this.lookupAnyBody(t);
  }
  lookupAnyNonTreeNode(t) {
    return this.lookupRepresentationItem(t) || this.lookupPartDefinition(t);
  }
  lookupAnyNode(t) {
    return this.lookupAnyTreeNode(t) || this.lookupAnyNonTreeNode(t);
  }
  _registerCadConfiguration(t) {
    console.assert(t.isAConfigurationNode()), console.assert(!this._cadConfigurations.has(t)), this._cadConfigurations.add(t), t.isADefaultNode() && this._defaultCadConfiguration === null && (this._defaultCadConfiguration = t);
  }
  getInstanceCountByInclusion(t) {
    return this._getInclusionContent(t).bodies.size;
  }
  lookupAnyBodyByInstanceInc(t, e) {
    const s = this._getInclusionContent(t).bodies.get(e);
    return s !== void 0 ? s : null;
  }
  _registerAnyBodyByInstanceInc(t, e) {
    const i = t.getInstanceInc(), s = this._getInclusionContent(e), r = s.bodies.get(i[1]);
    if (r !== void 0)
      if (console.assert(t.hasAuthoredId()), r.hasAuthoredId()) {
        console.assert(r.constructor === t.constructor);
        return;
      } else {
        const o = r;
        console.assert(o.constructor === Ge);
        const a = o.getRuntimeId();
        o.getParent().removeBodyInstance(o), t instanceof Ge ? this._bodyInstances.set(a, t) : t instanceof In ? this._pmiBodies.set(a, t) : this._viewFrames.set(a, t);
      }
    s.bodies.set(i[1], t);
  }
  _getInclusionContent(t) {
    console.assert(t !== ve.Invalid);
    let e = this._inclusionContents.get(t);
    return e === void 0 && (e = new My(), this._inclusionContents.set(t, e)), e;
  }
  _getModelContent(t, e) {
    console.assert(e !== Ji.Invalid);
    let i = this._modelContents.get(t);
    i === void 0 && (i = /* @__PURE__ */ new Map(), this._modelContents.set(t, i));
    let s = i.get(e);
    return s === void 0 && (s = new ky(), i.set(e, s)), s;
  }
  registerPrototypeByDataId(t, e, i, s) {
    const r = this._getModelContent(t, e);
    console.assert(!r.prototypes.has(i)), r.prototypes.set(i, s);
  }
  registerPartDefinitionByDataId(t, e, i, s) {
    const r = this._getModelContent(t, e);
    console.assert(!r.partDefinitions.has(i)), r.partDefinitions.set(i, s);
  }
  lookupPrototypeByDataId(t, e, i) {
    const r = this._getModelContent(t, e).prototypes.get(i);
    return r !== void 0 ? r : null;
  }
  lookupPartDefinitionByDataId(t, e, i) {
    const r = this._getModelContent(t, e).partDefinitions.get(i);
    return r !== void 0 ? r : null;
  }
  registerInclusionContext(t) {
    const e = t.getInclusionKey();
    this._getInclusionContent(e).contexts.push(t);
  }
  getInclusionContexts(t) {
    return this._getInclusionContent(t).contexts;
  }
  _createLayer(t, e, i, s) {
    const r = new Ys(t, e, i, s);
    return console.assert(!this._layers.has(t)), this._layers.set(t, r), e !== null && this._updateNameToLayersMap(e, t), r;
  }
  _updateNameToLayersMap(t, e) {
    const i = this._layersIds.get(t);
    i !== void 0 ? i.push(e) : this._layersIds.set(t, [e]);
  }
  /**
   * Creates a new layer in the assembly tree. Also creates a mapping in the supplied assembly tree from
   * the authored layer id to the effective, runtime, id.
   * @param authoredLayerId The authored ID of the layer. Used to create the mapping in the assembly tree
   * @param layerName Name of the layer
   * @param loadContext Attach context of the node creating the layer. A layer mapping will be created in it
   */
  createLayer(t, e, i) {
    const s = this._nextLayerId++, r = this._createLayer(s, e, [], []);
    return i.addLayerIdToMap(s, t), r;
  }
  /**
   * Changes the name of an existing layer.
   * @param layerId Layer id to update
   * @param layerName Name to be set
   */
  updateLayerName(t, e) {
    const i = this._layers.get(t);
    i !== void 0 && (i.name = e, this._updateNameToLayersMap(e, t));
  }
  _registerNodeInLayer(t, e, i) {
    const s = gn(t);
    let r = s.getRuntimeLayerId(e);
    e === Ys.NoLayerId && r === null ? r = this.createLayer(Ys.NoLayerId, "No layer", s).id : r === null && (r = this._nextLayerId++, this._createLayer(r, null, [t], []), s.addLayerIdToMap(r, e));
    const o = this._layers.get(r);
    o !== void 0 ? i(o).push(t) : (console.assert(!1, "Layer has mapping in LoadContext but not represented in AssemblyTree"), this._createLayer(r, null, [t], []), s.addLayerIdToMap(r, e));
  }
  /**
   * Registers a node as part of a layer. This will create a layer if one doesn't exist.
   * @param node Node to be registered
   * @param authoredLayerId Authored id of the Layer
   */
  registerNodeInLayer(t, e) {
    return this._registerNodeInLayer(t, e, (i) => i.nodes);
  }
  /**
   * Registers a tree node as part of a layer. This will create a layer if one doesn't exist.
   * @param node Node to be registered
   * @param authoredLayerId Authored id of the Layer
   */
  registerTreeNodeInLayer(t, e) {
    return this._registerNodeInLayer(t, e, (i) => i.treeNodes);
  }
  addFilter(t, e) {
    this._filters.push({ filter: t, loadContext: e });
  }
  getFilters() {
    const t = /* @__PURE__ */ new Map();
    for (let e = 0; e < this._filters.length; e++) {
      const i = this.getFilterName(e) || "";
      t.set(e, i);
    }
    return t;
  }
  getFilterName(t) {
    if (t < this._filters.length) {
      const { filter: e } = this._filters[t];
      return e.name || "";
    }
    return null;
  }
  getFiltersWithNode(t) {
    const e = t.getAuthoredId(), i = this._filters, s = [];
    for (let r = 0; r < i.length; r++) {
      const { filter: o, loadContext: a } = i[r];
      if (o.layers !== null)
        for (const l of o.layers.authoredIds) {
          const c = a.getRuntimeLayerId(l);
          if (c === null)
            continue;
          const h = this.getNodesFromLayer(c);
          if (h !== null)
            for (const u of h)
              t === u && s.push(r);
        }
      if (o.entities !== null)
        for (const l of o.entities.ids)
          e === l && s.push(r);
    }
    return s;
  }
  getNodesFromFilterIds(t) {
    const e = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set();
    let s = null;
    for (const r of t) {
      const { filter: o, loadContext: a } = this._filters[r], l = o.layers;
      if (l !== null) {
        const h = l.isInclusive;
        s === null && (s = h);
        for (const u of l.authoredIds) {
          const p = a.getRuntimeLayerId(u);
          if (p === null)
            continue;
          const m = this._layers.get(p);
          if (m && m.nodes !== null)
            for (const g of m.nodes) {
              const _ = g.getRuntimeId();
              h ? (e.add(_), i.delete(_)) : (e.delete(_), i.add(_));
            }
        }
      }
      const c = o.entities;
      if (c !== null) {
        const h = c.isInclusive;
        s === null && (s = h);
        for (const u of c.ids)
          h ? (e.add(u), i.delete(u)) : (e.delete(u), i.add(u));
      }
    }
    return s === null ? null : s ? new pu(!0, e) : new pu(!1, i);
  }
  getLayers() {
    const t = /* @__PURE__ */ new Map();
    return this._layers.forEach((e, i) => {
      const s = e.name || "";
      t.set(i, s);
    }), t;
  }
  getUniqueLayerNames() {
    const t = /* @__PURE__ */ new Set(), e = [];
    return this._layers.forEach((i) => {
      const s = i.name;
      s !== null && (t.has(s) || (t.add(s), e.push(s)));
    }), e;
  }
  getLayerName(t) {
    const e = this._layers.get(t);
    return e !== void 0 ? e.name || "" : null;
  }
  getLayersIdFromName(t) {
    const e = this._layersIds.get(t);
    return e !== void 0 ? e : null;
  }
  getNodesFromLayer(t, e) {
    const i = this._layers.get(t);
    return i !== void 0 ? e ? i.treeNodes : i.nodes : null;
  }
  getNodesFromLayers(t, e) {
    const i = [];
    for (const s of t) {
      const r = this.getNodesFromLayer(s, e);
      if (r !== null)
        for (const o of r)
          i.push(o);
    }
    return i;
  }
  getNodesFromLayerName(t, e) {
    const i = this._layersIds.get(t);
    return i !== void 0 ? this.getNodesFromLayers(i, e) : null;
  }
  generateProductName() {
    return `Product ${this._unnamedProductCount++}`;
  }
  generateGroupName() {
    return `Product ${this._unnamedGroupCount++}`;
  }
  generateDrawingSheetName() {
    return `Product ${this._unnamedDrawingSheetCount++}`;
  }
  generateDrawingViewName() {
    return `Product ${this._unnamedDrawingViewCount++}`;
  }
  forEachCadView(t) {
    this._cadViews.forEach(t);
  }
  forEachPmi(t) {
    this._pmis.forEach(t);
  }
  forEachCadConfiguration(t) {
    this._cadConfigurations.forEach(t);
  }
  hasActiveCadView() {
    return this._activeCadView !== null;
  }
  activateCadView(t, e, i) {
    return console.assert(this._activeCadView === null), this._activeCadView = t, t.activate(
      this,
      this._engine,
      this._callbackManager,
      this._cuttingManager,
      this._view,
      e,
      i,
      this._activeCadConfiguration
    );
  }
  async deactivateActiveCadView() {
    this._activeCadView !== null && (await this._activeCadView.deactivate(this._cuttingManager), console.assert(this._activeCadView !== null), this._activeCadView = null);
  }
  getDefaultCadView(t) {
    let e;
    return t === null ? this._defaultCadViewsByConfiguration.size === 1 && (e = this._defaultCadViewsByConfiguration.values().next().value) : e = this._defaultCadViewsByConfiguration.get(t), e !== void 0 ? e : null;
  }
  getCadViewPmis(t) {
    const e = [];
    return this._pmis.forEach((i) => {
      t.hasPmi(i) && e.push(i);
    }), e;
  }
  isMeasurable() {
    return this._isMeasurable;
  }
  containsDrawings() {
    return this._containsDrawings;
  }
  getCadConfigurations() {
    const t = [];
    return this._cadConfigurations.forEach((e) => {
      t.push(e);
    }), t;
  }
  getDefaultCadConfiguration() {
    return this._defaultCadConfiguration;
  }
  getActiveCadConfiguration() {
    return this._activeCadConfiguration;
  }
  activateCadConfiguration(t) {
    console.assert(t.isAConfigurationNode()), this._activeCadConfiguration = t;
  }
  massageAuthoredUserId(t, e) {
    if (e === null)
      return this.generateDynamicNodeId();
    {
      const i = t.toRuntimeId(e);
      return this.lookupAnyNode(i) !== null ? this.generateDynamicNodeId() : e;
    }
  }
  createNode(t, e, i, s, r, o = null) {
    const a = Yt.createDynamic(
      this,
      t,
      e,
      i,
      s,
      r,
      !1,
      o
    );
    return t.addProductOccurrence(a), a.markLoaded(), a;
  }
  createPart(t) {
    const e = Ei.createDynamic(this, t, null);
    return e.markLoaded(), e;
  }
  setPart(t, e) {
    e.addReferrer(t);
    let i = this._partToInstance.get(e);
    if (i === void 0) {
      const s = Ne(this._rootNode), r = () => {
        const a = {}, l = Ws.create(() => (console.assert(a.node !== void 0), new bh(Si.create(a.node))));
        return a.instance = new Yr(l, s), a.node = Yt.createDynamic(
          this,
          a.instance,
          null,
          null,
          null,
          !0
        ), a.node.setPartDefinition(e), a.node.markLoaded(), a;
      }, { instance: o } = r();
      i = o;
    }
    t.setPrototype(i);
  }
  _createCadView(t, e, i, s, r, o, a, l) {
    const c = Ri.createDynamic(
      this,
      t,
      e,
      i,
      s,
      r,
      o,
      a,
      l
    );
    return t.addCadView(c), c.markLoaded(), c;
  }
  async _createCadViewInstance(t, e, i) {
    if (i !== null) {
      const [s, r] = await t.createMeshInstance(i), l = {
        nodeInfo: {
          nodeId: this.generateDynamicNodeId(),
          bits: We.IsShownSpecified | We.IsShown,
          name: null,
          localTransform: null,
          attributes: [],
          header: _n.dynamic,
          exchangeId: null,
          layerId: null,
          genericTypeId: null,
          genericId: null,
          userDatas: null
        },
        inclusionKey: s,
        instanceKey: r,
        bits: 0
      }, h = ke(e).getMasterModelKey();
      console.assert(e.isLoaded());
      const u = ms.reify(this, h, e, l);
      e.setViewFrame(u), u.markLoaded();
    }
  }
  createCadView(t, e, i, s, r, o, a, l, c, h) {
    const u = this._createCadView(
      e,
      i,
      s,
      r,
      o,
      a,
      l,
      c
    );
    return h !== null && this._createCadViewInstance(t, u, h), u;
  }
  createMeshInstance(t, e, i, s, r, o, a, l, c, h) {
    let u = 0;
    c && (u |= We.InitiallyShown);
    let p = 0;
    a && (p |= zn.PreventFromResetting), l && (p |= zn.OutOfHierarchy), h && (p |= zn.ImplicitBody);
    const m = Ge.createDynamic(
      this,
      e,
      i,
      s,
      r,
      o,
      u,
      p
    );
    return o.addBodyInstance(m), t && m.markLoaded(), m;
  }
  createPmiInstance(t, e, i, s, r, o, a, l) {
    const c = Ne(r), p = {
      nodeInfo: {
        nodeId: this.massageAuthoredUserId(c, i),
        bits: We.InitiallyShown,
        name: s,
        localTransform: null,
        attributes: [],
        header: _n.dynamic,
        exchangeId: null,
        layerId: null,
        genericTypeId: null,
        genericId: null,
        userDatas: null
      },
      inclusionKey: t,
      instanceKey: e,
      bits: 0
    }, m = gi.createDynamic(
      this,
      c,
      r,
      s,
      o,
      a,
      [p],
      l
    );
    return r.addPmi(m), m.markLoaded(), m;
  }
  getRelationshipsOfItem(t, e) {
    const i = /* @__PURE__ */ new Map();
    let s = [];
    const r = this.lookupAnyTreeNode(t);
    if (r === null)
      return i;
    s = Ne(r).getRelationships();
    for (const a of s)
      if (a.relating !== null && a.relating.relationElt.id === e)
        er.addFromRelatingElt(a, i);
      else {
        const l = a.related;
        let c = -1;
        l !== null && (c = er.findIndexInRelated(e, l.relationships)), c >= 0 && er.addFromRelatedElt(a, i);
      }
    return i;
  }
  getAutomaticMeasurementUnitScaling() {
    return this._automaticMeasurementUnitScaling;
  }
  setAutomaticMeasurementUnitScaling(t) {
    this._automaticMeasurementUnitScaling = t;
  }
  getInitiallyHiddenStayHidden() {
    return this._initiallyHiddenStayHidden;
  }
  setInitiallyHiddenStayHidden(t) {
    this._initiallyHiddenStayHidden = t;
  }
  async _removeIdMappingsRecursive(t) {
    const e = (l) => {
      const c = l.getGenericId();
      if (c !== null) {
        const u = this._genericIdToNodes.get(c);
        u !== void 0 && u.delete(l);
      }
      const h = Qo(l);
      if (h !== null) {
        const u = this._genericTypeToNodes.get(h);
        u !== void 0 && u.delete(l);
      }
    }, i = (l) => {
      const c = /* @__PURE__ */ new Map();
      for (const h of l) {
        const u = h.getAuthoredLayerId();
        if (u === null)
          continue;
        const m = gn(h).getRuntimeLayerId(u);
        if (m === null)
          continue;
        const g = c.get(m);
        g === void 0 ? c.set(m, [h]) : g.push(h);
      }
      c.forEach((h, u) => {
        const p = this._layers.get(u);
        p.nodes = p.nodes.filter((m) => h.indexOf(m) === -1), p.treeNodes = p.treeNodes.filter(
          (m) => h.indexOf(m) === -1
        );
      });
    }, s = (l) => {
      const c = /* @__PURE__ */ new Set();
      l.forEach((h) => {
        const u = h.getInstanceInc();
        c.add(u[0]);
      }), c.forEach((h) => {
        const u = this._inclusionContents.get(h);
        if (u !== void 0)
          for (const p of l) {
            const m = p.getInstanceInc();
            m[0] === h && u.bodies.delete(m[1]);
          }
      });
    }, r = [], o = [], a = {
      enterProductOccurrence: (l) => {
        e(l), this._productOccurrences.delete(l.getRuntimeId()), r.push(l);
      },
      enterAnyBody: (l) => {
        e(l);
        const c = l.getRuntimeId();
        l instanceof Ge ? this._bodyInstances.delete(c) : l instanceof In ? this._pmiBodies.delete(c) : this._viewFrames.delete(c), r.push(l), o.push(l);
      },
      enterCadView: (l) => {
        this._cadViews.delete(l.getRuntimeId());
      },
      enterPmi: (l) => {
        this._pmis.delete(l.getRuntimeId());
      }
    };
    await yi.walk(a, t, ft.None), i(r), s(o);
  }
  async deleteNode(t) {
    if (!this._canDeleteNode(t)) {
      const i = t.getRuntimeId();
      throw new Mt(`Cannot delete node (${i})`);
    }
    const e = zo(
      t,
      bt.All,
      !0,
      /* @__PURE__ */ new Set(),
      ft.None
    );
    if (this._engine.setPartVisibility(e, !1, !1), this._engine.setInstanceModifier(Fe.DoNotSelect, e, !0), t instanceof Yt) {
      this._cadConfigurations.delete(t) && (t === this._activeCadConfiguration && (this._activeCadConfiguration = null), t === this._defaultCadConfiguration && (this._defaultCadConfiguration = null));
      const i = t.getParent(), s = gn(i);
      if (console.assert(i !== null), i !== null) {
        let r;
        if (i instanceof Yr)
          r = i.removeReferrer(t);
        else if (i instanceof xi && i.getChildren().length === 1) {
          const o = i.getInclusionKey();
          this._inclusionContents.delete(o);
          const a = i.getModelKey(), l = this._modelContents.get(s);
          l !== void 0 && (l.delete(a), l.size === 0 && this._modelContents.delete(s)), r = i.removeProductOccurrence(t);
        } else
          r = i.removeProductOccurrence(t);
        console.assert(r);
      }
      return this._productOccurrences.delete(t.getRuntimeId()), await this._removeIdMappingsRecursive(t), s.getChildren().length === 0 ? s.purgeContents() : t.purgeContents();
    } else if (t instanceof gi)
      t.getParent().removePmi(t), this._pmis.delete(t.getRuntimeId());
    else {
      t.getParent().removeBodyInstance(t);
      const s = t.getInstanceInc();
      this._getInclusionContent(s[0]).bodies.delete(s[1]), this._bodyInstances.delete(t.getRuntimeId());
    }
  }
  _canDeleteNode(t) {
    return !this._nodeDeletionBlackList.has(t);
  }
  allowNodeDeletion(t) {
    this._nodeDeletionBlackList.delete(t);
  }
  preventNodeDeletion(t) {
    const e = t.getParent();
    if (e instanceof Yr)
      throw new re();
    if (e !== null) {
      if (console.assert(e === null || this._nodeDeletionBlackList.has(e)), t instanceof Yt)
        console.assert(!t.hasAuthoredId()), console.assert(!t.isOutOfHierarchy());
      else if (t instanceof Ge) {
        const i = t.getInstanceInc();
        console.assert(!t.hasAuthoredId()), console.assert(i[0] === ve.Local), console.assert(t.isOutOfHierarchy());
      }
    }
    this._nodeDeletionBlackList.add(t);
  }
  preventMeshDeletion(t) {
    this._meshDeletionBlackList.add(t);
  }
  async _resetContents() {
    if (this.hasActiveCadView())
      return await this.deactivateActiveCadView(), this._resetContents();
    await this._rootLoadContext.purgeContents(), this._productOccurrences.clear(), this._pmis.clear(), this._cadViews.clear(), this._bodyInstances.clear(), this._pmiBodies.clear(), this._viewFrames.clear(), this._partDefinitions.clear(), this._representationItems.clear(), this._partToInstance.clear(), this._filters.length = 0, this._layers.clear(), this._layersIds.clear(), this._genericTypeToNodes.clear(), this._genericIdToNodes.clear(), this._cadConfigurations.clear(), this._modelContents.clear(), this._inclusionContents.clear(), this._currentNodeIdOffset = 0, this._activeCadView = null, this._activeCadConfiguration = null, this._defaultCadConfiguration = null, this._firstProductOccurrenceWithView = null, this._containsDrawings = !1, this._isMeasurable = !1, this._requestedNodes.clear(), this._unnamedProductCount = 0, this._unnamedGroupCount = 0, this._unnamedDrawingSheetCount = 0, this._unnamedDrawingViewCount = 0, this._seenExternalModel = !1, this._rootNode.unsetMeasurementUnit(), this._nodeDeletionBlackList.forEach((t) => {
      if (t instanceof Yt) {
        const e = t.getRuntimeId();
        this._productOccurrences.set(e, t);
        const i = t.getParent();
        i instanceof Yr ? console.assert(!1) : i.addProductOccurrence(t), t.setVisibility(!0), t.unsetMeasurementUnit(), t.hasLocalTransformOverride() && t.removeLocalTransformOverride();
      } else if (t instanceof Ge) {
        const e = t.getRuntimeId();
        this._bodyInstances.set(e, t);
        const i = t.getInstanceInc(), s = i[0];
        console.assert(s === ve.Local), this._getInclusionContent(s).bodies.set(i[1], t), t.getParent().addBodyInstance(t);
      } else if (t instanceof gi) {
        const e = t.getRuntimeId();
        this._pmis.set(e, t), t.getParent().addPmi(t);
      } else if (t instanceof on) {
        const e = t.getParent();
        e !== null && e.addLoadContext(t);
      } else if (t instanceof hi) {
        const e = t.getParent();
        e instanceof Yt, e.addAttachContext(t);
      } else {
        const e = t.getInclusionKey();
        console.assert(e === ve.Local), this._getInclusionContent(e).contexts.push(t), t.getParent().addInclusionContext(t);
      }
    });
  }
  async reset() {
    await this._callbackManager.promiseTrigger("_resetAssemblyTreeBegin", null), await this._resetContents();
    const t = [];
    this._nodeDeletionBlackList.forEach((i) => {
      if (i instanceof Ge) {
        const s = i.getInstanceInc();
        console.assert(s[0] === ve.Local), t.push(s[1]);
      }
    });
    const e = [];
    this._meshDeletionBlackList.forEach((i) => {
      e.push(i);
    }), await this._engine.resetToEmpty(t, e), await this._resetContents();
  }
  setViewAxes(t, e) {
    this._model.setViewAxes(t, e);
  }
  async _requestIncsOfNodes(t) {
    if (this._config.streamingMode !== Ps.OnDemand)
      return;
    const e = /* @__PURE__ */ new Set(), i = [], s = [];
    for (const a of t) {
      const l = Fd(a, bt.All, !1, e).then((c) => {
        for (const h of c)
          i.push(h);
      });
      s.push(l);
    }
    await zt(s);
    const r = [], o = [];
    e.forEach((a) => {
      if (!a.isRequested()) {
        a.setRequested();
        const l = a.isInitiallyShown();
        l !== a.isVisible() && (l ? (a.setVisibility(!0), r.push(a.getRuntimeId())) : (a.setVisibility(!1), o.push(a.getRuntimeId())));
      }
    }), r.length + o.length > 0 && this._callbackManager.trigger("visibilityChanged", r, o), this._engine.requestMeshInstances(i);
  }
  async _requestExternalModelsLocal(t, e, i) {
    const s = await e.loadPendingExternalModels(t);
    return s.length !== 0 && (await ir(s), await this._requestNodes(t, [e], i)), s;
  }
  async _requestExternalModelsNonLocal(t, e, i) {
    const s = await xy(e);
    if (s.length === 0)
      return [];
    const r = [];
    for (const a of s) {
      const l = this._requestExternalModelsLocal(t, a, i);
      r.push(l);
    }
    return (await Promise.all(r)).flat();
  }
  async _requestExternalModelsOfNodes(t, e, i) {
    const s = [];
    for (const o of e) {
      const a = this._requestExternalModelsNonLocal(t, o, i);
      s.push(a);
    }
    return (await Promise.all(s)).flat();
  }
  async _requestNodes(t, e, i) {
    if (!i) {
      const l = this._activeLoadIds.size !== 0, c = [];
      l && this._activeLoadIds.forEach((h) => {
        c.push(h);
      });
      for (const h of e)
        l && this._requestedNodes.set(h, c), h instanceof Yt && t.notifyDirectRequest(h);
    }
    const s = this._requestIncsOfNodes(e), r = this._requestExternalModelsOfNodes(
      t,
      e,
      i
    ), o = [s, r];
    return (await Promise.all(o))[1];
  }
  async requestNodes(t, e, i) {
    const s = await this._requestNodes(t, e, i), r = [];
    for (const o of s) {
      const a = o.getChildren();
      r.push(...a);
    }
    if (r.length > 0) {
      const o = r.map((a) => a.getRuntimeId());
      await this._callbackManager.promiseTrigger(
        "_subtreeLoaded",
        "subtreeLoaded",
        o,
        ps.LoadModel
      );
    }
  }
  isBeingRequested(t) {
    let e = t;
    const i = !1;
    do
      if (e instanceof Pi) {
        if (this._requestedNodes.has(e))
          return !0;
        e = e.getParent();
      } else if (e instanceof hi)
        e = e.getParent();
      else if (e instanceof xi)
        e = e.getParent();
      else if (e instanceof on) {
        const s = e.getParent();
        if (s === null)
          return !1;
        e = s;
      } else
        return console.assert(!1), !1;
    while (!i);
    return !1;
  }
  onDemandRequestsActive() {
    return this._requestedNodes.size !== 0;
  }
  onLoadBegin() {
    const t = this._nextLoadId++;
    return this._activeLoadIds.add(t), t;
  }
  onLoadEnd(t) {
    this._activeLoadIds.delete(t);
    const e = [];
    this._requestedNodes.forEach((i, s) => {
      let r = !0;
      for (const o of i)
        if (this._activeLoadIds.has(o)) {
          r = !1;
          break;
        }
      r && e.push(s);
    });
    for (const i of e)
      this._requestedNodes.delete(i);
  }
  markSeenExternalModel() {
    this._seenExternalModel = !0;
  }
  seenExternalModel() {
    return this._seenExternalModel;
  }
  getNodesByGenericId(t) {
    return this._genericIdToNodes.get(t) || null;
  }
  getNodesByGenericType(t) {
    return this._genericTypeToNodes.get(t) || null;
  }
  genericTypeToNodes() {
    return this._genericTypeToNodes;
  }
  registerGenericGlobalId(t, e) {
    let i = this._genericIdToNodes.get(e);
    i === void 0 && (i = /* @__PURE__ */ new Set()), i.add(t), this._genericIdToNodes.set(e, i);
  }
  registerGenericType(t, e) {
    let i = this._genericTypeToNodes.get(e);
    i === void 0 && (i = /* @__PURE__ */ new Set()), i.add(t), this._genericTypeToNodes.set(e, i);
  }
  disableAutomaticFitWorld() {
    return this._config.disableAutomaticFitWorld;
  }
  markImplicitNodesOutOfHierarchy() {
    return this._config.markImplicitNodesOutOfHierarchy;
  }
  async _throttleLoad() {
    this._engine.throttleLoad(200, 200), await this._engine.sleep(20);
  }
  /**
   * Enqueues an action that can be throttled by user interactions.
   */
  enqueue(t) {
    const e = typeof t == "function" ? ji.create(t) : t;
    return this._centralQueue.push(async () => {
      const i = this._isScs && this._centralQueueClock.isTicking();
      i && await this._throttleLoad();
      const s = await e.get();
      return i && await this._throttleLoad(), s;
    });
  }
  _onUserInteraction(t, e) {
    if (!this._isScs)
      return;
    let i = !1;
    switch (e) {
      case kt.MouseDown:
      case kt.MouseUp:
      case kt.Mousewheel:
      case kt.TouchStart:
      case kt.TouchMove:
      case kt.TouchEnd:
      case kt.KeyDown:
      case kt.KeyUp:
      case kt.ViewOrientationChange:
        i = !0;
        break;
      case kt.MouseMove:
        i = t.getButtons() !== Ai.None;
        break;
      default:
        $n();
    }
    i && this._centralQueueClock.tickFor(1e3);
  }
}
class bu {
  constructor(t, e) {
    this._inclusionsOf = /* @__PURE__ */ new Map(), this._masterModelKey = Hn.Invalid, this._prototypeInstanceCount = -1, this._attachScope = t, this._attachedInvisibly = e;
  }
  getAttachScope() {
    return this._attachScope;
  }
  getMasterModelKey() {
    return console.assert(this._masterModelKey !== Hn.Invalid), this._masterModelKey;
  }
  getModelKeys() {
    const t = [];
    return this._inclusionsOf.forEach((e, i) => {
      t.push(i);
    }), t;
  }
  hasInclusions() {
    return this._inclusionsOf.size > 0;
  }
  getAllInclusions() {
    const t = [];
    return this._inclusionsOf.forEach((e, i) => {
      for (const s of e)
        t.push(s, i);
    }), t;
  }
  getInclusionsOf(t) {
    t = t;
    const e = this._inclusionsOf.get(t);
    if (e === void 0)
      return [];
    const i = [];
    for (const s of e)
      i.push(s, t);
    return i;
  }
  hasModelIncluded(t) {
    return this._inclusionsOf.has(t);
  }
  attachedInvisibly() {
    return this._attachedInvisibly;
  }
  prototypeInstanceCount() {
    return console.assert(this._prototypeInstanceCount >= 0), this._prototypeInstanceCount;
  }
  registerInclusion(t, e) {
    const i = this._inclusionsOf.get(e);
    i === void 0 ? this._inclusionsOf.set(e, [t]) : i.push(t);
  }
  registerMasterModelKey(t) {
    console.assert(this._masterModelKey === Hn.Invalid), this._masterModelKey = t;
  }
  registerPrototypeInstanceCount(t) {
    console.assert(this._prototypeInstanceCount === -1), this._prototypeInstanceCount = t;
  }
}
class Py {
  constructor() {
    this._calculatedCutoff = 0, this._requireBoundingInfo = !1, this._prevPriorityValue = 1, this._priorityProxies = /* @__PURE__ */ new Map();
  }
  getPriorityCompareValue(t) {
    if (typeof t == "number")
      return t;
    {
      const e = this._priorityProxies.get(t);
      return e.worldBounding !== null && console.assert(e.priorityHeuristic <= 1), e.priorityHeuristic;
    }
  }
  setRequireBoundingInfo(t) {
    this._requireBoundingInfo = t;
  }
  comparePriority(t, e) {
    const i = this.getPriorityCompareValue(t), s = this.getPriorityCompareValue(e);
    return i < s;
  }
  _updateHeuristicInfo(t, e) {
    var i;
    if (e.worldBounding !== null) {
      const s = Or(e.worldBounding.center()), r = Or(e.worldBounding.extents()), o = t.calculateAttachHeuristic(r, s);
      e.priorityHeuristic = o;
    }
    if ((i = e.xmlAttachInfo) != null && i.directlyRequested) {
      e.worldBounding === null && (e.priorityHeuristic = 0);
      const s = -1e6;
      e.priorityHeuristic += s;
    }
  }
  createPriority(t, e, i) {
    if (i === null)
      return ++this._prevPriorityValue, {};
    const s = /* @__PURE__ */ Object.create(null);
    let r, o;
    if (i.bounding !== null)
      r = e.transformBox(i.bounding), o = 0;
    else {
      if (this._requireBoundingInfo)
        throw new Error("WorldBounding must be specified when streamCutoff is enabled");
      r = null, o = ++this._prevPriorityValue;
    }
    const a = {
      xmlAttachInfo: i,
      worldBounding: r,
      priorityHeuristic: o
    };
    return this._updateHeuristicInfo(t, a), this._priorityProxies.set(s, a), s;
  }
  destroyPriority(t) {
    typeof t == "object" && this._priorityProxies.delete(t);
  }
  onViewChange(t, e, i) {
    this._calculateCutoff(i.getProjectionMatrix(e.getCamera())), this._priorityProxies.forEach((s) => {
      this._updateHeuristicInfo(t, s);
    });
  }
  reset() {
    this._priorityProxies.clear();
  }
  _calculateCutoff(t) {
    let i = 0.98;
    t.m[11] !== 0 && (i = (1 - t.m[15]) / t.m[11] * t.m[10] + t.m[14]);
    const s = Q.inverse(t);
    if (!s)
      throw new Error();
    const r = lc(s.transform4(new jn(0, 0, i, 1))), o = lc(
      s.transform4(new jn(0.0125, 0, i, 1))
    ), a = lc(
      s.transform4(new jn(0, 0.0125, i, 1))
    );
    cc(1 / r[3], r), cc(1 / o[3], o), cc(1 / a[3], a), this._calculatedCutoff = Math.min(
      du(kc(o, r)),
      du(kc(a, r))
    );
  }
  getCalculatedCutoff() {
    return this._calculatedCutoff;
  }
  // this will be true if streamcutoff is enabled.
}
class Gl {
  constructor(t) {
    this._planes = [], this._absPlanes = [], this._signs = [], this._distanceScale = [];
    const e = t.length;
    for (const i of t)
      this._planes.push(i.slice());
    for (let i = 0; i < e; ++i) {
      this._planes[i][3] = -this._planes[i][3], this._absPlanes[i] = d_(this._planes[i]), this._signs[i] = [0, 0, 0];
      for (let s = 0; s < 3; ++s)
        this._signs[i][s] = this._planes[i][s] >= 0 ? 1 : -1;
    }
    for (let i = 0; i < e; ++i) {
      const s = Sh(this._planes[i]);
      this._distanceScale[i] = s === 0 ? 0 : 1 / s;
    }
  }
  static fromPlaneCoefficients(t) {
    const e = [];
    for (const i of t) {
      const s = [i.x, i.y, i.z, i.w];
      e.push(s);
    }
    return new Gl(e);
  }
  static createFrustumFromMatrix(t) {
    const e = [];
    for (let i = 0; i < 3; ++i)
      e[i] = kc(go(t, 3), go(t, i));
    for (let i = 0; i < 3; ++i)
      e[i + 3] = f_(go(t, 3), go(t, i));
    return new Gl(e);
  }
  testAxisAlignedBox(t, e) {
    const i = this._planes.length;
    let s = $a.FullyInside;
    for (let r = 0; r < i; ++r) {
      const o = rs(this._planes[r], t), a = rs(this._absPlanes[r], e);
      if (o + a <= this._planes[r][3])
        return $a.Outside;
      o - a < this._planes[r][3] && (s = $a.PartiallyInside);
    }
    return s;
  }
  axisAlignedBoxNotOutside(t, e) {
    const i = this._planes.length;
    for (let s = 0; s < i; ++s)
      if (rs(this._planes[s], p_(t, m_(e, this._signs[s]))) <= this._planes[s][3])
        return !1;
    return !0;
  }
  sphereNotOutside(t, e) {
    const i = this._planes.length;
    for (let s = 0; s < i; ++s) {
      const r = rs(this._planes[s], t) - this._planes[s][3];
      if (r < 0 && r * r * this._distanceScale[s] >= e)
        return !1;
    }
    return !0;
  }
  sphereFullyInside(t, e) {
    const i = this._planes.length;
    for (let s = 0; s < i; ++s) {
      const r = rs(this._planes[s], t) - this._planes[s][3];
      if (r < 0 || r * r * this._distanceScale[s] < e)
        return !1;
    }
    return !0;
  }
  pointInside(t) {
    const e = this._planes.length;
    for (let i = 0; i < e; ++i)
      if (rs(this._planes[i], t) - this._planes[i][3] < 0)
        return !1;
    return !0;
  }
  // 1 / (a^2 + b^2 + c^2) for each plane
}
function Gy(n) {
  return 1 / (1 + Math.exp(n));
}
class Iu {
  constructor(t) {
    const e = t.getCamera(), i = e.getPosition(), s = e.getTarget(), r = d.subtract(s, i);
    let o = r.length();
    o < 1e-7 && (o = 1e-7), this._eyeDistanceInverse = 1 / o, r.scale(this._eyeDistanceInverse);
    const a = t.getFullCameraMatrix();
    this._frustum = Gl.createFrustumFromMatrix(a), this._viewProjectionW = go(a, 3), this._cameraIsOrtho = e.getProjection() === Lo.Orthographic, this._position = Or(i), this._eye = Or(r);
  }
  calculateAttachHeuristic(t, e) {
    let i = 0;
    if (this._frustum.axisAlignedBoxNotOutside(e, t)) {
      const s = Sh(t), r = y_(e, s, this._viewProjectionW);
      if (r > 0) {
        let o = g_(e, this._position);
        const l = 1 / (rs(this._eye, o) * this._eyeDistanceInverse + 1e-5);
        o = __(1 / uu(o), o);
        const c = rs(this._eye, o);
        let h = Math.pow(l, 6);
        this._cameraIsOrtho || (h *= Math.pow(c, 10) * 5), h < 1e-5 && (h = 1e-5), i = r * h;
      }
      return console.assert(0 <= i), -i - 1;
    }
    return i = Gy(uu(t)), console.assert(0 <= i && i < 1), i;
  }
}
const _p = class {
  static isSupported() {
    return _p._enabled && typeof fetch == "function" && typeof ReadableStream == "function";
  }
  static async request(n) {
    const t = await fetch(n);
    if (t.status === 200)
      return t;
    throw new ts(`Failed to fetch "${n}" with status ${t.status}.`);
  }
};
let jr = _p;
jr._enabled = !0;
const Yy = 13;
class Yl {
  constructor(t, e, i, s) {
    this._cameraTimeoutId = null, this._isFirstAttachment = !0, this._attachScope = 0, s === null && (s = Yy), console.assert(s > 0), this._engine = t, this._view = e, this._callbackManager = i, this._parentToXmlAttachInfos = /* @__PURE__ */ new Map(), this._viewInfo = new Iu(this._view), this._attachPriorityManager = new Py(), this._comparePriority = (r, o) => this._attachPriorityManager.comparePriority(r, o), this._attachQueue = this._createAttachQueue(s), this._prefetchScsQueue = this._createPrefetchScsQueue(s), this._registerCameraListener();
  }
  static async createWithEmptyModel(t, e, i, s) {
    return await t.loadEmpty(), new Yl(t, e, i, s);
  }
  setPrefetchScsCutoffScale(t) {
    this._prefetchScsQueue.setCutoffScale(t), this._attachPriorityManager.setRequireBoundingInfo(this._prefetchScsQueue.cutoffEnabled());
  }
  /**
   * Used in the constructor only.
   */
  _createAttachQueue(t) {
    return new Nd(
      t,
      this._comparePriority,
      !1
    );
  }
  /**
   * Used in the constructor only.
   */
  _createPrefetchScsQueue(t) {
    const e = t + 15;
    return new Cf(
      0,
      this._attachPriorityManager,
      e,
      (i, s) => this._comparePriority(i, s),
      !1
    );
  }
  _reprioritizeAttachments() {
    this._viewInfo = new Iu(this._view), this._attachPriorityManager.onViewChange(this._viewInfo, this._view, this._engine), this._attachQueue.markDirty(), this._prefetchScsQueue.update();
  }
  /**
   * Used in the constructor only.
   */
  _registerCameraListener() {
    const t = () => {
      this._onCameraChange();
    };
    this._callbackManager.bind({
      camera: t,
      _shutdownBegin: () => {
        this._cameraTimeoutId !== null && (clearTimeout(this._cameraTimeoutId), this._cameraTimeoutId = null), this._callbackManager.unbind({ camera: t });
      }
    });
  }
  reprioritizeAttachmentsNow() {
    this._cameraTimeoutId !== null && (clearTimeout(this._cameraTimeoutId), this._cameraTimeoutId = null), this._reprioritizeAttachments();
  }
  _onCameraChange() {
    this._cameraTimeoutId !== null && clearTimeout(this._cameraTimeoutId), this._cameraTimeoutId = this._engine.setTimeout(() => {
      this._cameraTimeoutId = null, this._reprioritizeAttachments();
    }, 500);
  }
  /**
   * This listens on SC messages relevant for a given attachment.
   * This abstracts away the low-level details about an attachment
   * and bundles relevant information in a promise return value.
   */
  _awaitAttachInfo(t, e, i, s, r) {
    const o = s === null, a = new bu(e, i);
    let l = !1;
    const c = [], h = be(), u = be();
    let p = !1;
    const m = () => {
      console.assert(!p), p = !0, this._cleanupAttachLowLevel(), this._callbackManager.unbind(_);
    };
    let g = null;
    const _ = {
      _priorityMetaDataSent: (y, b) => {
        y === e && (a.registerPrototypeInstanceCount(b), h.resolve());
      },
      _announceModel: (y, b) => {
        y === e && (l = !0, a.registerMasterModelKey(b));
      },
      _inclusion: (y, b, w) => {
        y === e && (a.registerInclusion(b, w), c.push(w));
      },
      _remapModel: (y, b, w) => {
        y === e && t.remapModel(b, w);
      },
      _remapInclusion: (y, b, w, v) => {
        y === e && t.remapInclusion(b, w, v);
      },
      _missingModel: (y, b) => {
        y === e && (g = b);
      },
      _attached: (y) => {
        if (y !== e)
          return;
        if (!l) {
          if (g !== null && (o || r)) {
            console.assert(c.length === 0), u.reject(new Fl(g));
            return;
          }
          if (c.length !== 1) {
            u.reject(new ts("Bad model: Could not find master model key."));
            return;
          }
          const v = c[0];
          a.registerMasterModelKey(v);
        }
        const b = [h], w = this._isFirstAttachment;
        if (w) {
          this._isFirstAttachment = !1;
          const v = o ? Di.Direct : Di.Indirect, C = this._callbackManager.promiseTrigger("_firstAttachment", null, v);
          b.push(C);
        }
        zt(b).catch((v) => {
          throw console.assert(!1), v;
        }).then(async () => {
          w && this._engine.getSessionType() === Oe.Network && await this._callbackManager.promiseTrigger("_firstBoundingReady", null), m(), u.resolve(a);
        });
      }
    };
    return this._callbackManager.bind(_), u.catch((y) => {
      throw m(), y;
    });
  }
  _createPriority(t, e) {
    return this._attachPriorityManager.createPriority(
      this._viewInfo,
      t,
      e
    );
  }
  _cleanupAttachLowLevel() {
  }
  async _cleanupAttachHighLevel(t, e, i) {
    try {
      return await t;
    } finally {
      i !== null && this._forgetXmlAttachment(i), this._attachPriorityManager.destroyPriority(e);
    }
  }
  newAttachScope() {
    return ++this._attachScope;
  }
  _attachByStream(t, e, i, s, r, o, a, l) {
    const c = Q.toMatrix12(s.m), h = this._createPriority(s, a), u = this._attachQueue.push(async () => {
      const p = this.newAttachScope(), m = this._awaitAttachInfo(
        e,
        p,
        o.get(),
        a,
        l
      );
      try {
        return await t.enqueue(() => this._engine.attachModel(
          p,
          i,
          c,
          r,
          o.get()
        )), await m;
      } catch (g) {
        throw this._cleanupAttachLowLevel(), g;
      }
    }, h);
    return this._cleanupAttachHighLevel(u, h, a);
  }
  static _getAllModelKeys(t) {
    const e = t.getMasterModelKey(), i = t.getAllInclusions();
    if (i[1] !== e) {
      for (let r = 2; r < i.length; r += 2)
        if (i[r + 1] === e) {
          const a = i[r];
          i[r] = i[0], i[r + 1] = i[1], i[0] = a, i[1] = e;
          break;
        }
    }
    const s = [];
    for (let r = 0, o = 1; o < i.length; ++r, o += 2)
      s[r] = i[o];
    return s;
  }
  /**
   * This function is used to attach SCS buffers that are keyed to an `ExternalModelName`.
   * This happens when attaching an SCS from a model found in a shattered XML file.
   *
   * This function should be used over `simpleAttach` for this case. This is because `simpleAttach`
   * only takes a buffer as an argument. Without storing the entire buffer as a key to the attached
   * model keys of the SCS model, subsequent attachments of equivalent buffers cannot leverage
   * making new inclusions of the existing attached models. On the other hand, this keys the
   * attached models from the SCS buffer, allowing model sharing for subsequent attachments.
   *
   * cancelUnitMatrix is a patch to tell to the engine to cancel the undesired scale matrix for
   * some model type in some version when using the shattered workflow.
   *
   * Returns `Promise<null>` when the attachment is skipped (due to `toAttachData` returning `null`).
   */
  async attachByNamedScsBuffer(t, e, i, s, r, o, a, l, c) {
    t.getAutomaticMeasurementUnitScaling() || (o = nn);
    const h = gn(l.parent), u = Q.toMatrix12(r.m), p = this._createPriority(r, l), m = async (_) => {
      const y = await (async () => {
        const C = h.getScsModelKeysOf(e);
        return C === null ? (h.initializeScsModelKeysOf(e), _) : C;
      })(), b = h.getScsModelKeysOf(e);
      if (b === null)
        throw new re();
      const w = this.newAttachScope();
      let v;
      if (y instanceof Uint8Array || jr.isSupported() && y instanceof Response) {
        const k = this._awaitAttachInfo(
          i,
          w,
          a.get(),
          l,
          !1
        );
        try {
          await t.enqueue(() => {
            const Y = this._engine.attachScsBuffer(
              w,
              y instanceof Uint8Array ? y : null,
              // if attachData is not an array, then data will be fed into SC as it arrives
              u,
              o,
              a.get(),
              !0,
              c
            );
            return y instanceof Uint8Array || this.streamScsData(w, y), Y;
          }), v = await k;
        } catch (Y) {
          throw this._cleanupAttachLowLevel(), Y;
        }
        if (b.state === ds.Pending) {
          const Y = Yl._getAllModelKeys(v);
          b.resolve(Y);
        }
      } else if (y === null)
        v = null, b.state === ds.Pending && b.resolve(null);
      else if (y instanceof Array) {
        console.assert(b.state !== ds.Pending);
        const C = new bu(w, a.get());
        C.registerPrototypeInstanceCount(0);
        for (let k = 0; k < y.length; ++k) {
          const Y = y[k], P = this._engine.attachScsModelByKey(
            w,
            Y,
            u,
            o,
            a.get()
          );
          C.registerInclusion(P, Y), k === 0 && C.registerMasterModelKey(Y);
        }
        v = C;
      } else
        throw new re();
      return v;
    }, g = (async () => {
      const _ = await this._prefetchScsQueue.push(async () => h.toScsBuffer(e, s), p);
      return l.directlyRequested = !0, this._attachQueue.push(() => m(_), p);
    })();
    return this._cleanupAttachHighLevel(g, p, l);
  }
  // Streams the data from a fetch response into the the buffer associated with the attach scope
  streamScsData(t, e) {
    this._callbackManager.trigger("_fetchBegin", e.url, t);
    const i = e.body.getReader(), s = async () => {
      for (; ; ) {
        const { done: r, value: o } = await i.read();
        if (r) {
          this._engine.feedScsBuffer(t, null), this._callbackManager.trigger("_fetchEnd", e.url, t);
          return;
        }
        this._engine.feedScsBuffer(t, o);
      }
    };
    this._engine.setTimeout(s, 0);
  }
  _attachByScsBuffer(t, e, i, s, r, o, a) {
    const c = Q.toMatrix12(s.m), h = this._createPriority(s, null), u = this._attachQueue.push(async () => {
      const p = this.newAttachScope(), m = this._awaitAttachInfo(
        e,
        p,
        o.get(),
        null,
        !1
      );
      try {
        return await t.enqueue(() => {
          const _ = this._engine.attachScsBuffer(
            p,
            i instanceof Uint8Array ? i : null,
            // if scsBuffer is not an array, then data will be fed into SC as it arrives
            c,
            r,
            o.get(),
            !1,
            a
          );
          return i instanceof Uint8Array || this.streamScsData(p, i), _;
        }), await m;
      } catch (g) {
        throw this._cleanupAttachLowLevel(), g;
      }
    }, h);
    return this._cleanupAttachHighLevel(u, h, null);
  }
  simpleAttach(t, e, i, s, r, o, a, l) {
    if (t.getAutomaticMeasurementUnitScaling() || (r = nn), typeof i == "string")
      return this._attachByStream(
        t,
        e,
        i,
        s,
        r,
        o,
        a,
        l
      );
    if (a === null)
      return this._attachByScsBuffer(
        t,
        e,
        i,
        s,
        r,
        o,
        !1
      );
    throw new re();
  }
  reset() {
    return this._isFirstAttachment = !0, this._attachScope = 0, this._parentToXmlAttachInfos.clear(), this._attachPriorityManager.reset(), this.clearAttachQueues();
  }
  /**
   * This method will effectively cancel an active LoadSubtreeByXML operation.
   * All deferred promises in the prefetch queue will be canceled.
   * Note that any open promises i.e. SCS files that are being fetched when this method is called will resolve before this method returns.
   */
  async clearAttachQueues() {
    return this._prefetchScsQueue.killDeferred(), this._attachQueue.killDeferred(), await this._prefetchScsQueue.waitForIdle(), this._attachQueue.waitForIdle();
  }
  isIdle() {
    return this._attachQueue.isIdle();
  }
  /**
   * Call this when a node has been directly requested by `Model.prototype.requestNodes`.
   */
  notifyDirectRequest(t) {
    const e = this._parentToXmlAttachInfos.get(t);
    if (e !== void 0) {
      let i = !1;
      for (const s of e)
        s.directlyRequested || (s.directlyRequested = !0, i = !0);
      i && this._reprioritizeAttachments();
    }
  }
  registerXmlAttachInfo(t) {
    const e = t.parent;
    let i = this._parentToXmlAttachInfos.get(e);
    i === void 0 && (i = [], this._parentToXmlAttachInfos.set(e, i)), i.push(t);
  }
  _forgetXmlAttachment(t) {
    const e = t.parent, i = this._parentToXmlAttachInfos.get(e);
    if (i.length === 1)
      console.assert(i[0] === t), this._parentToXmlAttachInfos.delete(e);
    else {
      console.assert(i.length > 1);
      const s = i.indexOf(t);
      console.assert(s >= 0), i.splice(s, 1);
    }
  }
  maxConcurrentAttachments() {
    return this._attachQueue.maxActivePromises();
  }
}
function Xh(n, t) {
  return new Promise((e, i) => {
    const s = new XMLHttpRequest();
    s.open("GET", n, !0), t && (s.responseType = t), s.onload = function(r) {
      if (s.readyState === Md.Done)
        if (s.status === Wd.Ok)
          e(s);
        else {
          const o = new ts(
            `XMLHttpRequest failed to GET "${n}" with status ${s.status}.`
          );
          i(o);
        }
    }, s.onerror = function(r) {
      i(r);
    }, s.send();
  });
}
async function yp(n) {
  const t = await Xh(n, "arraybuffer");
  return new Uint8Array(t.response);
}
class Vy {
  constructor() {
    this._cache = /* @__PURE__ */ new Map();
  }
  clear() {
    this._cache.clear();
  }
  async load(t, e) {
    const i = this._cache.get(t);
    return i !== void 0 ? i : (this._cache.set(t, e), e);
  }
}
const bp = "Missing";
function Ip(n) {
  return new DOMParser().parseFromString(n, "application/xml");
}
async function Ty(n) {
  const t = await Xh(n);
  let e = t.responseXML;
  return e === null && (e = Ip(t.responseText)), e;
}
function Ey(n) {
  if (!n.hasChildNodes)
    return null;
  const t = n.firstChild;
  if (!(t instanceof Comment))
    return null;
  const e = t.data.split(" ");
  if (e.length !== 2 || e[0] !== "HC")
    return null;
  const i = e[1].split(".");
  if (i.length < 2)
    return null;
  const s = [];
  for (const r of i) {
    if (!Pd(r))
      return null;
    s.push(parseInt(r, 10));
  }
  return s;
}
function Ry(n) {
  return Ko(vh, n);
}
function Ny(n) {
  const t = n.getElementsByTagName("parsererror");
  if (t.length > 0)
    throw new ce(t[0].textContent || "unknown error");
}
function Ly(n) {
  const t = n.getParent();
  return t instanceof hi && t.getParent() instanceof on;
}
function Xy(n, t, e, i, s, r) {
  const o = new hi(
    t,
    s,
    r,
    Hn.Local,
    e
  );
  switch (i) {
    case 0:
      return o;
    case 1: {
      const a = new xi(
        n,
        o,
        ve.Local,
        Ji.Local
      );
      o.addInclusionContext(a);
      const l = Yt.createDynamic(
        n,
        a,
        bp,
        null,
        // authored node id
        null,
        // local transform
        !r
      );
      return a.addProductOccurrence(l), o;
    }
    default:
      return $n();
  }
}
function Fy(n, t, e, i) {
  return {
    getAttachScope() {
      return n;
    },
    getMasterModelKey() {
      return i;
    },
    getModelKeys() {
      return [i];
    },
    hasInclusions() {
      return !0;
    },
    getAllInclusions() {
      return [e, i];
    },
    getInclusionsOf(s) {
      return s === i ? [e, i] : [];
    },
    hasModelIncluded(s) {
      return s === i;
    },
    attachedInvisibly() {
      return t;
    },
    prototypeInstanceCount() {
      return 0;
    }
  };
}
class Fh {
  constructor(t, e, i, s, r) {
    this._loadQueue = new Ns(1024, !1), this._activeLoadCount = 0, this._activeLoadGeneration = 0, this._isFirstLoad = !0, this._firstAssemblyDataHeader = null, console.assert(t.isInitialized()), this._assemblyTree = t, this._scAttacher = e, this._engine = i, this._view = s, this._callbackManager = r, this._isScsSession = this._engine.getSessionType() === Oe.Scs, this._nodesUntilNextSleep = 2e3;
  }
  // Modify the scale of the PO if needed, depends of the unit
  _resolveMeasurementUnits(t, e, i, s) {
    if (!this._assemblyTree.getAutomaticMeasurementUnitScaling())
      return;
    const r = Pn(t.getParent());
    if (r === null)
      throw new re();
    const o = r.getMeasurementUnit(), a = t.getMeasurementUnit();
    let l = t.getLocalTransform();
    if (l === null && (l = Xi.getIdentity()), o !== a) {
      const c = a / o;
      l[0] *= c, l[5] *= c, l[10] *= c;
    }
    this._applyScalePatchIfNeeded(
      l,
      e,
      i,
      s,
      a
    ), t.setLocalTransformAsInitial(l);
  }
  // Will directly modify localChildMatrix to apply the scale patch
  // COM-4049 Fix for Aras to manage loading monolithic scs from shattered XML
  // Inventor after 2021 (HC v9) + solidedge after 2023 add an unit scale in the first PO root child
  // Because data is in a different unit than the real unit defined in nodeUnit
  // We need to revert it because the scale is already applied in the master assembly (xml)
  // Only if the shattered part is generated with output_scs, else the scale is already skiped during conversion
  _applyScalePatchIfNeeded(t, e, i, s, r) {
    const o = s === Rr.Inventor, a = s === Rr.Se, l = o && Ko(i, [9, 0, 0]) || a && Ko(i, [23, 0, 0]), u = o ? 10 : 1e3;
    if (e && l && r !== u) {
      const p = r / u;
      t[0] *= p, t[5] *= p, t[10] *= p;
    }
  }
  /**
   * Used to create assembly tree data for instances that don't have authored assembly tree data.
   */
  async _patchImplicitNodesByModelInc(t, e, i, s, r) {
    let o = 0;
    if (s.length === 0)
      return;
    let a;
    const l = ji.create(() => {
      const c = t.get(), h = ke(c), u = h.getAttachScope();
      a = h.attachedInvisibly();
      const p = h.split(u, a, c);
      c.addAttachContext(p);
      const m = new xi(
        this._assemblyTree,
        p,
        e,
        i
      );
      p.addInclusionContext(m);
      const g = Yt.createDynamic(
        this._assemblyTree,
        m,
        `Of Inclusion (${e})`,
        null,
        null,
        !a,
        r
      );
      return m.addProductOccurrence(g), g;
    });
    for (const c of s) {
      let h = this._assemblyTree.lookupAnyBodyByInstanceInc(e, c);
      if (h === null) {
        const u = l.get(), p = `Implicit Body ${++o}`, m = await this._engine.getPartsBounding(
          [e, c],
          !0,
          !1
        ), g = m.max !== m.min && !m.isDegenerate();
        h = this._assemblyTree.createMeshInstance(
          !0,
          // mark loaded
          e,
          c,
          null,
          // authored node id
          p,
          u,
          // parent
          !1,
          // prevent from resetting
          !1,
          // out of hierarchy
          g,
          !0
          // is implicit
        ), a && h.setVisibility(!1);
      }
    }
  }
  _getPrototypeInstanceCountByAttachment(t) {
    const e = /* @__PURE__ */ new Set();
    let i = 0;
    const s = t.getAllInclusions();
    for (let r = 0; r < s.length; r += 2) {
      const o = s[r], a = s[r + 1];
      e.has(a) || (e.add(a), i += this._assemblyTree.getInstanceCountByInclusion(o));
    }
    return i;
  }
  /**
   * Used to create assembly tree data for instances that don't have authored assembly tree data.
   */
  async _patchImplicitNodesByAttachment(t, e, i) {
    console.assert(t.isLoaded());
    let s = null;
    const r = ji.create(() => {
      const h = new Wr(), u = e.getMasterModelKey();
      s = new hi(
        h,
        e.getAttachScope(),
        e.attachedInvisibly(),
        u,
        t
      );
      const p = new xi(
        this._assemblyTree,
        s,
        ve.Local,
        Ji.Local
      );
      s.addInclusionContext(p);
      const m = Yt.createDynamic(
        this._assemblyTree,
        p,
        "Implicit Bodies",
        null,
        // authored node id
        null,
        // local transform
        !e.attachedInvisibly(),
        i
      );
      return p.addProductOccurrence(m), m;
    });
    let o = e.prototypeInstanceCount();
    o === 0 && ([o] = await this._engine.instanceKeyInfo(
      e.getAttachScope(),
      wl.Attachment,
      vl.KeyCountOnly
    ));
    let a = this._getPrototypeInstanceCountByAttachment(e);
    if (a === o)
      return;
    const l = await this._engine.instanceKeyInfo(
      e.getAttachScope(),
      wl.Attachment,
      vl.AllKeys
    ), c = e.getAllInclusions();
    for (let h = 0; h < c.length; h += 2) {
      const u = c[h], p = c[h + 1], m = l.get(p);
      m !== void 0 && await this._patchImplicitNodesByModelInc(
        r,
        u,
        p,
        m,
        i
      );
    }
    if (a = this._getPrototypeInstanceCountByAttachment(e), a < o)
      throw new re();
    s !== null && (await ir([s]), t instanceof on, t.addAttachContext(s));
  }
  /**
   * Newly loaded children should have their instances demanded if any of their
   * ancestors are currently being demanded. This function performs this logic.
   */
  async _updateOnDemandRequests(t) {
    if (!this._assemblyTree.onDemandRequestsActive())
      return;
    const e = t.getChildren(), i = [];
    for (const s of e)
      this._assemblyTree.isBeingRequested(s) && i.push(s);
    return this._assemblyTree.requestNodes(this, i, !0);
  }
  async _populateAttachment(t, e, i, s, r, o) {
    console.assert(r === Di.Indirect == (o !== null));
    const a = await this._parseRootNodes(
      t,
      e,
      i,
      s,
      o
    );
    return await this._postProcessAttachContext(e, s, r, a), a;
  }
  async _postProcessAttachContext(t, e, i, s) {
    await yi.forceLazyPromises(s), await this._assemblyTree.enqueue(() => Sf(this._engine, s));
    let r = this._assemblyTree.markImplicitNodesOutOfHierarchy();
    r && (r = s.getChildren().length > 0 || i === Di.Indirect), await this._patchImplicitNodesByAttachment(t, e, r), await this._updateOnDemandRequests(s);
    const a = s.getChildren().map((l) => l.getRuntimeId());
    this._callbackManager.trigger("_attachmentPopulated", a);
  }
  async _parseRootNodes(t, e, i, s, r) {
    const o = s.getMasterModelKey(), a = s.getInclusionsOf(o);
    o === Hn.Invalid && (console.assert(a.length === 0), a.push(ve.Invalid, Ji.Invalid));
    const l = new hi(
      i,
      s.getAttachScope(),
      s.attachedInvisibly(),
      o,
      e
    );
    r !== null && l.setReservedNodeIdOffset(r);
    const c = new Ns(1, !0), h = await this._assemblyTree.enqueue(() => l.getRootNodeMetaData(this._assemblyTree));
    for (let u = 0; u < a.length; u += 2)
      c.push(() => {
        const p = a[u], m = a[u + 1];
        return this._parseRootNode(t, l, h, p, m);
      });
    return await c.waitForIdle(), l;
  }
  async _parseRootNode(t, e, i, s, r) {
    console.assert(s !== ve.Local);
    const o = await this._populateInclusion(
      t,
      e,
      i,
      s,
      r
    );
    if (o.hasAuthoredId()) {
      console.assert(!o.isLoaded());
      const a = Ne(o);
      Ly(a) && this._setupRootNode(o, !1);
    } else
      o.getName() === null && (e.removeProductOccurrence(o) || console.assert(!1));
  }
  _setupRootNode(t, e, i = !1, s = [], r = Rr.Unknown) {
    console.assert(!t.isAbsoluteRoot()), e && t.markIsExternalModelRoot(this._assemblyTree), this._resolveMeasurementUnits(t, i, s, r);
  }
  async _populateInclusion(t, e, i, s, r) {
    console.assert(s !== ve.Local);
    const o = new xi(
      this._assemblyTree,
      e,
      s,
      r
    );
    e.addInclusionContext(o);
    const a = await (async () => {
      if (i === null || i.bytes.length === 0) {
        let h = null;
        return i === null && (h = bp), Yt.createDynamic(
          this._assemblyTree,
          o,
          h,
          null,
          // authored node id
          null,
          // local transform
          !e.attachedInvisibly()
        );
      }
      const l = new jo(i), c = Yt.parseBinary(
        t,
        this._assemblyTree,
        o,
        l
      );
      return Yt.reify(
        t,
        this,
        this._assemblyTree,
        o,
        c,
        o
      );
    })();
    return o.addProductOccurrence(a), a;
  }
  /**
   * COM-1701
   */
  async _rectifyLateVisibilityChange(t, e) {
    const i = ke(e.getParent()), s = Pn(e.getParent());
    if (console.assert(s === Pn(i)), t.attachInvisibly || s === null || !s.isLoaded())
      return;
    const r = s.isVisible();
    if (i.attachedInvisibly() === !r)
      return;
    const o = r ? hs.Initial : hs.Hide;
    return wf({
      assemblyTree: this._assemblyTree,
      engine: this._engine,
      attachContext: i,
      setVisibility: o
    });
  }
  _loadCleanup(t, e, i) {
    console.assert(this._activeLoadCount > 0), t.onLoadComplete(), e !== null && this._callbackManager.unbind(e), --this._activeLoadCount, this._assemblyTree.onLoadEnd(i), this._callbackManager.trigger("visibilityChanged", [], []);
  }
  _wrap(t, e, i, s) {
    const r = this._activeLoadGeneration;
    return this._loadQueue.push(async () => {
      const o = this._assemblyTree.onLoadBegin();
      let a = null;
      if (r !== this._activeLoadGeneration)
        throw this._loadCleanup(e, a, o), new Xl();
      this._firstAssemblyDataHeader === null && (a = {
        _modelStructureHeaderParsed: async (p) => {
          a !== null && (this._firstAssemblyDataHeader === null && (this._firstAssemblyDataHeader = p), this._callbackManager.unbind(a), a = null);
        }
      }, this._callbackManager.bind(a, !0));
      try {
        await i;
      } catch (p) {
        throw await e.purgeContents(), this._loadCleanup(e, a, o), p;
      }
      const l = e.getParent();
      if (l === null)
        throw this._loadCleanup(e, a, o), new re();
      s === Di.Direct && (e.hasChildren() ? l.addLoadContext(e) : await e.purgeContents()), this._loadCleanup(e, a, o);
      const h = e.getChildren(), u = [];
      for (const p of h) {
        const m = this._rectifyLateVisibilityChange(t, p);
        u.push(m);
      }
      if (await zt(u), this._isFirstLoad) {
        this._isFirstLoad = !1, e.markAsFirstLoad();
        const p = h.map((g) => g.getRuntimeId()), m = !1;
        try {
          await this._callbackManager.promiseTrigger(
            "_firstModelLoaded",
            "firstModelLoaded",
            p,
            m,
            s
          );
        } catch (g) {
          throw console.assert(!1), g;
        }
      }
      return e;
    });
  }
  _initLoad(t, e, i) {
    ++this._activeLoadCount;
    const s = this._isScsSession && i ? new Vy() : null;
    return new on(t, e, s);
  }
  static _getNetMatrix(t, e) {
    let i = Q.createFromArray(Uo(t));
    return e !== null && (i = Q.multiply(e, i)), i;
  }
  _lazyAttachInvisibly(t, e) {
    return ji.create(() => e.attachInvisibly || !t.isVisible());
  }
  _loadBySingleAttach(t, e, i, s) {
    const r = this._initLoad(e, s, !1), o = Si.create(async () => {
      const a = await i, l = new Wr(), c = Fh._getNetMatrix(e, t.additionalMatrix), h = e.getMeasurementUnit(), u = this._lazyAttachInvisibly(e, t), p = await this._scAttacher.simpleAttach(
        this._assemblyTree,
        l,
        a,
        c,
        h,
        u,
        null,
        // xml attach info
        !1
      ), m = await this._populateAttachment(
        t,
        r,
        l,
        p,
        Di.Direct,
        null
      );
      return await ir([r, m]), m.hasChildren() && r.addAttachContext(m), {};
    });
    return this._wrap(t, r, o, Di.Direct);
  }
  async _populateFromXml(t, e, i, s) {
    let o = i.documentElement.firstElementChild, a = null, l = null;
    for (; o !== null; ) {
      if (o.localName === "ModelFile" && (console.assert(a === null), a = oc.parseXml(
        t,
        this._assemblyTree,
        e,
        o,
        s
      )), o.localName === "DefaultCamera" && (l = _e.parseCamera(o), !l))
        throw new ce(`"DefaultCamera" element exists but couldn't be parsed`);
      o = o.nextElementSibling;
    }
    if (a === null)
      throw new ce('Expected "ModelFile" element.');
    let c = !1;
    if (this._isFirstLoad) {
      let u = nn;
      if (this._assemblyTree.getAutomaticMeasurementUnitScaling() && (u = Pn(e).getMeasurementUnit()), l != null)
        c = !0, await this._view._setCameraPromise(l, 0);
      else {
        const p = oc.parseBounding(a, u);
        !p.isDegenerate() && l === null && (c = !0, await this._view.setViewOrientation(et.Iso, 0, p));
      }
    }
    const h = await oc.reify(
      t,
      this._callbackManager,
      this,
      this._assemblyTree,
      e,
      a
    );
    for (const u of h)
      this._setupRootNode(u, !1);
    this._isFirstLoad && !c && await this._view.setViewOrientation(et.Iso, 0);
  }
  _loadByXml(t, e, i, s, r) {
    const o = this._initLoad(e, r, !0), a = Si.create(async () => {
      const l = await i;
      Ny(l);
      const c = Ey(l);
      if (c === null || !Ry(c))
        throw new ce("Bad version.");
      const h = (b) => s(b, c);
      this._scAttacher.reprioritizeAttachmentsNow(), e.addLoadContext(o);
      const u = Ne(e), p = ke(u), m = this._scAttacher.newAttachScope(), g = this._lazyAttachInvisibly(e, t), _ = p.split(
        m,
        g.get(),
        o
      );
      o.addAttachContext(_);
      const y = u.split(
        this._assemblyTree,
        _
      );
      return _.addInclusionContext(y), await this._populateFromXml(t, y, l, h), await ir([o, _]), {};
    });
    return this._wrap(t, o, a, Di.Indirect);
  }
  // For external models built-directly inside SC metadata (i.e. not from a shattered XML file).
  async _attachExternalModelByInc(t, e) {
    console.assert(t.inclusionKey !== ve.Local);
    const i = ke(e).getAttachScope(), s = t.modelKey, r = this._lazyAttachInvisibly(e, t.config), o = new Wr(), a = new hi(
      o,
      i,
      r.get(),
      s,
      e
    ), l = await a.getRootNodeMetaData(this._assemblyTree);
    return await this._populateInclusion(
      t.config,
      a,
      l,
      t.inclusionKey,
      t.modelKey
    ), a;
  }
  // For external models given by shattered XML files.
  async _attachExternalModelInfoByName(t, e, i) {
    const s = new Wr(), r = this._lazyAttachInvisibly(e, t.config), o = e.getMeasurementUnit(), a = (() => {
      const h = Q.createFromArray(Uo(e));
      if (o <= 0 || !this._assemblyTree.getAutomaticMeasurementUnitScaling())
        return h;
      const u = (() => {
        const g = i.getAttachContext().getParent();
        if (g === null)
          return nn;
        const _ = g.getParent();
        return _ === null ? nn : _.getMeasurementUnit();
      })(), p = u === nn ? 1 : o / u;
      return p === 1 ? h : Q.multiply(
        h,
        new Q().setScaleComponent(p, p, p)
      );
    })(), l = {
      bounding: t.bounding,
      parent: e,
      directlyRequested: !1
    };
    let c;
    if (this._isScsSession)
      this._scAttacher.registerXmlAttachInfo(l), c = await this._scAttacher.attachByNamedScsBuffer(
        this._assemblyTree,
        t.modelName,
        s,
        t.toAttachData,
        a,
        o,
        r,
        l,
        t.cancelUnitScale
      ) || 0;
    else
      try {
        const h = await t.toAttachData(t.modelName);
        if (h === null || h === or)
          c = 0;
        else {
          if (typeof h != "string")
            throw new re();
          this._scAttacher.registerXmlAttachInfo(l), c = await this._scAttacher.simpleAttach(
            this._assemblyTree,
            s,
            h,
            a,
            o,
            r,
            l,
            t.config.allowMissingExternalModels
          );
        }
      } catch (h) {
        if (t.config.allowMissingExternalModels && h instanceof Fl)
          c = 1;
        else
          throw h;
      }
    if (typeof c == "number") {
      const h = this._scAttacher.newAttachScope(), u = !r.get();
      return Xy(
        this._assemblyTree,
        s,
        e,
        c,
        h,
        u
      );
    } else
      return this._populateAttachment(
        t.config,
        e,
        s,
        c,
        Di.Indirect,
        t.reservedNodeIdOffset
      );
  }
  setPrefetchScsCutoffScale(t) {
    this._scAttacher.setPrefetchScsCutoffScale(t);
  }
  isIdle() {
    return this._activeLoadCount === 0 ? (console.assert(this._scAttacher.isIdle()), !0) : !1;
  }
  waitOnCurrentLoads() {
    return this._loadQueue.waitForIdle();
  }
  cancelPendingLoads() {
    return ++this._activeLoadGeneration, this.waitOnCurrentLoads();
  }
  async cancelActiveAttachmentProcess() {
    return this._scAttacher.clearAttachQueues();
  }
  loadByStream(t, e, i) {
    if (i === or) {
      const s = new on(e, or, null);
      return Promise.resolve(s);
    }
    return this._loadBySingleAttach(t, e, Promise.resolve(i), i);
  }
  loadByScsBuffer(t, e, i) {
    return this._loadBySingleAttach(t, e, Promise.resolve(i), "*SCS Buffer*");
  }
  async loadByScsFile(t, e, i) {
    if (jr.isSupported())
      return this._loadBySingleAttach(t, e, jr.request(i), i);
    {
      const s = yp(i);
      return this._loadBySingleAttach(t, e, s, i);
    }
  }
  loadByXmlDoc(t, e, i, s) {
    let r;
    return typeof i == "string" ? r = Ip(i) : r = i, this._loadByXml(t, e, Promise.resolve(r), s, "*XML Document*");
  }
  loadByXmlFile(t, e, i, s) {
    const r = Ty(i);
    return this._loadByXml(t, e, r, s, i);
  }
  async attachByExternalModelInfo(t, e, i) {
    let s, r = !1;
    Jo(t) ? (r = t.cancelUnitScale, s = await this._attachExternalModelInfoByName(t, e, i)) : s = await this._attachExternalModelByInc(t, e);
    const o = [], a = s.getChildren(), l = s.getAssemblyDataVersion(), c = s.getOriginalFileType();
    for (const h of a) {
      this._setupRootNode(h, !0, r, l, c);
      const u = this._rectifyLateVisibilityChange(t.config, h);
      o.push(u);
    }
    return await zt(o), s;
  }
  /**
   * I don't think this is used at all. If so, this should be removed.
   */
  async loadByAssemblyData(t, e, i, s) {
    const r = Di.Direct, [o, a] = i, l = this._scAttacher.newAttachScope(), c = !e.isVisible(), h = Fy(l, c, o, a), u = this._initLoad(e, "*Assembly Data*", !1), p = Si.create(async () => {
      const m = new Wr(), g = h.getMasterModelKey(), _ = new hi(
        m,
        l,
        h.attachedInvisibly(),
        g,
        u
      );
      return await this._parseRootNode(t, _, s, o, a), await this._postProcessAttachContext(u, h, r, _), await ir([u, _]), _.hasChildren() && u.addAttachContext(_), {};
    });
    return this._wrap(t, u, p, r);
  }
  reset() {
    return this._isFirstLoad = !0, this._firstAssemblyDataHeader = null, this._scAttacher.reset();
  }
  notifyDirectRequest(t) {
    this._scAttacher.notifyDirectRequest(t);
  }
  onLoadChildProductOccurrence() {
    if (this._nodesUntilNextSleep === 0)
      return this._nodesUntilNextSleep = 2e3, this._engine.sleep(
        10
        /* sleepLengthMilliseconds */
      );
    --this._nodesUntilNextSleep;
  }
  firstAssemblyDataHeader() {
    return this._firstAssemblyDataHeader;
  }
}
function Ky(n, t, e, i, s) {
  const r = [], o = (u) => {
    u.getInclusionContexts().forEach((m) => {
      r.push(m.getInclusionKey());
    });
  }, a = (u) => {
    u.getAttachContexts().forEach(o);
  }, c = {
    enterProductOccurrence: (u) => {
      if (i.has(u) || (i.add(u), u.isOutOfHierarchy() && !e))
        return;
      u.getChildContexts().forEach((m) => {
        m instanceof on ? a(m) : o(m);
      });
    }
  }, h = n.walk(c, t, s);
  return h ? h.then(() => r) : r;
}
function Oy(n, t, e, i) {
  return Ky(
    ka,
    n,
    t,
    e,
    i
  );
}
function Ay(n, t, e) {
  const i = [], s = /* @__PURE__ */ new Set();
  for (const r of t) {
    const o = n.lookupAnyTreeNode(r);
    if (o === null)
      throw new sn(r);
    const a = ks(o), l = Oy(o, a, s, e);
    for (const c of l)
      i.push(c);
  }
  return i;
}
async function Dy(n) {
  let t = !1;
  const e = (s) => {
    s.hasLocalTransformOverride() && (s.removeLocalTransformOverride(), t = !0);
  }, i = {
    enterProductOccurrence: e,
    enterPmi: e,
    enterCadView: e,
    enterAnyBody: (s) => {
      s.preventFromResetting() || e(s);
    }
  };
  return await yi.walk(i, n, ft.None), t;
}
function zy(n, t, e) {
  const i = [], s = /* @__PURE__ */ new Set(), r = (a) => s.has(a) ? !1 : (s.add(a), !0), o = {
    followProductOccurrence: r,
    followPmi: r,
    followCadView: r,
    followAnyBody: r,
    enterAnyBody: (a) => {
      if (!a.isOutOfHierarchy()) {
        const l = a.getInstanceInc();
        i.push(l[0], l[1]);
      }
    }
  };
  for (const a of t)
    ka.walk(o, a, ft.None);
  n.setMeshLevel(i, e);
}
function By(n) {
  return n instanceof Ce || n instanceof Re || n instanceof cr || n instanceof hr || n instanceof ur || n instanceof ga || n instanceof fa || n instanceof _a || n instanceof ya || n instanceof ba || n instanceof Ia || n instanceof wa || n instanceof va || n instanceof Sa || n instanceof xa || n instanceof Za || n instanceof Ca || n instanceof pa;
}
function Jy(n) {
  return n instanceof ma || n instanceof qr || n instanceof Es;
}
function wu(n) {
  return async (t, e) => {
    const i = Ko(e, [7, 3]) ? `${t}.scs` : t, s = await n(i);
    return typeof s == "string" ? jr.isSupported() ? jr.request(s) : yp(s) : s;
  };
}
class Kh {
  constructor(t, e, i, s, r, o) {
    this._clearQueue = new Ns(1, !1), this._clearInProgress = !1, this._cadConfigurationsEnabled = !0, this._engine = e, this._callbackManager = i, this._cuttingManager = s, this._view = r, this._model = o, this._assemblyTree = new Wy(
      t,
      this._engine,
      this._callbackManager,
      this._cuttingManager,
      this._view,
      this._model
    ), this._readyPromise = gh();
  }
  /**
   * Until `modelStructure.isReady()` is true, only the following functions are legal to call:
   *      - `modelStructure.waitForReady()`
   *      - `modelStructure.isReady()`
   */
  static unsafeCreate(t, e, i, s, r, o, a) {
    return this._create(
      t,
      e,
      i,
      s,
      r,
      o,
      a
    ).unsafeValue;
  }
  static async create(t, e, i, s, r, o, a) {
    return this._create(
      t,
      e,
      i,
      s,
      r,
      o,
      a
    );
  }
  static _create(t, e, i, s, r, o, a) {
    const l = new Kh(
      t,
      e,
      i,
      s,
      r,
      o
    ), c = l._init(a);
    return os(l, c);
  }
  async _init(t) {
    const e = await Yl.createWithEmptyModel(
      this._engine,
      this._view,
      this._callbackManager,
      t
    );
    this._assemblyTree.initialize(e);
    const i = new Fh(
      this._assemblyTree,
      e,
      this._engine,
      this._view,
      this._callbackManager
    );
    console.assert(this._treeLoader === void 0), this._treeLoader = i, this._readyPromise.resolve();
  }
  async _loadSubtreePrologue(t, e, i) {
    if (this._engine.getSessionType() !== t)
      throw new ts("Incompatible load types.");
    if (i && await this._clearQueue.waitOnLatest(), this._clearInProgress)
      throw new Xl();
    const s = this._assemblyTree.lookupProductOccurrence(e);
    if (s === null)
      throw new Vi(e, li.ProductOccurrence);
    return s;
  }
  async _loadSubtreeEpilogue(t, e) {
    t.isFirstLoad() && this._engine.getSessionType() === Oe.Scs && await this._callbackManager.promiseTrigger("_firstBoundingReady", null);
    const s = t.getChildren().map((r) => r.getRuntimeId());
    return e && await this._callbackManager.promiseTrigger(
      "_subtreeLoaded",
      "subtreeLoaded",
      s,
      ps.LoadModel
    ), s;
  }
  async loadSubtreeFromXmlFile(t, e, i, s) {
    await this._disableCadConfigurations();
    const r = Oe.Network, o = await this._loadSubtreePrologue(r, t, !0), a = await this._treeLoader.loadByXmlFile(
      s,
      o,
      e,
      i
    );
    return this._loadSubtreeEpilogue(a, !1);
  }
  async loadSubtreeFromXmlDoc(t, e, i, s) {
    await this._disableCadConfigurations();
    const r = Oe.Network, o = await this._loadSubtreePrologue(r, t, !0), a = await this._treeLoader.loadByXmlDoc(s, o, e, i);
    return this._loadSubtreeEpilogue(a, !1);
  }
  async loadSubtreeFromScsXmlFile(t, e, i, s) {
    await this._disableCadConfigurations();
    const r = Oe.Scs, o = await this._loadSubtreePrologue(r, t, !0), a = wu(i), l = await this._treeLoader.loadByXmlFile(s, o, e, a);
    return this._loadSubtreeEpilogue(l, !1);
  }
  async loadSubtreeFromScsXmlDoc(t, e, i, s) {
    await this._disableCadConfigurations();
    const r = Oe.Scs, o = await this._loadSubtreePrologue(r, t, !0), a = wu(i), l = await this._treeLoader.loadByXmlDoc(s, o, e, a);
    return this._loadSubtreeEpilogue(l, !1);
  }
  async _loadSubtreeFromStream(t, e, i, s) {
    const r = Oe.Network, o = await this._loadSubtreePrologue(r, t, i), a = await this._treeLoader.loadByStream(s, o, e);
    return this._loadSubtreeEpilogue(a, s._allowSubtreeLoadedCallback);
  }
  async loadSubtreeFromStream(t, e, i) {
    return this._loadSubtreeFromStream(t, e, !0, i);
  }
  async loadSubtreeFromScsFile(t, e, i) {
    const s = Oe.Scs, r = await this._loadSubtreePrologue(s, t, !0), o = await this._treeLoader.loadByScsFile(i, r, e);
    return this._loadSubtreeEpilogue(o, i._allowSubtreeLoadedCallback);
  }
  async loadSubtreeFromScsBuffer(t, e, i) {
    const s = Oe.Scs, r = await this._loadSubtreePrologue(s, t, !0), o = await this._treeLoader.loadByScsBuffer(i, r, e);
    return this._loadSubtreeEpilogue(o, i._allowSubtreeLoadedCallback);
  }
  /**
   * I don't think this is used at all. If so, this should be removed.
   */
  async loadSubtreeFromAssemblyData(t, e, i, s) {
    const r = Oe.Network, o = await this._loadSubtreePrologue(r, t, !0), a = await this._treeLoader.loadByAssemblyData(
      s,
      o,
      e,
      i
    );
    return this._loadSubtreeEpilogue(a, s._allowSubtreeLoadedCallback);
  }
  async loadMeasurementFromJson(t) {
    const e = Object.keys(t);
    for (const i of e) {
      const s = parseInt(i, 10);
      if (isNaN(s))
        continue;
      const r = t[s], o = parseInt(r.instance_id, 10);
      if (isNaN(o))
        continue;
      const a = await this._getNodeOrRepItemFromId(o);
      if (!(a instanceof Ke))
        continue;
      const l = r.edge_properties;
      for (let h = 0; h < l.length; h++) {
        const u = l[h], p = u.id, m = u.data;
        let g = null;
        switch (u.type) {
          case "circle":
            g = qr.fromJson(m);
            break;
          case "line":
            g = ma.fromJson(m);
            break;
          case "unknown_edge":
            g = Es.fromJson(m);
            break;
        }
        g !== null && a.setEdgeMeasurementProperty(p, g);
      }
      const c = r.face_properties;
      for (let h = 0; h < c.length; h++) {
        const u = c[h], p = u.id, m = u.data;
        let g = null;
        switch (u.type) {
          case "cylinder":
            g = Ce.fromJson(m);
            break;
          case "plane":
            g = Re.fromJson(m);
            break;
          case "cone":
            g = cr.fromJson(m);
            break;
          case "sphere":
            g = hr.fromJson(m);
            break;
          case "torus":
            g = ur.fromJson(m);
            break;
        }
        g !== null && a.setFaceMeasurementProperty(p, g);
      }
    }
  }
  async loadMeasurementFromString(t) {
    const e = JSON.parse(t);
    return this.loadMeasurementFromJson(e);
  }
  async loadMeasurementFromFile(t) {
    const e = await Xh(t, "blob");
    if (e.status !== 200)
      throw new Error(`Cannot pull measurement file '${t}': ${e.response}`);
    const s = (await Ch.loadAsync(e.response)).file("measurement.json");
    if (!s)
      throw new Error(`Cannot pull measurement data from '${t}'`);
    const r = await s.async("string");
    return this.loadMeasurementFromString(r);
  }
  async _clearImpl() {
    console.assert(!this._clearInProgress), this._clearInProgress = !0;
    try {
      await this._treeLoader.cancelActiveAttachmentProcess(), await this._treeLoader.cancelPendingLoads(), console.assert(this._treeLoader.isIdle()), console.assert(this._clearInProgress), await this._treeLoader.reset(), console.assert(this._treeLoader.isIdle()), console.assert(this._clearInProgress), await this._assemblyTree.reset(), console.assert(this._treeLoader.isIdle()), console.assert(this._clearInProgress), this._clearInProgress = !1;
    } catch (t) {
      throw console.assert(this._clearInProgress), this._clearInProgress = !1, t;
    }
  }
  clear() {
    return this._clearQueue.push(async () => (this._callbackManager.trigger("modelSwitchStart", !0), await this._clearImpl(), this._callbackManager.promiseTrigger(
      "_modelSwitched",
      "modelSwitched",
      !0,
      [],
      Di.Direct
    )));
  }
  switchToModel(t) {
    const e = t === or;
    return this._clearQueue.push(async () => {
      this._callbackManager.trigger("modelSwitchStart", !1), await this._clearImpl();
      let i;
      return e ? i = [] : i = await this._loadSubtreeFromStream(
        this.getAbsoluteRootNodeId(),
        t,
        !1,
        new mr()
      ), await this._callbackManager.promiseTrigger(
        "_modelSwitched",
        "modelSwitched",
        e,
        i,
        Di.Direct
      ), i;
    });
  }
  getAbsoluteRootNodeId() {
    return this._assemblyTree.getRootNode().getRuntimeId();
  }
  isIdValid(t) {
    return this._assemblyTree.lookupAnyNode(t) !== null;
  }
  _getNodeChildren(t, e) {
    let i = t.getChildrenSync();
    e || (i = i.filter((o) => !o.isOutOfHierarchy()));
    const s = t.getBodyInstances();
    for (const o of s)
      (!o.isOutOfHierarchy() || e) && i.push(o);
    const r = t.getPmis();
    for (const o of r)
      i.push(o);
    return i;
  }
  getChildIds(t, e) {
    const i = this._assemblyTree.lookupProductOccurrence(t);
    if (i === null)
      return [];
    const s = this._getNodeChildren(i, e), r = [];
    for (const o of s)
      r.push(o.getRuntimeId());
    return r;
  }
  isOutOfHierarchy(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    return e !== null && ks(e);
  }
  getParentId(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    if (e === null)
      return null;
    const i = Jd(e.getParent());
    return i === null ? null : i.getRuntimeId();
  }
  async getPartReferrers(t) {
    const e = this._assemblyTree.lookupProductOccurrence(t);
    if (e === null)
      return null;
    const i = this._assemblyTree.getRootNode();
    await Zc(i), await Pf(i);
    const s = e.getPartDefinitionSync();
    if (s === null)
      return null;
    const r = s.getReferrers(), o = /* @__PURE__ */ new Set();
    for (const a of r) {
      const c = a.getParent().getReferrers();
      for (const h of c)
        o.add(h.getRuntimeId());
    }
    return Array.from(o);
  }
  async getAttributes(t) {
    const e = await this._getNodeOrRepItemFromId(t);
    return e === null ? [] : e.getAttributes();
  }
  async getProperties(t, e) {
    const i = await this._getNodeOrRepItemFromId(t);
    if (i === null)
      return null;
    const s = {}, r = {}, o = [];
    let a = i.getAttributes().then((h) => {
      for (const u of h) {
        const p = u.getValueName();
        let m = u.getTitle();
        p !== null && (m !== "" ? m = m + "/" + p : m = p);
        const _ = `${u.getValue()}${u.getUnit()}`;
        s[m] = _;
      }
    });
    o.push(a);
    const l = (h) => {
      const u = this.getNetMatrix(t), p = new d(u[0], u[1], u[2]), m = this.getUnit(t), g = p.length() / m, _ = h.surfaceArea * g * g, y = h.volume * g * g * g, b = Eo(_, m);
      s["Surface Area"] = `${b}${Ig}`;
      const w = Eo(y, m);
      s.Volume = `${w}${wg}`;
      const v = Q.createFromArray(u).transform(
        h.centerOfGravity
      ), C = d.scale(v, 1 / m), k = C.x.toLocaleString(), Y = C.y.toLocaleString(), P = C.z.toLocaleString();
      s.COG = `x:${k} y:${Y} z:${P}`;
    }, c = async (h) => {
      const u = await h.value;
      if (u !== null) {
        const p = await u.getAttributes();
        for (const m of p) {
          const g = m.getValueName();
          let _ = m.getTitle();
          g !== null && (_ !== "" ? _ = _ + "/" + g : _ = g);
          const b = `${m.getValue()}${m.getUnit()}`;
          r[_] = b;
        }
      }
    };
    if (i instanceof Ke) {
      const h = i.getPhysicalProperties();
      h !== null && l(h);
    } else
      i instanceof Yt && (a = Promise.resolve(Bo(i)).then(async () => {
        const h = await i.getPhysicalProperties(e);
        h !== null && l(h);
        const u = await i.getPartDefinition();
        if (u !== null)
          return c(u);
      }), o.push(a));
    return await zt(o), { ...r, ...s };
  }
  addProperty(t, e, i, s) {
    const r = this._assemblyTree.lookupAnyNode(t);
    if (r === null)
      return !1;
    const o = new Wn(
      Jn.String,
      e,
      null,
      i,
      s
    );
    return r.addAttribute(o), !0;
  }
  setPhysicalProperties(t, e, i, s) {
    const r = this._assemblyTree.lookupRepresentationItem(t);
    if (r === null)
      return !1;
    const o = new sr(i, s, e);
    return r.setPhysicalProperties(o), !0;
  }
  getUserDataIndices(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    if (e === null)
      throw new sn(t);
    return e.getUserDataIndices();
  }
  getUserData(t, e) {
    const i = this._assemblyTree.lookupAnyTreeNode(t);
    if (i === null)
      throw new sn(t);
    return i.getUserData(e);
  }
  getInstanceIncs(t, e) {
    const i = this._assemblyTree.lookupAnyTreeNode(t);
    if (i === null)
      return console.assert(!1), [];
    const s = ks(i);
    return zo(
      i,
      e,
      s,
      /* @__PURE__ */ new Set(),
      ft.None
    );
  }
  getNodeFromInstanceInc(t, e, i, s) {
    let r = this._assemblyTree.lookupAnyBodyByInstanceInc(
      e,
      i
    );
    if (r === null) {
      const o = t ? this._rectifyParent(e, null) : this._assemblyTree.getRootNode();
      r = this._assemblyTree.createMeshInstance(
        t,
        e,
        i,
        null,
        // authored ID
        null,
        // name
        o,
        !1,
        // prevent from resetting
        s,
        !0,
        // initially visible
        !1
        // implicit body
      );
    } else
      r instanceof In && (r = r.getParent());
    return r.getRuntimeId();
  }
  _getAssociatedModelKey(t) {
    return t instanceof Ei ? t.getModelKey() : this._getAssociatedModelKey(t.getParent());
  }
  getAssociatedModelKey(t) {
    let e = this._assemblyTree.lookupAnyTreeNode(t);
    return e === null ? (e = this._assemblyTree.lookupAnyNonTreeNode(t), e === null ? null : this._getAssociatedModelKey(e)) : ke(e).getMasterModelKey();
  }
  getMatrix(t) {
    const e = this._assemblyTree.lookupAnyNode(t);
    if (e === null)
      return new Q();
    const i = e.getLocalTransform();
    return i === null ? new Q() : Q.createFromArray(i);
  }
  async setMatrix(t, e, i) {
    const s = this._assemblyTree.lookupAnyTreeNode(t);
    if (s === null)
      return;
    i ? s.setLocalTransformAsInitial(e.m) : s.overrideLocalTransform(e.m);
    const r = ks(s);
    return po(this._engine, this._callbackManager, [s], r);
  }
  setMatrices(t, e, i) {
    const s = [];
    let r = !1;
    for (let o = 0; o < t.length; o++) {
      const a = this._assemblyTree.lookupAnyTreeNode(t[o]), l = e[o];
      a !== null && (i ? a.setLocalTransformAsInitial(l.m) : a.overrideLocalTransform(l.m), r = r || ks(a), s.push(a));
    }
    return po(this._engine, this._callbackManager, s, r);
  }
  async resetToInitialMatrix(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    if (e !== null && e.hasLocalTransformOverride()) {
      e.removeLocalTransformOverride();
      const i = ks(e);
      return po(this._engine, this._callbackManager, [e], i);
    }
  }
  getNetMatrix(t) {
    const e = this._assemblyTree.lookupAnyNode(t);
    return e === null ? Xi.getIdentity() : Uo(e);
  }
  _getBodyInstanceIndexFrom(t, e, i) {
    i === void 0 && (i = {});
    const s = t.getBodyInstances();
    for (const a of s)
      if (i.value !== void 0 ? i.value++ : i.value = 0, a === e)
        return i.value;
    let r;
    const o = t.getChildrenSync();
    for (const a of o)
      if (r = this._getBodyInstanceIndexFrom(a, e, i), r !== void 0)
        return r;
  }
  async getNodeOrRepItem(t) {
    if (t instanceof Ge) {
      const e = t.getParent();
      let i, s = e;
      for (; ; ) {
        if (!(s instanceof Yt))
          return null;
        await Bo(s);
        const a = await s.getPartDefinition();
        if (a !== null) {
          i = await a.value;
          break;
        }
        s = s.getParent();
      }
      const r = this._getBodyInstanceIndexFrom(s, t), o = i.getRepresentationItems();
      return r !== void 0 && r < o.length ? o[r] : null;
    } else if (t instanceof Yt || t instanceof gi || t instanceof Ri || t instanceof Ei || t instanceof Ke)
      return t;
    return null;
  }
  async _getNodeOrRepItemFromId(t) {
    const e = this._assemblyTree.lookupAnyNode(t);
    return e === null ? null : this.getNodeOrRepItem(e);
  }
  async getPointAttributes(t, e) {
    const i = await this._getNodeOrRepItemFromId(t);
    if (i instanceof Ke) {
      const s = i.getPointAttributes(e);
      if (s !== null)
        return s.copy();
    }
    return null;
  }
  async getEdgeCount(t) {
    const e = await this._getNodeOrRepItemFromId(t);
    return e instanceof Ke ? e.getEdgeCount() : 0;
  }
  async getEdgeAttributes(t, e) {
    const i = await this._getNodeOrRepItemFromId(t);
    if (i instanceof Ke) {
      const s = i.getEdgeAttributes(e);
      if (s !== null)
        return s.copy();
    }
    return null;
  }
  async getEdgeProperty(t, e) {
    const i = await this._getNodeOrRepItemFromId(t);
    if (i instanceof Ke) {
      const s = i.getEdgeMeasurementProperty(e);
      if (s !== null)
        return s.copy();
    }
    return null;
  }
  async getFaceCount(t) {
    const e = await this._getNodeOrRepItemFromId(t);
    return e instanceof Ke ? e.getFaceCount() : 0;
  }
  async getFaceAttributes(t, e) {
    const i = await this._getNodeOrRepItemFromId(t);
    if (i instanceof Ke) {
      const s = i.getFaceAttributes(e);
      if (s != null)
        return s.copy();
    }
    return null;
  }
  async getFaceProperty(t, e) {
    const i = await this._getNodeOrRepItemFromId(t);
    if (i instanceof Ke) {
      const s = i.getFaceMeasurementProperty(e);
      if (s !== null)
        return s.copy();
    }
    return null;
  }
  setEdgeProperty(t, e, i) {
    const s = this._assemblyTree.lookupRepresentationItem(t);
    s !== null && Jy(i) && s.setEdgeMeasurementProperty(e, i);
  }
  setFaceProperty(t, e, i) {
    const s = this._assemblyTree.lookupRepresentationItem(t);
    s !== null && By(i) && s.setFaceMeasurementProperty(e, i);
  }
  getName(t) {
    const e = this._assemblyTree.lookupAnyNode(t);
    return e !== null ? e.getName() : null;
  }
  getNodeExchangeId(t) {
    const e = this._assemblyTree.lookupAnyNode(t);
    return e !== null ? e.getExchangeId() : null;
  }
  getFilters() {
    return this._assemblyTree.getFilters();
  }
  getFilterName(t) {
    return this._assemblyTree.getFilterName(t);
  }
  getFiltersWithNode(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    return e === null ? [] : this._assemblyTree.getFiltersWithNode(e);
  }
  getNodesFromFilterIds(t) {
    return this._assemblyTree.getNodesFromFilterIds(t);
  }
  getLayers() {
    return this._assemblyTree.getLayers();
  }
  getUniqueLayerNames() {
    return this._assemblyTree.getUniqueLayerNames();
  }
  getLayerName(t) {
    return this._assemblyTree.getLayerName(t);
  }
  getLayerIdsFromName(t) {
    return this._assemblyTree.getLayersIdFromName(t);
  }
  getNodeLayerId(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    if (e === null)
      return null;
    const i = e.getAuthoredLayerId();
    return i === null ? null : gn(e).getRuntimeLayerId(i);
  }
  getAuthoredNodesFromLayer(t, e) {
    const i = this._assemblyTree.getNodesFromLayer(t, e);
    return i === null ? null : i.map((s) => s.getAuthoredId());
  }
  getAuthoredNodesFromLayers(t, e) {
    const i = this._assemblyTree.getNodesFromLayers(t, e);
    return i === null ? null : i.map((s) => s.getAuthoredId());
  }
  getRuntimeNodesFromLayer(t, e) {
    const i = this._assemblyTree.getNodesFromLayer(t, e);
    return i === null ? null : i.map((s) => s.getRuntimeId());
  }
  getRuntimeNodesFromLayers(t, e) {
    const i = this._assemblyTree.getNodesFromLayers(t, e);
    return i === null ? null : i.map((s) => s.getRuntimeId());
  }
  getRuntimeNodesFromLayerName(t, e) {
    const i = this._assemblyTree.getNodesFromLayerName(t, e);
    return i === null ? null : i.map((s) => s.getRuntimeId());
  }
  createCadView(t, e, i, s, r, o, a, l, c) {
    if (this._assemblyTree.lookupProductOccurrence(t) === null)
      return null;
    const u = this._assemblyTree.lookupProductOccurrence(t);
    if (u === null)
      return null;
    const p = [];
    for (const _ of s) {
      const y = this._assemblyTree.lookupPmi(_);
      y !== null && p.push(y);
    }
    const m = /* @__PURE__ */ new Map();
    for (const [_, y] of a)
      m.set(_, y.m);
    return this._assemblyTree.createCadView(
      this._engine,
      u,
      e,
      i,
      p,
      r,
      o,
      m,
      l,
      c
    ).getRuntimeId();
  }
  getCadViewMap() {
    const t = this._assemblyTree.getFirstProductOccurrenceWithView(), e = /* @__PURE__ */ new Map();
    return this._assemblyTree.forEachCadView((i) => {
      const s = i.getRuntimeId(), r = i.getParent();
      let o;
      r === t ? o = i.getName() || "(null)" : o = `${r.getName()} - ${i.getName()}`, e.set(s, o);
    }), e;
  }
  async activateCadView(t, e, i) {
    if (this._assemblyTree.hasActiveCadView())
      return await this._assemblyTree.deactivateActiveCadView(), this.activateCadView(t, e, i);
    const s = this._assemblyTree.lookupCadView(t);
    if (s !== null)
      return this._assemblyTree.activateCadView(s, e, i);
  }
  getCadViewPmis(t) {
    const e = this._assemblyTree.lookupCadView(t);
    if (e === null)
      return [];
    const i = [], s = this._assemblyTree.getCadViewPmis(e);
    for (const r of s)
      i.push(r.getRuntimeId());
    return i;
  }
  async _disableCadConfigurations() {
    this._cadConfigurationsEnabled = !1, await this._assemblyTree.deactivateActiveCadView();
  }
  async cadConfigurationsEnabled() {
    return this._cadConfigurationsEnabled && this._assemblyTree.seenExternalModel() && await this._disableCadConfigurations(), this._cadConfigurationsEnabled;
  }
  getCadConfigurations() {
    const t = {};
    return this._assemblyTree.forEachCadConfiguration((e) => {
      const i = e.getRuntimeId(), s = e.getName() || "(null)";
      t[i] = s;
    }), t;
  }
  getDefaultCadConfiguration() {
    const t = this._assemblyTree.getDefaultCadConfiguration();
    return t !== null ? t.getRuntimeId() : null;
  }
  getActiveCadConfiguration() {
    const t = this._assemblyTree.getActiveCadConfiguration();
    return t !== null ? t.getRuntimeId() : null;
  }
  getCadViewConfiguration(t) {
    const e = this._assemblyTree.lookupCadView(t);
    if (e === null)
      return null;
    const i = e.getParent();
    return i !== null && i.isAConfigurationNode() ? i.getRuntimeId() : null;
  }
  async _activateCadConfiguration(t, e) {
    this._assemblyTree.activateCadConfiguration(t);
    const i = t.getRuntimeId(), s = this._assemblyTree.getCadConfigurations().filter((l) => l !== t).map((l) => l.getRuntimeId()), r = /* @__PURE__ */ new Map();
    r.set(i, !0), s.forEach((l) => {
      r.set(l, !1);
    }), await this.setVisibilitiesByMap(r);
    const o = await Fd(t, bt.All, !0, /* @__PURE__ */ new Set());
    e && o !== null && o.length > 0 && await this._view.fitNodes([i], Ni), this._callbackManager.trigger("configurationActivated", i);
  }
  async activateCadConfiguration(t, e) {
    const i = this._assemblyTree.lookupProductOccurrence(t);
    if (i !== null)
      return this._activateCadConfiguration(i, e);
  }
  async activateDefaultCadConfiguration(t) {
    const e = this._assemblyTree.getDefaultCadConfiguration();
    e !== null && await this._activateCadConfiguration(e, t);
  }
  getDefaultCadView() {
    const t = this._assemblyTree.getDefaultCadConfiguration(), e = this._assemblyTree.getDefaultCadView(t);
    return e !== null ? e.getRuntimeId() : null;
  }
  async activateDefaultCadView(t, e) {
    const i = this.getDefaultCadView();
    i !== null && await this.activateCadView(i, t, e);
  }
  getPmis() {
    const t = {};
    return this._assemblyTree.forEachPmi((e) => {
      const i = e.getRuntimeId(), s = e.getName() || "(null)";
      t[i] = s;
    }), t;
  }
  getPmiType(t) {
    const e = this._assemblyTree.lookupPmi(t);
    return e === null ? Ud.Unknown : e.getPmiType();
  }
  getPmiSubType(t) {
    const e = this._assemblyTree.lookupPmi(t);
    return e === null ? Qd.Unknown : e.getPmiSubType();
  }
  getUnit(t) {
    const e = this._assemblyTree.lookupAnyNode(t);
    return e instanceof Yt ? e.getMeasurementUnit() : e instanceof Ge ? e.getParent().getMeasurementUnit() : 1;
  }
  _rectifyParent(t, e) {
    if (e !== null) {
      const s = this._assemblyTree.lookupProductOccurrence(e);
      if (s !== null)
        return s;
      console.assert(!1);
    }
    const i = this._assemblyTree.getInclusionContexts(t);
    if (i.length > 0) {
      const r = i[0].getChildren();
      return console.assert(r.length > 0), r[0];
    }
    return this._assemblyTree.getRootNode();
  }
  createMeshInstance(t, e, i, s, r, o, a) {
    const l = this._rectifyParent(t, s);
    return this._assemblyTree.createMeshInstance(
      !0,
      // mark loaded
      t,
      e,
      null,
      // authored id
      i,
      l,
      r,
      o,
      !0,
      // initially visible
      a
    ).getRuntimeId();
  }
  createPmiInstance(t, e, i, s, r, o, a) {
    const l = this._rectifyParent(t, a);
    return this._assemblyTree.createPmiInstance(
      t,
      e,
      null,
      o,
      l,
      i,
      s,
      r
    ).getRuntimeId();
  }
  setVisibilitiesByMap(t, e) {
    const i = /* @__PURE__ */ new Map();
    t.forEach((a, l) => {
      const c = this._assemblyTree.lookupAnyTreeNode(l);
      c !== null && i.set(c, a);
    });
    let s = null;
    const r = this.getActiveCadConfiguration();
    r !== null && (s = this._assemblyTree.lookupProductOccurrence(r));
    const o = this._assemblyTree.getRootNode();
    return xc({
      assemblyTree: this._assemblyTree,
      engine: this._engine,
      startNode: o,
      visibilityFormatter: (a) => i.get(a),
      resetNonAffectedToDefault: !1,
      configurationNode: s !== null ? s : void 0,
      callbackManager: this._callbackManager,
      initiallyHiddenStayHidden: e
    });
  }
  setBodyNodesVisibility(t, e) {
    const i = typeof e == "boolean" ? (s) => e : e;
    return vf({
      assemblyTree: this._assemblyTree,
      engine: this._engine,
      startNode: t,
      visibilityFormatter: i,
      resetNonAffectedToDefault: !1,
      callbackManager: this._callbackManager,
      initiallyHiddenStayHidden: !1
    });
  }
  setVisibilitiesByValue(t, e, i) {
    const s = /* @__PURE__ */ new Map();
    for (const r of t)
      s.set(r, e);
    return this.setVisibilitiesByMap(
      s,
      i !== null ? i : void 0
    );
  }
  resetAllVisibilities() {
    const t = this._assemblyTree.getRootNode(), e = this._assemblyTree.getActiveCadConfiguration();
    return xc({
      assemblyTree: this._assemblyTree,
      engine: this._engine,
      startNode: t,
      visibilityFormatter: () => {
      },
      resetNonAffectedToDefault: !0,
      configurationNode: e !== null ? e : void 0,
      callbackManager: this._callbackManager
    });
  }
  async resetAllTransforms() {
    const t = this._assemblyTree.getRootNode();
    if (await Dy(t))
      return po(this._engine, this._callbackManager, [t], !1);
  }
  async reset() {
    if (this._cadConfigurationsEnabled = !0, this.isACadDrawing())
      return this._callbackManager.promiseTrigger("_resetDrawing", null);
    this._assemblyTree.hasActiveCadView() && await this._assemblyTree.deactivateActiveCadView();
    const t = [this.resetAllVisibilities(), this.resetAllTransforms()];
    await zt(t);
  }
  setPmiColor(t, e) {
    e === void 0 && (e = this.getAbsoluteRootNodeId());
    const i = this.getInstanceIncs(
      e,
      bt.PmiBody | bt.ViewFrame
    );
    i.length > 0 && (this._engine.setPartColor(i, vt.Faces, t), this._engine.setPartColor(i, vt.Lines, t));
  }
  resetPmiColor(t) {
    t === void 0 && (t = this.getAbsoluteRootNodeId());
    const e = this.getInstanceIncs(
      t,
      bt.PmiBody | bt.ViewFrame
    );
    e.length > 0 && (this._engine.unsetPartColor(e, vt.Faces), this._engine.unsetPartColor(e, vt.Lines));
  }
  getPmiTopologyReferences(t) {
    const e = this._assemblyTree.lookupPmi(t);
    return e === null ? null : e.getPmiTopologyReferences(this._assemblyTree);
  }
  createNode(t, e, i, s = null, r = !0, o = null) {
    let a = null;
    t !== null && (a = this._assemblyTree.lookupProductOccurrence(t)), a === null && (a = this._assemblyTree.getRootNode()), i !== null && !Qr(i) && (i = null);
    const l = (() => {
      if (o) {
        const u = o / a.getMeasurementUnit(), p = new Q().setScaleComponent(u, u, u);
        return s ? Q.multiply(s, p) : p;
      } else
        return s;
    })(), c = l === null ? null : l.m;
    return this._assemblyTree.createNode(
      a,
      e,
      i,
      c,
      r,
      o
    ).getRuntimeId();
  }
  async deleteNode(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    if (e !== null) {
      if (e instanceof Yt || e instanceof Ge || e instanceof gi)
        return this._assemblyTree.deleteNode(e);
      throw new Vi(
        t,
        li.ProductOccurrence,
        li.BodyInstance
      );
    }
  }
  createPart(t) {
    return this._assemblyTree.createPart(t).getRuntimeId();
  }
  setPart(t, e) {
    const i = this._assemblyTree.lookupProductOccurrence(t);
    if (i === null)
      return !1;
    const s = this._assemblyTree.lookupPartDefinition(e);
    return s === null ? !1 : (this._assemblyTree.setPart(i, s), !0);
  }
  createAndAddRepItem(t, e) {
    const i = this._assemblyTree.lookupPartDefinition(t);
    return i === null ? null : i.createRepItem(this._assemblyTree, e).getRuntimeId();
  }
  getLowestAvailableNodeId() {
    return this._assemblyTree.getLowestAvailableNodeId();
  }
  getType(t) {
    const e = this._assemblyTree.lookupAnyNode(t);
    return e === null ? At.Unknown : Df(e);
  }
  isVisible(t) {
    const e = this._assemblyTree.lookupAnyNode(t);
    return e !== null ? e.isVisible() : !1;
  }
  getBranchVisibility(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    return e !== null ? Af(e) : Pt.Hidden;
  }
  setMeshLevel(t, e) {
    const i = [];
    for (const s of t) {
      const r = this._assemblyTree.lookupAnyTreeNode(s);
      r !== null && i.push(r);
    }
    return zy(this._engine, i, e);
  }
  setEnableAutomaticUnitScaling(t) {
    this._assemblyTree.setAutomaticMeasurementUnitScaling(t);
  }
  setBehaviorInitiallyHidden(t) {
    this._assemblyTree.setInitiallyHiddenStayHidden(t);
  }
  isACadDrawing() {
    return this._assemblyTree.containsDrawings();
  }
  isMeasurable() {
    return this._assemblyTree.isMeasurable();
  }
  async isLineMeasurable(t, e) {
    const i = await this._getNodeOrRepItemFromId(t);
    return i instanceof Ke ? i.getEdgeMeasurementProperty(e) !== null : !1;
  }
  async isFaceMeasurable(t, e) {
    const i = await this._getNodeOrRepItemFromId(t);
    return i instanceof Ke ? i.getFaceMeasurementProperty(e) !== null : !1;
  }
  getModelFileNameFromNode(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    return e !== null ? ke(e).getOriginalFileName() : null;
  }
  getModelFileTypeFromNode(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    return e !== null ? ke(e).getOriginalFileType() : null;
  }
  isAnnotationView(t) {
    const e = this._assemblyTree.lookupCadView(t);
    if (e !== null)
      return e.isAnnotationView();
    throw new Vi(t, li.CadView);
  }
  isCombineStateView(t) {
    const e = this._assemblyTree.lookupCadView(t);
    if (e)
      return e.isCombineStateView();
    throw new Vi(t, li.CadView);
  }
  /** This will undo the effect of calling preventNodeDeletion() for the given node. */
  allowNodeDeletion(t) {
    const e = this._assemblyTree.lookupBodyInstance(t);
    if (e === null)
      throw new re();
    this._assemblyTree.allowNodeDeletion(e);
  }
  preventNodeDeletion(t) {
    const e = this._assemblyTree.lookupBodyInstance(t);
    if (e === null)
      throw new re();
    this._assemblyTree.preventNodeDeletion(e);
  }
  preventMeshDeletion(t) {
    this._assemblyTree.preventMeshDeletion(t);
  }
  getBounding(t, e, i, s) {
    return Od(
      this._assemblyTree,
      this._engine,
      t,
      e,
      i,
      s
    );
  }
  getIdOffset(t) {
    const e = this._assemblyTree.lookupAnyNode(t);
    if (e !== null) {
      let i;
      return e instanceof Ei ? i = e.getInclusionContextForNodeId() : e instanceof Ke ? i = e.getParent().getInclusionContextForNodeId() : i = Ne(e), i.getIdOffset();
    }
    return 0;
  }
  /**
   * Motivation for this function:
   *
   * It is possible to begin a load where some SC geometry gets streamed in
   * but the assembly tree has not been fully parsed. Suppose an SC instance
   * (A) gets streamed, and has its node parsed by the assembly tree. If the
   * user attempts to select (A), our internals will find the NodeId associated
   * with (A). This is so far okay (but not ideal perhaps). The big issue comes
   * when the user starts to query the parents or children of the node. Since
   * the entire loaded subtree has not been fully parsed, querying such things
   * may not make sense because they might not be available. (Querying other
   * things might also be problematic.)
   *
   * It might make sense to not expose this function publically (as it is today
   * in `Model`) and do all the required filtering of selection results in the
   * selection internals. This, however might be 'problematic' when loading a
   * giant model (such as the Boeing). In this case, it might take ages for the
   * tree to completely load, which would make geometry not selectable in the
   * meantime. This might be interpreted as a bug from our users because they might
   * want to highlight such selected geometries.
   *
   * Related: COM-1169
   */
  isNodeLoaded(t) {
    const e = this._assemblyTree.lookupAnyNode(t);
    if (e === null)
      throw new sn(t);
    return e.isLoaded();
  }
  shutdown() {
    this._treeLoader && this._treeLoader.cancelPendingLoads();
  }
  isReady() {
    return console.assert(this._readyPromise.state !== ds.Rejected), this._readyPromise.state !== ds.Pending;
  }
  waitForReady() {
    return this._readyPromise;
  }
  lookupAnyTreeNode(t) {
    return this._assemblyTree.lookupAnyTreeNode(t);
  }
  lookupAnyBody(t) {
    return this._assemblyTree.lookupAnyBody(t);
  }
  lookupBodyInstance(t) {
    return this._assemblyTree.lookupBodyInstance(t);
  }
  gatherInstanceIncsFromNodeIds(t, e, i) {
    return Kd(this._assemblyTree, t, e, i);
  }
  gatherInclusionKeysFromNodeIds(t) {
    return Ay(this._assemblyTree, t, ft.None);
  }
  async requestNodes(t) {
    const e = [];
    for (const i of t) {
      const s = this._assemblyTree.lookupAnyTreeNode(i);
      s !== null && e.push(s);
    }
    return this._assemblyTree.requestNodes(this._treeLoader, e, !1);
  }
  isWithinExternalModel(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    if (e === null)
      return !1;
    let i = Pn(e);
    for (; i !== null; ) {
      if (i.isExternalModelRoot())
        return !0;
      i = Pn(i.getParent());
    }
    return !1;
  }
  getNodeGenericType(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    return e !== null ? Qo(e) : null;
  }
  getNodeGenericId(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    return e !== null ? e.getGenericId() : null;
  }
  getNodesByGenericId(t) {
    const e = this._assemblyTree.getNodesByGenericId(t);
    if (e !== null) {
      const i = /* @__PURE__ */ new Set();
      return e.forEach((s) => {
        i.add(s.getRuntimeId());
      }), i;
    }
    return null;
  }
  getNodesByGenericType(t) {
    const e = this._assemblyTree.getNodesByGenericType(t);
    if (e !== null) {
      const i = /* @__PURE__ */ new Set();
      return e.forEach((s) => {
        i.add(s.getRuntimeId());
      }), i;
    }
    return null;
  }
  getGenericTypes() {
    const t = [];
    return this._assemblyTree.genericTypeToNodes().forEach((i, s) => {
      t.push(s);
    }), t;
  }
  getGenericTypeIdMap() {
    const t = /* @__PURE__ */ new Map();
    return this._assemblyTree.genericTypeToNodes().forEach((i, s) => {
      const r = /* @__PURE__ */ new Set();
      i.forEach((o) => {
        r.add(o.getRuntimeId());
      }), t.set(s, r);
    }), t;
  }
  hasEffectiveGenericType(t, e) {
    const i = this.lookupAnyTreeNode(t);
    if (i === null)
      throw new sn(t);
    return s_(i, e);
  }
  registerGenericId(t, e) {
    return this._assemblyTree.registerGenericGlobalId(t, e);
  }
  registerGenericType(t, e) {
    return this._assemblyTree.registerGenericType(t, e);
  }
  hasRelationships(t) {
    const e = this.lookupAnyTreeNode(t);
    if (e === null)
      throw new sn(t);
    return Ne(e).getRelationships().length > 0;
  }
  getBimIdFromNode(t) {
    const e = this.lookupAnyTreeNode(t);
    return e === null || !e.hasAuthoredId() ? null : e.getAuthoredId().toString();
  }
  getRuntimeNodeFromBimId(t, e) {
    const i = this.lookupAnyTreeNode(t);
    return i === null ? null : Ne(i).getRuntimeNodeFromBimId(e);
  }
  getRelationsByTypeFromNode(t, e) {
    return this._assemblyTree.getRelationshipsOfItem(t, e);
  }
  firstAssemblyDataHeader() {
    return this._treeLoader.firstAssemblyDataHeader();
  }
  setPrefetchScsCutoffScale(t) {
    this._treeLoader.setPrefetchScsCutoffScale(t);
  }
  getAllRelationships(t) {
    const e = this.lookupAnyTreeNode(t);
    return e === null ? [] : Ne(e).getRelationships();
  }
  getAllBimInfos(t) {
    const e = this.lookupAnyTreeNode(t);
    return e === null ? [] : Ne(e).getBimInfos();
  }
  getInfoOfBimId(t, e) {
    const i = this.getAllBimInfos(t);
    for (const s of i)
      if (s.id === e) {
        let r = s.name, o = !1;
        if (s.category === Gs.Connected) {
          const a = this.getRuntimeNodeFromBimId(t, e);
          a !== null && this.getName(a) !== null && (r = this.getName(a), o = !0);
        }
        return { name: r, connected: o };
      }
    return { name: "", connected: !1 };
  }
  indexOfBimInfo(t, e) {
    let i = 0;
    for (const s of t) {
      if (e === s.type)
        return i;
      i++;
    }
    return -1;
  }
  getBimIdRelationshipTypes(t, e) {
    const i = [], s = this.lookupAnyTreeNode(t);
    if (s === null)
      return [];
    const o = Ne(s).getRelationships();
    for (const a of o)
      if (a.relating !== null && a.relating.relationElt.id === e) {
        const l = this.indexOfBimInfo(i, a.type);
        if (l < 0) {
          const c = [];
          if (a.related !== null)
            for (const h of a.related.relationships)
              c.push(h.id);
          i.push({
            type: a.type,
            relateds: c,
            relatings: []
          });
        } else if (a.related !== null)
          for (const c of a.related.relationships)
            i[l].relateds.indexOf(c.id) < 0 && i[l].relateds.push(c.id);
      } else if (a.related !== null) {
        for (const l of a.related.relationships)
          if (l.id === e) {
            const c = this.indexOfBimInfo(i, a.type);
            a.relating !== null && (c < 0 ? i.push({
              type: a.type,
              relateds: [],
              relatings: [a.relating.relationElt.id]
            }) : i[c].relatings.push(a.relating.relationElt.id));
          }
      }
    return i;
  }
}
class jy {
  constructor(t) {
    this._engine = t;
  }
  getIdentityInc() {
    return this._identityInc;
  }
  // SC does not guarante an identity matrix to be created on the client
  // XXX: We should probably just reserve Matrix Inc (0, 1) for an eternal identity matrix in SC C++ code.
  async init() {
    const t = await this._engine.createIdentityMatrix();
    this._identityInc = t;
  }
}
function Hy(n, t) {
  const e = [];
  for (let i = 0; i < n.length; i += t)
    e.push(n.slice(i, i + t));
  return e;
}
function uc(n, t, e) {
  if (n.selectionMask === Xt.None)
    throw new Mt("selectionMask is None");
  return {
    ...n,
    cullSuboptimalEntities: t,
    enableOcclusionChecks: t,
    restrictLinesAndPointsToSelectedFaceInstances: e ? !1 : n.restrictLinesAndPointsToSelectedFaceInstances
  };
}
function Uy(n) {
  let t = Number.POSITIVE_INFINITY, e = Number.POSITIVE_INFINITY, i = null;
  for (const s of n)
    if (s.length > 0) {
      const r = s[0];
      r.radialMetric < t ? (t = r.radialMetric, e = r.zMetric, i = s) : r.radialMetric === t && r.zMetric < e && (e = r.zMetric, i = s);
    }
  return i;
}
function Qy(n, t, e, i) {
  const s = t !== null ? t.entities : [], r = e !== null ? e.entities : [], o = i !== null ? i.entities : [], a = [s, r, o];
  for (; ; ) {
    const l = Uy(a);
    if (l === null) {
      console.assert(s.length === 0), console.assert(r.length === 0), console.assert(o.length === 0);
      return;
    }
    console.assert(l.length > 0);
    let c;
    if (l === s) {
      const h = s.pop();
      c = Oh(h);
    } else if (l === r) {
      const h = r.pop();
      c = Ah(h);
    } else {
      console.assert(l === o);
      const h = o.pop();
      c = Hr(h, !0);
    }
    n.push(c);
  }
}
function Hr(n, t) {
  const e = d.createFromArray(n.rayPoint), i = d.createFromArray(n.normal), s = new d(n.bounding.min[0], n.bounding.min[1], n.bounding.min[2]), r = new d(n.bounding.max[0], n.bounding.max[1], n.bounding.max[2]), o = new ni(s, r), a = new Pa(
    e,
    i,
    n.elementIndex,
    n.overlayIndex,
    n.elementBits,
    o,
    t
  ), l = n.instanceInc;
  return de.create(l[1], l[0], a, null, null);
}
function Oh(n) {
  const t = new d(n.bounding.min[0], n.bounding.min[1], n.bounding.min[2]), e = new d(n.bounding.max[0], n.bounding.max[1], n.bounding.max[2]), i = new ni(t, e), s = new Ga(
    n.elementIndex,
    d.createFromArray(n.point),
    n.lineSegmentVertices,
    n.bestLineSegmentVertexIndex,
    i,
    n.overlayIndex,
    n.elementBits
  ), r = n.instanceInc;
  return de.create(r[1], r[0], null, s, null);
}
function Ah(n) {
  const t = new Ya(
    d.createFromArray(n.point),
    n.elementIndex,
    n.overlayIndex,
    n.elementBits
  ), e = n.instanceInc;
  return de.create(e[1], e[0], null, null, t);
}
function vu(n) {
  if (n.point !== null) {
    const t = n.point.entities[0];
    return Ah(t);
  }
  if (n.line !== null) {
    const t = n.line.entities[0];
    return Oh(t);
  }
  if (n.face !== null) {
    const t = n.face.entities[0];
    return Hr(t, !1);
  }
  if (n.proximityFace !== null) {
    const t = n.proximityFace.entities[0];
    return Hr(t, !0);
  }
  return null;
}
function Su(n) {
  let t = null;
  if (n.face !== null) {
    const s = n.face.entities[0];
    t = Hr(s, !1);
  } else if (n.proximityFace !== null) {
    const s = n.proximityFace.entities[0];
    t = Hr(s, !0);
  }
  let e = null;
  if (n.line !== null) {
    const s = n.line.entities[0];
    e = Oh(s);
  }
  let i = null;
  if (n.point !== null) {
    const s = n.point.entities[0];
    i = Ah(s);
  }
  return new Ml(t, e, i);
}
function xu(n) {
  const t = [];
  if (n.face !== null)
    for (const e of n.face.entities) {
      const i = Hr(e, !1);
      t.push(i);
    }
  return Qy(t, n.line, n.point, n.proximityFace), t;
}
class qy {
  constructor(t) {
    this._pickTolerance = 20, this._incrementalChunkedItems = /* @__PURE__ */ new Map(), this._sc = t;
  }
  setPickTolerance(t) {
    this._pickTolerance = t;
  }
  getPickTolerance() {
    return this._pickTolerance;
  }
  async beginScreenAreaSelection(t, e, i) {
    const s = i;
    let r;
    try {
      r = await this._sc.beginScreenAreaSelection(
        t.x,
        t.y,
        e.x,
        e.y,
        s
      );
    } catch (o) {
      throw $s(o) && o.scFunction === "beginScreenAreaSelection" ? new as() : o;
    }
    return new wo(r);
  }
  async beginRayDrillSelection(t, e, i) {
    const s = i;
    let r;
    try {
      r = await this._sc.beginRayDrillSelection(
        t.x,
        t.y,
        e,
        s
      );
    } catch (o) {
      throw $s(o) && o.scFunction === "beginRayDrillSelection" ? new as() : o;
    }
    return new wo(r);
  }
  async beginConvexPolyhedronSelection(t, e, i) {
    const s = i, r = [];
    for (const l of t)
      r.push(l.getCoefficients());
    const o = [e.x, e.y, e.z];
    let a;
    try {
      a = await this._sc.beginConvexPolyhedronSelection(r, o, s);
    } catch (l) {
      throw $s(l) && l.scFunction === "beginConvexPolyhedronSelection" ? new as() : l;
    }
    return new wo(a);
  }
  async beginSphereSelection(t, e, i) {
    const s = i;
    let r;
    try {
      r = await this._sc.beginSphereSelection(t, e, s);
    } catch (o) {
      throw $s(o) && o.scFunction === "beginSphereSelection" ? new as() : o;
    }
    return new wo(r);
  }
  endIncrementalSelection(t) {
    this._incrementalChunkedItems.delete(t._handle), this._sc.endVolumeSelection(t._handle);
  }
  async advanceIncrementalSelection(t, e) {
    const i = this._incrementalChunkedItems.get(t._handle);
    if (i && i.length !== 0)
      return i.pop();
    let s;
    try {
      s = await this._sc.advanceVolumeSelection(
        t._handle,
        5e3
        /* Batch */
      );
    } catch (a) {
      throw $s(a) && a.scFunction === "advanceVolumeSelection" ? new as() : a;
    }
    if (s.length === 2 && s[1] === lh.Invalid)
      return e ? (await this._sc.setStreamIdleMarker(), this.advanceIncrementalSelection(t, !1)) : null;
    const r = [];
    for (let a = 0; a < s.length; a += 2) {
      const l = s[a], c = s[a + 1];
      r.push(de.create(c, l));
    }
    if (r.length <= 500)
      return r;
    const o = Hy(
      r,
      500
      /* Chunk */
    ).reverse();
    return this._incrementalChunkedItems.set(t._handle, o), o.pop();
  }
  async _screenSelectByRay(t, e, i, s) {
    const r = uc(e, i, s), o = e.selectionMask, l = e.selectionMask !== Xt.Face || e.enableProximityFaces ? this._pickTolerance : -1;
    return this._sc.screenSelectByRay(o, t.x, t.y, l, r);
  }
  async _worldSelectByRay(t, e, i) {
    const s = uc(e, i, !1), r = Il(t);
    return this._sc.worldSelectByRay(r, s);
  }
  async pickFromScreen(t, e, i) {
    const s = await this._screenSelectByRay(t, e, !0, i);
    return vu(s);
  }
  async pickAllFromScreen(t, e, i) {
    const s = await this._screenSelectByRay(t, e, !1, i);
    return xu(s);
  }
  async compositePickFromScreen(t, e, i) {
    const s = await this._screenSelectByRay(t, e, !0, i);
    return Su(s);
  }
  async pickFromRay(t, e) {
    const i = await this._worldSelectByRay(t, e, !0);
    return vu(i);
  }
  async pickAllFromRay(t, e) {
    const i = await this._worldSelectByRay(t, e, !1);
    return xu(i);
  }
  async pickCompositeFromRay(t, e) {
    const i = uc(e, !0, !1), s = Il(t), r = await this._sc.worldSelectByRay(s, i);
    return Su(r);
  }
}
class $y extends _s {
  constructor(t) {
    super(), this._position = new E(10, 10), this._nextItemPosition = E.zero(), this._statItemOffset = new E(5, 5), this._maxStatWidth = 0, this._viewer = t, this._backgroundPanel = new Ol(this._position, new E(300, 100)), this._backgroundPanel.setFillColor(it.white()), this._backgroundPanel.setStrokeWidth(0), this._statsText = new Sm();
  }
  draw() {
    this._updateBackgroundSize();
    const t = this._viewer.markupManager.getRenderer();
    t.drawRectangle(this._backgroundPanel), t.drawTexts(this._statsText);
  }
  clearStatsText() {
    this._statsText.clear(), this._nextItemPosition.assign(this._position);
  }
  setPosition(t) {
    this._position.assign(t), this._backgroundPanel.setPosition(this._position);
  }
  addStatistic(t, e) {
    const i = E.add(this._nextItemPosition, this._statItemOffset), s = `${t}: ${e}`;
    this._statsText.addString(s, i), this._nextItemPosition.y += this._statsText.getFontSize();
  }
  _updateBackgroundSize() {
    const t = this._viewer.markupManager.getRenderer(), e = this._statsText.getStrings(), i = this._statsText.getFontSize();
    for (const o of e) {
      const a = t.measureText(o.text, this._statsText);
      this._maxStatWidth = Math.max(this._maxStatWidth, a.x);
    }
    const s = 2 * this._statItemOffset.x + this._maxStatWidth, r = e.length * (i + this._statItemOffset.y);
    this._backgroundPanel.setSize(new E(s, r));
  }
}
class wp {
  constructor() {
    this.total_element_count = 0, this.total_triangle_count = 0;
  }
}
class tb {
  constructor(t, e) {
    this._statisticsDisplayHandle = null, this._statistics = new wp(), this._viewer = e, this._callbackManager = t, this._callbackManager.bind({
      frameDrawn: async () => {
        await this.update();
      }
    }), this._statisticsDisplay = new $y(this._viewer);
  }
  async update() {
    const t = await this._viewer.getStatistics();
    this._statistics = t, this._statisticsDisplay.clearStatsText();
    const e = Object.keys(this._statistics);
    for (const i of e) {
      const s = i, r = this._statistics[s];
      this._statisticsDisplay.addStatistic(s, r.toString());
    }
  }
  isShown() {
    return this._statisticsDisplayHandle !== null;
  }
  getStatistics() {
    return this._statistics;
  }
  async showDisplay() {
    this.isShown() || (await this.update(), this._statisticsDisplayHandle = this._viewer.markupManager.registerMarkup(
      this._statisticsDisplay
    ));
  }
  hideDisplay() {
    this.isShown() && (this._viewer.markupManager.unregisterMarkup(this._statisticsDisplayHandle), this._statisticsDisplayHandle = null);
  }
}
class eb {
  constructor(t, e) {
    this._engineReadyPromise = be(), this._sessionStartedPromise = be(), this._connectionlessEmpty = !1, this._uri = "ws://localhost:9999", this._streamingMode = Ps.Default, this._rendererType = qo.Client, this._meshLevel = 0, this._memoryLimit = 0, this._boundingPreviewMode = vs.All, this._streamCutoffScale = 1, this._loadFinished = !1, this._statistics = new wp(), this._cachedTriangleCount = null, this._cachedElementCount = null, this._windowSize = new E(0, 0), this._cuttingSectionToKeyMap = /* @__PURE__ */ new Map(), this._cappingQuantizationGranularity = -1e4, this._cappingFaceColor = it.createFromFloat(0.5, 0.5, 0.5), this._cappingLineColor = it.createFromFloat(0.5, 0.5, 0.5), this._cappingGeometryVisibility = !0, this._cappingNeedsUpdate = !0, this._cappingDelayTimeoutId = null, this._cappingDelay = 500, this._requestBatchCountByType = [], this._pendingRequestsByType = [], this._callbackManager = t, this._applyOptions(e);
    for (let i = 0; i < mo.Count; ++i)
      this._requestBatchCountByType.push(0), this._pendingRequestsByType.push([]);
  }
  getNetworkModelName() {
    if (console.assert(this._sessionType === Oe.Network), this._model !== void 0)
      return this._model;
    throw new re();
  }
  // Method inherited from AbstractScEngine.  Mainly used as an avenue for the AssemblyTree to log messages for debugging purposes.
  logMessage(t) {
    console.log(t);
  }
  // Method inherited from AbstractScEngine.  Used to abstract the setTimeout method as this method is not available in pure non browser based javascript environments, i.e. v8, JsCore.
  setTimeout(t, e) {
    return setTimeout(t, e);
  }
  // Method inherited from AbstractScEngine. The default Communicator implementation of this method makes use of setTimeout (see above).
  sleep(t) {
    return Ll(t);
  }
  getScsInfo() {
    return console.assert(this._sessionType === Oe.Scs), this._buffer !== void 0 ? this._buffer : /^wss?:\/\//i.test(this._uri) ? null : this._uri;
  }
  _applyOptions(t) {
    t.empty !== void 0 && (this._connectionlessEmpty = t.empty), t.endpointUri !== void 0 && (this._uri = t.endpointUri), t.model && (this._model = t.model), t.sessionToken !== void 0 && (this._sessionToken = t.sessionToken), t.buffer !== void 0 && (this._buffer = t.buffer), t.streamingMode !== void 0 && (this._streamingMode = t.streamingMode), t.rendererType !== void 0 && (this._rendererType = t.rendererType), t.defaultMeshLevel !== void 0 && (this._meshLevel = t.defaultMeshLevel), t.memoryLimit !== void 0 && (this._memoryLimit = t.memoryLimit), t.boundingPreviewMode !== void 0 && (this._boundingPreviewMode = t.boundingPreviewMode), t.streamCutoffScale !== void 0 && this._setStreamCutoffScale(t.streamCutoffScale);
  }
  start(t, e) {
    return this._canvasContainer = t, this._initOptions = e, Xo.createInstance({
      container: t,
      onReady: (i) => {
        this._onEngineReady(i);
      },
      onError: (i) => {
        this._callbackManager.trigger(
          "modelLoadFailure",
          this._model || "",
          `failed to load engine: ${i}`
        );
      },
      enginePath: e.enginePath
    }), !0;
  }
  setPickTolerance(t) {
    this._scSelectionManager.setPickTolerance(t);
  }
  getPickTolerance() {
    return this._scSelectionManager.getPickTolerance();
  }
  _onEngineReady(t) {
    this._sc = t, this._sessionType = Oe.Uninitialized, this._matrixCache = new jy(this), this._scSelectionManager = new qy(this._sc), this.resize(), this._callbackManager.bind({
      _firstBoundingReady: async () => {
        this._regenerateCapping();
      }
    }), this._sc.setEventHandler("session_started", () => {
      const e = () => (this._callbackManager.unbind(i), this._sessionStartedPromise), i = {
        _sessionStarted: () => this._onSessionStarted(),
        _assemblyTreeReady: e,
        _modelSwitched: e
      };
      this._callbackManager.bind(i), this._sessionStartedPromise.resolve(
        this._callbackManager.promiseTrigger("_sessionStarted", null)
      );
    }), this._sc.setEventHandler(
      "announce_model",
      (e, i, s) => {
        this._callbackManager.trigger("_announceModel", i, s);
      }
    ), this._sc.setEventHandler("first_instance", () => {
      this._callbackManager.trigger("_firstInstance");
    }), this._sc.setEventHandler(
      "inclusion",
      (e, i, s, r) => {
        this._callbackManager.trigger("_inclusion", i, s, r);
      }
    ), this._sc.setEventHandler(
      "remap_model",
      (e, i, s, r) => {
        this._callbackManager.trigger(
          "_remapModel",
          i,
          s,
          r
        );
      }
    ), this._sc.setEventHandler(
      "remap_inclusion",
      (e, i, s, r, o) => {
        this._callbackManager.trigger(
          "_remapInclusion",
          i,
          s,
          r,
          o
        );
      }
    ), this._sc.setEventHandler(
      "capping_idle",
      (e, i, s) => {
        this._callbackManager.trigger("cappingIdle", i, s);
      }
    ), this._sc.setEventHandler("stream_active", this._initOptions.streamingActivated), this._sc.setEventHandler("stream_idle", this._initOptions.streamingDeactivated), this._sc.setEventHandler("open_model_failed", (e, i) => {
      let s;
      switch (i.reason) {
        case "UNKNOWN_MODEL":
          s = "Unknown model";
          break;
        case "BAD_NETWORK_VERSION":
          s = "Client/Server network version mismatch";
          break;
        case "BAD_STREAM_VERSION":
        case "BAD_STORE_VERSION":
          s = "Unsupported file version";
          break;
        default:
          s = "Internal Error";
      }
      this._callbackManager.trigger("modelLoadFailure", this._model || "", s);
    }), this._sc.setEventHandler(
      "missing_model",
      (e, i, s) => {
        this._callbackManager.trigger("_missingModel", i, s), this._callbackManager.trigger("missingModel", s);
      }
    ), this._sc.setEventHandler("bad_data", (e, i) => {
      let s;
      switch (i.type) {
        case "TRUNCATED_BLOCK":
          s = "Failed to parse truncated data block.";
          break;
        case "ZFRAME_DECOMPRESS_FAILED":
          s = "Failed to decompress data.";
          break;
        case "UNMATCHED_CODE":
          s = "Unknown opcode.";
          break;
        case "STORE_VERSION_MISMATCHED":
          s = "Store version mismatched.", s += ` Expected='${i.expected}'.`, s += ` Actual='${i.actual}'.`;
          break;
        case "STREAM_VERSION_MISMATCHED":
          s = "Stream version mismatched.", s += ` Expected='${i.expected}'.`, s += ` Actual='${i.actual}'.`;
          break;
        case "PARSE_BOUNDING_TREE_FAILED":
          s = "Failed to parse bounding ";
          break;
        default:
          s = "Unknown error.";
      }
      this._callbackManager.trigger("modelLoadFailure", this._model || "", s);
    }), this._sc.setEventHandler("socket_open_failed", () => {
      this._callbackManager.trigger(
        "modelLoadFailure",
        this._model || "",
        "WebSocket connection failed."
      );
    }), this._sc.setEventHandler(
      "post_draw",
      (e, i, s, r) => {
        this._syncedCamera = s, this._statistics = i, this._initOptions.renderComplete(), this._fillStatTotalCounts();
        const o = this._fromScCamera(s);
        this._callbackManager.trigger("frameDrawn", o, r);
      }
    ), this._sc.setEventHandler(
      "priority_meta_data_sent",
      (e, i, s) => {
        this._initOptions.priorityMetaDataSent(i, s);
      }
    ), this.setAllowHighDpi(!0), this._sc.setEventHandler(
      "meta_data",
      (e, i, s, r) => {
        i < 0 && (i += 4294967296), this._callbackManager.trigger("_metaData", i, s, r);
      }
    ), this._sc.setEventHandler("draw_complete", () => {
      this._callbackManager.trigger("_drawComplete");
    }), this._sc.setEventHandler("webgl_context_lost", () => {
      this._callbackManager.trigger("webGlContextLost");
    }), this._sc.setEventHandler("websocket_connection_closed", () => {
      this._callbackManager.trigger("websocketConnectionClosed");
    }), this._initOptions.engineReady(this._sessionStartedPromise), this._engineReadyPromise.resolve();
  }
  loadFinished() {
    return this._loadFinished;
  }
  resetCachedStatistics() {
    this._cachedElementCount = null, this._cachedTriangleCount = null;
  }
  setAmbientOcclusionEnabled(t) {
    this._sc.setAmbientOcclusionEnabled(t);
  }
  setAmbientOcclusionRadius(t) {
    this._sc.setAmbientOcclusionRadius(t);
  }
  setLightingEnabled(t) {
    this._sc.setLightingEnabled(t);
  }
  _fillStatTotalCounts() {
    this._cachedElementCount !== null && this._cachedTriangleCount !== null && (this._statistics.total_element_count = this._cachedElementCount, this._statistics.total_triangle_count = this._cachedTriangleCount);
  }
  async _updateCachedStats() {
    const t = this._sc.getElementCount(), e = this._sc.getTriangleCount(), i = await Promise.all([t, e]);
    this._cachedElementCount = i[0], this._cachedTriangleCount = i[1], this._fillStatTotalCounts();
  }
  _toVector3(t) {
    return t.toArray();
  }
  startExplode(t, e) {
    this.delayCapping(), this._sc.startExplode(t, this._toVector3(e));
  }
  setExplodeMagnitude(t) {
    this._callbackManager.trigger("explode", t), this.delayCapping(), this._sc.explode(t);
  }
  stopExplode() {
    this.delayCapping(), this._sc.resetExplode();
  }
  async getStatistics(t = !1) {
    return t && !this.loadFinished() ? (await this._updateCachedStats(), this._fillStatTotalCounts(), this._statistics) : this.loadFinished() && this._cachedTriangleCount === null ? (await this._updateCachedStats(), this._fillStatTotalCounts(), this._statistics) : (this._fillStatTotalCounts(), this._statistics);
  }
  setStreamIdleMarker() {
    return this._sc.setStreamIdleMarker();
  }
  hasDepthRange(t) {
    return this._sc.MeshInstance.hasDepthRange(t);
  }
  setDepthRange(t, e, i) {
    this._sc.MeshInstance.setDepthRange(t, e, i);
  }
  unsetDepthRange(t) {
    this._sc.MeshInstance.unsetDepthRange(t);
  }
  setDefaultDepthRange(t, e) {
    this._sc.setDefaultDepthRange(t, e);
  }
  _getScPlaneArray(t) {
    const e = [];
    for (let i = 0; i < t.getCount(); i++) {
      const s = t.getPlane(i);
      if (s === null)
        continue;
      const r = [];
      s.normal.toArray(r), r[3] = s.d, e.push(r);
    }
    return e;
  }
  getCuttingSectionLimits() {
    return this._sc.cuttingSectionLimits();
  }
  async _addCuttingSection(t, e) {
    let i = Pr.Invalid;
    const s = this._getScPlaneArray(t);
    if (s.length > 0 && (i = await this._sc.addCuttingSection(s), i === Pr.Invalid)) {
      const r = e === uo.Add ? "add" : "update";
      throw new Mt(`Failed to ${r} cutting section.`);
    }
    this._cuttingSectionToKeyMap.set(t, i), e === uo.Add && this._callbackManager.trigger("addCuttingSection", t);
  }
  addCuttingSection(t) {
    return this._addCuttingSection(t, uo.Add);
  }
  async removeCuttingSection(t) {
    const e = this._cuttingSectionToKeyMap.get(t);
    if (e === void 0) {
      console.assert(!1);
      return;
    }
    if (this._cuttingSectionToKeyMap.delete(t), this._callbackManager.trigger("removeCuttingSection"), e !== Pr.Invalid)
      return this._sc.removeCuttingSections([e]);
  }
  removeAllCuttingSections() {
    return this._cuttingSectionToKeyMap.clear(), this._callbackManager.trigger("removeCuttingSection"), this._sc.removeAllCuttingSections();
  }
  async updateCuttingSection(t) {
    const e = this._cuttingSectionToKeyMap.get(t);
    if (e === void 0) {
      console.assert(!1);
      return;
    }
    if (e === Pr.Invalid)
      return this._addCuttingSection(t, uo.Update);
    const i = this._getScPlaneArray(t);
    return this._sc.replaceCuttingSection(i, e);
  }
  setCappingDelay(t) {
    this._cappingDelay = t;
  }
  enableCappingIdleCallback(t) {
    return this._sc.setCappingIdleHookEnabled(t);
  }
  getCappedInstances() {
    return this._sc.getCappedInstances();
  }
  delayCapping() {
    this._cappingDelayTimeoutId === null ? this._sc.pauseCapping() : clearTimeout(this._cappingDelayTimeoutId), this._cappingDelayTimeoutId = setTimeout(() => {
      this._cappingDelayTimeoutId = null, this._sc.resumeCapping();
    }, this._cappingDelay);
  }
  setCappingGeometryVisibility(t) {
    if (!(this._cappingGeometryVisibility === t && !this._cappingNeedsUpdate))
      if (this._cappingDelayTimeoutId !== null && (clearTimeout(this._cappingDelayTimeoutId), this._cappingDelayTimeoutId = null), this._cappingNeedsUpdate = !1, this._cappingGeometryVisibility = t, t) {
        const e = this._cappingLineColor !== null ? this._toRgba(this._cappingLineColor, 1) : [-1, -1, -1, -1], i = this._cappingFaceColor !== null ? this._toRgba(this._cappingFaceColor, 1) : [-1, -1, -1, -1];
        this._sc.enableCapping(e, i, this._cappingQuantizationGranularity);
      } else
        this._sc.disableCapping();
  }
  _regenerateCapping() {
    this._cappingNeedsUpdate = !0, this.setCappingGeometryVisibility(this._cappingGeometryVisibility);
  }
  getCappingGeometryVisibility() {
    return this._cappingGeometryVisibility;
  }
  _toRgb(t) {
    return t.toFloatArray();
  }
  _toRgba(t, e) {
    return t.toFloatArray([0, 0, 0, e]);
  }
  setCappingFaceColor(t) {
    t === null && this._cappingFaceColor === null || t !== null && this._cappingFaceColor !== null && t.equals(this._cappingFaceColor) || (t !== null ? this._cappingFaceColor = t.copy() : this._cappingFaceColor = null, this._regenerateCapping());
  }
  setCappingLineColor(t) {
    t === null && this._cappingLineColor === null || t !== null && this._cappingLineColor !== null && t.equals(this._cappingLineColor) || (t !== null ? this._cappingLineColor = t.copy() : this._cappingLineColor = null, this._regenerateCapping());
  }
  async _onSessionStarted() {
    this._sc.suspendDrawing(), this._sc.setDrawMode(Dn.Highlight), this._sc.setHighlightedInstanceFilter(xs.Colorize), this._sc.setUnhighlightedFilter(xs.None), this._sc.setHighlightMode(hh.VisibleWithFullOutline), this._sc.setAntiAliasingMode(ch.SMAA);
    const t = [];
    t.push(this._matrixCache.init()), this._regenerateCapping(), await Promise.all(t), this._initOptions.sceneReady(), this._sc.resumeDrawing();
  }
  isInit() {
    return this._sc !== void 0;
  }
  setRemoteEndpoint(t, e) {
    this._uri = t, this._model = e;
  }
  getSessionType() {
    return this._sessionType;
  }
  _awaitEmptyLoad() {
    const t = be(), e = {
      _attached: (i) => {
        this._callbackManager.unbind(e), i === lr.OfInitialEmptyModel ? t.resolve() : t.reject(new re());
      }
    };
    return this._callbackManager.bind(e), t;
  }
  async loadEmpty() {
    await this._engineReadyPromise;
    try {
      if (this._sessionType !== Oe.Uninitialized)
        throw new ts("Incompatible load types.");
      const t = this._awaitEmptyLoad();
      return this._connectionlessEmpty || this._buffer !== void 0 || this._model === void 0 ? this._sessionType = this._loadEmptyScs() : this._sessionType = this._loadEmptyNetwork(), t;
    } catch (t) {
      throw this._callbackManager.trigger("modelLoadFailure", this._model || "", t.message), t;
    }
  }
  _loadEmpty(t) {
    return console.assert(t.XHRonprogress === void 0), console.assert(t.XHRonerror === void 0), console.assert(t.XHRonloadend === void 0), t.XHRonprogress = (e) => {
      this._callbackManager.trigger("XHRonprogress", e);
    }, t.XHRonerror = (e) => {
      this._callbackManager.trigger("XHRonerror", e);
    }, t.XHRonloadend = (e, i, s) => {
      this._callbackManager.trigger("XHRonloadend", e, i, s);
    }, this._sc.load(t);
  }
  _loadEmptyScs() {
    console.assert(this._model === void 0);
    const t = {
      empty: !0
    };
    return this._streamingMode === Ps.OnDemand && (t.streamInstancesOnDemand = !0), this._loadEmpty(t);
  }
  _loadEmptyNetwork() {
    console.assert(this._model !== void 0);
    const t = {
      model: or,
      uri: this._uri,
      serverSideRendering: this._rendererType === qo.Server,
      meshLevel: this._meshLevel,
      streamCutoffScale: this._streamCutoffScale
    };
    switch (this._sessionToken !== void 0 && (t.sessionToken = this._sessionToken), this._memoryLimit > 0 && (t.limitMiB = this._memoryLimit), (this._boundingPreviewMode & vs.Model) === vs.Model && (t.streamModelBoundingPreviews = !0), (this._boundingPreviewMode & vs.Instance) === vs.Instance && (t.streamInstanceBoundingPreviews = !0), (this._boundingPreviewMode & vs.Ejected) === vs.Ejected && (t.streamEjectedBoundingPreviews = !0), this._streamingMode) {
      case Ps.OnDemand:
        t.streamInstancesOnDemand = !0;
        break;
      case Ps.All:
        t.streamCulled = !0, t.streamMetaDataOnIdle = !0;
        break;
    }
    return this._loadEmpty(t);
  }
  setProjection(t) {
    const e = this.getCamera();
    e.getProjection() !== t && (e.setProjection(t), this.setCamera(e));
  }
  getViewMatrix(t) {
    const e = t !== void 0 ? this._toCamera(t) : this._sc.getCamera();
    return Q.createFromArray(e.viewMatrix());
  }
  getProjectionMatrix(t) {
    const e = t !== void 0 ? this._toCamera(t) : this._sc.getCamera();
    return Q.createFromArray(e.projectionMatrix());
  }
  getFullCameraMatrix(t) {
    const e = t !== void 0 ? this._toCamera(t) : this._sc.getCamera();
    return Q.createFromArray(e.fullMatrix());
  }
  getSynchedViewMatrix() {
    return this._syncedCamera ? Q.createFromArray(this._syncedCamera.viewMatrix()) : new Q();
  }
  getSynchedProjectionMatrix() {
    return this._syncedCamera ? Q.createFromArray(this._syncedCamera.projectionMatrix()) : new Q();
  }
  getPrimaryModelKey() {
    return this._sc.primaryModelKey();
  }
  getPartsBounding(t, e, i) {
    return this.getBounding(t, e, !1, i);
  }
  async getDrawnPartsBounding(t) {
    const e = await this._sc.MeshInstance.getDrawnWorldSpaceBounding(t), i = new ni();
    return i.min.fromArray(e.min), i.max.fromArray(e.max), i;
  }
  async getBounding(t, e, i, s) {
    const r = await this._sc.MeshInstance.getWorldSpaceBounding(
      t,
      e,
      i,
      s
    ), o = new ni();
    return o.min.fromArray(r.min), o.max.fromArray(r.max), o;
  }
  async getLooseBounding() {
    const t = await this._sc.getLooseBounding(), e = new ni();
    return e.min.fromArray(t.min), e.max.fromArray(t.max), e;
  }
  getClientDimensions() {
    const t = this._sc.container;
    return [t.clientWidth, t.clientHeight];
  }
  async getModelBounding(t, e, i) {
    return this.getBounding([], t, e, i);
  }
  async pickFromScreen(t, e, i) {
    return this._scSelectionManager.pickFromScreen(t, e, i);
  }
  async pickAllFromScreen(t, e, i) {
    return this._scSelectionManager.pickAllFromScreen(t, e, i);
  }
  async compositePickFromScreen(t, e, i) {
    return this._scSelectionManager.compositePickFromScreen(t, e, i);
  }
  async beginScreenAreaSelection(t, e, i) {
    return this._scSelectionManager.beginScreenAreaSelection(t, e, i);
  }
  async beginRayDrillSelection(t, e, i) {
    return this._scSelectionManager.beginRayDrillSelection(t, e, i);
  }
  async beginConvexPolyhedronSelection(t, e, i) {
    return this._scSelectionManager.beginConvexPolyhedronSelection(
      t,
      e,
      i
    );
  }
  async beginSphereSelection(t, e, i) {
    return this._scSelectionManager.beginSphereSelection(t, e, i);
  }
  endIncrementalSelection(t) {
    this._scSelectionManager.endIncrementalSelection(t);
  }
  async advanceIncrementalSelection(t) {
    return this._scSelectionManager.advanceIncrementalSelection(t, !1);
  }
  flushMetaDataCache() {
    this._sc.flushMetaDataCache();
  }
  async safeGetMetaDatas(t, e) {
    const i = [];
    for (const s of e)
      i.push(t, s);
    try {
      return await this.getDataFromIds(i);
    } catch {
      return null;
    }
  }
  async safeGetMetaData(t, e) {
    const i = await this.safeGetMetaDatas(t, [e]);
    return i !== null ? i[0] : null;
  }
  async safeLoadMetaDatas(t) {
    await this.getDataFromIds(t);
  }
  getDataFromIds(t) {
    if (this._requestBatchCountByType[mo.MetaData] === 0)
      return this._getDataFromIds(t);
    const e = new Zg(t);
    return this._pendingRequestsByType[mo.MetaData].push(e), e.promise;
  }
  _getDataFromIds(t) {
    return this._sc.getMetaData(t);
  }
  pickFromRay(t, e) {
    return this._scSelectionManager.pickFromRay(t, e);
  }
  pickAllFromRay(t, e) {
    return this._scSelectionManager.pickAllFromRay(t, e);
  }
  updateCamera(t) {
    const e = t._getFlags(), i = this._sc.getCamera();
    return (e & ki.Position) === ki.Position && i.setPosition(this._toVector3(t.getPosition())), (e & ki.Target) === ki.Target && i.setTarget(this._toVector3(t.getTarget())), (e & ki.Up) === ki.Up && i.setUpVector(this._toVector3(t.getUp())), this._setCamera(i), this.getCamera();
  }
  _toProjection(t) {
    switch (t) {
      default:
      case te.Orthographic:
        return Lo.Orthographic;
      case te.Perspective:
        return Lo.Perspective;
    }
  }
  _toCamera(t) {
    const e = this._sc.getCamera();
    return e.reset(
      this._toProjection(t.getProjection()),
      this._toVector3(t.getPosition()),
      this._toVector3(t.getTarget()),
      this._toVector3(t.getUp()),
      t.getWidth(),
      t.getHeight()
    ), e.setNearLimit(t.getNearLimit()), e;
  }
  setCamera(t) {
    const e = this._toCamera(t);
    this._setCamera(e);
  }
  _setCamera(t) {
    this.delayCapping(), this._sc.setCamera(t);
  }
  markCameraAsEmpty() {
    this._sc.markCameraAsEmpty();
  }
  setInstancesMatrix(t, e) {
    this._sc.MeshInstance.setAnonymousMatrix(t, e.m);
  }
  // This implementation attempts to reduce saturation when setting large quantities of matrices in SSR (i.e. Animation System)
  // A single message containing all new matrix values is sent via setAnonymousMatrices as opposed to individual messages via setAnonymousMatrix
  setMatrices(t, e) {
    const i = [];
    for (let s = 0; s < e.length; s++)
      i.push(...e[s].m);
    this._sc.MeshInstance.setAnonymousMatrices(t, i);
  }
  highlightParts(t, e) {
    this._sc.MeshInstance.setHighlighted(t, e), this._sc.MeshInstance.setXRay(t, e);
  }
  highlightElements(t, e, i, s, r) {
    const o = this._toElementType(e);
    this._sc.MeshInstance.setElementHighlighted(
      t,
      o,
      i,
      s,
      r
    ), this._sc.MeshInstance.setElementXRay(t, o, i, s, r);
  }
  getPartHighlighted(t) {
    return this._sc.MeshInstance.getHighlighted(t);
  }
  getElementHighlighted(t, e, i) {
    return this._sc.MeshInstance.getElementHighlighted(
      t,
      this._toElementType(e),
      i
    );
  }
  setNodeHighlightColor(t, e) {
    let i;
    t ? (this._sc.setHighlightedInstanceFilter(xs.Colorize), i = this._toRgba(t, 1), this._sc.setHiddenLineHighlightedInstanceFillColor(i), this._sc.setHighlightedInstanceColor(i)) : this._sc.setHighlightedInstanceFilter(xs.None), e ? i = this._toRgba(e, 1) : i = [0, 0, 0, 0], this._sc.setHiddenLineHighlightedInstanceOutlineColor(i), this._sc.setHighlightedInstanceOutlineColor(i);
  }
  setElementHighlightColor(t, e) {
    let i;
    t ? (this._sc.setHighlightedElementFilter(xs.Colorize), i = this._toRgba(t, 1), this._sc.setHighlightedElementColor(i), this._sc.setHiddenLineHighlightedElementFillColor(i)) : this._sc.setHighlightedElementFilter(xs.None), e ? i = this._toRgba(e, 1) : i = [0, 0, 0, 0], this._sc.setHighlightedElementOutlineColor(i), this._sc.setHiddenLineHighlightedElementOutlineColor(i);
  }
  setHighlightColorizeCompression(t) {
    this._sc.setHighlightColorizeCompression(t);
  }
  async computeMinimumBodyBodyDistance(t, e) {
    if (t.length !== 2 || e.length !== 2)
      throw new Mt("Invalid instance inc.");
    const i = await this._sc.MeshInstance.computeMinimalBodyBodyDistance(t, e);
    return La(i);
  }
  async computeMininimumFaceFaceDistance(t, e, i, s) {
    if (t.length !== 2 || i.length !== 2)
      throw new Mt("Invalid instance inc.");
    const r = await this._sc.MeshInstance.computeMinimalFaceFaceDistance(
      t,
      e,
      i,
      s
    );
    return La(r);
  }
  async computeMinimumFaceRayDistance(t, e, i) {
    if (t.length !== 2)
      throw new Mt("Invalid instance inc.");
    const s = Il(i), r = await this._sc.MeshInstance.computeMinimalFaceRayDistance(t, e, s);
    return La(r);
  }
  async computeMinimumFaceLineDistance(t, e, i) {
    if (t.length !== 2)
      throw new Mt("Invalid instance inc.");
    const s = Il(i), r = await this._sc.MeshInstance.computeMinimalFaceLineDistance(t, e, s);
    return La(r);
  }
  pauseRendering(t) {
    if (this._sc.suspendDrawing(), typeof t == "function")
      try {
        t();
      } finally {
        this._sc.resumeDrawing();
      }
  }
  resumeRendering() {
    this._sc.resumeDrawing();
  }
  beginRequestBatch(t) {
    ++this._requestBatchCountByType[t];
  }
  endRequestBatch(t) {
    this._requestBatchCountByType[t] > 0 && --this._requestBatchCountByType[t], this._flushBatchedRequests(t);
  }
  _flushBatchedRequests(t) {
    const e = this._pendingRequestsByType[t];
    this._pendingRequestsByType[t] = [];
    const i = [];
    for (const s of e)
      for (const r of s.ids)
        i.push(r);
    switch (t) {
      case mo.MetaData:
        return this._flushBatchedMetaDataRequests(e, i);
      default:
        return console.assert(!1), Promise.resolve();
    }
  }
  async _flushBatchedMetaDataRequests(t, e) {
    const i = await this._getDataFromIds(e);
    let s = 0;
    for (const r of t) {
      const o = [], a = r.ids.length / 2;
      for (let l = 0; l < a; ++l) {
        const c = i[s++];
        o.push(c);
      }
      r.promise.resolve(o);
    }
    console.assert(s === i.length);
  }
  clearHighlight() {
    this._sc.unsetAllHighlighted(), this._sc.unsetAllXRay();
  }
  resetColors() {
    this._sc.unsetAllColors();
  }
  resetOpacity() {
    this._sc.unsetAllOpacity();
  }
  setPartOpacity(t, e) {
    this.pauseRendering(() => {
      this._sc.MeshInstance.setOpacity(t, Je.Faces, e), this._sc.MeshInstance.setOpacity(t, Je.Lines, e), this._sc.MeshInstance.setOpacity(t, Je.Points, e);
    });
  }
  unsetPartOpacity(t) {
    this.pauseRendering(() => {
      this._sc.MeshInstance.unsetOpacity(t, Je.Faces), this._sc.MeshInstance.unsetOpacity(t, Je.Lines), this._sc.MeshInstance.unsetOpacity(t, Je.Points);
    });
  }
  getPartOpacity(t) {
    return this._sc.MeshInstance.getOpacity(t, Je.Faces);
  }
  getEffectivePartOpacity(t, e) {
    return this._sc.MeshInstance.getEffectiveOpacity(t, this._toElementType(e));
  }
  async getPartHasTransparency(t) {
    const e = [];
    e.push(this._sc.MeshInstance.hasTransparency(t, Je.Faces)), e.push(this._sc.MeshInstance.hasTransparency(t, Je.Lines)), e.push(this._sc.MeshInstance.hasTransparency(t, Je.Points));
    const [i, s, r] = await Promise.all(e);
    for (let o = 0; o < i.length; ++o)
      i[o] || (i[o] = s[o] || r[o]);
    return i;
  }
  setPartColor(t, e, i) {
    this._sc.MeshInstance.setColor(t, this._toElementType(e), i.getFloatArray());
  }
  unsetPartColor(t, e) {
    this._sc.MeshInstance.unsetColor(t, this._toElementType(e));
  }
  getPartColor(t, e) {
    return this._sc.MeshInstance.getColor(t, this._toElementType(e)).then(
      (i) => i.map((s) => s ? it.createFromFloatArray(s) : null)
    );
  }
  async getEffectivePartColor(t, e) {
    const i = this._toElementType(e);
    return (await this._sc.MeshInstance.getEffectiveColor(t, i)).map(it.createFromFloatArray);
  }
  setPartAmbientColor(t, e, i) {
    this._sc.MeshInstance.setAmbientColor(
      t,
      this._toElementType(e),
      i.getFloatArray()
    );
  }
  setPartAmbientMix(t, e, i) {
    this._sc.MeshInstance.setAmbientMix(t, this._toElementType(e), i);
  }
  setPartEmissiveColor(t, e, i) {
    this._sc.MeshInstance.setEmissiveColor(
      t,
      this._toElementType(e),
      i.getFloatArray()
    );
  }
  unsetPartEmissiveColor(t, e) {
    this._sc.MeshInstance.unsetEmissiveColor(t, this._toElementType(e));
  }
  setPartSpecularColor(t, e, i) {
    this._sc.MeshInstance.setSpecularColor(
      t,
      this._toElementType(e),
      i.getFloatArray()
    );
  }
  unsetPartSpecularColor(t, e) {
    this._sc.MeshInstance.unsetSpecularColor(t, this._toElementType(e));
  }
  setPartSpecularIntensity(t, e, i) {
    this._sc.MeshInstance.setSpecularIntensity(t, this._toElementType(e), i);
  }
  unsetPartSpecularIntensity(t, e) {
    this._sc.MeshInstance.unsetSpecularIntensity(t, this._toElementType(e));
  }
  setElementColor(t, e, i, s, r) {
    this._sc.MeshInstance.setElementColor(
      t,
      this._toElementType(e),
      i,
      s,
      r.getFloatArray()
    );
  }
  unsetElementColor(t, e, i, s) {
    this._sc.MeshInstance.unsetElementColor(
      t,
      this._toElementType(e),
      i,
      s
    );
  }
  getElementColor(t, e, i) {
    return this._sc.MeshInstance.getElementColor(
      t,
      this._toElementType(e),
      i
    ).then((s) => s.map((r) => r ? it.createFromFloatArray(r) : null));
  }
  async getEffectiveElementColor(t, e, i) {
    const s = this._toElementType(e);
    return (await this._sc.MeshInstance.getEffectiveElementColor(t, s, i)).map(it.createFromFloatArray);
  }
  synchronizeVisibilities(t, e) {
    t.length > 0 && this._sc.MeshInstance.synchronizeVisibilities(t, e);
  }
  setPartVisibility(t, e, i) {
    t.length > 0 && this._sc.MeshInstance.setVisible(t, e, i);
  }
  setElementVisibility(t, e, i, s, r) {
    t.length > 0 && this._sc.MeshInstance.setElementVisible(
      t,
      this._toElementType(e),
      i,
      s,
      r
    );
  }
  clearElementVisibility(t, e) {
    t.length > 0 && this._sc.MeshInstance.clearElementVisible(t, this._toElementType(e));
  }
  setVisibilityByAttachment(t, e) {
    this._sc.setVisibilityByAttachment(t, e);
  }
  requestMeshInstances(t) {
    this._sc.demandMeshInstances(t);
  }
  getRendererType() {
    return this._rendererType;
  }
  _toMeshDataBuilder(t) {
    const e = t._getFaceData(), i = t._getPointData(), s = t._getPolylineData(), r = new this._sc.MeshDataBuilder();
    for (const h of e)
      r.addFace(h.vertexData, {
        normals: h.normalData,
        rgba32s: h.rgba32data,
        uvs: h.uvData,
        bits: h.bits
      });
    for (const h of i)
      r.addPoints(h.vertexData, {
        rgba32s: h.rgba32data,
        bits: h.bits
      });
    for (const h of s)
      r.addPolyline(h.vertexData, {
        rgba32s: h.rgba32data,
        bits: h.bits
      });
    let o;
    ((h) => {
      h[h.None = 0] = "None", h[h.ClockwiseWinding = 1] = "ClockwiseWinding", h[h.CounterClockwiseWinding = 2] = "CounterClockwiseWinding", h[h.TwoSided = 4] = "TwoSided", h[h.Manifold = 65536] = "Manifold";
    })(o || (o = {}));
    let a = 0;
    switch (t.getFaceWinding()) {
      case yn.Clockwise:
        a = 1;
        break;
      case yn.CounterClockwise:
        a = 2;
        break;
      case yn.Unknown:
      default:
        a = 0;
        break;
    }
    const l = t.getBackfacesEnabled() ? 4 : 0, c = t.isManifold() ? 65536 : 0;
    return r.formatBits |= a | l | c, r;
  }
  createMesh(t) {
    const e = this._toMeshDataBuilder(t);
    return this._sc.MeshData.create(e);
  }
  replaceMesh(t, e) {
    const i = this._toMeshDataBuilder(e);
    return this._sc.MeshData.replace(t, i);
  }
  destroyMeshes(t) {
    return this._sc.MeshData.destroy(t);
  }
  _toImageFormat(t) {
    switch (t) {
      case Oi.Gray8:
        return Ss.Gray8;
      case Oi.GrayAlpha16:
        return Ss.GrayAlpha16;
      case Oi.Rgb24:
        return Ss.Rgb24;
      case Oi.Rgba32:
        return Ss.Rgba32;
      case Oi.Jpeg:
        return Ss.Jpeg;
      case Oi.Png:
        return Ss.Png;
    }
  }
  _validateImage(t) {
    if (t.format === void 0)
      throw new fn("missing 'format' property");
    if (t.data === void 0)
      throw new fn("missing 'data' property");
    if ((t.format === Oi.Gray8 || t.format === Oi.GrayAlpha16 || t.format === Oi.Rgb24 || t.format === Oi.Rgba32) && (t.width === void 0 || t.width <= 0 || t.height === void 0 || t.height <= 0))
      throw new fn("uncompressed format requested but missing width or height");
  }
  async _pngImageHasAlpha(t) {
    let e;
    try {
      e = await new Promise((a, l) => {
        const c = new Image();
        c.onload = () => {
          a(c);
        }, c.onerror = () => {
          l();
        }, c.src = `data:image/png;base64, ${_g(t)}`;
      });
    } catch {
      return console.warn(
        "Unable to read PNG image to check alpha component. Will be considered with alpha."
      ), !0;
    }
    const i = document.createElement("canvas"), s = i.getContext("2d");
    if (s === null)
      return console.warn(
        "Unable to create 2d context to check alpha component. Will be considered with alpha."
      ), !0;
    i.width = e.width, i.height = e.height, s.drawImage(e, 0, 0);
    const o = s.getImageData(0, 0, e.width, e.height).data;
    for (let a = 0; a < o.length; a += 4)
      if (o[a + 3] < 255)
        return !0;
    return !1;
  }
  async createImage(t, e) {
    this._validateImage(t);
    let i = !1;
    if (t.format === Oi.Png && (i = await this._pngImageHasAlpha(t.data)), e !== void 0) {
      this._validateImage(e);
      let s = !1;
      return e.format === Oi.Png && (s = await this._pngImageHasAlpha(e.data)), this._sc.Image.create(
        this._toImageFormat(t.format),
        t.data,
        i,
        t.width,
        t.height,
        this._toImageFormat(e.format),
        e.data,
        s,
        e.width,
        e.height
      );
    } else
      return this._sc.Image.create(
        this._toImageFormat(t.format),
        t.data,
        i,
        t.width,
        t.height
      );
  }
  destroyImages(t) {
    return this._sc.Image.destroy(t);
  }
  _toTextureTiling(t) {
    switch (t) {
      default:
      case Yc.Repeat:
        return yl.Repeat;
      case Yc.Clamp:
        return yl.Clamp;
    }
  }
  _toTextureInterpolation(t) {
    return t === !1 ? gl.Off : gl.On;
  }
  _toTextureMipMapping(t) {
    return t === !1 ? fl.Off : fl.On;
  }
  _toTextureParameterization(t) {
    switch (t) {
      default:
      case _l.UV:
        return _l.UV;
    }
  }
  _toTextureModifier(t) {
    switch (t) {
      default:
      case 0:
        return Mo.None;
      case Mo.Decal:
        return Mo.Decal;
    }
  }
  async setTexture(t, e) {
    if (e.imageId === void 0)
      throw new fn("missing 'imageId' property");
    return this._sc.MeshInstance.setTexture(
      t,
      Je.Faces,
      e.imageId,
      e.matrix !== void 0 ? e.matrix.m : new Q().m,
      this._toTextureTiling(e.tiling),
      this._toTextureInterpolation(e.interpolation),
      this._toTextureMipMapping(e.mipMapping),
      this._toTextureParameterization(e.parameterization),
      this._toTextureModifier(e.modifiers)
    );
  }
  unsetTexture(t) {
    this._sc.MeshInstance.unsetTexture(t, Je.Faces);
  }
  createMatrix(t) {
    return this._sc.Matrix.create(t);
  }
  createIdentityMatrix() {
    return this._sc.Matrix.create();
  }
  async createMeshInstance(t) {
    const e = t.getMeshId();
    if (e === null)
      throw new Mt("MeshId is not set");
    let i = this._matrixCache.getIdentityInc();
    const s = [], r = t.getMatrix();
    if (r) {
      const u = this.createMatrix(r.m).then((p) => {
        i = p;
      });
      s.push(u);
    }
    const o = new it(255, 0, 0), a = this._toRgba(
      t.getFaceColor() || o,
      t.getOpacity()
    ), l = this._toRgba(
      t.getLineColor() || o,
      t.getLineOpacity()
    ), c = this._toRgba(
      t.getPointColor() || o,
      t.getPointOpacity()
    );
    await Promise.all(s);
    const h = await this._sc.MeshInstance.create(
      e,
      i,
      a,
      l,
      c,
      t.getCreationFlags(),
      t.getOverlayIndex()
    );
    return this._callbackManager.trigger("_geometryCreated", h), h;
  }
  destroyLocalInstances(t) {
    return this._sc.MeshInstance.destroy(t);
  }
  _fromScCamera(t) {
    let e = te.Orthographic;
    return t.projection() === te.Perspective && (e = te.Perspective), ci.create(
      d.createFromArray(t.position()),
      d.createFromArray(t.target()),
      d.createFromArray(t.upVector()),
      e,
      t.fieldWidth(),
      t.fieldHeight(),
      t.nearLimit()
    );
  }
  async getCameraPromise() {
    const t = await this._sc.getCameraPromise();
    return this._fromScCamera(t);
  }
  getCamera() {
    const t = this._sc.getCamera();
    return this._fromScCamera(t);
  }
  resize() {
    this._sc.onResize(), this._windowSize.set(this._canvasContainer.offsetWidth, this._canvasContainer.offsetHeight);
  }
  setFaceVisibility(t) {
    this._sc.setFacesVisible(t);
  }
  setLineVisibility(t) {
    this._sc.setLinesVisible(t);
  }
  getCanvasSize() {
    return this._windowSize.copy();
  }
  setBackgroundGradient(t, e) {
    this._sc.setBackgroundGradient(
      t ? this._toRgba(t, 1) : [0, 0, 0, 0],
      e ? this._toRgba(e, 1) : [0, 0, 0, 0]
    );
  }
  setBoundingPreviewUnderDrawColor(t) {
    this._sc.setBoundingPreviewUnderdrawColor(this._toRgba(t, 0.7));
  }
  setBoundingPreviewTestedColor(t) {
    this._sc.setBoundingPreviewTestedColor(this._toRgba(t, 0.7));
  }
  setBoundingPreviewEjectedColor(t) {
    this._sc.setBoundingPreviewEjectedColor(this._toRgba(t, 0.7));
  }
  setBoundingPreviewUnderDraw(t) {
    this._sc.setBoundingPreviewUnderdraw(
      t.reduce((e, i) => (e.push(this._toVector3(i.min), this._toVector3(i.max)), e), [])
    );
  }
  setBoundingDebugLevel(t) {
    this._sc.setBoundingDebugLevel(t);
  }
  setBoundingPreviewTested(t) {
    this._sc.setBoundingPreviewTested(
      t.reduce((e, i) => (e.push(this._toVector3(i.min), this._toVector3(i.max)), e), [])
    );
  }
  setBoundingPreviewEjected(t) {
    this._sc.setBoundingPreviewEjected(
      t.reduce((e, i) => (e.push(this._toVector3(i.min), this._toVector3(i.max)), e), [])
    );
  }
  setServerRenderQuality(t, e, i, s) {
    this._sc.setSsrQuality({
      jpegQualityLow: t,
      jpegQualityHigh: e,
      scaleLow: i,
      scaleHigh: s
    });
  }
  setMinimumFramerate(t) {
    this._sc.setMinFrameRate(t);
  }
  getMinimumFramerate() {
    return this._sc.getMinFrameRate();
  }
  setBackFacesVisible(t) {
    this._sc.setBackFacesVisible(t);
  }
  setDrawMode(t) {
    this._sc.setDrawMode(t);
  }
  enableHiddenLineRendering(t) {
    this.setDrawMode(Dn.HiddenLine), this._sc.setHiddenLineVisibleLineColor(
      this._toRgba(t.getVisibleLineColor(), t.getVisibleLineOpacity())
    ), this._sc.setHiddenLineHiddenLineColor(
      this._toRgba(t.getObscuredLineColor(), t.getObscuredLineOpacity())
    );
  }
  setAntiAliasingMode(t) {
    this._sc.setAntiAliasingMode(t);
  }
  setInstanceModifier(t, e, i) {
    switch (t) {
      case Fe.DoNotCut:
        this._sc.MeshInstance.setDoNotCut(e, i);
        break;
      case Fe.DoNotExplode:
        this._sc.MeshInstance.setDoNotExplode(e, i);
        break;
      case Fe.DoNotSelect:
        this._sc.MeshInstance.setDoNotSelect(e, i);
        break;
      case Fe.SuppressCameraScale:
        this._sc.MeshInstance.setSuppressCameraScale(e, i);
        break;
      case Fe.OverrideSceneVisibility:
        this._sc.MeshInstance.setOverrideSceneVisibility(e, i);
        break;
      case Fe.DoNotLight:
        this._sc.MeshInstance.setDoNotLight(e, i);
        break;
      case Fe.DoNotOutlineHighlight:
        this._sc.MeshInstance.setDoNotOutlineHighlight(e, i);
        break;
      case Fe.ExcludeBounding:
        this._sc.MeshInstance.setExcludeBounding(e, i);
        break;
      case Fe.DoNotUseVertexColors:
        this._sc.MeshInstance.setDoNotUseVertexColors(e, i);
        break;
      case Fe.AlwaysDraw:
        this._sc.MeshInstance.setAlwaysDraw(e, i);
        break;
      case Fe.DoNotXRay:
        this._sc.MeshInstance.setDoNotXRay(e, i);
        break;
      case Fe.ScreenOriented:
        this._sc.MeshInstance.setScreenOriented(e, i);
        break;
      case Fe.ScreenSpace:
        this._sc.MeshInstance.setScreenSpace(e, i);
        break;
      case Fe.ScreenSpaceStretched:
        this._sc.MeshInstance.setScreenSpaceStretched(e, i);
        break;
    }
  }
  attachModel(t, e, i, s, r) {
    const o = [e, i];
    return this._attachModels(t, [o], s, r);
  }
  attachScsModelByKey(t, e, i, s, r) {
    return console.assert(this._sessionType === Oe.Scs), this._sc.attachScsModelByKey(
      t,
      i,
      e,
      s,
      r
    );
  }
  async _attachModels(t, e, i, s) {
    await this._sc.attachModels(
      t,
      e,
      i,
      s
    ), this._callbackManager.trigger("_attached", t);
  }
  async attachScsBuffer(t, e, i, s, r, o, a) {
    await this._sc.attachScsBuffer(
      t,
      e,
      i,
      s,
      r,
      o,
      a
    ), this._callbackManager.trigger("_attached", t);
  }
  feedScsBuffer(t, e) {
    this._sc.feedScsBuffer(t, e);
  }
  _parseKeyInfo(t, e, i) {
    if (t || e)
      return i;
    const s = /* @__PURE__ */ new Map();
    for (let r = 0; r < i.length; ++r) {
      const o = i[r++], a = [];
      for (; r < i.length && i[r] !== Ji.Invalid; ++r)
        a.push(i[r]);
      s.set(o, a);
    }
    return s;
  }
  async instanceKeyInfo(t, e, i) {
    const s = e === wl.Model, r = i === vl.KeyCountOnly, o = await this._sc.meshInstanceKeyInfo(t, s, r);
    return this._parseKeyInfo(s, r, o);
  }
  async metaDataKeyInfo(t, e, i) {
    const s = await this._sc.metaDataKeyInfo(t, e, i);
    return this._parseKeyInfo(e, i, s);
  }
  modelKeysFromInclusionKeys(t) {
    return this._sc.modelKeysFromInclusionKeys(t);
  }
  detachInclusions(t) {
    return this._sc.detachInclusions(t);
  }
  async resetToEmpty(t, e) {
    for (let i = 0; i < this._requestBatchCountByType.length; ++i) {
      this._requestBatchCountByType[i] = 0;
      for (const s of this._pendingRequestsByType[i])
        s.promise.reject(s.ids);
      this._pendingRequestsByType[i].length = 0;
    }
    await this._sc.resetToEmpty(t, e), this.flushMetaDataCache();
  }
  setDrawStrategy(t) {
    console.warn(
      "This API has been deactivated for lack of stability it is recommended not to use it"
    ), this._sc.setDrawStrategy(t);
  }
  redraw() {
    this._sc.queueRedraw();
  }
  disconnectNetwork() {
    this._sc.disconnectNetwork();
  }
  shutdown() {
    this._cappingDelayTimeoutId !== null && (clearTimeout(this._cappingDelayTimeoutId), this._cappingDelayTimeoutId = null), this._sessionType = Oe.Uninitialized, this._sc.shutDown();
  }
  getVersionString() {
    return this._sc.getStreamVersion().toString();
  }
  setAllowHighDpi(t) {
    this._sc.allowHighDpi = t, this.resize();
  }
  getAllowHighDpi() {
    return this._sc.allowHighDpi;
  }
  setMeshLevel(t, e) {
    this._sc.MeshInstance.setMeshLevel(t, e);
  }
  setMetallicRoughness(t, e, i) {
    this._sc.MeshInstance.setMetallicRoughness(t, e, i);
  }
  setMetallicRoughnessMaterialOverride(t, e) {
    this._sc.setMetallicRoughnessMaterialOverride(t, e);
  }
  async getMetallicRoughness(t) {
    const e = await this._sc.MeshInstance.getMetallicRoughness(t), i = [];
    for (let s = 0; s < e.length; s += 2) {
      if (e[s] < 0 || e[s + 1] < 0) {
        i.push(null);
        continue;
      }
      i.push({
        metallic: e[s],
        roughness: e[s + 1]
      });
    }
    return i;
  }
  unsetMetallicRoughness(t) {
    this._sc.MeshInstance.unsetMetallicRoughness(t);
  }
  setOverlayVisibility(t, e) {
    this._sc.Overlay.setVisible(t, e);
  }
  setOverlayCamera(t, e) {
    const i = this._toCamera(e);
    this._sc.Overlay.setCamera(t, i);
  }
  destroyOverlay(t) {
    this._sc.Overlay.destroy(t);
  }
  _overlayUnit(t) {
    switch (t) {
      case Bt.ProportionOfCanvas:
        return Gr.ProportionOfScreen;
      case Bt.MinimumProportionOfCanvas:
        return Gr.MinimumProportionOfScreen;
      case Bt.ProportionOfOtherDimension:
        return Gr.ProportionOfOtherDimension;
      default:
        return Gr.Pixels;
    }
  }
  getMaxOverlayIndex() {
    return this._sc.Overlay.maxIndex();
  }
  _overlayAnchor(t) {
    switch (t) {
      case Jt.BottomCenter:
        return kn.BottomCenter;
      case Jt.Center:
        return kn.Center;
      case Jt.LeftCenter:
        return kn.LeftCenter;
      case Jt.LowerLeftCorner:
        return kn.LowerLeftCorner;
      case Jt.LowerRightCorner:
        return kn.LowerRightCorner;
      case Jt.RightCenter:
        return kn.RightCenter;
      case Jt.TopCenter:
        return kn.TopCenter;
      case Jt.UpperRightCorner:
        return kn.UpperRightCorner;
      default:
        return kn.UpperLeftCorner;
    }
  }
  setOverlayViewport(t, e, i, s, r, o, a, l, c, h) {
    this._sc.Overlay.setViewport(
      t,
      this._overlayAnchor(e),
      i,
      this._overlayUnit(s),
      r,
      this._overlayUnit(o),
      a,
      this._overlayUnit(l),
      c,
      this._overlayUnit(h)
    );
  }
  addNodesToOverlay(t, e) {
    this._sc.MeshInstance.setOverlayIndex(t, e);
  }
  getInstancesMeshData(t) {
    return this._sc.MeshInstance.getMeshData(t);
  }
  getInstancesCappingMeshData(t) {
    return this._sc.MeshInstance.getCappingMeshData(t);
  }
  getMeshData(t) {
    return this._sc.MeshData.getData(t);
  }
  _toElementType(t) {
    switch (t) {
      case vt.Faces:
        return Je.Faces;
      case vt.Lines:
        return Je.Lines;
      case vt.Points:
        return Je.Points;
    }
  }
  _toXRayGroup(t) {
    switch (t) {
      case ta.Selected:
        return bl.Selected;
      case ta.Unselected:
        return bl.Unselected;
    }
  }
  setXRayColor(t, e, i) {
    this._sc.setXRayMaterial(
      this._toXRayGroup(t),
      this._toElementType(e),
      this._toRgba(i, 1)
    );
  }
  unsetXRayColor(t, e) {
    return this._sc.unsetXRayMaterial(this._toXRayGroup(t), this._toElementType(e));
  }
  setXRayOpacity(t, e) {
    e !== void 0 ? this._sc.setXRayOpacity(this._toElementType(e), t) : (this._sc.setXRayOpacity(Je.Faces, t), this._sc.setXRayOpacity(Je.Lines, t), this._sc.setXRayOpacity(Je.Points, t));
  }
  setXRayTransparencyMode(t) {
    this._sc.setXRayTransparencyMode(t);
  }
  setGoochBlue(t) {
    this._sc.setGoochBlue(t);
  }
  setGoochBaseColorProminence(t) {
    this._sc.setGoochBaseColorProminence(t);
  }
  setGoochYellow(t) {
    this._sc.setGoochYellow(t);
  }
  setGoochLuminanceShiftStrength(t) {
    this._sc.setGoochLuminanceShiftStrength(t);
  }
  setToonShadingBandCount(t) {
    this._sc.setToonBandCount(t);
  }
  setToonShadingSpecularFactor(t) {
    this._sc.setToonSpecularFactor(t);
  }
  setTransparencyMode(t) {
    this._sc.setTransparencyMode(t);
  }
  setPointSize(t, e) {
    this._sc.setPointSize(t, e);
  }
  async getPointSize() {
    const t = await Promise.all([this._sc.getPointSize(), this._sc.getPointSizeUnit()]);
    return [t[0], t[1]];
  }
  setPointShape(t) {
    this._sc.setPointShape(t);
  }
  async getPointShape() {
    return await this._sc.getPointShape();
  }
  setEyeDomeLightingEnabled(t) {
    this._sc.setEyeDomeLightingEnabled(t);
  }
  getEyeDomeLightingEnabled() {
    return this._sc.getEyeDomeLightingEnabled();
  }
  setEyeDomeLightingBlurSamples(t) {
    this._sc.setEyeDomeLightingBlurSamples(t);
  }
  getEyeDomeLightingBlurSamples() {
    return this._sc.getEyeDomeLightingBlurSamples();
  }
  setEyeDomeLightingBlurInterval(t) {
    this._sc.setEyeDomeLightingBlurInterval(t);
  }
  getEyeDomeLightingBlurInterval() {
    return this._sc.getEyeDomeLightingBlurInterval();
  }
  setEyeDomeLightingBlurEdgeDistance(t) {
    this._sc.setEyeDomeLightingBlurEdgeDistance(t);
  }
  getEyeDomeLightingBlurEdgeDistance() {
    return this._sc.getEyeDomeLightingBlurEdgeDistance();
  }
  setEyeDomeLightingShadingEdgeDistance(t) {
    this._sc.setEyeDomeLightingShadingEdgeDistance(t);
  }
  getEyeDomeLightingShadingEdgeDistance() {
    return this._sc.getEyeDomeLightingShadingEdgeDistance();
  }
  setEyeDomeLightingOpacity(t) {
    this._sc.setEyeDomeLightingOpacity(t);
  }
  getEyeDomeLightingOpacity() {
    return this._sc.getEyeDomeLightingOpacity();
  }
  setDisplayIncompleteFrames(t) {
    this._sc.setDisplayIncompleteFrames(t);
  }
  setInteractiveDrawDelay(t) {
    this._sc.setPostInputDelay(t);
  }
  setInteractiveDrawLimitIncreaseEnabled(t) {
    this._sc.setInteractiveDrawLimitIncreaseEnabled(t);
  }
  getInteractiveDrawLimitIncreaseEnabled() {
    return this._sc.getInteractiveDrawLimitIncreaseEnabled();
  }
  setCullingVector(t, e, i, s) {
    this._sc.MeshInstance.setCullingVector(
      t,
      e,
      [i.x, i.y, i.z],
      s
    );
  }
  unsetCullingVector(t) {
    this._sc.MeshInstance.unsetCullingVector(t);
  }
  async getCullingVector(t) {
    const e = await this._sc.MeshInstance.getCullingVector(t), i = [];
    for (const s of e)
      s.vector[0] === 0 && s.vector[1] === 0 && s.vector[2] === 0 ? i.push(null) : i.push({
        space: s.space,
        vector: d.createFromArray(s.vector),
        toleranceDegrees: s.toleranceDegrees
      });
    return i;
  }
  _setStreamCutoffScale(t) {
    this._streamCutoffScale = Math.max(0, Math.min(t, 2));
  }
  setStreamCutoffScale(t) {
    this._setStreamCutoffScale(t), this._sc.setStreamCutoffScale(this._streamCutoffScale);
  }
  getStreamCutoffScale() {
    return this._streamCutoffScale;
  }
  loseWebGlContext() {
    return this._sc._loseWebGlContext();
  }
  triangulatePolygon(t, e) {
    const i = this._sc.triangulatePolygon(t, e);
    return new Float32Array(i);
  }
  debug_log(t) {
    return this._sc.debug_log(t);
  }
  debug_stateFailure(t) {
    return this._sc.debug_stateFailure(t);
  }
  debug_sync() {
    return this._sc.debug_sync();
  }
  setLinePattern(t, e, i, s) {
    this._sc.MeshInstance.setLinePattern(t, e, i, s);
  }
  unsetLinePattern(t) {
    this._sc.MeshInstance.unsetLinePattern(t);
  }
  async createFloorplanMesh(t) {
    return this._sc.createFloorplanMesh(t);
  }
  async exportToSvg(t) {
    return (await this._sc.exportToSvg(t)).map((s) => String.fromCharCode(s)).join("");
  }
  async beginExportToSvg(t) {
    return this._sc.beginExportToSvg(t);
  }
  async advanceExportToSvg() {
    const t = await this._sc.advanceExportToSvg();
    if (t.length !== 0)
      return t.reduce((e, i) => {
        const s = String.fromCharCode(i);
        switch (s) {
          case `
`:
            return e;
          case "'":
            return `${e}"`;
          default:
            return `${e}${s}`;
        }
      }, "");
  }
  waitForImageDecoding() {
    return this._sc.waitForImageDecoding();
  }
  registerBimInstances(t, e) {
    return this._sc.registerBimInstances(t, e);
  }
  setAmbientLightColor(t) {
    this._sc.setAmbientLightColor(this._toRgb(t));
  }
  getLightKeys() {
    return this._sc.getLightKeys();
  }
  async getLight(t) {
    try {
      const e = await this._sc.getLight(t);
      return new dy(
        e.type.value,
        e.space.value,
        new d(...e.position),
        it.createFromFloatArray(e.color)
      );
    } catch {
      return;
    }
  }
  clearLights() {
    this._sc.clearLights();
  }
  addLight(t) {
    return this._sc.addLight(
      t.type,
      t.space,
      this._toVector3(t.position),
      this._toRgb(t.color)
    );
  }
  removeLight(t) {
    this._sc.removeLight(t);
  }
  updateLight(t, e) {
    this._sc.updateLight(
      t,
      e.type,
      e.space,
      this._toVector3(e.position),
      this._toRgb(e.color)
    );
  }
  setBloomEnabled(t) {
    this._sc.setBloomEnabled(t);
  }
  setBloomThreshold(t) {
    this._sc.setBloomThreshold(t);
  }
  setBloomThresholdRampWidth(t) {
    this._sc.setBloomThresholdRampWidth(t);
  }
  setBloomIntensityScale(t) {
    this._sc.setBloomIntensityScale(t);
  }
  _toBlurIntervalUnit(t) {
    switch (t) {
      default:
      case mn.Pixels:
        return ko.Pixels;
      case mn.ProportionOfWidth:
        return ko.ProportionOfWidth;
      case mn.ProportionOfHeight:
        return ko.ProportionOfHeight;
    }
  }
  setBloomLayers(t) {
    for (const e of t)
      if (e.blurInterval !== void 0 && e.blurInterval.length !== 2)
        throw new Mt(
          "'blurInterval' must be an array containing a number followed by a BlurIntervalUnit"
        );
    this._sc.suspendDrawing(), this._sc.setBloomLayerCount(t.length);
    for (let e = 0; e < t.length; ++e) {
      const i = t[e];
      i.intensity !== void 0 && this._sc.setBloomIntensity(e, i.intensity), i.blurSamples !== void 0 && this._sc.setBloomBlurSamples(e, i.blurSamples), i.blurInterval !== void 0 && this._sc.setBloomBlurInterval(
        e,
        i.blurInterval[0],
        this._toBlurIntervalUnit(i.blurInterval[1])
      );
    }
    this._sc.resumeDrawing();
  }
  startComparison(t, e, i) {
    const s = i != null && i.sameColor ? this._toRgb(i.sameColor) : [0, 0, 0], r = i != null && i.only1Color ? this._toRgb(i.only1Color) : [1, 0, 0], o = i != null && i.only2Color ? this._toRgb(i.only2Color) : [0, 1, 0];
    this._sc.setComparisonColors(s, r, o), this._sc.startComparison(t, e);
  }
  endComparison() {
    this._sc.endComparison();
  }
  setSimpleShadowColor(t) {
    this._sc.setSimpleShadowColor(this._toRgb(t));
  }
  setSimpleShadowEnabled(t) {
    this._sc.setSimpleShadowEnabled(t);
  }
  setSimpleShadowOpacity(t) {
    this._sc.setSimpleShadowOpacity(t);
  }
  setGroundPlane(t, e) {
    e !== void 0 ? this._sc.setGroundPlaneWithPosition(this._toVector3(t), this._toVector3(e)) : this._sc.setGroundPlane(this._toVector3(t));
  }
  setSimpleShadowResolution(t) {
    this._sc.setSimpleShadowResolution(t);
  }
  setSimpleShadowBlurSamples(t) {
    this._sc.setSimpleShadowBlurSamples(t);
  }
  setSimpleShadowBlurInterval(t) {
    this._sc.setSimpleShadowBlurInterval(t);
  }
  setSimpleShadowInteractiveUpdateEnabled(t = !0) {
    this._sc.setSimpleShadowInteractiveUpdateEnabled(t);
  }
  setSilhouetteColor(t) {
    this._sc.setSilhouetteColor(this._toRgb(t));
  }
  setSilhouetteEnabled(t = !0) {
    this._sc.setSilhouetteEnabled(t);
  }
  setSilhouetteOpacity(t) {
    this._sc.setSilhouetteOpacity(t);
  }
  setSilhouetteThreshold(t) {
    this._sc.setSilhouetteThreshold(t);
  }
  setSilhouetteThresholdRampWidth(t) {
    this._sc.setSilhouetteThresholdRampWidth(t);
  }
  setHardEdgeColor(t) {
    this._sc.setHardEdgeColor(this._toRgb(t));
  }
  setHardEdgesEnabled(t = !0) {
    this._sc.setHardEdgesEnabled(t);
  }
  setHardEdgeOpacity(t) {
    this._sc.setHardEdgeOpacity(t);
  }
  setHardEdgeThreshold(t) {
    this._sc.setHardEdgeThreshold(t);
  }
  setHardEdgeThresholdRampWidth(t) {
    this._sc.setHardEdgeThresholdRampWidth(t);
  }
  setSimpleReflectionEnabled(t = !0) {
    this._sc.setSimpleReflectionEnabled(t);
  }
  setSimpleReflectionBlurInterval(t, e) {
    this._sc.setSimpleReflectionBlurInterval(t, this._toBlurIntervalUnit(e));
  }
  setSimpleReflectionBlurSamples(t) {
    this._sc.setSimpleReflectionBlurSamples(t);
  }
  setSimpleReflectionFadeAngle(t) {
    this._sc.setSimpleReflectionFadeAngle(t);
  }
  setSimpleReflectionOpacity(t) {
    this._sc.setSimpleReflectionOpacity(t);
  }
  setSimpleReflectionAttenuation(t, e, i = uh.World) {
    this._sc.setSimpleReflectionAttenuation(t, e, i);
  }
  throttleLoad(t, e) {
    this._sc.throttleLoad(t, e);
  }
  _toVector3Array(t) {
    const e = [];
    for (const i of t)
      e.push([i.x, i.y, i.z]);
    return e;
  }
  testPointVisibility(t) {
    return this._sc.testPointVisibility(this._toVector3Array(t));
  }
  setPointVisibilityTest(t) {
    this._sc.setPointVisibilityTest(this._toVector3Array(t));
  }
  setImageBasedLightingEnabled(t) {
    this._sc.setImageBasedLightingEnabled(t);
  }
  setImageBasedLightingIntensity(t) {
    this._sc.setImageBasedLightingIntensity(t);
  }
  _toMatrix9(t) {
    return [
      t.m[0],
      t.m[1],
      t.m[2],
      t.m[4],
      t.m[5],
      t.m[6],
      t.m[8],
      t.m[9],
      t.m[10]
    ];
  }
  setImageBasedLightingMatrix(t) {
    this._sc.setImageBasedLightingMatrix(this._toMatrix9(t));
  }
  setImageBasedLightingEnvironment(t) {
    this._sc.setImageBasedLightingEnvironment(t);
  }
  setImageBasedLightingEnvironmentToDefault() {
    this._sc.setImageBasedLightingEnvironmentToDefault();
  }
  setLineJitterEnabled(t) {
    this._sc.setLineJitterEnabled(t);
  }
  setLineJitterInstanceCount(t) {
    this._sc.setLineJitterInstanceCount(t);
  }
  setLineJitterRadius(t) {
    this._sc.setLineJitterRadius(t);
  }
  setLineJitterFrequency(t) {
    this._sc.setLineJitterFrequency(t);
  }
}
const ib = () => new window.XMLHttpRequest();
function nb(n, t) {
  let e, i, s, r;
  t || (t = {}), typeof t == "function" ? (r = t, t = {}) : typeof t.callback == "function" && (r = t.callback), !r && typeof Promise < "u" ? e = new Promise(function(o, a) {
    i = o, s = a;
  }) : (i = function(o) {
    r(null, o);
  }, s = function(o) {
    r(o, null);
  });
  try {
    const o = ib();
    if (o.open("GET", n, !0), "responseType" in o && (o.responseType = "arraybuffer"), o.overrideMimeType && o.overrideMimeType("text/plain; charset=x-user-defined"), o.onreadystatechange = function() {
      if (o.readyState === 4)
        if (o.status === 200 || o.status === 0)
          try {
            i(o.response ?? o.responseText);
          } catch (a) {
            s(a);
          }
        else
          s(new Error("Ajax error for " + n + " : " + this.status + " " + this.statusText));
    }, t.progress) {
      const a = t.progress;
      o.onprogress = function(l) {
        a({
          path: n,
          originalEvent: l,
          percent: l.loaded / l.total * 100,
          loaded: l.loaded,
          total: l.total
        });
      };
    }
    o.send();
  } catch (o) {
    s(o, null);
  }
  return e;
}
class sb {
  constructor(t) {
    this._id = 0, this._bcfMap = /* @__PURE__ */ new Map(), this._viewer = t;
  }
  _getId() {
    return ++this._id;
  }
  /**
   * Gets a map containing BCF data correlated with the BCF filename.
   */
  getBCFMap() {
    return this._bcfMap;
  }
  /**
   * Gets the parsed BCF data for a BCF file.
   * @param id corresponding to the BCF file.
   */
  getBCFData(t) {
    return this._bcfMap.get(t) || null;
  }
  /**
   * Removes the parsed BCF data for a BCF file.
   * @param id corresponding to the BCF file.
   */
  removeBCFData(t) {
    this._bcfMap.delete(t), this._viewer.trigger("bcfRemoved", t);
  }
  /**
   * Creates a BCF file.
   * @param filename
   */
  createBCFData(t) {
    const e = this._getId(), i = new sl(t, e);
    return this._bcfMap.set(e, i), this._viewer.trigger("bcfLoaded", i.getId(), i.getFilename()), i;
  }
  /**
   * Imports BCF data from a BCF file.
   * @param filename
   */
  async addBCFFromFile(t) {
    const e = this._getId(), i = new sl(t, e);
    this._bcfMap.set(e, i);
    const s = await new om.external.Promise((r, o) => {
      nb(t, (a, l) => {
        a ? o(a) : r(l);
      });
    });
    await this._loadBCFData(s, i);
  }
  /**
   * Imports BCF data from a buffer.
   * @param buffer
   * @param filename
   */
  async addBCFFromBuffer(t, e) {
    const i = this._getId(), s = new sl(e, i);
    this._bcfMap.set(i, s), await this._loadBCFData(t, s);
  }
  async _getVersion(t) {
    const e = t.file("bcf.version");
    if (e === null)
      return pn.v1_0;
    {
      const r = (await this._getDocument(e)).documentElement.firstElementChild;
      if (r != null && r.textContent)
        switch (r.textContent) {
          case "2.0 RC":
            return pn.v2_0;
          case "2.1":
            return pn.v2_1;
        }
      return pn.Unknown;
    }
  }
  async _loadBCFData(t, e) {
    const i = this._viewer.model, s = await i.getModelBounding(!0, !1), r = i.getNodeUnitMultiplier(i.getAbsoluteRootNode()), o = e.getId(), a = e.getFilename(), l = await Ch.loadAsync(t);
    e.setVersion(await this._getVersion(l));
    const c = [];
    l.forEach(async (h) => {
      const u = be();
      c.push(u);
      const p = this._getFileType(h);
      if (p === Ci.Markup || p === Ci.Snapshot || p === Ci.Viewpoint) {
        const m = h.split("/"), g = m[0], _ = m[1];
        let y = e.getTopic(g);
        if (y === null && (y = new Al(o, a, g, this._viewer), e.addTopic(g, y)), _.length) {
          const b = l.file(h);
          if (b !== null)
            switch (p) {
              case Ci.Markup:
                y.addMarkup(_, await this._getDocument(b));
                break;
              case Ci.Viewpoint:
                y.addViewpoint(
                  _,
                  await this._getDocument(b),
                  e.getVersion(),
                  s,
                  r
                );
                break;
              case Ci.Snapshot:
                y.addSnapshot(_, await b.async("uint8array"));
                break;
            }
        }
      }
      u.resolve();
    }), await zt(c), this._viewer.trigger("bcfLoaded", o, a);
  }
  async _getDocument(t) {
    return new DOMParser().parseFromString(await t.async("text"), "application/xml");
  }
  _getFileType(t) {
    if (t.slice(-1) === "/")
      return Ci.TopicFolder;
    const e = t.split(".");
    switch (console.assert(e.length === 2), e[1]) {
      case "bcf":
        return Ci.Markup;
      case "bcfv":
        return Ci.Viewpoint;
      case "png":
        return Ci.Snapshot;
      case "version":
        return Ci.Version;
      case "xsd":
        return Ci.Schema;
      case "bcfp":
        return Ci.Project;
    }
    return Ci.Unknown;
  }
}
class rb {
  constructor(t, e) {
    this._callbackManager = t, this._operatorManager = e, this._contextEventChecker = new ob(this._callbackManager);
  }
  injectMouseDownEvent(t, e, i, s, r) {
    const o = new Qn(t, e, i, s, r, Gn.Down), a = kt.MouseDown;
    this._callbackManager.trigger("_inputInteraction", o, a), this._operatorManager.injectEvent(o, a), this._contextEventChecker.onMouseDownEvent(o);
  }
  injectMouseMoveEvent(t, e, i, s, r) {
    const o = new Qn(t, e, i, s, r, Gn.Move), a = kt.MouseMove;
    this._callbackManager.trigger("_inputInteraction", o, a), this._operatorManager.injectEvent(o, a);
  }
  injectMouseUpEvent(t, e, i, s, r) {
    const o = new Qn(t, e, i, s, r, Gn.Up), a = kt.MouseUp;
    this._callbackManager.trigger("_inputInteraction", o, a), this._operatorManager.injectEvent(o, a), this._contextEventChecker.onMouseUpEvent(o);
  }
  injectMousewheelEvent(t, e, i, s, r) {
    const o = new fm(t, e, i, s, r, Gn.Wheel), a = kt.Mousewheel;
    this._callbackManager.trigger("_inputInteraction", o, a), this._operatorManager.injectEvent(o, a);
  }
  injectKeyDownEvent(t, e) {
    const i = new Xc(t, e, Mc.Down), s = kt.KeyDown;
    this._callbackManager.trigger("_inputInteraction", i, s), this._operatorManager.injectEvent(i, s);
  }
  injectKeyUpEvent(t, e) {
    const i = new Xc(t, e, Mc.Up), s = kt.KeyUp;
    this._callbackManager.trigger("_inputInteraction", i, s), this._operatorManager.injectEvent(i, s);
  }
  injectTouchStartEvent(t, e, i, s) {
    const r = new ll(t, e, i, s, tl.Start), o = kt.TouchStart;
    this._callbackManager.trigger("_inputInteraction", r, o), this._operatorManager.injectEvent(r, o), this._contextEventChecker.onTouchStartEvent(r);
  }
  injectTouchMoveEvent(t, e, i, s) {
    const r = new ll(t, e, i, s, tl.Start), o = kt.TouchMove;
    this._callbackManager.trigger("_inputInteraction", r, o), this._operatorManager.injectEvent(r, o), this._contextEventChecker.onTouchMoveEvent(r);
  }
  injectTouchEndEvent(t, e, i, s) {
    const r = new ll(t, e, i, s, tl.End), o = kt.TouchEnd;
    this._callbackManager.trigger("_inputInteraction", r, o), this._operatorManager.injectEvent(r, o), this._contextEventChecker.onTouchEndEvent(r);
  }
  injectViewOrientationChangeEvent() {
    this._operatorManager._injectViewOrientationChangeEvent();
  }
}
class ob {
  constructor(t) {
    this._contextMenuMouseButton = Kt.Right, this._contextMenuPositionStart = E.zero(), this._touchTimer = new As(), this._activeTouchCount = 0, this._initialPosition = E.zero(), this._callbackManager = t;
  }
  onMouseDownEvent(t) {
    t.getHandled() || this._contextMenuPositionStart.assign(t.getPosition());
  }
  onMouseUpEvent(t) {
    if (!t.getHandled()) {
      const e = t.getPosition();
      t.getButton() === this._contextMenuMouseButton && this._contextMenuPositionStart.equals(e) && this._callbackManager.trigger("contextMenu", e, t.getModifiers());
    }
  }
  onTouchStartEvent(t) {
    const e = t.getPosition().copy();
    this._activeTouchCount === 0 && (this._initialPosition = e), ++this._activeTouchCount, t.getHandled() || this._touchTimer.set(600, () => {
      this._callbackManager.trigger("contextMenu", e, ye.None);
    });
  }
  onTouchMoveEvent(t) {
    if (!this._touchTimer.isIdle(mi.BeforeAction)) {
      const e = E.subtract(this._initialPosition, t.getPosition()), i = Math.abs(e.squaredLength()), s = window.outerHeight * 0.02, r = s * s;
      i > r && this._touchTimer.clear();
    }
  }
  onTouchEndEvent(t) {
    this._activeTouchCount > 0 && --this._activeTouchCount, this._touchTimer.clear();
  }
}
class ab {
  constructor() {
    this._activeInterpolation = null, this._updateTimer = new As(), this._updateInterval = 16;
  }
  stop() {
    this._activeInterpolation && this._activeInterpolation.stop(), this._activeInterpolation = null, this._updateTimer.clear();
  }
  start(t, e = !0) {
    return this._activeInterpolation && !e ? !1 : (this.stop(), this._activeInterpolation = t, this._activeInterpolation.start(), this.update(), !0);
  }
  update() {
    if (this._activeInterpolation)
      if (this._activeInterpolation.update(), this._activeInterpolation.isComplete()) {
        const t = this._activeInterpolation.getCallback();
        t !== null && t();
      } else
        this._updateTimer.isIdle(mi.BeforeAction) && this._updateTimer.set(this._updateInterval, () => {
          this.update();
        });
  }
}
class Lr {
  constructor(t, e, i, s, r) {
    this._container = t, this._canvasContainerElement = e, this._markupSvgElement = i, this._redlineSvgElement = s, this._redlineElement = r;
  }
  getCanvasContainerElement() {
    return this._canvasContainerElement;
  }
  getMarkupSvgElement() {
    return this._markupSvgElement;
  }
  getRedlineSvgElement() {
    return this._redlineSvgElement;
  }
  getRedlineElement() {
    return this._redlineElement;
  }
  shutdown() {
    this._container.removeChild(this._markupSvgElement), this._container.removeChild(this._redlineSvgElement), this._container.removeChild(this._redlineElement), this._container.removeChild(this._canvasContainerElement);
  }
  static createFromElement(t) {
    let e = t.id;
    e.length === 0 && (e = Qi());
    const i = `${e}-canvas-container`, s = `${e}-svg`, r = `${e}-redline-svg`, o = `${e}-redline`, a = document.createElement("div");
    a.id = i, a.style.width = "100%", a.style.height = "100%", a.style.position = "absolute", a.tabIndex = -1, a.classList.add("webviewer-canvas"), a.oncontextmenu = () => !1, t.appendChild(a);
    const l = Lr._createSvgElement(s);
    t.appendChild(l);
    const c = Lr._createSvgElement(r);
    t.appendChild(c);
    const h = document.createElement("div");
    return h.id = o, h.style.position = "absolute", h.style.width = "100%", h.style.height = "100%", h.style.pointerEvents = "none", t.appendChild(h), new Lr(
      t,
      a,
      l,
      c,
      h
    );
  }
  static createFromId(t) {
    const e = document.getElementById(t);
    return e === null ? null : this.createFromElement(e);
  }
  static _createSvgElement(t) {
    const e = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    return e.id = t, e.style.width = "100%", e.style.height = "100%", e.style.position = "absolute", e.style.pointerEvents = "none", e.style.overflow = "hidden", e.setAttributeNS(
      "http://www.w3.org/2000/xmlns/",
      "xmlns:xlink",
      "http://www.w3.org/1999/xlink"
    ), e;
  }
}
class lb {
  constructor() {
    this.left = 0, this.top = 0;
  }
}
const $e = class {
  constructor(n, t) {
    this._isIE = !1, this._isFirefox = !1, this._canvas = null, this._canvasEventFunctions = /* @__PURE__ */ new Map(), this._documentEventFunctions = /* @__PURE__ */ new Map(), this._pointerEventsEnabled = !0, this._processInput = !1, this._eventsBound = !1, this._dragStarted = !1, this._captureInput = !1, this._elementOffset = new lb(), this._pointerUp = !1, this._buttons = Ai.None, this._eventDispatcher = n, this._timeoutMonitor = t, this._document = document;
    const e = navigator.userAgent.toLowerCase();
    this._isIE = e.indexOf("trident") >= 0 || e.indexOf("edge") >= 0, this._isFirefox = e.indexOf("firefox") > -1;
  }
  _tryLockEventDispatcher() {
    return !$e._activeEventDispatcherLocked || $e._activeEventDispatcher === this._eventDispatcher ? (this._calculateElementOffset(), $e._activeEventDispatcher = this._eventDispatcher, $e._activeOffset = this._elementOffset, $e._activeEventDispatcherLocked = !0, !0) : !1;
  }
  _unlockEventDispatcher() {
    $e._activeEventDispatcherLocked = !1;
  }
  shutdown() {
    this.unbindEvents();
  }
  setDocument(n) {
    this._unbindDocumentEvents(), this._document = n, this._initDocumentEvents();
  }
  setOptions(n) {
    n.hasOwnProperty("usePointerEvents") && this.setPointerEventsEnabled(!!n.usePointerEvents);
  }
  elementResize() {
    this._calculateElementOffset();
  }
  setPointerEventsEnabled(n) {
    this._pointerEventsEnabled = n;
  }
  getPointerEventsEnabled() {
    return this._pointerEventsEnabled;
  }
  _browserSupportsPointerEvents() {
    return window.hasOwnProperty("PointerEvent");
  }
  _usePointerEvents() {
    return this._browserSupportsPointerEvents() && this._pointerEventsEnabled && this._isIE;
  }
  _calculateElementOffset() {
    if (this._canvas !== null) {
      const n = this._canvas.getBoundingClientRect();
      this._elementOffset.left = n.left, this._elementOffset.top = n.top;
    }
  }
  _initDocumentEvents() {
    this._usePointerEvents() ? (this._bindDocumentEvent("pointermove", (n) => {
      this._processDocumentPointerMove(n);
    }), this._bindDocumentEvent("pointerup", (n) => {
      this._processDocumentPointerUp(n);
    })) : (this._bindDocumentEvent("mousemove", (n) => {
      this._processDocumentMouseMove(n);
    }), this._bindDocumentEvent("mouseup", (n) => {
      this._processDocumentMouseUp(n);
    }));
  }
  _initCanvasEvents() {
    this._usePointerEvents() ? (this._bindCanvasEvent("pointerdown", (n) => {
      this._processPointerDown(n);
    }), this._bindCanvasEvent("pointermove", (n) => {
      this._processPointerMove(n);
    }), this._bindCanvasEvent("pointerup", (n) => {
      this._processPointerUp(n);
    }), this._bindCanvasEvent("pointerenter", (n) => {
      this._processPointerEnter(n);
    }), this._bindCanvasEvent("pointerleave", (n) => {
      this._processPointerLeave(n);
    })) : (this._bindCanvasEvent("mousedown", (n) => {
      this._processMouseDown(n);
    }), this._bindCanvasEvent("mousemove", (n) => {
      this._processMouseMove(n);
    }), this._bindCanvasEvent("mouseup", (n) => {
      this._processMouseUp(n);
    }), this._bindCanvasEvent("mouseenter", (n) => {
      this._processMouseEnter(n);
    }), this._bindCanvasEvent("mouseleave", (n) => {
      this._processMouseLeave(n);
    }), this._bindCanvasEvent("touchstart", (n) => {
      this._processTouchStart(n);
    }), this._bindCanvasEvent("touchmove", (n) => {
      this._processTouchMove(n);
    }), this._bindCanvasEvent("touchend", (n) => {
      this._processTouchEnd(n);
    }), this._bindCanvasEvent("touchcancel", (n) => {
      this._processTouchEnd(n);
    })), this._isFirefox ? this._bindCanvasEvent("DOMMouseScroll", (n) => {
      this._processMousewheel(n);
    }) : this._bindCanvasEvent("mousewheel", (n) => {
      this._processMousewheel(n);
    }), this._bindCanvasEvent("keydown", (n) => {
      this._processKeyDownEvent(n);
    }), this._bindCanvasEvent("keyup", (n) => {
      this._processKeyUpEvent(n);
    });
  }
  bindEvents(n) {
    this._eventsBound || (this._canvas = n, this.elementResize(), this._processInput = !0, this._initCanvasEvents(), this._initDocumentEvents(), this._eventsBound = !0);
  }
  _bindDocumentEvent(n, t) {
    if (this._document === null)
      return;
    const e = this._documentEventFunctions.get(n);
    e !== void 0 && this._document.removeEventListener(n, e), this._documentEventFunctions.set(n, t), this._document.addEventListener(n, t);
  }
  _bindCanvasEvent(n, t) {
    if (this._canvas === null)
      return;
    const e = this._canvasEventFunctions.get(n);
    e !== void 0 && this._canvas.removeEventListener(n, e), this._canvasEventFunctions.set(n, t), this._canvas.addEventListener(n, t);
  }
  _unbindDocumentEvents() {
    this._documentEventFunctions.forEach((n, t) => {
      this._document.removeEventListener(t, n);
    }), this._documentEventFunctions.clear();
  }
  _unbindCanvasEvents() {
    this._canvas !== null && (this._canvasEventFunctions.forEach((n, t) => {
      this._canvas.removeEventListener(t, n);
    }), this._canvasEventFunctions.clear()), console.assert(this._canvasEventFunctions.size === 0);
  }
  unbindEvents() {
    this._unbindCanvasEvents(), this._unbindDocumentEvents(), this._processInput = !1, this._eventsBound = !1, $e._activeEventDispatcher === this._eventDispatcher && this._unlockEventDispatcher();
  }
  _convertEventCoordsToTargetCoords(n, t, e = !0) {
    let i;
    return e && $e._activeOffset !== null ? i = $e._activeOffset : i = this._elementOffset, new E(n - i.left, t - i.top);
  }
  focusInput(n) {
    this._canvas !== null && (n ? this._canvas.focus() : this._canvas.blur());
  }
  _setButtons(n) {
    n.buttons && (this._buttons = n.buttons);
  }
  ////Mouse Events
  _processMouseDown(n) {
    if (this._tryLockEventDispatcher()) {
      switch (n.button) {
        case 0:
          this._buttons |= Ai.Left;
          break;
        case 1:
          this._buttons |= Ai.Middle;
          break;
        case 2:
          this._buttons |= Ai.Right;
          break;
      }
      if (n.preventDefault(), this._timeoutMonitor.resetTimeout(), this._processInput) {
        const t = this._convertEventCoordsToTargetCoords(n.clientX, n.clientY), e = this._getEventModifiers(n);
        $e._activeEventDispatcher.injectMouseDownEvent(
          t.x,
          t.y,
          n.button,
          this._buttons,
          e
        ), this._dragStarted = !0;
      }
    }
  }
  _processMouseMove(n, t = !1) {
    if (n.preventDefault(), this._timeoutMonitor.resetTimeout(), !(!t && !this._tryLockEventDispatcher()) && this._processInput) {
      const e = this._convertEventCoordsToTargetCoords(n.clientX, n.clientY), i = this._getEventModifiers(n);
      $e._activeEventDispatcher !== null && $e._activeEventDispatcher.injectMouseMoveEvent(
        e.x,
        e.y,
        Kt.None,
        this._buttons,
        i
      );
    }
  }
  _processMouseUp(n, t = !1) {
    switch (n.button) {
      case 0:
        this._buttons &= ~Ai.Left;
        break;
      case 1:
        this._buttons &= ~Ai.Middle;
        break;
      case 2:
        this._buttons &= ~Ai.Right;
        break;
    }
    if (n.preventDefault(), this._timeoutMonitor.resetTimeout(), !!this._tryLockEventDispatcher() && (n.stopPropagation(), this._processInput)) {
      const e = this._convertEventCoordsToTargetCoords(n.clientX, n.clientY), i = this._getEventModifiers(n);
      $e._activeEventDispatcher.injectMouseUpEvent(
        e.x,
        e.y,
        n.button,
        this._buttons,
        i
      ), this._buttons === Ai.None && (this._dragStarted = !1, this._captureInput = !1, t && this._unlockEventDispatcher());
    }
  }
  _processMousewheel(n) {
    if (n.preventDefault(), this._timeoutMonitor.resetTimeout(), this._processInput) {
      let t;
      const e = this._convertEventCoordsToTargetCoords(n.clientX, n.clientY), i = this._getEventModifiers(n);
      this._isFirefox ? t = n.detail > 0 ? -1 : 1 : t = n.wheelDelta > 0 ? 1 : -1, this._eventDispatcher.injectMousewheelEvent(
        e.x,
        e.y,
        t,
        this._buttons,
        i
      );
    }
  }
  _processDocumentMouseMove(n) {
    this._dragStarted && this._captureInput && this._processMouseMove(n, !0);
  }
  _processDocumentMouseUp(n) {
    this._dragStarted && this._captureInput && this._processMouseUp(n, !0);
  }
  _processMouseLeave(n) {
    if (this._dragStarted) {
      this._captureInput = !0;
      return;
    }
    this._unlockEventDispatcher();
  }
  _processMouseEnter(n) {
    this._tryLockEventDispatcher() && this._dragStarted && (this._captureInput = !1);
  }
  //KeyEvents
  _isFunctionKey(n) {
    return 112 <= n.which && n.which <= 123;
  }
  _processKeyDownEvent(n) {
    if (this._isFunctionKey(n) || n.preventDefault(), this._timeoutMonitor.resetTimeout(), this._processInput) {
      const t = this._getEventModifiers(n);
      this._eventDispatcher.injectKeyDownEvent(
        // tslint:disable-next-line:deprecation
        n.which,
        t
      );
    }
  }
  _processKeyUpEvent(n) {
    if (n.preventDefault(), this._timeoutMonitor.resetTimeout(), this._processInput) {
      const t = this._getEventModifiers(n);
      this._eventDispatcher.injectKeyUpEvent(
        // tslint:disable-next-line:deprecation
        n.which,
        t
      );
    }
  }
  //Touch Events
  _processTouchStart(n) {
    if (n.preventDefault(), this._timeoutMonitor.resetTimeout(), this._processInput)
      for (let t = 0; t < n.changedTouches.length; t++) {
        const e = n.changedTouches.item(t), i = this._convertEventCoordsToTargetCoords(e.clientX, e.clientY, !1);
        this._eventDispatcher.injectTouchStartEvent(
          e.identifier,
          i.x,
          i.y,
          this._buttons
        );
      }
  }
  _processTouchMove(n) {
    if (n.preventDefault(), this._timeoutMonitor.resetTimeout(), this._processInput)
      for (let t = 0; t < n.changedTouches.length; t++) {
        const e = n.changedTouches.item(t), i = this._convertEventCoordsToTargetCoords(e.clientX, e.clientY, !1);
        this._eventDispatcher.injectTouchMoveEvent(
          e.identifier,
          i.x,
          i.y,
          this._buttons
        );
      }
  }
  _processTouchEnd(n) {
    if (n.preventDefault(), this._timeoutMonitor.resetTimeout(), this._processInput)
      for (let t = 0; t < n.changedTouches.length; t++) {
        const e = n.changedTouches.item(t), i = this._convertEventCoordsToTargetCoords(e.clientX, e.clientY, !1);
        this._eventDispatcher.injectTouchEndEvent(
          e.identifier,
          i.x,
          i.y,
          this._buttons
        );
      }
  }
  //PointerEvents
  _processPointerDown(n) {
    if (this._tryLockEventDispatcher() && (this._setButtons(n), n.preventDefault(), this._timeoutMonitor.resetTimeout(), this._processInput)) {
      const t = this._convertEventCoordsToTargetCoords(n.clientX, n.clientY), e = this._getEventModifiers(n);
      n.pointerType === "mouse" ? $e._activeEventDispatcher.injectMouseDownEvent(
        t.x,
        t.y,
        n.button,
        this._buttons,
        e
      ) : n.pointerType === "touch" && $e._activeEventDispatcher.injectTouchStartEvent(
        n.pointerId,
        t.x,
        t.y,
        this._buttons
      ), this._pointerUp = !1;
    }
  }
  _processPointerMove(n, t = !1) {
    if (n.preventDefault(), this._timeoutMonitor.resetTimeout(), !(!t && !this._tryLockEventDispatcher()) && (this._setButtons(n), this._processInput)) {
      const e = this._convertEventCoordsToTargetCoords(n.clientX, n.clientY), i = this._getEventModifiers(n);
      $e._activeEventDispatcher !== null && (n.pointerType === "mouse" ? $e._activeEventDispatcher.injectMouseMoveEvent(
        e.x,
        e.y,
        n.button,
        this._buttons,
        i
      ) : n.pointerType === "touch" && $e._activeEventDispatcher.injectTouchMoveEvent(
        n.pointerId,
        e.x,
        e.y,
        this._buttons
      ));
    }
  }
  _processPointerUp(n, t = !1) {
    if (this._setButtons(n), n.preventDefault(), this._timeoutMonitor.resetTimeout(), !!this._tryLockEventDispatcher() && this._processInput) {
      const e = this._convertEventCoordsToTargetCoords(n.clientX, n.clientY), i = this._getEventModifiers(n);
      n.pointerType === "mouse" && !this._pointerUp ? $e._activeEventDispatcher.injectMouseUpEvent(
        e.x,
        e.y,
        n.button,
        this._buttons,
        i
      ) : n.pointerType === "touch" && this._eventDispatcher.injectTouchEndEvent(
        n.pointerId,
        e.x,
        e.y,
        this._buttons
      ), this._buttons === Ai.None && (this._dragStarted = !1, this._captureInput = !1, this._pointerUp = !0, t && this._unlockEventDispatcher());
    }
  }
  _processPointerEnter(n) {
    this._tryLockEventDispatcher() && (this._pointerUp || (this._captureInput = !1));
  }
  _processPointerLeave(n) {
    if (!this._pointerUp) {
      this._captureInput = !0;
      return;
    }
    this._unlockEventDispatcher();
  }
  _processDocumentPointerMove(n) {
    !this._pointerUp && this._captureInput && this._processPointerMove(n, !0);
  }
  _processDocumentPointerUp(n) {
    !this._pointerUp && this._captureInput && this._processPointerUp(n, !0);
  }
  _getEventModifiers(n) {
    let t = ye.None;
    return n.altKey && (t |= ye.Alt), n.ctrlKey && (t |= ye.Control), n.shiftKey && (t |= ye.Shift), n.metaKey && (t |= ye.Command), t;
  }
};
let Ql = $e;
Ql._activeEventDispatcher = null;
Ql._activeEventDispatcherLocked = !1;
Ql._activeOffset = null;
var ql = { exports: {} }, xo = { exports: {} };
(function() {
  var n, t, e, i, s, r;
  typeof performance < "u" && performance !== null && performance.now ? xo.exports = function() {
    return performance.now();
  } : typeof process < "u" && process !== null && process.hrtime ? (xo.exports = function() {
    return (n() - s) / 1e6;
  }, t = process.hrtime, n = function() {
    var o;
    return o = t(), o[0] * 1e9 + o[1];
  }, i = n(), r = process.uptime() * 1e9, s = i - r) : Date.now ? (xo.exports = function() {
    return Date.now() - e;
  }, e = Date.now()) : (xo.exports = function() {
    return (/* @__PURE__ */ new Date()).getTime() - e;
  }, e = (/* @__PURE__ */ new Date()).getTime());
}).call(tr);
var cb = xo.exports, hb = cb, gs = typeof window > "u" ? tr : window, za = ["moz", "webkit"], Xr = "AnimationFrame", Ur = gs["request" + Xr], ha = gs["cancel" + Xr] || gs["cancelRequest" + Xr];
for (var oo = 0; !Ur && oo < za.length; oo++)
  Ur = gs[za[oo] + "Request" + Xr], ha = gs[za[oo] + "Cancel" + Xr] || gs[za[oo] + "CancelRequest" + Xr];
if (!Ur || !ha) {
  var dc = 0, Zu = 0, js = [], ub = 1e3 / 60;
  Ur = function(n) {
    if (js.length === 0) {
      var t = hb(), e = Math.max(0, ub - (t - dc));
      dc = e + t, setTimeout(function() {
        var i = js.slice(0);
        js.length = 0;
        for (var s = 0; s < i.length; s++)
          if (!i[s].cancelled)
            try {
              i[s].callback(dc);
            } catch (r) {
              setTimeout(function() {
                throw r;
              }, 0);
            }
      }, Math.round(e));
    }
    return js.push({
      handle: ++Zu,
      callback: n,
      cancelled: !1
    }), Zu;
  }, ha = function(n) {
    for (var t = 0; t < js.length; t++)
      js[t].handle === n && (js[t].cancelled = !0);
  };
}
ql.exports = function(n) {
  return Ur.call(gs, n);
};
ql.exports.cancel = function() {
  ha.apply(gs, arguments);
};
ql.exports.polyfill = function(n) {
  n || (n = gs), n.requestAnimationFrame = Ur, n.cancelAnimationFrame = ha;
};
var db = ql.exports;
const mc = /* @__PURE__ */ Rl(db);
var mb = function(n) {
  this.ok = !1, this.alpha = 1, n.charAt(0) == "#" && (n = n.substr(1, 6)), n = n.replace(/ /g, ""), n = n.toLowerCase();
  var t = {
    aliceblue: "f0f8ff",
    antiquewhite: "faebd7",
    aqua: "00ffff",
    aquamarine: "7fffd4",
    azure: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "000000",
    blanchedalmond: "ffebcd",
    blue: "0000ff",
    blueviolet: "8a2be2",
    brown: "a52a2a",
    burlywood: "deb887",
    cadetblue: "5f9ea0",
    chartreuse: "7fff00",
    chocolate: "d2691e",
    coral: "ff7f50",
    cornflowerblue: "6495ed",
    cornsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "00ffff",
    darkblue: "00008b",
    darkcyan: "008b8b",
    darkgoldenrod: "b8860b",
    darkgray: "a9a9a9",
    darkgreen: "006400",
    darkkhaki: "bdb76b",
    darkmagenta: "8b008b",
    darkolivegreen: "556b2f",
    darkorange: "ff8c00",
    darkorchid: "9932cc",
    darkred: "8b0000",
    darksalmon: "e9967a",
    darkseagreen: "8fbc8f",
    darkslateblue: "483d8b",
    darkslategray: "2f4f4f",
    darkturquoise: "00ced1",
    darkviolet: "9400d3",
    deeppink: "ff1493",
    deepskyblue: "00bfff",
    dimgray: "696969",
    dodgerblue: "1e90ff",
    feldspar: "d19275",
    firebrick: "b22222",
    floralwhite: "fffaf0",
    forestgreen: "228b22",
    fuchsia: "ff00ff",
    gainsboro: "dcdcdc",
    ghostwhite: "f8f8ff",
    gold: "ffd700",
    goldenrod: "daa520",
    gray: "808080",
    green: "008000",
    greenyellow: "adff2f",
    honeydew: "f0fff0",
    hotpink: "ff69b4",
    indianred: "cd5c5c",
    indigo: "4b0082",
    ivory: "fffff0",
    khaki: "f0e68c",
    lavender: "e6e6fa",
    lavenderblush: "fff0f5",
    lawngreen: "7cfc00",
    lemonchiffon: "fffacd",
    lightblue: "add8e6",
    lightcoral: "f08080",
    lightcyan: "e0ffff",
    lightgoldenrodyellow: "fafad2",
    lightgrey: "d3d3d3",
    lightgreen: "90ee90",
    lightpink: "ffb6c1",
    lightsalmon: "ffa07a",
    lightseagreen: "20b2aa",
    lightskyblue: "87cefa",
    lightslateblue: "8470ff",
    lightslategray: "778899",
    lightsteelblue: "b0c4de",
    lightyellow: "ffffe0",
    lime: "00ff00",
    limegreen: "32cd32",
    linen: "faf0e6",
    magenta: "ff00ff",
    maroon: "800000",
    mediumaquamarine: "66cdaa",
    mediumblue: "0000cd",
    mediumorchid: "ba55d3",
    mediumpurple: "9370d8",
    mediumseagreen: "3cb371",
    mediumslateblue: "7b68ee",
    mediumspringgreen: "00fa9a",
    mediumturquoise: "48d1cc",
    mediumvioletred: "c71585",
    midnightblue: "191970",
    mintcream: "f5fffa",
    mistyrose: "ffe4e1",
    moccasin: "ffe4b5",
    navajowhite: "ffdead",
    navy: "000080",
    oldlace: "fdf5e6",
    olive: "808000",
    olivedrab: "6b8e23",
    orange: "ffa500",
    orangered: "ff4500",
    orchid: "da70d6",
    palegoldenrod: "eee8aa",
    palegreen: "98fb98",
    paleturquoise: "afeeee",
    palevioletred: "d87093",
    papayawhip: "ffefd5",
    peachpuff: "ffdab9",
    peru: "cd853f",
    pink: "ffc0cb",
    plum: "dda0dd",
    powderblue: "b0e0e6",
    purple: "800080",
    rebeccapurple: "663399",
    red: "ff0000",
    rosybrown: "bc8f8f",
    royalblue: "4169e1",
    saddlebrown: "8b4513",
    salmon: "fa8072",
    sandybrown: "f4a460",
    seagreen: "2e8b57",
    seashell: "fff5ee",
    sienna: "a0522d",
    silver: "c0c0c0",
    skyblue: "87ceeb",
    slateblue: "6a5acd",
    slategray: "708090",
    snow: "fffafa",
    springgreen: "00ff7f",
    steelblue: "4682b4",
    tan: "d2b48c",
    teal: "008080",
    thistle: "d8bfd8",
    tomato: "ff6347",
    turquoise: "40e0d0",
    violet: "ee82ee",
    violetred: "d02090",
    wheat: "f5deb3",
    white: "ffffff",
    whitesmoke: "f5f5f5",
    yellow: "ffff00",
    yellowgreen: "9acd32"
  };
  n = t[n] || n;
  for (var e = [
    {
      re: /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*((?:\d?\.)?\d)\)$/,
      example: ["rgba(123, 234, 45, 0.8)", "rgba(255,234,245,1.0)"],
      process: function(l) {
        return [
          parseInt(l[1]),
          parseInt(l[2]),
          parseInt(l[3]),
          parseFloat(l[4])
        ];
      }
    },
    {
      re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
      example: ["rgb(123, 234, 45)", "rgb(255,234,245)"],
      process: function(l) {
        return [
          parseInt(l[1]),
          parseInt(l[2]),
          parseInt(l[3])
        ];
      }
    },
    {
      re: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
      example: ["#00ff00", "336699"],
      process: function(l) {
        return [
          parseInt(l[1], 16),
          parseInt(l[2], 16),
          parseInt(l[3], 16)
        ];
      }
    },
    {
      re: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      example: ["#fb0", "f0f"],
      process: function(l) {
        return [
          parseInt(l[1] + l[1], 16),
          parseInt(l[2] + l[2], 16),
          parseInt(l[3] + l[3], 16)
        ];
      }
    }
  ], i = 0; i < e.length; i++) {
    var s = e[i].re, r = e[i].process, o = s.exec(n);
    if (o) {
      var a = r(o);
      this.r = a[0], this.g = a[1], this.b = a[2], a.length > 3 && (this.alpha = a[3]), this.ok = !0;
    }
  }
  this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.alpha = this.alpha < 0 ? 0 : this.alpha > 1 || isNaN(this.alpha) ? 1 : this.alpha, this.toRGB = function() {
    return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
  }, this.toRGBA = function() {
    return "rgba(" + this.r + ", " + this.g + ", " + this.b + ", " + this.alpha + ")";
  }, this.toHex = function() {
    var l = this.r.toString(16), c = this.g.toString(16), h = this.b.toString(16);
    return l.length == 1 && (l = "0" + l), c.length == 1 && (c = "0" + c), h.length == 1 && (h = "0" + h), "#" + l + c + h;
  }, this.getHelpXML = function() {
    for (var l = new Array(), c = 0; c < e.length; c++)
      for (var h = e[c].example, u = 0; u < h.length; u++)
        l[l.length] = h[u];
    for (var p in t)
      l[l.length] = p;
    var m = document.createElement("ul");
    m.setAttribute("id", "rgbcolor-examples");
    for (var c = 0; c < l.length; c++)
      try {
        var g = document.createElement("li"), _ = new RGBColor(l[c]), y = document.createElement("div");
        y.style.cssText = "margin: 3px; border: 1px solid black; background:" + _.toHex() + "; color:" + _.toHex(), y.appendChild(document.createTextNode("test"));
        var b = document.createTextNode(
          " " + l[c] + " -> " + _.toRGB() + " -> " + _.toHex()
        );
        g.appendChild(y), g.appendChild(b), m.appendChild(g);
      } catch {
      }
    return m;
  };
};
const sh = /* @__PURE__ */ Rl(mb);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var vp = function(n, t) {
  return (vp = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var s in i)
      Object.prototype.hasOwnProperty.call(i, s) && (e[s] = i[s]);
  })(n, t);
};
function Sp(n, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  function e() {
    this.constructor = n;
  }
  vp(n, t), n.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
function pb(n) {
  var t = "";
  Array.isArray(n) || (n = [n]);
  for (var e = 0; e < n.length; e++) {
    var i = n[e];
    if (i.type === at.CLOSE_PATH)
      t += "z";
    else if (i.type === at.HORIZ_LINE_TO)
      t += (i.relative ? "h" : "H") + i.x;
    else if (i.type === at.VERT_LINE_TO)
      t += (i.relative ? "v" : "V") + i.y;
    else if (i.type === at.MOVE_TO)
      t += (i.relative ? "m" : "M") + i.x + " " + i.y;
    else if (i.type === at.LINE_TO)
      t += (i.relative ? "l" : "L") + i.x + " " + i.y;
    else if (i.type === at.CURVE_TO)
      t += (i.relative ? "c" : "C") + i.x1 + " " + i.y1 + " " + i.x2 + " " + i.y2 + " " + i.x + " " + i.y;
    else if (i.type === at.SMOOTH_CURVE_TO)
      t += (i.relative ? "s" : "S") + i.x2 + " " + i.y2 + " " + i.x + " " + i.y;
    else if (i.type === at.QUAD_TO)
      t += (i.relative ? "q" : "Q") + i.x1 + " " + i.y1 + " " + i.x + " " + i.y;
    else if (i.type === at.SMOOTH_QUAD_TO)
      t += (i.relative ? "t" : "T") + i.x + " " + i.y;
    else {
      if (i.type !== at.ARC)
        throw new Error('Unexpected command type "' + i.type + '" at index ' + e + ".");
      t += (i.relative ? "a" : "A") + i.rX + " " + i.rY + " " + i.xRot + " " + +i.lArcFlag + " " + +i.sweepFlag + " " + i.x + " " + i.y;
    }
  }
  return t;
}
function rh(n, t) {
  var e = n[0], i = n[1];
  return [e * Math.cos(t) - i * Math.sin(t), e * Math.sin(t) + i * Math.cos(t)];
}
function Cn() {
  for (var n = [], t = 0; t < arguments.length; t++)
    n[t] = arguments[t];
  for (var e = 0; e < n.length; e++)
    if (typeof n[e] != "number")
      throw new Error("assertNumbers arguments[" + e + "] is not a number. " + typeof n[e] + " == typeof " + n[e]);
  return !0;
}
var Cs = Math.PI;
function pc(n, t, e) {
  n.lArcFlag = n.lArcFlag === 0 ? 0 : 1, n.sweepFlag = n.sweepFlag === 0 ? 0 : 1;
  var i = n.rX, s = n.rY, r = n.x, o = n.y;
  i = Math.abs(n.rX), s = Math.abs(n.rY);
  var a = rh([(t - r) / 2, (e - o) / 2], -n.xRot / 180 * Cs), l = a[0], c = a[1], h = Math.pow(l, 2) / Math.pow(i, 2) + Math.pow(c, 2) / Math.pow(s, 2);
  1 < h && (i *= Math.sqrt(h), s *= Math.sqrt(h)), n.rX = i, n.rY = s;
  var u = Math.pow(i, 2) * Math.pow(c, 2) + Math.pow(s, 2) * Math.pow(l, 2), p = (n.lArcFlag !== n.sweepFlag ? 1 : -1) * Math.sqrt(Math.max(0, (Math.pow(i, 2) * Math.pow(s, 2) - u) / u)), m = i * c / s * p, g = -s * l / i * p, _ = rh([m, g], n.xRot / 180 * Cs);
  n.cX = _[0] + (t + r) / 2, n.cY = _[1] + (e + o) / 2, n.phi1 = Math.atan2((c - g) / s, (l - m) / i), n.phi2 = Math.atan2((-c - g) / s, (-l - m) / i), n.sweepFlag === 0 && n.phi2 > n.phi1 && (n.phi2 -= 2 * Cs), n.sweepFlag === 1 && n.phi2 < n.phi1 && (n.phi2 += 2 * Cs), n.phi1 *= 180 / Cs, n.phi2 *= 180 / Cs;
}
function Cu(n, t, e) {
  Cn(n, t, e);
  var i = n * n + t * t - e * e;
  if (0 > i)
    return [];
  if (i === 0)
    return [[n * e / (n * n + t * t), t * e / (n * n + t * t)]];
  var s = Math.sqrt(i);
  return [[(n * e + t * s) / (n * n + t * t), (t * e - n * s) / (n * n + t * t)], [(n * e - t * s) / (n * n + t * t), (t * e + n * s) / (n * n + t * t)]];
}
var ti, is = Math.PI / 180;
function ku(n, t, e) {
  return (1 - e) * n + e * t;
}
function Mu(n, t, e, i) {
  return n + Math.cos(i / 180 * Cs) * t + Math.sin(i / 180 * Cs) * e;
}
function Wu(n, t, e, i) {
  var s = 1e-6, r = t - n, o = e - t, a = 3 * r + 3 * (i - e) - 6 * o, l = 6 * (o - r), c = 3 * r;
  return Math.abs(a) < s ? [-c / l] : function(h, u, p) {
    p === void 0 && (p = 1e-6);
    var m = h * h / 4 - u;
    if (m < -p)
      return [];
    if (m <= p)
      return [-h / 2];
    var g = Math.sqrt(m);
    return [-h / 2 - g, -h / 2 + g];
  }(l / a, c / a, s);
}
function Pu(n, t, e, i, s) {
  var r = 1 - s;
  return n * (r * r * r) + t * (3 * r * r * s) + e * (3 * r * s * s) + i * (s * s * s);
}
(function(n) {
  function t() {
    return s(function(a, l, c) {
      return a.relative && (a.x1 !== void 0 && (a.x1 += l), a.y1 !== void 0 && (a.y1 += c), a.x2 !== void 0 && (a.x2 += l), a.y2 !== void 0 && (a.y2 += c), a.x !== void 0 && (a.x += l), a.y !== void 0 && (a.y += c), a.relative = !1), a;
    });
  }
  function e() {
    var a = NaN, l = NaN, c = NaN, h = NaN;
    return s(function(u, p, m) {
      return u.type & at.SMOOTH_CURVE_TO && (u.type = at.CURVE_TO, a = isNaN(a) ? p : a, l = isNaN(l) ? m : l, u.x1 = u.relative ? p - a : 2 * p - a, u.y1 = u.relative ? m - l : 2 * m - l), u.type & at.CURVE_TO ? (a = u.relative ? p + u.x2 : u.x2, l = u.relative ? m + u.y2 : u.y2) : (a = NaN, l = NaN), u.type & at.SMOOTH_QUAD_TO && (u.type = at.QUAD_TO, c = isNaN(c) ? p : c, h = isNaN(h) ? m : h, u.x1 = u.relative ? p - c : 2 * p - c, u.y1 = u.relative ? m - h : 2 * m - h), u.type & at.QUAD_TO ? (c = u.relative ? p + u.x1 : u.x1, h = u.relative ? m + u.y1 : u.y1) : (c = NaN, h = NaN), u;
    });
  }
  function i() {
    var a = NaN, l = NaN;
    return s(function(c, h, u) {
      if (c.type & at.SMOOTH_QUAD_TO && (c.type = at.QUAD_TO, a = isNaN(a) ? h : a, l = isNaN(l) ? u : l, c.x1 = c.relative ? h - a : 2 * h - a, c.y1 = c.relative ? u - l : 2 * u - l), c.type & at.QUAD_TO) {
        a = c.relative ? h + c.x1 : c.x1, l = c.relative ? u + c.y1 : c.y1;
        var p = c.x1, m = c.y1;
        c.type = at.CURVE_TO, c.x1 = ((c.relative ? 0 : h) + 2 * p) / 3, c.y1 = ((c.relative ? 0 : u) + 2 * m) / 3, c.x2 = (c.x + 2 * p) / 3, c.y2 = (c.y + 2 * m) / 3;
      } else
        a = NaN, l = NaN;
      return c;
    });
  }
  function s(a) {
    var l = 0, c = 0, h = NaN, u = NaN;
    return function(p) {
      if (isNaN(h) && !(p.type & at.MOVE_TO))
        throw new Error("path must start with moveto");
      var m = a(p, l, c, h, u);
      return p.type & at.CLOSE_PATH && (l = h, c = u), p.x !== void 0 && (l = p.relative ? l + p.x : p.x), p.y !== void 0 && (c = p.relative ? c + p.y : p.y), p.type & at.MOVE_TO && (h = l, u = c), m;
    };
  }
  function r(a, l, c, h, u, p) {
    return Cn(a, l, c, h, u, p), s(function(m, g, _, y) {
      var b = m.x1, w = m.x2, v = m.relative && !isNaN(y), C = m.x !== void 0 ? m.x : v ? 0 : g, k = m.y !== void 0 ? m.y : v ? 0 : _;
      function Y(O) {
        return O * O;
      }
      m.type & at.HORIZ_LINE_TO && l !== 0 && (m.type = at.LINE_TO, m.y = m.relative ? 0 : _), m.type & at.VERT_LINE_TO && c !== 0 && (m.type = at.LINE_TO, m.x = m.relative ? 0 : g), m.x !== void 0 && (m.x = m.x * a + k * c + (v ? 0 : u)), m.y !== void 0 && (m.y = C * l + m.y * h + (v ? 0 : p)), m.x1 !== void 0 && (m.x1 = m.x1 * a + m.y1 * c + (v ? 0 : u)), m.y1 !== void 0 && (m.y1 = b * l + m.y1 * h + (v ? 0 : p)), m.x2 !== void 0 && (m.x2 = m.x2 * a + m.y2 * c + (v ? 0 : u)), m.y2 !== void 0 && (m.y2 = w * l + m.y2 * h + (v ? 0 : p));
      var P = a * h - l * c;
      if (m.xRot !== void 0 && (a !== 1 || l !== 0 || c !== 0 || h !== 1))
        if (P === 0)
          delete m.rX, delete m.rY, delete m.xRot, delete m.lArcFlag, delete m.sweepFlag, m.type = at.LINE_TO;
        else {
          var L = m.xRot * Math.PI / 180, R = Math.sin(L), D = Math.cos(L), J = 1 / Y(m.rX), G = 1 / Y(m.rY), X = Y(D) * J + Y(R) * G, Z = 2 * R * D * (J - G), W = Y(R) * J + Y(D) * G, st = X * h * h - Z * l * h + W * l * l, j = Z * (a * h + l * c) - 2 * (X * c * h + W * a * l), gt = X * c * c - Z * a * c + W * a * a, U = (Math.atan2(j, st - gt) + Math.PI) % Math.PI / 2, ht = Math.sin(U), z = Math.cos(U);
          m.rX = Math.abs(P) / Math.sqrt(st * Y(z) + j * ht * z + gt * Y(ht)), m.rY = Math.abs(P) / Math.sqrt(st * Y(ht) - j * ht * z + gt * Y(z)), m.xRot = 180 * U / Math.PI;
        }
      return m.sweepFlag !== void 0 && 0 > P && (m.sweepFlag = +!m.sweepFlag), m;
    });
  }
  function o() {
    return function(a) {
      var l = {};
      for (var c in a)
        l[c] = a[c];
      return l;
    };
  }
  n.ROUND = function(a) {
    function l(c) {
      return Math.round(c * a) / a;
    }
    return a === void 0 && (a = 1e13), Cn(a), function(c) {
      return c.x1 !== void 0 && (c.x1 = l(c.x1)), c.y1 !== void 0 && (c.y1 = l(c.y1)), c.x2 !== void 0 && (c.x2 = l(c.x2)), c.y2 !== void 0 && (c.y2 = l(c.y2)), c.x !== void 0 && (c.x = l(c.x)), c.y !== void 0 && (c.y = l(c.y)), c.rX !== void 0 && (c.rX = l(c.rX)), c.rY !== void 0 && (c.rY = l(c.rY)), c;
    };
  }, n.TO_ABS = t, n.TO_REL = function() {
    return s(function(a, l, c) {
      return a.relative || (a.x1 !== void 0 && (a.x1 -= l), a.y1 !== void 0 && (a.y1 -= c), a.x2 !== void 0 && (a.x2 -= l), a.y2 !== void 0 && (a.y2 -= c), a.x !== void 0 && (a.x -= l), a.y !== void 0 && (a.y -= c), a.relative = !0), a;
    });
  }, n.NORMALIZE_HVZ = function(a, l, c) {
    return a === void 0 && (a = !0), l === void 0 && (l = !0), c === void 0 && (c = !0), s(function(h, u, p, m, g) {
      if (isNaN(m) && !(h.type & at.MOVE_TO))
        throw new Error("path must start with moveto");
      return l && h.type & at.HORIZ_LINE_TO && (h.type = at.LINE_TO, h.y = h.relative ? 0 : p), c && h.type & at.VERT_LINE_TO && (h.type = at.LINE_TO, h.x = h.relative ? 0 : u), a && h.type & at.CLOSE_PATH && (h.type = at.LINE_TO, h.x = h.relative ? m - u : m, h.y = h.relative ? g - p : g), h.type & at.ARC && (h.rX === 0 || h.rY === 0) && (h.type = at.LINE_TO, delete h.rX, delete h.rY, delete h.xRot, delete h.lArcFlag, delete h.sweepFlag), h;
    });
  }, n.NORMALIZE_ST = e, n.QT_TO_C = i, n.INFO = s, n.SANITIZE = function(a) {
    a === void 0 && (a = 0), Cn(a);
    var l = NaN, c = NaN, h = NaN, u = NaN;
    return s(function(p, m, g, _, y) {
      var b = Math.abs, w = !1, v = 0, C = 0;
      if (p.type & at.SMOOTH_CURVE_TO && (v = isNaN(l) ? 0 : m - l, C = isNaN(c) ? 0 : g - c), p.type & (at.CURVE_TO | at.SMOOTH_CURVE_TO) ? (l = p.relative ? m + p.x2 : p.x2, c = p.relative ? g + p.y2 : p.y2) : (l = NaN, c = NaN), p.type & at.SMOOTH_QUAD_TO ? (h = isNaN(h) ? m : 2 * m - h, u = isNaN(u) ? g : 2 * g - u) : p.type & at.QUAD_TO ? (h = p.relative ? m + p.x1 : p.x1, u = p.relative ? g + p.y1 : p.y2) : (h = NaN, u = NaN), p.type & at.LINE_COMMANDS || p.type & at.ARC && (p.rX === 0 || p.rY === 0 || !p.lArcFlag) || p.type & at.CURVE_TO || p.type & at.SMOOTH_CURVE_TO || p.type & at.QUAD_TO || p.type & at.SMOOTH_QUAD_TO) {
        var k = p.x === void 0 ? 0 : p.relative ? p.x : p.x - m, Y = p.y === void 0 ? 0 : p.relative ? p.y : p.y - g;
        v = isNaN(h) ? p.x1 === void 0 ? v : p.relative ? p.x : p.x1 - m : h - m, C = isNaN(u) ? p.y1 === void 0 ? C : p.relative ? p.y : p.y1 - g : u - g;
        var P = p.x2 === void 0 ? 0 : p.relative ? p.x : p.x2 - m, L = p.y2 === void 0 ? 0 : p.relative ? p.y : p.y2 - g;
        b(k) <= a && b(Y) <= a && b(v) <= a && b(C) <= a && b(P) <= a && b(L) <= a && (w = !0);
      }
      return p.type & at.CLOSE_PATH && b(m - _) <= a && b(g - y) <= a && (w = !0), w ? [] : p;
    });
  }, n.MATRIX = r, n.ROTATE = function(a, l, c) {
    l === void 0 && (l = 0), c === void 0 && (c = 0), Cn(a, l, c);
    var h = Math.sin(a), u = Math.cos(a);
    return r(u, h, -h, u, l - l * u + c * h, c - l * h - c * u);
  }, n.TRANSLATE = function(a, l) {
    return l === void 0 && (l = 0), Cn(a, l), r(1, 0, 0, 1, a, l);
  }, n.SCALE = function(a, l) {
    return l === void 0 && (l = a), Cn(a, l), r(a, 0, 0, l, 0, 0);
  }, n.SKEW_X = function(a) {
    return Cn(a), r(1, 0, Math.atan(a), 1, 0, 0);
  }, n.SKEW_Y = function(a) {
    return Cn(a), r(1, Math.atan(a), 0, 1, 0, 0);
  }, n.X_AXIS_SYMMETRY = function(a) {
    return a === void 0 && (a = 0), Cn(a), r(-1, 0, 0, 1, a, 0);
  }, n.Y_AXIS_SYMMETRY = function(a) {
    return a === void 0 && (a = 0), Cn(a), r(1, 0, 0, -1, 0, a);
  }, n.A_TO_C = function() {
    return s(function(a, l, c) {
      return at.ARC === a.type ? function(h, u, p) {
        var m, g, _, y;
        h.cX || pc(h, u, p);
        for (var b = Math.min(h.phi1, h.phi2), w = Math.max(h.phi1, h.phi2) - b, v = Math.ceil(w / 90), C = new Array(v), k = u, Y = p, P = 0; P < v; P++) {
          var L = ku(h.phi1, h.phi2, P / v), R = ku(h.phi1, h.phi2, (P + 1) / v), D = R - L, J = 4 / 3 * Math.tan(D * is / 4), G = [Math.cos(L * is) - J * Math.sin(L * is), Math.sin(L * is) + J * Math.cos(L * is)], X = G[0], Z = G[1], W = [Math.cos(R * is), Math.sin(R * is)], st = W[0], j = W[1], gt = [st + J * Math.sin(R * is), j - J * Math.cos(R * is)], U = gt[0], ht = gt[1];
          C[P] = { relative: h.relative, type: at.CURVE_TO };
          var z = function(O, _t) {
            var rt = rh([O * h.rX, _t * h.rY], h.xRot), ut = rt[0], oe = rt[1];
            return [h.cX + ut, h.cY + oe];
          };
          m = z(X, Z), C[P].x1 = m[0], C[P].y1 = m[1], g = z(U, ht), C[P].x2 = g[0], C[P].y2 = g[1], _ = z(st, j), C[P].x = _[0], C[P].y = _[1], h.relative && (C[P].x1 -= k, C[P].y1 -= Y, C[P].x2 -= k, C[P].y2 -= Y, C[P].x -= k, C[P].y -= Y), k = (y = [C[P].x, C[P].y])[0], Y = y[1];
        }
        return C;
      }(a, a.relative ? 0 : l, a.relative ? 0 : c) : a;
    });
  }, n.ANNOTATE_ARCS = function() {
    return s(function(a, l, c) {
      return a.relative && (l = 0, c = 0), at.ARC === a.type && pc(a, l, c), a;
    });
  }, n.CLONE = o, n.CALCULATE_BOUNDS = function() {
    var a = function(p) {
      var m = {};
      for (var g in p)
        m[g] = p[g];
      return m;
    }, l = t(), c = i(), h = e(), u = s(function(p, m, g) {
      var _ = h(c(l(a(p))));
      function y(ht) {
        ht > u.maxX && (u.maxX = ht), ht < u.minX && (u.minX = ht);
      }
      function b(ht) {
        ht > u.maxY && (u.maxY = ht), ht < u.minY && (u.minY = ht);
      }
      if (_.type & at.DRAWING_COMMANDS && (y(m), b(g)), _.type & at.HORIZ_LINE_TO && y(_.x), _.type & at.VERT_LINE_TO && b(_.y), _.type & at.LINE_TO && (y(_.x), b(_.y)), _.type & at.CURVE_TO) {
        y(_.x), b(_.y);
        for (var w = 0, v = Wu(m, _.x1, _.x2, _.x); w < v.length; w++)
          0 < (U = v[w]) && 1 > U && y(Pu(m, _.x1, _.x2, _.x, U));
        for (var C = 0, k = Wu(g, _.y1, _.y2, _.y); C < k.length; C++)
          0 < (U = k[C]) && 1 > U && b(Pu(g, _.y1, _.y2, _.y, U));
      }
      if (_.type & at.ARC) {
        y(_.x), b(_.y), pc(_, m, g);
        for (var Y = _.xRot / 180 * Math.PI, P = Math.cos(Y) * _.rX, L = Math.sin(Y) * _.rX, R = -Math.sin(Y) * _.rY, D = Math.cos(Y) * _.rY, J = _.phi1 < _.phi2 ? [_.phi1, _.phi2] : -180 > _.phi2 ? [_.phi2 + 360, _.phi1 + 360] : [_.phi2, _.phi1], G = J[0], X = J[1], Z = function(ht) {
          var z = ht[0], O = ht[1], _t = 180 * Math.atan2(O, z) / Math.PI;
          return _t < G ? _t + 360 : _t;
        }, W = 0, st = Cu(R, -P, 0).map(Z); W < st.length; W++)
          (U = st[W]) > G && U < X && y(Mu(_.cX, P, R, U));
        for (var j = 0, gt = Cu(D, -L, 0).map(Z); j < gt.length; j++) {
          var U;
          (U = gt[j]) > G && U < X && b(Mu(_.cY, L, D, U));
        }
      }
      return p;
    });
    return u.minX = 1 / 0, u.maxX = -1 / 0, u.minY = 1 / 0, u.maxY = -1 / 0, u;
  };
})(ti || (ti = {}));
var vn, xp = function() {
  function n() {
  }
  return n.prototype.round = function(t) {
    return this.transform(ti.ROUND(t));
  }, n.prototype.toAbs = function() {
    return this.transform(ti.TO_ABS());
  }, n.prototype.toRel = function() {
    return this.transform(ti.TO_REL());
  }, n.prototype.normalizeHVZ = function(t, e, i) {
    return this.transform(ti.NORMALIZE_HVZ(t, e, i));
  }, n.prototype.normalizeST = function() {
    return this.transform(ti.NORMALIZE_ST());
  }, n.prototype.qtToC = function() {
    return this.transform(ti.QT_TO_C());
  }, n.prototype.aToC = function() {
    return this.transform(ti.A_TO_C());
  }, n.prototype.sanitize = function(t) {
    return this.transform(ti.SANITIZE(t));
  }, n.prototype.translate = function(t, e) {
    return this.transform(ti.TRANSLATE(t, e));
  }, n.prototype.scale = function(t, e) {
    return this.transform(ti.SCALE(t, e));
  }, n.prototype.rotate = function(t, e, i) {
    return this.transform(ti.ROTATE(t, e, i));
  }, n.prototype.matrix = function(t, e, i, s, r, o) {
    return this.transform(ti.MATRIX(t, e, i, s, r, o));
  }, n.prototype.skewX = function(t) {
    return this.transform(ti.SKEW_X(t));
  }, n.prototype.skewY = function(t) {
    return this.transform(ti.SKEW_Y(t));
  }, n.prototype.xSymmetry = function(t) {
    return this.transform(ti.X_AXIS_SYMMETRY(t));
  }, n.prototype.ySymmetry = function(t) {
    return this.transform(ti.Y_AXIS_SYMMETRY(t));
  }, n.prototype.annotateArcs = function() {
    return this.transform(ti.ANNOTATE_ARCS());
  }, n;
}(), gb = function(n) {
  return n === " " || n === "	" || n === "\r" || n === `
`;
}, Gu = function(n) {
  return "0".charCodeAt(0) <= n.charCodeAt(0) && n.charCodeAt(0) <= "9".charCodeAt(0);
}, fb = function(n) {
  function t() {
    var e = n.call(this) || this;
    return e.curNumber = "", e.curCommandType = -1, e.curCommandRelative = !1, e.canParseCommandOrComma = !0, e.curNumberHasExp = !1, e.curNumberHasExpDigits = !1, e.curNumberHasDecimal = !1, e.curArgs = [], e;
  }
  return Sp(t, n), t.prototype.finish = function(e) {
    if (e === void 0 && (e = []), this.parse(" ", e), this.curArgs.length !== 0 || !this.canParseCommandOrComma)
      throw new SyntaxError("Unterminated command at the path end.");
    return e;
  }, t.prototype.parse = function(e, i) {
    var s = this;
    i === void 0 && (i = []);
    for (var r = function(u) {
      i.push(u), s.curArgs.length = 0, s.canParseCommandOrComma = !0;
    }, o = 0; o < e.length; o++) {
      var a = e[o], l = !(this.curCommandType !== at.ARC || this.curArgs.length !== 3 && this.curArgs.length !== 4 || this.curNumber.length !== 1 || this.curNumber !== "0" && this.curNumber !== "1"), c = Gu(a) && (this.curNumber === "0" && a === "0" || l);
      if (!Gu(a) || c)
        if (a !== "e" && a !== "E")
          if (a !== "-" && a !== "+" || !this.curNumberHasExp || this.curNumberHasExpDigits)
            if (a !== "." || this.curNumberHasExp || this.curNumberHasDecimal || l) {
              if (this.curNumber && this.curCommandType !== -1) {
                var h = Number(this.curNumber);
                if (isNaN(h))
                  throw new SyntaxError("Invalid number ending at " + o);
                if (this.curCommandType === at.ARC) {
                  if (this.curArgs.length === 0 || this.curArgs.length === 1) {
                    if (0 > h)
                      throw new SyntaxError('Expected positive number, got "' + h + '" at index "' + o + '"');
                  } else if ((this.curArgs.length === 3 || this.curArgs.length === 4) && this.curNumber !== "0" && this.curNumber !== "1")
                    throw new SyntaxError('Expected a flag, got "' + this.curNumber + '" at index "' + o + '"');
                }
                this.curArgs.push(h), this.curArgs.length === _b[this.curCommandType] && (at.HORIZ_LINE_TO === this.curCommandType ? r({ type: at.HORIZ_LINE_TO, relative: this.curCommandRelative, x: h }) : at.VERT_LINE_TO === this.curCommandType ? r({ type: at.VERT_LINE_TO, relative: this.curCommandRelative, y: h }) : this.curCommandType === at.MOVE_TO || this.curCommandType === at.LINE_TO || this.curCommandType === at.SMOOTH_QUAD_TO ? (r({ type: this.curCommandType, relative: this.curCommandRelative, x: this.curArgs[0], y: this.curArgs[1] }), at.MOVE_TO === this.curCommandType && (this.curCommandType = at.LINE_TO)) : this.curCommandType === at.CURVE_TO ? r({ type: at.CURVE_TO, relative: this.curCommandRelative, x1: this.curArgs[0], y1: this.curArgs[1], x2: this.curArgs[2], y2: this.curArgs[3], x: this.curArgs[4], y: this.curArgs[5] }) : this.curCommandType === at.SMOOTH_CURVE_TO ? r({ type: at.SMOOTH_CURVE_TO, relative: this.curCommandRelative, x2: this.curArgs[0], y2: this.curArgs[1], x: this.curArgs[2], y: this.curArgs[3] }) : this.curCommandType === at.QUAD_TO ? r({ type: at.QUAD_TO, relative: this.curCommandRelative, x1: this.curArgs[0], y1: this.curArgs[1], x: this.curArgs[2], y: this.curArgs[3] }) : this.curCommandType === at.ARC && r({ type: at.ARC, relative: this.curCommandRelative, rX: this.curArgs[0], rY: this.curArgs[1], xRot: this.curArgs[2], lArcFlag: this.curArgs[3], sweepFlag: this.curArgs[4], x: this.curArgs[5], y: this.curArgs[6] })), this.curNumber = "", this.curNumberHasExpDigits = !1, this.curNumberHasExp = !1, this.curNumberHasDecimal = !1, this.canParseCommandOrComma = !0;
              }
              if (!gb(a))
                if (a === "," && this.canParseCommandOrComma)
                  this.canParseCommandOrComma = !1;
                else if (a !== "+" && a !== "-" && a !== ".")
                  if (c)
                    this.curNumber = a, this.curNumberHasDecimal = !1;
                  else {
                    if (this.curArgs.length !== 0)
                      throw new SyntaxError("Unterminated command at index " + o + ".");
                    if (!this.canParseCommandOrComma)
                      throw new SyntaxError('Unexpected character "' + a + '" at index ' + o + ". Command cannot follow comma");
                    if (this.canParseCommandOrComma = !1, a !== "z" && a !== "Z")
                      if (a === "h" || a === "H")
                        this.curCommandType = at.HORIZ_LINE_TO, this.curCommandRelative = a === "h";
                      else if (a === "v" || a === "V")
                        this.curCommandType = at.VERT_LINE_TO, this.curCommandRelative = a === "v";
                      else if (a === "m" || a === "M")
                        this.curCommandType = at.MOVE_TO, this.curCommandRelative = a === "m";
                      else if (a === "l" || a === "L")
                        this.curCommandType = at.LINE_TO, this.curCommandRelative = a === "l";
                      else if (a === "c" || a === "C")
                        this.curCommandType = at.CURVE_TO, this.curCommandRelative = a === "c";
                      else if (a === "s" || a === "S")
                        this.curCommandType = at.SMOOTH_CURVE_TO, this.curCommandRelative = a === "s";
                      else if (a === "q" || a === "Q")
                        this.curCommandType = at.QUAD_TO, this.curCommandRelative = a === "q";
                      else if (a === "t" || a === "T")
                        this.curCommandType = at.SMOOTH_QUAD_TO, this.curCommandRelative = a === "t";
                      else {
                        if (a !== "a" && a !== "A")
                          throw new SyntaxError('Unexpected character "' + a + '" at index ' + o + ".");
                        this.curCommandType = at.ARC, this.curCommandRelative = a === "a";
                      }
                    else
                      i.push({ type: at.CLOSE_PATH }), this.canParseCommandOrComma = !0, this.curCommandType = -1;
                  }
                else
                  this.curNumber = a, this.curNumberHasDecimal = a === ".";
            } else
              this.curNumber += a, this.curNumberHasDecimal = !0;
          else
            this.curNumber += a;
        else
          this.curNumber += a, this.curNumberHasExp = !0;
      else
        this.curNumber += a, this.curNumberHasExpDigits = this.curNumberHasExp;
    }
    return i;
  }, t.prototype.transform = function(e) {
    return Object.create(this, { parse: { value: function(i, s) {
      s === void 0 && (s = []);
      for (var r = 0, o = Object.getPrototypeOf(this).parse.call(this, i); r < o.length; r++) {
        var a = o[r], l = e(a);
        Array.isArray(l) ? s.push.apply(s, l) : s.push(l);
      }
      return s;
    } } });
  }, t;
}(xp), at = function(n) {
  function t(e) {
    var i = n.call(this) || this;
    return i.commands = typeof e == "string" ? t.parse(e) : e, i;
  }
  return Sp(t, n), t.prototype.encode = function() {
    return t.encode(this.commands);
  }, t.prototype.getBounds = function() {
    var e = ti.CALCULATE_BOUNDS();
    return this.transform(e), e;
  }, t.prototype.transform = function(e) {
    for (var i = [], s = 0, r = this.commands; s < r.length; s++) {
      var o = e(r[s]);
      Array.isArray(o) ? i.push.apply(i, o) : i.push(o);
    }
    return this.commands = i, this;
  }, t.encode = function(e) {
    return pb(e);
  }, t.parse = function(e) {
    var i = new fb(), s = [];
    return i.parse(e, s), i.finish(s), s;
  }, t.CLOSE_PATH = 1, t.MOVE_TO = 2, t.HORIZ_LINE_TO = 4, t.VERT_LINE_TO = 8, t.LINE_TO = 16, t.CURVE_TO = 32, t.SMOOTH_CURVE_TO = 64, t.QUAD_TO = 128, t.SMOOTH_QUAD_TO = 256, t.ARC = 512, t.LINE_COMMANDS = t.LINE_TO | t.HORIZ_LINE_TO | t.VERT_LINE_TO, t.DRAWING_COMMANDS = t.HORIZ_LINE_TO | t.VERT_LINE_TO | t.LINE_TO | t.CURVE_TO | t.SMOOTH_CURVE_TO | t.QUAD_TO | t.SMOOTH_QUAD_TO | t.ARC, t;
}(xp), _b = ((vn = {})[at.MOVE_TO] = 2, vn[at.LINE_TO] = 2, vn[at.HORIZ_LINE_TO] = 1, vn[at.VERT_LINE_TO] = 1, vn[at.CLOSE_PATH] = 0, vn[at.QUAD_TO] = 4, vn[at.SMOOTH_QUAD_TO] = 2, vn[at.CURVE_TO] = 6, vn[at.SMOOTH_CURVE_TO] = 4, vn[at.ARC] = 7, vn);
function ul(n) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? ul = function(t) {
    return typeof t;
  } : ul = function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, ul(n);
}
function yb(n, t) {
  if (!(n instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
var bb = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259], Ib = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];
function wb(n, t, e, i, s) {
  if (typeof n == "string" && (n = document.getElementById(n)), !n || ul(n) !== "object" || !("getContext" in n))
    throw new TypeError("Expecting canvas with `getContext` method in processCanvasRGB(A) calls!");
  var r = n.getContext("2d");
  try {
    return r.getImageData(t, e, i, s);
  } catch (o) {
    throw new Error("unable to access image data: " + o);
  }
}
function vb(n, t, e, i, s, r) {
  if (!(isNaN(r) || r < 1)) {
    r |= 0;
    var o = wb(n, t, e, i, s);
    o = Sb(o, t, e, i, s, r), n.getContext("2d").putImageData(o, t, e);
  }
}
function Sb(n, t, e, i, s, r) {
  for (var o = n.data, a = 2 * r + 1, l = i - 1, c = s - 1, h = r + 1, u = h * (h + 1) / 2, p = new Yu(), m = p, g, _ = 1; _ < a; _++)
    m = m.next = new Yu(), _ === h && (g = m);
  m.next = p;
  for (var y = null, b = null, w = 0, v = 0, C = bb[r], k = Ib[r], Y = 0; Y < s; Y++) {
    m = p;
    for (var P = o[v], L = o[v + 1], R = o[v + 2], D = o[v + 3], J = 0; J < h; J++)
      m.r = P, m.g = L, m.b = R, m.a = D, m = m.next;
    for (var G = 0, X = 0, Z = 0, W = 0, st = h * P, j = h * L, gt = h * R, U = h * D, ht = u * P, z = u * L, O = u * R, _t = u * D, rt = 1; rt < h; rt++) {
      var ut = v + ((l < rt ? l : rt) << 2), oe = o[ut], Le = o[ut + 1], Wt = o[ut + 2], Dt = o[ut + 3], ee = h - rt;
      ht += (m.r = oe) * ee, z += (m.g = Le) * ee, O += (m.b = Wt) * ee, _t += (m.a = Dt) * ee, G += oe, X += Le, Z += Wt, W += Dt, m = m.next;
    }
    y = p, b = g;
    for (var ie = 0; ie < i; ie++) {
      var Ye = _t * C >> k;
      if (o[v + 3] = Ye, Ye !== 0) {
        var bi = 255 / Ye;
        o[v] = (ht * C >> k) * bi, o[v + 1] = (z * C >> k) * bi, o[v + 2] = (O * C >> k) * bi;
      } else
        o[v] = o[v + 1] = o[v + 2] = 0;
      ht -= st, z -= j, O -= gt, _t -= U, st -= y.r, j -= y.g, gt -= y.b, U -= y.a;
      var x = ie + r + 1;
      x = w + (x < l ? x : l) << 2, G += y.r = o[x], X += y.g = o[x + 1], Z += y.b = o[x + 2], W += y.a = o[x + 3], ht += G, z += X, O += Z, _t += W, y = y.next;
      var $ = b, H = $.r, T = $.g, V = $.b, K = $.a;
      st += H, j += T, gt += V, U += K, G -= H, X -= T, Z -= V, W -= K, b = b.next, v += 4;
    }
    w += i;
  }
  for (var tt = 0; tt < i; tt++) {
    v = tt << 2;
    var nt = o[v], A = o[v + 1], lt = o[v + 2], dt = o[v + 3], ct = h * nt, It = h * A, jt = h * lt, Ft = h * dt, si = u * nt, cn = u * A, Ii = u * lt, hn = u * dt;
    m = p;
    for (var pe = 0; pe < h; pe++)
      m.r = nt, m.g = A, m.b = lt, m.a = dt, m = m.next;
    for (var En = i, Rn = 0, Gi = 0, He = 0, Yi = 0, qi = 1; qi <= r; qi++) {
      v = En + tt << 2;
      var wn = h - qi;
      si += (m.r = nt = o[v]) * wn, cn += (m.g = A = o[v + 1]) * wn, Ii += (m.b = lt = o[v + 2]) * wn, hn += (m.a = dt = o[v + 3]) * wn, Yi += nt, Rn += A, Gi += lt, He += dt, m = m.next, qi < c && (En += i);
    }
    v = tt, y = p, b = g;
    for (var Zi = 0; Zi < s; Zi++) {
      var Ve = v << 2;
      o[Ve + 3] = dt = hn * C >> k, dt > 0 ? (dt = 255 / dt, o[Ve] = (si * C >> k) * dt, o[Ve + 1] = (cn * C >> k) * dt, o[Ve + 2] = (Ii * C >> k) * dt) : o[Ve] = o[Ve + 1] = o[Ve + 2] = 0, si -= ct, cn -= It, Ii -= jt, hn -= Ft, ct -= y.r, It -= y.g, jt -= y.b, Ft -= y.a, Ve = tt + ((Ve = Zi + h) < c ? Ve : c) * i << 2, si += Yi += y.r = o[Ve], cn += Rn += y.g = o[Ve + 1], Ii += Gi += y.b = o[Ve + 2], hn += He += y.a = o[Ve + 3], y = y.next, ct += nt = b.r, It += A = b.g, jt += lt = b.b, Ft += dt = b.a, Yi -= nt, Rn -= A, Gi -= lt, He -= dt, b = b.next, v += i;
    }
  }
  return n;
}
var Yu = (
  /**
   * Set properties.
   */
  function n() {
    yb(this, n), this.r = 0, this.g = 0, this.b = 0, this.a = 0, this.next = null;
  }
);
function io(n) {
  return n.replace(/(?!\u3000)\s+/gm, " ");
}
function xb(n) {
  return n.replace(/^[\n \t]+/, "");
}
function Zb(n) {
  return n.replace(/[\n \t]+$/, "");
}
function an(n) {
  const t = n.match(/-?(\d+(?:\.\d*(?:[eE][+-]?\d+)?)?|\.\d+)(?=\D|$)/gm);
  return t ? t.map(parseFloat) : [];
}
function Cb(n) {
  const t = an(n);
  return [
    t[0] || 0,
    t[1] || 0,
    t[2] || 0,
    t[3] || 0,
    t[4] || 0,
    t[5] || 0
  ];
}
const kb = /^[A-Z-]+$/;
function Mb(n) {
  return kb.test(n) ? n.toLowerCase() : n;
}
function Zp(n) {
  const t = /url\(('([^']+)'|"([^"]+)"|([^'")]+))\)/.exec(n);
  return t && (t[2] || t[3] || t[4]) || "";
}
function Wb(n) {
  if (!n.startsWith("rgb"))
    return n;
  let t = 3;
  return n.replace(
    /\d+(\.\d+)?/g,
    (i, s) => t-- && s ? String(Math.round(parseFloat(i))) : i
  );
}
const Pb = /(\[[^\]]+\])/g, Gb = /(#[^\s+>~.[:]+)/g, Yb = /(\.[^\s+>~.[:]+)/g, Vb = /(::[^\s+>~.[:]+|:first-line|:first-letter|:before|:after)/gi, Tb = /(:[\w-]+\([^)]*\))/gi, Eb = /(:[^\s+>~.[:]+)/g, Rb = /([^\s+>~.[:]+)/g;
function Hs(n, t) {
  const e = t.exec(n);
  return e ? [
    n.replace(t, " "),
    e.length
  ] : [
    n,
    0
  ];
}
function Nb(n) {
  const t = [
    0,
    0,
    0
  ];
  let e = n.replace(/:not\(([^)]*)\)/g, "     $1 ").replace(/{[\s\S]*/gm, " "), i = 0;
  return [e, i] = Hs(e, Pb), t[1] += i, [e, i] = Hs(e, Gb), t[0] += i, [e, i] = Hs(e, Yb), t[1] += i, [e, i] = Hs(e, Vb), t[2] += i, [e, i] = Hs(e, Tb), t[1] += i, [e, i] = Hs(e, Eb), t[1] += i, e = e.replace(/[*\s+>~]/g, " ").replace(/[#.]/g, " "), [e, i] = Hs(e, Rb), t[2] += i, t.join("");
}
const Fr = 1e-8;
function Vu(n) {
  return Math.sqrt(Math.pow(n[0], 2) + Math.pow(n[1], 2));
}
function oh(n, t) {
  return (n[0] * t[0] + n[1] * t[1]) / (Vu(n) * Vu(t));
}
function Tu(n, t) {
  return (n[0] * t[1] < n[1] * t[0] ? -1 : 1) * Math.acos(oh(n, t));
}
function Eu(n) {
  return n * n * n;
}
function Ru(n) {
  return 3 * n * n * (1 - n);
}
function Nu(n) {
  return 3 * n * (1 - n) * (1 - n);
}
function Lu(n) {
  return (1 - n) * (1 - n) * (1 - n);
}
function Xu(n) {
  return n * n;
}
function Fu(n) {
  return 2 * n * (1 - n);
}
function Ku(n) {
  return (1 - n) * (1 - n);
}
class Zt {
  static empty(t) {
    return new Zt(t, "EMPTY", "");
  }
  split() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : " ";
    const { document: e, name: i } = this;
    return io(this.getString()).trim().split(t).map(
      (s) => new Zt(e, i, s)
    );
  }
  hasValue(t) {
    const e = this.value;
    return e !== null && e !== "" && (t || e !== 0) && typeof e < "u";
  }
  isString(t) {
    const { value: e } = this, i = typeof e == "string";
    return !i || !t ? i : t.test(e);
  }
  isUrlDefinition() {
    return this.isString(/^url\(/);
  }
  isPixels() {
    if (!this.hasValue())
      return !1;
    const t = this.getString();
    switch (!0) {
      case t.endsWith("px"):
      case /^[0-9]+$/.test(t):
        return !0;
      default:
        return !1;
    }
  }
  setValue(t) {
    return this.value = t, this;
  }
  getValue(t) {
    return typeof t > "u" || this.hasValue() ? this.value : t;
  }
  getNumber(t) {
    if (!this.hasValue())
      return typeof t > "u" ? 0 : parseFloat(t);
    const { value: e } = this;
    let i = parseFloat(e);
    return this.isString(/%$/) && (i /= 100), i;
  }
  getString(t) {
    return typeof t > "u" || this.hasValue() ? typeof this.value > "u" ? "" : String(this.value) : String(t);
  }
  getColor(t) {
    let e = this.getString(t);
    return this.isNormalizedColor || (this.isNormalizedColor = !0, e = Wb(e), this.value = e), e;
  }
  getDpi() {
    return 96;
  }
  getRem() {
    return this.document.rootEmSize;
  }
  getEm() {
    return this.document.emSize;
  }
  getUnits() {
    return this.getString().replace(/[0-9.-]/g, "");
  }
  getPixels(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    if (!this.hasValue())
      return 0;
    const [i, s] = typeof t == "boolean" ? [
      void 0,
      t
    ] : [
      t
    ], { viewPort: r } = this.document.screen;
    switch (!0) {
      case this.isString(/vmin$/):
        return this.getNumber() / 100 * Math.min(r.computeSize("x"), r.computeSize("y"));
      case this.isString(/vmax$/):
        return this.getNumber() / 100 * Math.max(r.computeSize("x"), r.computeSize("y"));
      case this.isString(/vw$/):
        return this.getNumber() / 100 * r.computeSize("x");
      case this.isString(/vh$/):
        return this.getNumber() / 100 * r.computeSize("y");
      case this.isString(/rem$/):
        return this.getNumber() * this.getRem();
      case this.isString(/em$/):
        return this.getNumber() * this.getEm();
      case this.isString(/ex$/):
        return this.getNumber() * this.getEm() / 2;
      case this.isString(/px$/):
        return this.getNumber();
      case this.isString(/pt$/):
        return this.getNumber() * this.getDpi() * (1 / 72);
      case this.isString(/pc$/):
        return this.getNumber() * 15;
      case this.isString(/cm$/):
        return this.getNumber() * this.getDpi() / 2.54;
      case this.isString(/mm$/):
        return this.getNumber() * this.getDpi() / 25.4;
      case this.isString(/in$/):
        return this.getNumber() * this.getDpi();
      case (this.isString(/%$/) && s):
        return this.getNumber() * this.getEm();
      case this.isString(/%$/):
        return this.getNumber() * r.computeSize(i);
      default: {
        const o = this.getNumber();
        return e && o < 1 ? o * r.computeSize(i) : o;
      }
    }
  }
  getMilliseconds() {
    return this.hasValue() ? this.isString(/ms$/) ? this.getNumber() : this.getNumber() * 1e3 : 0;
  }
  getRadians() {
    if (!this.hasValue())
      return 0;
    switch (!0) {
      case this.isString(/deg$/):
        return this.getNumber() * (Math.PI / 180);
      case this.isString(/grad$/):
        return this.getNumber() * (Math.PI / 200);
      case this.isString(/rad$/):
        return this.getNumber();
      default:
        return this.getNumber() * (Math.PI / 180);
    }
  }
  getDefinition() {
    const t = this.getString(), e = /#([^)'"]+)/.exec(t), i = (e == null ? void 0 : e[1]) || t;
    return this.document.definitions[i];
  }
  getFillStyleDefinition(t, e) {
    let i = this.getDefinition();
    if (!i)
      return null;
    if (typeof i.createGradient == "function" && "getBoundingBox" in t)
      return i.createGradient(this.document.ctx, t, e);
    if (typeof i.createPattern == "function") {
      if (i.getHrefAttribute().hasValue()) {
        const s = i.getAttribute("patternTransform");
        i = i.getHrefAttribute().getDefinition(), i && s.hasValue() && i.getAttribute("patternTransform", !0).setValue(s.value);
      }
      if (i)
        return i.createPattern(this.document.ctx, t, e);
    }
    return null;
  }
  getTextBaseline() {
    if (!this.hasValue())
      return null;
    const t = this.getString();
    return Zt.textBaselineMapping[t] || null;
  }
  addOpacity(t) {
    let e = this.getColor();
    const i = e.length;
    let s = 0;
    for (let r = 0; r < i && (e[r] === "," && s++, s !== 3); r++)
      ;
    if (t.hasValue() && this.isString() && s !== 3) {
      const r = new sh(e);
      r.ok && (r.alpha = t.getNumber(), e = r.toRGBA());
    }
    return new Zt(this.document, this.name, e);
  }
  constructor(t, e, i) {
    this.document = t, this.name = e, this.value = i, this.isNormalizedColor = !1;
  }
}
Zt.textBaselineMapping = {
  baseline: "alphabetic",
  "before-edge": "top",
  "text-before-edge": "top",
  middle: "middle",
  central: "middle",
  "after-edge": "bottom",
  "text-after-edge": "bottom",
  ideographic: "ideographic",
  alphabetic: "alphabetic",
  hanging: "hanging",
  mathematical: "alphabetic"
};
class ua {
  clear() {
    this.viewPorts = [];
  }
  setCurrent(t, e) {
    this.viewPorts.push({
      width: t,
      height: e
    });
  }
  removeCurrent() {
    this.viewPorts.pop();
  }
  getRoot() {
    const [t] = this.viewPorts;
    return t || Ou();
  }
  getCurrent() {
    const { viewPorts: t } = this, e = t[t.length - 1];
    return e || Ou();
  }
  get width() {
    return this.getCurrent().width;
  }
  get height() {
    return this.getCurrent().height;
  }
  computeSize(t) {
    return typeof t == "number" ? t : t === "x" ? this.width : t === "y" ? this.height : Math.sqrt(Math.pow(this.width, 2) + Math.pow(this.height, 2)) / Math.sqrt(2);
  }
  constructor() {
    this.viewPorts = [];
  }
}
ua.DEFAULT_VIEWPORT_WIDTH = 800;
ua.DEFAULT_VIEWPORT_HEIGHT = 600;
function Ou() {
  return {
    width: ua.DEFAULT_VIEWPORT_WIDTH,
    height: ua.DEFAULT_VIEWPORT_HEIGHT
  };
}
class Pe {
  static parse(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    const [i = e, s = e] = an(t);
    return new Pe(i, s);
  }
  static parseScale(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    const [i = e, s = i] = an(t);
    return new Pe(i, s);
  }
  static parsePath(t) {
    const e = an(t), i = e.length, s = [];
    for (let r = 0; r < i; r += 2)
      s.push(new Pe(e[r], e[r + 1]));
    return s;
  }
  angleTo(t) {
    return Math.atan2(t.y - this.y, t.x - this.x);
  }
  applyTransform(t) {
    const { x: e, y: i } = this, s = e * t[0] + i * t[2] + t[4], r = e * t[1] + i * t[3] + t[5];
    this.x = s, this.y = r;
  }
  constructor(t, e) {
    this.x = t, this.y = e;
  }
}
class Lb {
  isWorking() {
    return this.working;
  }
  start() {
    if (this.working)
      return;
    const { screen: t, onClick: e, onMouseMove: i } = this, s = t.ctx.canvas;
    s.onclick = e, s.onmousemove = i, this.working = !0;
  }
  stop() {
    if (!this.working)
      return;
    const t = this.screen.ctx.canvas;
    this.working = !1, t.onclick = null, t.onmousemove = null;
  }
  hasEvents() {
    return this.working && this.events.length > 0;
  }
  runEvents() {
    if (!this.working)
      return;
    const { screen: t, events: e, eventElements: i } = this, { style: s } = t.ctx.canvas;
    let r;
    s && (s.cursor = ""), e.forEach((o, a) => {
      let { run: l } = o;
      for (r = i[a]; r; )
        l(r), r = r.parent;
    }), this.events = [], this.eventElements = [];
  }
  checkPath(t, e) {
    if (!this.working || !e)
      return;
    const { events: i, eventElements: s } = this;
    i.forEach((r, o) => {
      let { x: a, y: l } = r;
      !s[o] && e.isPointInPath && e.isPointInPath(a, l) && (s[o] = t);
    });
  }
  checkBoundingBox(t, e) {
    if (!this.working || !e)
      return;
    const { events: i, eventElements: s } = this;
    i.forEach((r, o) => {
      let { x: a, y: l } = r;
      !s[o] && e.isPointInBox(a, l) && (s[o] = t);
    });
  }
  mapXY(t, e) {
    const { window: i, ctx: s } = this.screen, r = new Pe(t, e);
    let o = s.canvas;
    for (; o; )
      r.x -= o.offsetLeft, r.y -= o.offsetTop, o = o.offsetParent;
    return i != null && i.scrollX && (r.x += i.scrollX), i != null && i.scrollY && (r.y += i.scrollY), r;
  }
  onClick(t) {
    const { x: e, y: i } = this.mapXY(t.clientX, t.clientY);
    this.events.push({
      type: "onclick",
      x: e,
      y: i,
      run(s) {
        s.onClick && s.onClick();
      }
    });
  }
  onMouseMove(t) {
    const { x: e, y: i } = this.mapXY(t.clientX, t.clientY);
    this.events.push({
      type: "onmousemove",
      x: e,
      y: i,
      run(s) {
        s.onMouseMove && s.onMouseMove();
      }
    });
  }
  constructor(t) {
    this.screen = t, this.working = !1, this.events = [], this.eventElements = [], this.onClick = this.onClick.bind(this), this.onMouseMove = this.onMouseMove.bind(this);
  }
}
const Cp = typeof window < "u" ? window : null, kp = typeof fetch < "u" ? fetch.bind(void 0) : void 0;
class bs {
  wait(t) {
    this.waits.push(t);
  }
  ready() {
    return this.readyPromise ? this.readyPromise : Promise.resolve();
  }
  isReady() {
    if (this.isReadyLock)
      return !0;
    const t = this.waits.every(
      (e) => e()
    );
    return t && (this.waits = [], this.resolveReady && this.resolveReady()), this.isReadyLock = t, t;
  }
  setDefaults(t) {
    t.strokeStyle = "rgba(0,0,0,0)", t.lineCap = "butt", t.lineJoin = "miter", t.miterLimit = 4;
  }
  setViewBox(t) {
    let { document: e, ctx: i, aspectRatio: s, width: r, desiredWidth: o, height: a, desiredHeight: l, minX: c = 0, minY: h = 0, refX: u, refY: p, clip: m = !1, clipX: g = 0, clipY: _ = 0 } = t;
    const y = io(s).replace(/^defer\s/, ""), [b, w] = y.split(" "), v = b || "xMidYMid", C = w || "meet", k = r / o, Y = a / l, P = Math.min(k, Y), L = Math.max(k, Y);
    let R = o, D = l;
    C === "meet" && (R *= P, D *= P), C === "slice" && (R *= L, D *= L);
    const J = new Zt(e, "refX", u), G = new Zt(e, "refY", p), X = J.hasValue() && G.hasValue();
    if (X && i.translate(-P * J.getPixels("x"), -P * G.getPixels("y")), m) {
      const Z = P * g, W = P * _;
      i.beginPath(), i.moveTo(Z, W), i.lineTo(r, W), i.lineTo(r, a), i.lineTo(Z, a), i.closePath(), i.clip();
    }
    if (!X) {
      const Z = C === "meet" && P === Y, W = C === "slice" && L === Y, st = C === "meet" && P === k, j = C === "slice" && L === k;
      v.startsWith("xMid") && (Z || W) && i.translate(r / 2 - R / 2, 0), v.endsWith("YMid") && (st || j) && i.translate(0, a / 2 - D / 2), v.startsWith("xMax") && (Z || W) && i.translate(r - R, 0), v.endsWith("YMax") && (st || j) && i.translate(0, a - D);
    }
    switch (!0) {
      case v === "none":
        i.scale(k, Y);
        break;
      case C === "meet":
        i.scale(P, P);
        break;
      case C === "slice":
        i.scale(L, L);
        break;
    }
    i.translate(-c, -h);
  }
  start(t) {
    let { enableRedraw: e = !1, ignoreMouse: i = !1, ignoreAnimation: s = !1, ignoreDimensions: r = !1, ignoreClear: o = !1, forceRedraw: a, scaleWidth: l, scaleHeight: c, offsetX: h, offsetY: u } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const { mouse: p } = this, m = 1e3 / bs.FRAMERATE;
    if (this.isReadyLock = !1, this.frameDuration = m, this.readyPromise = new Promise((w) => {
      this.resolveReady = w;
    }), this.isReady() && this.render(t, r, o, l, c, h, u), !e)
      return;
    let g = Date.now(), _ = g, y = 0;
    const b = () => {
      g = Date.now(), y = g - _, y >= m && (_ = g - y % m, this.shouldUpdate(s, a) && (this.render(t, r, o, l, c, h, u), p.runEvents())), this.intervalId = mc(b);
    };
    i || p.start(), this.intervalId = mc(b);
  }
  stop() {
    this.intervalId && (mc.cancel(this.intervalId), this.intervalId = null), this.mouse.stop();
  }
  shouldUpdate(t, e) {
    if (!t) {
      const { frameDuration: i } = this;
      if (this.animations.reduce(
        (r, o) => o.update(i) || r,
        !1
      ))
        return !0;
    }
    return !!(typeof e == "function" && e() || !this.isReadyLock && this.isReady() || this.mouse.hasEvents());
  }
  render(t, e, i, s, r, o, a) {
    const { viewPort: l, ctx: c, isFirstRender: h } = this, u = c.canvas;
    l.clear(), u.width && u.height && l.setCurrent(u.width, u.height);
    const p = t.getStyle("width"), m = t.getStyle("height");
    !e && (h || typeof s != "number" && typeof r != "number") && (p.hasValue() && (u.width = p.getPixels("x"), u.style && (u.style.width = "".concat(u.width, "px"))), m.hasValue() && (u.height = m.getPixels("y"), u.style && (u.style.height = "".concat(u.height, "px"))));
    let g = u.clientWidth || u.width, _ = u.clientHeight || u.height;
    if (e && p.hasValue() && m.hasValue() && (g = p.getPixels("x"), _ = m.getPixels("y")), l.setCurrent(g, _), typeof o == "number" && t.getAttribute("x", !0).setValue(o), typeof a == "number" && t.getAttribute("y", !0).setValue(a), typeof s == "number" || typeof r == "number") {
      const y = an(t.getAttribute("viewBox").getString());
      let b = 0, w = 0;
      if (typeof s == "number") {
        const C = t.getStyle("width");
        C.hasValue() ? b = C.getPixels("x") / s : y[2] && !isNaN(y[2]) && (b = y[2] / s);
      }
      if (typeof r == "number") {
        const C = t.getStyle("height");
        C.hasValue() ? w = C.getPixels("y") / r : y[3] && !isNaN(y[3]) && (w = y[3] / r);
      }
      b || (b = w), w || (w = b), t.getAttribute("width", !0).setValue(s), t.getAttribute("height", !0).setValue(r);
      const v = t.getStyle("transform", !0, !0);
      v.setValue("".concat(v.getString(), " scale(").concat(1 / b, ", ").concat(1 / w, ")"));
    }
    i || c.clearRect(0, 0, g, _), t.render(c), h && (this.isFirstRender = !1);
  }
  constructor(t, { fetch: e = kp, window: i = Cp } = {}) {
    if (this.ctx = t, this.viewPort = new ua(), this.mouse = new Lb(this), this.animations = [], this.waits = [], this.frameDuration = 0, this.isReadyLock = !1, this.isFirstRender = !0, this.intervalId = null, this.window = i, !e)
      throw new Error("Can't find 'fetch' in 'globalThis', please provide it via options");
    this.fetch = e;
  }
}
bs.defaultWindow = Cp;
bs.defaultFetch = kp;
bs.FRAMERATE = 30;
bs.MAX_VIRTUAL_PIXELS = 3e4;
const { defaultFetch: Xb } = bs, Fb = typeof DOMParser < "u" ? DOMParser : void 0;
class gc {
  async parse(t) {
    return t.startsWith("<") ? this.parseFromString(t) : this.load(t);
  }
  parseFromString(t) {
    const e = new this.DOMParser();
    try {
      return this.checkDocument(e.parseFromString(t, "image/svg+xml"));
    } catch {
      return this.checkDocument(e.parseFromString(t, "text/xml"));
    }
  }
  checkDocument(t) {
    const e = t.getElementsByTagName("parsererror")[0];
    if (e)
      throw new Error(e.textContent || "Unknown parse error");
    return t;
  }
  async load(t) {
    const i = await (await this.fetch(t)).text();
    return this.parseFromString(i);
  }
  constructor({ fetch: t = Xb, DOMParser: e = Fb } = {}) {
    if (!t)
      throw new Error("Can't find 'fetch' in 'globalThis', please provide it via options");
    if (!e)
      throw new Error("Can't find 'DOMParser' in 'globalThis', please provide it via options");
    this.fetch = t, this.DOMParser = e;
  }
}
class Kb {
  apply(t) {
    const { x: e, y: i } = this.point;
    t.translate(e || 0, i || 0);
  }
  unapply(t) {
    const { x: e, y: i } = this.point;
    t.translate(-1 * e || 0, -1 * i || 0);
  }
  applyToPoint(t) {
    const { x: e, y: i } = this.point;
    t.applyTransform([
      1,
      0,
      0,
      1,
      e || 0,
      i || 0
    ]);
  }
  constructor(t, e) {
    this.type = "translate", this.point = Pe.parse(e);
  }
}
class Ob {
  apply(t) {
    const { cx: e, cy: i, originX: s, originY: r, angle: o } = this, a = e + s.getPixels("x"), l = i + r.getPixels("y");
    t.translate(a, l), t.rotate(o.getRadians()), t.translate(-a, -l);
  }
  unapply(t) {
    const { cx: e, cy: i, originX: s, originY: r, angle: o } = this, a = e + s.getPixels("x"), l = i + r.getPixels("y");
    t.translate(a, l), t.rotate(-1 * o.getRadians()), t.translate(-a, -l);
  }
  applyToPoint(t) {
    const { cx: e, cy: i, angle: s } = this, r = s.getRadians();
    t.applyTransform([
      1,
      0,
      0,
      1,
      e || 0,
      i || 0
      // this.p.y
    ]), t.applyTransform([
      Math.cos(r),
      Math.sin(r),
      -Math.sin(r),
      Math.cos(r),
      0,
      0
    ]), t.applyTransform([
      1,
      0,
      0,
      1,
      -e || 0,
      -i || 0
      // -this.p.y
    ]);
  }
  constructor(t, e, i) {
    this.type = "rotate";
    const s = an(e);
    this.angle = new Zt(t, "angle", s[0]), this.originX = i[0], this.originY = i[1], this.cx = s[1] || 0, this.cy = s[2] || 0;
  }
}
class Ab {
  apply(t) {
    const { scale: { x: e, y: i }, originX: s, originY: r } = this, o = s.getPixels("x"), a = r.getPixels("y");
    t.translate(o, a), t.scale(e, i || e), t.translate(-o, -a);
  }
  unapply(t) {
    const { scale: { x: e, y: i }, originX: s, originY: r } = this, o = s.getPixels("x"), a = r.getPixels("y");
    t.translate(o, a), t.scale(1 / e, 1 / i || e), t.translate(-o, -a);
  }
  applyToPoint(t) {
    const { x: e, y: i } = this.scale;
    t.applyTransform([
      e || 0,
      0,
      0,
      i || 0,
      0,
      0
    ]);
  }
  constructor(t, e, i) {
    this.type = "scale";
    const s = Pe.parseScale(e);
    (s.x === 0 || s.y === 0) && (s.x = Fr, s.y = Fr), this.scale = s, this.originX = i[0], this.originY = i[1];
  }
}
class Mp {
  apply(t) {
    const { originX: e, originY: i, matrix: s } = this, r = e.getPixels("x"), o = i.getPixels("y");
    t.translate(r, o), t.transform(s[0], s[1], s[2], s[3], s[4], s[5]), t.translate(-r, -o);
  }
  unapply(t) {
    const { originX: e, originY: i, matrix: s } = this, r = s[0], o = s[2], a = s[4], l = s[1], c = s[3], h = s[5], u = 0, p = 0, m = 1, g = 1 / (r * (c * m - h * p) - o * (l * m - h * u) + a * (l * p - c * u)), _ = e.getPixels("x"), y = i.getPixels("y");
    t.translate(_, y), t.transform(g * (c * m - h * p), g * (h * u - l * m), g * (a * p - o * m), g * (r * m - a * u), g * (o * h - a * c), g * (a * l - r * h)), t.translate(-_, -y);
  }
  applyToPoint(t) {
    t.applyTransform(this.matrix);
  }
  constructor(t, e, i) {
    this.type = "matrix", this.matrix = Cb(e), this.originX = i[0], this.originY = i[1];
  }
}
class Wp extends Mp {
  constructor(t, e, i) {
    super(t, e, i), this.type = "skew", this.angle = new Zt(t, "angle", e);
  }
}
class Db extends Wp {
  constructor(t, e, i) {
    super(t, e, i), this.type = "skewX", this.matrix = [
      1,
      0,
      Math.tan(this.angle.getRadians()),
      1,
      0,
      0
    ];
  }
}
class zb extends Wp {
  constructor(t, e, i) {
    super(t, e, i), this.type = "skewY", this.matrix = [
      1,
      Math.tan(this.angle.getRadians()),
      0,
      1,
      0,
      0
    ];
  }
}
function Bb(n) {
  return io(n).trim().replace(/\)([a-zA-Z])/g, ") $1").replace(/\)(\s?,\s?)/g, ") ").split(/\s(?=[a-z])/);
}
function Jb(n) {
  const [t = "", e = ""] = n.split("(");
  return [
    t.trim(),
    e.trim().replace(")", "")
  ];
}
class _r {
  static fromElement(t, e) {
    const i = e.getStyle("transform", !1, !0);
    if (i.hasValue()) {
      const [s, r = s] = e.getStyle("transform-origin", !1, !0).split();
      if (s && r) {
        const o = [
          s,
          r
        ];
        return new _r(t, i.getString(), o);
      }
    }
    return null;
  }
  apply(t) {
    this.transforms.forEach(
      (e) => e.apply(t)
    );
  }
  unapply(t) {
    this.transforms.forEach(
      (e) => e.unapply(t)
    );
  }
  // TODO: applyToPoint unused ... remove?
  applyToPoint(t) {
    this.transforms.forEach(
      (e) => e.applyToPoint(t)
    );
  }
  constructor(t, e, i) {
    this.document = t, this.transforms = [], Bb(e).forEach((r) => {
      if (r === "none")
        return;
      const [o, a] = Jb(r), l = _r.transformTypes[o];
      l && this.transforms.push(new l(this.document, a, i));
    });
  }
}
_r.transformTypes = {
  translate: Kb,
  rotate: Ob,
  scale: Ab,
  matrix: Mp,
  skewX: Db,
  skewY: zb
};
class Me {
  getAttribute(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    const i = this.attributes[t];
    if (!i && e) {
      const s = new Zt(this.document, t, "");
      return this.attributes[t] = s, s;
    }
    return i || Zt.empty(this.document);
  }
  getHrefAttribute() {
    let t;
    for (const e in this.attributes)
      if (e === "href" || e.endsWith(":href")) {
        t = this.attributes[e];
        break;
      }
    return t || Zt.empty(this.document);
  }
  getStyle(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
    const s = this.styles[t];
    if (s)
      return s;
    const r = this.getAttribute(t);
    if (r.hasValue())
      return this.styles[t] = r, r;
    if (!i) {
      const { parent: o } = this;
      if (o) {
        const a = o.getStyle(t);
        if (a.hasValue())
          return a;
      }
    }
    if (e) {
      const o = new Zt(this.document, t, "");
      return this.styles[t] = o, o;
    }
    return Zt.empty(this.document);
  }
  render(t) {
    if (!(this.getStyle("display").getString() === "none" || this.getStyle("visibility").getString() === "hidden")) {
      if (t.save(), this.getStyle("mask").hasValue()) {
        const e = this.getStyle("mask").getDefinition();
        e && (this.applyEffects(t), e.apply(t, this));
      } else if (this.getStyle("filter").getValue("none") !== "none") {
        const e = this.getStyle("filter").getDefinition();
        e && (this.applyEffects(t), e.apply(t, this));
      } else
        this.setContext(t), this.renderChildren(t), this.clearContext(t);
      t.restore();
    }
  }
  setContext(t) {
  }
  applyEffects(t) {
    const e = _r.fromElement(this.document, this);
    e && e.apply(t);
    const i = this.getStyle("clip-path", !1, !0);
    if (i.hasValue()) {
      const s = i.getDefinition();
      s && s.apply(t);
    }
  }
  clearContext(t) {
  }
  renderChildren(t) {
    this.children.forEach((e) => {
      e.render(t);
    });
  }
  addChild(t) {
    const e = t instanceof Me ? t : this.document.createElement(t);
    e.parent = this, Me.ignoreChildTypes.includes(e.type) || this.children.push(e);
  }
  matchesSelector(t) {
    var e;
    const { node: i } = this;
    if (typeof i.matches == "function")
      return i.matches(t);
    const s = (e = i.getAttribute) === null || e === void 0 ? void 0 : e.call(i, "class");
    return !s || s === "" ? !1 : s.split(" ").some(
      (r) => ".".concat(r) === t
    );
  }
  addStylesFromStyleDefinition() {
    const { styles: t, stylesSpecificity: e } = this.document;
    let i;
    for (const s in t)
      if (!s.startsWith("@") && this.matchesSelector(s)) {
        const r = t[s], o = e[s];
        if (r)
          for (const a in r) {
            let l = this.stylesSpecificity[a];
            typeof l > "u" && (l = "000"), o && o >= l && (i = r[a], i && (this.styles[a] = i), this.stylesSpecificity[a] = o);
          }
      }
  }
  removeStyles(t, e) {
    return e.reduce((s, r) => {
      const o = t.getStyle(r);
      if (!o.hasValue())
        return s;
      const a = o.getString();
      return o.setValue(""), [
        ...s,
        [
          r,
          a
        ]
      ];
    }, []);
  }
  restoreStyles(t, e) {
    e.forEach((i) => {
      let [s, r] = i;
      t.getStyle(s, !0).setValue(r);
    });
  }
  isFirstChild() {
    var t;
    return ((t = this.parent) === null || t === void 0 ? void 0 : t.children.indexOf(this)) === 0;
  }
  constructor(t, e, i = !1) {
    if (this.document = t, this.node = e, this.captureTextNodes = i, this.type = "", this.attributes = {}, this.styles = {}, this.stylesSpecificity = {}, this.animationFrozen = !1, this.animationFrozenValue = "", this.parent = null, this.children = [], !e || e.nodeType !== 1)
      return;
    Array.from(e.attributes).forEach((o) => {
      const a = Mb(o.nodeName);
      this.attributes[a] = new Zt(t, a, o.value);
    }), this.addStylesFromStyleDefinition(), this.getAttribute("style").hasValue() && this.getAttribute("style").getString().split(";").map(
      (a) => a.trim()
    ).forEach((a) => {
      if (!a)
        return;
      const [l, c] = a.split(":").map(
        (h) => h.trim()
      );
      l && (this.styles[l] = new Zt(t, l, c));
    });
    const { definitions: s } = t, r = this.getAttribute("id");
    r.hasValue() && (s[r.getString()] || (s[r.getString()] = this)), Array.from(e.childNodes).forEach((o) => {
      if (o.nodeType === 1)
        this.addChild(o);
      else if (i && (o.nodeType === 3 || o.nodeType === 4)) {
        const a = t.createTextNode(o);
        a.getText().length > 0 && this.addChild(a);
      }
    });
  }
}
Me.ignoreChildTypes = [
  "title"
];
class jb extends Me {
  constructor(t, e, i) {
    super(t, e, i);
  }
}
function Hb(n) {
  const t = n.trim();
  return /^('|")/.test(t) ? t : '"'.concat(t, '"');
}
function Ub(n) {
  return typeof process > "u" ? n : n.trim().split(",").map(Hb).join(",");
}
function Qb(n) {
  if (!n)
    return "";
  const t = n.trim().toLowerCase();
  switch (t) {
    case "normal":
    case "italic":
    case "oblique":
    case "inherit":
    case "initial":
    case "unset":
      return t;
    default:
      return /^oblique\s+(-|)\d+deg$/.test(t) ? t : "";
  }
}
function qb(n) {
  if (!n)
    return "";
  const t = n.trim().toLowerCase();
  switch (t) {
    case "normal":
    case "bold":
    case "lighter":
    case "bolder":
    case "inherit":
    case "initial":
    case "unset":
      return t;
    default:
      return /^[\d.]+$/.test(t) ? t : "";
  }
}
class Li {
  static parse() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", e = arguments.length > 1 ? arguments[1] : void 0, i = "", s = "", r = "", o = "", a = "";
    const l = io(t).trim().split(" "), c = {
      fontSize: !1,
      fontStyle: !1,
      fontWeight: !1,
      fontVariant: !1
    };
    return l.forEach((h) => {
      switch (!0) {
        case (!c.fontStyle && Li.styles.includes(h)):
          h !== "inherit" && (i = h), c.fontStyle = !0;
          break;
        case (!c.fontVariant && Li.variants.includes(h)):
          h !== "inherit" && (s = h), c.fontStyle = !0, c.fontVariant = !0;
          break;
        case (!c.fontWeight && Li.weights.includes(h)):
          h !== "inherit" && (r = h), c.fontStyle = !0, c.fontVariant = !0, c.fontWeight = !0;
          break;
        case !c.fontSize:
          h !== "inherit" && (o = h.split("/")[0] || ""), c.fontStyle = !0, c.fontVariant = !0, c.fontWeight = !0, c.fontSize = !0;
          break;
        default:
          h !== "inherit" && (a += h);
      }
    }), new Li(i, s, r, o, a, e);
  }
  toString() {
    return [
      Qb(this.fontStyle),
      this.fontVariant,
      qb(this.fontWeight),
      this.fontSize,
      // Wrap fontFamily only on nodejs and only for canvas.ctx
      Ub(this.fontFamily)
    ].join(" ").trim();
  }
  constructor(t, e, i, s, r, o) {
    const a = o ? typeof o == "string" ? Li.parse(o) : o : {};
    this.fontFamily = r || a.fontFamily, this.fontSize = s || a.fontSize, this.fontStyle = t || a.fontStyle, this.fontWeight = i || a.fontWeight, this.fontVariant = e || a.fontVariant;
  }
}
Li.styles = "normal|italic|oblique|inherit";
Li.variants = "normal|small-caps|inherit";
Li.weights = "normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit";
class Tn {
  get x() {
    return this.x1;
  }
  get y() {
    return this.y1;
  }
  get width() {
    return this.x2 - this.x1;
  }
  get height() {
    return this.y2 - this.y1;
  }
  addPoint(t, e) {
    typeof t < "u" && ((isNaN(this.x1) || isNaN(this.x2)) && (this.x1 = t, this.x2 = t), t < this.x1 && (this.x1 = t), t > this.x2 && (this.x2 = t)), typeof e < "u" && ((isNaN(this.y1) || isNaN(this.y2)) && (this.y1 = e, this.y2 = e), e < this.y1 && (this.y1 = e), e > this.y2 && (this.y2 = e));
  }
  addX(t) {
    this.addPoint(t, 0);
  }
  addY(t) {
    this.addPoint(0, t);
  }
  addBoundingBox(t) {
    if (!t)
      return;
    const { x1: e, y1: i, x2: s, y2: r } = t;
    this.addPoint(e, i), this.addPoint(s, r);
  }
  sumCubic(t, e, i, s, r) {
    return Math.pow(1 - t, 3) * e + 3 * Math.pow(1 - t, 2) * t * i + 3 * (1 - t) * Math.pow(t, 2) * s + Math.pow(t, 3) * r;
  }
  bezierCurveAdd(t, e, i, s, r) {
    const o = 6 * e - 12 * i + 6 * s, a = -3 * e + 9 * i - 9 * s + 3 * r, l = 3 * i - 3 * e;
    if (a === 0) {
      if (o === 0)
        return;
      const p = -l / o;
      0 < p && p < 1 && (t ? this.addX(this.sumCubic(p, e, i, s, r)) : this.addY(this.sumCubic(p, e, i, s, r)));
      return;
    }
    const c = Math.pow(o, 2) - 4 * l * a;
    if (c < 0)
      return;
    const h = (-o + Math.sqrt(c)) / (2 * a);
    0 < h && h < 1 && (t ? this.addX(this.sumCubic(h, e, i, s, r)) : this.addY(this.sumCubic(h, e, i, s, r)));
    const u = (-o - Math.sqrt(c)) / (2 * a);
    0 < u && u < 1 && (t ? this.addX(this.sumCubic(u, e, i, s, r)) : this.addY(this.sumCubic(u, e, i, s, r)));
  }
  // from http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
  addBezierCurve(t, e, i, s, r, o, a, l) {
    this.addPoint(t, e), this.addPoint(a, l), this.bezierCurveAdd(!0, t, i, r, a), this.bezierCurveAdd(!1, e, s, o, l);
  }
  addQuadraticCurve(t, e, i, s, r, o) {
    const a = t + 0.6666666666666666 * (i - t), l = e + 2 / 3 * (s - e), c = a + 1 / 3 * (r - t), h = l + 1 / 3 * (o - e);
    this.addBezierCurve(t, e, a, c, l, h, r, o);
  }
  isPointInBox(t, e) {
    const { x1: i, y1: s, x2: r, y2: o } = this;
    return i <= t && t <= r && s <= e && e <= o;
  }
  constructor(t = Number.NaN, e = Number.NaN, i = Number.NaN, s = Number.NaN) {
    this.x1 = t, this.y1 = e, this.x2 = i, this.y2 = s, this.addPoint(t, e), this.addPoint(i, s);
  }
}
class Ir extends Me {
  calculateOpacity() {
    let t = 1, e = this;
    for (; e; ) {
      const i = e.getStyle("opacity", !1, !0);
      i.hasValue(!0) && (t *= i.getNumber()), e = e.parent;
    }
    return t;
  }
  setContext(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    if (!e) {
      const i = this.getStyle("fill"), s = this.getStyle("fill-opacity"), r = this.getStyle("stroke"), o = this.getStyle("stroke-opacity");
      if (i.isUrlDefinition()) {
        const m = i.getFillStyleDefinition(this, s);
        m && (t.fillStyle = m);
      } else if (i.hasValue()) {
        i.getString() === "currentColor" && i.setValue(this.getStyle("color").getColor());
        const m = i.getColor();
        m !== "inherit" && (t.fillStyle = m === "none" ? "rgba(0,0,0,0)" : m);
      }
      if (s.hasValue()) {
        const m = new Zt(this.document, "fill", t.fillStyle).addOpacity(s).getColor();
        t.fillStyle = m;
      }
      if (r.isUrlDefinition()) {
        const m = r.getFillStyleDefinition(this, o);
        m && (t.strokeStyle = m);
      } else if (r.hasValue()) {
        r.getString() === "currentColor" && r.setValue(this.getStyle("color").getColor());
        const m = r.getString();
        m !== "inherit" && (t.strokeStyle = m === "none" ? "rgba(0,0,0,0)" : m);
      }
      if (o.hasValue()) {
        const m = new Zt(this.document, "stroke", t.strokeStyle).addOpacity(o).getString();
        t.strokeStyle = m;
      }
      const a = this.getStyle("stroke-width");
      if (a.hasValue()) {
        const m = a.getPixels();
        t.lineWidth = m || Fr;
      }
      const l = this.getStyle("stroke-linecap"), c = this.getStyle("stroke-linejoin"), h = this.getStyle("stroke-miterlimit"), u = this.getStyle("stroke-dasharray"), p = this.getStyle("stroke-dashoffset");
      if (l.hasValue() && (t.lineCap = l.getString()), c.hasValue() && (t.lineJoin = c.getString()), h.hasValue() && (t.miterLimit = h.getNumber()), u.hasValue() && u.getString() !== "none") {
        const m = an(u.getString());
        typeof t.setLineDash < "u" ? t.setLineDash(m) : typeof t.webkitLineDash < "u" ? t.webkitLineDash = m : typeof t.mozDash < "u" && !(m.length === 1 && m[0] === 0) && (t.mozDash = m);
        const g = p.getPixels();
        typeof t.lineDashOffset < "u" ? t.lineDashOffset = g : typeof t.webkitLineDashOffset < "u" ? t.webkitLineDashOffset = g : typeof t.mozDashOffset < "u" && (t.mozDashOffset = g);
      }
    }
    if (this.modifiedEmSizeStack = !1, typeof t.font < "u") {
      const i = this.getStyle("font"), s = this.getStyle("font-style"), r = this.getStyle("font-variant"), o = this.getStyle("font-weight"), a = this.getStyle("font-size"), l = this.getStyle("font-family"), c = new Li(s.getString(), r.getString(), o.getString(), a.hasValue() ? "".concat(a.getPixels(!0), "px") : "", l.getString(), Li.parse(i.getString(), t.font));
      s.setValue(c.fontStyle), r.setValue(c.fontVariant), o.setValue(c.fontWeight), a.setValue(c.fontSize), l.setValue(c.fontFamily), t.font = c.toString(), a.isPixels() && (this.document.emSize = a.getPixels(), this.modifiedEmSizeStack = !0);
    }
    e || (this.applyEffects(t), t.globalAlpha = this.calculateOpacity());
  }
  clearContext(t) {
    super.clearContext(t), this.modifiedEmSizeStack && this.document.popEmSize();
  }
  constructor(...t) {
    super(...t), this.modifiedEmSizeStack = !1;
  }
}
class Ks extends Ir {
  setContext(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    super.setContext(t, e);
    const i = this.getStyle("dominant-baseline").getTextBaseline() || this.getStyle("alignment-baseline").getTextBaseline();
    i && (t.textBaseline = i);
  }
  initializeCoordinates() {
    this.x = 0, this.y = 0, this.leafTexts = [], this.textChunkStart = 0, this.minX = Number.POSITIVE_INFINITY, this.maxX = Number.NEGATIVE_INFINITY;
  }
  getBoundingBox(t) {
    if (this.type !== "text")
      return this.getTElementBoundingBox(t);
    this.initializeCoordinates(), this.adjustChildCoordinatesRecursive(t);
    let e = null;
    return this.children.forEach((i, s) => {
      const r = this.getChildBoundingBox(t, this, this, s);
      e ? e.addBoundingBox(r) : e = r;
    }), e;
  }
  getFontSize() {
    const { document: t, parent: e } = this, i = Li.parse(t.ctx.font).fontSize;
    return e.getStyle("font-size").getNumber(i);
  }
  getTElementBoundingBox(t) {
    const e = this.getFontSize();
    return new Tn(this.x, this.y - e, this.x + this.measureText(t), this.y);
  }
  getGlyph(t, e, i) {
    const s = e[i];
    let r;
    if (t.isArabic) {
      var o;
      const a = e.length, l = e[i - 1], c = e[i + 1];
      let h = "isolated";
      (i === 0 || l === " ") && i < a - 1 && c !== " " && (h = "terminal"), i > 0 && l !== " " && i < a - 1 && c !== " " && (h = "medial"), i > 0 && l !== " " && (i === a - 1 || c === " ") && (h = "initial"), r = ((o = t.arabicGlyphs[s]) === null || o === void 0 ? void 0 : o[h]) || t.glyphs[s];
    } else
      r = t.glyphs[s];
    return r || (r = t.missingGlyph), r;
  }
  getText() {
    return "";
  }
  getTextFromNode(t) {
    const e = t || this.node, i = Array.from(e.parentNode.childNodes), s = i.indexOf(e), r = i.length - 1;
    let o = io(
      // textNode.value
      // || textNode.text
      e.textContent || ""
    );
    return s === 0 && (o = xb(o)), s === r && (o = Zb(o)), o;
  }
  renderChildren(t) {
    if (this.type !== "text") {
      this.renderTElementChildren(t);
      return;
    }
    this.initializeCoordinates(), this.adjustChildCoordinatesRecursive(t), this.children.forEach((i, s) => {
      this.renderChild(t, this, this, s);
    });
    const { mouse: e } = this.document.screen;
    e.isWorking() && e.checkBoundingBox(this, this.getBoundingBox(t));
  }
  renderTElementChildren(t) {
    const { document: e, parent: i } = this, s = this.getText(), r = i.getStyle("font-family").getDefinition();
    if (r) {
      const { unitsPerEm: l } = r.fontFace, c = Li.parse(e.ctx.font), h = i.getStyle("font-size").getNumber(c.fontSize), u = i.getStyle("font-style").getString(c.fontStyle), p = h / l, m = r.isRTL ? s.split("").reverse().join("") : s, g = an(i.getAttribute("dx").getString()), _ = m.length;
      for (let y = 0; y < _; y++) {
        const b = this.getGlyph(r, m, y);
        t.translate(this.x, this.y), t.scale(p, -p);
        const w = t.lineWidth;
        t.lineWidth = t.lineWidth * l / h, u === "italic" && t.transform(1, 0, 0.4, 1, 0, 0), b.render(t), u === "italic" && t.transform(1, 0, -0.4, 1, 0, 0), t.lineWidth = w, t.scale(1 / p, -1 / p), t.translate(-this.x, -this.y), this.x += h * (b.horizAdvX || r.horizAdvX) / l, typeof g[y] < "u" && !isNaN(g[y]) && (this.x += g[y]);
      }
      return;
    }
    const { x: o, y: a } = this;
    t.fillStyle && t.fillText(s, o, a), t.strokeStyle && t.strokeText(s, o, a);
  }
  applyAnchoring() {
    if (this.textChunkStart >= this.leafTexts.length)
      return;
    const t = this.leafTexts[this.textChunkStart], e = t.getStyle("text-anchor").getString("start"), i = !1;
    let s = 0;
    e === "start" && !i || e === "end" && i ? s = t.x - this.minX : e === "end" && !i || e === "start" && i ? s = t.x - this.maxX : s = t.x - (this.minX + this.maxX) / 2;
    for (let r = this.textChunkStart; r < this.leafTexts.length; r++)
      this.leafTexts[r].x += s;
    this.minX = Number.POSITIVE_INFINITY, this.maxX = Number.NEGATIVE_INFINITY, this.textChunkStart = this.leafTexts.length;
  }
  adjustChildCoordinatesRecursive(t) {
    this.children.forEach((e, i) => {
      this.adjustChildCoordinatesRecursiveCore(t, this, this, i);
    }), this.applyAnchoring();
  }
  adjustChildCoordinatesRecursiveCore(t, e, i, s) {
    const r = i.children[s];
    r.children.length > 0 ? r.children.forEach((o, a) => {
      e.adjustChildCoordinatesRecursiveCore(t, e, r, a);
    }) : this.adjustChildCoordinates(t, e, i, s);
  }
  adjustChildCoordinates(t, e, i, s) {
    const r = i.children[s];
    if (typeof r.measureText != "function")
      return r;
    t.save(), r.setContext(t, !0);
    const o = r.getAttribute("x"), a = r.getAttribute("y"), l = r.getAttribute("dx"), c = r.getAttribute("dy"), h = r.getStyle("font-family").getDefinition(), u = !!(h != null && h.isRTL);
    s === 0 && (o.hasValue() || o.setValue(r.getInheritedAttribute("x")), a.hasValue() || a.setValue(r.getInheritedAttribute("y")), l.hasValue() || l.setValue(r.getInheritedAttribute("dx")), c.hasValue() || c.setValue(r.getInheritedAttribute("dy")));
    const p = r.measureText(t);
    return u && (e.x -= p), o.hasValue() ? (e.applyAnchoring(), r.x = o.getPixels("x"), l.hasValue() && (r.x += l.getPixels("x"))) : (l.hasValue() && (e.x += l.getPixels("x")), r.x = e.x), e.x = r.x, u || (e.x += p), a.hasValue() ? (r.y = a.getPixels("y"), c.hasValue() && (r.y += c.getPixels("y"))) : (c.hasValue() && (e.y += c.getPixels("y")), r.y = e.y), e.y = r.y, e.leafTexts.push(r), e.minX = Math.min(e.minX, r.x, r.x + p), e.maxX = Math.max(e.maxX, r.x, r.x + p), r.clearContext(t), t.restore(), r;
  }
  getChildBoundingBox(t, e, i, s) {
    const r = i.children[s];
    if (typeof r.getBoundingBox != "function")
      return null;
    const o = r.getBoundingBox(t);
    return o && r.children.forEach((a, l) => {
      const c = e.getChildBoundingBox(t, e, r, l);
      o.addBoundingBox(c);
    }), o;
  }
  renderChild(t, e, i, s) {
    const r = i.children[s];
    r.render(t), r.children.forEach((o, a) => {
      e.renderChild(t, e, r, a);
    });
  }
  measureText(t) {
    const { measureCache: e } = this;
    if (~e)
      return e;
    const i = this.getText(), s = this.measureTargetText(t, i);
    return this.measureCache = s, s;
  }
  measureTargetText(t, e) {
    if (!e.length)
      return 0;
    const { parent: i } = this, s = i.getStyle("font-family").getDefinition();
    if (s) {
      const o = this.getFontSize(), a = s.isRTL ? e.split("").reverse().join("") : e, l = an(i.getAttribute("dx").getString()), c = a.length;
      let h = 0;
      for (let u = 0; u < c; u++) {
        const p = this.getGlyph(s, a, u);
        h += (p.horizAdvX || s.horizAdvX) * o / s.fontFace.unitsPerEm, typeof l[u] < "u" && !isNaN(l[u]) && (h += l[u]);
      }
      return h;
    }
    if (!t.measureText)
      return e.length * 10;
    t.save(), this.setContext(t, !0);
    const { width: r } = t.measureText(e);
    return this.clearContext(t), t.restore(), r;
  }
  /**
  * Inherits positional attributes from {@link TextElement} parent(s). Attributes
  * are only inherited from a parent to its first child.
  * @param name - The attribute name.
  * @returns The attribute value or null.
  */
  getInheritedAttribute(t) {
    let e = this;
    for (; e instanceof Ks && e.isFirstChild() && e.parent; ) {
      const i = e.parent.getAttribute(t);
      if (i.hasValue(!0))
        return i.getString("0");
      e = e.parent;
    }
    return null;
  }
  constructor(t, e, i) {
    super(t, e, new.target === Ks ? !0 : i), this.type = "text", this.x = 0, this.y = 0, this.leafTexts = [], this.textChunkStart = 0, this.minX = Number.POSITIVE_INFINITY, this.maxX = Number.NEGATIVE_INFINITY, this.measureCache = -1;
  }
}
class $l extends Ks {
  getText() {
    return this.text;
  }
  constructor(t, e, i) {
    super(t, e, new.target === $l ? !0 : i), this.type = "tspan", this.text = this.children.length > 0 ? "" : this.getTextFromNode();
  }
}
class $b extends $l {
  constructor(...t) {
    super(...t), this.type = "textNode";
  }
}
class Rt extends at {
  reset() {
    this.i = -1, this.command = null, this.previousCommand = null, this.start = new Pe(0, 0), this.control = new Pe(0, 0), this.current = new Pe(0, 0), this.points = [], this.angles = [];
  }
  isEnd() {
    const { i: t, commands: e } = this;
    return t >= e.length - 1;
  }
  next() {
    const t = this.commands[++this.i];
    return this.previousCommand = this.command, this.command = t, t;
  }
  getPoint() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "x", e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "y";
    const i = new Pe(this.command[t], this.command[e]);
    return this.makeAbsolute(i);
  }
  getAsControlPoint(t, e) {
    const i = this.getPoint(t, e);
    return this.control = i, i;
  }
  getAsCurrentPoint(t, e) {
    const i = this.getPoint(t, e);
    return this.current = i, i;
  }
  getReflectedControlPoint() {
    const t = this.previousCommand.type;
    if (t !== at.CURVE_TO && t !== at.SMOOTH_CURVE_TO && t !== at.QUAD_TO && t !== at.SMOOTH_QUAD_TO)
      return this.current;
    const { current: { x: e, y: i }, control: { x: s, y: r } } = this;
    return new Pe(2 * e - s, 2 * i - r);
  }
  makeAbsolute(t) {
    if (this.command.relative) {
      const { x: e, y: i } = this.current;
      t.x += e, t.y += i;
    }
    return t;
  }
  addMarker(t, e, i) {
    const { points: s, angles: r } = this;
    i && r.length > 0 && !r[r.length - 1] && (r[r.length - 1] = s[s.length - 1].angleTo(i)), this.addMarkerAngle(t, e ? e.angleTo(t) : null);
  }
  addMarkerAngle(t, e) {
    this.points.push(t), this.angles.push(e);
  }
  getMarkerPoints() {
    return this.points;
  }
  getMarkerAngles() {
    const { angles: t } = this, e = t.length;
    for (let i = 0; i < e; i++)
      if (!t[i]) {
        for (let s = i + 1; s < e; s++)
          if (t[s]) {
            t[i] = t[s];
            break;
          }
      }
    return t;
  }
  constructor(t) {
    super(t.replace(/([+\-.])\s+/gm, "$1").replace(/[^MmZzLlHhVvCcSsQqTtAae\d\s.,+-].*/g, "")), this.control = new Pe(0, 0), this.start = new Pe(0, 0), this.current = new Pe(0, 0), this.command = null, this.commands = this.commands, this.i = -1, this.previousCommand = null, this.points = [], this.angles = [];
  }
}
class me extends Ir {
  path(t) {
    const { pathParser: e } = this, i = new Tn();
    for (e.reset(), t && t.beginPath(); !e.isEnd(); )
      switch (e.next().type) {
        case Rt.MOVE_TO:
          this.pathM(t, i);
          break;
        case Rt.LINE_TO:
          this.pathL(t, i);
          break;
        case Rt.HORIZ_LINE_TO:
          this.pathH(t, i);
          break;
        case Rt.VERT_LINE_TO:
          this.pathV(t, i);
          break;
        case Rt.CURVE_TO:
          this.pathC(t, i);
          break;
        case Rt.SMOOTH_CURVE_TO:
          this.pathS(t, i);
          break;
        case Rt.QUAD_TO:
          this.pathQ(t, i);
          break;
        case Rt.SMOOTH_QUAD_TO:
          this.pathT(t, i);
          break;
        case Rt.ARC:
          this.pathA(t, i);
          break;
        case Rt.CLOSE_PATH:
          this.pathZ(t, i);
          break;
      }
    return i;
  }
  getBoundingBox(t) {
    return this.path();
  }
  getMarkers() {
    const { pathParser: t } = this, e = t.getMarkerPoints(), i = t.getMarkerAngles();
    return e.map(
      (r, o) => [
        r,
        i[o]
      ]
    );
  }
  renderChildren(t) {
    this.path(t), this.document.screen.mouse.checkPath(this, t);
    const e = this.getStyle("fill-rule");
    t.fillStyle !== "" && (e.getString("inherit") !== "inherit" ? t.fill(e.getString()) : t.fill()), t.strokeStyle !== "" && (this.getAttribute("vector-effect").getString() === "non-scaling-stroke" ? (t.save(), t.setTransform(1, 0, 0, 1, 0, 0), t.stroke(), t.restore()) : t.stroke());
    const i = this.getMarkers();
    if (i) {
      const s = i.length - 1, r = this.getStyle("marker-start"), o = this.getStyle("marker-mid"), a = this.getStyle("marker-end");
      if (r.isUrlDefinition()) {
        const l = r.getDefinition(), [c, h] = i[0];
        l.render(t, c, h);
      }
      if (o.isUrlDefinition()) {
        const l = o.getDefinition();
        for (let c = 1; c < s; c++) {
          const [h, u] = i[c];
          l.render(t, h, u);
        }
      }
      if (a.isUrlDefinition()) {
        const l = a.getDefinition(), [c, h] = i[s];
        l.render(t, c, h);
      }
    }
  }
  static pathM(t) {
    const e = t.getAsCurrentPoint();
    return t.start = t.current, {
      point: e
    };
  }
  pathM(t, e) {
    const { pathParser: i } = this, { point: s } = me.pathM(i), { x: r, y: o } = s;
    i.addMarker(s), e.addPoint(r, o), t && t.moveTo(r, o);
  }
  static pathL(t) {
    const { current: e } = t, i = t.getAsCurrentPoint();
    return {
      current: e,
      point: i
    };
  }
  pathL(t, e) {
    const { pathParser: i } = this, { current: s, point: r } = me.pathL(i), { x: o, y: a } = r;
    i.addMarker(r, s), e.addPoint(o, a), t && t.lineTo(o, a);
  }
  static pathH(t) {
    const { current: e, command: i } = t, s = new Pe((i.relative ? e.x : 0) + i.x, e.y);
    return t.current = s, {
      current: e,
      point: s
    };
  }
  pathH(t, e) {
    const { pathParser: i } = this, { current: s, point: r } = me.pathH(i), { x: o, y: a } = r;
    i.addMarker(r, s), e.addPoint(o, a), t && t.lineTo(o, a);
  }
  static pathV(t) {
    const { current: e, command: i } = t, s = new Pe(e.x, (i.relative ? e.y : 0) + i.y);
    return t.current = s, {
      current: e,
      point: s
    };
  }
  pathV(t, e) {
    const { pathParser: i } = this, { current: s, point: r } = me.pathV(i), { x: o, y: a } = r;
    i.addMarker(r, s), e.addPoint(o, a), t && t.lineTo(o, a);
  }
  static pathC(t) {
    const { current: e } = t, i = t.getPoint("x1", "y1"), s = t.getAsControlPoint("x2", "y2"), r = t.getAsCurrentPoint();
    return {
      current: e,
      point: i,
      controlPoint: s,
      currentPoint: r
    };
  }
  pathC(t, e) {
    const { pathParser: i } = this, { current: s, point: r, controlPoint: o, currentPoint: a } = me.pathC(i);
    i.addMarker(a, o, r), e.addBezierCurve(s.x, s.y, r.x, r.y, o.x, o.y, a.x, a.y), t && t.bezierCurveTo(r.x, r.y, o.x, o.y, a.x, a.y);
  }
  static pathS(t) {
    const { current: e } = t, i = t.getReflectedControlPoint(), s = t.getAsControlPoint("x2", "y2"), r = t.getAsCurrentPoint();
    return {
      current: e,
      point: i,
      controlPoint: s,
      currentPoint: r
    };
  }
  pathS(t, e) {
    const { pathParser: i } = this, { current: s, point: r, controlPoint: o, currentPoint: a } = me.pathS(i);
    i.addMarker(a, o, r), e.addBezierCurve(s.x, s.y, r.x, r.y, o.x, o.y, a.x, a.y), t && t.bezierCurveTo(r.x, r.y, o.x, o.y, a.x, a.y);
  }
  static pathQ(t) {
    const { current: e } = t, i = t.getAsControlPoint("x1", "y1"), s = t.getAsCurrentPoint();
    return {
      current: e,
      controlPoint: i,
      currentPoint: s
    };
  }
  pathQ(t, e) {
    const { pathParser: i } = this, { current: s, controlPoint: r, currentPoint: o } = me.pathQ(i);
    i.addMarker(o, r, r), e.addQuadraticCurve(s.x, s.y, r.x, r.y, o.x, o.y), t && t.quadraticCurveTo(r.x, r.y, o.x, o.y);
  }
  static pathT(t) {
    const { current: e } = t, i = t.getReflectedControlPoint();
    t.control = i;
    const s = t.getAsCurrentPoint();
    return {
      current: e,
      controlPoint: i,
      currentPoint: s
    };
  }
  pathT(t, e) {
    const { pathParser: i } = this, { current: s, controlPoint: r, currentPoint: o } = me.pathT(i);
    i.addMarker(o, r, r), e.addQuadraticCurve(s.x, s.y, r.x, r.y, o.x, o.y), t && t.quadraticCurveTo(r.x, r.y, o.x, o.y);
  }
  static pathA(t) {
    const { current: e, command: i } = t;
    let { rX: s, rY: r, xRot: o, lArcFlag: a, sweepFlag: l } = i;
    const c = o * (Math.PI / 180), h = t.getAsCurrentPoint(), u = new Pe(Math.cos(c) * (e.x - h.x) / 2 + Math.sin(c) * (e.y - h.y) / 2, -Math.sin(c) * (e.x - h.x) / 2 + Math.cos(c) * (e.y - h.y) / 2), p = Math.pow(u.x, 2) / Math.pow(s, 2) + Math.pow(u.y, 2) / Math.pow(r, 2);
    p > 1 && (s *= Math.sqrt(p), r *= Math.sqrt(p));
    let m = (a === l ? -1 : 1) * Math.sqrt((Math.pow(s, 2) * Math.pow(r, 2) - Math.pow(s, 2) * Math.pow(u.y, 2) - Math.pow(r, 2) * Math.pow(u.x, 2)) / (Math.pow(s, 2) * Math.pow(u.y, 2) + Math.pow(r, 2) * Math.pow(u.x, 2)));
    isNaN(m) && (m = 0);
    const g = new Pe(m * s * u.y / r, m * -r * u.x / s), _ = new Pe((e.x + h.x) / 2 + Math.cos(c) * g.x - Math.sin(c) * g.y, (e.y + h.y) / 2 + Math.sin(c) * g.x + Math.cos(c) * g.y), y = Tu([
      1,
      0
    ], [
      (u.x - g.x) / s,
      (u.y - g.y) / r
    ]), b = [
      (u.x - g.x) / s,
      (u.y - g.y) / r
    ], w = [
      (-u.x - g.x) / s,
      (-u.y - g.y) / r
    ];
    let v = Tu(b, w);
    return oh(b, w) <= -1 && (v = Math.PI), oh(b, w) >= 1 && (v = 0), {
      currentPoint: h,
      rX: s,
      rY: r,
      sweepFlag: l,
      xAxisRotation: c,
      centp: _,
      a1: y,
      ad: v
    };
  }
  pathA(t, e) {
    const { pathParser: i } = this, { currentPoint: s, rX: r, rY: o, sweepFlag: a, xAxisRotation: l, centp: c, a1: h, ad: u } = me.pathA(i), p = 1 - a ? 1 : -1, m = h + p * (u / 2), g = new Pe(c.x + r * Math.cos(m), c.y + o * Math.sin(m));
    if (i.addMarkerAngle(g, m - p * Math.PI / 2), i.addMarkerAngle(s, m - p * Math.PI), e.addPoint(s.x, s.y), t && !isNaN(h) && !isNaN(u)) {
      const _ = r > o ? r : o, y = r > o ? 1 : r / o, b = r > o ? o / r : 1;
      t.translate(c.x, c.y), t.rotate(l), t.scale(y, b), t.arc(0, 0, _, h, h + u, !!(1 - a)), t.scale(1 / y, 1 / b), t.rotate(-l), t.translate(-c.x, -c.y);
    }
  }
  static pathZ(t) {
    t.current = t.start;
  }
  pathZ(t, e) {
    me.pathZ(this.pathParser), t && e.x1 !== e.x2 && e.y1 !== e.y2 && t.closePath();
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "path", this.pathParser = new Rt(this.getAttribute("d").getString());
  }
}
class Ra extends Ir {
  setContext(t) {
    var e;
    const { document: i } = this, { screen: s, window: r } = i, o = t.canvas;
    if (s.setDefaults(t), "style" in o && typeof t.font < "u" && r && typeof r.getComputedStyle < "u") {
      t.font = r.getComputedStyle(o).getPropertyValue("font");
      const w = new Zt(i, "fontSize", Li.parse(t.font).fontSize);
      w.hasValue() && (i.rootEmSize = w.getPixels("y"), i.emSize = i.rootEmSize);
    }
    this.getAttribute("x").hasValue() || this.getAttribute("x", !0).setValue(0), this.getAttribute("y").hasValue() || this.getAttribute("y", !0).setValue(0);
    let { width: a, height: l } = s.viewPort;
    this.getStyle("width").hasValue() || this.getStyle("width", !0).setValue("100%"), this.getStyle("height").hasValue() || this.getStyle("height", !0).setValue("100%"), this.getStyle("color").hasValue() || this.getStyle("color", !0).setValue("black");
    const c = this.getAttribute("refX"), h = this.getAttribute("refY"), u = this.getAttribute("viewBox"), p = u.hasValue() ? an(u.getString()) : null, m = !this.root && this.getStyle("overflow").getValue("hidden") !== "visible";
    let g = 0, _ = 0, y = 0, b = 0;
    p && (g = p[0], _ = p[1]), this.root || (a = this.getStyle("width").getPixels("x"), l = this.getStyle("height").getPixels("y"), this.type === "marker" && (y = g, b = _, g = 0, _ = 0)), s.viewPort.setCurrent(a, l), this.node && (!this.parent || ((e = this.node.parentNode) === null || e === void 0 ? void 0 : e.nodeName) === "foreignObject") && this.getStyle("transform", !1, !0).hasValue() && !this.getStyle("transform-origin", !1, !0).hasValue() && this.getStyle("transform-origin", !0, !0).setValue("50% 50%"), super.setContext(t), t.translate(this.getAttribute("x").getPixels("x"), this.getAttribute("y").getPixels("y")), p && (a = p[2], l = p[3]), i.setViewBox({
      ctx: t,
      aspectRatio: this.getAttribute("preserveAspectRatio").getString(),
      width: s.viewPort.width,
      desiredWidth: a,
      height: s.viewPort.height,
      desiredHeight: l,
      minX: g,
      minY: _,
      refX: c.getValue(),
      refY: h.getValue(),
      clip: m,
      clipX: y,
      clipY: b
    }), p && (s.viewPort.removeCurrent(), s.viewPort.setCurrent(a, l));
  }
  clearContext(t) {
    super.clearContext(t), this.document.screen.viewPort.removeCurrent();
  }
  /**
  * Resize SVG to fit in given size.
  * @param width
  * @param height
  * @param preserveAspectRatio
  */
  resize(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : t, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
    const s = this.getAttribute("width", !0), r = this.getAttribute("height", !0), o = this.getAttribute("viewBox"), a = this.getAttribute("style"), l = s.getNumber(0), c = r.getNumber(0);
    if (i)
      if (typeof i == "string")
        this.getAttribute("preserveAspectRatio", !0).setValue(i);
      else {
        const h = this.getAttribute("preserveAspectRatio");
        h.hasValue() && h.setValue(h.getString().replace(/^\s*(\S.*\S)\s*$/, "$1"));
      }
    if (s.setValue(t), r.setValue(e), o.hasValue() || o.setValue("0 0 ".concat(l || t, " ").concat(c || e)), a.hasValue()) {
      const h = this.getStyle("width"), u = this.getStyle("height");
      h.hasValue() && h.setValue("".concat(t, "px")), u.hasValue() && u.setValue("".concat(e, "px"));
    }
  }
  constructor(...t) {
    super(...t), this.type = "svg", this.root = !1;
  }
}
class Pp extends me {
  path(t) {
    const e = this.getAttribute("x").getPixels("x"), i = this.getAttribute("y").getPixels("y"), s = this.getStyle("width", !1, !0).getPixels("x"), r = this.getStyle("height", !1, !0).getPixels("y"), o = this.getAttribute("rx"), a = this.getAttribute("ry");
    let l = o.getPixels("x"), c = a.getPixels("y");
    if (o.hasValue() && !a.hasValue() && (c = l), a.hasValue() && !o.hasValue() && (l = c), l = Math.min(l, s / 2), c = Math.min(c, r / 2), t) {
      const h = 4 * ((Math.sqrt(2) - 1) / 3);
      t.beginPath(), r > 0 && s > 0 && (t.moveTo(e + l, i), t.lineTo(e + s - l, i), t.bezierCurveTo(e + s - l + h * l, i, e + s, i + c - h * c, e + s, i + c), t.lineTo(e + s, i + r - c), t.bezierCurveTo(e + s, i + r - c + h * c, e + s - l + h * l, i + r, e + s - l, i + r), t.lineTo(e + l, i + r), t.bezierCurveTo(e + l - h * l, i + r, e, i + r - c + h * c, e, i + r - c), t.lineTo(e, i + c), t.bezierCurveTo(e, i + c - h * c, e + l - h * l, i, e + l, i), t.closePath());
    }
    return new Tn(e, i, e + s, i + r);
  }
  getMarkers() {
    return null;
  }
  constructor(...t) {
    super(...t), this.type = "rect";
  }
}
class t0 extends me {
  path(t) {
    const e = this.getAttribute("cx").getPixels("x"), i = this.getAttribute("cy").getPixels("y"), s = this.getAttribute("r").getPixels();
    return t && s > 0 && (t.beginPath(), t.arc(e, i, s, 0, Math.PI * 2, !1), t.closePath()), new Tn(e - s, i - s, e + s, i + s);
  }
  getMarkers() {
    return null;
  }
  constructor(...t) {
    super(...t), this.type = "circle";
  }
}
class e0 extends me {
  path(t) {
    const e = 4 * ((Math.sqrt(2) - 1) / 3), i = this.getAttribute("rx").getPixels("x"), s = this.getAttribute("ry").getPixels("y"), r = this.getAttribute("cx").getPixels("x"), o = this.getAttribute("cy").getPixels("y");
    return t && i > 0 && s > 0 && (t.beginPath(), t.moveTo(r + i, o), t.bezierCurveTo(r + i, o + e * s, r + e * i, o + s, r, o + s), t.bezierCurveTo(r - e * i, o + s, r - i, o + e * s, r - i, o), t.bezierCurveTo(r - i, o - e * s, r - e * i, o - s, r, o - s), t.bezierCurveTo(r + e * i, o - s, r + i, o - e * s, r + i, o), t.closePath()), new Tn(r - i, o - s, r + i, o + s);
  }
  getMarkers() {
    return null;
  }
  constructor(...t) {
    super(...t), this.type = "ellipse";
  }
}
class i0 extends me {
  getPoints() {
    return [
      new Pe(this.getAttribute("x1").getPixels("x"), this.getAttribute("y1").getPixels("y")),
      new Pe(this.getAttribute("x2").getPixels("x"), this.getAttribute("y2").getPixels("y"))
    ];
  }
  path(t) {
    const [{ x: e, y: i }, { x: s, y: r }] = this.getPoints();
    return t && (t.beginPath(), t.moveTo(e, i), t.lineTo(s, r)), new Tn(e, i, s, r);
  }
  getMarkers() {
    const [t, e] = this.getPoints(), i = t.angleTo(e);
    return [
      [
        t,
        i
      ],
      [
        e,
        i
      ]
    ];
  }
  constructor(...t) {
    super(...t), this.type = "line";
  }
}
class Gp extends me {
  path(t) {
    const { points: e } = this, [{ x: i, y: s }] = e, r = new Tn(i, s);
    return t && (t.beginPath(), t.moveTo(i, s)), e.forEach((o) => {
      let { x: a, y: l } = o;
      r.addPoint(a, l), t && t.lineTo(a, l);
    }), r;
  }
  getMarkers() {
    const { points: t } = this, e = t.length - 1, i = [];
    return t.forEach((s, r) => {
      r !== e && i.push([
        s,
        s.angleTo(t[r + 1])
      ]);
    }), i.length > 0 && i.push([
      t[t.length - 1],
      i[i.length - 1][1]
    ]), i;
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "polyline", this.points = [], this.points = Pe.parsePath(this.getAttribute("points").getString());
  }
}
class n0 extends Gp {
  path(t) {
    const e = super.path(t), [{ x: i, y: s }] = this.points;
    return t && (t.lineTo(i, s), t.closePath()), e;
  }
  constructor(...t) {
    super(...t), this.type = "polygon";
  }
}
class s0 extends Me {
  createPattern(t, e, i) {
    const s = this.getStyle("width").getPixels("x", !0), r = this.getStyle("height").getPixels("y", !0), o = new Ra(this.document, null);
    o.attributes.viewBox = new Zt(this.document, "viewBox", this.getAttribute("viewBox").getValue()), o.attributes.width = new Zt(this.document, "width", "".concat(s, "px")), o.attributes.height = new Zt(this.document, "height", "".concat(r, "px")), o.attributes.transform = new Zt(this.document, "transform", this.getAttribute("patternTransform").getValue()), o.children = this.children;
    const a = this.document.createCanvas(s, r), l = a.getContext("2d"), c = this.getAttribute("x"), h = this.getAttribute("y");
    c.hasValue() && h.hasValue() && l.translate(c.getPixels("x", !0), h.getPixels("y", !0)), i.hasValue() ? this.styles["fill-opacity"] = i : Reflect.deleteProperty(this.styles, "fill-opacity");
    for (let p = -1; p <= 1; p++)
      for (let m = -1; m <= 1; m++)
        l.save(), o.attributes.x = new Zt(this.document, "x", p * a.width), o.attributes.y = new Zt(this.document, "y", m * a.height), o.render(l), l.restore();
    return t.createPattern(a, "repeat");
  }
  constructor(...t) {
    super(...t), this.type = "pattern";
  }
}
class r0 extends Me {
  render(t, e, i) {
    if (!e)
      return;
    const { x: s, y: r } = e, o = this.getAttribute("orient").getString("auto"), a = this.getAttribute("markerUnits").getString("strokeWidth");
    t.translate(s, r), o === "auto" && t.rotate(i), a === "strokeWidth" && t.scale(t.lineWidth, t.lineWidth), t.save();
    const l = new Ra(this.document);
    l.type = this.type, l.attributes.viewBox = new Zt(this.document, "viewBox", this.getAttribute("viewBox").getValue()), l.attributes.refX = new Zt(this.document, "refX", this.getAttribute("refX").getValue()), l.attributes.refY = new Zt(this.document, "refY", this.getAttribute("refY").getValue()), l.attributes.width = new Zt(this.document, "width", this.getAttribute("markerWidth").getValue()), l.attributes.height = new Zt(this.document, "height", this.getAttribute("markerHeight").getValue()), l.attributes.overflow = new Zt(this.document, "overflow", this.getAttribute("overflow").getValue()), l.attributes.fill = new Zt(this.document, "fill", this.getAttribute("fill").getColor("black")), l.attributes.stroke = new Zt(this.document, "stroke", this.getAttribute("stroke").getValue("none")), l.children = this.children, l.render(t), t.restore(), a === "strokeWidth" && t.scale(1 / t.lineWidth, 1 / t.lineWidth), o === "auto" && t.rotate(-i), t.translate(-s, -r);
  }
  constructor(...t) {
    super(...t), this.type = "marker";
  }
}
class o0 extends Me {
  render() {
  }
  constructor(...t) {
    super(...t), this.type = "defs";
  }
}
class Dh extends Ir {
  getBoundingBox(t) {
    const e = new Tn();
    return this.children.forEach((i) => {
      e.addBoundingBox(i.getBoundingBox(t));
    }), e;
  }
  constructor(...t) {
    super(...t), this.type = "g";
  }
}
class Yp extends Me {
  getGradientUnits() {
    return this.getAttribute("gradientUnits").getString("objectBoundingBox");
  }
  createGradient(t, e, i) {
    let s = this;
    this.getHrefAttribute().hasValue() && (s = this.getHrefAttribute().getDefinition(), this.inheritStopContainer(s));
    const { stops: r } = s, o = this.getGradient(t, e);
    if (!o)
      return this.addParentOpacity(i, r[r.length - 1].color);
    if (r.forEach((a) => {
      o.addColorStop(a.offset, this.addParentOpacity(i, a.color));
    }), this.getAttribute("gradientTransform").hasValue()) {
      const { document: a } = this, { MAX_VIRTUAL_PIXELS: l } = bs, { viewPort: c } = a.screen, h = c.getRoot(), u = new Pp(a);
      u.attributes.x = new Zt(a, "x", -l / 3), u.attributes.y = new Zt(a, "y", -l / 3), u.attributes.width = new Zt(a, "width", l), u.attributes.height = new Zt(a, "height", l);
      const p = new Dh(a);
      p.attributes.transform = new Zt(a, "transform", this.getAttribute("gradientTransform").getValue()), p.children = [
        u
      ];
      const m = new Ra(a);
      m.attributes.x = new Zt(a, "x", 0), m.attributes.y = new Zt(a, "y", 0), m.attributes.width = new Zt(a, "width", h.width), m.attributes.height = new Zt(a, "height", h.height), m.children = [
        p
      ];
      const g = a.createCanvas(h.width, h.height), _ = g.getContext("2d");
      return _.fillStyle = o, m.render(_), _.createPattern(g, "no-repeat");
    }
    return o;
  }
  inheritStopContainer(t) {
    this.attributesToInherit.forEach((e) => {
      !this.getAttribute(e).hasValue() && t.getAttribute(e).hasValue() && this.getAttribute(e, !0).setValue(t.getAttribute(e).getValue());
    });
  }
  addParentOpacity(t, e) {
    return t.hasValue() ? new Zt(this.document, "color", e).addOpacity(t).getColor() : e;
  }
  constructor(t, e, i) {
    super(t, e, i), this.attributesToInherit = [
      "gradientUnits"
    ], this.stops = [];
    const { stops: s, children: r } = this;
    r.forEach((o) => {
      o.type === "stop" && s.push(o);
    });
  }
}
class a0 extends Yp {
  getGradient(t, e) {
    const i = this.getGradientUnits() === "objectBoundingBox", s = i ? e.getBoundingBox(t) : null;
    if (i && !s)
      return null;
    !this.getAttribute("x1").hasValue() && !this.getAttribute("y1").hasValue() && !this.getAttribute("x2").hasValue() && !this.getAttribute("y2").hasValue() && (this.getAttribute("x1", !0).setValue(0), this.getAttribute("y1", !0).setValue(0), this.getAttribute("x2", !0).setValue(1), this.getAttribute("y2", !0).setValue(0));
    const r = i ? s.x + s.width * this.getAttribute("x1").getNumber() : this.getAttribute("x1").getPixels("x"), o = i ? s.y + s.height * this.getAttribute("y1").getNumber() : this.getAttribute("y1").getPixels("y"), a = i ? s.x + s.width * this.getAttribute("x2").getNumber() : this.getAttribute("x2").getPixels("x"), l = i ? s.y + s.height * this.getAttribute("y2").getNumber() : this.getAttribute("y2").getPixels("y");
    return r === a && o === l ? null : t.createLinearGradient(r, o, a, l);
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "linearGradient", this.attributesToInherit.push("x1", "y1", "x2", "y2");
  }
}
class l0 extends Yp {
  getGradient(t, e) {
    const i = this.getGradientUnits() === "objectBoundingBox", s = e.getBoundingBox(t);
    if (i && !s)
      return null;
    this.getAttribute("cx").hasValue() || this.getAttribute("cx", !0).setValue("50%"), this.getAttribute("cy").hasValue() || this.getAttribute("cy", !0).setValue("50%"), this.getAttribute("r").hasValue() || this.getAttribute("r", !0).setValue("50%");
    const r = i ? s.x + s.width * this.getAttribute("cx").getNumber() : this.getAttribute("cx").getPixels("x"), o = i ? s.y + s.height * this.getAttribute("cy").getNumber() : this.getAttribute("cy").getPixels("y");
    let a = r, l = o;
    this.getAttribute("fx").hasValue() && (a = i ? s.x + s.width * this.getAttribute("fx").getNumber() : this.getAttribute("fx").getPixels("x")), this.getAttribute("fy").hasValue() && (l = i ? s.y + s.height * this.getAttribute("fy").getNumber() : this.getAttribute("fy").getPixels("y"));
    const c = i ? (s.width + s.height) / 2 * this.getAttribute("r").getNumber() : this.getAttribute("r").getPixels(), h = this.getAttribute("fr").getPixels();
    return t.createRadialGradient(a, l, h, r, o, c);
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "radialGradient", this.attributesToInherit.push("cx", "cy", "r", "fx", "fy", "fr");
  }
}
class c0 extends Me {
  constructor(t, e, i) {
    super(t, e, i), this.type = "stop";
    const s = Math.max(0, Math.min(1, this.getAttribute("offset").getNumber())), r = this.getStyle("stop-opacity");
    let o = this.getStyle("stop-color", !0);
    o.getString() === "" && o.setValue("#000"), r.hasValue() && (o = o.addOpacity(r)), this.offset = s, this.color = o.getColor();
  }
}
class zh extends Me {
  getProperty() {
    const t = this.getAttribute("attributeType").getString(), e = this.getAttribute("attributeName").getString();
    return t === "CSS" ? this.parent.getStyle(e, !0) : this.parent.getAttribute(e, !0);
  }
  calcValue() {
    const { initialUnits: t } = this, { progress: e, from: i, to: s } = this.getProgress();
    let r = i.getNumber() + (s.getNumber() - i.getNumber()) * e;
    return t === "%" && (r *= 100), "".concat(r).concat(t);
  }
  update(t) {
    const { parent: e } = this, i = this.getProperty();
    if (this.initialValue || (this.initialValue = i.getString(), this.initialUnits = i.getUnits()), this.duration > this.maxDuration) {
      const r = this.getAttribute("fill").getString("remove");
      if (this.getAttribute("repeatCount").getString() === "indefinite" || this.getAttribute("repeatDur").getString() === "indefinite")
        this.duration = 0;
      else if (r === "freeze" && !this.frozen)
        this.frozen = !0, e && i && (e.animationFrozen = !0, e.animationFrozenValue = i.getString());
      else if (r === "remove" && !this.removed)
        return this.removed = !0, e && i && i.setValue(e.animationFrozen ? e.animationFrozenValue : this.initialValue), !0;
      return !1;
    }
    this.duration += t;
    let s = !1;
    if (this.begin < this.duration) {
      let r = this.calcValue();
      const o = this.getAttribute("type");
      if (o.hasValue()) {
        const a = o.getString();
        r = "".concat(a, "(").concat(r, ")");
      }
      i.setValue(r), s = !0;
    }
    return s;
  }
  getProgress() {
    const { document: t, values: e } = this;
    let i = (this.duration - this.begin) / (this.maxDuration - this.begin), s, r;
    if (e.hasValue()) {
      const o = i * (e.getValue().length - 1), a = Math.floor(o), l = Math.ceil(o);
      let c;
      c = e.getValue()[a], s = new Zt(t, "from", c ? parseFloat(c) : 0), c = e.getValue()[l], r = new Zt(t, "to", c ? parseFloat(c) : 0), i = (o - a) / (l - a);
    } else
      s = this.from, r = this.to;
    return {
      progress: i,
      from: s,
      to: r
    };
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "animate", this.duration = 0, this.initialUnits = "", this.removed = !1, this.frozen = !1, t.screen.animations.push(this), this.begin = this.getAttribute("begin").getMilliseconds(), this.maxDuration = this.begin + this.getAttribute("dur").getMilliseconds(), this.from = this.getAttribute("from"), this.to = this.getAttribute("to"), this.values = new Zt(t, "values", null);
    const s = this.getAttribute("values");
    s.hasValue() && this.values.setValue(s.getString().split(";"));
  }
}
class h0 extends zh {
  calcValue() {
    const { progress: t, from: e, to: i } = this.getProgress(), s = new sh(e.getColor()), r = new sh(i.getColor());
    if (s.ok && r.ok) {
      const o = s.r + (r.r - s.r) * t, a = s.g + (r.g - s.g) * t, l = s.b + (r.b - s.b) * t;
      return "rgb(".concat(Math.floor(o), ", ").concat(Math.floor(a), ", ").concat(Math.floor(l), ")");
    }
    return this.getAttribute("from").getColor();
  }
  constructor(...t) {
    super(...t), this.type = "animateColor";
  }
}
class u0 extends zh {
  calcValue() {
    const { progress: t, from: e, to: i } = this.getProgress(), s = an(e.getString()), r = an(i.getString());
    return s.map((a, l) => {
      const c = r[l];
      return a + (c - a) * t;
    }).join(" ");
  }
  constructor(...t) {
    super(...t), this.type = "animateTransform";
  }
}
class Vp extends Me {
  constructor(t, e, i) {
    super(t, e, i), this.type = "font-face", this.ascent = this.getAttribute("ascent").getNumber(), this.descent = this.getAttribute("descent").getNumber(), this.unitsPerEm = this.getAttribute("units-per-em").getNumber();
  }
}
class Bh extends me {
  constructor(t, e, i) {
    super(t, e, i), this.type = "glyph", this.horizAdvX = this.getAttribute("horiz-adv-x").getNumber(), this.unicode = this.getAttribute("unicode").getString(), this.arabicForm = this.getAttribute("arabic-form").getString();
  }
}
class Tp extends Bh {
  constructor(...t) {
    super(...t), this.type = "missing-glyph", this.horizAdvX = 0;
  }
}
class d0 extends Me {
  render() {
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "font", this.isArabic = !1, this.glyphs = {}, this.arabicGlyphs = {}, this.isRTL = !1, this.horizAdvX = this.getAttribute("horiz-adv-x").getNumber();
    const { definitions: s } = t, { children: r } = this;
    for (const o of r)
      if (o instanceof Vp) {
        this.fontFace = o;
        const a = o.getStyle("font-family");
        a.hasValue() && (s[a.getString()] = this);
      } else if (o instanceof Tp)
        this.missingGlyph = o;
      else if (o instanceof Bh)
        if (o.arabicForm) {
          this.isRTL = !0, this.isArabic = !0;
          const a = this.arabicGlyphs[o.unicode];
          typeof a > "u" ? this.arabicGlyphs[o.unicode] = {
            [o.arabicForm]: o
          } : a[o.arabicForm] = o;
        } else
          this.glyphs[o.unicode] = o;
  }
}
class m0 extends Ks {
  getText() {
    const t = this.getHrefAttribute().getDefinition();
    if (t) {
      const e = t.children[0];
      if (e)
        return e.getText();
    }
    return "";
  }
  constructor(...t) {
    super(...t), this.type = "tref";
  }
}
class p0 extends Ks {
  getText() {
    return this.text;
  }
  renderChildren(t) {
    if (this.hasText) {
      super.renderChildren(t);
      const { document: e, x: i, y: s } = this, { mouse: r } = e.screen, o = new Zt(e, "fontSize", Li.parse(e.ctx.font).fontSize);
      r.isWorking() && r.checkBoundingBox(this, new Tn(i, s - o.getPixels("y"), i + this.measureText(t), s));
    } else if (this.children.length > 0) {
      const e = new Dh(this.document);
      e.children = this.children, e.parent = this, e.render(t);
    }
  }
  onClick() {
    const { window: t } = this.document;
    t && t.open(this.getHrefAttribute().getString());
  }
  onMouseMove() {
    const t = this.document.ctx;
    t.canvas.style.cursor = "pointer";
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "a";
    const { childNodes: s } = e, r = s[0], o = s.length > 0 && Array.from(s).every(
      (a) => a.nodeType === 3
    );
    this.hasText = o, this.text = o ? this.getTextFromNode(r) : "";
  }
}
class g0 extends Ks {
  getText() {
    return this.text;
  }
  path(t) {
    const { dataArray: e } = this;
    t && t.beginPath(), e.forEach((i) => {
      let { type: s, points: r } = i;
      switch (s) {
        case Rt.LINE_TO:
          t && t.lineTo(r[0], r[1]);
          break;
        case Rt.MOVE_TO:
          t && t.moveTo(r[0], r[1]);
          break;
        case Rt.CURVE_TO:
          t && t.bezierCurveTo(r[0], r[1], r[2], r[3], r[4], r[5]);
          break;
        case Rt.QUAD_TO:
          t && t.quadraticCurveTo(r[0], r[1], r[2], r[3]);
          break;
        case Rt.ARC: {
          const [o, a, l, c, h, u, p, m] = r, g = l > c ? l : c, _ = l > c ? 1 : l / c, y = l > c ? c / l : 1;
          t && (t.translate(o, a), t.rotate(p), t.scale(_, y), t.arc(0, 0, g, h, h + u, !!(1 - m)), t.scale(1 / _, 1 / y), t.rotate(-p), t.translate(-o, -a));
          break;
        }
        case Rt.CLOSE_PATH:
          t && t.closePath();
          break;
      }
    });
  }
  renderChildren(t) {
    this.setTextData(t), t.save();
    const e = this.parent.getStyle("text-decoration").getString(), i = this.getFontSize(), { glyphInfo: s } = this, r = t.fillStyle;
    e === "underline" && t.beginPath(), s.forEach((o, a) => {
      const { p0: l, p1: c, rotation: h, text: u } = o;
      t.save(), t.translate(l.x, l.y), t.rotate(h), t.fillStyle && t.fillText(u, 0, 0), t.strokeStyle && t.strokeText(u, 0, 0), t.restore(), e === "underline" && (a === 0 && t.moveTo(l.x, l.y + i / 8), t.lineTo(c.x, c.y + i / 5));
    }), e === "underline" && (t.lineWidth = i / 20, t.strokeStyle = r, t.stroke(), t.closePath()), t.restore();
  }
  getLetterSpacingAt() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return this.letterSpacingCache[t] || 0;
  }
  findSegmentToFitChar(t, e, i, s, r, o, a, l, c) {
    let h = o, u = this.measureText(t, l);
    l === " " && e === "justify" && i < s && (u += (s - i) / r), c > -1 && (h += this.getLetterSpacingAt(c));
    const p = this.textHeight / 20, m = this.getEquidistantPointOnPath(h, p, 0), g = this.getEquidistantPointOnPath(h + u, p, 0), _ = {
      p0: m,
      p1: g
    }, y = m && g ? Math.atan2(g.y - m.y, g.x - m.x) : 0;
    if (a) {
      const b = Math.cos(Math.PI / 2 + y) * a, w = Math.cos(-y) * a;
      _.p0 = {
        ...m,
        x: m.x + b,
        y: m.y + w
      }, _.p1 = {
        ...g,
        x: g.x + b,
        y: g.y + w
      };
    }
    return h += u, {
      offset: h,
      segment: _,
      rotation: y
    };
  }
  measureText(t, e) {
    const { measuresCache: i } = this, s = e || this.getText();
    if (i.has(s))
      return i.get(s);
    const r = this.measureTargetText(t, s);
    return i.set(s, r), r;
  }
  // This method supposes what all custom fonts already loaded.
  // If some font will be loaded after this method call, <textPath> will not be rendered correctly.
  // You need to call this method manually to update glyphs cache.
  setTextData(t) {
    if (this.glyphInfo)
      return;
    const e = this.getText(), i = e.split(""), s = e.split(" ").length - 1, r = this.parent.getAttribute("dx").split().map(
      (v) => v.getPixels("x")
    ), o = this.parent.getAttribute("dy").getPixels("y"), a = this.parent.getStyle("text-anchor").getString("start"), l = this.getStyle("letter-spacing"), c = this.parent.getStyle("letter-spacing");
    let h = 0;
    !l.hasValue() || l.getValue() === "inherit" ? h = c.getPixels() : l.hasValue() && l.getValue() !== "initial" && l.getValue() !== "unset" && (h = l.getPixels());
    const u = [], p = e.length;
    this.letterSpacingCache = u;
    for (let v = 0; v < p; v++)
      u.push(typeof r[v] < "u" ? r[v] : h);
    const m = u.reduce(
      (v, C, k) => k === 0 ? 0 : v + C || 0,
      0
    ), g = this.measureText(t), _ = Math.max(g + m, 0);
    this.textWidth = g, this.textHeight = this.getFontSize(), this.glyphInfo = [];
    const y = this.getPathLength(), b = this.getStyle("startOffset").getNumber(0) * y;
    let w = 0;
    (a === "middle" || a === "center") && (w = -_ / 2), (a === "end" || a === "right") && (w = -_), w += b, i.forEach((v, C) => {
      const { offset: k, segment: Y, rotation: P } = this.findSegmentToFitChar(t, a, _, y, s, w, o, v, C);
      w = k, !(!Y.p0 || !Y.p1) && this.glyphInfo.push({
        // transposeX: midpoint.x,
        // transposeY: midpoint.y,
        text: i[C],
        p0: Y.p0,
        p1: Y.p1,
        rotation: P
      });
    });
  }
  parsePathData(t) {
    if (this.pathLength = -1, !t)
      return [];
    const e = [], { pathParser: i } = t;
    for (i.reset(); !i.isEnd(); ) {
      const { current: s } = i, r = s ? s.x : 0, o = s ? s.y : 0, a = i.next();
      let l = a.type, c = [];
      switch (a.type) {
        case Rt.MOVE_TO:
          this.pathM(i, c);
          break;
        case Rt.LINE_TO:
          l = this.pathL(i, c);
          break;
        case Rt.HORIZ_LINE_TO:
          l = this.pathH(i, c);
          break;
        case Rt.VERT_LINE_TO:
          l = this.pathV(i, c);
          break;
        case Rt.CURVE_TO:
          this.pathC(i, c);
          break;
        case Rt.SMOOTH_CURVE_TO:
          l = this.pathS(i, c);
          break;
        case Rt.QUAD_TO:
          this.pathQ(i, c);
          break;
        case Rt.SMOOTH_QUAD_TO:
          l = this.pathT(i, c);
          break;
        case Rt.ARC:
          c = this.pathA(i);
          break;
        case Rt.CLOSE_PATH:
          me.pathZ(i);
          break;
      }
      a.type !== Rt.CLOSE_PATH ? e.push({
        type: l,
        points: c,
        start: {
          x: r,
          y: o
        },
        pathLength: this.calcLength(r, o, l, c)
      }) : e.push({
        type: Rt.CLOSE_PATH,
        points: [],
        pathLength: 0
      });
    }
    return e;
  }
  pathM(t, e) {
    const { x: i, y: s } = me.pathM(t).point;
    e.push(i, s);
  }
  pathL(t, e) {
    const { x: i, y: s } = me.pathL(t).point;
    return e.push(i, s), Rt.LINE_TO;
  }
  pathH(t, e) {
    const { x: i, y: s } = me.pathH(t).point;
    return e.push(i, s), Rt.LINE_TO;
  }
  pathV(t, e) {
    const { x: i, y: s } = me.pathV(t).point;
    return e.push(i, s), Rt.LINE_TO;
  }
  pathC(t, e) {
    const { point: i, controlPoint: s, currentPoint: r } = me.pathC(t);
    e.push(i.x, i.y, s.x, s.y, r.x, r.y);
  }
  pathS(t, e) {
    const { point: i, controlPoint: s, currentPoint: r } = me.pathS(t);
    return e.push(i.x, i.y, s.x, s.y, r.x, r.y), Rt.CURVE_TO;
  }
  pathQ(t, e) {
    const { controlPoint: i, currentPoint: s } = me.pathQ(t);
    e.push(i.x, i.y, s.x, s.y);
  }
  pathT(t, e) {
    const { controlPoint: i, currentPoint: s } = me.pathT(t);
    return e.push(i.x, i.y, s.x, s.y), Rt.QUAD_TO;
  }
  pathA(t) {
    let { rX: e, rY: i, sweepFlag: s, xAxisRotation: r, centp: o, a1: a, ad: l } = me.pathA(t);
    return s === 0 && l > 0 && (l -= 2 * Math.PI), s === 1 && l < 0 && (l += 2 * Math.PI), [
      o.x,
      o.y,
      e,
      i,
      a,
      l,
      r,
      s
    ];
  }
  calcLength(t, e, i, s) {
    let r = 0, o = null, a = null, l = 0;
    switch (i) {
      case Rt.LINE_TO:
        return this.getLineLength(t, e, s[0], s[1]);
      case Rt.CURVE_TO:
        for (r = 0, o = this.getPointOnCubicBezier(0, t, e, s[0], s[1], s[2], s[3], s[4], s[5]), l = 0.01; l <= 1; l += 0.01)
          a = this.getPointOnCubicBezier(l, t, e, s[0], s[1], s[2], s[3], s[4], s[5]), r += this.getLineLength(o.x, o.y, a.x, a.y), o = a;
        return r;
      case Rt.QUAD_TO:
        for (r = 0, o = this.getPointOnQuadraticBezier(0, t, e, s[0], s[1], s[2], s[3]), l = 0.01; l <= 1; l += 0.01)
          a = this.getPointOnQuadraticBezier(l, t, e, s[0], s[1], s[2], s[3]), r += this.getLineLength(o.x, o.y, a.x, a.y), o = a;
        return r;
      case Rt.ARC: {
        r = 0;
        const c = s[4], h = s[5], u = s[4] + h;
        let p = Math.PI / 180;
        if (Math.abs(c - u) < p && (p = Math.abs(c - u)), o = this.getPointOnEllipticalArc(s[0], s[1], s[2], s[3], c, 0), h < 0)
          for (l = c - p; l > u; l -= p)
            a = this.getPointOnEllipticalArc(s[0], s[1], s[2], s[3], l, 0), r += this.getLineLength(o.x, o.y, a.x, a.y), o = a;
        else
          for (l = c + p; l < u; l += p)
            a = this.getPointOnEllipticalArc(s[0], s[1], s[2], s[3], l, 0), r += this.getLineLength(o.x, o.y, a.x, a.y), o = a;
        return a = this.getPointOnEllipticalArc(s[0], s[1], s[2], s[3], u, 0), r += this.getLineLength(o.x, o.y, a.x, a.y), r;
      }
    }
    return 0;
  }
  getPointOnLine(t, e, i, s, r) {
    let o = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : e, a = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : i;
    const l = (r - i) / (s - e + Fr);
    let c = Math.sqrt(t * t / (1 + l * l));
    s < e && (c *= -1);
    let h = l * c, u = null;
    if (s === e)
      u = {
        x: o,
        y: a + h
      };
    else if ((a - i) / (o - e + Fr) === l)
      u = {
        x: o + c,
        y: a + h
      };
    else {
      let p = 0, m = 0;
      const g = this.getLineLength(e, i, s, r);
      if (g < Fr)
        return null;
      let _ = (o - e) * (s - e) + (a - i) * (r - i);
      _ /= g * g, p = e + _ * (s - e), m = i + _ * (r - i);
      const y = this.getLineLength(o, a, p, m), b = Math.sqrt(t * t - y * y);
      c = Math.sqrt(b * b / (1 + l * l)), s < e && (c *= -1), h = l * c, u = {
        x: p + c,
        y: m + h
      };
    }
    return u;
  }
  getPointOnPath(t) {
    const e = this.getPathLength();
    let i = 0, s = null;
    if (t < -5e-5 || t - 5e-5 > e)
      return null;
    const { dataArray: r } = this;
    for (const o of r) {
      if (o && (o.pathLength < 5e-5 || i + o.pathLength + 5e-5 < t)) {
        i += o.pathLength;
        continue;
      }
      const a = t - i;
      let l = 0;
      switch (o.type) {
        case Rt.LINE_TO:
          s = this.getPointOnLine(a, o.start.x, o.start.y, o.points[0], o.points[1], o.start.x, o.start.y);
          break;
        case Rt.ARC: {
          const c = o.points[4], h = o.points[5], u = o.points[4] + h;
          if (l = c + a / o.pathLength * h, h < 0 && l < u || h >= 0 && l > u)
            break;
          s = this.getPointOnEllipticalArc(o.points[0], o.points[1], o.points[2], o.points[3], l, o.points[6]);
          break;
        }
        case Rt.CURVE_TO:
          l = a / o.pathLength, l > 1 && (l = 1), s = this.getPointOnCubicBezier(l, o.start.x, o.start.y, o.points[0], o.points[1], o.points[2], o.points[3], o.points[4], o.points[5]);
          break;
        case Rt.QUAD_TO:
          l = a / o.pathLength, l > 1 && (l = 1), s = this.getPointOnQuadraticBezier(l, o.start.x, o.start.y, o.points[0], o.points[1], o.points[2], o.points[3]);
          break;
      }
      if (s)
        return s;
      break;
    }
    return null;
  }
  getLineLength(t, e, i, s) {
    return Math.sqrt((i - t) * (i - t) + (s - e) * (s - e));
  }
  getPathLength() {
    return this.pathLength === -1 && (this.pathLength = this.dataArray.reduce(
      (t, e) => e.pathLength > 0 ? t + e.pathLength : t,
      0
    )), this.pathLength;
  }
  getPointOnCubicBezier(t, e, i, s, r, o, a, l, c) {
    const h = l * Eu(t) + o * Ru(t) + s * Nu(t) + e * Lu(t), u = c * Eu(t) + a * Ru(t) + r * Nu(t) + i * Lu(t);
    return {
      x: h,
      y: u
    };
  }
  getPointOnQuadraticBezier(t, e, i, s, r, o, a) {
    const l = o * Xu(t) + s * Fu(t) + e * Ku(t), c = a * Xu(t) + r * Fu(t) + i * Ku(t);
    return {
      x: l,
      y: c
    };
  }
  getPointOnEllipticalArc(t, e, i, s, r, o) {
    const a = Math.cos(o), l = Math.sin(o), c = {
      x: i * Math.cos(r),
      y: s * Math.sin(r)
    };
    return {
      x: t + (c.x * a - c.y * l),
      y: e + (c.x * l + c.y * a)
    };
  }
  // TODO need some optimisations. possibly build cache only for curved segments?
  buildEquidistantCache(t, e) {
    const i = this.getPathLength(), s = e || 0.25, r = t || i / 100;
    if (!this.equidistantCache || this.equidistantCache.step !== r || this.equidistantCache.precision !== s) {
      this.equidistantCache = {
        step: r,
        precision: s,
        points: []
      };
      let o = 0;
      for (let a = 0; a <= i; a += s) {
        const l = this.getPointOnPath(a), c = this.getPointOnPath(a + s);
        !l || !c || (o += this.getLineLength(l.x, l.y, c.x, c.y), o >= r && (this.equidistantCache.points.push({
          x: l.x,
          y: l.y,
          distance: a
        }), o -= r));
      }
    }
  }
  getEquidistantPointOnPath(t, e, i) {
    if (this.buildEquidistantCache(e, i), t < 0 || t - this.getPathLength() > 5e-5)
      return null;
    const s = Math.round(t / this.getPathLength() * (this.equidistantCache.points.length - 1));
    return this.equidistantCache.points[s] || null;
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "textPath", this.textWidth = 0, this.textHeight = 0, this.pathLength = -1, this.glyphInfo = null, this.letterSpacingCache = [], this.measuresCache = /* @__PURE__ */ new Map([
      [
        "",
        0
      ]
    ]);
    const s = this.getHrefAttribute().getDefinition();
    this.text = this.getTextFromNode(), this.dataArray = this.parsePathData(s);
  }
}
const f0 = /^\s*data:(([^/,;]+\/[^/,;]+)(?:;([^,;=]+=[^,;=]+))?)?(?:;(base64))?,(.*)$/i;
class _0 extends Ir {
  async loadImage(t) {
    try {
      const e = await this.document.createImage(t);
      this.image = e;
    } catch (e) {
      console.error('Error while loading image "'.concat(t, '":'), e);
    }
    this.loaded = !0;
  }
  async loadSvg(t) {
    const e = f0.exec(t);
    if (e) {
      const i = e[5];
      i && (e[4] === "base64" ? this.image = atob(i) : this.image = decodeURIComponent(i));
    } else
      try {
        const s = await (await this.document.fetch(t)).text();
        this.image = s;
      } catch (i) {
        console.error('Error while loading image "'.concat(t, '":'), i);
      }
    this.loaded = !0;
  }
  renderChildren(t) {
    const { document: e, image: i, loaded: s } = this, r = this.getAttribute("x").getPixels("x"), o = this.getAttribute("y").getPixels("y"), a = this.getStyle("width").getPixels("x"), l = this.getStyle("height").getPixels("y");
    if (!(!s || !i || !a || !l)) {
      if (t.save(), t.translate(r, o), typeof i == "string") {
        const c = e.canvg.forkString(t, i, {
          ignoreMouse: !0,
          ignoreAnimation: !0,
          ignoreDimensions: !0,
          ignoreClear: !0,
          offsetX: 0,
          offsetY: 0,
          scaleWidth: a,
          scaleHeight: l
        }), { documentElement: h } = c.document;
        h && (h.parent = this), c.render();
      } else
        e.setViewBox({
          ctx: t,
          aspectRatio: this.getAttribute("preserveAspectRatio").getString(),
          width: a,
          desiredWidth: i.width,
          height: l,
          desiredHeight: i.height
        }), this.loaded && (!("complete" in i) || i.complete) && t.drawImage(i, 0, 0);
      t.restore();
    }
  }
  getBoundingBox() {
    const t = this.getAttribute("x").getPixels("x"), e = this.getAttribute("y").getPixels("y"), i = this.getStyle("width").getPixels("x"), s = this.getStyle("height").getPixels("y");
    return new Tn(t, e, t + i, e + s);
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "image", this.loaded = !1;
    const s = this.getHrefAttribute().getString();
    if (!s)
      return;
    const r = s.endsWith(".svg") || /^\s*data:image\/svg\+xml/i.test(s);
    t.images.push(this), r ? this.loadSvg(s) : this.loadImage(s);
  }
}
class y0 extends Ir {
  render(t) {
  }
  constructor(...t) {
    super(...t), this.type = "symbol";
  }
}
class b0 {
  async load(t, e) {
    try {
      const { document: i } = this, r = (await i.canvg.parser.load(e)).getElementsByTagName("font");
      Array.from(r).forEach((o) => {
        const a = i.createElement(o);
        i.definitions[t] = a;
      });
    } catch (i) {
      console.error('Error while loading font "'.concat(e, '":'), i);
    }
    this.loaded = !0;
  }
  constructor(t) {
    this.document = t, this.loaded = !1, t.fonts.push(this);
  }
}
class Ep extends Me {
  constructor(t, e, i) {
    super(t, e, i), this.type = "style", io(
      Array.from(e.childNodes).map(
        (o) => o.textContent
      ).join("").replace(/(\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+\/)|(^[\s]*\/\/.*)/gm, "").replace(/@import.*;/g, "")
      // remove imports
    ).split("}").forEach((o) => {
      const a = o.trim();
      if (!a)
        return;
      const l = a.split("{"), c = l[0].split(","), h = l[1].split(";");
      c.forEach((u) => {
        const p = u.trim();
        if (!p)
          return;
        const m = t.styles[p] || {};
        if (h.forEach((g) => {
          const _ = g.indexOf(":"), y = g.substr(0, _).trim(), b = g.substr(_ + 1, g.length - _).trim();
          y && b && (m[y] = new Zt(t, y, b));
        }), t.styles[p] = m, t.stylesSpecificity[p] = Nb(p), p === "@font-face") {
          const g = m["font-family"].getString().replace(/"|'/g, "");
          m.src.getString().split(",").forEach((y) => {
            if (y.indexOf('format("svg")') > 0) {
              const b = Zp(y);
              b && new b0(t).load(g, b);
            }
          });
        }
      });
    });
  }
}
Ep.parseExternalUrl = Zp;
class I0 extends Ir {
  setContext(t) {
    super.setContext(t);
    const e = this.getAttribute("x"), i = this.getAttribute("y");
    e.hasValue() && t.translate(e.getPixels("x"), 0), i.hasValue() && t.translate(0, i.getPixels("y"));
  }
  path(t) {
    const { element: e } = this;
    e && e.path(t);
  }
  renderChildren(t) {
    const { document: e, element: i } = this;
    if (i) {
      let s = i;
      if (i.type === "symbol" && (s = new Ra(e), s.attributes.viewBox = new Zt(e, "viewBox", i.getAttribute("viewBox").getString()), s.attributes.preserveAspectRatio = new Zt(e, "preserveAspectRatio", i.getAttribute("preserveAspectRatio").getString()), s.attributes.overflow = new Zt(e, "overflow", i.getAttribute("overflow").getString()), s.children = i.children, i.styles.opacity = new Zt(e, "opacity", this.calculateOpacity())), s.type === "svg") {
        const o = this.getStyle("width", !1, !0), a = this.getStyle("height", !1, !0);
        o.hasValue() && (s.attributes.width = new Zt(e, "width", o.getString())), a.hasValue() && (s.attributes.height = new Zt(e, "height", a.getString()));
      }
      const r = s.parent;
      s.parent = this, s.render(t), s.parent = r;
    }
  }
  getBoundingBox(t) {
    const { element: e } = this;
    return e ? e.getBoundingBox(t) : null;
  }
  elementTransform() {
    const { document: t, element: e } = this;
    return e ? _r.fromElement(t, e) : null;
  }
  get element() {
    return this.cachedElement || (this.cachedElement = this.getHrefAttribute().getDefinition()), this.cachedElement;
  }
  constructor(...t) {
    super(...t), this.type = "use";
  }
}
function Ba(n, t, e, i, s, r) {
  return n[e * i * 4 + t * 4 + r];
}
function Ja(n, t, e, i, s, r, o) {
  n[e * i * 4 + t * 4 + r] = o;
}
function qe(n, t, e) {
  return n[t] * e;
}
function ns(n, t, e, i) {
  return t + Math.cos(n) * e + Math.sin(n) * i;
}
class Rp extends Me {
  apply(t, e, i, s, r) {
    const { includeOpacity: o, matrix: a } = this, l = t.getImageData(0, 0, s, r);
    for (let c = 0; c < r; c++)
      for (let h = 0; h < s; h++) {
        const u = Ba(l.data, h, c, s, r, 0), p = Ba(l.data, h, c, s, r, 1), m = Ba(l.data, h, c, s, r, 2), g = Ba(l.data, h, c, s, r, 3);
        let _ = qe(a, 0, u) + qe(a, 1, p) + qe(a, 2, m) + qe(a, 3, g) + qe(a, 4, 1), y = qe(a, 5, u) + qe(a, 6, p) + qe(a, 7, m) + qe(a, 8, g) + qe(a, 9, 1), b = qe(a, 10, u) + qe(a, 11, p) + qe(a, 12, m) + qe(a, 13, g) + qe(a, 14, 1), w = qe(a, 15, u) + qe(a, 16, p) + qe(a, 17, m) + qe(a, 18, g) + qe(a, 19, 1);
        o && (_ = 0, y = 0, b = 0, w *= g / 255), Ja(l.data, h, c, s, r, 0, _), Ja(l.data, h, c, s, r, 1, y), Ja(l.data, h, c, s, r, 2, b), Ja(l.data, h, c, s, r, 3, w);
      }
    t.clearRect(0, 0, s, r), t.putImageData(l, 0, 0);
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "feColorMatrix";
    let s = an(this.getAttribute("values").getString());
    switch (this.getAttribute("type").getString("matrix")) {
      case "saturate": {
        const r = s[0];
        s = [
          0.213 + 0.787 * r,
          0.715 - 0.715 * r,
          0.072 - 0.072 * r,
          0,
          0,
          0.213 - 0.213 * r,
          0.715 + 0.285 * r,
          0.072 - 0.072 * r,
          0,
          0,
          0.213 - 0.213 * r,
          0.715 - 0.715 * r,
          0.072 + 0.928 * r,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          1
        ];
        break;
      }
      case "hueRotate": {
        const r = s[0] * Math.PI / 180;
        s = [
          ns(r, 0.213, 0.787, -0.213),
          ns(r, 0.715, -0.715, -0.715),
          ns(r, 0.072, -0.072, 0.928),
          0,
          0,
          ns(r, 0.213, -0.213, 0.143),
          ns(r, 0.715, 0.285, 0.14),
          ns(r, 0.072, -0.072, -0.283),
          0,
          0,
          ns(r, 0.213, -0.213, -0.787),
          ns(r, 0.715, -0.715, 0.715),
          ns(r, 0.072, 0.928, 0.072),
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          1
        ];
        break;
      }
      case "luminanceToAlpha":
        s = [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0.2125,
          0.7154,
          0.0721,
          0,
          0,
          0,
          0,
          0,
          0,
          1
        ];
        break;
    }
    this.matrix = s, this.includeOpacity = this.getAttribute("includeOpacity").hasValue();
  }
}
class tc extends Me {
  apply(t, e) {
    const { document: i } = this;
    let s = this.getAttribute("x").getPixels("x"), r = this.getAttribute("y").getPixels("y"), o = this.getStyle("width").getPixels("x"), a = this.getStyle("height").getPixels("y");
    if (!o && !a) {
      const m = new Tn();
      this.children.forEach((g) => {
        m.addBoundingBox(g.getBoundingBox(t));
      }), s = Math.floor(m.x1), r = Math.floor(m.y1), o = Math.floor(m.width), a = Math.floor(m.height);
    }
    const l = this.removeStyles(e, tc.ignoreStyles), c = i.createCanvas(s + o, r + a), h = c.getContext("2d");
    i.screen.setDefaults(h), this.renderChildren(h), new Rp(i, {
      nodeType: 1,
      childNodes: [],
      attributes: [
        {
          nodeName: "type",
          value: "luminanceToAlpha"
        },
        {
          nodeName: "includeOpacity",
          value: "true"
        }
      ]
    }).apply(h, 0, 0, s + o, r + a);
    const u = i.createCanvas(s + o, r + a), p = u.getContext("2d");
    i.screen.setDefaults(p), e.render(p), p.globalCompositeOperation = "destination-in", p.fillStyle = h.createPattern(c, "no-repeat"), p.fillRect(0, 0, s + o, r + a), t.fillStyle = p.createPattern(u, "no-repeat"), t.fillRect(0, 0, s + o, r + a), this.restoreStyles(e, l);
  }
  render(t) {
  }
  constructor(...t) {
    super(...t), this.type = "mask";
  }
}
tc.ignoreStyles = [
  "mask",
  "transform",
  "clip-path"
];
const Au = () => {
};
class w0 extends Me {
  apply(t) {
    const { document: e } = this, i = Reflect.getPrototypeOf(t), { beginPath: s, closePath: r } = t;
    i && (i.beginPath = Au, i.closePath = Au), Reflect.apply(s, t, []), this.children.forEach((o) => {
      if (!("path" in o))
        return;
      let a = "elementTransform" in o ? o.elementTransform() : null;
      a || (a = _r.fromElement(e, o)), a && a.apply(t), o.path(t), i && (i.closePath = r), a && a.unapply(t);
    }), Reflect.apply(r, t, []), t.clip(), i && (i.beginPath = s, i.closePath = r);
  }
  render(t) {
  }
  constructor(...t) {
    super(...t), this.type = "clipPath";
  }
}
class ec extends Me {
  apply(t, e) {
    const { document: i, children: s } = this, r = "getBoundingBox" in e ? e.getBoundingBox(t) : null;
    if (!r)
      return;
    let o = 0, a = 0;
    s.forEach((b) => {
      const w = b.extraFilterDistance || 0;
      o = Math.max(o, w), a = Math.max(a, w);
    });
    const l = Math.floor(r.width), c = Math.floor(r.height), h = l + 2 * o, u = c + 2 * a;
    if (h < 1 || u < 1)
      return;
    const p = Math.floor(r.x), m = Math.floor(r.y), g = this.removeStyles(e, ec.ignoreStyles), _ = i.createCanvas(h, u), y = _.getContext("2d");
    i.screen.setDefaults(y), y.translate(-p + o, -m + a), e.render(y), s.forEach((b) => {
      typeof b.apply == "function" && b.apply(y, 0, 0, h, u);
    }), t.drawImage(_, 0, 0, h, u, p - o, m - a, h, u), this.restoreStyles(e, g);
  }
  render(t) {
  }
  constructor(...t) {
    super(...t), this.type = "filter";
  }
}
ec.ignoreStyles = [
  "filter",
  "transform",
  "clip-path"
];
class v0 extends Me {
  apply(t, e, i, s, r) {
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "feDropShadow", this.addStylesFromStyleDefinition();
  }
}
class S0 extends Me {
  apply(t, e, i, s, r) {
  }
  constructor(...t) {
    super(...t), this.type = "feMorphology";
  }
}
class x0 extends Me {
  apply(t, e, i, s, r) {
  }
  constructor(...t) {
    super(...t), this.type = "feComposite";
  }
}
class Z0 extends Me {
  apply(t, e, i, s, r) {
    const { document: o, blurRadius: a } = this, l = o.window ? o.window.document.body : null, c = t.canvas;
    c.id = o.getUniqueId(), l && (c.style.display = "none", l.appendChild(c)), vb(c, e, i, s, r, a), l && l.removeChild(c);
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "feGaussianBlur", this.blurRadius = Math.floor(this.getAttribute("stdDeviation").getNumber()), this.extraFilterDistance = this.blurRadius;
  }
}
class C0 extends Me {
  constructor(...t) {
    super(...t), this.type = "title";
  }
}
class k0 extends Me {
  constructor(...t) {
    super(...t), this.type = "desc";
  }
}
const M0 = {
  svg: Ra,
  rect: Pp,
  circle: t0,
  ellipse: e0,
  line: i0,
  polyline: Gp,
  polygon: n0,
  path: me,
  pattern: s0,
  marker: r0,
  defs: o0,
  linearGradient: a0,
  radialGradient: l0,
  stop: c0,
  animate: zh,
  animateColor: h0,
  animateTransform: u0,
  font: d0,
  "font-face": Vp,
  "missing-glyph": Tp,
  glyph: Bh,
  text: Ks,
  tspan: $l,
  tref: m0,
  a: p0,
  textPath: g0,
  image: _0,
  g: Dh,
  symbol: y0,
  style: Ep,
  use: I0,
  mask: tc,
  clipPath: w0,
  filter: ec,
  feDropShadow: v0,
  feMorphology: S0,
  feComposite: x0,
  feColorMatrix: Rp,
  feGaussianBlur: Z0,
  title: C0,
  desc: k0
};
function W0(n, t) {
  const e = document.createElement("canvas");
  return e.width = n, e.height = t, e;
}
async function P0(n) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  const e = document.createElement("img");
  return t && (e.crossOrigin = "Anonymous"), new Promise((i, s) => {
    e.onload = () => {
      i(e);
    }, e.onerror = (r, o, a, l, c) => {
      s(c);
    }, e.src = n;
  });
}
const fc = 12;
class Vs {
  bindCreateImage(t, e) {
    return typeof e == "boolean" ? (i, s) => t(i, typeof s == "boolean" ? s : e) : t;
  }
  get window() {
    return this.screen.window;
  }
  get fetch() {
    return this.screen.fetch;
  }
  get ctx() {
    return this.screen.ctx;
  }
  get emSize() {
    const { emSizeStack: t } = this;
    return t[t.length - 1] || fc;
  }
  set emSize(t) {
    const { emSizeStack: e } = this;
    e.push(t);
  }
  popEmSize() {
    const { emSizeStack: t } = this;
    t.pop();
  }
  getUniqueId() {
    return "canvg".concat(++this.uniqueId);
  }
  isImagesLoaded() {
    return this.images.every(
      (t) => t.loaded
    );
  }
  isFontsLoaded() {
    return this.fonts.every(
      (t) => t.loaded
    );
  }
  createDocumentElement(t) {
    const e = this.createElement(t.documentElement);
    return e.root = !0, e.addStylesFromStyleDefinition(), this.documentElement = e, e;
  }
  createElement(t) {
    const e = t.nodeName.replace(/^[^:]+:/, ""), i = Vs.elementTypes[e];
    return i ? new i(this, t) : new jb(this, t);
  }
  createTextNode(t) {
    return new $b(this, t);
  }
  setViewBox(t) {
    this.screen.setViewBox({
      document: this,
      ...t
    });
  }
  constructor(t, { rootEmSize: e = fc, emSize: i = fc, createCanvas: s = Vs.createCanvas, createImage: r = Vs.createImage, anonymousCrossOrigin: o } = {}) {
    this.canvg = t, this.definitions = {}, this.styles = {}, this.stylesSpecificity = {}, this.images = [], this.fonts = [], this.emSizeStack = [], this.uniqueId = 0, this.screen = t.screen, this.rootEmSize = e, this.emSize = i, this.createCanvas = s, this.createImage = this.bindCreateImage(r, o), this.screen.wait(
      () => this.isImagesLoaded()
    ), this.screen.wait(
      () => this.isFontsLoaded()
    );
  }
}
Vs.createCanvas = W0;
Vs.createImage = P0;
Vs.elementTypes = M0;
class nr {
  /**
  * Create Canvg instance from SVG source string or URL.
  * @param ctx - Rendering context.
  * @param svg - SVG source string or URL.
  * @param options - Rendering options.
  * @returns Canvg instance.
  */
  static async from(t, e) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const r = await new gc(i).parse(e);
    return new nr(t, r, i);
  }
  /**
  * Create Canvg instance from SVG source string.
  * @param ctx - Rendering context.
  * @param svg - SVG source string.
  * @param options - Rendering options.
  * @returns Canvg instance.
  */
  static fromString(t, e) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const r = new gc(i).parseFromString(e);
    return new nr(t, r, i);
  }
  /**
  * Create new Canvg instance with inherited options.
  * @param ctx - Rendering context.
  * @param svg - SVG source string or URL.
  * @param options - Rendering options.
  * @returns Canvg instance.
  */
  fork(t, e) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return nr.from(t, e, {
      ...this.options,
      ...i
    });
  }
  /**
  * Create new Canvg instance with inherited options.
  * @param ctx - Rendering context.
  * @param svg - SVG source string.
  * @param options - Rendering options.
  * @returns Canvg instance.
  */
  forkString(t, e) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return nr.fromString(t, e, {
      ...this.options,
      ...i
    });
  }
  /**
  * Document is ready promise.
  * @returns Ready promise.
  */
  ready() {
    return this.screen.ready();
  }
  /**
  * Document is ready value.
  * @returns Is ready or not.
  */
  isReady() {
    return this.screen.isReady();
  }
  /**
  * Render only first frame, ignoring animations and mouse.
  * @param options - Rendering options.
  */
  async render() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.start({
      enableRedraw: !0,
      ignoreAnimation: !0,
      ignoreMouse: !0,
      ...t
    }), await this.ready(), this.stop();
  }
  /**
  * Start rendering.
  * @param options - Render options.
  */
  start() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const { documentElement: e, screen: i, options: s } = this;
    i.start(e, {
      enableRedraw: !0,
      ...s,
      ...t
    });
  }
  /**
  * Stop rendering.
  */
  stop() {
    this.screen.stop();
  }
  /**
  * Resize SVG to fit in given size.
  * @param width
  * @param height
  * @param preserveAspectRatio
  */
  resize(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : t, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
    this.documentElement.resize(t, e, i);
  }
  /**
  * Main constructor.
  * @param ctx - Rendering context.
  * @param svg - SVG Document.
  * @param options - Rendering options.
  */
  constructor(t, e, i = {}) {
    this.parser = new gc(i), this.screen = new bs(t, i), this.options = i;
    const s = new Vs(this, i), r = s.createDocumentElement(e);
    this.document = s, this.documentElement = r;
  }
}
(function(n, t, e, i, s, r) {
  function o(f, I, S, M, N) {
    return m(f, f, S, M, I, f.defaultView.pageXOffset, f.defaultView.pageYOffset).then(function(F) {
      W("Document cloned");
      var ot = "data-html2canvas-node" + N, q = "[" + ot + "='" + N + "']";
      f.querySelector(q).removeAttribute(ot);
      var ot = F.contentWindow, pt = ot.document.querySelector(q);
      return (typeof I.onclone == "function" ? Promise.resolve(I.onclone(ot.document)) : Promise.resolve(!0)).then(function() {
        return a(pt, F, I, S, M);
      });
    });
  }
  function a(f, I, S, M, N) {
    var F = I.contentWindow, q = new wn(F.document), ot = new X(S, q), pt = O(f);
    M = S.type === "view" ? M : c(F.document), N = S.type === "view" ? N : h(F.document);
    var Nt = new S.renderer(M, N, ot, S, t);
    return new rt(f, Nt, q, ot, S).ready.then(function() {
      W("Finished rendering");
      var ue;
      return ue = S.type === "view" ? l(Nt.canvas, {
        width: Nt.canvas.width,
        height: Nt.canvas.height,
        top: 0,
        left: 0,
        x: 0,
        y: 0
      }) : f === F.document.body || f === F.document.documentElement || S.canvas != null ? Nt.canvas : l(Nt.canvas, {
        width: S.width != null ? S.width : pt.width,
        height: S.height != null ? S.height : pt.height,
        top: pt.top,
        left: pt.left,
        x: F.pageXOffset,
        y: F.pageYOffset
      }), S.removeContainer && (I.parentNode.removeChild(I), W("Cleaned up container")), ue;
    });
  }
  function l(f, I) {
    var S = t.createElement("canvas"), M = Math.min(f.width - 1, Math.max(0, I.left)), N = Math.min(f.width, Math.max(1, I.left + I.width)), F = Math.min(f.height - 1, Math.max(0, I.top)), q = Math.min(f.height, Math.max(1, I.top + I.height));
    return S.width = I.width, S.height = I.height, W("Cropping canvas at:", "left:", I.left, "top:", I.top, "width:", N - M, "height:", q - F), W("Resulting crop with width", I.width, "and height", I.height, " with x", M, "and y", F), S.getContext("2d").drawImage(f, M, F, N - M, q - F, I.x, I.y, N - M, q - F), S;
  }
  function c(f) {
    return Math.max(
      Math.max(f.body.scrollWidth, f.documentElement.scrollWidth),
      Math.max(f.body.offsetWidth, f.documentElement.offsetWidth),
      Math.max(f.body.clientWidth, f.documentElement.clientWidth)
    );
  }
  function h(f) {
    return Math.max(
      Math.max(f.body.scrollHeight, f.documentElement.scrollHeight),
      Math.max(f.body.offsetHeight, f.documentElement.offsetHeight),
      Math.max(f.body.clientHeight, f.documentElement.clientHeight)
    );
  }
  function u() {
    return "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
  }
  function p(f, I) {
    for (var S = f.nodeType === 3 ? t.createTextNode(f.nodeValue) : f.cloneNode(!1), M = f.firstChild; M; )
      I !== !0 && M.nodeType === 1 && M.nodeName === "SCRIPT" || S.appendChild(p(M, I)), M = M.nextSibling;
    return S;
  }
  function m(f, I, S, M, N, F, q) {
    b(f);
    var ot = t.documentMode && 9 >= t.documentMode ? p(f.documentElement, N.javascriptEnabled) : f.documentElement.cloneNode(!0), pt = I.createElement("iframe");
    return pt.className = "html2canvas-container", pt.style.visibility = "hidden", pt.style.position = "fixed", pt.style.left = "-10000px", pt.style.top = "0px", pt.style.border = "0", pt.width = S, pt.height = M, pt.scrolling = "no", I.body.appendChild(pt), new Promise(function(Nt) {
      var ue = pt.contentWindow.document;
      g(f.documentElement, ot, "textarea"), g(f.documentElement, ot, "select"), pt.contentWindow.onload = pt.onload = function() {
        var ri = setInterval(function() {
          0 < ue.body.childNodes.length && (w(f, ue), clearInterval(ri), N.type === "view" && pt.contentWindow.scrollTo(F, q), Nt(pt));
        }, 50);
      }, ue.open(), ue.write("<!DOCTYPE html><html></html>"), !f.defaultView || F === f.defaultView.pageXOffset && q === f.defaultView.pageYOffset || f.defaultView.scrollTo(F, q), ue.replaceChild(
        N.javascriptEnabled === !0 ? ue.adoptNode(ot) : v(ue.adoptNode(ot)),
        ue.documentElement
      ), ue.close();
    });
  }
  function g(f, I, S) {
    f = f.getElementsByTagName(S), I = I.getElementsByTagName(S), S = f.length;
    for (var M = 0; M < S; M++)
      I[M].value = f[M].value;
  }
  function _(f, I, S, M, N, F) {
    return new Ii(f, I, n.document).then(y(f)).then(function(q) {
      return m(q, S, M, N, F, 0, 0);
    });
  }
  function y(f) {
    return function(I) {
      var S = new DOMParser(), M;
      try {
        M = S.parseFromString(I, "text/html");
      } catch {
        W("DOMParser not supported, falling back to createHTMLDocument"), M = t.implementation.createHTMLDocument("");
        try {
          M.open(), M.write(I), M.close();
        } catch {
          W("createHTMLDocument write not supported, falling back to document.body.innerHTML"), M.body.innerHTML = I;
        }
      }
      return I = M.querySelector("base"), I && I.href.host || (I = M.createElement("base"), I.href = f, M.head.insertBefore(I, M.head.firstChild)), M;
    };
  }
  function b(f) {
    [].slice.call(f.querySelectorAll("canvas"), 0).forEach(function(I) {
      I.setAttribute("data-html2canvas-canvas-clone", "canvas-" + Kp++);
    });
  }
  function w(f, I) {
    [].slice.call(f.querySelectorAll("[data-html2canvas-canvas-clone]"), 0).forEach(function(S) {
      try {
        var M = I.querySelector(
          '[data-html2canvas-canvas-clone="' + S.getAttribute("data-html2canvas-canvas-clone") + '"]'
        );
        M && (M.width = S.width, M.height = S.height, M.getContext("2d").putImageData(S.getContext("2d").getImageData(0, 0, S.width, S.height), 0, 0));
      } catch (N) {
        W("Unable to copy canvas content from", S, N);
      }
      S.removeAttribute("data-html2canvas-canvas-clone");
    });
  }
  function v(f) {
    return [].slice.call(f.childNodes, 0).filter(C).forEach(function(I) {
      I.tagName === "SCRIPT" ? f.removeChild(I) : v(I);
    }), f;
  }
  function C(f) {
    return f.nodeType === Node.ELEMENT_NODE;
  }
  function k(f) {
    var I = t.createElement("a");
    return I.href = f, I.href = I.href, I;
  }
  function Y(f) {
    this.b = this.g = this.r = 0, this.a = null, this.fromArray(f) || this.namedColor(f) || this.rgb(f) || this.rgba(f) || this.hex6(f) || this.hex3(f);
  }
  function P(f) {
    if (this.src = f, W("DummyImageContainer for", f), !this.promise || !this.image) {
      W("Initiating DummyImageContainer"), P.prototype.image = new Image();
      var I = this.image;
      P.prototype.promise = new Promise(function(S, M) {
        I.onload = S, I.onerror = M, I.src = u(), I.complete === !0 && S(I);
      });
    }
  }
  function L(f, I) {
    var S = t.createElement("div"), M = t.createElement("img"), N = t.createElement("span"), F;
    S.style.visibility = "hidden", S.style.fontFamily = f, S.style.fontSize = I, S.style.margin = 0, S.style.padding = 0, t.body.appendChild(S), M.src = u(), M.width = 1, M.height = 1, M.style.margin = 0, M.style.padding = 0, M.style.verticalAlign = "baseline", N.style.fontFamily = f, N.style.fontSize = I, N.style.margin = 0, N.style.padding = 0, N.appendChild(t.createTextNode("Hidden Text")), S.appendChild(N), S.appendChild(M), F = M.offsetTop - N.offsetTop + 1, S.removeChild(N), S.appendChild(t.createTextNode("Hidden Text")), S.style.lineHeight = "normal", M.style.verticalAlign = "super", M = M.offsetTop - S.offsetTop + 1, t.body.removeChild(S), this.baseline = F, this.lineWidth = 1, this.middle = M;
  }
  function R() {
    this.data = {};
  }
  function D(f, I, S) {
    this.image = null, this.src = f;
    var M = this, N = O(f);
    this.promise = (I ? new Promise(function(F) {
      f.contentWindow.document.URL === "about:blank" || f.contentWindow.document.documentElement == null ? f.contentWindow.onload = f.onload = function() {
        F(f);
      } : F(f);
    }) : this.proxyLoad(S.proxy, N, S)).then(function(F) {
      return html2canvas(F.contentWindow.document.documentElement, {
        type: "view",
        width: F.width,
        height: F.height,
        proxy: S.proxy,
        javascriptEnabled: S.javascriptEnabled,
        removeContainer: S.removeContainer,
        allowTaint: S.allowTaint,
        imageTimeout: S.imageTimeout / 2
      });
    }).then(function(F) {
      return M.image = F;
    });
  }
  function J(f) {
    this.src = f.value, this.colorStops = [], this.type = null, this.y1 = this.x1 = this.y0 = this.x0 = 0.5, this.promise = Promise.resolve(!0);
  }
  function G(f, I) {
    this.src = f, this.image = new Image();
    var S = this;
    this.tainted = null, this.promise = new Promise(function(M, N) {
      S.image.onload = M, S.image.onerror = N, I && (S.image.crossOrigin = "anonymous"), S.image.src = f, S.image.complete === !0 && M(S.image);
    });
  }
  function X(f, I) {
    this.link = null, this.options = f, this.support = I, this.origin = this.getOrigin(n.location.href);
  }
  function Z(f) {
    J.apply(this, arguments), this.type = this.TYPES.LINEAR;
    var I = f.args[0].match(this.stepRegExp) === null;
    I ? f.args[0].split(" ").reverse().forEach(function(S) {
      switch (S) {
        case "left":
          this.x0 = 0, this.x1 = 1;
          break;
        case "top":
          this.y0 = 0, this.y1 = 1;
          break;
        case "right":
          this.x0 = 1, this.x1 = 0;
          break;
        case "bottom":
          this.y0 = 1, this.y1 = 0;
          break;
        case "to":
          S = this.y0;
          var M = this.x0;
          this.y0 = this.y1, this.x0 = this.x1, this.x1 = M, this.y1 = S;
      }
    }, this) : (this.y0 = 0, this.y1 = 1), this.colorStops = f.args.slice(I ? 1 : 0).map(function(S) {
      return S = S.match(this.stepRegExp), { color: new Y(S[1]), stop: S[3] === "%" ? S[2] / 100 : null };
    }, this), this.colorStops[0].stop === null && (this.colorStops[0].stop = 0), this.colorStops[this.colorStops.length - 1].stop === null && (this.colorStops[this.colorStops.length - 1].stop = 1), this.colorStops.forEach(function(S, M) {
      S.stop === null && this.colorStops.slice(M).some(function(N, F) {
        return N.stop !== null ? (S.stop = (N.stop - this.colorStops[M - 1].stop) / (F + 1) + this.colorStops[M - 1].stop, !0) : !1;
      }, this);
    }, this);
  }
  function W() {
    n.html2canvas.logging && n.console && n.console.log && Function.prototype.bind.call(n.console.log, n.console).apply(
      n.console,
      [Date.now() - n.html2canvas.start + "ms", "html2canvas:"].concat(
        [].slice.call(arguments, 0)
      )
    );
  }
  function st(f, I) {
    this.node = f, this.parent = I, this.borders = this.bounds = this.stack = null, this.clip = [], this.backgroundClip = [], this.computedStyles = this.visible = this.offsetBounds = null, this.colors = {}, this.styles = {}, this.transformMatrix = this.transformData = this.backgroundImages = null, this.isPseudoElement = !1, this.opacity = null;
  }
  function j(f) {
    if (f && f[1] === "matrix")
      return f[2].split(",").map(function(I) {
        return parseFloat(I.trim());
      });
  }
  function gt(f) {
    return f.toString().indexOf("%") !== -1;
  }
  function U(f) {
    var I, S, M, N, F, q = [], ot = 0, pt = 0, Nt, ue, ri = function() {
      I && (S.substr(0, 1) === '"' && (S = S.substr(1, S.length - 2)), S && ue.push(S), I.substr(0, 1) === "-" && 0 < (N = I.indexOf("-", 1) + 1) && (M = I.substr(0, N), I = I.substr(N)), q.push({ prefix: M, method: I.toLowerCase(), value: F, args: ue, image: null })), ue = [], I = M = S = F = "";
    };
    return ue = [], I = M = S = F = "", f.split("").forEach(function(Te) {
      if (!(ot === 0 && -1 < ` \r
	`.indexOf(Te))) {
        switch (Te) {
          case '"':
            Nt ? Nt === Te && (Nt = null) : Nt = Te;
            break;
          case "(":
            if (!Nt) {
              if (ot === 0) {
                ot = 1, F += Te;
                return;
              }
              pt++;
            }
            break;
          case ")":
            if (!Nt && ot === 1) {
              if (pt === 0) {
                ot = 0, F += Te, ri();
                return;
              }
              pt--;
            }
            break;
          case ",":
            if (!Nt) {
              if (ot === 0) {
                ri();
                return;
              }
              if (ot === 1 && pt === 0 && !I.match(/^url$/i)) {
                ue.push(S), S = "", F += Te;
                return;
              }
            }
        }
        F += Te, ot === 0 ? I += Te : S += Te;
      }
    }), ri(), q;
  }
  function ht(f) {
    return f.replace("px", "");
  }
  function z(f) {
    return parseFloat(f);
  }
  function O(f) {
    if (f.getBoundingClientRect) {
      var I = f.getBoundingClientRect(), S = f.offsetWidth == null ? I.width : f.offsetWidth;
      return {
        top: I.top,
        bottom: I.bottom || I.top + I.height,
        right: I.left + S,
        left: I.left,
        width: S,
        height: f.offsetHeight == null ? I.height : f.offsetHeight
      };
    }
    return {};
  }
  function _t(f) {
    var I = f.offsetParent ? _t(f.offsetParent) : { top: 0, left: 0 };
    return {
      top: f.offsetTop + I.top,
      bottom: f.offsetTop + f.offsetHeight + I.top,
      right: f.offsetLeft + I.left + f.offsetWidth,
      left: f.offsetLeft + I.left,
      width: f.offsetWidth,
      height: f.offsetHeight
    };
  }
  function rt(f, I, S, M, N) {
    if (W("Starting NodeParser"), this.renderer = I, this.options = N, this.range = null, this.support = S, this.renderQueue = [], this.stack = new qi(!0, 1, f.ownerDocument, null), S = new st(f, null), N.background && I.rectangle(0, 0, I.width, I.height, new Y(N.background)), f === f.ownerDocument.documentElement) {
      var F = new st(
        S.color("backgroundColor").isTransparent() ? f.ownerDocument.body : f.ownerDocument.documentElement,
        null
      );
      I.rectangle(0, 0, I.width, I.height, F.color("backgroundColor"));
    }
    S.visibile = S.isElementVisible(), this.createPseudoHideStyles(f.ownerDocument), this.disableAnimations(f.ownerDocument), this.nodes = [].concat.apply(
      [],
      [S].concat(this.getChildren(S)).filter(function(q) {
        return q.visible = q.isElementVisible();
      }).map(this.getPseudoElements, this)
    ), this.fontMetrics = new R(), W("Fetched nodes, total:", this.nodes.length), W("Calculate overflow clips"), this.calculateOverflowClips(), W("Start fetching images"), this.images = M.fetch(this.nodes.filter(lt)), this.ready = this.images.ready.then(
      It(function() {
        return W("Images loaded, starting parsing"), W("Creating stacking contexts"), this.createStackingContexts(), W("Sorting stacking contexts"), this.sortStackingContexts(this.stack), this.parse(this.stack), W("Render queue created with " + this.renderQueue.length + " items"), new Promise(
          It(function(q) {
            N.async ? typeof N.async == "function" ? N.async.call(this, this.renderQueue, q) : 0 < this.renderQueue.length ? (this.renderIndex = 0, this.asyncRenderer(this.renderQueue, q)) : q() : (this.renderQueue.forEach(this.paint, this), q());
          }, this)
        );
      }, this)
    );
  }
  function ut(f) {
    return f.replace(/(\-[a-z])/g, function(I) {
      return I.toUpperCase().replace("-", "");
    });
  }
  function oe() {
  }
  function Le(f, I, S, M) {
    return f.map(function(N, F) {
      if (0 < N.width) {
        var q = I.left, ot = I.top, pt = I.width, Nt = I.height - f[2].width;
        switch (F) {
          case 0:
            Nt = f[0].width, N.args = ie(
              {
                c1: [q, ot],
                c2: [q + pt, ot],
                c3: [q + pt - f[1].width, ot + Nt],
                c4: [q + f[3].width, ot + Nt]
              },
              M[0],
              M[1],
              S.topLeftOuter,
              S.topLeftInner,
              S.topRightOuter,
              S.topRightInner
            );
            break;
          case 1:
            q = I.left + I.width - f[1].width, pt = f[1].width, N.args = ie(
              {
                c1: [q + pt, ot],
                c2: [q + pt, ot + Nt + f[2].width],
                c3: [q, ot + Nt],
                c4: [q, ot + f[0].width]
              },
              M[1],
              M[2],
              S.topRightOuter,
              S.topRightInner,
              S.bottomRightOuter,
              S.bottomRightInner
            );
            break;
          case 2:
            ot = ot + I.height - f[2].width, Nt = f[2].width, N.args = ie(
              {
                c1: [q + pt, ot + Nt],
                c2: [q, ot + Nt],
                c3: [q + f[3].width, ot],
                c4: [q + pt - f[3].width, ot]
              },
              M[2],
              M[3],
              S.bottomRightOuter,
              S.bottomRightInner,
              S.bottomLeftOuter,
              S.bottomLeftInner
            );
            break;
          case 3:
            pt = f[3].width, N.args = ie(
              {
                c1: [q, ot + Nt + f[2].width],
                c2: [q, ot],
                c3: [q + pt, ot + f[0].width],
                c4: [q + pt, ot + Nt]
              },
              M[3],
              M[0],
              S.bottomLeftOuter,
              S.bottomLeftInner,
              S.topLeftOuter,
              S.topLeftInner
            );
        }
      }
      return N;
    });
  }
  function Wt(f, I, S, M) {
    var F = (Math.sqrt(2) - 1) / 3 * 4, N = S * F, F = M * F;
    return S = f + S, M = I + M, {
      topLeft: ee({ x: f, y: M }, { x: f, y: M - F }, { x: S - N, y: I }, { x: S, y: I }),
      topRight: ee({ x: f, y: I }, { x: f + N, y: I }, { x: S, y: M - F }, { x: S, y: M }),
      bottomRight: ee({ x: S, y: I }, { x: S, y: I + F }, { x: f + N, y: M }, { x: f, y: M }),
      bottomLeft: ee({ x: S, y: M }, { x: S - N, y: M }, { x: f, y: I + F }, { x: f, y: I })
    };
  }
  function Dt(f, I, S) {
    var M = f.left, N = f.top, F = f.width;
    f = f.height;
    var q = I[0][0], ot = I[0][1], pt = I[1][0], Nt = I[1][1], ue = I[2][0], ri = I[2][1], Te = I[3][0];
    I = I[3][1];
    var Ae = F - pt, De = f - ri, es = F - ue, Is = f - I;
    return {
      topLeftOuter: Wt(M, N, q, ot).topLeft.subdivide(0.5),
      topLeftInner: Wt(
        M + S[3].width,
        N + S[0].width,
        Math.max(0, q - S[3].width),
        Math.max(0, ot - S[0].width)
      ).topLeft.subdivide(0.5),
      topRightOuter: Wt(M + Ae, N, pt, Nt).topRight.subdivide(0.5),
      topRightInner: Wt(
        M + Math.min(Ae, F + S[3].width),
        N + S[0].width,
        Ae > F + S[3].width ? 0 : pt - S[3].width,
        Nt - S[0].width
      ).topRight.subdivide(0.5),
      bottomRightOuter: Wt(M + es, N + De, ue, ri).bottomRight.subdivide(0.5),
      bottomRightInner: Wt(
        M + Math.min(es, F - S[3].width),
        N + Math.min(De, f + S[0].width),
        Math.max(0, ue - S[1].width),
        ri - S[2].width
      ).bottomRight.subdivide(0.5),
      bottomLeftOuter: Wt(M, N + Is, Te, I).bottomLeft.subdivide(0.5),
      bottomLeftInner: Wt(
        M + S[3].width,
        N + Is,
        Math.max(0, Te - S[3].width),
        I - S[2].width
      ).bottomLeft.subdivide(0.5)
    };
  }
  function ee(f, I, S, M) {
    var N = function(F, q, ot) {
      return { x: F.x + (q.x - F.x) * ot, y: F.y + (q.y - F.y) * ot };
    };
    return {
      start: f,
      startControl: I,
      endControl: S,
      end: M,
      subdivide: function(F) {
        var q = N(f, I, F), Nt = N(I, S, F), ot = N(S, M, F), pt = N(q, Nt, F), Nt = N(Nt, ot, F);
        return F = N(pt, Nt, F), [ee(f, q, pt, F), ee(F, Nt, ot, M)];
      },
      curveTo: function(F) {
        F.push(["bezierCurve", I.x, I.y, S.x, S.y, M.x, M.y]);
      },
      curveToReversed: function(F) {
        F.push(["bezierCurve", S.x, S.y, I.x, I.y, f.x, f.y]);
      }
    };
  }
  function ie(f, I, S, M, N, F, q) {
    var ot = [];
    return 0 < I[0] || 0 < I[1] ? (ot.push(["line", M[1].start.x, M[1].start.y]), M[1].curveTo(ot)) : ot.push(["line", f.c1[0], f.c1[1]]), 0 < S[0] || 0 < S[1] ? (ot.push(["line", F[0].start.x, F[0].start.y]), F[0].curveTo(ot), ot.push(["line", q[0].end.x, q[0].end.y]), q[0].curveToReversed(ot)) : (ot.push(["line", f.c2[0], f.c2[1]]), ot.push(["line", f.c3[0], f.c3[1]])), 0 < I[0] || 0 < I[1] ? (ot.push(["line", N[1].end.x, N[1].end.y]), N[1].curveToReversed(ot)) : ot.push(["line", f.c4[0], f.c4[1]]), ot;
  }
  function Ye(f, I, S, M, N, F, q) {
    0 < I[0] || 0 < I[1] ? (f.push(["line", M[0].start.x, M[0].start.y]), M[0].curveTo(f), M[1].curveTo(f)) : f.push(["line", F, q]), (0 < S[0] || 0 < S[1]) && f.push(["line", N[0].start.x, N[0].start.y]);
  }
  function bi(f) {
    return 0 > f.cssInt("zIndex");
  }
  function x(f) {
    return 0 < f.cssInt("zIndex");
  }
  function $(f) {
    return f.cssInt("zIndex") === 0;
  }
  function H(f) {
    return ["inline", "inline-block", "inline-table"].indexOf(f.css("display")) !== -1;
  }
  function T(f) {
    return 0 < f.node.data.trim().length;
  }
  function V(f) {
    return ["TopLeft", "TopRight", "BottomRight", "BottomLeft"].map(function(I) {
      return I = f.css("border" + I + "Radius").split(" "), 1 >= I.length && (I[1] = I[0]), I.map(jt);
    });
  }
  function K(f) {
    return f.nodeType === Node.TEXT_NODE || f.nodeType === Node.ELEMENT_NODE;
  }
  function tt(f) {
    return f.css("position") !== "static";
  }
  function nt(f) {
    return f.css("float") !== "none";
  }
  function A(f) {
    var I = this;
    return function() {
      return !f.apply(I, arguments);
    };
  }
  function lt(f) {
    return f.node.nodeType === Node.ELEMENT_NODE;
  }
  function dt(f) {
    return f.node.nodeType === Node.TEXT_NODE;
  }
  function ct(f) {
    return function(I, S) {
      return I.cssInt("zIndex") + f.indexOf(I) / f.length - (S.cssInt("zIndex") + f.indexOf(S) / f.length);
    };
  }
  function It(f, I) {
    return function() {
      return f.apply(I, arguments);
    };
  }
  function jt(f) {
    return parseInt(f, 10);
  }
  function Ft(f) {
    return f.width;
  }
  function si(f) {
    return f.node.nodeType !== Node.ELEMENT_NODE || "SCRIPT HEAD TITLE OBJECT BR OPTION".split(" ").indexOf(f.node.nodeName) === -1;
  }
  function cn(f) {
    for (var I = [], S = 0, M = !1, N; f.length; )
      [32, 13, 10, 9, 45].indexOf(f[S]) !== -1 === M ? (N = f.splice(0, S), N.length && I.push(n.html2canvas.punycode.ucs2.encode(N)), M = !M, S = 0) : S++, S >= f.length && (N = f.splice(0, S), N.length && I.push(n.html2canvas.punycode.ucs2.encode(N)));
    return I;
  }
  function Ii(f, I, S) {
    if (!I)
      return Promise.reject("No proxy configured");
    var M = En(Qh);
    return f = Rn(I, f, M), Qh ? Hh(f) : pe(S, f, M).then(function(N) {
      return Ve(N.content);
    });
  }
  function hn(f, I, S) {
    var M = En(qh);
    return f = Rn(I, f, M), qh ? Promise.resolve(f) : pe(S, f, M).then(function(N) {
      return "data:" + N.type + ";base64," + N.content;
    });
  }
  function pe(f, I, S) {
    return new Promise(function(M, N) {
      var F = f.createElement("script"), q = function() {
        delete n.html2canvas.proxy[S], f.body.removeChild(F);
      };
      n.html2canvas.proxy[S] = function(ot) {
        q(), M(ot);
      }, F.src = I, F.onerror = function(ot) {
        q(), N(ot);
      }, f.body.appendChild(F);
    });
  }
  function En(f) {
    var I = new Uint32Array(1);
    return (window.crypto || window.msCrypto).getRandomValues(I), f ? "" : "html2canvas_" + Date.now() + "_" + ++jp + "_" + Math.round(1e5 * (I[0] / 4294967295));
  }
  function Rn(f, I, S) {
    return f + "?url=" + encodeURIComponent(I) + (S.length ? "&callback=html2canvas.proxy." + S : "");
  }
  function Gi(f, I) {
    t.createElement("script");
    var S = t.createElement("a");
    S.href = f, this.src = f = S.href, this.image = new Image();
    var M = this;
    this.promise = new Promise(function(N, F) {
      M.image.crossOrigin = "Anonymous", M.image.onload = N, M.image.onerror = F, new hn(f, I, t).then(function(q) {
        M.image.src = q;
      }).catch(F);
    });
  }
  function He(f, I, S) {
    st.call(this, f, I), this.isPseudoElement = !0, this.before = S === ":before";
  }
  function Yi(f, I, S, M, N) {
    this.width = f, this.height = I, this.images = S, this.options = M, this.document = N;
  }
  function qi(f, I, S, M) {
    st.call(this, S, M), this.ownStacking = f, this.contexts = [], this.children = [], this.opacity = (this.parent ? this.parent.stack.opacity : 1) * I;
  }
  function wn(f) {
    this.rangeBounds = this.testRangeBounds(f), this.cors = this.testCORS(), this.svg = this.testSVG();
  }
  function Zi(f) {
    this.src = f, this.image = null;
    var I = this;
    this.promise = this.hasFabric().then(function() {
      return I.isInline(f) ? Promise.resolve(I.inlineFormatting(f)) : Hh(f);
    }).then(function(S) {
      return new Promise(function(M) {
        html2canvas.fabric.loadSVGFromString(S, I.createCanvas.call(I, M));
      });
    });
  }
  function Ve(f) {
    var I = f.length, S, M, N, F, q, ot, pt = "";
    for (S = 0; S < I; S += 4)
      M = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(f[S]), N = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(f[S + 1]), F = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(f[S + 2]), q = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(f[S + 3]), M = M << 2 | N >> 4, N = (N & 15) << 4 | F >> 2, ot = (F & 3) << 6 | q, pt = F === 64 ? pt + String.fromCharCode(M) : q === 64 || q === -1 ? pt + String.fromCharCode(M, N) : pt + String.fromCharCode(M, N, ot);
    return pt;
  }
  function zs(f, I) {
    this.src = f, this.image = null;
    var S = this;
    this.promise = I ? new Promise(function(M, N) {
      S.image = new Image(), S.image.onload = M, S.image.onerror = N, S.image.src = "data:image/svg+xml," + new XMLSerializer().serializeToString(f), S.image.complete === !0 && M(S.image);
    }) : this.hasFabric().then(function() {
      return new Promise(function(M) {
        html2canvas.fabric.parseSVGDocument(f, S.createCanvas.call(S, M));
      });
    });
  }
  function wr(f, I) {
    st.call(this, f, I);
  }
  function Xp(f, I, S) {
    if (0 < f.length)
      return I + S.toUpperCase();
  }
  function jh(f) {
    J.apply(this, arguments), this.type = f.args[0] === "linear" ? this.TYPES.LINEAR : this.TYPES.RADIAL;
  }
  function Hh(f) {
    return new Promise(function(I, S) {
      var M = new XMLHttpRequest();
      M.open("GET", f), M.onload = function() {
        M.status === 200 ? I(M.responseText) : S(Error(M.statusText));
      }, M.onerror = function() {
        S(Error("Network Error"));
      }, M.send();
    });
  }
  function Xe(f, I) {
    Yi.apply(this, arguments), this.canvas = this.options.canvas || this.document.createElement("canvas"), this.options.canvas || (this.canvas.width = f, this.canvas.height = I), this.ctx = this.canvas.getContext("2d"), this.taintCtx = this.document.createElement("canvas").getContext("2d"), this.ctx.textBaseline = "bottom", this.variables = {}, W("Initialized CanvasRenderer with size", f, "x", I);
  }
  function Fp(f) {
    return 0 < f.length;
  }
  if (function() {
    function f(B, mt) {
      Ue[Lt] = B, Ue[Lt + 1] = mt, Lt += 2, Lt === 2 && Qe();
    }
    function I(B) {
      return typeof B == "function";
    }
    function S() {
      return function() {
        process.nextTick(q);
      };
    }
    function M() {
      var B = 0, mt = new qt(q), yt = t.createTextNode("");
      return mt.observe(yt, { characterData: !0 }), function() {
        yt.data = B = ++B % 2;
      };
    }
    function N() {
      var B = new MessageChannel();
      return B.port1.onmessage = q, function() {
        B.port2.postMessage(0);
      };
    }
    function F() {
      return function() {
        setTimeout(q, 1);
      };
    }
    function q() {
      for (var B = 0; B < Lt; B += 2)
        (0, Ue[B])(Ue[B + 1]), Ue[B] = void 0, Ue[B + 1] = void 0;
      Lt = 0;
    }
    function ot() {
    }
    function pt(B, mt, yt, Tt) {
      try {
        B.call(mt, yt, Tt);
      } catch (ae) {
        return ae;
      }
    }
    function Nt(B, mt, yt) {
      f(function(Tt) {
        var ae = !1, Ze = pt(
          yt,
          mt,
          function(wi) {
            ae || (ae = !0, mt !== wi ? ri(Tt, wi) : Ae(Tt, wi));
          },
          function(wi) {
            ae || (ae = !0, De(Tt, wi));
          }
        );
        !ae && Ze && (ae = !0, De(Tt, Ze));
      }, B);
    }
    function ue(B, mt) {
      mt.a === 1 ? Ae(B, mt.b) : B.a === 2 ? De(B, mt.b) : es(
        mt,
        void 0,
        function(yt) {
          ri(B, yt);
        },
        function(yt) {
          De(B, yt);
        }
      );
    }
    function ri(B, mt) {
      if (B === mt)
        De(B, new TypeError("You cannot resolve a promise with itself"));
      else if (typeof mt == "function" || typeof mt == "object" && mt !== null)
        if (mt.constructor === B.constructor)
          ue(B, mt);
        else {
          var yt;
          try {
            yt = mt.then;
          } catch (Tt) {
            ge.error = Tt, yt = ge;
          }
          yt === ge ? De(B, ge.error) : yt === void 0 ? Ae(B, mt) : I(yt) ? Nt(B, mt, yt) : Ae(B, mt);
        }
      else
        Ae(B, mt);
    }
    function Te(B) {
      B.f && B.f(B.b), Is(B);
    }
    function Ae(B, mt) {
      B.a === void 0 && (B.b = mt, B.a = 1, B.e.length !== 0 && f(Is, B));
    }
    function De(B, mt) {
      B.a === void 0 && (B.a = 2, B.b = mt, f(Te, B));
    }
    function es(B, mt, yt, Tt) {
      var ae = B.e, Ze = ae.length;
      B.f = null, ae[Ze] = mt, ae[Ze + 1] = yt, ae[Ze + 2] = Tt, Ze === 0 && B.a && f(Is, B);
    }
    function Is(B) {
      var mt = B.e, yt = B.a;
      if (mt.length !== 0) {
        for (var Tt, ae, Ze = B.b, wi = 0; wi < mt.length; wi += 3)
          Tt = mt[wi], ae = mt[wi + yt], Tt ? $i(yt, Tt, ae, Ze) : ae(Ze);
        B.e.length = 0;
      }
    }
    function Na() {
      this.error = null;
    }
    function $i(B, mt, yt, Tt) {
      var ae = I(yt), Ze, wi, Js, $h;
      if (ae) {
        try {
          Ze = yt(Tt);
        } catch (Hp) {
          ze.error = Hp, Ze = ze;
        }
        if (Ze === ze ? ($h = !0, wi = Ze.error, Ze = null) : Js = !0, mt === Ze) {
          De(mt, new TypeError("A promises callback cannot return that same promise."));
          return;
        }
      } else
        Ze = Tt, Js = !0;
      mt.a === void 0 && (ae && Js ? ri(mt, Ze) : $h ? De(mt, wi) : B === 1 ? Ae(mt, Ze) : B === 2 && De(mt, Ze));
    }
    function Bs(B, mt) {
      try {
        mt(
          function(yt) {
            ri(B, yt);
          },
          function(yt) {
            De(B, yt);
          }
        );
      } catch (yt) {
        De(B, yt);
      }
    }
    function Fi(B, mt, yt, Tt) {
      this.n = B, this.c = new B(ot, Tt), this.i = yt, this.o(mt) ? (this.m = mt, this.d = this.length = mt.length, this.l(), this.length === 0 ? Ae(this.c, this.b) : (this.length = this.length || 0, this.k(), this.d === 0 && Ae(this.c, this.b))) : De(this.c, this.p());
    }
    function xt(B) {
      if (this.b = this.a = void 0, this.e = [], ot !== B) {
        if (!I(B))
          throw new TypeError(
            "You must pass a resolver function as the first argument to the promise constructor"
          );
        if (!(this instanceof xt))
          throw new TypeError(
            "Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function."
          );
        Bs(this, B);
      }
    }
    var Gt = Array.isArray ? Array.isArray : function(B) {
      return Object.prototype.toString.call(B) === "[object Array]";
    }, Lt = 0, Ee = typeof n < "u" ? n : {}, qt = Ee.MutationObserver || Ee.WebKitMutationObserver, Ee = typeof Uint8ClampedArray < "u" && typeof importScripts < "u" && typeof MessageChannel < "u", Ue = Array(1e3), Qe;
    Qe = typeof process < "u" && {}.toString.call(process) === "[object process]" ? S() : qt ? M() : Ee ? N() : F();
    var ge = new Na(), ze = new Na();
    Fi.prototype.o = function(B) {
      return Gt(B);
    }, Fi.prototype.p = function() {
      return Error("Array Methods must be provided an Array");
    }, Fi.prototype.l = function() {
      this.b = Array(this.length);
    }, Fi.prototype.k = function() {
      for (var B = this.length, mt = this.c, yt = this.m, Tt = 0; mt.a === void 0 && Tt < B; Tt++)
        this.j(yt[Tt], Tt);
    }, Fi.prototype.j = function(B, mt) {
      var yt = this.n;
      typeof B == "object" && B !== null ? B.constructor === yt && B.a !== void 0 ? (B.f = null, this.g(B.a, mt, B.b)) : this.q(yt.resolve(B), mt) : (this.d--, this.b[mt] = this.h(B));
    }, Fi.prototype.g = function(B, mt, yt) {
      var Tt = this.c;
      Tt.a === void 0 && (this.d--, this.i && B === 2 ? De(Tt, yt) : this.b[mt] = this.h(yt)), this.d === 0 && Ae(Tt, this.b);
    }, Fi.prototype.h = function(B) {
      return B;
    }, Fi.prototype.q = function(B, mt) {
      var yt = this;
      es(
        B,
        void 0,
        function(Tt) {
          yt.g(1, mt, Tt);
        },
        function(Tt) {
          yt.g(2, mt, Tt);
        }
      );
    }, xt.all = function(B, mt) {
      return new Fi(this, B, !0, mt).c;
    }, xt.race = function(B, mt) {
      function yt(Js) {
        ri(ae, Js);
      }
      function Tt(Js) {
        De(ae, Js);
      }
      var ae = new this(ot, mt);
      if (!Gt(B))
        return De(ae, new TypeError("You must pass an array to race.")), ae;
      for (var Ze = B.length, wi = 0; ae.a === void 0 && wi < Ze; wi++)
        es(this.resolve(B[wi]), void 0, yt, Tt);
      return ae;
    }, xt.resolve = function(B, mt) {
      if (B && typeof B == "object" && B.constructor === this)
        return B;
      var yt = new this(ot, mt);
      return ri(yt, B), yt;
    }, xt.reject = function(B, mt) {
      var yt = new this(ot, mt);
      return De(yt, B), yt;
    }, xt.prototype = {
      constructor: xt,
      then: function(B, mt) {
        var yt = this.a;
        if (yt === 1 && !B || yt === 2 && !mt)
          return this;
        var Tt = new this.constructor(ot), ae = this.b;
        if (yt) {
          var Ze = arguments[yt - 1];
          f(function() {
            $i(yt, Tt, Ze, ae);
          });
        } else
          es(this, Tt, B, mt);
        return Tt;
      },
      catch: function(B) {
        return this.then(null, B);
      }
    };
    var xe = {
      Promise: xt,
      polyfill: function() {
        var B;
        B = typeof i < "u" ? i : typeof n < "u" && n.document ? n : self, "Promise" in B && "resolve" in B.Promise && "reject" in B.Promise && "all" in B.Promise && "race" in B.Promise && function() {
          var mt;
          return new B.Promise(function(yt) {
            mt = yt;
          }), I(mt);
        }() || (B.Promise = xt);
      }
    };
    typeof s == "function" && s.amd ? s(function() {
      return xe;
    }) : typeof module < "u" && module.exports ? module.exports = xe : typeof this < "u" && (this.ES6Promise = xe);
  }.call(n), n && n.ES6Promise && n.ES6Promise.polyfill(), typeof t > "u" || typeof Object.create != "function" || typeof t.createElement("canvas").getContext != "function")
    (n || module.exports).html2canvas = function() {
      return Promise.reject("No canvas support");
    };
  else {
    (function(f) {
      function I(xt) {
        throw RangeError(Na[xt]);
      }
      function S(xt, Gt) {
        for (var Lt = xt.length, qt = []; Lt--; )
          qt[Lt] = Gt(xt[Lt]);
        return qt;
      }
      function M(xt, Gt) {
        var Lt = xt.split("@"), qt = "";
        return 1 < Lt.length && (qt = Lt[0] + "@", xt = Lt[1]), Lt = xt.split(Is), Lt = S(Lt, Gt).join("."), qt + Lt;
      }
      function N(xt) {
        for (var Gt = [], Lt = 0, qt = xt.length, Ee, Ue; Lt < qt; )
          Ee = xt.charCodeAt(Lt++), 55296 <= Ee && 56319 >= Ee && Lt < qt ? (Ue = xt.charCodeAt(Lt++), (Ue & 64512) == 56320 ? Gt.push(((Ee & 1023) << 10) + (Ue & 1023) + 65536) : (Gt.push(Ee), Lt--)) : Gt.push(Ee);
        return Gt;
      }
      function F(xt) {
        return S(xt, function(Gt) {
          var Lt = "";
          return 65535 < Gt && (Gt -= 65536, Lt += Bs(Gt >>> 10 & 1023 | 55296), Gt = 56320 | Gt & 1023), Lt += Bs(Gt);
        }).join("");
      }
      function q(xt, Gt) {
        return xt + 22 + 75 * (26 > xt) - ((Gt != 0) << 5);
      }
      function ot(xt, Gt, Lt) {
        var qt = 0;
        for (xt = Lt ? $i(xt / 700) : xt >> 1, xt += $i(xt / Gt); 455 < xt; qt += 36)
          xt = $i(xt / 35);
        return $i(qt + 36 * xt / (xt + 38));
      }
      function pt(xt) {
        var Gt = [], Lt = xt.length, qt, Ee = 0, Ue = 128, Qe = 72, ge, ze, xe, B, mt;
        for (ge = xt.lastIndexOf("-"), 0 > ge && (ge = 0), ze = 0; ze < ge; ++ze)
          128 <= xt.charCodeAt(ze) && I("not-basic"), Gt.push(xt.charCodeAt(ze));
        for (ge = 0 < ge ? ge + 1 : 0; ge < Lt; ) {
          for (ze = Ee, qt = 1, xe = 36; ge >= Lt && I("invalid-input"), B = xt.charCodeAt(ge++), B = 10 > B - 48 ? B - 22 : 26 > B - 65 ? B - 65 : 26 > B - 97 ? B - 97 : 36, (36 <= B || B > $i((2147483647 - Ee) / qt)) && I("overflow"), Ee += B * qt, mt = xe <= Qe ? 1 : xe >= Qe + 26 ? 26 : xe - Qe, !(B < mt); xe += 36)
            B = 36 - mt, qt > $i(2147483647 / B) && I("overflow"), qt *= B;
          qt = Gt.length + 1, Qe = ot(Ee - ze, qt, ze == 0), $i(Ee / qt) > 2147483647 - Ue && I("overflow"), Ue += $i(Ee / qt), Ee %= qt, Gt.splice(Ee++, 0, Ue);
        }
        return F(Gt);
      }
      function Nt(xt) {
        var Gt, Lt, qt, Ee, Ue, Qe, ge, ze, xe, B = [], mt, yt, Tt;
        for (xt = N(xt), mt = xt.length, Gt = 128, Lt = 0, Ue = 72, Qe = 0; Qe < mt; ++Qe)
          xe = xt[Qe], 128 > xe && B.push(Bs(xe));
        for ((qt = Ee = B.length) && B.push("-"); qt < mt; ) {
          for (ge = 2147483647, Qe = 0; Qe < mt; ++Qe)
            xe = xt[Qe], xe >= Gt && xe < ge && (ge = xe);
          for (yt = qt + 1, ge - Gt > $i((2147483647 - Lt) / yt) && I("overflow"), Lt += (ge - Gt) * yt, Gt = ge, Qe = 0; Qe < mt; ++Qe)
            if (xe = xt[Qe], xe < Gt && 2147483647 < ++Lt && I("overflow"), xe == Gt) {
              for (ze = Lt, ge = 36; xe = ge <= Ue ? 1 : ge >= Ue + 26 ? 26 : ge - Ue, !(ze < xe); ge += 36)
                Tt = ze - xe, ze = 36 - xe, B.push(Bs(q(xe + Tt % ze, 0))), ze = $i(Tt / ze);
              B.push(Bs(q(ze, 0))), Ue = ot(Lt, yt, qt == Ee), Lt = 0, ++qt;
            }
          ++Lt, ++Gt;
        }
        return B.join("");
      }
      var ue = typeof e == "object" && e && !e.nodeType && e, ri = typeof module == "object" && module && !module.nodeType && module, Te = typeof i == "object" && i;
      (Te.global === Te || Te.window === Te || Te.self === Te) && (f = Te);
      var Ae, De = /^xn--/, es = /[^\x20-\x7E]/, Is = /[\x2E\u3002\uFF0E\uFF61]/g, Na = {
        overflow: "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      }, $i = Math.floor, Bs = String.fromCharCode, Fi;
      if (Ae = {
        version: "1.3.1",
        ucs2: { decode: N, encode: F },
        decode: pt,
        encode: Nt,
        toASCII: function(xt) {
          return M(xt, function(Gt) {
            return es.test(Gt) ? "xn--" + Nt(Gt) : Gt;
          });
        },
        toUnicode: function(xt) {
          return M(xt, function(Gt) {
            return De.test(Gt) ? pt(Gt.slice(4).toLowerCase()) : Gt;
          });
        }
      }, typeof s == "function" && typeof s.amd == "object" && s.amd)
        s("punycode", function() {
          return Ae;
        });
      else if (ue && ri)
        if (module.exports == ue)
          ri.exports = Ae;
        else
          for (Fi in Ae)
            Ae.hasOwnProperty(Fi) && (ue[Fi] = Ae[Fi]);
      else
        f.punycode = Ae;
    })(this);
    var Kp = 0, Op = 0;
    n.html2canvas = function(f, I) {
      var S = Op++;
      if (I = I || {}, I.logging && (n.html2canvas.logging = !0, n.html2canvas.start = Date.now()), I.async = typeof I.async > "u" ? !0 : I.async, I.allowTaint = typeof I.allowTaint > "u" ? !1 : I.allowTaint, I.removeContainer = typeof I.removeContainer > "u" ? !0 : I.removeContainer, I.javascriptEnabled = typeof I.javascriptEnabled > "u" ? !1 : I.javascriptEnabled, I.imageTimeout = typeof I.imageTimeout > "u" ? 1e4 : I.imageTimeout, I.renderer = typeof I.renderer == "function" ? I.renderer : Xe, I.strict = !!I.strict, typeof f == "string") {
        if (typeof I.proxy != "string")
          return Promise.reject("Proxy must be used when rendering url");
        var M = I.width != null ? I.width : n.innerWidth, N = I.height != null ? I.height : n.innerHeight;
        return _(k(f), I.proxy, t, M, N, I).then(function(q) {
          return a(q.contentWindow.document.documentElement, q, I, M, N);
        });
      }
      var F = (f === r ? [t.documentElement] : f.length ? f : [f])[0];
      return F.setAttribute("data-html2canvas-node" + S, S), o(
        F.ownerDocument,
        I,
        F.ownerDocument.defaultView.innerWidth,
        F.ownerDocument.defaultView.innerHeight,
        S
      ).then(function(q) {
        return typeof I.onrendered == "function" && (W(
          "options.onrendered is deprecated, html2canvas returns a Promise containing the canvas"
        ), I.onrendered(q)), q;
      });
    }, n.html2canvas.punycode = this.punycode, n.html2canvas.proxy = {}, Y.prototype.darken = function(f) {
      return f = 1 - f, new Y([
        Math.round(this.r * f),
        Math.round(this.g * f),
        Math.round(this.b * f),
        this.a
      ]);
    }, Y.prototype.isTransparent = function() {
      return this.a === 0;
    }, Y.prototype.isBlack = function() {
      return this.r === 0 && this.g === 0 && this.b === 0;
    }, Y.prototype.fromArray = function(f) {
      return Array.isArray(f) && (this.r = Math.min(f[0], 255), this.g = Math.min(f[1], 255), this.b = Math.min(f[2], 255), 3 < f.length && (this.a = f[3])), Array.isArray(f);
    };
    var Ap = /^#([a-f0-9]{3})$/i;
    Y.prototype.hex3 = function(f) {
      return (f = f.match(Ap)) !== null && (this.r = parseInt(f[1][0] + f[1][0], 16), this.g = parseInt(f[1][1] + f[1][1], 16), this.b = parseInt(f[1][2] + f[1][2], 16)), f !== null;
    };
    var Dp = /^#([a-f0-9]{6})$/i;
    Y.prototype.hex6 = function(f) {
      return (f = f.match(Dp)) !== null && (this.r = parseInt(f[1].substring(0, 2), 16), this.g = parseInt(f[1].substring(2, 4), 16), this.b = parseInt(f[1].substring(4, 6), 16)), f !== null;
    };
    var zp = /^rgb\((\d{1,3}) *, *(\d{1,3}) *, *(\d{1,3})\)$/;
    Y.prototype.rgb = function(f) {
      return (f = f.match(zp)) !== null && (this.r = Number(f[1]), this.g = Number(f[2]), this.b = Number(f[3])), f !== null;
    };
    var Bp = /^rgba\((\d{1,3}) *, *(\d{1,3}) *, *(\d{1,3}) *, *(\d+\.?\d*)\)$/;
    Y.prototype.rgba = function(f) {
      return (f = f.match(Bp)) !== null && (this.r = Number(f[1]), this.g = Number(f[2]), this.b = Number(f[3]), this.a = Number(f[4])), f !== null;
    }, Y.prototype.toString = function() {
      return this.a !== null && this.a !== 1 ? "rgba(" + [this.r, this.g, this.b, this.a].join() + ")" : "rgb(" + [this.r, this.g, this.b].join() + ")";
    }, Y.prototype.namedColor = function(f) {
      var I = Jp[f.toLowerCase()];
      if (I)
        this.r = I[0], this.g = I[1], this.b = I[2];
      else if (f.toLowerCase() === "transparent")
        return this.r = this.g = this.b = this.a = 0, !0;
      return !!I;
    }, Y.prototype.isColor = !0;
    var Jp = {
      aliceblue: [240, 248, 255],
      antiquewhite: [250, 235, 215],
      aqua: [0, 255, 255],
      aquamarine: [127, 255, 212],
      azure: [240, 255, 255],
      beige: [245, 245, 220],
      bisque: [255, 228, 196],
      black: [0, 0, 0],
      blanchedalmond: [255, 235, 205],
      blue: [0, 0, 255],
      blueviolet: [138, 43, 226],
      brown: [165, 42, 42],
      burlywood: [222, 184, 135],
      cadetblue: [95, 158, 160],
      chartreuse: [127, 255, 0],
      chocolate: [210, 105, 30],
      coral: [255, 127, 80],
      cornflowerblue: [100, 149, 237],
      cornsilk: [255, 248, 220],
      crimson: [220, 20, 60],
      cyan: [0, 255, 255],
      darkblue: [0, 0, 139],
      darkcyan: [0, 139, 139],
      darkgoldenrod: [184, 134, 11],
      darkgray: [169, 169, 169],
      darkgreen: [0, 100, 0],
      darkgrey: [169, 169, 169],
      darkkhaki: [189, 183, 107],
      darkmagenta: [139, 0, 139],
      darkolivegreen: [85, 107, 47],
      darkorange: [255, 140, 0],
      darkorchid: [153, 50, 204],
      darkred: [139, 0, 0],
      darksalmon: [233, 150, 122],
      darkseagreen: [143, 188, 143],
      darkslateblue: [72, 61, 139],
      darkslategray: [47, 79, 79],
      darkslategrey: [47, 79, 79],
      darkturquoise: [0, 206, 209],
      darkviolet: [148, 0, 211],
      deeppink: [255, 20, 147],
      deepskyblue: [0, 191, 255],
      dimgray: [105, 105, 105],
      dimgrey: [105, 105, 105],
      dodgerblue: [30, 144, 255],
      firebrick: [178, 34, 34],
      floralwhite: [255, 250, 240],
      forestgreen: [34, 139, 34],
      fuchsia: [255, 0, 255],
      gainsboro: [220, 220, 220],
      ghostwhite: [248, 248, 255],
      gold: [255, 215, 0],
      goldenrod: [218, 165, 32],
      gray: [128, 128, 128],
      green: [0, 128, 0],
      greenyellow: [173, 255, 47],
      grey: [128, 128, 128],
      honeydew: [240, 255, 240],
      hotpink: [255, 105, 180],
      indianred: [205, 92, 92],
      indigo: [75, 0, 130],
      ivory: [255, 255, 240],
      khaki: [240, 230, 140],
      lavender: [230, 230, 250],
      lavenderblush: [255, 240, 245],
      lawngreen: [124, 252, 0],
      lemonchiffon: [255, 250, 205],
      lightblue: [173, 216, 230],
      lightcoral: [240, 128, 128],
      lightcyan: [224, 255, 255],
      lightgoldenrodyellow: [250, 250, 210],
      lightgray: [211, 211, 211],
      lightgreen: [144, 238, 144],
      lightgrey: [211, 211, 211],
      lightpink: [255, 182, 193],
      lightsalmon: [255, 160, 122],
      lightseagreen: [32, 178, 170],
      lightskyblue: [135, 206, 250],
      lightslategray: [119, 136, 153],
      lightslategrey: [119, 136, 153],
      lightsteelblue: [176, 196, 222],
      lightyellow: [255, 255, 224],
      lime: [0, 255, 0],
      limegreen: [50, 205, 50],
      linen: [250, 240, 230],
      magenta: [255, 0, 255],
      maroon: [128, 0, 0],
      mediumaquamarine: [102, 205, 170],
      mediumblue: [0, 0, 205],
      mediumorchid: [186, 85, 211],
      mediumpurple: [147, 112, 219],
      mediumseagreen: [60, 179, 113],
      mediumslateblue: [123, 104, 238],
      mediumspringgreen: [0, 250, 154],
      mediumturquoise: [72, 209, 204],
      mediumvioletred: [199, 21, 133],
      midnightblue: [25, 25, 112],
      mintcream: [245, 255, 250],
      mistyrose: [255, 228, 225],
      moccasin: [255, 228, 181],
      navajowhite: [255, 222, 173],
      navy: [0, 0, 128],
      oldlace: [253, 245, 230],
      olive: [128, 128, 0],
      olivedrab: [107, 142, 35],
      orange: [255, 165, 0],
      orangered: [255, 69, 0],
      orchid: [218, 112, 214],
      palegoldenrod: [238, 232, 170],
      palegreen: [152, 251, 152],
      paleturquoise: [175, 238, 238],
      palevioletred: [219, 112, 147],
      papayawhip: [255, 239, 213],
      peachpuff: [255, 218, 185],
      peru: [205, 133, 63],
      pink: [255, 192, 203],
      plum: [221, 160, 221],
      powderblue: [176, 224, 230],
      purple: [128, 0, 128],
      rebeccapurple: [102, 51, 153],
      red: [255, 0, 0],
      rosybrown: [188, 143, 143],
      royalblue: [65, 105, 225],
      saddlebrown: [139, 69, 19],
      salmon: [250, 128, 114],
      sandybrown: [244, 164, 96],
      seagreen: [46, 139, 87],
      seashell: [255, 245, 238],
      sienna: [160, 82, 45],
      silver: [192, 192, 192],
      skyblue: [135, 206, 235],
      slateblue: [106, 90, 205],
      slategray: [112, 128, 144],
      slategrey: [112, 128, 144],
      snow: [255, 250, 250],
      springgreen: [0, 255, 127],
      steelblue: [70, 130, 180],
      tan: [210, 180, 140],
      teal: [0, 128, 128],
      thistle: [216, 191, 216],
      tomato: [255, 99, 71],
      turquoise: [64, 224, 208],
      violet: [238, 130, 238],
      wheat: [245, 222, 179],
      white: [255, 255, 255],
      whitesmoke: [245, 245, 245],
      yellow: [255, 255, 0],
      yellowgreen: [154, 205, 50]
    };
    R.prototype.getMetrics = function(f, I) {
      return this.data[f + "-" + I] === r && (this.data[f + "-" + I] = new L(f, I)), this.data[f + "-" + I];
    }, D.prototype.proxyLoad = function(f, I, S) {
      var M = this.src;
      return _(M.src, f, M.ownerDocument, I.width, I.height, S);
    }, J.prototype.TYPES = { LINEAR: 1, RADIAL: 2 }, X.prototype.findImages = function(f) {
      var I = [];
      return f.reduce(function(S, M) {
        switch (M.node.nodeName) {
          case "IMG":
            return S.concat([{ args: [M.node.src], method: "url" }]);
          case "svg":
          case "IFRAME":
            return S.concat([{ args: [M.node], method: M.node.nodeName }]);
        }
        return S;
      }, []).forEach(this.addImage(I, this.loadImage), this), I;
    }, X.prototype.findBackgroundImage = function(f, I) {
      return I.parseBackgroundImages().filter(this.hasImageBackground).forEach(this.addImage(f, this.loadImage), this), f;
    }, X.prototype.addImage = function(f, I) {
      return function(S) {
        S.args.forEach(function(M) {
          this.imageExists(f, M) || (f.splice(0, 0, I.call(this, S)), W("Added image #" + f.length, typeof M == "string" ? M.substring(0, 100) : M));
        }, this);
      };
    }, X.prototype.hasImageBackground = function(f) {
      return f.method !== "none";
    }, X.prototype.loadImage = function(f) {
      return f.method === "url" ? (f = f.args[0], !this.isSVG(f) || this.support.svg || this.options.allowTaint ? f.match(/data:image\/.*;base64,/i) ? new G(f.replace(/url\(['"]{0,}|['"]{0,}\)$/gi, ""), !1) : this.isSameOrigin(f) || this.options.allowTaint === !0 || this.isSVG(f) ? new G(f, !1) : this.support.cors && !this.options.allowTaint && this.options.useCORS ? new G(f, !0) : this.options.proxy ? new Gi(f, this.options.proxy) : new P(f) : new Zi(f)) : f.method === "linear-gradient" ? new Z(f) : f.method === "gradient" ? new jh(f) : f.method === "svg" ? new zs(f.args[0], this.support.svg) : f.method === "IFRAME" ? new D(f.args[0], this.isSameOrigin(f.args[0].src), this.options) : new P(f);
    }, X.prototype.isSVG = function(f) {
      return f.substring(f.length - 3).toLowerCase() === "svg" || Zi.prototype.isInline(f);
    }, X.prototype.imageExists = function(f, I) {
      return f.some(function(S) {
        return S.src === I;
      });
    }, X.prototype.isSameOrigin = function(f) {
      return this.getOrigin(f) === this.origin;
    }, X.prototype.getOrigin = function(f) {
      var I = this.link || (this.link = t.createElement("a"));
      return I.href = f, I.href = I.href, I.protocol + I.hostname + I.port;
    }, X.prototype.getPromise = function(f) {
      return this.timeout(f, this.options.imageTimeout).catch(function() {
        return new P(f.src).promise.then(function(I) {
          f.image = I;
        });
      });
    }, X.prototype.get = function(f) {
      var I = null;
      return this.images.some(function(S) {
        return (I = S).src === f;
      }) ? I : null;
    }, X.prototype.fetch = function(f) {
      return this.images = f.reduce(It(this.findBackgroundImage, this), this.findImages(f)), this.images.forEach(function(I, S) {
        I.promise.then(
          function() {
            W("Succesfully loaded image #" + (S + 1), I);
          },
          function(M) {
            W("Failed loading image #" + (S + 1), I, M);
          }
        );
      }), this.ready = Promise.all(this.images.map(this.getPromise, this)), W("Finished searching images"), this;
    }, X.prototype.timeout = function(f, I) {
      var S, M = Promise.race([
        f.promise,
        new Promise(function(N, F) {
          S = setTimeout(function() {
            W("Timed out loading image", f), F(f);
          }, I);
        })
      ]).then(function(N) {
        return clearTimeout(S), N;
      });
      return M.catch(function() {
        clearTimeout(S);
      }), M;
    }, Z.prototype = Object.create(J.prototype), Z.prototype.stepRegExp = /((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\))\s*(\d{1,3})?(%|px)?/, st.prototype.cloneTo = function(f) {
      f.visible = this.visible, f.borders = this.borders, f.bounds = this.bounds, f.clip = this.clip, f.backgroundClip = this.backgroundClip, f.computedStyles = this.computedStyles, f.styles = this.styles, f.backgroundImages = this.backgroundImages, f.opacity = this.opacity;
    }, st.prototype.getOpacity = function() {
      return this.opacity === null ? this.opacity = this.cssFloat("opacity") : this.opacity;
    }, st.prototype.assignStack = function(f) {
      this.stack = f, f.children.push(this);
    }, st.prototype.isElementVisible = function() {
      return this.node.nodeType === Node.TEXT_NODE ? this.parent.visible : this.css("display") !== "none" && this.css("visibility") !== "hidden" && !this.node.hasAttribute("data-html2canvas-ignore") && (this.node.nodeName !== "INPUT" || this.node.getAttribute("type") !== "hidden");
    }, st.prototype.css = function(f) {
      return this.computedStyles || (this.computedStyles = this.isPseudoElement ? this.parent.computedStyle(this.before ? ":before" : ":after") : this.computedStyle(null)), this.styles[f] || (this.styles[f] = this.computedStyles[f]);
    }, st.prototype.prefixedCss = function(f) {
      var I = ["webkit", "moz", "ms", "o"], S = this.css(f);
      return S === r && I.some(function(M) {
        return S = this.css(M + f.substr(0, 1).toUpperCase() + f.substr(1)), S !== r;
      }, this), S === r ? null : S;
    }, st.prototype.computedStyle = function(f) {
      return this.node.ownerDocument.defaultView.getComputedStyle(this.node, f);
    }, st.prototype.cssInt = function(f) {
      return f = parseInt(this.css(f), 10), isNaN(f) ? 0 : f;
    }, st.prototype.color = function(f) {
      return this.colors[f] || (this.colors[f] = new Y(this.css(f)));
    }, st.prototype.cssFloat = function(f) {
      return f = parseFloat(this.css(f)), isNaN(f) ? 0 : f;
    }, st.prototype.fontWeight = function() {
      var f = this.css("fontWeight");
      switch (parseInt(f, 10)) {
        case 401:
          f = "bold";
          break;
        case 400:
          f = "normal";
      }
      return f;
    }, st.prototype.parseClip = function() {
      var f = this.css("clip").match(this.CLIP);
      return f ? {
        top: parseInt(f[1], 10),
        right: parseInt(f[2], 10),
        bottom: parseInt(f[3], 10),
        left: parseInt(f[4], 10)
      } : null;
    }, st.prototype.parseBackgroundImages = function() {
      return this.backgroundImages || (this.backgroundImages = U(this.css("backgroundImage")));
    }, st.prototype.cssList = function(f, I) {
      var S = (this.css(f) || "").split(","), S = S[I || 0] || S[0] || "auto", S = S.trim().split(" ");
      return S.length === 1 && (S = [S[0], S[0]]), S;
    }, st.prototype.parseBackgroundSize = function(f, I, S) {
      S = this.cssList("backgroundSize", S);
      var M;
      if (gt(S[0]))
        M = f.width * parseFloat(S[0]) / 100;
      else {
        if (/contain|cover/.test(S[0]))
          return I = I.width / I.height, f.width / f.height < I ^ S[0] === "contain" ? { width: f.height * I, height: f.height } : { width: f.width, height: f.width / I };
        M = parseInt(S[0], 10);
      }
      return f = S[0] === "auto" && S[1] === "auto" ? I.height : S[1] === "auto" ? M / I.width * I.height : gt(S[1]) ? f.height * parseFloat(S[1]) / 100 : parseInt(S[1], 10), S[0] === "auto" && (M = f / I.height * I.width), { width: M, height: f };
    }, st.prototype.parseBackgroundPosition = function(f, I, S, M) {
      S = this.cssList("backgroundPosition", S);
      var N;
      return N = gt(S[0]) ? (f.width - (M || I).width) * (parseFloat(S[0]) / 100) : parseInt(S[0], 10), f = S[1] === "auto" ? N / I.width * I.height : gt(S[1]) ? (f.height - (M || I).height) * parseFloat(S[1]) / 100 : parseInt(S[1], 10), S[0] === "auto" && (N = f / I.height * I.width), { left: N, top: f };
    }, st.prototype.parseBackgroundRepeat = function(f) {
      return this.cssList("backgroundRepeat", f)[0];
    }, st.prototype.parseTextShadows = function() {
      var f = this.css("textShadow"), I = [];
      if (f && f !== "none")
        for (var f = f.match(this.TEXT_SHADOW_PROPERTY), S = 0; f && S < f.length; S++) {
          var M = f[S].match(this.TEXT_SHADOW_VALUES);
          I.push({
            color: new Y(M[0]),
            offsetX: M[1] ? parseFloat(M[1].replace("px", "")) : 0,
            offsetY: M[2] ? parseFloat(M[2].replace("px", "")) : 0,
            blur: M[3] ? M[3].replace("px", "") : 0
          });
        }
      return I;
    }, st.prototype.parseTransform = function() {
      if (!this.transformData)
        if (this.hasTransform()) {
          var f = this.parseBounds(), I = this.prefixedCss("transformOrigin").split(" ").map(ht).map(z);
          I[0] += f.left, I[1] += f.top, this.transformData = { origin: I, matrix: this.parseTransformMatrix() };
        } else
          this.transformData = { origin: [0, 0], matrix: [1, 0, 0, 1, 0, 0] };
      return this.transformData;
    }, st.prototype.parseTransformMatrix = function() {
      if (!this.transformMatrix) {
        var f = this.prefixedCss("transform");
        this.transformMatrix = (f = f ? j(f.match(this.MATRIX_PROPERTY)) : null) ? f : [1, 0, 0, 1, 0, 0];
      }
      return this.transformMatrix;
    }, st.prototype.parseBounds = function() {
      return this.bounds || (this.bounds = this.hasTransform() ? _t(this.node) : O(this.node));
    }, st.prototype.hasTransform = function() {
      return this.parseTransformMatrix().join(",") !== "1,0,0,1,0,0" || this.parent && this.parent.hasTransform();
    }, st.prototype.getValue = function() {
      var f = this.node.value || "";
      return this.node.tagName === "SELECT" ? (f = this.node, f = (f = f.options[f.selectedIndex || 0]) && f.text || "") : this.node.type === "password" && (f = Array(f.length + 1).join("•")), f.length === 0 ? this.node.placeholder || "" : f;
    }, st.prototype.MATRIX_PROPERTY = /(matrix)\((.+)\)/, st.prototype.TEXT_SHADOW_PROPERTY = /((rgba|rgb)\([^\)]+\)(\s-?\d+px){0,})/g, st.prototype.TEXT_SHADOW_VALUES = /(-?\d+px)|(#.+)|(rgb\(.+\))|(rgba\(.+\))/g, st.prototype.CLIP = /^rect\((\d+)px,? (\d+)px,? (\d+)px,? (\d+)px\)$/, rt.prototype.calculateOverflowClips = function() {
      this.nodes.forEach(function(f) {
        if (lt(f)) {
          f.isPseudoElement === !0 && f.appendToDOM(), f.borders = this.parseBorders(f);
          var I = f.css("overflow") === "hidden" ? [f.borders.clip] : [], S = f.parseClip();
          S && ["absolute", "fixed"].indexOf(f.css("position")) !== -1 && I.push([
            [
              "rect",
              f.bounds.left + S.left,
              f.bounds.top + S.top,
              S.right - S.left,
              S.bottom - S.top
            ]
          ]), f.clip = f.parent && f.parent.clip.length ? f.parent.clip.concat(I) : I, f.backgroundClip = f.css("overflow") !== "hidden" ? f.clip.concat([f.borders.clip]) : f.clip, f.isPseudoElement === !0 && f.cleanDOM();
        } else
          dt(f) && (f.clip = f.parent && f.parent.clip.length ? f.parent.clip : []);
        f.isPseudoElement !== !0 && (f.bounds = null);
      }, this);
    }, rt.prototype.asyncRenderer = function(f, I, S) {
      S = S || Date.now(), this.paint(f[this.renderIndex++]), f.length === this.renderIndex ? I() : S + 20 > Date.now() ? this.asyncRenderer(f, I, S) : setTimeout(
        It(function() {
          this.asyncRenderer(f, I);
        }, this),
        0
      );
    }, rt.prototype.createPseudoHideStyles = function(f) {
      this.createStyles(
        f,
        "." + He.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + ':before { content: "" !important; display: none !important; }.' + He.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER + ':after { content: "" !important; display: none !important; }'
      );
    }, rt.prototype.disableAnimations = function(f) {
      this.createStyles(
        f,
        "* { -webkit-animation: none !important; -moz-animation: none !important; -o-animation: none !important; animation: none !important; -webkit-transition: none !important; -moz-transition: none !important; -o-transition: none !important; transition: none !important;}"
      );
    }, rt.prototype.createStyles = function(f, I) {
      var S = f.createElement("style");
      S.innerHTML = I, f.body.appendChild(S);
    }, rt.prototype.getPseudoElements = function(f) {
      var I = [[f]];
      if (f.node.nodeType === Node.ELEMENT_NODE) {
        var S = this.getPseudoElement(f, ":before");
        f = this.getPseudoElement(f, ":after"), S && I.push(S), f && I.push(f);
      }
      return [].concat.apply([], I);
    }, rt.prototype.getPseudoElement = function(f, I) {
      var S = f.computedStyle(I);
      if (!S || !S.content || S.content === "none" || S.content === "-moz-alt-content" || S.display === "none")
        return null;
      var M, N = S.content, F = N.substr(0, 1);
      M = F === N.substr(N.length - 1) && F.match(/'|"/) ? N.substr(1, N.length - 2) : N;
      for (var q = M.substr(0, 3) === "url", N = t.createElement(q ? "img" : "html2canvaspseudoelement"), F = new He(N, f, I), ot = S.length - 1; 0 <= ot; ot--) {
        var pt = ut(S.item(ot));
        N.style[pt] = S[pt];
      }
      return N.className = He.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + " " + He.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER, q ? (N.src = U(M)[0].args[0], [F]) : (S = t.createTextNode(M), N.appendChild(S), [F, new wr(S, F)]);
    }, rt.prototype.getChildren = function(f) {
      return [].concat.apply(
        [],
        [].filter.call(f.node.childNodes, K).map(function(I) {
          var S = [I.nodeType === Node.TEXT_NODE ? new wr(I, f) : new st(I, f)].filter(si);
          return I.nodeType === Node.ELEMENT_NODE && S.length && I.tagName !== "TEXTAREA" ? S[0].isElementVisible() ? S.concat(this.getChildren(S[0])) : [] : S;
        }, this)
      );
    }, rt.prototype.newStackingContext = function(f, I) {
      var S = new qi(I, f.getOpacity(), f.node, f.parent);
      f.cloneTo(S), (I ? S.getParentStack(this) : S.parent.stack).contexts.push(S), f.stack = S;
    }, rt.prototype.createStackingContexts = function() {
      this.nodes.forEach(function(f) {
        var I;
        (I = lt(f)) && ((I = this.isRootElement(f) || 1 > f.getOpacity()) || (I = f.css("position"), I = (["absolute", "relative", "fixed"].indexOf(I) !== -1 ? f.css("zIndex") : "auto") !== "auto"), I = I || this.isBodyWithTransparentRoot(f) || f.hasTransform()), I ? this.newStackingContext(f, !0) : lt(f) && (tt(f) && $(f) || ["inline-block", "inline-table"].indexOf(f.css("display")) !== -1 || nt(f)) ? this.newStackingContext(f, !1) : f.assignStack(f.parent.stack);
      }, this);
    }, rt.prototype.isBodyWithTransparentRoot = function(f) {
      return f.node.nodeName === "BODY" && f.parent.color("backgroundColor").isTransparent();
    }, rt.prototype.isRootElement = function(f) {
      return f.parent === null;
    }, rt.prototype.sortStackingContexts = function(f) {
      f.contexts.sort(ct(f.contexts.slice(0))), f.contexts.forEach(this.sortStackingContexts, this);
    }, rt.prototype.parseTextBounds = function(f) {
      return function(I, S, M) {
        if (f.parent.css("textDecoration").substr(0, 4) !== "none" || I.trim().length !== 0) {
          if (this.support.rangeBounds && !f.parent.hasTransform())
            return S = M.slice(0, S).join("").length, this.getRangeBounds(f.node, S, I.length);
          if (f.node && typeof f.node.data == "string")
            return I = f.node.splitText(I.length), S = this.getWrapperBounds(f.node, f.parent.hasTransform()), f.node = I, S;
        } else
          (!this.support.rangeBounds || f.parent.hasTransform()) && (f.node = f.node.splitText(I.length));
        return {};
      };
    }, rt.prototype.getWrapperBounds = function(f, I) {
      var S = f.ownerDocument.createElement("html2canvaswrapper"), M = f.parentNode, N = f.cloneNode(!0);
      S.appendChild(f.cloneNode(!0)), M.replaceChild(S, f);
      var F = I ? _t(S) : O(S);
      return M.replaceChild(N, S), F;
    }, rt.prototype.getRangeBounds = function(f, I, S) {
      var M = this.range || (this.range = f.ownerDocument.createRange());
      return M.setStart(f, I), M.setEnd(f, I + S), M.getBoundingClientRect();
    }, rt.prototype.parse = function(f) {
      var I = f.contexts.filter(bi), M = f.children.filter(lt), F = M.filter(A(nt)), S = F.filter(A(tt)).filter(A(H)), M = M.filter(A(tt)).filter(nt), N = F.filter(A(tt)).filter(H), F = f.contexts.concat(F.filter(tt)).filter($), q = f.children.filter(dt).filter(T);
      f = f.contexts.filter(x), I.concat(S).concat(M).concat(N).concat(F).concat(q).concat(f).forEach(function(ot) {
        this.renderQueue.push(ot), ot instanceof qi && (this.parse(ot), this.renderQueue.push(new oe()));
      }, this);
    }, rt.prototype.paint = function(f) {
      try {
        f instanceof oe ? this.renderer.ctx.restore() : dt(f) ? (f.parent.isPseudoElement === !0 && f.parent.appendToDOM(), this.paintText(f), f.parent.isPseudoElement === !0 && f.parent.cleanDOM()) : this.paintNode(f);
      } catch (I) {
        if (W(I), this.options.strict)
          throw I;
      }
    }, rt.prototype.paintNode = function(f) {
      f instanceof qi && (this.renderer.setOpacity(f.opacity), this.renderer.ctx.save(), f.hasTransform() && this.renderer.setTransform(f.parseTransform())), f.node.nodeName === "INPUT" && f.node.type === "checkbox" ? this.paintCheckbox(f) : f.node.nodeName === "INPUT" && f.node.type === "radio" ? this.paintRadio(f) : this.paintElement(f);
    }, rt.prototype.paintElement = function(f) {
      var I = f.parseBounds();
      this.renderer.clip(
        f.backgroundClip,
        function() {
          this.renderer.renderBackground(f, I, f.borders.borders.map(Ft));
        },
        this
      ), this.renderer.clip(
        f.clip,
        function() {
          this.renderer.renderBorders(f.borders.borders);
        },
        this
      ), this.renderer.clip(
        f.backgroundClip,
        function() {
          switch (f.node.nodeName) {
            case "svg":
            case "IFRAME":
              var S = this.images.get(f.node);
              S ? this.renderer.renderImage(f, I, f.borders, S) : W("Error loading <" + f.node.nodeName + ">", f.node);
              break;
            case "IMG":
              (S = this.images.get(f.node.src)) ? this.renderer.renderImage(f, I, f.borders, S) : W("Error loading <img>", f.node.src);
              break;
            case "CANVAS":
              this.renderer.renderImage(f, I, f.borders, { image: f.node });
              break;
            case "SELECT":
            case "INPUT":
            case "TEXTAREA":
              this.paintFormValue(f);
          }
        },
        this
      );
    }, rt.prototype.paintCheckbox = function(f) {
      var M = f.parseBounds(), I = Math.min(M.width, M.height), S = { width: I - 1, height: I - 1, top: M.top, left: M.left }, M = [3, 3], N = [M, M, M, M], F = [1, 1, 1, 1].map(function(ot) {
        return { color: new Y("#A5A5A5"), width: ot };
      }), q = Dt(S, N, F);
      this.renderer.clip(
        f.backgroundClip,
        function() {
          this.renderer.rectangle(
            S.left + 1,
            S.top + 1,
            S.width - 2,
            S.height - 2,
            new Y("#DEDEDE")
          ), this.renderer.renderBorders(Le(F, S, q, N)), f.node.checked && (this.renderer.font(
            new Y("#424242"),
            "normal",
            "normal",
            "bold",
            I - 3 + "px",
            "arial"
          ), this.renderer.text("✔", S.left + I / 6, S.top + I - 1));
        },
        this
      );
    }, rt.prototype.paintRadio = function(f) {
      var I = f.parseBounds(), S = Math.min(I.width, I.height) - 2;
      this.renderer.clip(
        f.backgroundClip,
        function() {
          this.renderer.circleStroke(
            I.left + 1,
            I.top + 1,
            S,
            new Y("#DEDEDE"),
            1,
            new Y("#A5A5A5")
          ), f.node.checked && this.renderer.circle(
            Math.ceil(I.left + S / 4) + 1,
            Math.ceil(I.top + S / 4) + 1,
            Math.floor(S / 2),
            new Y("#424242")
          );
        },
        this
      );
    }, rt.prototype.paintFormValue = function(f) {
      var I = f.getValue();
      if (0 < I.length) {
        var S = f.node.ownerDocument, M = S.createElement("html2canvaswrapper");
        "lineHeight textAlign fontFamily fontWeight fontSize color paddingLeft paddingTop paddingRight paddingBottom width height borderLeftStyle borderTopStyle borderLeftWidth borderTopWidth boxSizing whiteSpace wordWrap".split(" ").forEach(function(F) {
          try {
            M.style[F] = f.css(F);
          } catch (q) {
            W("html2canvas: Parse: Exception caught in renderFormValue: " + q.message);
          }
        });
        var N = f.parseBounds();
        M.style.position = "fixed", M.style.left = N.left + "px", M.style.top = N.top + "px", M.textContent = I, S.body.appendChild(M), this.paintText(new wr(M.firstChild, f)), S.body.removeChild(M);
      }
    }, rt.prototype.paintText = function(f) {
      f.applyTextTransform();
      var S = n.html2canvas.punycode.ucs2.decode(f.node.data), I = this.options.letterRendering && !/^(normal|none|0px)$/.test(f.parent.css("letterSpacing")) || /[^\u0000-\u00ff]/.test(f.node.data) ? S.map(function(q) {
        return n.html2canvas.punycode.ucs2.encode([q]);
      }) : cn(S), S = f.parent.fontWeight(), M = f.parent.css("fontSize"), N = f.parent.css("fontFamily"), F = f.parent.parseTextShadows();
      this.renderer.font(
        f.parent.color("color"),
        f.parent.css("fontStyle"),
        f.parent.css("fontVariant"),
        S,
        M,
        N
      ), F.length ? this.renderer.fontShadow(F[0].color, F[0].offsetX, F[0].offsetY, F[0].blur) : this.renderer.clearShadow(), this.renderer.clip(
        f.parent.clip,
        function() {
          I.map(this.parseTextBounds(f), this).forEach(function(q, ot) {
            q && (this.renderer.text(I[ot], q.left, q.bottom), this.renderTextDecoration(f.parent, q, this.fontMetrics.getMetrics(N, M)));
          }, this);
        },
        this
      );
    }, rt.prototype.renderTextDecoration = function(f, I, S) {
      switch (f.css("textDecoration").split(" ")[0]) {
        case "underline":
          this.renderer.rectangle(
            I.left,
            Math.round(I.top + S.baseline + S.lineWidth),
            I.width,
            1,
            f.color("color")
          );
          break;
        case "overline":
          this.renderer.rectangle(I.left, Math.round(I.top), I.width, 1, f.color("color"));
          break;
        case "line-through":
          this.renderer.rectangle(
            I.left,
            Math.ceil(I.top + S.middle + S.lineWidth),
            I.width,
            1,
            f.color("color")
          );
      }
    };
    var Uh = {
      inset: [
        ["darken", 0.6],
        ["darken", 0.1],
        ["darken", 0.1],
        ["darken", 0.6]
      ]
    };
    rt.prototype.parseBorders = function(f) {
      var I = f.parseBounds(), S = V(f), M = ["Top", "Right", "Bottom", "Left"].map(function(F, q) {
        var ot = f.css("border" + F + "Style"), pt = f.color("border" + F + "Color");
        return ot === "inset" && pt.isBlack() && (pt = new Y([255, 255, 255, pt.a])), ot = Uh[ot] ? Uh[ot][q] : null, {
          width: f.cssInt("border" + F + "Width"),
          color: ot ? pt[ot[0]](ot[1]) : pt,
          args: null
        };
      }), N = Dt(I, S, M);
      return { clip: this.parseBackgroundClip(f, N, M, S, I), borders: Le(M, I, N, S) };
    }, rt.prototype.parseBackgroundClip = function(f, I, S, M, N) {
      var F = [];
      switch (f.css("backgroundClip")) {
        case "content-box":
        case "padding-box":
          Ye(
            F,
            M[0],
            M[1],
            I.topLeftInner,
            I.topRightInner,
            N.left + S[3].width,
            N.top + S[0].width
          ), Ye(
            F,
            M[1],
            M[2],
            I.topRightInner,
            I.bottomRightInner,
            N.left + N.width - S[1].width,
            N.top + S[0].width
          ), Ye(
            F,
            M[2],
            M[3],
            I.bottomRightInner,
            I.bottomLeftInner,
            N.left + N.width - S[1].width,
            N.top + N.height - S[2].width
          ), Ye(
            F,
            M[3],
            M[0],
            I.bottomLeftInner,
            I.topLeftInner,
            N.left + S[3].width,
            N.top + N.height - S[2].width
          );
          break;
        default:
          Ye(F, M[0], M[1], I.topLeftOuter, I.topRightOuter, N.left, N.top), Ye(F, M[1], M[2], I.topRightOuter, I.bottomRightOuter, N.left + N.width, N.top), Ye(
            F,
            M[2],
            M[3],
            I.bottomRightOuter,
            I.bottomLeftOuter,
            N.left + N.width,
            N.top + N.height
          ), Ye(F, M[3], M[0], I.bottomLeftOuter, I.topLeftOuter, N.left, N.top + N.height);
      }
      return F;
    };
    var jp = 0, Qh = "withCredentials" in new XMLHttpRequest(), qh = "crossOrigin" in new Image();
    He.prototype.cloneTo = function(f) {
      He.prototype.cloneTo.call(this, f), f.isPseudoElement = !0, f.before = this.before;
    }, He.prototype = Object.create(st.prototype), He.prototype.appendToDOM = function() {
      this.before ? this.parent.node.insertBefore(this.node, this.parent.node.firstChild) : this.parent.node.appendChild(this.node), this.parent.node.className += " " + this.getHideClass();
    }, He.prototype.cleanDOM = function() {
      this.node.parentNode.removeChild(this.node), this.parent.node.className = this.parent.node.className.replace(this.getHideClass(), "");
    }, He.prototype.getHideClass = function() {
      return this["PSEUDO_HIDE_ELEMENT_CLASS_" + (this.before ? "BEFORE" : "AFTER")];
    }, He.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = "___html2canvas___pseudoelement_before", He.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER = "___html2canvas___pseudoelement_after", Yi.prototype.renderImage = function(f, I, S, M) {
      var N = f.cssInt("paddingLeft"), F = f.cssInt("paddingTop"), q = f.cssInt("paddingRight");
      f = f.cssInt("paddingBottom"), S = S.borders, q = I.width - (S[1].width + S[3].width + N + q), f = I.height - (S[0].width + S[2].width + F + f), this.drawImage(
        M,
        0,
        0,
        M.image.width || q,
        M.image.height || f,
        I.left + N + S[3].width,
        I.top + F + S[0].width,
        q,
        f
      );
    }, Yi.prototype.renderBackground = function(f, I, S) {
      0 < I.height && 0 < I.width && (this.renderBackgroundColor(f, I), this.renderBackgroundImage(f, I, S));
    }, Yi.prototype.renderBackgroundColor = function(f, I) {
      var S = f.color("backgroundColor");
      S.isTransparent() || this.rectangle(I.left, I.top, I.width, I.height, S);
    }, Yi.prototype.renderBorders = function(f) {
      f.forEach(this.renderBorder, this);
    }, Yi.prototype.renderBorder = function(f) {
      f.color.isTransparent() || f.args === null || this.drawShape(f.args, f.color);
    }, Yi.prototype.renderBackgroundImage = function(f, I, S) {
      f.parseBackgroundImages().reverse().forEach(function(M, N, F) {
        switch (M.method) {
          case "url":
            var q = this.images.get(M.args[0]);
            q ? this.renderBackgroundRepeating(f, I, q, F.length - (N + 1), S) : W("Error loading background-image", M.args[0]);
            break;
          case "linear-gradient":
          case "gradient":
            (N = this.images.get(M.value)) ? this.renderBackgroundGradient(N, I, S) : W("Error loading background-image", M.args[0]);
            break;
          case "none":
            break;
          default:
            W("Unknown background-image type", M.args[0]);
        }
      }, this);
    }, Yi.prototype.renderBackgroundRepeating = function(f, I, S, M, N) {
      var F = f.parseBackgroundSize(I, S.image, M), q = f.parseBackgroundPosition(I, S.image, M, F);
      switch (f.parseBackgroundRepeat(M)) {
        case "repeat-x":
        case "repeat no-repeat":
          this.backgroundRepeatShape(
            S,
            q,
            F,
            I,
            I.left + N[3],
            I.top + q.top + N[0],
            99999,
            F.height,
            N
          );
          break;
        case "repeat-y":
        case "no-repeat repeat":
          this.backgroundRepeatShape(
            S,
            q,
            F,
            I,
            I.left + q.left + N[3],
            I.top + N[0],
            F.width,
            99999,
            N
          );
          break;
        case "no-repeat":
          this.backgroundRepeatShape(
            S,
            q,
            F,
            I,
            I.left + q.left + N[3],
            I.top + q.top + N[0],
            F.width,
            F.height,
            N
          );
          break;
        default:
          this.renderBackgroundRepeat(S, q, F, { top: I.top, left: I.left }, N[3], N[0]);
      }
    }, qi.prototype = Object.create(st.prototype), qi.prototype.getParentStack = function(f) {
      var I = this.parent ? this.parent.stack : null;
      return I ? I.ownStacking ? I : I.getParentStack(f) : f.stack;
    }, wn.prototype.testRangeBounds = function(f) {
      var I, S, M = !1;
      return f.createRange && (I = f.createRange(), I.getBoundingClientRect && (S = f.createElement("boundtest"), S.style.height = "123px", S.style.display = "block", f.body.appendChild(S), I.selectNode(S), I = I.getBoundingClientRect(), I = I.height, I === 123 && (M = !0), f.body.removeChild(S))), M;
    }, wn.prototype.testCORS = function() {
      return typeof new Image().crossOrigin < "u";
    }, wn.prototype.testSVG = function() {
      var f = new Image(), I = t.createElement("canvas"), S = I.getContext("2d");
      f.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";
      try {
        S.drawImage(f, 0, 0), I.toDataURL();
      } catch {
        return !1;
      }
      return !0;
    }, Zi.prototype.hasFabric = function() {
      return html2canvas.fabric ? Promise.resolve() : Promise.reject(Error("html2canvas.svg.js is not loaded, cannot render svg"));
    }, Zi.prototype.inlineFormatting = function(f) {
      return /^data:image\/svg\+xml;base64,/.test(f) ? this.decode64(this.removeContentType(f)) : this.removeContentType(f);
    }, Zi.prototype.removeContentType = function(f) {
      return f.replace(/^data:image\/svg\+xml(;base64)?,/, "");
    }, Zi.prototype.isInline = function(f) {
      return /^data:image\/svg\+xml/i.test(f);
    }, Zi.prototype.createCanvas = function(f) {
      var I = this;
      return function(S, M) {
        var N = new html2canvas.fabric.StaticCanvas("c");
        I.image = N.lowerCanvasEl, N.setWidth(M.width).setHeight(M.height).add(html2canvas.fabric.util.groupSVGElements(S, M)).renderAll(), f(N.lowerCanvasEl);
      };
    }, Zi.prototype.decode64 = function(f) {
      return typeof n.atob == "function" ? n.atob(f) : Ve(f);
    }, zs.prototype = Object.create(Zi.prototype), wr.prototype = Object.create(st.prototype), wr.prototype.applyTextTransform = function() {
      this.node.data = this.transform(this.parent.css("textTransform"));
    }, wr.prototype.transform = function(f) {
      var I = this.node.data;
      switch (f) {
        case "lowercase":
          return I.toLowerCase();
        case "capitalize":
          return I.replace(/(^|\s|:|-|\(|\))([a-z])/g, Xp);
        case "uppercase":
          return I.toUpperCase();
        default:
          return I;
      }
    }, jh.prototype = Object.create(J.prototype), Xe.prototype = Object.create(Yi.prototype), Xe.prototype.setFillStyle = function(f) {
      return this.ctx.fillStyle = typeof f == "object" && f.isColor ? f.toString() : f, this.ctx;
    }, Xe.prototype.rectangle = function(f, I, S, M, N) {
      this.setFillStyle(N).fillRect(f, I, S, M);
    }, Xe.prototype.circle = function(f, I, S, M) {
      this.setFillStyle(M), this.ctx.beginPath(), this.ctx.arc(f + S / 2, I + S / 2, S / 2, 0, 2 * Math.PI, !0), this.ctx.closePath(), this.ctx.fill();
    }, Xe.prototype.circleStroke = function(f, I, S, M, N, F) {
      this.circle(f, I, S, M), this.ctx.strokeStyle = F.toString(), this.ctx.stroke();
    }, Xe.prototype.drawShape = function(f, I) {
      this.shape(f), this.setFillStyle(I).fill();
    }, Xe.prototype.taints = function(f) {
      if (f.tainted === null) {
        this.taintCtx.drawImage(f.image, 0, 0);
        try {
          this.taintCtx.getImageData(0, 0, 1, 1), f.tainted = !1;
        } catch {
          this.taintCtx = t.createElement("canvas").getContext("2d"), f.tainted = !0;
        }
      }
      return f.tainted;
    }, Xe.prototype.drawImage = function(f, I, S, M, N, F, q, ot, pt) {
      this.taints(f) && !this.options.allowTaint || this.ctx.drawImage(f.image, I, S, M, N, F, q, ot, pt);
    }, Xe.prototype.clip = function(f, I, S) {
      this.ctx.save(), f.filter(Fp).forEach(function(M) {
        this.shape(M).clip();
      }, this), I.call(S), this.ctx.restore();
    }, Xe.prototype.shape = function(f) {
      return this.ctx.beginPath(), f.forEach(function(I, S) {
        I[0] === "rect" ? this.ctx.rect.apply(this.ctx, I.slice(1)) : this.ctx[S === 0 ? "moveTo" : I[0] + "To"].apply(this.ctx, I.slice(1));
      }, this), this.ctx.closePath(), this.ctx;
    }, Xe.prototype.font = function(f, I, S, M, N, F) {
      this.setFillStyle(f).font = [I, S, M, N, F].join(" ").split(",")[0];
    }, Xe.prototype.fontShadow = function(f, I, S, M) {
      this.setVariable("shadowColor", f.toString()).setVariable("shadowOffsetY", I).setVariable("shadowOffsetX", S).setVariable("shadowBlur", M);
    }, Xe.prototype.clearShadow = function() {
      this.setVariable("shadowColor", "rgba(0,0,0,0)");
    }, Xe.prototype.setOpacity = function(f) {
      this.ctx.globalAlpha = f;
    }, Xe.prototype.setTransform = function(f) {
      this.ctx.translate(f.origin[0], f.origin[1]), this.ctx.transform.apply(this.ctx, f.matrix), this.ctx.translate(-f.origin[0], -f.origin[1]);
    }, Xe.prototype.setVariable = function(f, I) {
      return this.variables[f] !== I && (this.variables[f] = this.ctx[f] = I), this;
    }, Xe.prototype.text = function(f, I, S) {
      this.ctx.fillText(f, I, S);
    }, Xe.prototype.backgroundRepeatShape = function(f, I, S, M, N, F, q, ot, pt) {
      this.clip(
        [
          [
            ["line", Math.round(N), Math.round(F)],
            ["line", Math.round(N + q), Math.round(F)],
            ["line", Math.round(N + q), Math.round(ot + F)],
            ["line", Math.round(N), Math.round(ot + F)]
          ]
        ],
        function() {
          this.renderBackgroundRepeat(f, I, S, M, pt[3], pt[0]);
        },
        this
      );
    }, Xe.prototype.renderBackgroundRepeat = function(f, I, S, M, N, F) {
      N = Math.round(M.left + I.left + N), I = Math.round(M.top + I.top + F), this.setFillStyle(this.ctx.createPattern(this.resizeImage(f, S), "repeat")), this.ctx.translate(N, I), this.ctx.fill(), this.ctx.translate(-N, -I);
    }, Xe.prototype.renderBackgroundGradient = function(f, I) {
      if (f instanceof Z) {
        var S = this.ctx.createLinearGradient(
          I.left + I.width * f.x0,
          I.top + I.height * f.y0,
          I.left + I.width * f.x1,
          I.top + I.height * f.y1
        );
        f.colorStops.forEach(function(M) {
          S.addColorStop(M.stop, M.color.toString());
        }), this.rectangle(I.left, I.top, I.width, I.height, S);
      }
    }, Xe.prototype.resizeImage = function(f, I) {
      var S = f.image;
      if (S.width === I.width && S.height === I.height)
        return S;
      var M = t.createElement("canvas");
      return M.width = I.width, M.height = I.height, M.getContext("2d").drawImage(S, 0, 0, S.width, S.height, 0, 0, I.width, I.height), M;
    };
  }
}).call(
  {},
  typeof window < "u" ? window : void 0,
  typeof document < "u" ? document : void 0
);
function _c(n) {
  const t = document.createElement("canvas");
  return t.width = n.width, t.height = n.height, t.getContext("2d").drawImage(n, 0, 0), t;
}
function Np(n) {
  if (n instanceof HTMLCanvasElement) {
    const t = n;
    if (t.clientWidth > 0 && t.clientHeight > 0)
      return n;
  }
  for (let t = 0; t < n.childNodes.length; t++) {
    const e = n.childNodes.item(t), i = Np(e);
    if (i)
      return i;
  }
  return null;
}
function G0(n) {
  const e = new DOMParser().parseFromString(n, "text/xml"), i = e.getElementsByTagName("defs"), s = [];
  for (let c = 0; c < i.length; c++) {
    const u = i.item(c).getElementsByTagName("marker");
    for (let p = 0; p < u.length; p++) {
      const m = u.item(p);
      s.push(m);
    }
  }
  const r = [], o = e.getElementsByTagName("line");
  for (let c = 0; c < o.length; c++) {
    const h = o.item(c);
    if (h.style.marker !== null && h.style.marker.length > 0) {
      const u = h.style.marker.indexOf("#") + 1, p = h.style.marker.indexOf('"', u + 1), m = h.style.marker.substring(u, p);
      let g = null, _ = null;
      for (let b = 0; b < s.length; b++)
        if (s[b].id === m) {
          g = s[b], _ = s[b + 1];
          break;
        }
      const y = { line: h, start: g, end: _ };
      r.push(y);
    }
  }
  const a = "marker: url";
  let l = n.indexOf(a);
  for (; l >= 0; ) {
    const c = n.indexOf(")", l) + 1, h = n.substring(l, c), u = h.indexOf("#") + 1, p = h.indexOf('"', u), m = h.indexOf(
      "&quot",
      u + a.length + 1
    );
    let g = p;
    (p < 0 || m < p) && (g = m);
    const _ = h.substring(u, g);
    for (const y of r) {
      const b = y.start, w = y.end;
      if (b !== null && w !== null && b.id === _) {
        let v = `marker-start: url('#${b.id}');`;
        v += `marker-end: url('#${w.id}')`, n = n.slice(0, l) + v + n.slice(c);
        break;
      }
    }
    l = n.indexOf(a, c + 1);
  }
  return n;
}
function Y0(n, t) {
  const e = n.getContext("2d");
  if (e === null)
    throw new Mt("failed to create 2D canvas context");
  for (const r of t)
    e.drawImage(r, 0, 0);
  const i = be(), s = new Image();
  return s.src = n.toDataURL(), s.onload = () => {
    i.resolve(s);
  }, i;
}
class V0 {
  constructor(t, e) {
    this._domElements = t, this._config = e;
  }
  async _extractMarkupSvgAsCanvas() {
    const t = this._domElements.getMarkupSvgElement();
    let e = new XMLSerializer().serializeToString(t);
    e = G0(e);
    const i = document.createElement("canvas");
    document.body.appendChild(i);
    const s = i.getContext("2d");
    if (!s)
      return i;
    await (await nr.from(s, e)).render();
    const o = _c(i);
    return document.body.removeChild(i), o;
  }
  async _extractRedlineSvgAsCanvas(t, e) {
    const i = this._domElements.getRedlineSvgElement();
    i.setAttribute("width", `${t}`), i.setAttribute("height", `${e}`);
    let s = new XMLSerializer().serializeToString(i);
    s = s.replace("width: 100%;", `width: ${t};`), s = s.replace("height: 100%;", `height: ${e};`);
    const r = document.createElement("canvas");
    document.body.appendChild(r);
    const o = r.getContext("2d");
    if (!o)
      return r;
    await (await nr.from(o, s)).render();
    const l = _c(r);
    return document.body.removeChild(r), l;
  }
  async _extractRedlineAsCanvas() {
    const t = this._domElements.getRedlineElement();
    return html2canvas(t, {
      background: void 0,
      letterRendering: !0
      // Fixes word break issue
    });
  }
  async capture(t) {
    const e = Np(t);
    if (e === null)
      throw new Mt("failed to find canvas");
    const i = document.createElement("canvas");
    i.width = this._config.width || t.clientWidth, i.height = this._config.height || t.clientHeight, i.style.width = "100%", i.style.height = "100%";
    const s = [];
    return this._config.layers & To.Model && s.push(_c(e)), this._config.layers & To.Svg && (s.push(await this._extractMarkupSvgAsCanvas()), s.push(
      await this._extractRedlineSvgAsCanvas(i.width, i.height)
    )), this._config.layers & To.Html && s.push(await this._extractRedlineAsCanvas()), Y0(i, s);
  }
}
class T0 {
  constructor(t) {
    this._timeoutDurationMinutes = 15, this._timeoutWarningMinutes = 14, this._timer = new As(), this._enabled = !0, this._callbackManager = t, this.resetTimeout();
  }
  setTimeoutDurations(t, e) {
    return this._timeoutDurationMinutes = t, this._timeoutWarningMinutes = e, this.resetTimeout(), !0;
  }
  shutdown() {
    this._enabled = !1, this._timer.clear();
  }
  resetTimeout() {
    if (!this._enabled)
      return;
    const t = Math.round(this._timeoutWarningMinutes * 60 * 1e3);
    this._timer.set(t, () => {
      this._warn();
    });
  }
  _warn() {
    console.assert(this._timer.isIdle(mi.BeforeAction));
    const t = this._timeoutDurationMinutes - this._timeoutWarningMinutes, e = Math.round(t * 60 * 1e3);
    this._callbackManager.trigger("timeoutWarning", t), this._timer.set(e, () => {
      this._timeout();
    });
  }
  _timeout() {
    this._callbackManager.trigger("timeout"), this._callbackManager.trigger("_timeout");
  }
}
const Jh = class {
  /**
   * Creates a new Web Viewer instance. You must pass in a **containerId** key with the ID of an element or a **container** element to use for your viewer.
   * The system will create any required elements inside the supplied container.
   *
   * @param inputParams object containing key-value pairs for viewer to set
   */
  constructor(n) {
    if (this._callbackManager = new Cg(), this._interpolationManager = new ab(), this._streamingMode = Ps.Interactive, this._rendererType = qo.Client, this._alreadyShutDown = !1, this._shutdownTimer = new As(), this._sceneReadyPromise = be(), this._modelLoadFailure = !1, this._seenPriorityMetaDataSent = !1, this._params = { ...n }, this._contextMenuActiveFlag = !1, this._params.containerId !== void 0) {
      const m = Lr.createFromId(this._params.containerId);
      if (m === null)
        throw new fn("'containerId' is invalid");
      this._domElements = m;
    } else if (this._params.container !== void 0)
      this._domElements = Lr.createFromElement(this._params.container);
    else
      throw new fn("must supply 'container' or 'containerId'");
    this.operatorManager = new _y(this), this._eventDispatcher = new rb(this._callbackManager, this.operatorManager), this._timeoutMonitor = new T0(this._callbackManager), this._inputMonitor = new Ql(this._eventDispatcher, this._timeoutMonitor), this._setInitialOptions(this._params), this._engine = new eb(this._callbackManager, this._params), this._statistics = new tb(this._callbackManager, this);
    const t = new gp(this), e = new Ds(this);
    this.model = new Yo(this._engine, this._callbackManager), this.view = new Sy(
      this,
      this._engine,
      this._callbackManager,
      this._eventDispatcher,
      this._interpolationManager,
      this._statistics,
      t,
      e
    ), this.cuttingManager = new hy(this, this.model, this._callbackManager, this._engine);
    const i = {
      disableAutomaticFitWorld: Zr(this._params.disableAutomaticFitWorld, !1),
      markImplicitNodesOutOfHierarchy: Zr(
        this._params._markImplicitNodesOutOfHierarchy,
        !0
      ),
      streamingMode: Zr(this._params.streamingMode, Ps.Default)
    };
    this._modelStructure = Kh.unsafeCreate(
      i,
      this._engine,
      this._callbackManager,
      this.cuttingManager,
      this.view,
      this.model,
      this._params._maxConcurrentAttachments || null
    ), this.model._setModelStructure(this._modelStructure), this.measureManager = new fy(this, this._callbackManager), this.lineManager = new my(this, this._callbackManager), this.explodeManager = new uy(this.model, this._engine, this._callbackManager), this.overlayManager = new gm(this, this._engine), this.BCFManager = new sb(this), this.selectionManager = new Bl(
      this._callbackManager,
      this._engine,
      this.view,
      this.model,
      this._modelStructure
    );
    const s = new Wa();
    Zr(
      this._params.disableAutomaticFloorplanOverlay,
      !1
    ) && (s.autoActivate = Xs.Never), this.floorplanManager = new ys(
      this,
      this.model,
      this.overlayManager,
      this._engine,
      this._modelStructure,
      s
    );
    const o = Zr(
      this._params.disableAutomaticBackgroundSheets,
      !1
    );
    this.sheetManager = new yy(
      this,
      this._engine,
      this._callbackManager,
      o
    ), this.noteTextManager = new Ul(this), this.markupManager = new gy(
      this._domElements,
      this.measureManager,
      this.lineManager,
      this._callbackManager,
      this.sheetManager,
      this.noteTextManager,
      this
    ), this.view._setMarkupManager(this.markupManager), this.animationManager = new nm(this), this._initEventDispatcher();
    const a = () => {
      this.model.setPmiColor(it.black());
    }, l = (m) => {
      this.model.isDrawing() && (m = this.sheetManager.get3DNodes());
      const g = bt.PmiBody | bt.ViewFrame;
      this.model._setInstanceModifier(
        Fe.OverrideSceneVisibility,
        m,
        !0,
        g
      );
      for (const _ of m)
        this.model.setPmiColorOverride(!0, _);
    }, c = async (m) => {
      m ? await Promise.all([
        this.view.setPointSize(3e-3, Wc.ProportionOfBoundingDiagonal),
        this.view.setEyeDomeLightingEnabled(!0),
        this.view.setPointShape(Pc.Disk)
      ]) : await Promise.all([
        //reset to defaults
        this.view.setPointSize(1, Wc.ScreenPixels),
        this.view.setEyeDomeLightingEnabled(!1),
        this.view.setPointShape(Pc.Square)
      ]);
    }, h = async (m) => {
      for (const g of m) {
        const _ = this.model.getModelFileTypeFromNode(g);
        if (_ !== null && _ !== Vo.Unknown) {
          await c(!1);
          break;
        }
      }
    }, u = async (m) => {
      const g = [];
      if (this.model.getModelFileTypeFromNode(m[0]) === Vo.Ifc)
        for (const _ of m) {
          const y = this.model.registerIfcNodes(_);
          g.push(y);
        }
      await Promise.all(g);
    }, p = (m) => {
      const g = this.selectionManager.getSelectionFilter(), _ = this.model.getModelFileTypeFromNode(m[0]) === Vo.Ifc;
      if (!g && _) {
        this.selectionManager.setSelectionFilter(Fc);
        return;
      }
      g === Fc && !_ && this.selectionManager.setSelectionFilter(null);
    };
    this.setCallbacks({
      _resetAssemblyTreeBegin: async () => {
        a();
      },
      _sessionStarted: () => c(!0),
      _firstModelLoaded: async (m) => {
        a(), p(m), l([this.model.getAbsoluteRootNode()]), await Promise.all([u(m), h(m)]);
        const g = this.model.getDefaultCadView() !== null;
        this.model.getDefaultCadConfiguration() !== null && await this._modelStructure.cadConfigurationsEnabled() && await this.model.activateDefaultCadConfiguration(!g), g && await this.model.activateDefaultCadView();
      },
      _modelSwitched: async (m, g) => {
        p(g), l(g), await Promise.all([u(g), h(g)]);
      },
      _subtreeLoaded: async (m) => {
        l(m), await u(m);
      },
      modelLoadFailure: () => {
        this._modelLoadFailure = !0;
      }
    });
  }
  static get defaultEnginePath() {
    return Xo.defaultEnginePath;
  }
  static set defaultEnginePath(n) {
    Xo.defaultEnginePath = n;
  }
  /**
   * Sets a boolean with the status of the context menu
   * @param isActive
   */
  setContextMenuStatus(n) {
    this._contextMenuActiveFlag = n;
  }
  /**
   * @returns boolean true if the context menu is active, false otherwise
   */
  getContextMenuStatus() {
    return this._contextMenuActiveFlag;
  }
  /**
   * Gets the parameters that were used to initialize this instance of the WebViewer
   * @returns initial creation parameters
   */
  getCreationParameters() {
    return { ...this._params };
  }
  /**
   * @param options
   */
  _setInitialOptions(n) {
    this._inputMonitor.setOptions(n), n.streamingMode !== void 0 ? this._streamingMode = n.streamingMode : n.streamingMode = this._streamingMode, n.rendererType !== void 0 ? this._rendererType = n.rendererType : n.rendererType = this._rendererType;
  }
  /**
   * @param viewer
   */
  _initEventDispatcher() {
    const n = new Rh(this), t = new Rm(this), e = new Km(this), i = new Fm(this), s = new Em(
      this,
      n,
      t,
      e
    ), r = new Xm(this), o = new Wl(this), a = new Lm(this, r, o), l = new Nm(this), c = new mp(this, this.noteTextManager), h = new sp(this), u = new dp(this), p = new tp(this), m = new np(this), g = new ip(this), _ = new ep(this), y = new Dm(this, this.measureManager), b = new Bm(
      this,
      this.measureManager
    ), w = new jm(
      this,
      this.measureManager
    ), v = new Hm(
      this,
      this.measureManager
    ), C = new Om(
      this,
      this.measureManager
    ), k = new zm(
      this,
      this.measureManager
    ), Y = new Qm(
      this,
      this.measureManager
    ), P = new Um(this, this.measureManager), L = new up(this, this.noteTextManager), R = new ap(this, this.cuttingManager), D = new cp(this), J = new hp(this), G = new rp(this), X = new lp(this), Z = new pp(this);
    this.operatorManager._registerOperator(Et.Navigate, s), this.operatorManager._registerOperator(Et.Orbit, n), this.operatorManager._registerOperator(Et.Pan, t), this.operatorManager._registerOperator(Et.Zoom, e), this.operatorManager._registerOperator(Et.WindowZoom, i), this.operatorManager._registerOperator(Et.Walk, r), this.operatorManager._registerOperator(Et.KeyboardWalk, o), this.operatorManager._registerOperator(Et.WalkMode, a), this.operatorManager._registerOperator(Et.Turntable, l), this.operatorManager._registerOperator(Et.Select, c), this.operatorManager._registerOperator(Et.AreaSelect, h), this.operatorManager._registerOperator(Et.RayDrillSelect, u), this.operatorManager._registerOperator(Et.RedlineCircle, p), this.operatorManager._registerOperator(Et.RedlineText, m), this.operatorManager._registerOperator(Et.RedlineRectangle, g), this.operatorManager._registerOperator(Et.RedlinePolyline, _), this.operatorManager._registerOperator(Et.MeasureEdgeLength, y), this.operatorManager._registerOperator(
      Et.MeasureFaceFaceDistance,
      b
    ), this.operatorManager._registerOperator(
      Et.MeasureLineLineAngle,
      w
    ), this.operatorManager._registerOperator(
      Et.MeasurePointPointDistance,
      v
    ), this.operatorManager._registerOperator(
      Et.MeasureBodyBodyDistance,
      C
    ), this.operatorManager._registerOperator(
      Et.MeasureFaceFaceAngle,
      k
    ), this.operatorManager._registerOperator(
      Et.MeasurePolylineDistance,
      Y
    ), this.operatorManager._registerOperator(
      Et.MeasurePolygonArea,
      P
    ), this.operatorManager._registerOperator(Et.Note, L), this.operatorManager._registerOperator(Et.Cutting, R), this.operatorManager._registerOperator(Et.Handle, D), this.operatorManager._registerOperator(Et.NavCube, J), this.operatorManager._registerOperator(Et.AxisTriad, G), this.operatorManager._registerOperator(Et.Floorplan, X), this.operatorManager._registerOperator(Et.SpaceMouse, Z), s.setBimNavigationEnabled(!1), y.addMapping(Kt.Left), b.addMapping(Kt.Left), v.addMapping(Kt.Left), v.addMapping(Kt.Left, ye.Alt), k.addMapping(Kt.Left), i.addMapping(Kt.Left), R.addMapping(Kt.Left), h.addMapping(Kt.Left), h.addMapping(Kt.Left, ye.Control), this.operatorManager.set(Et.Navigate, 0), this.operatorManager.set(Et.Select, 1), this.operatorManager.push(Et.Cutting), this.operatorManager.push(Et.Handle), this.operatorManager.push(Et.NavCube), this.operatorManager.push(Et.AxisTriad), this.operatorManager.push(Et.Floorplan), this.operatorManager.push(Et.SpaceMouse);
  }
  /**
   * Returns the viewer version string.
   * @returns string containing version information for the viewer.
   */
  getViewerVersionString() {
    return Jh.VIEWER_VERSION_STRING;
  }
  /**
   * Returns the format version string.
   * @returns string containing version information for the format.
   */
  getFormatVersionString() {
    return this._engine.getVersionString();
  }
  /**
   * Starts the viewer and begins the loading process
   */
  start() {
    const n = this._domElements.getCanvasContainerElement();
    return this._engine.start(n, {
      enginePath: this._params.enginePath,
      engineReady: async (t) => {
        await t, await this._modelStructure.waitForReady(), await this._scEngineReady();
      },
      sceneReady: () => {
        this._sceneReady();
      },
      renderComplete: () => {
        this._renderComplete();
      },
      streamingActivated: () => {
        this._streamingActivated();
      },
      streamingDeactivated: () => {
        this._streamingDeactivated();
      },
      priorityMetaDataSent: (t, e) => {
        this._priorityMetaDataSent(t, e);
      }
    });
  }
  /**
   * Associates a custom operator object with a system generated operatorId.
   * @param operatorId the ID of the operator that is to be unregistered
   * @returns an operatorId to be used for this operator.
   */
  registerCustomOperator(n) {
    return this.operatorManager.registerCustomOperator(n);
  }
  /**
   * Removes a previously registered custom operator from the system.
   * @param operatorId the ID of the operator that is to be unregistered
   */
  unregisterCustomOperator(n) {
    this.operatorManager.unregisterCustomOperator(n);
  }
  /**
   * Sets whether keyboard input should be directed to this Web Viewer.
   * @param focus if true, the Web Viewer will be focused and accept keyboard input, otherwise it will be blurred and not accept keyboard input
   */
  focusInput(n) {
    this._inputMonitor.focusInput(n);
  }
  /**
   * Registers callbacks that will be called when their corresponding events occur.
   * @param callbacks object with property names set to corresponding functions to be called when the event occurs.
   */
  setCallbacks(n) {
    this._callbackManager.bind(n);
  }
  /**
   * Unregisters callbacks from the system. Note the actual function object passed in must be the same as the one that was registered using setCallbacks.
   * @param callbacks object with property names set to corresponding functions to be unregistered.
   */
  unsetCallbacks(n) {
    this._callbackManager.unbind(n);
  }
  /**
   * This method should be called after the container element is moved or resized.
   */
  resizeCanvas() {
    this._alreadyShutDown || (this._engine.resize(), this._inputMonitor.elementResize());
  }
  /**
   * This method should be called when the viewer is being moved to a new window. An example use case would be opening a new pop up window.
   * @param win the new document that this viewer will be associated with.
   */
  moveToWindow(n) {
    this._inputMonitor.setDocument(n.document);
  }
  /**
   * Forces the viewer to perform a full redraw.
   * @param callback A function to be called once the draw is complete.
   * This is provided instead of a `Promise` to ensure the callback is
   * called before the start of another redraw.
   */
  redraw(n) {
    if (n) {
      const t = () => {
        this._callbackManager.unbind({ _drawComplete: t }), n();
      };
      this._callbackManager.bind({ _drawComplete: t });
    }
    this._engine.redraw();
  }
  /**
   * Selects a part with the given Id.
   * @param nodeId nodeId of the part to select. Pass null to clear the selection.
   */
  selectPart(n, t = ai.Set) {
    return this.selectionManager.selectNode(n, t);
  }
  /**
   * Used to trigger Web Viewer events from operators. Refer to the overloaded method signatures for acceptable invocations of this method. Refer to [[CallbackMap]] for additional details for each event.
   * @param name
   * @param args
   */
  trigger(n, ...t) {
    this._callbackManager.unsafeTrigger(n, t);
  }
  /** @hidden */
  _getCallbackManager() {
    return this._callbackManager;
  }
  /** @hidden */
  _setStreamIdleMarker() {
    return this._engine.setStreamIdleMarker();
  }
  /**
   * Gets viewer statistics for the current rendered frame. Statistics marked with a (*) below must be calculated and will not be included in the results unless the calculateTotals parameter is true.
   * The values of these items will be cached and only updated during the next call to this method with calculateTotals set to true.
   * @param calculateTotals Forces an update of the total count elements. Please note that repeatedly calculating these items can cause a performance impact.
   * @returns an object containing informational key/value pairs
   *
   * | Statistic Name| Description                                          |
   * | ----------------------- | -----------------------------------------------------|
   * | draw_call_count  | number of draw calls made when rendering the frame             |
   * | frames_per_second  | frames per second estimation    |
   * | triangle_count  | the number of triangles rendered    |
   * | line_segment_count  | the number of line segments rendered    |
   * | point_count  | the number of points rendered    |
   * | total_element_count(*)  | the total number of elements in the scene    |
   * | total_triangle_count(*)  | the total number of triangles in the scene   |
   *
   */
  getStatistics(n = !1) {
    return this._engine.getStatistics(n);
  }
  /**
   * Sets a minimum frame rate that will be maintained by the viewer.
   * The viewer will use various culling techniques in order to maintain the value passed in.
   *
   * Passing `0` will cause the entire scene to be drawn for every frame.
   * @param value The frame rate for the viewer to maintain.
   * @returns Promise that is resolved when the operation has completed.
   */
  setMinimumFramerate(n) {
    return this._setMinimumFramerate(n), Promise.resolve();
  }
  _setMinimumFramerate(n) {
    this._engine.setMinimumFramerate(n);
  }
  /**
   * Gets the minimum framerate that will be maintained by the viewer. The viewer will use various culling techniques in order to maintain the value returned.
   * @returns Promise that is resolved when the operation has completed.
   */
  getMinimumFramerate() {
    return this._engine.getMinimumFramerate();
  }
  /**
   * Sets the image quality settings for the high quality and low quality server side render. The low quality settings will be applied during model interaction (camera changes, selection, etc)
   * @param jpegQualityLow The JPEG quality of the low quality render frame
   * @param jpegQualityHigh The JPEG quality of the high quality render frame
   * @param scaleLow The scale factor for the low quality render frame
   * @param scaleHigh The scale factor for the high quality render frame
   */
  setServerRenderQuality(n, t, e, i) {
    return this._engine.setServerRenderQuality(
      n,
      t,
      e,
      i
    );
  }
  /**
   * Gets the streaming mode this viewer was created with.
   * @returns the streaming mode.
   */
  getStreamingMode() {
    return this._streamingMode;
  }
  /**
   * Gets the RendererType this viewer was created with.
   * @returns the render mode.
   */
  getRendererType() {
    return this._engine.getRendererType();
  }
  /**
   * Gets the view element for this viewer. This element contains the canvas
   * @returns the view element
   */
  getViewElement() {
    return this._domElements.getCanvasContainerElement();
  }
  /**
   * Releases the resources used by the viewer. This method should be called when the viewer is no longer needed but the page is not being reloaded.
   */
  shutdown() {
    if (!this._alreadyShutDown) {
      if (this._shutdownTimer.clear(), !this._modelStructure.isReady() && !this._modelLoadFailure) {
        this._shutdownTimer.set(500, () => {
          this.shutdown();
        });
        return;
      }
      this._callbackManager.trigger("_shutdownBegin"), this.operatorManager._shutdown(), this._inputMonitor.shutdown(), this.markupManager._shutdown(), this._timeoutMonitor.shutdown(), this._modelStructure.shutdown(), this._domElements.shutdown(), this._engine.shutdown(), this.animationManager._shutdown(), this._alreadyShutDown = !0;
    }
  }
  /**
   * Sets the parameters for client driven timeout monitoring.
   * If no input is recorded for the the duration, the viewer will disconnect and free server resources.
   * Calling this method will reset any pending timeout duration.
   * No timeout will occur when viewing SCS Files.
   * The default value is to disconnect after 15 minutes, with a warning issued after 14 minutes of inactivity.
   * <br><br> <strong>Please note:</strong> Both parameters are required.
   * @param timeoutDuration the total time in minutes of inactivity that is allowed before a timeout event occurs
   * @param warningTime the number of minutes before issuing a timeoutWarning event
   * @returns boolean value indicating whether the timeout values were sucessfully updated
   */
  setClientTimeout(n, t) {
    return this._timeoutMonitor.setTimeoutDurations(n, t);
  }
  /**
   * Resets the client timeout to the duration set with setClientTimeout.
   */
  resetClientTimeout() {
    this._timeoutMonitor.resetTimeout();
  }
  /**
   * Pauses rendering updates for the viewer. This function is useful when
   * performing large batches of updates and you would like the result
   * to appear all at once.
   *
   * @param callback If provided, rendering will be paused, the callback
   * will be called, and then rendering will be resumed once the callback
   * returns or throws an exception.
   */
  pauseRendering(n) {
    return this._pauseRendering(n), Promise.resolve();
  }
  _pauseRendering(n) {
    this._engine.pauseRendering(n);
  }
  /**
   * Resumes rendering in the viewer.
   */
  resumeRendering() {
    return this._resumeRendering(), Promise.resolve();
  }
  _resumeRendering() {
    this._engine.resumeRendering();
  }
  /**
   * Delays capping processing by a fixed time interval.
   */
  delayCapping() {
    this.cuttingManager.delayCapping();
  }
  /**
   * Reset the camera, visibility, and transforms to their default state
   * @param duration the amount of time in milliseconds that the camera transition between the current and initial view should take.
   * @returns Promise that resolves when the operation has completed.
   */
  async reset(n = Ni) {
    await this.model.reset();
    const t = this.model.getDefaultCadView() !== null;
    this.model.getDefaultCadConfiguration() !== null && await this._modelStructure.cadConfigurationsEnabled() ? await this.model.activateDefaultCadConfiguration(!t) : !this.sheetManager.isDrawingSheetActive() && !t && await this.view.resetCamera(n), t && await this.model.activateDefaultCadView(n);
  }
  /**
   * Disconnects the network connection when in CSR mode.
   */
  closeConnection() {
    this.view.setCamera(this.view.getCamera()), this._engine.disconnectNetwork(), this._timeoutMonitor.shutdown();
  }
  /**
   * Controls rendering on high DPI displays. If true, the image will be rendered at full resolution when a high-DPI display is detected. If false, the image may be rendered at a lower resolution. The default value is false.
   * This method may be called any time during or after the sceneReady callback has triggered.
   * @param allow controls the high DPI Setting.
   */
  setAllowHighDpi(n) {
    this._engine.setAllowHighDpi(n);
  }
  /**
   * Gets the current value for high DPI rendering
   * @returns current high DPI setting
   */
  getAllowHighDpi() {
    return this._engine.getAllowHighDpi();
  }
  /**
   * Creates an Image of the current canvas
   */
  takeSnapshot(n = new by()) {
    const t = be(), e = new V0(this._domElements, n), i = this._domElements.getCanvasContainerElement(), s = this._domElements.getRedlineElement(), r = n.width > 0 && n.height > 0;
    if (r) {
      const a = `${100 * (n.width / i.clientWidth)}%`, l = `${100 * (n.height / i.clientHeight)}%`;
      i.style.width = a, i.style.height = l, s.style.width = a, s.style.height = l;
    }
    const o = this.getAllowHighDpi();
    return this._engine.setAllowHighDpi(!1), this._engine.resize(), this.redraw(async () => {
      const a = await e.capture(i);
      r && (i.style.width = "100%", i.style.height = "100%", s.style.width = "100%", s.style.height = "100%"), this._engine.setAllowHighDpi(o), this._engine.resize(), t.resolve(a);
    }), t;
  }
  fitWorld(n = Ni) {
    return this.view.fitWorld(n);
  }
  /**
   * Sets the orientation of the current model view.
   * @param orientation a [[ViewOrientation]] object specifying back, front, top, etc.
   * @param duration the time in milliseconds for the model to transition to the new view orientation.
   */
  async setViewOrientation(n, t = Ni) {
    await this.view.setViewOrientation(n, t), this._eventDispatcher.injectViewOrientationChangeEvent();
  }
  _applyMetallicRoughnessDefaults() {
    let n = 1, t = 1, e = !1;
    this._params.defaultMetallicFactor != null && (n = this._params.defaultMetallicFactor, e = !0), this._params.defaultRoughnessFactor != null && (t = this._params.defaultRoughnessFactor, e = !0), e && this._engine.setMetallicRoughnessMaterialOverride(
      n,
      t
    );
  }
  async _scEngineReady() {
    console.assert(this._modelStructure.isReady());
    const n = this.model.getAbsoluteRootNode(), t = this._engine.getSessionType();
    try {
      this.cuttingManager._init(), await this._sceneReadyPromise, await this._callbackManager.promiseTrigger("_assemblyTreeReady", "assemblyTreeReady");
      let e = "";
      try {
        const i = new mr();
        i._allowSubtreeLoadedCallback = !1;
        let s = 0;
        if (this._applyMetallicRoughnessDefaults(), t === Oe.Network)
          e = this._engine.getNetworkModelName(), e === or || await this.model.loadSubtreeFromModel(n, e, i);
        else if (t === Oe.Scs) {
          this._timeoutMonitor.shutdown();
          const r = this._engine.getScsInfo();
          typeof r == "string" ? await this.model.loadSubtreeFromScsFile(n, r, i) : r !== null && await this.model.loadSubtreeFromScsBuffer(n, r, i), this._params.streamCutoffScale !== void 0 && (s = this._params.streamCutoffScale);
        } else
          throw new re();
        this._modelStructure.setPrefetchScsCutoffScale(s);
      } catch (i) {
        throw this._callbackManager.trigger("modelLoadFailure", e, `${i}`, i), i;
      }
    } finally {
      return console.assert(this._modelStructure.isReady()), this._callbackManager.promiseTrigger("_modelStructureReady", "modelStructureReady");
    }
  }
  _sceneReady() {
    this._inputMonitor.bindEvents(this._domElements.getCanvasContainerElement()), this.selectionManager._init(), this._callbackManager.bind({
      _timeout: () => {
        this.shutdown();
      }
    }), this._callbackManager.trigger("sceneReady"), this._sceneReadyPromise && this._sceneReadyPromise.resolve();
  }
  _priorityMetaDataSent(n, t) {
    if (this._callbackManager.trigger("_priorityMetaDataSent", n, t), !this._seenPriorityMetaDataSent) {
      if (n !== lr.OfInitialEmptyModel || t !== 0)
        throw new re();
      this._seenPriorityMetaDataSent = !0, this._callbackManager.trigger("_attached", lr.OfInitialEmptyModel);
    }
  }
  _renderComplete() {
    this.markupManager._update();
  }
  _streamingActivated() {
    this._callbackManager.trigger("streamingActivated");
  }
  _streamingDeactivated() {
    this._callbackManager.trigger("streamingDeactivated");
  }
  /**
   * Specifies a scale factor that will be applied to the streaming size cutoff.
   * An object whose projected size is lower than the cutoff will not be streamed
   * until its projected size reaches the cutoff.
   *
   * This value may also be set for file-based sessions.  In that case, when loading
   * an SCS file based assembly via XML, projected size will be calculated on a
   * per-file basis using the bounding information provided in the XML.
   * For additional information, refer to [[Model.loadSubtreeFromXmlBuffer]].
   *
   * A value of 0 will disable the cutoff.  The value should be in the interval of [0.0, 2.0].
   */
  setStreamCutoffScale(n) {
    return this._setStreamCutoffScale(n), Promise.resolve();
  }
  _setStreamCutoffScale(n) {
    this._engine.setStreamCutoffScale(n), this._modelStructure.setPrefetchScsCutoffScale(n);
  }
  /**
   * Returns the scale factor that will be applied to the streaming size cutoff.
   * An object whose projected size is lower than the cutoff will not be streamed
   * until its projected size reaches the cutoff. A value of 0 disables the cutoff.
   */
  getStreamCutoffScale() {
    return this._engine.getStreamCutoffScale();
  }
  /** @hidden */
  _loseWebGlContext() {
    return this._engine.loseWebGlContext();
  }
  /** @hidden */
  _getScEngine() {
    return this._engine;
  }
  /** @hidden */
  _debug_log(n) {
    return this._engine.debug_log(n);
  }
  /** @hidden */
  _debug_stateFailure(n) {
    return this._engine.debug_stateFailure(n);
  }
  /** @hidden */
  _debug_sync() {
    return this._engine.debug_sync();
  }
  /**
   * Exports the current scene to a two-dimensional SVG representation.
   *
   * @param config Allows customization of the resultant SVG.
   * @return A promise that resolves to the created SVG string.
   */
  async exportToSvg(n = new yu()) {
    let t;
    this.cuttingManager._setStandinGeometryVisible(!1);
    try {
      await this.waitForIdle({ redraw: !1 }), t = await this._engine.exportToSvg(n);
    } finally {
      this.cuttingManager._setStandinGeometryVisible(!0);
    }
    return t;
  }
  /**
   * Setup the env to export the current scene to a two-dimensional SVG representation through stream.
   *
   * @param config Allows customization of the resultant SVG.
   * @return A promise that resolves to void when the env is ready.
   */
  async beginExportToSvg(n = new yu()) {
    this.cuttingManager._setStandinGeometryVisible(!1);
    try {
      await this.waitForIdle({ redraw: !1 }), await this._engine.beginExportToSvg(n);
    } catch {
      await this.endExportToSvg();
    }
  }
  /**
   * Reset the env after SVG stream export.
   *
   * @return A promise that resolves to void when the env is reset.
   */
  async endExportToSvg() {
    return this.cuttingManager._setStandinGeometryVisible(!0);
  }
  /**
   * Get the next chunk of the SVG code
   *
   * @return A promise that resolves to a string containing the next chunk or undefined on completed..
   */
  async advanceExportToSvg() {
    return this._engine.advanceExportToSvg();
  }
  /**
   * Returns a Promise that will resolve after streaming and associated
   * asynchronous operations complete and the scene is fully drawn.
   */
  async waitForIdle(n = {}) {
    if (this._alreadyShutDown)
      return;
    await this._setStreamIdleMarker();
    const t = [];
    if (this.cuttingManager.hasActiveCuttingSection() && (await this.cuttingManager.enableCappingIdleCallback(!0) || t.push(this.cuttingManager.waitForCappingIdle())), t.push(this._engine.waitForImageDecoding()), await Promise.all(t), n.redraw !== !1) {
      const e = be();
      this.redraw(() => {
        e.resolve();
      }), await e;
    }
  }
};
let Lp = Jh;
Lp.BUILD_ID = "<BUILD_ID>";
Lp.VIEWER_VERSION_STRING = `${yd(vh)} Build ${Jh.BUILD_ID}`;
export {
  B0 as Animation,
  Hd as AntiAliasingMode,
  pr as AssemblyDataParseError,
  Jn as AttributeType,
  Ht as Axis,
  Ds as AxisTriad,
  le as BasicUnit,
  J0 as Bcf,
  j0 as Bim,
  ei as BimMask,
  mn as BlurIntervalUnit,
  vs as BoundingPreviewMode,
  ni as Box,
  Pt as BranchVisibility,
  Vt as BuiltinOverlayIndex,
  Kt as Button,
  Ai as Buttons,
  ci as Camera,
  it as Color,
  Mt as CommunicatorError,
  S_ as CullingVectorSpace,
  hy as CuttingManager,
  _u as CuttingPlane,
  cy as CuttingSection,
  Ni as DefaultTransitionDuration,
  ih as DepthRange,
  xn as DrawMode,
  $d as DrawStrategy,
  vt as ElementType,
  or as EmptyModelName,
  q0 as Event,
  kt as EventType,
  uy as ExplodeManager,
  x_ as FaceFaceDistanceItem,
  kg as FaceMeshData,
  yn as FaceWinding,
  Vo as FileType,
  D0 as FilterId,
  pu as FilteredNodes,
  U0 as Floorplan,
  Vr as FloorplanOrientation,
  ws as HandleEventType,
  Bn as HandleType,
  Oi as ImageFormat,
  Dl as IncrementalPickConfig,
  I_ as InfoType,
  Fe as InstanceModifier,
  re as InternalLogicError,
  xh as InvalidIndexError,
  jd as InvalidNodeId,
  sn as InvalidNodeIdError,
  Vi as InvalidNodeTypeError,
  Ut as KeyCode,
  Mc as KeyInputType,
  ye as KeyModifiers,
  z0 as LayerId,
  dy as Light,
  my as LineManager,
  Z_ as LinePatternLengthUnit,
  Xl as LoadCancelledError,
  ts as LoadError,
  mr as LoadSubtreeConfig,
  $0 as Markup,
  gy as MarkupManager,
  Hl as MarkupTypeManager,
  Q as Matrix,
  fy as MeasureManager,
  Hi as MeshData,
  St as MeshInstanceCreationFlags,
  bn as MeshInstanceData,
  Fl as MissingModelError,
  Yo as Model,
  Gn as MouseInputType,
  gp as NavCube,
  ps as NodeSource,
  At as NodeType,
  qp as Ohm,
  Et as OperatorId,
  _y as OperatorManager,
  tI as Operators,
  fo as OrbitFallbackMode,
  H0 as Overlay,
  Jt as OverlayAnchor,
  Bt as OverlayUnit,
  fn as ParseError,
  Ie as PickConfig,
  Ms as PickOutsideCanvasError,
  je as Plane,
  Qd as PmiSubType,
  $o as PmiTopoRef,
  Ud as PmiType,
  E as Point2,
  d as Point3,
  jn as Point4,
  Wg as PointMeshData,
  Pc as PointShape,
  Wc as PointSizeUnit,
  Mg as PolylineMeshData,
  te as Projection,
  Ti as Quaternion,
  Vn as Ray,
  v_ as RefOnTopoItem,
  qd as RelationshipType,
  qo as RendererType,
  R0 as Sc,
  b_ as ScreenConfiguration,
  Q0 as Selection,
  Ln as SelectionHighlightMode,
  as as SelectionInvalidatedError,
  Xt as SelectionMask,
  ai as SelectionMode,
  pi as SelectionType,
  yy as SheetManager,
  Gc as SimpleReflectionAttenuationUnit,
  by as SnapshotConfig,
  To as SnapshotLayer,
  Ps as StreamingMode,
  Go as SubentityAttributes,
  Qp as Subscript1,
  tu as Subscript2,
  eu as Subscript3,
  ic as SubscriptNeg,
  yu as SvgConfig,
  W_ as TextureModifier,
  M_ as TextureParameterization,
  Yc as TextureTiling,
  tl as TouchInputType,
  w_ as TransparencyMode,
  k_ as TreeWalkMode,
  N0 as Util,
  fp as VerticalGradient,
  Sy as View,
  mu as ViewAxes,
  et as ViewOrientation,
  C_ as VisibilityState,
  Ot as WalkDirection,
  _o as WalkMode,
  Lp as WebViewer,
  ta as XRayGroup,
  ce as XmlParseError,
  rg as closestPointFromPointToSegment,
  Hu as closestPointScalarFromPointToSegment,
  Yn as computeAngleBetweenVector,
  lo as computeOffaxisRotation,
  ss as computePointToLineDistance,
  Qi as createUuid,
  cs as degreesToRadians,
  sg as distanceLineLine,
  Eo as formatWithUnit,
  yc as generateArcPoints,
  ng as generatePointsOnCircle,
  lg as getLongUnitString,
  eg as intersect3d2Planes,
  Ts as intersectionPlaneLine,
  Ju as intersectionPlaneLine2,
  hg as isIColor,
  Du as isIPoint2,
  zu as isIPoint3,
  E0 as isIPoint4,
  Uu as isPointInRect2d,
  og as isPointOnLineSegment,
  co as isPointOnLineSegment2d,
  ju as lineLineIntersect,
  Bu as oneVectorCross,
  Vl as radiansToDegrees
};
