function tv(s, t) {
  for (var e = 0; e < t.length; e++) {
    const i = t[e];
    if (typeof i != "string" && !Array.isArray(i)) {
      for (const n in i)
        if (n !== "default" && !(n in s)) {
          const r = Object.getOwnPropertyDescriptor(i, n);
          r && Object.defineProperty(s, n, r.get ? r : {
            enumerable: !0,
            get: () => i[n]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(s, Symbol.toStringTag, { value: "Module" }));
}
const ev = "¹", Tp = "²", Np = "³", of = "⁻", iv = "Ω";
var di = /* @__PURE__ */ ((s) => (s[s.unitUnknown = 0] = "unitUnknown", s[s.unitLength = 1] = "unitLength", s[s.unitMass = 2] = "unitMass", s[s.unitTime = 3] = "unitTime", s[s.unitElectricCurrent = 4] = "unitElectricCurrent", s[s.unitThermoTemperature = 5] = "unitThermoTemperature", s[s.unitSubstanceAmount = 6] = "unitSubstanceAmount", s[s.unitLuminosityIntensity = 7] = "unitLuminosityIntensity", s[s.unitPlaneAngle = 8] = "unitPlaneAngle", s[s.unitSolidAngle = 9] = "unitSolidAngle", s[s.unitFrequency = 10] = "unitFrequency", s[s.unitForce = 11] = "unitForce", s[s.unitPressure = 12] = "unitPressure", s[s.unitEnergy = 13] = "unitEnergy", s[s.unitPower = 14] = "unitPower", s[s.unitElectricCharge = 15] = "unitElectricCharge", s[s.unitElectromotiveForce = 16] = "unitElectromotiveForce", s[s.unitCapacitance = 17] = "unitCapacitance", s[s.unitElectricResistance = 18] = "unitElectricResistance", s[s.unitElectricConductance = 19] = "unitElectricConductance", s[s.unitMagneticFlux = 20] = "unitMagneticFlux", s[s.unitMagneticFluxDensity = 21] = "unitMagneticFluxDensity", s[s.unitInductance = 22] = "unitInductance", s[s.unitLuminousFlux = 23] = "unitLuminousFlux", s[s.unitIlluminance = 24] = "unitIlluminance", s[s.unitActivityRadionuclide = 25] = "unitActivityRadionuclide", s[s.unitKerma = 26] = "unitKerma", s[s.unitDoseEquivalent = 27] = "unitDoseEquivalent", s[s.unitCatalyticActivity = 28] = "unitCatalyticActivity", s))(di || {});
function xm(s) {
  return s !== null && typeof s == "object" && "x" in s && typeof s.x == "number" && "y" in s && typeof s.y == "number";
}
function Im(s) {
  return s !== null && typeof s == "object" && "z" in s && typeof s.z == "number" && xm(s);
}
function HC(s) {
  return s !== null && typeof s == "object" && "w" in s && typeof s.w == "number" && Im(s);
}
class _ {
  /**
   * Creates a new point object.
   * @param x X value
   * @param y Y value
   * @param z Z value
   */
  constructor(t, e, i) {
    this.x = t, this.y = e, this.z = i;
  }
  /**
   * Sets this point equal to another point.
   * @param point The point to assign.
   * @returns This point object.
   */
  assign(t) {
    return this.x = t.x, this.y = t.y, this.z = t.z, this;
  }
  /**
   * Sets the values of this point.
   * @param x X value to set.
   * @param y Y value to set.
   * @param z Z value to set.
   * @returns This point object.
   */
  set(t, e, i) {
    return this.x = t, this.y = e, this.z = i, this;
  }
  /**
   * Sets an array from this point.
   * @param arr Array to assign.
   */
  toArray(t = [0, 0, 0]) {
    return t[0] = this.x, t[1] = this.y, t[2] = this.z, t;
  }
  /**
   * Sets this point from an array.
   * @param arr Array to assign from.
   * @returns This point object.
   */
  fromArray(t) {
    return this.x = t[0], this.y = t[1], this.z = t[2], this;
  }
  /**
   * Adds another point to this point.
   * @param point Point to add.
   * @returns This point object.
   */
  add(t) {
    return this.x += t.x, this.y += t.y, this.z += t.z, this;
  }
  /**
   * Subtracts another point from this point.
   * @param point Point to subtract.
   * @returns This point object.
   */
  subtract(t) {
    return this.x -= t.x, this.y -= t.y, this.z -= t.z, this;
  }
  /**
   * Creates a copy of this point.
   * @returns Copy of this point object.
   */
  copy() {
    return new _(this.x, this.y, this.z);
  }
  /**
   * Creates a new [[Point3]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t) {
    if (Im(t))
      return new _(t.x, t.y, t.z);
    throw new TypeError("Point3.fromJson: data does not satisfy type IPoint3 constraints");
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return {
      x: this.x,
      y: this.y,
      z: this.z
    };
  }
  /**
   * Strictly compares this point with another.
   * @param other Point to compare with.
   * @returns True if the values of this point equal those of the other.
   */
  equals(t) {
    return this.x === t.x && this.y === t.y && this.z === t.z;
  }
  /**
   * Compares this point with another using a tolerance.
   * @param other Point to compare with.
   * @param tolerance Tolerance to be used in the comparison.
   * @returns True if the values of this point equal those of the other.
   */
  equalsWithTolerance(t, e) {
    return Math.abs(this.x - t.x) < e && Math.abs(this.y - t.y) < e && Math.abs(this.z - t.z) < e;
  }
  /**
   * Returns a boolean value indicating if this vector lies on a major axis.
   */
  isAxis() {
    return Math.abs(this.x) === 1 && this.y === 0 && this.z === 0 || this.x === 0 && Math.abs(this.y) === 1 && this.z === 0 || this.x === 0 && this.y === 0 && Math.abs(this.z) === 1;
  }
  /**
   * Returns the length of this vector.
   * @returns Vector length.
   */
  length() {
    return Math.sqrt(this.squaredLength());
  }
  /**
   * Returns the squared length of this vector.
   * @returns Vector squared length.
   */
  squaredLength() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  /**
   * Scale the point by constant value.
   * @param k Constant value to scale by.
   * @returns Point object.
   */
  scale(t) {
    return this.x *= t, this.y *= t, this.z *= t, this;
  }
  /**
   * Normalizes the vector.
   * @returns This object.
   */
  normalize() {
    const t = this.length();
    return t === 0 ? this : this.scale(1 / t);
  }
  /**
   * Negates the point.
   * @returns This object.
   */
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this;
  }
  /**
   * Creates a new Point initialized to (0,0,0).
   * @returns New point with all elements set to 0.
   */
  static zero() {
    return new _(0, 0, 0);
  }
  /**
   * Adds two points.
   * @param p1 First point.
   * @param p2 Second point.
   * @returns Sum of p1 and p2.
   */
  static add(t, e) {
    return new _(t.x + e.x, t.y + e.y, t.z + e.z);
  }
  /**
   * Subtract two points.
   * @param p1 First point.
   * @param p2 Second point.
   * @returns Difference of p1 and p2.
   */
  static subtract(t, e) {
    return new _(t.x - e.x, t.y - e.y, t.z - e.z);
  }
  /**
   * Calculate dot product.
   * @param p1 First point.
   * @param p2 Second point.
   * @returns Dot product of p1 and p2.
   */
  static dot(t, e) {
    return t.x * e.x + t.y * e.y + t.z * e.z;
  }
  /**
   * Calculate cross product.
   * @param p1 First point.
   * @param p2 Second point.
   * @returns Cross product of p1 and p2.
   */
  static cross(t, e) {
    return new _(
      t.y * e.z - t.z * e.y,
      t.z * e.x - t.x * e.z,
      t.x * e.y - t.y * e.x
    );
  }
  /**
   * Calculate distance between two points
   * @param p1 First point
   * @param p2 Second point
   * @returns Distance between p1 and p2
   */
  static distance(t, e) {
    return _.subtract(e, t).length();
  }
  /**
   * Scale a point by a constant factor
   * @param p1 Point to scale
   * @param k Constant value to scale byS
   * @returns Copy of p scaled by a constant factor
   */
  static scale(t, e) {
    return t.copy().scale(e);
  }
  /**
   * Creates a point from an array of numbers
   * @param Array to assign from
   * @returns new point set from array elements
   */
  static createFromArray(t) {
    return new _(t[0], t[1], t[2]);
  }
}
class Hr {
  constructor(t, e, i, n) {
    this.x = t, this.y = e, this.z = i, this.w = n;
  }
  scale(t) {
    return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this;
  }
  set(t, e, i, n) {
    this.x = t, this.y = e, this.z = i, this.w = n;
  }
  assign(t) {
    this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w;
  }
  static zero() {
    return new Hr(0, 0, 0, 0);
  }
  /**
   * Strictly compares this point with another.
   * @param other Point to compare with.
   * @returns True if the values of this point equal those of the other.
   */
  equals(t) {
    return this.x === t.x && this.y === t.y && this.z === t.z;
  }
  /**
   * Compares this point with another using a tolerance.
   * @param other Point to compare with.
   * @param tolerance Tolerance to be used in the comparison.
   * @returns True if the values of this point equal those of the other.
   */
  equalsWithTolerance(t, e) {
    return Math.abs(this.x - t.x) < e && Math.abs(this.y - t.y) < e && Math.abs(this.z - t.z) < e;
  }
}
let mt = class ar {
  /**
   * Creates a new matrix set to the identity matrix.
   */
  constructor() {
    this.loadIdentity();
  }
  /**
   * Sets the matrix to the identity matrix.
   * @returns This matrix object.
   */
  loadIdentity() {
    return this.m = [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ], this;
  }
  isIdentity() {
    const t = this.m;
    return t[0] === 1 && t[1] === 0 && t[2] === 0 && t[3] === 0 && t[4] === 0 && t[5] === 1 && t[6] === 0 && t[7] === 0 && t[8] === 0 && t[9] === 0 && t[10] === 1 && t[11] === 0 && t[12] === 0 && t[13] === 0 && t[14] === 0 && t[15] === 1;
  }
  /**
   * Strictly compares this matrix with another.
   * @param other Matrix to compare with.
   * @returns True if the values of this matrix equal those of the other.
   */
  equals(t) {
    for (let e = 0; e < 16; ++e) {
      const i = this.m[e], n = t.m[e];
      if (i !== n)
        return !1;
    }
    return !0;
  }
  /**
   * Compares this matrix with another using a tolerance.
   * @param other Matrix to compare with.
   * @param tolerance Tolerance to be used in the comparison.
   * @returns True if the values of this matrix equal those of the other.
   */
  equalsWithTolerance(t, e) {
    e = Math.abs(e);
    for (let i = 0; i < 16; ++i)
      if (Math.abs(this.m[i] - t.m[i]) > e)
        return !1;
    return !0;
  }
  /**
   * Sets the scale components of this matrix.
   * @param x X scale value.
   * @param y Y scale value.
   * @param z Z scale value.
   * @returns This matrix object.
   */
  setScaleComponent(t, e, i) {
    return this.m[0] = t, this.m[5] = e, this.m[10] = i, this;
  }
  /**
   * Sets the translation components of this matrix.
   * @param x X translation value.
   * @param y Y translation value.
   * @param z Z translation value.
   * @returns This matrix object.
   */
  setTranslationComponent(t, e, i) {
    return this.m[12] = t, this.m[13] = e, this.m[14] = i, this;
  }
  /**
   * Creates a copy of this matrix.
   * @returns Copy of this matrix.
   */
  copy() {
    const t = new ar();
    return t.m = this.m.slice(), t;
  }
  /**
   * Sets the value of this matrix to another.
   * @param matrix the matrix whose values will be set.
   * @returns This matrix object.
   */
  assign(t) {
    for (let e = 0; e < t.m.length; e++)
      this.m[e] = t.m[e];
    return this;
  }
  /**
   * Multiply the matrix by given scalar.
   * @param scalar Scalar to multiply the matrix with.
   * @return This matrix object.
   */
  multiplyByScalar(t) {
    for (let e = 0; e < 16; e++)
      this.m[e] *= t;
    return this;
  }
  /**
   * Transforms a point according to this matrix. The source and destination points are allowed to be the same object.
   * @param point The point to be transformed.
   * @param result A Point3 which can hold the result of the transformation.
   * @returns A new point if result is undefined, result otherwise.
   */
  transform(t, e) {
    return e = e ?? _.zero(), e.set(
      t.x * this.m[0] + t.y * this.m[4] + t.z * this.m[8] + this.m[12],
      t.x * this.m[1] + t.y * this.m[5] + t.z * this.m[9] + this.m[13],
      t.x * this.m[2] + t.y * this.m[6] + t.z * this.m[10] + this.m[14]
    ), e;
  }
  /**
   * Transforms a point according to this matrix. The source and destination points are allowed to be the same object.
   * @param point The point to be transformed.
   * @param result A Point3 which can hold the result of the transformation.
   * @returns A new point if result is undefined, result otherwise.
   */
  transform4(t, e) {
    return e = e ?? Hr.zero(), e.set(
      t.x * this.m[0] + t.y * this.m[4] + t.z * this.m[8] + this.m[12] * t.w,
      t.x * this.m[1] + t.y * this.m[5] + t.z * this.m[9] + this.m[13] * t.w,
      t.x * this.m[2] + t.y * this.m[6] + t.z * this.m[10] + this.m[14] * t.w,
      t.x * this.m[3] + t.y * this.m[7] + t.z * this.m[11] + this.m[15] * t.w
    ), e;
  }
  /**
   * Transforms an array of points according to this matrix.
   * @param inPoints an array of points to be transformed.
   * @param outPoints an array that will be populated with transformed points. Note that the results will be pushed onto the end of the array.
   */
  transformArray(t, e) {
    for (let i = 0; i < t.length; i++) {
      const n = t[i], r = new _(
        n.x * this.m[0] + n.y * this.m[4] + n.z * this.m[8] + this.m[12],
        n.x * this.m[1] + n.y * this.m[5] + n.z * this.m[9] + this.m[13],
        n.x * this.m[2] + n.y * this.m[6] + n.z * this.m[10] + this.m[14]
      );
      e[i] = r;
    }
  }
  transformBox(t) {
    if (t.isDegenerate())
      return yn.invalid();
    const e = t.getCorners();
    for (const n of e)
      this.transform(n, n);
    const i = new yn(e[0], e[0]);
    for (let n = 1; n < e.length; ++n) {
      const r = e[n];
      i.addPoint(r);
    }
    return i;
  }
  /**
   * Sets this matrix equal to its transpose.
   * @returns This matrix object.
   */
  // prettier-ignore
  transpose() {
    let t;
    return t = this.m[1], this.m[1] = this.m[4], this.m[4] = t, t = this.m[2], this.m[2] = this.m[8], this.m[8] = t, t = this.m[3], this.m[3] = this.m[12], this.m[12] = t, t = this.m[6], this.m[6] = this.m[9], this.m[9] = t, t = this.m[7], this.m[7] = this.m[13], this.m[13] = t, t = this.m[11], this.m[11] = this.m[14], this.m[14] = t, this;
  }
  /**
   * Creates a matrix from an array of numbers.
   * @param arr 16 element array of numbers.
   * @returns New matrix with elements set to the values of the array parameter. Array elements will be in column-major order.
   */
  static createFromArray(t) {
    const e = new ar();
    return e.m = t.slice(), e;
  }
  /**
   * Creates a rotation matrix from an arbitrary axis.
   * @param axis Axis to rotate about.
   * @param degrees Amount of degrees to rotate about the provided axis.
   * @returns Rotation matrix which represents the rotation about the supplied axis.
   */
  static createFromOffAxisRotation(t, e) {
    const i = e * (Math.PI / 180), n = Math.sin(i), r = Math.cos(i), o = new ar(), l = t.copy().normalize(), h = 1 - r, u = h * l.x * l.y, d = h * l.x * l.z, g = h * l.y * l.z;
    return o.m[0] = h * l.x * l.x + r, o.m[1] = n * l.z + u, o.m[2] = d - n * l.y, o.m[3] = 0, o.m[4] = u - n * l.z, o.m[5] = h * l.y * l.y + r, o.m[6] = n * l.x + g, o.m[7] = 0, o.m[8] = n * l.y + d, o.m[9] = g - n * l.x, o.m[10] = h * l.z * l.z + r, o.m[11] = 0, o.m[12] = 0, o.m[13] = 0, o.m[14] = 0, o.m[15] = 1, o;
  }
  /**
   * Creates a matrix from three [[Point3]]s, which will be used as the
   * columns of the matrix.
   *
   * @param xAxis The first column.
   * @param yAxis The second column.
   * @param zAxis The third column.
   */
  static createFromBasis(t, e, i) {
    const n = new ar();
    return n.m[0] = t.x, n.m[1] = t.y, n.m[2] = t.z, n.m[4] = e.x, n.m[5] = e.y, n.m[6] = e.z, n.m[8] = i.x, n.m[9] = i.y, n.m[10] = i.z, n;
  }
  /**
   * Multiplies two matrices.
   *
   * (p' = ABp <=> p' = multiply(B, A).transform(p))
   *
   * @param m1 The first matrix.
   * @param m2 The second matrix.
   * @returns Matrix which is the result of the multiplication.
   */
  static multiply(t, e) {
    const i = new ar();
    return i.m[0] = t.m[0] * e.m[0] + t.m[1] * e.m[4] + t.m[2] * e.m[8] + t.m[3] * e.m[12], i.m[1] = t.m[0] * e.m[1] + t.m[1] * e.m[5] + t.m[2] * e.m[9] + t.m[3] * e.m[13], i.m[2] = t.m[0] * e.m[2] + t.m[1] * e.m[6] + t.m[2] * e.m[10] + t.m[3] * e.m[14], i.m[3] = t.m[0] * e.m[3] + t.m[1] * e.m[7] + t.m[2] * e.m[11] + t.m[3] * e.m[15], i.m[4] = t.m[4] * e.m[0] + t.m[5] * e.m[4] + t.m[6] * e.m[8] + t.m[7] * e.m[12], i.m[5] = t.m[4] * e.m[1] + t.m[5] * e.m[5] + t.m[6] * e.m[9] + t.m[7] * e.m[13], i.m[6] = t.m[4] * e.m[2] + t.m[5] * e.m[6] + t.m[6] * e.m[10] + t.m[7] * e.m[14], i.m[7] = t.m[4] * e.m[3] + t.m[5] * e.m[7] + t.m[6] * e.m[11] + t.m[7] * e.m[15], i.m[8] = t.m[8] * e.m[0] + t.m[9] * e.m[4] + t.m[10] * e.m[8] + t.m[11] * e.m[12], i.m[9] = t.m[8] * e.m[1] + t.m[9] * e.m[5] + t.m[10] * e.m[9] + t.m[11] * e.m[13], i.m[10] = t.m[8] * e.m[2] + t.m[9] * e.m[6] + t.m[10] * e.m[10] + t.m[11] * e.m[14], i.m[11] = t.m[8] * e.m[3] + t.m[9] * e.m[7] + t.m[10] * e.m[11] + t.m[11] * e.m[15], i.m[12] = t.m[12] * e.m[0] + t.m[13] * e.m[4] + t.m[14] * e.m[8] + t.m[15] * e.m[12], i.m[13] = t.m[12] * e.m[1] + t.m[13] * e.m[5] + t.m[14] * e.m[9] + t.m[15] * e.m[13], i.m[14] = t.m[12] * e.m[2] + t.m[13] * e.m[6] + t.m[14] * e.m[10] + t.m[15] * e.m[14], i.m[15] = t.m[12] * e.m[3] + t.m[13] * e.m[7] + t.m[14] * e.m[11] + t.m[15] * e.m[15], i;
  }
  /**
   * Computes the determinant and inverse of a matrix, if possible.
   * @returns An array containing the inverse (or null if not invertible) followed by the determinant
   */
  inverseAndDeterminant() {
    const t = this.m[4] * this.m[9] - this.m[5] * this.m[8], e = this.m[4] * this.m[10] - this.m[6] * this.m[8], i = this.m[4] * this.m[11] - this.m[7] * this.m[8], n = this.m[4] * this.m[13] - this.m[5] * this.m[12], r = this.m[4] * this.m[14] - this.m[6] * this.m[12], o = this.m[4] * this.m[15] - this.m[7] * this.m[12], l = this.m[5] * this.m[10] - this.m[6] * this.m[9], h = this.m[5] * this.m[11] - this.m[7] * this.m[9], u = this.m[5] * this.m[14] - this.m[6] * this.m[13], d = this.m[5] * this.m[15] - this.m[7] * this.m[13], g = this.m[6] * this.m[11] - this.m[7] * this.m[10], y = this.m[6] * this.m[15] - this.m[7] * this.m[14], m = this.m[8] * this.m[13] - this.m[9] * this.m[12], x = this.m[8] * this.m[14] - this.m[10] * this.m[12], b = this.m[8] * this.m[15] - this.m[11] * this.m[12], I = this.m[9] * this.m[14] - this.m[10] * this.m[13], C = this.m[9] * this.m[15] - this.m[11] * this.m[13], P = this.m[10] * this.m[15] - this.m[11] * this.m[14], k = new ar();
    k.m[0] = this.m[5] * P - this.m[6] * C + this.m[7] * I, k.m[1] = this.m[2] * C - this.m[3] * I - this.m[1] * P, k.m[2] = this.m[1] * y - this.m[2] * d + this.m[3] * u, k.m[3] = this.m[2] * h - this.m[3] * l - this.m[1] * g, k.m[4] = this.m[6] * b - this.m[7] * x - this.m[4] * P, k.m[5] = this.m[0] * P - this.m[2] * b + this.m[3] * x, k.m[6] = this.m[2] * o - this.m[3] * r - this.m[0] * y, k.m[7] = this.m[0] * g - this.m[2] * i + this.m[3] * e, k.m[8] = this.m[4] * C - this.m[5] * b + this.m[7] * m, k.m[9] = this.m[1] * b - this.m[3] * m - this.m[0] * C, k.m[10] = this.m[0] * d - this.m[1] * o + this.m[3] * n, k.m[11] = this.m[1] * i - this.m[3] * t - this.m[0] * h, k.m[12] = this.m[5] * x - this.m[6] * m - this.m[4] * I, k.m[13] = this.m[0] * I - this.m[1] * x + this.m[2] * m, k.m[14] = this.m[1] * r - this.m[2] * n - this.m[0] * u, k.m[15] = this.m[0] * l - this.m[1] * e + this.m[2] * t;
    const O = k.m[0], B = -k.m[4], j = k.m[8], V = -k.m[12], Y = this.m[0] * O - this.m[1] * B + this.m[2] * j - this.m[3] * V;
    if (Y === 0)
      return [null, 0];
    const q = 1 / Y;
    return k.multiplyByScalar(q), [k, Y];
  }
  /**
   * Computes the inverse of a matrix if possible.
   * @param matrix Matrix whose inverse will be computed.
   * @returns Matrix set to the inverse of the supplied matrix.
   */
  static inverse(t) {
    return t.inverseAndDeterminant()[0];
  }
  /**
   * Computes the determinant of the upper-left 3x3 subsection of this matrix.
   */
  upperLeft3x3Determinant() {
    return this.m[0] * (this.m[5] * this.m[10] - this.m[9] * this.m[6]) - this.m[4] * (this.m[1] * this.m[10] - this.m[9] * this.m[2]) + this.m[8] * (this.m[1] * this.m[6] - this.m[5] * this.m[2]);
  }
  /**
   * @returns the version of this matrix suitable for applying to normals,
   * i.e. the inverse transpose of the upper-left 3x3 submatrix.
   */
  normalMatrix() {
    const t = this.copy().setTranslationComponent(0, 0, 0).inverseAndDeterminant()[0];
    return t ? t.transpose() : null;
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this.m.slice();
  }
  /**
   * Creates a new [[Matrix]] from an object given by [[toJson]].
   * @param An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t) {
    return ar.createFromArray(t);
  }
  /** @hidden */
  static toMatrix12(t) {
    return [t[0], t[1], t[2], t[4], t[5], t[6], t[8], t[9], t[10], t[12], t[13], t[14]];
  }
  /**
   * Returns the matrix for a clockwise rotation around the X-axis.
   * @param degrees The degrees of the rotation.
   * @returns The rotation matrix.
   */
  static xAxisRotation(t) {
    const e = new ar(), i = Fo(t), n = Math.cos(i), r = Math.sin(i);
    return e.m[5] = n, e.m[6] = -r, e.m[9] = r, e.m[10] = n, e;
  }
  /**
   * Returns the matrix for a clockwise rotation around the Y-axis.
   * @param degrees The degrees of the rotation.
   * @returns The rotation matrix.
   */
  static yAxisRotation(t) {
    const e = new ar(), i = Fo(t), n = Math.cos(i), r = Math.sin(i);
    return e.m[0] = n, e.m[2] = r, e.m[8] = -r, e.m[10] = n, e;
  }
  /**
   * Returns the matrix for a clockwise rotation around the Z-axis.
   * @param degrees The degrees of the rotation.
   * @returns The rotation matrix.
   */
  static zAxisRotation(t) {
    const e = new ar(), i = Fo(t), n = Math.cos(i), r = Math.sin(i);
    return e.m[0] = n, e.m[1] = -r, e.m[4] = r, e.m[5] = n, e;
  }
}, ln = class cc {
  constructor() {
    this.normal = _.zero(), this.d = 0;
  }
  setFromPointAndNormal(t, e) {
    return this.normal.assign(e), this.d = -_.dot(e, t), this;
  }
  /**
   * Update the plane to pass through the three points
   */
  setFromPoints(t, e, i) {
    this.normal = _.cross(_.subtract(e, t), _.subtract(i, t)).normalize(), this.d = -_.dot(t, this.normal);
  }
  setFromCoefficients(t, e, i, n) {
    this.normal.set(t, e, i), this.d = n;
  }
  getCoefficients() {
    const t = this.normal;
    return [t.x, t.y, t.z, this.d];
  }
  distanceToPoint(t) {
    return _.dot(this.normal, t) + this.d;
  }
  rayIntersection(t) {
    const e = _.zero();
    return this.intersectsRay(t, e) ? e : null;
  }
  intersectsRay(t, e) {
    const i = this.distanceToPoint(t.origin);
    if (Math.abs(i) <= 1e-6)
      return e && e.assign(t.origin), !0;
    const n = _.dot(this.normal, t.direction);
    if (Math.abs(n) <= 1e-6)
      return !1;
    const r = -i / n;
    if (r < 0)
      return !1;
    if (e) {
      const o = t.direction.copy().scale(r);
      e.set(t.origin.x + o.x, t.origin.y + o.y, t.origin.z + o.z);
    }
    return !0;
  }
  /**
   * Returns true if the point is on the side of the plane that the plane's normal is directed. Returns false otherwise.
   * @param p The point to test.
   */
  determineSide(t) {
    return this.normal.x * t.x + this.normal.y * t.y + this.normal.z * t.z + this.d > 0;
  }
  /**
   * Creates a copy of this plane
   * @returns a copy of this plane object
   */
  copy() {
    const t = new cc();
    return t.normal.assign(this.normal), t.d = this.d, t;
  }
  /**
   * Sets this plane equal to another plane
   * @param plane the plane to assign
   */
  assign(t) {
    this.normal.assign(t.normal), this.d = t.d;
  }
  /**
   * Returns true if the normal and d value are the same.
   * @param plane
   */
  equals(t) {
    return this.normal.equals(t.normal) && this.d === t.d;
  }
  static createFromPointAndNormal(t, e) {
    return new cc().setFromPointAndNormal(t, e);
  }
  static createFromPoints(t, e, i) {
    const n = new cc();
    return n.setFromPoints(t, e, i), n;
  }
  static createFromCoefficients(t, e, i, n) {
    const r = new cc();
    return r.setFromCoefficients(t, e, i, n), r;
  }
};
class K {
  /**
   * Creates a new point
   * @param {number} x value to set for x
   * @param {number} y value to set for y
   */
  constructor(t, e) {
    this.x = t, this.y = e;
  }
  /**
   * Sets this point equal to another point
   * @param {Point2} pt the point whose values will be used to set this object
   * @returns {Point2} the point object
   */
  assign(t) {
    return this.x = t.x, this.y = t.y, this;
  }
  /**
   * Adds a point to this one
   * @param {Point2} pt the point whose values will be added
   * @returns {Point2} the point object
   */
  add(t) {
    return this.x += t.x, this.y += t.y, this;
  }
  /**
   * Subtracts a point from this one
   * @param {Point2} pt the point whose values will be subtracted
   * @returns {Point2} the point object
   */
  subtract(t) {
    return this.x -= t.x, this.y -= t.y, this;
  }
  /**
   * Scales the point by a constant value
   * @param {number} k the value to scale by
   * @returns {Point2} the point object
   */
  scale(t) {
    return this.x *= t, this.y *= t, this;
  }
  /**
   * Compares this point with another point
   * @param {Point2} pt the point to compare with
   * @returns {Boolean} True if the values of this point equal the other. False otherwise.
   */
  equals(t) {
    return this.x === t.x && this.y === t.y;
  }
  /**
   * Sets the values of this point
   * @param {number} x value to set for x
   * @param {number} y value to set for y
   * @returns {Point2} the point object
   */
  set(t, e) {
    return this.x = t, this.y = e, this;
  }
  /**
   * Creates a copy of this point
   * @returns {Point} Copy of this point
   */
  copy() {
    return new K(this.x, this.y);
  }
  /**
   * Returns the length of this point
   * @returns {number} the point length
   */
  length() {
    return Math.sqrt(this.squaredLength());
  }
  /**
   * Returns the squared length of this vector.
   * @returns Vector squared length.
   */
  squaredLength() {
    return this.x * this.x + this.y * this.y;
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return {
      x: this.x,
      y: this.y
    };
  }
  /**
   * Creates a new [[Point2]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t) {
    if (xm(t))
      return new K(t.x, t.y);
    throw new TypeError("Point2.fromJson: data does not satisfy type IPoint2 constraints");
  }
  /**
   * Subtracts a point from another
   * @param {Point2} pt1 initial point
   * @param {Point2} pt2 the point to subtract
   * @returns {Point2} new point set to pt1 - pt2
   */
  static subtract(t, e) {
    return new K(t.x - e.x, t.y - e.y);
  }
  /**
   * Adds two points
   * @param {Point2} pt1 initial point
   * @param {Point2} pt2 the point to add
   * @returns {Point2} new point set to pt1 + pt2
   */
  static add(t, e) {
    return new K(t.x + e.x, t.y + e.y);
  }
  /**
   * Scale a point by a constant factor
   * @param {Point2} pt Point to be scaled
   * @param {number} k Amount to scale by
   * @returns {Point2} The scaled point
   */
  static scale(t, e) {
    return new K(t.x * e, t.y * e);
  }
  /**
   * Calculate distance between two points
   * @param {Point2} p1 first point
   * @param {Point2} p2 second point
   * @returns {number} the distance between p1 and p2
   */
  static distance(t, e) {
    return K.subtract(e, t).length();
  }
  /**
   * Creates a point initialized to (0,0)
   * @returns {Point} The new point
   */
  static zero() {
    return new K(0, 0);
  }
  static fromPoint3(t) {
    return new K(t.x, t.y);
  }
}
function nv(s) {
  const t = Math.abs(s.x), e = Math.abs(s.y), i = Math.abs(s.z);
  return t <= e && t <= i ? new _(1, 0, 0) : e <= t && e <= i ? new _(0, 1, 0) : new _(0, 0, 1);
}
function Cm(s, t) {
  const e = nv(s), i = _.cross(e, s);
  return t ? (t.assign(i), t) : i;
}
function Sm(s, t, e, i) {
  const n = e.normal.x * (t.x - s.x) + e.normal.y * (t.y - s.y) + e.normal.z * (t.z - s.z);
  if (Math.abs(n) < 1e-5)
    return !1;
  const r = -(e.d + e.normal.x * s.x + e.normal.y * s.y + e.normal.z * s.z) / n;
  return i.x = s.x + r * (t.x - s.x), i.y = s.y + r * (t.y - s.y), i.z = s.z + r * (t.z - s.z), !(r < 0 || r > 1);
}
function eo(s, t, e, i) {
  const n = _.subtract(e, t), r = n.squaredLength();
  let o = 0;
  r > 0 && (o = ((s.x - t.x) * (e.x - t.x) + (s.y - t.y) * (e.y - t.y) + (s.z - t.z) * (e.z - t.z)) / r), n.set(n.x * o, n.y * o, n.z * o), i.set(t.x + n.x, t.y + n.y, t.z + n.z);
  let l = new _(0, 0, 0);
  return l = _.subtract(s, i), l.length();
}
function sv(s) {
  return Math.abs(s - 25.4 / 72) < 0.01 ? "points" : Math.abs(s - 25.4) < 0.01 ? "inch" : Math.abs(s - 1) < 0.01 ? "mm" : Math.abs(s - 10) < 0.01 ? "cm" : Math.abs(s - 25.4 / 6) < 0.01 ? "picas" : Math.abs(s - 12 * 25.4) < 0.01 ? "ft" : Math.abs(s - 3 * 12 * 25.4) < 0.01 ? "yd" : Math.abs(s - 1e3) < 0.01 ? "m" : Math.abs(s - 1e6) < 0.01 ? "km" : Math.abs(s - 1760 * 3 * 12 * 25.4) < 0.01 ? "mi" : (console.log(`warning: unit multiplier doesn't map to known type: unit=${s}`), "");
}
function $c(s, t) {
  const e = sv(t);
  let i = "";
  for (let n = 2; n < 9 && (i = s.toFixed(n), parseFloat(i) === 0); n++)
    ;
  return parseFloat(i) === 0 && (i = "0"), i + e;
}
function Fo(s) {
  return s * (Math.PI / 180);
}
function rg(s) {
  return s * (180 / Math.PI);
}
function hc(s, t, e) {
  const i = s.copy().normalize(), n = Fo(t), r = Math.cos(n), o = Math.sin(n), l = 1 - r, h = l * i.x * i.y, u = l * i.x * i.z, d = l * i.y * i.z;
  return e === void 0 && (e = new mt()), e.m[0] = l * i.x * i.x + r, e.m[1] = o * i.z + h, e.m[2] = u - o * i.y, e.m[3] = 0, e.m[4] = h - o * i.z, e.m[5] = l * i.y * i.y + r, e.m[6] = o * i.x + d, e.m[7] = 0, e.m[8] = o * i.y + u, e.m[9] = d - o * i.x, e.m[10] = l * i.z * i.z + r, e.m[11] = 0, e.m[12] = 0, e.m[13] = 0, e.m[14] = 0, e.m[15] = 1, e;
}
function rv(s, t, e, i, n, r) {
  const o = _.cross(s.normal, e.normal), l = Math.abs(o.x), h = Math.abs(o.y), u = Math.abs(o.z);
  if (l + h + u < 1e-7) {
    const x = _.subtract(i, t);
    return _.dot(s.normal, x) === 0 ? 1 : 0;
  }
  let d;
  l > h ? l > u ? d = 1 : d = 3 : h > u ? d = 2 : d = 3;
  const g = _.zero(), y = -_.dot(s.normal, t), m = -_.dot(e.normal, i);
  switch (d) {
    case 1:
      g.x = 0, g.y = (m * s.normal.z - y * e.normal.z) / o.x, g.z = (y * e.normal.y - m * s.normal.y) / o.x;
      break;
    case 2:
      g.x = (y * e.normal.z - m * s.normal.z) / o.y, g.y = 0, g.z = (m * s.normal.x - y * e.normal.x) / o.y;
      break;
    case 3:
      g.x = (m * s.normal.y - y * e.normal.y) / o.z, g.y = (y * e.normal.x - m * s.normal.x) / o.z, g.z = 0;
  }
  return n.assign(g), r.set(g.x + o.x, g.y + o.y, g.z + o.z), 2;
}
function ov(s, t, e) {
  const i = new ln();
  return i.normal.x = (t.y - s.y) * (e.z - s.z) - (t.z - s.z) * (e.y - s.y), i.normal.y = (t.z - s.z) * (e.x - s.x) - (t.x - s.x) * (e.z - s.z), i.normal.z = (t.x - s.x) * (e.y - s.y) - (t.y - s.y) * (e.x - s.x), i.normal.normalize(), i.d = -i.normal.x * s.x - i.normal.y * s.y - i.normal.z * s.z, i;
}
function zo(s, t, e, i, n, r) {
  const o = ov(e, i, n);
  return Sm(s, t, o, r);
}
function yr(s, t) {
  const e = s.copy().normalize(), i = t.copy().normalize(), r = _.cross(e, i).length(), o = _.dot(e, i), l = Math.atan2(r, o);
  return rg(l);
}
function av(s, t, e, i, n) {
  const r = 2 * Math.PI / i;
  for (let d = 0; d < i; d++) {
    const y = e * Math.cos(r * d), m = e * Math.sin(r * d);
    s[d] = new _(0, y, m);
  }
  s[i] = s[0].copy();
  const o = Cm(n);
  o.normalize();
  const l = _.cross(o, n);
  l.normalize();
  const h = new mt(), u = h.m;
  u[0] = n.x, u[1] = n.y, u[2] = n.z, u[3] = 0, u[4] = o.x, u[5] = o.y, u[6] = o.z, u[7] = 0, u[8] = l.x, u[9] = l.y, u[10] = l.z, u[11] = 0, u[12] = 0, u[13] = 0, u[14] = 0, u[15] = 1, h.transformArray(s, s);
  for (let d = 0; d <= i; d++)
    s[d].set(
      s[d].x + t.x,
      s[d].y + t.y,
      s[d].z + t.z
    );
}
function lv(s, t, e, i, n, r) {
  const o = s, l = t, h = e, u = i;
  let d = 0, g = 0;
  const y = _.subtract(l, o), m = _.subtract(u, h), x = _.dot(y, o), b = _.dot(y, m), I = _.dot(y, y), C = _.dot(y, h), P = _.dot(m, m), k = _.dot(m, h), O = _.dot(m, o), B = _.dot(y, u), j = _.dot(m, l), V = I * P - b * b;
  if (V === 0) {
    let st, dt, U, J;
    I !== 0 ? (st = (C - x) / I, st < 0 ? st = 0 : st > 1 && (st = 1), U = (B - x) / I, U < 0 ? U = 0 : U > 1 && (U = 1)) : (st = 0, U = 0), P !== 0 ? (dt = (O - k) / P, dt < 0 ? dt = 0 : dt > 1 && (dt = 1), J = (j - k) / P, J < 0 ? J = 0 : J > 1 && (J = 1)) : (dt = 0, J = 0), d = (st + U) / 2, g = (dt + J) / 2;
  } else {
    const st = b * O - b * k - P * x + P * C, dt = I * O - I * k + b * C - b * x, U = st / V, J = dt / V, A = (C - x) / I, R = (O - k) / P, wt = (B - x) / I, z = (j - k) / P;
    0 <= U && U <= 1 && 0 <= J && J <= 1 ? (d = U, g = J) : U < 0 && 0 <= J && J <= 1 ? (d = U, g = R) : 1 < U && 0 <= J && J <= 1 ? (d = U, g = z) : 0 <= U && U <= 1 && J < 0 ? (d = A, g = J) : 0 <= U && U <= 1 && 1 < J ? (d = wt, g = J) : U < 0 && J < 0 ? (d = A, g = R) : U < 0 && 1 < J ? (d = wt, g = R) : 1 < U && J < 0 ? (d = A, g = z) : 1 < U && 1 < J && (d = wt, g = z), d < 0 ? d = 0 : d > 1 && (d = 1), g < 0 ? g = 0 : g > 1 && (g = 1);
  }
  return n.x = d * y.x + o.x, n.y = d * y.y + o.y, n.z = d * y.z + o.z, r.x = g * m.x + h.x, r.y = g * m.y + h.y, r.z = g * m.z + h.z, _.subtract(r, n).length();
}
function Pm(s, t, e, i) {
  const r = _.zero(), o = _.zero(), l = _.zero(), h = _.zero(), u = _.zero();
  if (l.x = s.x - e.x, l.y = s.y - e.y, l.z = s.z - e.z, h.x = i.x - e.x, h.y = i.y - e.y, h.z = i.z - e.z, Math.abs(h.x) < 1e-12 && Math.abs(h.y) < 1e-12 && Math.abs(h.z) < 1e-12 || (u.x = t.x - s.x, u.y = t.y - s.y, u.z = t.z - s.z, Math.abs(u.x) < 1e-12 && Math.abs(u.y) < 1e-12 && Math.abs(u.z) < 1e-12))
    return null;
  const d = l.x * h.x + l.y * h.y + l.z * h.z, g = h.x * u.x + h.y * u.y + h.z * u.z, y = l.x * u.x + l.y * u.y + l.z * u.z, m = h.x * h.x + h.y * h.y + h.z * h.z, b = (u.x * u.x + u.y * u.y + u.z * u.z) * m - g * g;
  if (Math.abs(b) < 1e-12)
    return null;
  const C = (d * g - y * m) / b, P = (d + g * C) / m;
  return r.x = s.x + C * u.x, r.y = s.y + C * u.y, r.z = s.z + C * u.z, o.x = e.x + P * h.x, o.y = e.y + P * h.y, o.z = e.z + P * h.z, r;
}
function km(s, t, e) {
  const i = _.subtract(t, s), n = _.subtract(e, s), o = _.dot(n, i) / i.squaredLength();
  return Math.max(0, Math.min(1, o));
}
function cv(s, t, e) {
  const i = km(s, t, e), n = _.subtract(t, s).scale(i);
  return _.add(s, n);
}
function hv(s, t, e, i) {
  const n = km(s, t, e);
  if (n < 0 || n > 1)
    return !1;
  const r = _.subtract(t, s).scale(n), o = _.add(s, r);
  return _.subtract(o, e).squaredLength() <= i * i;
}
function uv(s, t, e) {
  const i = K.subtract(e, t), n = i.length();
  let r = (s.x - t.x) * (e.x - t.x) + (s.y - t.y) * (e.y - t.y);
  return r /= n * n, i.scale(r), K.add(t, i);
}
function uc(s, t, e, i) {
  const n = uv(s, t, e);
  if (K.distance(s, n) <= i) {
    const o = Math.min(t.x, e.x), l = Math.max(t.x, e.x), h = Math.min(t.y, e.y), u = Math.max(t.y, e.y);
    return !(n.x < o || n.x > l || n.y < h || n.y > u);
  } else
    return !1;
}
function Mm(s, t, e, i = 0) {
  return !(s.x + i < t.x || s.x > t.x + e.x + i || s.y + i < t.y || s.y > t.y + e.y + i);
}
function xf(s, t, e, i, n) {
  const r = [], o = _.zero(), l = new mt(), h = t / n;
  for (let u = 0, d = 0; u <= n; ++u, d += h)
    hc(s, d, l), l.transform(i, o), r.push(_.add(e, o));
  return r;
}
function dv(s) {
  const t = s.sort((n, r) => n.exponent < r.exponent ? 1 : -1);
  let e = "";
  const i = ".";
  for (let n = 0; n < t.length; n++) {
    switch (t[n].basicUnit) {
      case di.unitLength:
        e += xi(t[n].factor, "m");
        break;
      case di.unitMass:
        e += fv(t[n].factor, "g");
        break;
      case di.unitTime:
        e += xi(t[n].factor, "s");
        break;
      case di.unitElectricCurrent:
        e += xi(t[n].factor, "A");
        break;
      case di.unitThermoTemperature:
        e += xi(t[n].factor, "K");
        break;
      case di.unitSubstanceAmount:
        e += xi(t[n].factor, "mol");
        break;
      case di.unitLuminosityIntensity:
        e += xi(t[n].factor, "cd");
        break;
      case di.unitPlaneAngle:
        e += xi(t[n].factor, "rad");
        break;
      case di.unitSolidAngle:
        e += xi(t[n].factor, "sr");
        break;
      case di.unitFrequency:
        e += xi(t[n].factor, "Hz");
        break;
      case di.unitForce:
        e += xi(t[n].factor, "N");
        break;
      case di.unitPressure:
        e += xi(t[n].factor, "Pa");
        break;
      case di.unitEnergy:
        e += xi(t[n].factor, "J");
        break;
      case di.unitPower:
        e += xi(t[n].factor, "W");
        break;
      case di.unitElectricCharge:
        e += xi(t[n].factor, "C");
        break;
      case di.unitElectromotiveForce:
        e += xi(t[n].factor, "V");
        break;
      case di.unitCapacitance:
        e += xi(t[n].factor, "F");
        break;
      case di.unitElectricResistance:
        e += xi(t[n].factor, iv);
        break;
      case di.unitElectricConductance:
        e += xi(t[n].factor, "S");
        break;
      case di.unitMagneticFlux:
        e += xi(t[n].factor, "Wb");
        break;
      case di.unitMagneticFluxDensity:
        e += xi(t[n].factor, "T");
        break;
      case di.unitInductance:
        e += xi(t[n].factor, "H");
        break;
      case di.unitLuminousFlux:
        e += xi(t[n].factor, "lm");
        break;
      case di.unitIlluminance:
        e += xi(t[n].factor, "lx");
        break;
      case di.unitActivityRadionuclide:
        e += xi(t[n].factor, "Bq");
        break;
      case di.unitKerma:
        e += xi(t[n].factor, "Gy");
        break;
      case di.unitDoseEquivalent:
        e += xi(t[n].factor, "Sv");
        break;
      case di.unitCatalyticActivity:
        e += xi(t[n].factor, "kat");
        break;
    }
    switch (t[n].exponent) {
      case 2:
        e += Tp;
        break;
      case 3:
        e += Np;
        break;
      case -1:
        e += of, e += ev;
        break;
      case -2:
        e += of, e += Tp;
        break;
      case -3:
        e += of, e += Np;
        break;
    }
    n + 1 < t.length && (e += i);
  }
  return e;
}
function xi(s, t) {
  let e = "";
  switch (s) {
    case 0.3048:
      e = "ft";
      break;
    case 0.0254:
      e = "inch";
      break;
    case 1e-3:
      e = `m${t}`;
      break;
    case 0.01:
      e = `c${t}`;
      break;
    case 0.1:
      e = `d${t}`;
      break;
    case 1:
      e = t;
      break;
    case 10:
      e = `da${t}`;
      break;
    case 100:
      e = `h${t}`;
      break;
    case 1e3:
      e = `k${t}`;
      break;
    case 60:
      e = "min";
      break;
    case 3600:
      e = "h";
      break;
    case 86400:
      e = "d";
      break;
    case 274.15:
      e = "°C";
      break;
    case 255.927778:
      e = "°F";
      break;
    case 0.555556:
      e = "°R";
      break;
  }
  return e;
}
function fv(s, t) {
  let e = "";
  switch (s) {
    case 1e-6:
      e = `m${t}`;
      break;
    case 1e-5:
      e = `d${t}`;
      break;
    case 1e-4:
      e = `c${t}`;
      break;
    case 1e-3:
      e = t;
      break;
    case 0.01:
      e = `da${t}`;
      break;
    case 0.1:
      e = `h${t}`;
      break;
    case 1:
      e = `k${t}`;
      break;
    case 100:
      e = "q";
      break;
    case 1e3:
      e = "t";
      break;
  }
  return e;
}
const qs = class qs {
  constructor(t, e, i, n) {
    this.x = t, this.y = e, this.z = i, this.w = n;
  }
  set(t, e, i, n) {
    this.x = t, this.y = e, this.z = i, this.w = n;
  }
  assign(t) {
    this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w;
  }
  copy() {
    return new qs(this.x, this.y, this.z, this.w);
  }
  equals(t) {
    return this.x === t.x && this.y === t.y && this.z === t.z && this.w === t.w;
  }
  equalsWithTolerance(t, e) {
    return this.x - t.x < e && this.x - t.x > -e && this.y - t.y < e && this.y - t.y > -e && this.z - t.z < e && this.z - t.z > -e && this.w - t.w < e && this.w - t.w > -e;
  }
  fromArray(t) {
    return this.x = t[0], this.y = t[1], this.z = t[2], this.w = t[3], this;
  }
  toArray(t) {
    return t[0] = this.x, t[1] = this.y, t[2] = this.z, t[3] = this.w, this;
  }
  negate() {
    return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this;
  }
  magnitudeSquared() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  magnitude() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  normalize() {
    const t = this.magnitude();
    return t === 0 ? this : (this.x = this.x / t, this.y = this.y / t, this.z = this.z / t, this.w = this.w / t, this);
  }
  static add(t, e) {
    return new qs(t.x + e.x, t.y + e.y, t.z + e.z, t.w + e.w);
  }
  static subtract(t, e) {
    return new qs(t.x - e.x, t.y - e.y, t.z - e.z, t.w - e.w);
  }
  static identity() {
    return new qs(0, 0, 0, 1);
  }
  static toMatrix(t) {
    let e = t.x * t.x + t.y * t.y + t.z * t.z + t.w * t.w;
    e = 2 / e;
    const i = t.x * e, n = t.y * e, r = t.z * e, o = t.w * i, l = t.w * n, h = t.w * r, u = t.x * i, d = t.x * n, g = t.x * r, y = t.y * n, m = t.y * r, x = t.z * r, b = new mt();
    return b.m[0] = 1 - (y + x), b.m[1] = d + h, b.m[2] = g - l, b.m[3] = 0, b.m[4] = d - h, b.m[5] = 1 - (u + x), b.m[6] = m + o, b.m[7] = 0, b.m[8] = g + l, b.m[9] = m - o, b.m[10] = 1 - (u + y), b.m[11] = 0, b.m[12] = 0, b.m[13] = 0, b.m[14] = 0, b.m[15] = 1, b;
  }
  static createFromMatrix(t) {
    const o = [], l = t.m[0] + t.m[5] + t.m[10];
    if (l > 0) {
      let h = Math.sqrt(l + 1);
      o[3] = 0.5 * h, h = 0.5 / h, o[0] = h * (t.m[6] - t.m[9]), o[1] = h * (t.m[8] - t.m[2]), o[2] = h * (t.m[1] - t.m[4]);
    } else {
      let h = 0;
      t.m[4 * 1 + 1] > t.m[4 * 0 + 0] && (h = 1), t.m[4 * 2 + 2] > t.m[4 * h + h] && (h = 2);
      const u = [1, 2, 0], d = u[h], g = u[d];
      let y = Math.sqrt(t.m[4 * h + h] - (t.m[4 * d + d] + t.m[4 * g + g]) + 1);
      o[h] = 0.5 * y, y = 0.5 / y, o[3] = y * (t.m[4 * d + g] - t.m[4 * g + d]), o[d] = y * (t.m[4 * h + d] + t.m[4 * d + h]), o[g] = y * (t.m[4 * h + g] + t.m[4 * g + h]);
    }
    return qs.identity().fromArray(o);
  }
  static interpolate(t, e, i) {
    const h = [], u = [], d = [];
    t.toArray(h), e.toArray(u);
    let g, y;
    const m = h[0] * u[0] + h[1] * u[1] + h[2] * u[2] + h[3] * u[3];
    if (1 + m > qs._epsilon) {
      if (1 - m > qs._epsilon) {
        const x = qs._arccos(m), I = 1 / Math.sin(x);
        g = I * Math.sin((1 - i) * x), y = I * Math.sin(i * x);
      } else
        g = 1 - i, y = i;
      for (let x = 0; x < 4; ++x)
        d[x] = g * h[x] + y * u[x];
    } else {
      d[0] = -h[1], d[1] = h[0], d[2] = -h[3], d[3] = h[2], g = Math.sin(0.5 * Math.PI * (1 - i)), y = Math.sin(0.5 * Math.PI * i);
      for (let x = 0; x < 3; ++x)
        d[x] = g * h[x] + y * d[x];
    }
    return qs.identity().fromArray(d);
  }
  static _arccos(t) {
    return t < -1 ? Math.PI : t > 1 ? 0 : Math.acos(t);
  }
};
qs._epsilon = 1e-5;
let Zn = qs;
class wr {
  constructor(t, e) {
    this.origin = _.zero(), this.direction = new _(0, 0, 1), t && this.origin.assign(t), e && this.direction.assign(e);
  }
  /**
   * Creates a copy of this ray
   * @returns {Ray} a copy of this ray object
   */
  copy() {
    return new wr(this.origin, this.direction);
  }
  /**
   * Sets this ray equal to another ray
   * @param {Ray} ray the ray to assign
   */
  assign(t) {
    return this.origin.assign(t.origin), this.direction.assign(t.direction), this;
  }
  /**
   * Flips the ray's direction.
   */
  negate() {
    return this.direction.negate(), this;
  }
}
class yn {
  /**
   * Creates a new box.
   * @param min The minimum extent of the box. Defaults to the origin.
   * @param max The maximum extent of the box. Defaults to the origin.
   */
  constructor(t = _.zero(), e = _.zero()) {
    this.min = t.copy(), this.max = e.copy();
  }
  /**
   * Creates a copy of the box.
   * @returns A copy of this box.
   */
  copy() {
    return new yn(this.min, this.max);
  }
  /**
   * Strictly compares this box with another box.
   * @param box Box to compare with.
   * @returns True if the values of this box equals the other. False otherwise.
   */
  equals(t) {
    return this.min.equals(t.min) && this.max.equals(t.max);
  }
  /**
   * Gets the center point for the box.
   * @returns The center point of this box.
   */
  center() {
    const t = _.add(this.min, this.max);
    return t.scale(0.5), t;
  }
  /**
   * Gets the extents of the box.
   * @returns A point with members set to extent values for each corresponding axis.
   */
  extents() {
    return _.subtract(this.max, this.min);
  }
  /**
   * Expands the extents of the box so that it will contain another box.
   * @param box The box to add.
   */
  addBox(t) {
    t.isDegenerate() || (this.addPoint(t.min), this.addPoint(t.max));
  }
  /**
   * Expands the extents of the box so that it will contain a particular point.
   * @param point The point to add.
   */
  addPoint(t) {
    t.x < this.min.x && (this.min.x = t.x), t.y < this.min.y && (this.min.y = t.y), t.z < this.min.z && (this.min.z = t.z), t.x > this.max.x && (this.max.x = t.x), t.y > this.max.y && (this.max.y = t.y), t.z > this.max.z && (this.max.z = t.z);
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      min: this.min.toJson(),
      max: this.max.toJson()
    };
  }
  /**
   * Creates a new [[Box]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t) {
    const e = t, i = _.fromJson(e.min), n = _.fromJson(e.max);
    return new yn(i, n);
  }
  /**
   * Gets all eight corner points for the box.
   * @returns The corner points of this box.
   */
  getCorners() {
    const t = [];
    return t[0] = this.min.copy(), t[1] = this.min.copy(), t[2] = this.min.copy(), t[1].x = this.max.x, t[2].y = this.max.y, t[3] = t[2].copy(), t[3].x = this.max.x, t[4] = t[0].copy(), t[5] = t[1].copy(), t[6] = t[2].copy(), t[7] = t[3].copy(), t[4].z = this.max.z, t[5].z = this.max.z, t[6].z = this.max.z, t[7].z = this.max.z, t;
  }
  /**
   * Returns whether a point is contained within the box
   * @returns whether a point is contained within the box
   */
  containsPoint(t) {
    return t.x >= this.min.x && t.x <= this.max.x && t.y >= this.min.y && t.y <= this.max.y && t.z >= this.min.z && t.z <= this.max.z;
  }
  /**
   * Creates and returns an invalid bounding box.
   * @returns an invalid bounding box.
   */
  static invalid() {
    return new yn(
      new _(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY),
      new _(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY)
    );
  }
  /**
   * Returns whether or not the box is degenerate.
   * @returns whether or not the box is degenerate.
   */
  isDegenerate() {
    return this.min.x > this.max.x || this.min.y > this.max.y || this.min.z > this.max.z;
  }
}
function gv(s) {
  return s !== null && typeof s == "object" && "r" in s && typeof s.r == "number" && "g" in s && typeof s.g == "number" && "b" in s && typeof s.b == "number";
}
class vt {
  /**
   * Creates a new color object. Values are specified in the 0-255 range.
   * @param r red color component
   * @param g green color component
   * @param b blue color component
   */
  constructor(t, e, i) {
    this.r = t, this.g = e, this.b = i;
  }
  /**
   * Sets this color equal to another color
   * @param color the point whose values will be used to set this color
   * @returns the color object
   */
  assign(t) {
    return this.set(t.r, t.g, t.b), this;
  }
  /**
   * Creates a copy of this color
   * @returns Copy of this color
   */
  copy() {
    return new vt(this.r, this.g, this.b);
  }
  /**
   * Compares this color with another color
   * @param color the color to compare with
   * @returns True if the values of this color equal the other. False otherwise.
   */
  equals(t) {
    return this.r === t.r && this.g === t.g && this.b === t.b;
  }
  /**
   * Sets the color object. Values are specified in the 0-255 range.
   * @param r red color component
   * @param g green color component
   * @param b blue color component
   */
  set(t, e, i) {
    this.r = t, this.g = e, this.b = i;
  }
  /**
   * Sets the color object from floating point values. Values are specified in the 0.0-1.0 range.
   * @param r red color component
   * @param g green color component
   * @param b blue color component
   */
  setFromFloat(t, e, i) {
    this.r = Math.round(255 * t), this.g = Math.round(255 * e), this.b = Math.round(255 * i);
  }
  /**
   * Sets this color from an array of normalized floating point values
   * @param the array to assign from
   */
  fromFloatArray(t) {
    return this.setFromFloat(t[0], t[1], t[2]);
  }
  /**
   * Gets an array of floating point values representing this color. Values are clamped in the 0.0 - 1.0 range.
   * @returns array of floating point values for this color.
   */
  getFloatArray() {
    return [this.r / 255, this.g / 255, this.b / 255];
  }
  /**
   * Populates an array with floating point values for this color. Values are clamped in the 0.0 - 1.0 range.
   * @param arr array whose first three elements will be populated with the r,g, and b values of this color respectively.
   */
  toFloatArray(t = [0, 0, 0]) {
    return t[0] = this.r / 255, t[1] = this.g / 255, t[2] = this.b / 255, t;
  }
  /**
   * Creates a new [[Color]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t) {
    if (gv(t))
      return new vt(t.r, t.g, t.b);
    throw new TypeError("Color.fromJson: data does not satisfy type IColor constraints");
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return {
      r: this.r,
      g: this.g,
      b: this.b
    };
  }
  /**
   * Creates a color object from floating point values. Values are specified in the 0.0-1.0 range.
   * @param r red color component
   * @param g green color component
   * @param b blue color component
   * @returns new color object
   */
  static createFromFloat(t, e, i) {
    const n = vt.black();
    return n.setFromFloat(t, e, i), n;
  }
  /**
   * Creates a color object from an array of floating point values.
   * Values are specified in the 0.0-1.0 range.
   */
  static createFromFloatArray(t) {
    const e = vt.black();
    return e.fromFloatArray(t), e;
  }
  /**
   * Creates a new color object initialized to red.
   * @returns new color object
   */
  static red() {
    return new vt(255, 0, 0);
  }
  /**
   * Creates a new color object initialized to green.
   * @returns new color object
   */
  static green() {
    return new vt(0, 255, 0);
  }
  /**
   * Creates a new color object initialized to blue.
   * @returns new color object
   */
  static blue() {
    return new vt(0, 0, 255);
  }
  /**
   * Creates a new color object initialized to yellow.
   * @returns new color object
   */
  static yellow() {
    return new vt(255, 255, 0);
  }
  /**
   * Creates a new color object initialized to white.
   * @returns new color object
   */
  static white() {
    return new vt(255, 255, 255);
  }
  /**
   * Creates a new color object initialized to black.
   * @returns new color object
   */
  static black() {
    return new vt(0, 0, 0);
  }
}
var Os = /* @__PURE__ */ ((s) => (s[s.Scalar = 1] = "Scalar", s[s.Vec3 = 3] = "Vec3", s[s.Quat = 4] = "Quat", s))(Os || {});
class _h {
  /**
   * Creates a new buffer for storing keyframe data.
   * @param keyType The type of keyframes that will be stored in the buffer.
   */
  constructor(t) {
    this.keyType = t, this.times = [], this.values = [], this.tangents = [], this._hasTangents = null, this.keyOffset = t;
  }
  _validateKey(t) {
    if (this.keyType !== t)
      throw new Error(
        `Cannot add keyframe of type: ${Os[t]} to buffer of type: ${Os[this.keyType]}`
      );
  }
  _validateTangents(t) {
    if (this._hasTangents === null)
      this._hasTangents = t;
    else if (this._hasTangents !== t)
      throw new Error(
        `Cannot add keyframe with${t ? "" : "out"} tangents to buffer with${t ? "out" : ""} tangents`
      );
  }
  _findIndexFromTime(t) {
    for (let e = 0; e < this.times.length; e++)
      if (this.times[e] >= t)
        return e;
    return this.times.length;
  }
  /** Returns the index of the keyframe at the specified time. */
  getKeyframeIndex(t) {
    return this.times.indexOf(t);
  }
  /** Deletes a keyframe at the specified index. */
  deleteKeyframe(t) {
    this.times.splice(t, 1), this.tangents.splice(t * this.keyOffset * 2, this.keyOffset * 2), this.values.splice(t * this.keyOffset, this.keyOffset);
  }
  /**
   * Inserts a Scalar keyframe with the specified time. The type of this buffer should be [[KeyType.Scalar]]
   * @returns Index at which keyframe was inserted
   */
  insertScalarKeyframe(t, e, i, n) {
    this._validateKey(
      1
      /* Scalar */
    );
    const r = this._findIndexFromTime(t);
    return this.times.splice(r, 0, t), this.values.splice(r, 0, e), i !== void 0 && n !== void 0 ? (this._validateTangents(!0), this.tangents.splice(r * 2, 0, i, n)) : this._validateTangents(!1), r;
  }
  /** Updates a Scalar keyframe at the specified index. The type of this buffer should be [[KeyType.Scalar]] */
  updateScalarKeyframe(t, e, i, n, r) {
    this.values[t] = i, this.times[t] = e, n !== void 0 && r !== void 0 && (this.tangents[t * 2] = n, this.tangents[t * 2 + 1] = r);
  }
  /**
   * Inserts a Vec3 keyframe with the specified time. The type of this buffer should be [[KeyType.Vec3]]
   * @returns Index at which keyframe was inserted
   */
  insertVec3Keyframe(t, e, i, n, r, o, l, h, u, d) {
    this._validateKey(
      3
      /* Vec3 */
    );
    const g = this._findIndexFromTime(t);
    return this.times.splice(g, 0, t), this.values.splice(g * this.keyOffset, 0, e, i, n), r !== void 0 && o !== void 0 && l !== void 0 && h !== void 0 && u !== void 0 && d !== void 0 ? (this._validateTangents(!0), this.tangents.splice(
      g * this.keyOffset * 2,
      0,
      r,
      o,
      l,
      h,
      u,
      d
    )) : this._validateTangents(!1), g;
  }
  /** Updates a Vec3 keyframe at the specified index. The type of this buffer should be [[KeyType.Vec3]] */
  updateVec3Keyframe(t, e, i, n, r, o, l, h, u, d, g) {
    return this.times[t] = e, this.values[t * this.keyOffset] = i, this.values[t * this.keyOffset + 1] = n, this.values[t * this.keyOffset + 2] = r, o !== void 0 && l !== void 0 && h !== void 0 && u !== void 0 && d !== void 0 && g !== void 0 ? (this._validateTangents(!0), this.tangents.splice(
      t * this.keyOffset * 2,
      0,
      o,
      l,
      h,
      u,
      d,
      g
    ), this.tangents[t * this.keyOffset * 2] = o, this.tangents[t * this.keyOffset * 2 + 1] = l, this.tangents[t * this.keyOffset * 2 + 2] = h, this.tangents[t * this.keyOffset * 2 + 3] = u, this.tangents[t * this.keyOffset * 2 + 4] = d, this.tangents[t * this.keyOffset * 2 + 5] = g) : this._validateTangents(!1), t;
  }
  /**
   * Inserts a Quat keyframe with the specified time. The type of this buffer should be [[KeyType.Quat]]
   * @returns Index at which keyframe was inserted
   */
  insertQuatKeyframe(t, e, i, n, r, o, l, h, u, d, g, y, m) {
    this._validateKey(
      4
      /* Quat */
    );
    const x = this._findIndexFromTime(t);
    this.times.splice(x, 0, t), this.values.splice(x * this.keyOffset, 0, e, i, n, r), o !== void 0 && l !== void 0 && h !== void 0 && u !== void 0 && d !== void 0 && g !== void 0 && y !== void 0 && m !== void 0 ? (this._validateTangents(!0), this.tangents.splice(
      x * this.keyOffset * 2,
      0,
      o,
      l,
      h,
      u,
      d,
      g,
      y,
      m
    )) : this._validateTangents(!1);
  }
  /** Updates a Quat keyframe at the specified index. The type of this buffer should be [[KeyType.Quat]] */
  updateQuatKeyframe(t, e, i, n, r, o, l, h, u, d, g, y, m, x) {
    this.times[t] = e, this.values[t * this.keyOffset] = i, this.values[t * this.keyOffset + 1] = n, this.values[t * this.keyOffset + 2] = r, this.values[t * this.keyOffset + 3] = o, l !== void 0 && h !== void 0 && u !== void 0 && d !== void 0 && g !== void 0 && y !== void 0 && m !== void 0 && x !== void 0 ? (this._validateTangents(!0), this.tangents.splice(
      t * this.keyOffset * 2,
      0,
      l,
      h,
      u,
      g,
      y,
      m
    ), this.tangents[t * this.keyOffset * 2] = l, this.tangents[t * this.keyOffset * 2 + 1] = h, this.tangents[t * this.keyOffset * 2 + 2] = u, this.tangents[t * this.keyOffset * 2 + 3] = x, this.tangents[t * this.keyOffset * 2 + 4] = g, this.tangents[t * this.keyOffset * 2 + 5] = y, this.tangents[t * this.keyOffset * 2 + 6] = m, this.tangents[t * this.keyOffset * 2 + 7] = x) : this._validateTangents(!1);
  }
  /** @hidden */
  _export() {
    const t = {};
    return this.tangents.length !== 0 && (t.tangents = this.tangents.slice()), {
      keyType: Os[this.keyType],
      times: this.times.slice(),
      values: this.values.slice(),
      ...t
    };
  }
  /** @hidden */
  static _import(t) {
    const e = new _h(Os[t.keyType]);
    return e.times = t.times.slice(), e.values = t.values.slice(), t.tangents !== void 0 && (e.tangents = t.tangents.slice()), e;
  }
}
var Nn = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.Transform = 1] = "Transform", s[s.Opacity = 2] = "Opacity", s[s.Visibility = 4] = "Visibility", s[s.Color = 8] = "Color", s))(Nn || {});
class Em {
  constructor(t) {
    this.nodeId = t, this.translate = _.zero(), this.rotation = Zn.identity(), this.scale = new _(1, 1, 1), this.color = new _(1, 1, 1), this.pivotPoint = null, this.opacity = 1, this.visibility = 1, this.matrix = new mt(), this.flags = 0;
  }
  updateMatrix() {
    this.pivotPoint ? this._updateMatrixWithOrigin() : this._updateMatrix();
  }
  // http://glmatrix.net/docs/mat4.js.html#line1354
  _updateMatrixWithOrigin() {
    const t = this.rotation.x, e = this.rotation.y, i = this.rotation.z, n = this.rotation.w, r = t + t, o = e + e, l = i + i, h = t * r, u = t * o, d = t * l, g = e * o, y = e * l, m = i * l, x = n * r, b = n * o, I = n * l, C = this.scale.x, P = this.scale.y, k = this.scale.z, O = this.pivotPoint.x, B = this.pivotPoint.y, j = this.pivotPoint.z, V = (1 - (g + m)) * C, Y = (u + I) * C, q = (d - b) * C, st = (u - I) * P, dt = (1 - (h + m)) * P, U = (y + x) * P, J = (d + b) * k, A = (y - x) * k, R = (1 - (h + g)) * k;
    this.matrix.m[0] = V, this.matrix.m[1] = Y, this.matrix.m[2] = q, this.matrix.m[3] = 0, this.matrix.m[4] = st, this.matrix.m[5] = dt, this.matrix.m[6] = U, this.matrix.m[7] = 0, this.matrix.m[8] = J, this.matrix.m[9] = A, this.matrix.m[10] = R, this.matrix.m[11] = 0, this.matrix.m[12] = this.translate.x + O - (V * O + st * B + J * j), this.matrix.m[13] = this.translate.y + B - (Y * O + dt * B + A * j), this.matrix.m[14] = this.translate.z + j - (q * O + U * B + R * j), this.matrix.m[15] = 1;
  }
  // http://glmatrix.net/docs/mat4.js.html#line1291
  _updateMatrix() {
    const t = this.rotation.x, e = this.rotation.y, i = this.rotation.z, n = this.rotation.w, r = t + t, o = e + e, l = i + i, h = t * r, u = t * o, d = t * l, g = e * o, y = e * l, m = i * l, x = n * r, b = n * o, I = n * l, C = this.scale.x, P = this.scale.y, k = this.scale.z;
    this.matrix.m[0] = (1 - (g + m)) * C, this.matrix.m[1] = (u + I) * C, this.matrix.m[2] = (d - b) * C, this.matrix.m[3] = 0, this.matrix.m[4] = (u - I) * P, this.matrix.m[5] = (1 - (h + m)) * P, this.matrix.m[6] = (y + x) * P, this.matrix.m[7] = 0, this.matrix.m[8] = (d + b) * k, this.matrix.m[9] = (y - x) * k, this.matrix.m[10] = (1 - (h + g)) * k, this.matrix.m[11] = 0, this.matrix.m[12] = this.translate.x, this.matrix.m[13] = this.translate.y, this.matrix.m[14] = this.translate.z, this.matrix.m[15] = 1;
  }
}
class Am {
  constructor() {
    this.position = null, this.target = null, this.up = null, this.width = null, this.height = null;
  }
  /** Reset this object to its initial state. */
  clear() {
    this.position = null, this.target = null, this.up = null, this.width = null, this.height = null;
  }
  /**
   * Set the stored values on the supplied [[Camera]].
   * @returns True if the camera was modified.
   */
  apply(t) {
    let e = !1;
    return this.position !== null && (t.setPosition(this.position), e = !0), this.target !== null && (t.setTarget(this.target), e = !0), this.up !== null && (t.setUp(this.up), e = !0), this.width !== null && (t.setWidth(this.width), e = !0), this.height !== null && (t.setHeight(this.height), e = !0), e;
  }
}
class Tm {
  constructor() {
    this.opacities = /* @__PURE__ */ new Map(), this.colors = /* @__PURE__ */ new Map(), this.matrixNodeIds = [], this.matrices = [], this.visibilityOn = [], this.visibilityOff = [];
  }
  /** Reset this object to its initial state. */
  clear() {
    this.opacities.clear(), this.colors.clear(), this.matrixNodeIds = [], this.matrices = [], this.visibilityOn = [], this.visibilityOff = [];
  }
  /** Set the stored values on the supplied [[WebViewer]]. */
  apply(t) {
    const e = t.model;
    this.opacities.size > 0 && e.setNodesOpacities(this.opacities), this.colors.size > 0 && e.setNodesColors(this.colors), this.matrixNodeIds.length > 0 && e._setNodesMatrices(this.matrixNodeIds, this.matrices), this.visibilityOn.length > 0 && e.setNodesVisibility(this.visibilityOn, !0), this.visibilityOff.length > 0 && e.setNodesVisibility(this.visibilityOff, !1);
  }
}
class Fu {
  constructor() {
    this.node = new Tm(), this.camera = new Am();
  }
  /** Reset this object to its initial state. */
  clear() {
    this.node.clear(), this.camera.clear();
  }
  /** Set the stored values on the supplied [[WebViewer]]. */
  apply(t) {
    this.node.apply(t);
    const e = t.view, i = e.getCamera();
    this.camera.apply(i) && e.setCamera(i);
  }
}
var Bu = /* @__PURE__ */ ((s) => (s[s.Translation = 0] = "Translation", s[s.Rotation = 1] = "Rotation", s[s.Scale = 2] = "Scale", s[s.Opacity = 3] = "Opacity", s[s.Visibility = 4] = "Visibility", s[s.Color = 5] = "Color", s[s.ColorMap = 6] = "ColorMap", s))(Bu || {});
class qc {
  constructor(t, e, i, n) {
    switch (this.name = t, this.nodeId = e, this.property = i, this.sampler = n, this.property) {
      case 0:
      case 2:
      case 5:
        if (n.buffer.keyType !== Os.Vec3)
          throw new Error("Key type mismatch. Expected Vec3");
        break;
      case 1:
        if (n.buffer.keyType !== Os.Quat)
          throw new Error("Key type mismatch. Expected Quat");
        break;
      case 3:
      case 4:
      case 6:
        if (n.buffer.keyType !== Os.Scalar)
          throw new Error("Key type mismatch. Expected Scalar");
        break;
    }
  }
  /** @hidden */
  _getValue(t, e) {
    switch (this.property) {
      case 0:
        this.sampler.interpolateVec3(t, e.translate), e.flags |= Nn.Transform;
        break;
      case 1:
        this.sampler.interpolateQuat(t, e.rotation), e.flags |= Nn.Transform;
        break;
      case 2:
        this.sampler.interpolateVec3(t, e.scale), e.flags |= Nn.Transform;
        break;
      case 3:
        e.opacity = this.sampler.interpolateScalar(t), e.flags |= Nn.Opacity;
        break;
      case 4:
        e.visibility = this.sampler.interpolateScalar(t), e.flags |= Nn.Visibility;
        break;
      case 5:
        this.sampler.interpolateVec3(t, e.color), e.flags |= Nn.Color;
        break;
      case 6:
        {
          const i = this.sampler.interpolateScalar(t), n = this._getColorFromMap(i);
          n !== null && (e.color.set(n.r, n.g, n.b), e.flags |= Nn.Color);
        }
        break;
    }
  }
  _getColorFromMap(t) {
    const e = (n, r, o, l, h) => {
      const u = (n - r) / (o - r);
      return new vt(
        (1 - u) * l.r + u * h.r,
        (1 - u) * l.g + u * h.g,
        (1 - u) * l.b + u * h.b
      );
    };
    if (this.colorMap === void 0)
      return null;
    t < 0 && (t = 0), t > 1 && (t = 1);
    let i = 0;
    for (; i < this.colorMap.length - 1; ) {
      const n = this.colorMap[i].position, r = this.colorMap[i].color, o = this.colorMap[i + 1].position, l = this.colorMap[i + 1].color;
      if (t <= n)
        return r;
      if (t <= o)
        return e(t, n, o, r, l);
      if (t >= o && i === this.colorMap.length - 2)
        return l;
      ++i;
    }
    return null;
  }
  /** @hidden */
  _gatherForExport(t) {
    this.colorMap !== void 0 && t.colorMaps.add(this.colorMap), t.samplers.add(this.sampler), this.sampler._gatherForExport(t);
  }
  /** @hidden */
  _export(t) {
    const e = {};
    return this.name !== "" && (e.name = this.name), this.colorMap !== void 0 && (e.colorMap = t.colorMaps.getIndex(this.colorMap)), {
      nodeId: this.nodeId,
      property: Bu[this.property],
      sampler: t.samplers.getIndex(this.sampler),
      ...e
    };
  }
  /** @hidden */
  static _import(t, e) {
    const i = new qc(
      e.name || "",
      e.nodeId,
      Bu[e.property],
      t.samplers[e.sampler]
    );
    return e.colorMap !== void 0 && (i.colorMap = t.colorMaps[e.colorMap]), i;
  }
}
var fr = /* @__PURE__ */ ((s) => (s[s.Position = 0] = "Position", s[s.Target = 1] = "Target", s[s.Up = 2] = "Up", s[s.Width = 3] = "Width", s[s.Height = 4] = "Height", s))(fr || {});
class Kc {
  /**
   * Do not use directly.  Create via Animation class API.
   * @hidden
   * */
  constructor(t, e, i) {
    switch (this.name = t, this.property = e, this.sampler = i, this.property) {
      case 0:
      case 1:
      case 2:
        if (i.buffer.keyType !== Os.Vec3)
          throw new Error("Key type mismatch. Expected Vec3");
        break;
      case 3:
      case 4:
        if (i.buffer.keyType !== Os.Scalar)
          throw new Error("Key type mismatch. Expected Scalar");
        break;
    }
  }
  /** @hidden */
  _getValue(t, e) {
    switch (this.property) {
      case 0:
        e.position === null && (e.position = new _(0, 0, 0)), this.sampler.interpolateVec3(t, e.position);
        break;
      case 1:
        e.target === null && (e.target = new _(0, 0, -1)), this.sampler.interpolateVec3(t, e.target);
        break;
      case 2:
        e.up === null && (e.up = new _(0, 1, 0)), this.sampler.interpolateVec3(t, e.up);
        break;
      case 3:
        e.width = this.sampler.interpolateScalar(t);
        break;
      case 4:
        e.height = this.sampler.interpolateScalar(t);
    }
  }
  /** @hidden */
  _gatherForExport(t) {
    t.samplers.add(this.sampler), this.sampler._gatherForExport(t);
  }
  /** @hidden */
  _export(t) {
    const e = {};
    return this.name !== "" && (e.name = this.name), {
      property: fr[this.property],
      sampler: t.samplers.getIndex(this.sampler),
      ...e
    };
  }
  /** @hidden */
  static _import(t, e) {
    return new Kc(
      e.name || "",
      fr[e.property],
      t.samplers[e.sampler]
    );
  }
}
class dd {
  /**
   * Creates a new, empty Animation
   * @param name friendly name for the animation
   */
  constructor(t) {
    this.name = t, this.nodeChannels = [], this.cameraChannels = [], this.pivotPoints = /* @__PURE__ */ new Map();
  }
  /**
   * Creates a new node animation channel.
   * @param name friendly name for the channel.
   * @param target id of node that will receive interpolated values.
   * @param property the node property that will be animated.
   * @param sampler sampler describing the buffer and interpolation type.
   */
  createNodeChannel(t, e, i, n) {
    const r = new qc(t, e, i, n);
    return this._registerNodeChannel(r), r;
  }
  _registerNodeChannel(t) {
    this.nodeChannels.push(t);
  }
  /**
   * Creates a new camera animation channel.
   * @param name friendly name for the channel.
   * @param property the property that will be animated by this channel.
   * @param sampler sampler describing the buffer and interpolation type used.
   */
  createCameraChannel(t, e, i) {
    const n = new Kc(t, e, i);
    return this._registerCameraChannel(n), n;
  }
  _registerCameraChannel(t) {
    this.cameraChannels.push(t);
  }
  /**
   * Removes a channel from this animation.
   *
   * Call [[Player.reload]] on any players that are referencing this animation.
   */
  deleteChannel(t) {
    for (let e = 0; e < this.nodeChannels.length; e++)
      if (this.nodeChannels[e] === t) {
        this.nodeChannels.splice(e, 1);
        return;
      }
    for (let e = 0; e < this.cameraChannels.length; e++)
      if (this.cameraChannels[e] === t) {
        this.cameraChannels.splice(e, 1);
        return;
      }
  }
  /** @hidden */
  _gatherForExport(t) {
    for (const e of this.nodeChannels)
      e._gatherForExport(t);
    for (const e of this.cameraChannels)
      e._gatherForExport(t);
  }
  /** @hidden */
  _export(t) {
    const e = [], i = {};
    this.name !== "" && (i.name = this.name);
    const n = {}, r = (o) => {
      if (this[o].length === 0)
        return;
      const l = [];
      for (const h of this[o])
        l.push(h._export(t));
      n[o] = l;
    };
    return this.pivotPoints.forEach((o, l) => {
      e.push({ node: l, point: o });
    }), e.length !== 0 && (i.pivotPoints = e), r("nodeChannels"), r("cameraChannels"), {
      ...i,
      ...n
    };
  }
  /** @hidden */
  static _import(t, e) {
    const i = new dd(e.name || "");
    if (e.nodeChannels !== void 0)
      for (const n of e.nodeChannels)
        i._registerNodeChannel(qc._import(t, n));
    if (e.cameraChannels !== void 0)
      for (const n of e.cameraChannels)
        i._registerCameraChannel(Kc._import(t, n));
    if (e.pivotPoints !== void 0)
      for (const n of e.pivotPoints) {
        const r = _.fromJson(n.point);
        i.pivotPoints.set(n.node, r);
      }
    return i;
  }
}
var Vu = /* @__PURE__ */ ((s) => (s[s.Constant = 0] = "Constant", s[s.Linear = 1] = "Linear", s[s.CubicSpline = 2] = "CubicSpline", s))(Vu || {});
const Gt = class Gt {
  /**
   * Creates a new sampler for a [[KeyframeBuffer]]
   * @param buffer The buffer that will be sampled.
   * @param interpolationType The Type of interpolation that will be used
   */
  constructor(t, e) {
    this.buffer = t, this.interpolationType = e;
  }
  /**
   * Returns the index of the next keyframe for a given frame T.
   * Note that this assumes that all keyframes in the buffer
   * are arranged in ascending order by frame time.
   */
  _getNextKeyframeIndex(t) {
    for (let e = 0; e < this.buffer.times.length; e += 1)
      if (this.buffer.times[e] > t)
        return e;
    return this.buffer.times.length;
  }
  /** Computes an interpolated quaternion for the given frame. */
  interpolateQuat(t, e) {
    const i = this._getNextKeyframeIndex(t);
    if (i === 0) {
      this._setQuatFromKeyframeIndex(0, e);
      return;
    } else if (i === this.buffer.times.length) {
      this._setQuatFromKeyframeIndex(i - 1, e);
      return;
    }
    switch (this.interpolationType) {
      case 0:
        this._setQuatFromKeyframeIndex(i - 1, e);
        break;
      case 1:
        this.interpolateQuatSlerp(i - 1, i, t, e);
        break;
      case 2:
        this.interpolateQuatCubicSpline(i - 1, i, t, e);
        break;
    }
  }
  /** Computes an interpolated Vector 3 value for the given frame. */
  interpolateVec3(t, e) {
    const i = this._getNextKeyframeIndex(t);
    if (i === 0) {
      this._setVecFromKeyframeIndex(0, e);
      return;
    } else if (i === this.buffer.times.length) {
      this._setVecFromKeyframeIndex(i - 1, e);
      return;
    }
    switch (this.interpolationType) {
      case 0:
        this._setVecFromKeyframeIndex(i - 1, e);
        break;
      case 1:
        this.interpolateVec3Linear(i - 1, i, t, e);
        break;
      case 2:
        this.interpolateVec3CubicSpline(i - 1, i, t, e);
        break;
    }
  }
  /** Computes an interpolated scalar value for the given frame. */
  interpolateScalar(t) {
    const e = this._getNextKeyframeIndex(t);
    if (e === 0)
      return this.buffer.values[0];
    if (e === this.buffer.times.length)
      return this.buffer.values[e - 1];
    switch (this.interpolationType) {
      case 0:
        return this.buffer.values[e - 1];
      case 1:
        return this.interpolateScalarLinear(e - 1, e, t);
      case 2:
        return this.interpolateScalarCubicSpline(e - 1, e, t);
    }
  }
  /** Performs linear interpolation of two scalar values beginning at indices k0 and k1. */
  interpolateScalarLinear(t, e, i) {
    const n = this.buffer.times[e] - this.buffer.times[t], r = (i - this.buffer.times[t]) / n, o = this.buffer.values[t], l = this.buffer.values[e];
    return o + (l - o) * r;
  }
  /** Performs spherical linear interpolation on the quaternion values beginning at indices k0 and k1. */
  interpolateQuatSlerp(t, e, i, n) {
    const r = this.buffer.times[e] - this.buffer.times[t], o = (i - this.buffer.times[t]) / r;
    this._setQuatFromKeyframeIndex(t, Gt.q0), this._setQuatFromKeyframeIndex(e, Gt.q1), n.assign(Zn.interpolate(Gt.q0, Gt.q1, o));
  }
  static _interpVec3(t, e, i, n) {
    e.subtract(t), e.scale(i), e.add(t), n.assign(e);
  }
  /** Performs linear interpolation on the Vector3 values at keyframes beginning at indices k0 and k1 */
  interpolateVec3Linear(t, e, i, n) {
    const r = this.buffer.times[e] - this.buffer.times[t], o = (i - this.buffer.times[t]) / r;
    this._setVecFromKeyframeIndex(t, Gt.v0), this._setVecFromKeyframeIndex(e, Gt.v1), Gt._interpVec3(Gt.v0, Gt.v1, o, n);
  }
  _interpCubicSpline(t, e, i, n, r) {
    const o = t ** 2, l = t ** 3;
    return (2 * l - 3 * o + 1) * e + (l - 2 * o + t) * n + (-2 * l + 3 * o) * i + (l - o) * r;
  }
  /** Performs Cubic Spline Interpolation on two scalar values beginning at indices k0 and k1 */
  interpolateScalarCubicSpline(t, e, i) {
    const n = this.buffer.times[e] - this.buffer.times[t], r = (i - this.buffer.times[t]) / n, o = this.buffer.values[t], l = this.buffer.values[e];
    let h = 0, u = 0;
    return this.buffer.tangents.length !== 0 && (h = this.buffer.tangents[t] * n, u = this.buffer.tangents[e] * n), this._interpCubicSpline(r, o, l, h, u);
  }
  /** Performs Cubic Spline Interpolation on the Vector3 values at keyframes beginning at indices k0 and k1 */
  interpolateVec3CubicSpline(t, e, i, n) {
    const r = this.buffer.times[e] - this.buffer.times[t], o = (i - this.buffer.times[t]) / r;
    this._setVecFromKeyframeIndex(t, Gt.v0), this._setVecFromKeyframeIndex(e, Gt.v1), this._setVecTanFromKeyframeIndex(t, Gt.v2), this._setVecTanFromKeyframeIndex(e, Gt.v3), Gt.v2.scale(r), Gt.v3.scale(r), n.set(
      this._interpCubicSpline(o, Gt.v0.x, Gt.v1.x, Gt.v2.x, Gt.v3.x),
      this._interpCubicSpline(o, Gt.v0.y, Gt.v1.y, Gt.v2.y, Gt.v3.y),
      this._interpCubicSpline(o, Gt.v0.z, Gt.v1.z, Gt.v2.z, Gt.v3.z)
    );
  }
  /** Performs Cubic Spline Interpolation on the Quaternion values beginning at indices k0 and k1 */
  interpolateQuatCubicSpline(t, e, i, n) {
    const r = this.buffer.times[e] - this.buffer.times[t], o = (i - this.buffer.times[t]) / r;
    this._setQuatFromKeyframeIndex(t, Gt.q0), this._setQuatFromKeyframeIndex(e, Gt.q1), this._setQuatTanFromKeyframeIndex(t, Gt.q2), this._setQuatTanFromKeyframeIndex(e, Gt.q3), Gt.q4.set(
      Gt.q2.x * r,
      Gt.q2.y * r,
      Gt.q2.z * r,
      Gt.q2.w * r
    ), Gt.q5.set(
      Gt.q3.x * r,
      Gt.q3.y * r,
      Gt.q3.z * r,
      Gt.q3.w * r
    ), n.set(
      this._interpCubicSpline(o, Gt.q0.x, Gt.q1.x, Gt.q4.x, Gt.q5.x),
      this._interpCubicSpline(o, Gt.q0.y, Gt.q1.y, Gt.q4.y, Gt.q5.y),
      this._interpCubicSpline(o, Gt.q0.z, Gt.q1.z, Gt.q4.z, Gt.q5.z),
      this._interpCubicSpline(o, Gt.q0.w, Gt.q1.w, Gt.q4.w, Gt.q5.w)
    ), n.normalize();
  }
  _setVecFromKeyframeIndex(t, e) {
    const i = t * 3;
    e.set(
      this.buffer.values[i],
      this.buffer.values[i + 1],
      this.buffer.values[i + 2]
    );
  }
  _setVecTanFromKeyframeIndex(t, e) {
    if (this.buffer.tangents.length === 0)
      e.set(0, 0, 0);
    else {
      const i = t * 3;
      e.set(
        this.buffer.tangents[i],
        this.buffer.tangents[i + 1],
        this.buffer.tangents[i + 2]
      );
    }
  }
  _setQuatFromKeyframeIndex(t, e) {
    const i = t * 4;
    e.set(
      this.buffer.values[i],
      this.buffer.values[i + 1],
      this.buffer.values[i + 2],
      this.buffer.values[i + 3]
    );
  }
  _setQuatTanFromKeyframeIndex(t, e) {
    if (this.buffer.tangents.length === 0)
      e.set(0, 0, 0, 1);
    else {
      const i = t * 4;
      e.set(
        this.buffer.tangents[i],
        this.buffer.tangents[i + 1],
        this.buffer.tangents[i + 2],
        this.buffer.tangents[i + 3]
      );
    }
  }
  /** @hidden */
  _gatherForExport(t) {
    t.buffers.add(this.buffer);
  }
  /** @hidden */
  _export(t) {
    return {
      buffer: t.buffers.getIndex(this.buffer),
      interpolationType: Vu[this.interpolationType]
    };
  }
  /** @hidden */
  static _import(t, e) {
    return new Gt(t.buffers[e.buffer], Vu[e.interpolationType]);
  }
};
Gt.q0 = Zn.identity(), Gt.q1 = Zn.identity(), Gt.q2 = Zn.identity(), Gt.q3 = Zn.identity(), Gt.q4 = Zn.identity(), Gt.q5 = Zn.identity(), Gt.v0 = _.zero(), Gt.v1 = _.zero(), Gt.v2 = _.zero(), Gt.v3 = _.zero();
let Xc = Gt;
var pl = /* @__PURE__ */ ((s) => (s[s.Unknown = 0] = "Unknown", s[s.Catia = 2] = "Catia", s[s.CatiaV5 = 3] = "CatiaV5", s[s.Cadds = 4] = "Cadds", s[s.Unigraphics = 5] = "Unigraphics", s[s.Parasolid = 6] = "Parasolid", s[s.Euclid = 7] = "Euclid", s[s.Iges = 9] = "Iges", s[s.Unisurf = 10] = "Unisurf", s[s.Vda = 11] = "Vda", s[s.Stl = 12] = "Stl", s[s.Wrl = 13] = "Wrl", s[s.Dxf = 14] = "Dxf", s[s.Acis = 15] = "Acis", s[s.ProE = 16] = "ProE", s[s.Step = 18] = "Step", s[s.Ideas = 19] = "Ideas", s[s.Jt = 20] = "Jt", s[s.Slw = 22] = "Slw", s[s.Cgr = 23] = "Cgr", s[s.Prc = 24] = "Prc", s[s.Xvl = 25] = "Xvl", s[s.Hpgl = 26] = "Hpgl", s[s.TopSolid = 27] = "TopSolid", s[s.OneSpaceDesigner = 28] = "OneSpaceDesigner", s[s._3dxml = 29] = "_3dxml", s[s.Inventor = 30] = "Inventor", s[s.PostScript = 31] = "PostScript", s[s.Pdp = 32] = "Pdp", s[s.U3d = 33] = "U3d", s[s.Ifc = 34] = "Ifc", s[s.Dwg = 35] = "Dwg", s[s.Dwf = 36] = "Dwf", s[s.Se = 37] = "Se", s[s.Obj = 38] = "Obj", s[s.Kmz = 39] = "Kmz", s[s.Dae = 40] = "Dae", s[s._3ds = 41] = "_3ds", s[s.Rhino = 43] = "Rhino", s[s.Xml = 44] = "Xml", s[s._3mf = 45] = "_3mf", s[s.Scs = 46] = "Scs", s[s._3dHtml = 47] = "_3dHtml", s[s.Hsf = 48] = "Hsf", s[s.Gltf = 49] = "Gltf", s[s.Revit = 50] = "Revit", s[s.Fbx = 51] = "Fbx", s))(pl || {}), fi = /* @__PURE__ */ ((s) => (s[s.IsLoaded = -2147483648] = "IsLoaded", s[s.InitiallyShown = 1073741824] = "InitiallyShown", s[s.InitiallyRemoved = 536870912] = "InitiallyRemoved", s[s.OutOfHierarchy = 268435456] = "OutOfHierarchy", s[s.IsAnnotationView = 134217728] = "IsAnnotationView", s[s.IsCameraSet = 67108864] = "IsCameraSet", s[s.IsPmiFilteringSet = 33554432] = "IsPmiFilteringSet", s[s.IsGeomFilteringSet = 16777216] = "IsGeomFilteringSet", s[s.IsCrossSectionSet = 8388608] = "IsCrossSectionSet", s[s.IsExplosionSet = 4194304] = "IsExplosionSet", s[s.IsCombineState = 2097152] = "IsCombineState", s[s.IsPerspective = 1048576] = "IsPerspective", s[s.IsShownSpecified = 524288] = "IsShownSpecified", s[s.IsShown = 262144] = "IsShown", s[s.BranchVisibilityHidden = 131072] = "BranchVisibilityHidden", s[s.BranchVisibilityShown = 65536] = "BranchVisibilityShown", s[s.BranchVisibilityDirty = 32768] = "BranchVisibilityDirty", s[s.PreventFromResetting = 16384] = "PreventFromResetting", s[s.HasDynamicFrame = 8192] = "HasDynamicFrame", s[s.IsMissing = 4096] = "IsMissing", s[s.IsExternalModelRoot = 2048] = "IsExternalModelRoot", s[s.Requested = 1024] = "Requested", s[s.ImplicitBody = 512] = "ImplicitBody", s[s.IsDefaultView = 256] = "IsDefaultView", s[s.Unused2 = 128] = "Unused2", s[s.Unused1 = 64] = "Unused1", s[s.NodeTypeDrawingSheet = 32] = "NodeTypeDrawingSheet", s[s.IsADefaultNodeType = 16] = "IsADefaultNodeType", s[s.NodeTypeDrawingView = 8] = "NodeTypeDrawingView", s[s.NodeTypeGroup = 4] = "NodeTypeGroup", s[s.NodeTypeProduct = 2] = "NodeTypeProduct", s[s.IsAConfigurationNode = 1] = "IsAConfigurationNode", s))(fi || {}), Br = /* @__PURE__ */ ((s) => (s[
  s.OutOfHierarchy = 268435456
  /* OutOfHierarchy */
] = "OutOfHierarchy", s[
  s.PreventFromResetting = 16384
  /* PreventFromResetting */
] = "PreventFromResetting", s[
  s.Requested = 1024
  /* Requested */
] = "Requested", s[
  s.ImplicitBody = 512
  /* ImplicitBody */
] = "ImplicitBody", s))(Br || {}), If = /* @__PURE__ */ ((s) => (s[
  s.IgnoreParentScale = 1
  /* IgnoreParentScale */
] = "IgnoreParentScale", s[
  s.IgnoreParentRotation = 2
  /* IgnoreParentRotation */
] = "IgnoreParentRotation", s))(If || {}), $t = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.BodyInstance = 1] = "BodyInstance", s[s.PmiBody = 2] = "PmiBody", s[s.ViewFrame = 4] = "ViewFrame", s[s.All = 7] = "All", s))($t || {}), In = /* @__PURE__ */ ((s) => (s[s.ProductOccurrence = 0] = "ProductOccurrence", s[s.AnyBody = 1] = "AnyBody", s[s.BodyInstance = 2] = "BodyInstance", s[s.CadView = 3] = "CadView", s))(In || {}), zi = ((s) => (s[s.InitiallyShown = fi.InitiallyShown] = "InitiallyShown", s[s.InitiallyRemoved = fi.InitiallyRemoved] = "InitiallyRemoved", s[s.IsShownSpecified = fi.IsShownSpecified] = "IsShownSpecified", s[s.IsShown = fi.IsShown] = "IsShown", s[s.IsLoaded = fi.IsLoaded] = "IsLoaded", s))(zi || {}), Cf = ((s) => (s[s.IsMissing = fi.IsMissing] = "IsMissing", s))(Cf || {}), Ii = ((s) => (s[s.IsAnnotationView = fi.IsAnnotationView] = "IsAnnotationView", s[s.IsCameraSet = fi.IsCameraSet] = "IsCameraSet", s[s.IsPmiFilteringSet = fi.IsPmiFilteringSet] = "IsPmiFilteringSet", s[s.IsGeomFilteringSet = fi.IsGeomFilteringSet] = "IsGeomFilteringSet", s[s.IsCrossSectionSet = fi.IsCrossSectionSet] = "IsCrossSectionSet", s[s.IsExplosionSet = fi.IsExplosionSet] = "IsExplosionSet", s[s.IsCombineState = fi.IsCombineState] = "IsCombineState", s[s.IsPerspective = fi.IsPerspective] = "IsPerspective", s[s.HasDynamicFrame = fi.HasDynamicFrame] = "HasDynamicFrame", s[s.IsDefaultView = fi.IsDefaultView] = "IsDefaultView", s))(Ii || {}), ko = /* @__PURE__ */ ((s) => (s[s.Rgba32 = 0] = "Rgba32", s[s.Rgb24 = 1] = "Rgb24", s[s.Gray8 = 2] = "Gray8", s[s.GrayAlpha16 = 3] = "GrayAlpha16", s[s.Jpeg = 4] = "Jpeg", s[s.Png = 5] = "Png", s))(ko || {}), og = /* @__PURE__ */ ((s) => (s[s.Invalid = 4294967295] = "Invalid", s))(og || {}), Ur = /* @__PURE__ */ ((s) => (s[s.Invalid = 4294967295] = "Invalid", s[s.Local = 0] = "Local", s))(Ur || {}), rl = /* @__PURE__ */ ((s) => (s[s.Invalid = 4294967295] = "Invalid", s))(rl || {}), zu = /* @__PURE__ */ ((s) => (s[s.Invalid = 4294967295] = "Invalid", s))(zu || {}), Nm = /* @__PURE__ */ ((s) => (s[s.Invalid = 4294967295] = "Invalid", s))(Nm || {}), Dm = /* @__PURE__ */ ((s) => (s[s.Invalid = 4294967295] = "Invalid", s))(Dm || {}), Ei = /* @__PURE__ */ ((s) => (s[s.Invalid = 4294967295] = "Invalid", s[s.Local = 0] = "Local", s))(Ei || {}), ag = /* @__PURE__ */ ((s) => (s[s.Invalid = 4294967295] = "Invalid", s))(ag || {}), Om = /* @__PURE__ */ ((s) => (s[s.Invalid = 4294967295] = "Invalid", s))(Om || {}), Rm = /* @__PURE__ */ ((s) => (s[s.Invalid = 4294967295] = "Invalid", s))(Rm || {}), Sc = /* @__PURE__ */ ((s) => (s[s.Invalid = 4294967295] = "Invalid", s))(Sc || {}), xs = /* @__PURE__ */ ((s) => (s[s.Invalid = 4294967295] = "Invalid", s[s.Empty = 4294967294] = "Empty", s[s.Local = 0] = "Local", s))(xs || {}), Lm = /* @__PURE__ */ ((s) => (s[s.World = 0] = "World", s[s.Camera = 1] = "Camera", s))(Lm || {}), Hu = /* @__PURE__ */ ((s) => (s[s.Directional = 0] = "Directional", s[s.Point = 1] = "Point", s))(Hu || {}), Ia = /* @__PURE__ */ ((s) => (s[s.OfInitialEmptyModel = 0] = "OfInitialEmptyModel", s))(Ia || {}), ol = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.SMAA = 1] = "SMAA", s))(ol || {}), Pc = /* @__PURE__ */ ((s) => (s[s.Floor = 0] = "Floor", s[s.Wall = 1] = "Wall", s[s.Door = 2] = "Door", s))(Pc || {}), kc = /* @__PURE__ */ ((s) => (s[s.Pixels = 0] = "Pixels", s[s.ProportionOfWidth = 1] = "ProportionOfWidth", s[s.ProportionOfHeight = 2] = "ProportionOfHeight", s))(kc || {}), Fm = /* @__PURE__ */ ((s) => (s[s.Object = 0] = "Object", s[s.World = 1] = "World", s))(Fm || {}), dr = /* @__PURE__ */ ((s) => (s[s.Default = 0] = "Default", s[s.Highlight = 1] = "Highlight", s[s.HiddenLine = 2] = "HiddenLine", s[s.XRay = 3] = "XRay", s[s.Gooch = 4] = "Gooch", s[s.Toon = 5] = "Toon", s))(dr || {}), Bm = /* @__PURE__ */ ((s) => (s[s.FixedFramerate = 0] = "FixedFramerate", s[s.OcclusionCulling = 1] = "OcclusionCulling", s))(Bm || {}), an = /* @__PURE__ */ ((s) => (s[s.Faces = 0] = "Faces", s[s.Lines = 1] = "Lines", s[s.Points = 2] = "Points", s))(an || {}), Vm = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.Faces = 1] = "Faces", s[s.Lines = 2] = "Lines", s[s.Points = 4] = "Points", s[s.All = 7] = "All", s))(Vm || {}), An = /* @__PURE__ */ ((s) => (s[s.Base = 0] = "Base", s[s.Specular = 1] = "Specular", s[s.Emissive = 2] = "Emissive", s[s.Ambient = 3] = "Ambient", s))(An || {}), Or = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.Modulate = 1] = "Modulate", s[s.Desaturate = 2] = "Desaturate", s[s.Colorize = 3] = "Colorize", s))(Or || {}), Uu = /* @__PURE__ */ ((s) => (s[s.Visible = 0] = "Visible", s[s.VisibleWithFullOutline = 1] = "VisibleWithFullOutline", s))(Uu || {}), zm = /* @__PURE__ */ ((s) => (s[s.Object = 0] = "Object", s[s.World = 1] = "World", s[s.ProportionOfScreenWidth = 2] = "ProportionOfScreenWidth", s[s.ProportionOfScreenHeight = 3] = "ProportionOfScreenHeight", s))(zm || {}), Hm = /* @__PURE__ */ ((s) => (s[s.Square = 0] = "Square", s[s.Disk = 1] = "Disk", s[s.Sphere = 2] = "Sphere", s))(Hm || {}), Um = /* @__PURE__ */ ((s) => (s[s.ScreenPixels = 0] = "ScreenPixels", s[s.CSSPixels = 1] = "CSSPixels", s[s.World = 2] = "World", s[s.ProportionOfScreenWidth = 3] = "ProportionOfScreenWidth", s[s.ProportionOfScreenHeight = 4] = "ProportionOfScreenHeight", s[s.ProportionOfBoundingDiagonal = 5] = "ProportionOfBoundingDiagonal", s))(Um || {}), Jc = /* @__PURE__ */ ((s) => (s[s.Perspective = 0] = "Perspective", s[s.Orthographic = 1] = "Orthographic", s[s.Stretched = 2] = "Stretched", s))(Jc || {}), en = /* @__PURE__ */ ((s) => (s[s.Uninitialized = 0] = "Uninitialized", s[s.Network = 1] = "Network", s[s.Scs = 2] = "Scs", s))(en || {}), oo = /* @__PURE__ */ ((s) => (s[s.Hide = 0] = "Hide", s[s.Show = 1] = "Show", s[s.Initial = 2] = "Initial", s))(oo || {}), lg = /* @__PURE__ */ ((s) => (s[s.World = 0] = "World", s[s.ProportionOfBoundingHeight = 1] = "ProportionOfBoundingHeight", s))(lg || {}), jm = /* @__PURE__ */ ((s) => (s[s.Low = 0] = "Low", s[s.Medium = 1] = "Medium", s[s.High = 2] = "High", s[s.Ultra = 3] = "Ultra", s))(jm || {}), cg = /* @__PURE__ */ ((s) => (s[s.SessionNotStarted = 0] = "SessionNotStarted", s[s.Cancelled = 1] = "Cancelled", s[s.CorruptRpcMessage = 2] = "CorruptRpcMessage", s))(cg || {}), ju = /* @__PURE__ */ ((s) => (s[s.On = 0] = "On", s[s.Off = 1] = "Off", s))(ju || {}), Wu = /* @__PURE__ */ ((s) => (s[s.On = 0] = "On", s[s.Off = 1] = "Off", s))(Wu || {}), Mc = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.Decal = 1] = "Decal", s))(Mc || {}), Gu = /* @__PURE__ */ ((s) => (s[s.UV = 0] = "UV", s))(Gu || {}), $u = /* @__PURE__ */ ((s) => (s[s.Repeat = 0] = "Repeat", s[s.Clamp = 1] = "Clamp", s[s.Trim = 2] = "Trim", s))($u || {}), Wm = /* @__PURE__ */ ((s) => (s[s.Unsorted = 0] = "Unsorted", s[s.SingleLayer = 1] = "SingleLayer", s))(Wm || {}), qu = /* @__PURE__ */ ((s) => (s[s.Selected = 0] = "Selected", s[s.Unselected = 1] = "Unselected", s))(qu || {}), mn = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.Floor = 1] = "Floor", s[s.Wall = 2] = "Wall", s[s.Door = 4] = "Door", s))(mn || {}), Me = /* @__PURE__ */ ((s) => (s[s.Invalid = -1] = "Invalid", s[s.Default = 0] = "Default", s))(Me || {}), ur = /* @__PURE__ */ ((s) => (s[s.UpperLeftCorner = 0] = "UpperLeftCorner", s[s.LowerLeftCorner = 1] = "LowerLeftCorner", s[s.LowerRightCorner = 2] = "LowerRightCorner", s[s.UpperRightCorner = 3] = "UpperRightCorner", s[s.TopCenter = 4] = "TopCenter", s[s.LeftCenter = 5] = "LeftCenter", s[s.RightCenter = 6] = "RightCenter", s[s.BottomCenter = 7] = "BottomCenter", s[s.Center = 8] = "Center", s))(ur || {}), al = /* @__PURE__ */ ((s) => (s[s.Pixels = 0] = "Pixels", s[s.ProportionOfScreen = 1] = "ProportionOfScreen", s[s.MinimumProportionOfScreen = 2] = "MinimumProportionOfScreen", s[s.ProportionOfOtherDimension = 3] = "ProportionOfOtherDimension", s))(al || {});
const Ns = 0;
function ha(s) {
  return s !== null && typeof s == "object" && "scFunction" in s && typeof s.scFunction == "string";
}
function Gm(s) {
  const t = s.data;
  return t !== null && typeof t == "object" && "scStateFailure" in t ? t.scStateFailure : null;
}
var ga = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function fd(s) {
  return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s;
}
var $m = { exports: {} };
/*!
 * Bowser - a browser detector
 * https://github.com/ded/bowser
 * MIT License | (c) Dustin Diaz 2015
 */
(function(s) {
  (function(t, e, i) {
    s.exports ? s.exports = i() : t[e] = i();
  })(ga, "bowser", function() {
    var t = !0;
    function e(u) {
      function d(X) {
        var At = u.match(X);
        return At && At.length > 1 && At[1] || "";
      }
      function g(X) {
        var At = u.match(X);
        return At && At.length > 1 && At[2] || "";
      }
      var y = d(/(ipod|iphone|ipad)/i).toLowerCase(), m = /like android/i.test(u), x = !m && /android/i.test(u), b = /nexus\s*[0-6]\s*/i.test(u), I = !b && /nexus\s*[0-9]+/i.test(u), C = /CrOS/.test(u), P = /silk/i.test(u), k = /sailfish/i.test(u), O = /tizen/i.test(u), B = /(web|hpw)(o|0)s/i.test(u), j = /windows phone/i.test(u), V = !j && /windows/i.test(u), Y = !y && !P && /macintosh/i.test(u), q = !x && !k && !O && !B && /linux/i.test(u), st = g(/edg([ea]|ios)\/(\d+(\.\d+)?)/i), dt = d(/version\/(\d+(\.\d+)?)/i), U = /tablet/i.test(u) && !/tablet pc/i.test(u), J = !U && /[^-]mobi/i.test(u), A = /xbox/i.test(u), R;
      /opera/i.test(u) ? R = {
        name: "Opera",
        opera: t,
        version: dt || d(/(?:opera|opr|opios)[\s\/](\d+(\.\d+)?)/i)
      } : /opr\/|opios/i.test(u) ? R = {
        name: "Opera",
        opera: t,
        version: d(/(?:opr|opios)[\s\/](\d+(\.\d+)?)/i) || dt
      } : /SamsungBrowser/i.test(u) ? R = {
        name: "Samsung Internet for Android",
        samsungBrowser: t,
        version: dt || d(/(?:SamsungBrowser)[\s\/](\d+(\.\d+)?)/i)
      } : /Whale/i.test(u) ? R = {
        name: "NAVER Whale browser",
        whale: t,
        version: d(/(?:whale)[\s\/](\d+(?:\.\d+)+)/i)
      } : /MZBrowser/i.test(u) ? R = {
        name: "MZ Browser",
        mzbrowser: t,
        version: d(/(?:MZBrowser)[\s\/](\d+(?:\.\d+)+)/i)
      } : /coast/i.test(u) ? R = {
        name: "Opera Coast",
        coast: t,
        version: dt || d(/(?:coast)[\s\/](\d+(\.\d+)?)/i)
      } : /focus/i.test(u) ? R = {
        name: "Focus",
        focus: t,
        version: d(/(?:focus)[\s\/](\d+(?:\.\d+)+)/i)
      } : /yabrowser/i.test(u) ? R = {
        name: "Yandex Browser",
        yandexbrowser: t,
        version: dt || d(/(?:yabrowser)[\s\/](\d+(\.\d+)?)/i)
      } : /ucbrowser/i.test(u) ? R = {
        name: "UC Browser",
        ucbrowser: t,
        version: d(/(?:ucbrowser)[\s\/](\d+(?:\.\d+)+)/i)
      } : /mxios/i.test(u) ? R = {
        name: "Maxthon",
        maxthon: t,
        version: d(/(?:mxios)[\s\/](\d+(?:\.\d+)+)/i)
      } : /epiphany/i.test(u) ? R = {
        name: "Epiphany",
        epiphany: t,
        version: d(/(?:epiphany)[\s\/](\d+(?:\.\d+)+)/i)
      } : /puffin/i.test(u) ? R = {
        name: "Puffin",
        puffin: t,
        version: d(/(?:puffin)[\s\/](\d+(?:\.\d+)?)/i)
      } : /sleipnir/i.test(u) ? R = {
        name: "Sleipnir",
        sleipnir: t,
        version: d(/(?:sleipnir)[\s\/](\d+(?:\.\d+)+)/i)
      } : /k-meleon/i.test(u) ? R = {
        name: "K-Meleon",
        kMeleon: t,
        version: d(/(?:k-meleon)[\s\/](\d+(?:\.\d+)+)/i)
      } : j ? (R = {
        name: "Windows Phone",
        osname: "Windows Phone",
        windowsphone: t
      }, st ? (R.msedge = t, R.version = st) : (R.msie = t, R.version = d(/iemobile\/(\d+(\.\d+)?)/i))) : /msie|trident/i.test(u) ? R = {
        name: "Internet Explorer",
        msie: t,
        version: d(/(?:msie |rv:)(\d+(\.\d+)?)/i)
      } : C ? R = {
        name: "Chrome",
        osname: "Chrome OS",
        chromeos: t,
        chromeBook: t,
        chrome: t,
        version: d(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
      } : /edg([ea]|ios)/i.test(u) ? R = {
        name: "Microsoft Edge",
        msedge: t,
        version: st
      } : /vivaldi/i.test(u) ? R = {
        name: "Vivaldi",
        vivaldi: t,
        version: d(/vivaldi\/(\d+(\.\d+)?)/i) || dt
      } : k ? R = {
        name: "Sailfish",
        osname: "Sailfish OS",
        sailfish: t,
        version: d(/sailfish\s?browser\/(\d+(\.\d+)?)/i)
      } : /seamonkey\//i.test(u) ? R = {
        name: "SeaMonkey",
        seamonkey: t,
        version: d(/seamonkey\/(\d+(\.\d+)?)/i)
      } : /firefox|iceweasel|fxios/i.test(u) ? (R = {
        name: "Firefox",
        firefox: t,
        version: d(/(?:firefox|iceweasel|fxios)[ \/](\d+(\.\d+)?)/i)
      }, /\((mobile|tablet);[^\)]*rv:[\d\.]+\)/i.test(u) && (R.firefoxos = t, R.osname = "Firefox OS")) : P ? R = {
        name: "Amazon Silk",
        silk: t,
        version: d(/silk\/(\d+(\.\d+)?)/i)
      } : /phantom/i.test(u) ? R = {
        name: "PhantomJS",
        phantom: t,
        version: d(/phantomjs\/(\d+(\.\d+)?)/i)
      } : /slimerjs/i.test(u) ? R = {
        name: "SlimerJS",
        slimer: t,
        version: d(/slimerjs\/(\d+(\.\d+)?)/i)
      } : /blackberry|\bbb\d+/i.test(u) || /rim\stablet/i.test(u) ? R = {
        name: "BlackBerry",
        osname: "BlackBerry OS",
        blackberry: t,
        version: dt || d(/blackberry[\d]+\/(\d+(\.\d+)?)/i)
      } : B ? (R = {
        name: "WebOS",
        osname: "WebOS",
        webos: t,
        version: dt || d(/w(?:eb)?osbrowser\/(\d+(\.\d+)?)/i)
      }, /touchpad\//i.test(u) && (R.touchpad = t)) : /bada/i.test(u) ? R = {
        name: "Bada",
        osname: "Bada",
        bada: t,
        version: d(/dolfin\/(\d+(\.\d+)?)/i)
      } : O ? R = {
        name: "Tizen",
        osname: "Tizen",
        tizen: t,
        version: d(/(?:tizen\s?)?browser\/(\d+(\.\d+)?)/i) || dt
      } : /qupzilla/i.test(u) ? R = {
        name: "QupZilla",
        qupzilla: t,
        version: d(/(?:qupzilla)[\s\/](\d+(?:\.\d+)+)/i) || dt
      } : /chromium/i.test(u) ? R = {
        name: "Chromium",
        chromium: t,
        version: d(/(?:chromium)[\s\/](\d+(?:\.\d+)?)/i) || dt
      } : /chrome|crios|crmo/i.test(u) ? R = {
        name: "Chrome",
        chrome: t,
        version: d(/(?:chrome|crios|crmo)\/(\d+(\.\d+)?)/i)
      } : x ? R = {
        name: "Android",
        version: dt
      } : /safari|applewebkit/i.test(u) ? (R = {
        name: "Safari",
        safari: t
      }, dt && (R.version = dt)) : y ? (R = {
        name: y == "iphone" ? "iPhone" : y == "ipad" ? "iPad" : "iPod"
      }, dt && (R.version = dt)) : /googlebot/i.test(u) ? R = {
        name: "Googlebot",
        googlebot: t,
        version: d(/googlebot\/(\d+(\.\d+))/i) || dt
      } : R = {
        name: d(/^(.*)\/(.*) /),
        version: g(/^(.*)\/(.*) /)
      }, !R.msedge && /(apple)?webkit/i.test(u) ? (/(apple)?webkit\/537\.36/i.test(u) ? (R.name = R.name || "Blink", R.blink = t) : (R.name = R.name || "Webkit", R.webkit = t), !R.version && dt && (R.version = dt)) : !R.opera && /gecko\//i.test(u) && (R.name = R.name || "Gecko", R.gecko = t, R.version = R.version || d(/gecko\/(\d+(\.\d+)?)/i)), !R.windowsphone && (x || R.silk) ? (R.android = t, R.osname = "Android") : !R.windowsphone && y ? (R[y] = t, R.ios = t, R.osname = "iOS") : Y ? (R.mac = t, R.osname = "macOS") : A ? (R.xbox = t, R.osname = "Xbox") : V ? (R.windows = t, R.osname = "Windows") : q && (R.linux = t, R.osname = "Linux");
      function wt(X) {
        switch (X) {
          case "NT":
            return "NT";
          case "XP":
            return "XP";
          case "NT 5.0":
            return "2000";
          case "NT 5.1":
            return "XP";
          case "NT 5.2":
            return "2003";
          case "NT 6.0":
            return "Vista";
          case "NT 6.1":
            return "7";
          case "NT 6.2":
            return "8";
          case "NT 6.3":
            return "8.1";
          case "NT 10.0":
            return "10";
          default:
            return;
        }
      }
      var z = "";
      R.windows ? z = wt(d(/Windows ((NT|XP)( \d\d?.\d)?)/i)) : R.windowsphone ? z = d(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i) : R.mac ? (z = d(/Mac OS X (\d+([_\.\s]\d+)*)/i), z = z.replace(/[_\s]/g, ".")) : y ? (z = d(/os (\d+([_\s]\d+)*) like mac os x/i), z = z.replace(/[_\s]/g, ".")) : x ? z = d(/android[ \/-](\d+(\.\d+)*)/i) : R.webos ? z = d(/(?:web|hpw)os\/(\d+(\.\d+)*)/i) : R.blackberry ? z = d(/rim\stablet\sos\s(\d+(\.\d+)*)/i) : R.bada ? z = d(/bada\/(\d+(\.\d+)*)/i) : R.tizen && (z = d(/tizen[\/\s](\d+(\.\d+)*)/i)), z && (R.osversion = z);
      var St = !R.windows && z.split(".")[0];
      return U || I || y == "ipad" || x && (St == 3 || St >= 4 && !J) || R.silk ? R.tablet = t : (J || y == "iphone" || y == "ipod" || x || b || R.blackberry || R.webos || R.bada) && (R.mobile = t), R.msedge || R.msie && R.version >= 10 || R.yandexbrowser && R.version >= 15 || R.vivaldi && R.version >= 1 || R.chrome && R.version >= 20 || R.samsungBrowser && R.version >= 4 || R.whale && o([R.version, "1.0"]) === 1 || R.mzbrowser && o([R.version, "6.0"]) === 1 || R.focus && o([R.version, "1.0"]) === 1 || R.firefox && R.version >= 20 || R.safari && R.version >= 6 || R.opera && R.version >= 10 || R.ios && R.osversion && R.osversion.split(".")[0] >= 6 || R.blackberry && R.version >= 10.1 || R.chromium && R.version >= 20 ? R.a = t : R.msie && R.version < 10 || R.chrome && R.version < 20 || R.firefox && R.version < 20 || R.safari && R.version < 6 || R.opera && R.version < 10 || R.ios && R.osversion && R.osversion.split(".")[0] < 6 || R.chromium && R.version < 20 ? R.c = t : R.x = t, R;
    }
    var i = e(typeof navigator < "u" && navigator.userAgent || "");
    i.test = function(u) {
      for (var d = 0; d < u.length; ++d) {
        var g = u[d];
        if (typeof g == "string" && g in i)
          return !0;
      }
      return !1;
    };
    function n(u) {
      return u.split(".").length;
    }
    function r(u, d) {
      var g = [], y;
      if (Array.prototype.map)
        return Array.prototype.map.call(u, d);
      for (y = 0; y < u.length; y++)
        g.push(d(u[y]));
      return g;
    }
    function o(u) {
      for (var d = Math.max(n(u[0]), n(u[1])), g = r(u, function(y) {
        var m = d - n(y);
        return y = y + new Array(m + 1).join(".0"), r(y.split("."), function(x) {
          return new Array(20 - x.length).join("0") + x;
        }).reverse();
      }); --d >= 0; ) {
        if (g[0][d] > g[1][d])
          return 1;
        if (g[0][d] === g[1][d]) {
          if (d === 0)
            return 0;
        } else
          return -1;
      }
    }
    function l(u, d, g) {
      var y = i;
      typeof d == "string" && (g = d, d = void 0), d === void 0 && (d = !1), g && (y = e(g));
      var m = "" + y.version;
      for (var x in u)
        if (u.hasOwnProperty(x) && y[x]) {
          if (typeof u[x] != "string")
            throw new Error("Browser version in the minVersion map should be a string: " + x + ": " + String(u));
          return o([m, u[x]]) < 0;
        }
      return d;
    }
    function h(u, d, g) {
      return !l(u, d, g);
    }
    return i.isUnsupportedBrowser = l, i.compareVersions = o, i.check = h, i._detect = e, i.detect = e, i;
  });
})($m);
var qm = $m.exports;
const pv = /* @__PURE__ */ fd(qm), mv = /* @__PURE__ */ tv({
  __proto__: null,
  default: pv
}, [qm]);
var _v = (() => {
  var s = import.meta.url;
  return function(t) {
    t = t || {};
    var e;
    e || (e = typeof t < "u" ? t : {});
    var i, n;
    e.ready = new Promise(function(a, c) {
      i = a, n = c;
    }), e.$$setReady = function() {
      e.kk(), e.$$onReady.apply(window, arguments), e.$$onReady = void 0, e.onAbort = void 0;
    }, e.kk = function() {
      function a(Bt) {
        if (!Bt)
          return 0;
        var Nt = e.$$es.allocateUint8Buffer(8 * Bt.length);
        if (Nt)
          At.set(Bt, Nt >> 3);
        else
          throw Error("Out of memory.");
        return Nt;
      }
      function c(Bt) {
        if (!Bt)
          return 0;
        var Nt = e.$$es.allocateUint8Buffer(4 * Bt.length);
        if (Nt)
          St.set(Bt, Nt >> 2);
        else
          throw Error("Out of memory.");
        return Nt;
      }
      function f(Bt) {
        if (!Bt)
          return 0;
        var Nt = e.$$es.allocateUint8Buffer(Bt.length);
        if (Nt)
          A.set(Bt, Nt);
        else
          throw Error("Out of memory.");
        return Nt;
      }
      function p(Bt) {
        e.$$es.deallocateUint8Buffer(Bt);
      }
      function v(Bt) {
        return function() {
          return H(
            Bt,
            arguments
          );
        };
      }
      function M(Bt, Nt, We) {
        function ie(Kn) {
          return function() {
            return Wt(), Ce && yt.callRecord.push(Kn + " " + ht(arguments)), L(this, e[Bt][Kn], arguments);
          };
        }
        function ki() {
          Wt(), this.$$memory = new Uint8Array(e[Bt]["sizeof_" + Nt]()), L(this, e[Bt][Pe + "create"], arguments);
        }
        var Pe = Nt + "_";
        ki.prototype = { $$stackify: !0 }, ki.copy = function(Kn) {
          Wt();
          var fs = Object.create(ki.prototype);
          return fs.$$memory = new Uint8Array(A.subarray(Kn, Kn + e[Bt]["sizeof_" + Nt]())), fs;
        }, ki.clone = function(Kn) {
          var fs = Object.create(ki.prototype);
          return fs.$$memory = new Uint8Array(Kn.$$memory), fs;
        }, ki.assign = function(Kn, fs) {
          Kn.$$memory.set(fs.$$memory);
        };
        for (var zn = 0; zn < We.length; zn++)
          ki.prototype[We[zn]] = ie(Pe + We[zn]);
        return yt[Nt] = ki;
      }
      function L(Bt, Nt, We) {
        return We = Array.prototype.slice.call(We), We.unshift(Bt), H(Nt, We);
      }
      function H(Bt, Nt) {
        for (var We = !1, ie = 0; ie < Nt.length; ++ie)
          if (Nt[ie].$$stackify) {
            We = !0;
            break;
          }
        if (!We)
          return Bt.apply(e, Nt);
        We = au();
        try {
          var ki = Array.prototype.slice.call(Nt);
          for (ie = 0; ie < Nt.length; ie++)
            if (Nt[ie].$$stackify) {
              var Pe = nc(Nt[ie].$$memory.length);
              A.set(Nt[ie].$$memory, Pe), ki[ie] = Pe;
            }
          var zn = Bt.apply(
            e,
            ki
          );
          for (ie = 0; ie < Nt.length; ie++)
            Nt[ie].$$stackify && Nt[ie].$$memory.set(A.subarray(ki[ie], ki[ie] + Nt[ie].$$memory.length));
        } finally {
          lu(We);
        }
        return zn;
      }
      function Q(Bt) {
        this.value = Bt;
      }
      function lt(Bt) {
        yt.suspendDrawing(Bt), e.ki("webgl_context_lost");
      }
      function ht() {
        return JSON.stringify(arguments, Tt);
      }
      function Tt(Bt, Nt) {
        return Nt !== null && typeof Nt == "object" && Nt.$$memory ? "stackified" : Nt;
      }
      function Wt() {
        if (yt !== e.$$facade)
          throw new ReferenceError("member called after shutdown");
      }
      var et = "$$cs";
      e.$$es.initializeLibrary();
      var yt = e.$$facade, qt = e.Oj ? new e.Oj() : void 0;
      e.tj = qt, yt.isValid = function() {
        return yt === e.$$facade;
      };
      var Ce = !1;
      yt.callRecord = [], yt.startRecording = function() {
        Ce = !0;
      }, yt.stopRecording = function() {
        Ce = !1;
      }, yt.logCallRecord = function() {
        for (var Bt = yt.callRecord, Nt = 0; Nt < Bt.length; ++Nt)
          console.log(Bt[Nt]);
      }, yt.shutDown = function() {
        Wt(), Ce && yt.callRecord.push("shutDown"), et === "$$cs" && e.canvas.removeEventListener("webglcontextlost", lt), e.$$es.shutDownLibrary(), qt && qt.Xk(), e.$$legacyClient ? (yt.container.innerHTML = "", e.$$wrapper.innerHTML = "") : (yt.containers.forEach((Bt) => {
          Bt.innerHTML = "";
        }), yt.wrappers.forEach((Bt) => {
          Bt.innerHTML = "";
        })), e.$$facade = void 0, e.tj = void 0, e.$$available = !0;
      }, yt.ByMeshInstance = new Q(0), yt.ByGroup = new Q(1), yt.ByExpandedGroup = new Q(2), function() {
        function Bt(G, tt) {
          if (ie([Xt.Scs]), !G)
            throw new Pe("InvalidConfig", "Invalid load configuration");
          var ct, gt, kt = new Promise(function(ke, ze) {
            ct = ke, gt = ze;
          });
          Hn = Xt.Scs;
          var Jt = new XMLHttpRequest();
          if (Jt.open("GET", tt), Jt.responseType = "arraybuffer", Jt.onload = function() {
            try {
              Nt(G, new Uint8Array(this.response)).then(function(ke) {
                ct(ke);
              }, function(ke) {
                gt(ke);
              });
            } catch {
            }
          }, typeof G.XHRonprogress == "function" && (Jt.onprogress = G.XHRonprogress), typeof G.XHRonerror == "function" && (Jt.onerror = G.XHRonerror), typeof G.XHRonloadend == "function") {
            var Ze = G.XHRonloadend;
            Jt.onloadend = function(ke) {
              Ze(ke, Jt.status, tt);
            };
          }
          return Jt.send(), kt;
        }
        function Nt(G, tt) {
          if (ie([Xt.Scs]), !G)
            throw new Pe("InvalidConfig", "Invalid load configuration");
          if (tt.constructor !== Uint8Array)
            throw new Pe("InvalidConfig", "'buffer' must be a Uint8Array");
          if (0 >= tt.byteLength)
            throw new Pe("EmptyBuffer", "'buffer' has a length of 0");
          var ct = e.$$es.allocateUint8Buffer(tt.byteLength);
          A.set(tt, ct);
          try {
            return We(G, ct, tt.byteLength);
          } catch (gt) {
            throw e.$$es.deallocateUint8Buffer(ct), gt;
          }
        }
        function We(G, tt, ct) {
          ie([Xt.Scs]);
          var gt = G.attachScope, kt = G.attachMeasurementUnit, Jt = G.attachInvisibly, Ze = G.resolveOnFullyLoaded, ke = G.inclusionMatrix;
          G = G.cancelUnitMatrix;
          var ze = 0;
          if (ke) {
            if (ke.constructor !== Array && ke.constructor !== Float64Array)
              throw new TypeError("'inclusionMatrix' is not an Array or Float64Array.");
            if (ke.length !== 12)
              throw new TypeError("'inclusionMatrix' needs to have exactly 12 elements.");
            if (ze = a(ke), !ze)
              throw Error("Internal logic error.");
          }
          Hn = Xt.Scs;
          var ps, Mn;
          ke = new Promise(function(Un, ms) {
            ps = Un, Mn = function(ks) {
              try {
                ki(ks), ms(null);
              } catch (Ws) {
                ms(Ws);
              }
            };
          });
          try {
            e.$$es.attachScsBuffer(gt, tt, ct, ze, kt, Jt, Ze, G, ps, Mn);
          } catch (Un) {
            Mn(Un);
          } finally {
            p(ze);
          }
          return ke;
        }
        function ie(G) {
          if (Hn !== Xt.Uninitialized) {
            if (G !== void 0) {
              for (var tt = 0; tt < G.length; ++tt)
                if (Hn === G[tt])
                  return;
            }
            throw new Pe("AlreadyCalled", "load() already called with an incompatible session type");
          }
        }
        function ki(G) {
          switch (G) {
            case e.LoadResult.WebGLMissing:
              throw new Pe(
                "WebGLError",
                "WebGL initialization failed"
              );
            case e.LoadResult.SessionAlreadyStarted:
              throw new Pe("AlreadyCalled", "load() already called");
          }
        }
        function Pe(G, tt) {
          this.code = G, this.message = tt, this.stack = Error().stack;
        }
        function zn(G) {
          var tt = JSON.parse(Y(G, 0));
          if ("rpc" in tt) {
            if (G = tt.rpc, tt = G.length / 2, tt === Math.floor(tt)) {
              for (var ct = new Uint8Array(tt), gt = 0; gt < tt; ++gt)
                ct[gt] = parseInt(G.substr(gt + gt, 2), 16);
              G = ct, tt = new DataView(G.buffer).getUint32(0, !0), ct = G[4], G = G.subarray(5), gt = f(G), e[et].notifyRpcClientResult(tt, ct, gt, G.length);
            }
          } else if ("event" in tt)
            switch (G = tt.event, tt = tt.data, G) {
              case "camera_set":
                Ya = na(tt), e.ki(G);
                break;
              default:
                Array.isArray(tt) ? (tt.unshift(G), e.ki.apply(e, tt)) : e.ki(G, tt);
            }
        }
        function Kn(G) {
          var tt = f(G);
          e.$$es.parseMetaData(Ja, tt, G.length);
        }
        function fs(G) {
          G = Y(G, 0), e.ki("post_draw_json", G);
        }
        function na(G) {
          var tt = new gs();
          return tt.reset.apply(tt, G), tt;
        }
        function Xa(G) {
          function tt(Mi, Er, ge, Xe) {
            if (0 > Xe || Xe >= Er.elementCount)
              throw new RangeError("invalid element index");
            var dn = { vertexCount: Ze[Mi][3 * Xe + 1], bits: Ze[Mi][3 * Xe + 2], iterate: function(Ms) {
              return gt(
                Mi,
                Er,
                ge,
                Xe,
                this,
                Ms
              );
            } };
            return typeof Symbol < "u" && typeof Symbol.iterator < "u" && (dn[Symbol.iterator] = ct), dn;
          }
          function ct() {
            return this.iterate(!0);
          }
          function gt(Mi, Er, ge, Xe, dn, Ms) {
            function Co() {
              var En = { position: void 0, normal: void 0, UV: void 0, RGBA: void 0 };
              ++Ar;
              for (var Ri = 0; Ri < Zr.length; ++Ri)
                Zr[Ri](En);
              return En;
            }
            if (typeof Xe == "number")
              var uu = ge + Ze[Mi][3 * Xe], du = dn.vertexCount;
            else
              uu = ge, du = Er.vertexCount;
            var rf = uu + du, Ar = uu, Zr = [];
            if (ze ? Zr.push(function(En) {
              var Ri = [kt[Es], kt[Es + 1], kt[Es + 2]];
              En.position = [ze[0] * Ri[0] + ze[4] * Ri[1] + ze[8] * Ri[2] + ze[12], ze[1] * Ri[0] + ze[5] * Ri[1] + ze[9] * Ri[2] + ze[13], ze[2] * Ri[0] + ze[6] * Ri[1] + ze[10] * Ri[2] + ze[14]];
            }) : Zr.push(function(En) {
              En.position = [kt[Es], kt[Es + 1], kt[Es + 2]];
            }), Er.hasNormals && Zr.push(function(En) {
              var Ri = Es + ps;
              En.normal = [kt[Ri], kt[Ri + 1], kt[Ri + 2]];
            }), Er.hasUVs && Zr.push(function(En) {
              var Ri = Es + Mn;
              En.UV = [kt[Ri], kt[Ri + 1]];
            }), Er.hasRGBAs) {
              var fu = new Uint8Array(kt.buffer);
              Zr.push(function(En) {
                var Ri = Es + Un << 2;
                En.RGBA = [fu[Ri], fu[Ri + 1], fu[Ri + 2], fu[Ri + 3]];
              });
            }
            if (Jt) {
              var Es = Jt[Ar] * ke;
              Zr.push(function() {
                Es = Jt[Ar] * ke;
              });
            } else
              Es = Ar * ke, Zr.push(function() {
                Es += ke;
              });
            return { done: function() {
              return Ar >= rf;
            }, next: Ms ? function() {
              return Ar < rf ? { value: Co(), done: !1 } : { done: !0 };
            } : function() {
              if (Ar < rf)
                return Co();
            }, goTo: function(En) {
              0 > En ? En = 0 : En >= du && (En = du), Ar = uu + En, Es = Jt ? Jt[Ar] * ke : Ar * ke;
            } };
          }
          var kt = G.vertices, Jt = G.indices, Ze = G.elements, ke = G.stride, ze = G.duplicateMatrix, ps = G.normalOffset, Mn = G.UVOffset, Un = G.RGBA32Offset, ms = G.faceVertexCount, ks = ms + G.lineVertexCount, Ws = { faces: { vertexCount: G.faceVertexCount, hasNormals: !!G.faceNormals, hasUVs: !!G.faceUVs, hasRGBAs: !!G.faceRGBA32s, elementCount: Ze[0] ? Ze[0].length / 3 : 0, iterate: function(Mi) {
            return gt(0, this, 0, void 0, void 0, Mi);
          }, element: function(Mi) {
            return tt(0, this, 0, Mi);
          } }, lines: { vertexCount: G.lineVertexCount, hasNormals: !!G.lineNormals, hasUVs: !!G.lineUVs, hasRGBAs: !!G.lineRGBA32s, elementCount: Ze[1] ? Ze[1].length / 3 : 0, iterate: function(Mi) {
            return gt(1, this, ms, void 0, void 0, Mi);
          }, element: function(Mi) {
            return tt(1, this, ms, Mi);
          } }, points: { vertexCount: G.pointVertexCount, hasNormals: !!G.pointNormals, hasUVs: !!G.pointUVs, hasRGBAs: !!G.pointRGBA32s, elementCount: Ze[2] ? Ze[2].length / 3 : 0, iterate: function(Mi) {
            return gt(2, this, ks, void 0, void 0, Mi);
          }, element: function(Mi) {
            return tt(2, this, ks, Mi);
          } } };
          typeof Symbol < "u" && typeof Symbol.iterator < "u" && (Ws.faces[Symbol.iterator] = ct, Ws.lines[Symbol.iterator] = ct, Ws.points[Symbol.iterator] = ct), G = G.forward;
          for (let Mi in G)
            G.hasOwnProperty(Mi) && (Ws[Mi] = G[Mi]);
          return Ws;
        }
        function Ja(G, tt, ct) {
          var gt = Mr[G];
          gt || (gt = Mr[G] = {}), gt[tt] = ct, e.ki(
            "meta_data",
            G,
            tt,
            ct
          );
        }
        function rn(G, tt) {
          if (et === "$$cs")
            return Oe.getMetaData(G);
          kr(G);
          for (var ct = [], gt = 0; gt < G.length; gt += 2) {
            var kt = G[gt], Jt = G[gt + 1], Ze = Mr[kt];
            (Ze ? Ze[Jt] : void 0) === void 0 && ct.push(kt, Jt);
          }
          if (ct.length === 0) {
            for (tt = [], gt = 0; gt < G.length; gt += 2)
              kt = G[gt], Jt = G[gt + 1], tt.push(Mr[kt][Jt]);
            return Promise.resolve(tt);
          }
          return tt ? (gt = new we("getMetaData", ct), Promise.reject(gt)) : Oe.requestMetaData(ct).then(function() {
            return Wt(), rn(G, !0);
          });
        }
        function rr() {
          et === "$$cs" && e.$$es.disconnectNetwork();
        }
        function D(G, tt, ct) {
          if (typeof ct == "function")
            Yr(G, tt, ct);
          else {
            ct = ct || 0;
            var gt = typeof G == "string" ? G + "_" + tt : tt, kt;
            e.$$es[gt] ? kt = e.$$es[gt] : kt = function() {
              return e[et][gt].apply(e, arguments);
            };
            var Jt = kt;
            ct & 1 && (Jt = function(ge) {
              return ge == 0 ? e.$$cs[gt].apply(e, arguments) : kt.apply(e, arguments);
            });
            var Ze = Jt;
            ct & 2 && (Ze = function(ge) {
              typeof ge == "number" && (ge = [ge]);
              var Xe = c(ge);
              if (!Xe)
                throw new TypeError("`keys' is not an Array or Uint32Array");
              var dn = Array.prototype.slice.call(arguments, 1);
              return dn.unshift(Xe, ge.length), Jt.apply(e, dn);
            });
            var ke = Ze;
            ct & 4 && (ke = function(ge) {
              kr(ge);
              var Xe = c(ge);
              if (!Xe)
                throw new TypeError("`ids' is not an Array or Uint32Array.");
              var dn = Array.prototype.slice.call(arguments, 1);
              return dn.unshift(Xe, ge.length >> 1), Ze.apply(e, dn);
            });
            var ze = ke;
            ct & 8 && (ze = function(ge) {
              ge.length === 4 && typeof ge[0] == "number" && (ge = [ge]);
              var Xe = ge, dn = e.$$es.allocateUint8Buffer(32 * Xe.length);
              if (dn)
                for (var Ms = 0; Ms < Xe.length; ++Ms) {
                  var Co = Xe[Ms];
                  if (Co.length !== 4)
                    throw Error("Planes are expected be exactly 4 numbers.");
                  At.set(Co, (dn >> 3) + 4 * Ms);
                }
              return Xe = Array.prototype.slice.call(arguments, 1), Xe.unshift(dn, ge.length), ke.apply(e, Xe);
            });
            var ps = ze;
            ct & 16 && (ps = function(ge) {
              ge.length === 3 && typeof ge[0] == "number" && (ge = [ge]);
              var Xe = ge, dn = e.$$es.allocateUint8Buffer(24 * Xe.length);
              if (dn)
                for (var Ms = 0; Ms < Xe.length; ++Ms) {
                  var Co = Xe[Ms];
                  if (Co.length !== 3)
                    throw Error("Points are expected be exactly 3 components.");
                  At.set(Co, (dn >> 3) + 3 * Ms);
                }
              return Xe = Array.prototype.slice.call(arguments, 1), Xe.unshift(dn, ge.length), ze.apply(e, Xe);
            });
            var Mn = ps;
            ct & 32 && (Mn = v(ze));
            var Un = Mn;
            ct & 64 && (Un = function() {
              return console.log("WARNING: Using deprecated function `" + (typeof G == "string" ? G + "." + tt : tt) + "'"), Mn.apply(e, arguments);
            });
            var ms = Un;
            ct & 128 && (ms = function() {
              var ge = arguments, Xe = ge[ge.length - 1];
              return Xe.constructor === Q ? ge[ge.length - 1] = Xe.value : (ge = Array.prototype.slice.call(ge), ge.push(0)), Un.apply(e, ge);
            });
            var ks = ms;
            ct & 256 && (ks = function() {
              var ge = Array.prototype.slice.call(arguments);
              return new Promise(function(Xe, dn) {
                ge.push(Xe), ge.push(Te(gt, dn)), ms.apply(e, ge);
              });
            });
            var Ws = ks;
            ct & 512 && (Ws = ct & 256 ? function() {
              return ks.apply(e, arguments).then(function(ge) {
                return Wt(), gs.copy(ge);
              });
            } : function() {
              return gs.copy(ks.apply(e, arguments));
            });
            var Mi = Ws;
            ct & 1024 && (Mi = ct & 256 ? function() {
              return Ws.apply(e, arguments).then(ra);
            } : function() {
              return ra(Ws.apply(e, arguments));
            });
            var Er = Mi;
            ct & 2048 && (Er = ct & 256 ? function() {
              return Mi.apply(e, arguments).then(sa);
            } : function() {
              return sa(Mi.apply(e, arguments));
            }), Yr(G, tt, function() {
              return Wt(), Ce && yt.callRecord.push(tt + " " + ht(arguments)), Er.apply(e, arguments);
            });
          }
        }
        function Yr(G, tt, ct) {
          var gt = typeof ct == "function" ? function() {
            return Wt(), Ce && yt.callRecord.push(tt + " " + ht(arguments)), ct.apply(e, arguments);
          } : ct;
          G === null ? yt[tt] = gt : typeof G == "string" ? yt[G][tt] = gt : G[tt] = gt;
        }
        function sa(G) {
          for (var tt = 0; tt < G.length; ++tt)
            0 > G[tt][0] && (G[tt] = null);
          return G;
        }
        function ra(G) {
          for (var tt = 0; tt < G.length; ++tt)
            0 > G[tt] && (G[tt] = null);
          return G;
        }
        function Te(G, tt) {
          return function(ct) {
            ct = new we(G, ct), tt(ct);
          };
        }
        function we(G, tt) {
          this.scFunction = G, this.data = tt;
        }
        function kr(G) {
          if (G.length & 1)
            throw new TypeError("`ids.length' must be divisible by two. (An Id is a pair of keys.)");
        }
        yt.CreateImageError = e.CreateImageError, yt.CreateMeshInstanceErrorType = e.CreateMeshInstanceErrorType, yt.CuttingSectionError = e.CuttingSectionError, yt.MeshDataGetDataError = e.MeshDataGetDataError, yt.MeshDataReplaceError = e.MeshDataReplaceError, yt.SetMatrixErrorType = e.SetMatrixErrorType, yt.SetTextureErrorType = e.SetTextureErrorType;
        var gs = M("$$es", "Camera", "reset viewMatrix projectionMatrix fullMatrix projection setProjection upVector setUpVector position setPosition target setTarget nearLimit setNearLimit fieldWidth fieldHeight setField setField setFieldByAngles setFieldByAngles dolly pan roll zoom orbit axisOrbit relativeOrbit unproject".split(" "));
        we.prototype.toString = function() {
          return this.scFunction + ": " + this.data;
        };
        var Oe = {}, Mr = {}, hu = new Uint8Array(0), Ya = new gs();
        D(null, "addCuttingSection", 264), D(null, "addDrawContext", function() {
          return new Promise(function(G, tt) {
            e[et].addDrawContext(G, tt);
          }).then(function(G) {
            return e.$$es.initializeDrawContext(G), G;
          });
        }), D(null, "addLight", 256), D(null, "setLightPower"), D(null, "setLightDecay"), D(null, "advanceVolumeSelection", 256), D(null, "attachModels", function(G, tt, ct, gt) {
          for (var kt = [], Jt = [], Ze = 0; Ze < tt.length; ++Ze) {
            var ke = tt[Ze];
            if (ke.length !== 2)
              throw new TypeError("Expecting [name, matrix] pair.");
            var ze = ke[0];
            if (typeof ze != "string")
              throw new TypeError("Name is not a string.");
            if (ke = ke[1], ke.constructor !== Array && ke.constructor !== Float64Array)
              throw new TypeError("Matrix is not an Array or Float64Array.");
            if (ke.length !== 12)
              throw new TypeError("Inclusion matrix needs to have exactly 12 elements.");
            ze = unescape(encodeURIComponent(ze));
            for (var ps = 0; ps < ze.length; ++ps)
              kt.push(ze.charCodeAt(ps));
            kt.push(0), Array.prototype.push.apply(Jt, ke);
          }
          var Mn = 0, Un = 0;
          if (Mn = f(kt), !Mn || (Un = a(Jt), !Un))
            throw p(Mn), p(Un), Error("Internal logic error.");
          return new Promise(function(ms, ks) {
            e[et].attachModels(Mn, kt.length, Un, Jt.length, G, ct, gt, ms, Te("attachModels", ks));
          });
        }), D(null, "attachScsModelByKey", function(G, tt, ct, gt, kt) {
          var Jt = [];
          if (tt.constructor !== Array && tt.constructor !== Float64Array)
            throw new TypeError("Matrix is not an Array or Float64Array.");
          if (tt.length !== 12)
            throw new TypeError("Inclusion matrix needs to have exactly 12 elements.");
          if (Array.prototype.push.apply(Jt, tt), tt = a(Jt), !tt)
            throw p(tt), Error("Internal logic error.");
          return e.$$es.attachScsModelByKey(tt, Jt.length, G, ct, gt, kt);
        }), D(null, "beginConvexPolyhedronSelection", 264), D(null, "beginRayDrillSelection", 256), D(null, "beginScreenAreaSelection", 256), D(null, "beginSphereSelection", 256), D(null, "clearLights"), D(null, "createFloorplanMesh", 388), D(null, "cuttingSectionLimits"), D(null, "demandMeshInstances", 132), D(null, "detachInclusions", 258), D(null, "disableCapping"), D(
          null,
          "disconnectNetwork",
          rr
        ), D(null, "enableCapping"), D(null, "endComparison"), D(null, "endVolumeSelection"), D(null, "explode"), D(null, "exportToSvg", 256), D(null, "beginExportToSvg", 256), D(null, "advanceExportToSvg", 256), D(null, "flushMetaDataCache", function() {
          et === "$$ss" && (Mr = {});
        }), D(null, "getAmbientOcclusionEnabled", 256), D(null, "getAmbientOcclusionRadius", 256), D(null, "getBackFacesVisible", 256), D(null, "getBackgroundGradient", 256), D(null, "getCamera", function(G) {
          return et === "$$ss" ? gs.clone(Ya) : Oe.getCamera(G);
        }), D(
          null,
          "getCameraPromise",
          768
        ), D(null, "getCappedInstances", 256), D(null, "getCuttingSections", 258), D(null, "getDefaultDepthRange", 256), D(null, "getElementCount", 256), D(null, "getEyeDomeLightingBlurEdgeDistance", 256), D(null, "getEyeDomeLightingBlurInterval", 256), D(null, "getEyeDomeLightingBlurSamples", 256), D(null, "getEyeDomeLightingEnabled", 256), D(null, "getEyeDomeLightingOpacity", 256), D(null, "getEyeDomeLightingShadingEdgeDistance", 256), D(null, "getFacesVisible", 256), D(null, "getFaceWindingFlipped", 256), D(
          null,
          "getFrontFacesVisible",
          256
        ), D(null, "getInteractiveDrawLimitIncreaseEnabled", 256), D(null, "getLightKeys", 256), D(null, "getLight", 256), D(null, "getLinesVisible", 256), D(null, "getLooseBounding", 256), D(null, "getMetaData", rn), D(null, "getMinFrameRate", 256), D(null, "getNetworkVersion"), D(null, "getPointShape", 256), D(null, "getPointSize", 256), D(null, "getPointSizeUnit", 256), D(null, "getPointsVisible", 256), D(null, "getStatistics", 256), D(null, "getStreamedBounding", 256), D(null, "getStreamVersion"), D(null, "getTriangleCount", 256), D(null, "markAllMeshInstancesInteresting"), D(null, "markCameraAsEmpty"), D(null, "meshInstanceKeyInfo", 257), D(null, "metaDataKeyInfo", 257), D(null, "modelKeysFromInclusionKeys", 258), D(null, "onResize", function(G) {
          var tt = yt.allowHighDpi && window.devicePixelRatio || 1, ct = e.$$legacyClient ? yt.container : yt.containers.get(G), gt = ct.clientWidth, kt = ct.clientHeight;
          if (ct = gt * tt, tt *= kt, et === "$$ss")
            qt.Pk(ct, tt, gt, kt);
          else {
            var Jt = e.$$es.maxFrameBufferSize();
            0 >= Jt ? (ct = gt, tt = kt) : ((ct > Jt || tt > Jt) && (ct = gt, tt = kt), (ct > Jt || tt > Jt) && (ct > tt ? (tt = tt / ct * Jt, ct = Jt) : (ct = ct / tt * Jt, tt = Jt)));
          }
          e.$$cs.setScreenDimensions(
            G,
            ct,
            tt,
            gt,
            kt
          ), et === "$$cs" && (e.$$legacyClient && (gt = e.canvas, gt.width = ct, gt.height = tt), yt.queueRedraw(G));
        }), D(null, "pauseCapping"), D(null, "primaryModelKey", 256), D(null, "queueRedraw"), D(null, "registerBimInstances", 4), D(null, "removeAllCuttingSections"), D(null, "removeCuttingSections", 258), D(null, "removeDrawContext"), D(null, "removeLight"), D(null, "replaceCuttingSection", 264), D(null, "requestGroups", 260), D(null, "requestImages", 260), D(null, "requestMeshInstances", 260), D(null, "requestMeshInstancesByGroup", 260), D(null, "resetExplode"), D(null, "resetToEmpty", function(G, tt) {
          var ct = c(tt);
          if (!ct)
            throw new TypeError("`meshKeys' is not an Array or Uint32Array");
          return Oe.resetToEmpty(G, ct, tt.length);
        }), D(null, "resumeCapping"), D(null, "resumeDrawing"), D(null, "screenSelectByRay", 256), D(null, "serverSideRendering", function() {
          return et === "$$ss";
        }), D(null, "setAmbientLightColor"), D(null, "setAmbientOcclusionBias"), D(null, "setAmbientOcclusionBlurInterval"), D(null, "setAmbientOcclusionBlurSamples"), D(null, "setAmbientOcclusionContrast"), D(null, "setAmbientOcclusionEdgeDistance"), D(null, "setAmbientOcclusionEnabled"), D(null, "setAmbientOcclusionIntensity"), D(null, "setAmbientOcclusionNoiseSize"), D(null, "setAmbientOcclusionOpacity"), D(null, "setAmbientOcclusionRadius"), D(null, "setAmbientOcclusionSamples"), D(null, "setAntiAliasingMode"), D(null, "setBackFacesVisible"), D(null, "setBackgroundColor"), D(null, "setBackgroundGradient"), D(null, "setBloomBlurInterval"), D(null, "setBloomBlurSamples"), D(null, "setBloomEnabled"), D(null, "setBloomIntensity"), D(null, "setBloomIntensityScale"), D(
          null,
          "setBloomLayerCount"
        ), D(null, "setBloomThreshold"), D(null, "setBloomThresholdRampWidth"), D(null, "setBoundingPreviewUnderdrawColor"), D(null, "setBoundingPreviewTestedColor"), D(null, "setBoundingPreviewEjectedColor"), D(null, "setBoundingPreviewColor"), D(null, "setBoundingPreviewUnderdraw", 16), D(null, "setBoundingPreviewTested", 16), D(null, "setBoundingPreviewEjected", 16), D(null, "setBoundingDebugLevel"), D(null, "setCamera", function(G, tt) {
          gs.assign(Ya, tt), Oe.setCamera(G, tt);
        }), D(null, "setCappingIdleHookEnabled", 256), D(null, "setClumpingEnabled"), D(null, "setComparisonColors"), D(null, "setCurrentView"), D(null, "setDefaultDepthRange"), D(null, "setDefaultGloss"), D(null, "setDefaultMirror"), D(null, "setDefaultSpecularMix"), D(null, "setDefaultSphereMap"), D(null, "setDisplayIncompleteFrames"), D(null, "setDrawIdleDelay"), D(null, "setDrawMode"), D(null, "setDrawStrategy"), D(null, "setEyeDomeLightingBlurEdgeDistance"), D(null, "setEyeDomeLightingBlurInterval"), D(null, "setEyeDomeLightingBlurSamples"), D(null, "setEyeDomeLightingEnabled"), D(null, "setEyeDomeLightingOpacity"), D(null, "setEyeDomeLightingShadingEdgeDistance"), D(null, "setFacesVisible"), D(null, "setFaceWindingFlipped"), D(null, "setFixedDrawLimit"), D(null, "setFrontFacesVisible"), D(null, "setGoochBaseColorProminence"), D(null, "setGoochBlue"), D(null, "setGoochLuminanceShiftStrength"), D(null, "setGoochYellow"), D(null, "setGroundPlane"), D(null, "setGroundPlaneWithPosition"), D(null, "setHardEdgeColor"), D(null, "setHardEdgeOpacity"), D(null, "setHardEdgesEnabled"), D(null, "setHardEdgeThreshold"), D(null, "setHardEdgeThresholdRampWidth"), D(null, "setHiddenLineHiddenLineColor"), D(null, "setHiddenLineHighlightedElementFillColor"), D(null, "setHiddenLineHighlightedElementOutlineColor"), D(null, "setHiddenLineHighlightedInstanceFillColor"), D(null, "setHiddenLineHighlightedInstanceOutlineColor"), D(null, "setHiddenLineVisibleLineColor"), D(null, "setHighlightColorizeCompression"), D(null, "setHighlightedElementColor"), D(null, "setHighlightedElementFilter"), D(null, "setHighlightedElementOutlineColor"), D(null, "setHighlightedInstanceColor"), D(null, "setHighlightedInstanceFilter"), D(null, "setHighlightedInstanceOutlineColor"), D(null, "setHighlightMode"), D(null, "setImageBasedLightingEnabled"), D(null, "setImageBasedLightingEnvironment", function(G, tt) {
          var ct = f(tt);
          if (!ct)
            throw new TypeError("`data' is not an Array or Uint8Array");
          return e[et].setImageBasedLightingEnvironment(G, ct, tt.length);
        }), D(null, "setImageBasedLightingEnvironmentToDefault"), D(null, "setImageBasedLightingIntensity"), D(null, "setImageBasedLightingMatrix"), D(null, "setInstancingEnabled"), D(null, "setInteractiveDrawLimitIncreaseEnabled"), D(null, "setInteractiveDrawLimitIncreaseInterval"), D(null, "setLightingEnabled"), D(null, "setLineJitterEnabled"), D(null, "setLineJitterFrequency"), D(null, "setLineJitterInstanceCount"), D(null, "setLineJitterRadius"), D(null, "setLinesVisible"), D(null, "setMeshLevel"), D(null, "setMetallicRoughnessMaterialOverride"), D(null, "setMinDrawLimit"), D(null, "setMinFrameRate"), D(null, "setMinIncrementalFrameRate"), D(null, "setMinInteractiveFrameRate"), D(null, "setPointShape"), D(null, "setPointSize"), D(null, "setPointsVisible"), D(null, "setPointVisibilityTest", 16), D(null, "setPostInputDelay"), D(null, "setSilhouetteColor"), D(null, "setSilhouetteEnabled"), D(null, "setSilhouetteOpacity"), D(null, "setSilhouetteThreshold"), D(null, "setSilhouetteThresholdRampWidth"), D(null, "setSimpleReflectionAttenuation"), D(null, "setSimpleReflectionBlurInterval"), D(null, "setSimpleReflectionBlurSamples"), D(null, "setSimpleReflectionEnabled"), D(null, "setSimpleReflectionFadeAngle"), D(null, "setSimpleReflectionOpacity"), D(null, "setSimpleShadowBlurInterval"), D(null, "setSimpleShadowBlurSamples"), D(null, "setSimpleShadowColor"), D(null, "setSimpleShadowEnabled"), D(null, "setSimpleShadowInteractiveUpdateEnabled"), D(null, "setSimpleShadowOpacity"), D(null, "setSimpleShadowResolution"), D(null, "setSmaaQuality"), D(null, "setSsrQuality", function(G) {
          qt.Vk(G);
        }), D(null, "setStreamCutoffScale"), D(null, "setStreamIdleMarker", 256), D(null, "setToonBandCount"), D(null, "setToonSpecularFactor"), D(null, "setTransparencyMode"), D(null, "setUnhighlightedColor"), D(null, "setUnhighlightedFilter"), D(null, "setVisibilityByAttachment"), D(null, "setXRayMaterial"), D(null, "setXRayOpacity"), D(null, "setXRayTransparencyMode"), D(null, "startComparison", function(G, tt, ct) {
          kr(tt), kr(ct);
          var gt = c(tt);
          if (!gt)
            throw new TypeError("`instanceSet1' is not an Array or Uint32Array.");
          var kt = c(ct);
          if (!kt)
            throw new TypeError("`instanceSet2' is not an Array or Uint32Array.");
          return e[et].startComparison(G, gt, tt.length >> 1, kt, ct.length >> 1);
        }), D(null, "startExplode", 4), D(null, "suspendDrawing"), D(
          null,
          "testPointVisibility",
          272
        ), D(null, "throttleLoad"), D(null, "triangulatePolygon", function(G, tt) {
          if (3 > G.length)
            throw new TypeError("'polygonPoints' does not describe a polygon.");
          var ct;
          if (G)
            if (ct = e.$$es.allocateUint8Buffer(4 * G.length))
              X.set(G, ct >> 2);
            else
              throw Error("Out of memory.");
          else
            ct = 0;
          if (!ct)
            throw Error("Internal logic error.");
          return e.$$es.triangulatePolygon(ct, G.length, tt);
        }), D(null, "truncateMetaData", function(G) {
          if (et === "$$cs")
            return Oe.truncateMetaData(G);
          for (var tt = 0; tt < G.length; tt += 2) {
            var ct = G[tt + 1], gt = Mr[G[tt]];
            gt && (gt[ct] = hu);
          }
        }), D(null, "unsetAllColors"), D(null, "unsetAllHighlighted"), D(null, "unsetAllOpacity"), D(null, "unsetAllXRay"), D(null, "unsetCurrentView"), D(null, "unsetXRayMaterial"), D(null, "updateLight"), D(null, "waitForImageDecoding", 256), D(null, "worldSelectByRay", 256), D(null, "_loseWebGlContext", function() {
          var G = e.Wi.getExtension("WEBGL_lose_context");
          return G !== null ? (G.loseContext(), !0) : !1;
        }), D(Oe, "getCamera", 512), D(Oe, "getMetaData", 260), D(Oe, "MeshData_getData", 256), D(Oe, "MeshInstance_setLinePattern", 132), D(
          Oe,
          "requestMetaData",
          260
        ), D(Oe, "resetToEmpty", 258), D(Oe, "setCamera", 32), D(Oe, "truncateMetaData", 260), D(null, "Debug_log", function(G) {
          G = unescape(encodeURIComponent(G));
          for (var tt = [], ct = 0; ct < G.length; ++ct)
            tt.push(G.charCodeAt(ct));
          tt.push(0);
          var gt = f(tt);
          if (!gt)
            throw Error("Internal logic error.");
          return new Promise(function(kt, Jt) {
            e[et].debug_log(gt, tt.length, kt, Jt);
          });
        }), D(null, "Debug_stateFailure", 256), D(null, "Debug_sync", 256), yt.Image = {}, D("Image", "create", function(G, tt, ct, gt, kt, Jt, Ze, ke, ze, ps) {
          var Mn = f(tt);
          if (!Mn)
            throw Error("Internal logic error.");
          var Un = f(Ze);
          return new Promise(function(ms, ks) {
            e[et].Image_create(Mn, tt.length, Un, Ze ? Ze.length : 0, G, ct, gt || 0, kt || 0, Jt || 0, ke || !1, ze || 0, ps || 0, ms, Te("Image_create", ks));
          });
        }), D("Image", "destroy", 260), yt.Matrix = {}, D("Matrix", "create", 256), D("Matrix", "destroy", 260), D("Matrix", "getElements", 260), D("Matrix", "setElements", 260), yt.MeshData = {}, D("MeshData", "create", function(G) {
          return new Promise(function(tt, ct) {
            var gt = G._marshal();
            e[et].MeshData_create(
              gt.bits,
              gt.totalFaceVertices,
              gt.totalLineVertices,
              gt.totalPointVertices,
              gt.floatDataPtr,
              gt.floatDataPtrLen,
              gt.faceElementInfosPtr,
              je * G._faceElements.length,
              gt.lineElementInfosPtr,
              je * G._lineElements.length,
              gt.pointElementInfosPtr,
              je * G._pointElements.length,
              tt,
              Te("MeshData_create", ct)
            );
          });
        }), D("MeshData", "destroy", 260), D("MeshData", "getData", function(G) {
          return Oe.MeshData_getData(G).then(Xa);
        }), D("MeshData", "lineElementSegments", 256), D("MeshData", "linesToIncidentFaces", 258), D("MeshData", "replace", function(G, tt) {
          return new Promise(function(ct, gt) {
            var kt = tt._marshal();
            e[et].MeshData_replace(
              G[0],
              G[1],
              kt.bits,
              kt.totalFaceVertices,
              kt.totalLineVertices,
              kt.totalPointVertices,
              kt.floatDataPtr,
              kt.floatDataPtrLen,
              kt.faceElementInfosPtr,
              je * tt._faceElements.length,
              kt.lineElementInfosPtr,
              je * tt._lineElements.length,
              kt.pointElementInfosPtr,
              je * tt._pointElements.length,
              ct,
              Te("MeshData_replace", gt)
            );
          });
        }), yt.MeshInstance = {}, D("MeshInstance", "clearAllElementHighlight", 132), D("MeshInstance", "clearAllElementVisible", 132), D("MeshInstance", "clearAllElementXRay", 132), D("MeshInstance", "clearElementColors", 132), D(
          "MeshInstance",
          "clearElementHighlight",
          132
        ), D("MeshInstance", "clearElementVisible", 132), D("MeshInstance", "clearElementXRay", 132), D("MeshInstance", "computeMinimalBodyBodyDistance", 256), D("MeshInstance", "computeMinimalFaceFaceDistance", 256), D("MeshInstance", "computeMinimalFaceLineDistance", 256), D("MeshInstance", "computeMinimalFaceRayDistance", 256), D("MeshInstance", "create", 256), D("MeshInstance", "destroy", 388), D("MeshInstance", "discardAnonymousMatrix", 388), D("MeshInstance", "getAlwaysDraw", 388), D(
          "MeshInstance",
          "getCappingMeshData",
          388
        ), D("MeshInstance", "getColor", 2436), D("MeshInstance", "getCullingVector", 388), D("MeshInstance", "getDoNotCut", 388), D("MeshInstance", "getDoNotExplode", 388), D("MeshInstance", "getDoNotLight", 388), D("MeshInstance", "getDoNotOutlineHighlight", 388), D("MeshInstance", "getDoNotSelect", 388), D("MeshInstance", "getDoNotUseVertexColors", 388), D("MeshInstance", "getDrawnWorldSpaceBounding", 260), D("MeshInstance", "getEffectiveColor", 388), D("MeshInstance", "getEffectiveElementColor", 388), D(
          "MeshInstance",
          "getEffectiveOpacity",
          388
        ), D("MeshInstance", "getElementColor", 2436), D("MeshInstance", "getElementHighlighted", 388), D("MeshInstance", "getElementVisible", 388), D("MeshInstance", "getElementXRay", 388), D("MeshInstance", "getExcludeBounding", 388), D("MeshInstance", "getFaceElementBounding", 258), D("MeshInstance", "getFacesVisible", 388), D("MeshInstance", "getHighlighted", 388), D("MeshInstance", "getLayerCount"), D("MeshInstance", "getLineElementBounding", 258), D("MeshInstance", "getLinesVisible", 388), D("MeshInstance", "getMatrix", 388), D(
          "MeshInstance",
          "getMeshData",
          388
        ), D("MeshInstance", "getMetallicRoughness", 388), D("MeshInstance", "getObjectSpaceBounding", 388), D("MeshInstance", "getOpacity", 1412), D("MeshInstance", "getOverrideSceneVisibility", 388), D("MeshInstance", "getPointElementBounding", 258), D("MeshInstance", "getPointsVisible", 388), D("MeshInstance", "getScreenOriented", 388), D("MeshInstance", "getSuppressCameraScale", 388), D("MeshInstance", "getWorldSpaceBounding", 260), D("MeshInstance", "hasDepthRange", 388), D("MeshInstance", "hasTransparency", 388), D(
          "MeshInstance",
          "linesToIncidentFaces",
          258
        ), D("MeshInstance", "matrixPreMultiply", 388), D("MeshInstance", "reifyAnonymousMatrix", 388), D("MeshInstance", "setAlwaysDraw", 132), D("MeshInstance", "setAmbientMix", 132), D("MeshInstance", "setAnonymousMatrix", 388), D("MeshInstance", "setAnonymousMatrices", function(G, tt) {
          var ct = 0, gt = 0;
          if (G.constructor !== Array && G.constructor !== Uint32Array)
            throw new TypeError("Incs Buffer is not an Array or Uint32Array.");
          if (tt.constructor !== Array && tt.constructor !== Float64Array)
            throw new TypeError("Matrices Buffer is not an Array or Float64Array.");
          if (ct = c(G), !ct || (gt = a(tt), !gt))
            throw p(ct), p(gt), Error("Internal logic error.");
          return new Promise(function(kt, Jt) {
            e[et].MeshInstance_setAnonymousMatrices(ct, G.length >> 1, gt, tt.length, kt, Te("MeshInstance_setAnonymousMatrices", Jt), 0);
          });
        }), D("MeshInstance", "setColor", 132), D("MeshInstance", "setCullingVector", 132), D("MeshInstance", "setDepthRange", 132), D("MeshInstance", "setDoNotCut", 132), D("MeshInstance", "setDoNotExplode", 132), D("MeshInstance", "setDoNotLight", 132), D(
          "MeshInstance",
          "setDoNotOutlineHighlight",
          132
        ), D("MeshInstance", "setDoNotSelect", 132), D("MeshInstance", "setDoNotReset", 132), D("MeshInstance", "setDoNotUseVertexColors", 132), D("MeshInstance", "setDoNotXRay", 132), D("MeshInstance", "setElementColor", 132), D("MeshInstance", "setElementHighlighted", 132), D("MeshInstance", "setElementVisible", 132), D("MeshInstance", "setElementXRay", 132), D("MeshInstance", "setExcludeBounding", 132), D("MeshInstance", "setFacesVisible", 132), D("MeshInstance", "setHighlighted", 132), D(
          "MeshInstance",
          "setLinePattern",
          function(G, tt, ct, gt) {
            var kt = f(tt);
            if (!kt)
              throw new TypeError("`pattern' is not an Array or Uint8Array");
            return Oe.MeshInstance_setLinePattern(G, kt, tt.length, ct, gt);
          }
        ), D("MeshInstance", "setLinesVisible", 132), D("MeshInstance", "setMatrix", 388), D("MeshInstance", "setMeshLevel", 132), D("MeshInstance", "setMetallicRoughness", 132), D("MeshInstance", "unsetMetallicRoughness", 132), D("MeshInstance", "setOpacity", 132), D("MeshInstance", "setOverlayId", 132), D("MeshInstance", "setOverrideSceneVisibility", 132), D(
          "MeshInstance",
          "setPointsVisible",
          132
        ), D("MeshInstance", "setScreenOriented", 132), D("MeshInstance", "setScreenSpace", 132), D("MeshInstance", "setScreenSpaceStretched", 132), D("MeshInstance", "setStreamCutoffScale", 132), D("MeshInstance", "setSuppressCameraScale", 132), D("MeshInstance", "setTexture", 388), D("MeshInstance", "setVisible", 132), D("MeshInstance", "setXRay", 132), D("MeshInstance", "synchronizeVisibilities", 4), D("MeshInstance", "unsetColor", 132), D("MeshInstance", "unsetCullingVector", 132), D("MeshInstance", "unsetDepthRange", 132), D(
          "MeshInstance",
          "unsetElementColor",
          132
        ), D("MeshInstance", "unsetLinePattern", 132), D("MeshInstance", "unsetMatrix", 388), D("MeshInstance", "unsetOpacity", 132), D("MeshInstance", "unsetTexture", 132), D("MeshInstance", "setSpecularIntensity", 132), D("MeshInstance", "unsetSpecularIntensity", 132), yt.Overlay = {}, D("Overlay", "destroy"), D("Overlay", "maxIndex"), D("Overlay", "setCamera", 32), D("Overlay", "setViewport"), D("Overlay", "setVisible");
        var sc = { open_model_failed: rr, session_started: function() {
          et === "$$cs" && (e.canvas.addEventListener(
            "webglcontextlost",
            lt,
            !1
          ), yt.onResize(0));
        }, post_draw_json: function(G, tt) {
          try {
            var ct = JSON.parse(tt);
          } catch (gt) {
            console.assert(!1, "malformed JSON from post_draw", gt);
            return;
          }
          e.ki("post_draw", ct.draw_index, ct.stats, na(ct.camera), ct.visiblePoints), ct.quality === "high" && (e.ki("draw_complete"), e.ki("draw_idle"));
        } }, bi = { session_started: function() {
          et === "$$ss" && (yt.resumeDrawing(0), e[et].Debug_notifyLoggedRpcExecutionIsAllowed());
        } }, fe = {};
        e.ki = function(G) {
          if (G in sc) {
            var tt = sc[G];
            tt.apply(this, arguments);
          }
          var ct = fe[G];
          try {
            if (ct !== void 0)
              for (var gt = 0; gt < ct.length; gt++)
                tt = ct[gt], typeof tt == "function" && tt.apply(this, arguments);
          } catch (kt) {
            console.log("Unhandled exception in " + G + " event handler:"), console.log(kt);
          }
          G in bi && (tt = bi[G], tt.apply(this, arguments));
        }, yt.setEventHandler = function(G, tt) {
          fe.hasOwnProperty(G) || (fe[G] = []), fe[G].push(tt);
        }, yt.unsetEventHandler = function(G, tt) {
          if (G = fe[G], G !== void 0)
            for (var ct = 0; ct < G.length; )
              G[ct] === tt ? G.splice(ct, 1) : ++ct;
        }, Pe.prototype = Object.create(Error.prototype), Pe.prototype.constructor = Pe;
        var Xt = { Uninitialized: 0, Network: 1, Scs: 2 };
        yt.SessionType = Xt;
        var Hn = Xt.Uninitialized;
        yt.load = function(G) {
          if (Wt(), Ce && yt.callRecord.push("load " + ht(G)), !G)
            throw new Pe("InvalidConfig", "Invalid load configuration");
          var tt = G.uri;
          if (!!tt + !!G.buffer + !!G.empty != 1)
            throw new Pe("InvalidConfig", "Must specify exactly one of 'uri', 'buffer', or 'empty'.");
          if (tt) {
            {
              if (typeof tt != "string")
                throw new Pe("InvalidConfig", "'uri' must be a string");
              const [Ze, ke, ze] = tt.split("://");
              if (ke) {
                if (ze)
                  throw new Pe("InvalidConfig", "Invalid URI");
                var ct = Ze;
              } else
                ct = "http";
            }
            if (ct === "ws" || ct === "wss") {
              if (ie(), !G)
                throw new Pe(
                  "InvalidConfig",
                  "Invalid load configuration"
                );
              if (G.model && typeof G.model == "string" || (G.model = ""), ct = G.sessionToken, ct === void 0 && (ct = ""), typeof ct != "string")
                throw new Pe("InvalidConfig", "'sessionToken' must be a string");
              var gt = G.limitMiB;
              if (gt === void 0 && (gt = 0), typeof gt != "number")
                throw new Pe("InvalidConfig", "'limitMiB' must be a number");
              var kt = G.meshLevel;
              if (kt === void 0 && (kt = 0), typeof kt != "number")
                throw new Pe("InvalidConfig", "'meshLevel' must be a number");
              var Jt = G.streamCutoffScale;
              if (Jt === void 0 && (Jt = -1), typeof Jt != "number")
                throw new Pe(
                  "InvalidConfig",
                  "'streamCutoffScale' must be a number"
                );
              if (Hn !== Xt.Uninitialized)
                throw new Pe("AlreadyCalled", "load() already called for a non-streaming session");
              Hn = Xt.Network, G.serverSideRendering ? (et = "$$ss", e.$$legacyClient ? qt.gj(e.$$wrapper) : qt.gj(yt.wrappers.get(0)), yt.onResize(0), qt.Tk(zn), qt.Uk(Kn), qt.Sk(fs), qt.Rk(e.ki), qt.connect(G)) : (et = "$$cs", ki(e.$$es.loadNetwork(
                tt,
                unescape(encodeURIComponent(G.model)),
                unescape(encodeURIComponent(ct)),
                !!G.streamCulled,
                !!G.streamMetaDataOnIdle,
                !!G.streamNoLimit,
                !!G.streamInstancesOnDemand,
                !!G.streamAggressiveCompression,
                !!G.streamModelBoundingPreviews,
                !!G.streamInstanceBoundingPreviews,
                !!G.streamOnlyInterestingBoundingPreviews,
                !!G.streamEjectedBoundingPreviews,
                gt,
                kt,
                Jt
              )));
            } else
              ct !== "http" && ct !== "https" || Bt(G, tt);
          } else
            G.buffer ? Nt(G, G.buffer) : (G = !!G.streamInstancesOnDemand, ie([Xt.Scs]), Hn = Xt.Scs, G = e.$$es.loadEmptyScs(G), ki(G));
          return Hn;
        }, yt.attachScsBuffer = function(G, tt, ct, gt, kt, Jt, Ze) {
          return G = { attachScope: G, inclusionMatrix: ct, attachMeasurementUnit: gt, attachInvisibly: kt, resolveOnFullyLoaded: Jt, cancelUnitMatrix: Ze }, tt === null || tt.length === 0 ? We(G, 0, 0) : Nt(G, tt);
        }, yt.feedScsBuffer = function(G, tt) {
          if (ie([Xt.Scs]), G === 0)
            throw new Pe("InvalidConfig", "'attachScope' should not be 0");
          var ct = 0, gt = 0;
          if (tt !== null) {
            if (tt.constructor !== Uint8Array)
              throw new Pe("InvalidConfig", "'buffer' must be a Uint8Array");
            if (0 >= tt.byteLength)
              throw new Pe("EmptyBuffer", "'buffer' has a length of 0");
            ct = tt.byteLength, gt = e.$$es.allocateUint8Buffer(tt.byteLength), A.set(tt, gt);
          }
          e.$$es.feedScsBuffer(G, gt, ct);
        };
      }();
      var je = 3, Oi = 4 * je;
      yt.MeshDataBuilder = function() {
        this._faceElements = [], this._lineElements = [], this._pointElements = [], this.formatBits = 0;
      }, yt.MeshDataBuilder.FormatBits = { ClockwiseWinding: 1, CounterClockwiseWinding: 2, TwoSided: 4, Manifold: 65536 }, yt.MeshDataBuilder.prototype = { constructor: yt.MeshDataBuilder, _getOptional: function(Bt, Nt) {
        return Bt === void 0 ? null : Bt[Nt] ? Bt[Nt] : null;
      }, _optionalGuard: function(Bt, Nt, We) {
        if (We) {
          if ((We = this[We][0]) && !We[Bt])
            throw Error("Cannot define " + Nt + " for some but not all vertices.");
        } else
          this._optionalGuard(Bt, Nt, "_faceElements"), this._optionalGuard(Bt, Nt, "_lineElements"), this._optionalGuard(Bt, Nt, "_pointElements");
      }, addFace: function(Bt, Nt) {
        var We = this._faceElements, ie = this._getOptional(Nt, "normals"), ki = this._getOptional(Nt, "uvs"), Pe = this._getOptional(Nt, "rgba32s");
        if (Nt = this._getOptional(Nt, "bits") || 0, Bt.length % 9 !== 0)
          throw Error("Illegal triangles: 'vertexData.length' must be divisible by 9 (i.e. 3 numbers per vertex and 3 vertices per triangle).");
        if (ie) {
          if (ie.length !== Bt.length)
            throw Error("Cannot define normals for some but not all vertices.");
          this._optionalGuard(
            "normals",
            "normals",
            "_faceElements"
          );
        }
        if (ki) {
          if (3 * ki.length !== 2 * Bt.length)
            throw Error("Cannot define UV parameters for some but not all vertices.");
          this._optionalGuard("uvs", "UV parameters", "_faceElements");
        }
        if (Pe) {
          if (3 * Pe.length !== 4 * Bt.length)
            throw Error("Cannot define RGBA32s for some but not all vertices.");
          if (this._optionalGuard("rgba32s", "RGBA32s"), !(this.formatBits & 32768)) {
            for (var zn = 3; zn < Pe.length; zn += 4)
              if (Pe[zn] != 255) {
                this.formatBits |= 32768;
                break;
              }
          }
        }
        We.push({ vertexData: Bt, normals: ie, uvs: ki, rgba32s: Pe, bits: Nt });
      }, addPolyline: function(Bt, Nt) {
        var We = this._lineElements, ie = this._getOptional(Nt, "rgba32s");
        if (Nt = this._getOptional(Nt, "bits") || 0, Bt.length % 3 !== 0)
          throw Error("vertexData array must be divisible by 3 (i.e. 3 numbers per vertex).");
        if (6 > Bt.length && 0 < Bt.length)
          throw Error("Illegal polyline: '0 < vertexData.length < 6'.");
        if (ie) {
          if (3 * ie.length !== 4 * Bt.length)
            throw Error("Cannot define RGBA32s for some but not all vertices.");
          this._optionalGuard("rgba32s", "RGBA32s");
        }
        We.push({ vertexData: Bt, rgba32s: ie, bits: Nt });
      }, addPoints: function(Bt, Nt) {
        var We = this._pointElements, ie = this._getOptional(Nt, "rgba32s");
        if (Nt = this._getOptional(Nt, "bits") || 0, Bt.length % 3 !== 0)
          throw Error("vertexData array must be divisible by 3 (i.e. 3 numbers per vertex).");
        if (ie) {
          if (3 * ie.length !== 4 * Bt.length)
            throw Error("Cannot define RGBA32s for some but not all vertices.");
          this._optionalGuard("rgba32s", "RGBA32s");
        }
        We.push({ vertexData: Bt, rgba32s: ie, bits: Nt });
      }, _marshal: function() {
        var Bt = this._faceElements, Nt = this._lineElements, We = this._pointElements, ie = !1, ki = !1, Pe = !1, zn = !1, Kn = !1, fs = !1, na = !1, Xa = !1, Ja = !1, rn = Bt[0], rr = Nt[0], D = We[0];
        rn && (ie = !!rn.normals, ki = !!rn.uvs, Pe = !!rn.rgba32s), rr && (zn = !!rr.normals, Kn = !!rr.uvs, fs = !!rr.rgba32s), D && (na = !!D.normals, Xa = !!D.uvs, Ja = !!D.rgba32s);
        var Yr = 3;
        rn = this.formatBits, (rr = ie || zn || na) && (Yr += 3, rn |= 4096, ie && (rn |= 8), zn && (rn |= 64), na && (rn |= 512)), (D = ki || Kn || Xa) && (Yr += 2, rn |= 8192, ki && (rn |= 16), Kn && (rn |= 128), Xa && (rn |= 1024));
        var sa = Pe || fs || Ja;
        sa && (Yr += 1, rn |= 16384, Pe && (rn |= 32), fs && (rn |= 256), Ja && (rn |= 2048));
        for (var ra = 0, Te = 0; Te < Bt.length; ++Te) {
          var we = Bt[Te];
          ra += we.vertexData.length;
        }
        ra /= 3;
        var kr = 0, gs = 0;
        for (Te = 0; Te < Nt.length; ++Te) {
          we = Nt[Te];
          var Oe = we.vertexData;
          Oe.length && (kr += Oe.length, ++gs);
        }
        for (kr = 2 * (kr / 3 - gs), Te = gs = 0; Te < We.length; ++Te)
          we = We[Te], gs += we.vertexData.length;
        gs /= 3, Yr *= ra + kr + gs, Te = e.$$es.allocateUint8Buffer;
        var Mr = Te(4 * Yr), hu = Bt.length ? Te(Oi * Bt.length) : 0, Ya = Nt.length ? Te(Oi * Nt.length) : 0, sc = We.length ? Te(Oi * We.length) : 0, bi = A.subarray(Mr), fe = X.subarray(Mr >> 2), Xt = 0, Hn = 0;
        for (Te = 0; Te < Bt.length; ++Te) {
          we = Bt[Te], Oe = we.vertexData;
          var G = we.normals, tt = we.uvs, ct = we.rgba32s, gt = Oe.length / 3, kt = St.subarray((hu >> 2) + je * Te);
          kt[0] = Hn, kt[1] = gt, kt[2] = we.bits, Hn += gt;
          var Jt = 0;
          for (gt = we = 0; gt < Oe.length; gt += 3)
            fe[Xt] = Oe[gt], fe[Xt + 1] = Oe[gt + 1], fe[Xt + 2] = Oe[gt + 2], Xt += 3, rr && (ie ? (fe[Xt] = G[gt], fe[Xt + 1] = G[gt + 1], fe[Xt + 2] = G[gt + 2]) : (fe[Xt] = 0, fe[Xt + 1] = 0, fe[Xt + 2] = 0), Xt += 3), D && (ki ? (fe[Xt] = tt[Jt], fe[Xt + 1] = tt[Jt + 1], Jt += 2) : (fe[Xt] = 0, fe[Xt + 1] = 0), Xt += 2), sa && (kt = Xt << 2, Pe ? (bi[kt++] = ct[we++], bi[kt++] = ct[we++], bi[kt++] = ct[we++], bi[kt++] = ct[we++]) : (bi[kt++] = 0, bi[kt++] = 0, bi[kt++] = 0, bi[kt++] = 0), ++Xt);
        }
        for (Te = Hn = 0; Te < Nt.length; ++Te)
          for (we = Nt[Te], Oe = we.vertexData, G = we.normals, tt = we.uvs, ct = we.rgba32s, gt = Oe.length / 3, 0 < gt && (gt = 2 * gt - 2), kt = St.subarray((Ya >> 2) + je * Te), kt[0] = Hn, kt[1] = gt, kt[2] = we.bits, Hn += gt, we = 4, gt = 3; gt < Oe.length; gt += 3)
            for (we -= 4, Bt = -3; 0 >= Bt; Bt += 3)
              ie = gt + Bt, fe[Xt] = Oe[ie], fe[Xt + 1] = Oe[ie + 1], fe[Xt + 2] = Oe[ie + 2], Xt += 3, rr && (zn ? (fe[Xt] = G[ie], fe[Xt + 1] = G[ie + 1], fe[Xt + 2] = G[ie + 2]) : (fe[Xt] = 0, fe[Xt + 1] = 0, fe[Xt + 2] = 0), Xt += 3), D && (Kn ? (ie = ie / 3 * 2, fe[Xt] = tt[ie], fe[Xt + 1] = tt[ie + 1]) : (fe[Xt] = 0, fe[Xt + 1] = 0), Xt += 2), sa && (kt = Xt << 2, fs ? (bi[kt++] = ct[we++], bi[kt++] = ct[we++], bi[kt++] = ct[we++], bi[kt++] = ct[we++]) : (bi[kt++] = 0, bi[kt++] = 0, bi[kt++] = 0, bi[kt++] = 0), ++Xt);
        for (Te = Hn = 0; Te < We.length; ++Te)
          for (we = We[Te], Oe = we.vertexData, G = we.normals, tt = we.uvs, ct = we.rgba32s, gt = Oe.length / 3, kt = St.subarray((sc >> 2) + je * Te), kt[0] = Hn, kt[1] = gt, kt[2] = we.bits, Hn += gt, gt = we = Jt = 0; gt < Oe.length; gt += 3)
            fe[Xt] = Oe[gt], fe[Xt + 1] = Oe[gt + 1], fe[Xt + 2] = Oe[gt + 2], Xt += 3, rr && (na ? (fe[Xt] = G[gt], fe[Xt + 1] = G[gt + 1], fe[Xt + 2] = G[gt + 2]) : (fe[Xt] = 0, fe[Xt + 1] = 0, fe[Xt + 2] = 0), Xt += 3), D && (Xa ? (fe[Xt] = tt[Jt], fe[Xt + 1] = tt[Jt + 1], Jt += 2) : (fe[Xt] = 0, fe[Xt + 1] = 0), Xt += 2), sa && (kt = Xt << 2, Ja ? (bi[kt++] = ct[we++], bi[kt++] = ct[we++], bi[kt++] = ct[we++], bi[kt++] = ct[we++]) : (bi[kt++] = 0, bi[kt++] = 0, bi[kt++] = 0, bi[kt++] = 0), ++Xt);
        return {
          totalFaceVertices: ra,
          totalLineVertices: kr,
          totalPointVertices: gs,
          faceElementInfosPtr: hu,
          lineElementInfosPtr: Ya,
          pointElementInfosPtr: sc,
          floatDataPtr: Mr,
          floatDataPtrLen: Yr,
          bits: rn
        };
      } };
    }, e.Oj = function() {
      var a = { Tj: null, aj: null, connection: null, jj: null, mj: null, fj: null, ej: null, dj: 1280, cj: 800, lj: 1280, kj: 800, Vi: 1, hk: { command: "SERVER_SETTINGS" }, gj: function(f) {
        this.Tj = f, c.gj();
      }, Xk: function() {
        this.ak = !0, delete this.jj, delete this.mj, delete this.fj, delete this.ej, this.connection && this.connection.close();
      }, pk: function(f) {
        a.aj !== f && (a.aj && (a.aj.style.display = "none"), a.aj = f, a.aj.style.display = "");
      }, connected: function() {
        return a.connection && a.connection.readyState === WebSocket.OPEN;
      }, Ij: function() {
        a.connected() && a.connection.send(JSON.stringify({ command: "SERVER_SIDE_CLIENT_INFO", width: a.dj * a.Vi, height: a.cj * a.Vi, layoutWidth: a.lj, layoutHeight: a.kj, encoding: "jpeg" }));
      }, Pk: function(f, p, v, M) {
        0 >= f || 0 >= p || 0 >= v || 0 >= M || a.dj === f && a.cj === p && a.lj === v && a.kj === M || (a.dj = f, a.cj = p, a.lj = v, a.kj = M, a.connected() && (a.Hj !== void 0 && window.clearTimeout(a.Hj), a.Hj = setTimeout(function() {
          a.ak || (a.Hj = void 0, a.Ij());
        }, 500)));
      }, Ok: function(f) {
        a.connected() && a.connection.send(f);
      }, Tk: function(f) {
        a.jj = f;
      }, Uk: function(f) {
        a.mj = f;
      }, Sk: function(f) {
        a.fj = f;
      }, Rk: function(f) {
        a.ej = f;
      }, Jk: function(f) {
        a.fj && a.fj(f);
      }, Vk: function(f) {
        var p = { command: "SERVER_SETTINGS" }, v;
        for (v in f)
          if (f.hasOwnProperty(v)) {
            if (v === "scaleHigh") {
              var M = f[v];
              if (typeof M != "number")
                continue;
              M = Math.min(1, M), 0 >= M && (M = 1), a.Vi !== M && (a.Vi = M, a.Ij());
            }
            v !== "jpegQualityHigh" && v !== "jpegQualityLow" && v !== "jpegChromaSamplesHigh" && v !== "jpegChromaSamplesLow" && v !== "scaleLow" || typeof f[v] != "number" || (p[v] = a.hk[v] = f[v]);
          }
        a.connected() && a.connection.send(JSON.stringify(p));
      }, connect: function(f) {
        var p = e.$$es.getNetworkVersion();
        a.connection = new WebSocket(f.uri, ["binary"]), a.connection.binaryType = "arraybuffer";
        var v = !1;
        a.connection.onclose = function() {
          e.ki("websocket_connection_closed");
        }, a.connection.onopen = function() {
          v = !0, a.connection.send(JSON.stringify({
            command: "SERVER_SIDE_RENDER",
            width: a.dj * a.Vi,
            height: a.cj * a.Vi,
            layoutWidth: a.lj,
            layoutHeight: a.kj,
            model: f.model,
            networkVersion: p,
            streamCulled: !!f.streamCulled,
            streamKeyedDataOnIdle: !!f.streamMetaDataOnIdle,
            streamNoLimit: !!f.streamNoLimit,
            streamInstancesOnDemand: !!f.streamInstancesOnDemand,
            streamBoundingPreviews: !!f.streamBoundingPreviews,
            streamModelBoundingPreviews: !!f.streamModelBoundingPreviews,
            streamInstanceBoundingPreviews: !!f.streamInstanceBoundingPreviews,
            streamOnlyInterestingBoundingPreviews: !!f.streamOnlyInterestingBoundingPreviews,
            streamEjectedBoundingPreviews: !!f.streamEjectedBoundingPreviews,
            limitMiB: f.limitMiB,
            meshLevel: f.meshLevel,
            streamCutoffScale: f.streamCutoffScale,
            sessionToken: f.sessionToken
          })), a.Ij(), a.connection.send(JSON.stringify(a.hk));
        }, a.connection.onerror = function() {
          a.ej && a.ej(v ? "socket_error" : "socket_open_failed");
        }, a.connection.onmessage = function(M) {
          if (!a.ak && M.data instanceof ArrayBuffer) {
            var L = new Uint8Array(M.data);
            if (M = L[0], M === 123)
              a.jj && a.jj(L);
            else if (M === 68)
              a.mj && a.mj(L.subarray(1));
            else {
              a.connection.send('{"command":"ACK"}');
              var H = [L[1], L[2]], Q = L[4] << 24 | L[5] << 16 | L[6] << 8 | L[7], lt = new Uint8Array(L.subarray(8, 8 + Q));
              L = L.subarray(8 + Q), M === 0 && c.zk(L, H, lt);
            }
          }
        };
      } }, c = { canvas: null, Rj: null, gj: function() {
      }, createElement: function() {
        this.canvas || (this.canvas = document.createElement("canvas"), this.canvas.setAttribute("style", "display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%;"), this.Rj = this.canvas.getContext("2d"), a.Tj.appendChild(this.canvas));
      }, drawImage: function(f, p) {
        var v = f.width - p[0];
        p = f.height - p[1], this.canvas.width !== v && (this.canvas.width = v), this.canvas.height !== p && (this.canvas.height = p), this.Rj.drawImage(f, 0, 0);
      }, sk: function(f, p, v) {
        var M = document.createElement("img");
        return this.Hk = M, M.onload = function() {
          M === c.Hk && (c.drawImage(M, p), a.pk(c.canvas), a.Jk(v)), URL.revokeObjectURL(f);
        }, M.onerror = function() {
          URL.revokeObjectURL(f);
        }, M.src = f, M;
      }, zk: function(f, p, v) {
        12 >= f.byteLength || (this.createElement(), this.sk(URL.createObjectURL(new Blob([f], { type: "image/jpeg" })), p, v));
      } };
      return a;
    };
    var r = Object.assign({}, e), o = "./this.program", l = (a, c) => {
      throw c;
    }, h = typeof window == "object", u = typeof importScripts == "function", d = typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string", g = "", y, m, x;
    if (d) {
      g = u ? require("path").dirname(g) + "/" : __dirname + "/";
      var b, I;
      typeof require == "function" && (b = require("fs"), I = require("path")), y = (a, c) => (a = I.normalize(a), b.readFileSync(a, c ? void 0 : "utf8")), x = (a) => (a = y(a, !0), a.buffer || (a = new Uint8Array(a)), a), m = (a, c, f) => {
        a = I.normalize(a), b.readFile(a, function(p, v) {
          p ? f(p) : c(v.buffer);
        });
      }, 1 < process.argv.length && (o = process.argv[1].replace(/\\/g, "/")), process.argv.slice(2), process.on("uncaughtException", function(a) {
        if (!(a instanceof It))
          throw a;
      }), process.on("unhandledRejection", function(a) {
        throw a;
      }), l = (a, c) => {
        if (O)
          throw process.exitCode = a, c;
        c instanceof It || P("exiting due to exception: " + c), process.exit(a);
      }, e.inspect = function() {
        return "[Emscripten Module object]";
      };
    } else
      (h || u) && (u ? g = self.location.href : typeof document < "u" && document.currentScript && (g = document.currentScript.src), s && (g = s), g.indexOf("blob:") !== 0 ? g = g.substr(0, g.replace(/[?#].*/, "").lastIndexOf("/") + 1) : g = "", y = (a) => {
        var c = new XMLHttpRequest();
        return c.open("GET", a, !1), c.send(null), c.responseText;
      }, u && (x = (a) => {
        var c = new XMLHttpRequest();
        return c.open("GET", a, !1), c.responseType = "arraybuffer", c.send(null), new Uint8Array(c.response);
      }), m = (a, c, f) => {
        var p = new XMLHttpRequest();
        p.open("GET", a, !0), p.responseType = "arraybuffer", p.onload = () => {
          p.status == 200 || p.status == 0 && p.response ? c(p.response) : f();
        }, p.onerror = f, p.send(null);
      });
    var C = e.print || console.log.bind(console), P = e.printErr || console.warn.bind(console);
    Object.assign(e, r), r = null, e.thisProgram && (o = e.thisProgram), e.quit && (l = e.quit);
    var k;
    e.wasmBinary && (k = e.wasmBinary);
    var O = e.noExitRuntime || !0;
    typeof WebAssembly != "object" && Ne("no native wasm support detected");
    var B, j = !1, V = typeof TextDecoder < "u" ? new TextDecoder("utf8") : void 0;
    function Y(a, c, f) {
      var p = c + f;
      for (f = c; a[f] && !(f >= p); )
        ++f;
      if (16 < f - c && a.buffer && V)
        return V.decode(a.subarray(c, f));
      for (p = ""; c < f; ) {
        var v = a[c++];
        if (v & 128) {
          var M = a[c++] & 63;
          if ((v & 224) == 192)
            p += String.fromCharCode((v & 31) << 6 | M);
          else {
            var L = a[c++] & 63;
            v = (v & 240) == 224 ? (v & 15) << 12 | M << 6 | L : (v & 7) << 18 | M << 12 | L << 6 | a[c++] & 63, 65536 > v ? p += String.fromCharCode(v) : (v -= 65536, p += String.fromCharCode(55296 | v >> 10, 56320 | v & 1023));
          }
        } else
          p += String.fromCharCode(v);
      }
      return p;
    }
    function q(a, c) {
      return a ? Y(A, a, c) : "";
    }
    function st(a, c, f, p) {
      if (!(0 < p))
        return 0;
      var v = f;
      p = f + p - 1;
      for (var M = 0; M < a.length; ++M) {
        var L = a.charCodeAt(M);
        if (55296 <= L && 57343 >= L) {
          var H = a.charCodeAt(++M);
          L = 65536 + ((L & 1023) << 10) | H & 1023;
        }
        if (127 >= L) {
          if (f >= p)
            break;
          c[f++] = L;
        } else {
          if (2047 >= L) {
            if (f + 1 >= p)
              break;
            c[f++] = 192 | L >> 6;
          } else {
            if (65535 >= L) {
              if (f + 2 >= p)
                break;
              c[f++] = 224 | L >> 12;
            } else {
              if (f + 3 >= p)
                break;
              c[f++] = 240 | L >> 18, c[f++] = 128 | L >> 12 & 63;
            }
            c[f++] = 128 | L >> 6 & 63;
          }
          c[f++] = 128 | L & 63;
        }
      }
      return c[f] = 0, f - v;
    }
    function dt(a) {
      for (var c = 0, f = 0; f < a.length; ++f) {
        var p = a.charCodeAt(f);
        127 >= p ? c++ : 2047 >= p ? c += 2 : 55296 <= p && 57343 >= p ? (c += 4, ++f) : c += 3;
      }
      return c;
    }
    var U, J, A, R, wt, z, St, X, At;
    function at() {
      var a = B.buffer;
      U = a, e.HEAP8 = J = new Int8Array(a), e.HEAP16 = R = new Int16Array(a), e.HEAP32 = z = new Int32Array(a), e.HEAPU8 = A = new Uint8Array(a), e.HEAPU16 = wt = new Uint16Array(a), e.HEAPU32 = St = new Uint32Array(a), e.HEAPF32 = X = new Float32Array(a), e.HEAPF64 = At = new Float64Array(a);
    }
    var ot, Ut = [], Pt = [], Lt = [], Je = [];
    function Bi() {
      var a = e.preRun.shift();
      Ut.unshift(a);
    }
    var re = 0, xe = null;
    function He() {
      re++, e.monitorRunDependencies && e.monitorRunDependencies(re);
    }
    function Be() {
      if (re--, e.monitorRunDependencies && e.monitorRunDependencies(re), re == 0 && xe) {
        var a = xe;
        xe = null, a();
      }
    }
    function Ne(a) {
      throw e.onAbort && e.onAbort(a), a = "Aborted(" + a + ")", P(a), j = !0, a = new WebAssembly.RuntimeError(a + ". Build with -sASSERTIONS for more info."), n(a), a;
    }
    function cn() {
      return T.startsWith("data:application/octet-stream;base64,");
    }
    var T;
    if (e.locateFile) {
      if (T = "engine.esm.wasm", !cn()) {
        var _t = T;
        T = e.locateFile ? e.locateFile(_t, g) : g + _t;
      }
    } else
      T = void 0;
    function ft() {
      var a = T;
      try {
        if (a == T && k)
          return new Uint8Array(k);
        if (x)
          return x(a);
        throw "both async and sync fetching of the wasm failed";
      } catch (c) {
        Ne(c);
      }
    }
    function $() {
      if (!k && (h || u)) {
        if (typeof fetch == "function" && !T.startsWith("file://"))
          return fetch(T, { credentials: "same-origin" }).then(function(a) {
            if (!a.ok)
              throw "failed to load wasm binary file at '" + T + "'";
            return a.arrayBuffer();
          }).catch(function() {
            return ft();
          });
        if (m)
          return new Promise(function(a, c) {
            m(T, function(f) {
              a(new Uint8Array(f));
            }, c);
          });
      }
      return Promise.resolve().then(function() {
        return ft();
      });
    }
    var W, nt, bt = { 731184: () => {
      console.log("RPC parsing failed");
    }, 731223: (a, c, f) => {
      e.$$facade && (e.$$legacyClient ? (At[a >> 3] = e.$$facade.container.clientWidth, At[c >> 3] = e.$$facade.container.clientHeight) : (At[a >> 3] = e.$$facade.containers.get(f).clientWidth, At[c >> 3] = e.$$facade.containers.get(f).clientHeight));
    }, 731574: () => {
      try {
        var a = window.bowser;
        return a && a.windows && (a.webkit || a.blink || a.gecko) ? 1 : 0;
      } catch {
        return 1;
      }
    }, 731747: () => {
      try {
        var a = window.bowser;
        if (!(a && a.windows && (a.chrome && 0 <= a.compareVersions([
          a.version,
          "55"
        ]) && 0 > a.compareVersions([a.version, "57"]) || a.firefox && 0 <= a.compareVersions([a.version, "51"]) && 0 > a.compareVersions([a.version, "58"]))))
          return 0;
      } catch {
        return 0;
      }
      try {
        var c = e.Wi, f = c.getExtension("WEBGL_debug_renderer_info");
        if (f) {
          var p = c.getParameter(f.UNMASKED_RENDERER_WEBGL);
          if (!(p && 0 <= p.indexOf("ANGLE") && (0 <= p.indexOf("AMD") || 0 <= p.indexOf("Radeon")) && 0 <= p.indexOf("Direct3D11")))
            return 0;
        }
      } catch {
      }
      return 1;
    } };
    function It(a) {
      this.name = "ExitStatus", this.message = "Program terminated with exit(" + a + ")", this.status = a;
    }
    function rt(a) {
      for (; 0 < a.length; )
        a.shift()(e);
    }
    var xt = [], Rt = [], Dt = (a, c) => {
      for (var f = 0, p = a.length - 1; 0 <= p; p--) {
        var v = a[p];
        v === "." ? a.splice(p, 1) : v === ".." ? (a.splice(p, 1), f++) : f && (a.splice(p, 1), f--);
      }
      if (c)
        for (; f; f--)
          a.unshift("..");
      return a;
    }, Ht = (a) => {
      var c = a.charAt(0) === "/", f = a.substr(-1) === "/";
      return (a = Dt(a.split("/").filter((p) => !!p), !c).join("/")) || c || (a = "."), a && f && (a += "/"), (c ? "/" : "") + a;
    }, Ue = (a) => {
      var c = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/.exec(a).slice(1);
      return a = c[0], c = c[1], !a && !c ? "." : (c && (c = c.substr(0, c.length - 1)), a + c);
    }, pe = (a) => {
      if (a === "/")
        return "/";
      a = Ht(a), a = a.replace(/\/$/, "");
      var c = a.lastIndexOf("/");
      return c === -1 ? a : a.substr(c + 1);
    };
    function sn() {
      if (typeof crypto == "object" && typeof crypto.getRandomValues == "function") {
        var a = new Uint8Array(1);
        return () => (crypto.getRandomValues(a), a[0]);
      }
      if (d)
        try {
          var c = require("crypto");
          return () => c.randomBytes(1)[0];
        } catch {
        }
      return () => Ne("randomDevice");
    }
    function kn() {
      for (var a = "", c = !1, f = arguments.length - 1; -1 <= f && !c; f--) {
        if (c = 0 <= f ? arguments[f] : "/", typeof c != "string")
          throw new TypeError("Arguments to path.resolve must be strings");
        if (!c)
          return "";
        a = c + "/" + a, c = c.charAt(0) === "/";
      }
      return a = Dt(a.split("/").filter((p) => !!p), !c).join("/"), (c ? "/" : "") + a || ".";
    }
    function $i(a, c) {
      var f = Array(dt(a) + 1);
      return a = st(a, f, 0, f.length), c && (f.length = a), f;
    }
    var es = [];
    function ai(a, c) {
      es[a] = { input: [], output: [], Ui: c }, Ha(a, Vs);
    }
    var Vs = { open: function(a) {
      var c = es[a.node.rdev];
      if (!c)
        throw new Ft(43);
      a.tty = c, a.seekable = !1;
    }, close: function(a) {
      a.tty.Ui.fsync(a.tty);
    }, fsync: function(a) {
      a.tty.Ui.fsync(a.tty);
    }, read: function(a, c, f, p) {
      if (!a.tty || !a.tty.Ui.$j)
        throw new Ft(60);
      for (var v = 0, M = 0; M < p; M++) {
        try {
          var L = a.tty.Ui.$j(a.tty);
        } catch {
          throw new Ft(29);
        }
        if (L === void 0 && v === 0)
          throw new Ft(6);
        if (L == null)
          break;
        v++, c[f + M] = L;
      }
      return v && (a.node.timestamp = Date.now()), v;
    }, write: function(a, c, f, p) {
      if (!a.tty || !a.tty.Ui.Ej)
        throw new Ft(60);
      try {
        for (var v = 0; v < p; v++)
          a.tty.Ui.Ej(a.tty, c[f + v]);
      } catch {
        throw new Ft(29);
      }
      return p && (a.node.timestamp = Date.now()), v;
    } }, zs = { $j: function(a) {
      if (!a.input.length) {
        var c = null;
        if (d) {
          var f = Buffer.alloc(256), p = 0;
          try {
            p = b.readSync(process.stdin.fd, f, 0, 256, -1);
          } catch (v) {
            if (v.toString().includes("EOF"))
              p = 0;
            else
              throw v;
          }
          0 < p ? c = f.slice(0, p).toString("utf-8") : c = null;
        } else
          typeof window < "u" && typeof window.prompt == "function" ? (c = window.prompt("Input: "), c !== null && (c += `
`)) : typeof readline == "function" && (c = readline(), c !== null && (c += `
`));
        if (!c)
          return null;
        a.input = $i(c, !0);
      }
      return a.input.shift();
    }, Ej: function(a, c) {
      c === null || c === 10 ? (C(Y(a.output, 0)), a.output = []) : c != 0 && a.output.push(c);
    }, fsync: function(a) {
      a.output && 0 < a.output.length && (C(Y(a.output, 0)), a.output = []);
    } }, Fn = { Ej: function(a, c) {
      c === null || c === 10 ? (P(Y(a.output, 0)), a.output = []) : c != 0 && a.output.push(c);
    }, fsync: function(a) {
      a.output && 0 < a.output.length && (P(Y(a.output, 0)), a.output = []);
    } }, Qt = { yi: null, Di: function() {
      return Qt.createNode(
        null,
        "/",
        16895,
        0
      );
    }, createNode: function(a, c, f, p) {
      if ((f & 61440) === 24576 || (f & 61440) === 4096)
        throw new Ft(63);
      return Qt.yi || (Qt.yi = { dir: { node: { Hi: Qt.hi.Hi, ui: Qt.hi.ui, lookup: Qt.hi.lookup, nj: Qt.hi.nj, rename: Qt.hi.rename, unlink: Qt.hi.unlink, rmdir: Qt.hi.rmdir, readdir: Qt.hi.readdir, symlink: Qt.hi.symlink }, stream: { Li: Qt.ii.Li } }, file: { node: { Hi: Qt.hi.Hi, ui: Qt.hi.ui }, stream: { Li: Qt.ii.Li, read: Qt.ii.read, write: Qt.ii.write, Pj: Qt.ii.Pj, Dj: Qt.ii.Dj, ek: Qt.ii.ek } }, link: { node: { Hi: Qt.hi.Hi, ui: Qt.hi.ui, readlink: Qt.hi.readlink }, stream: {} }, Sj: {
        node: { Hi: Qt.hi.Hi, ui: Qt.hi.ui },
        stream: Dd
      } }), f = Uh(a, c, f, p), (f.mode & 61440) === 16384 ? (f.hi = Qt.yi.dir.node, f.ii = Qt.yi.dir.stream, f.gi = {}) : (f.mode & 61440) === 32768 ? (f.hi = Qt.yi.file.node, f.ii = Qt.yi.file.stream, f.mi = 0, f.gi = null) : (f.mode & 61440) === 40960 ? (f.hi = Qt.yi.link.node, f.ii = Qt.yi.link.stream) : (f.mode & 61440) === 8192 && (f.hi = Qt.yi.Sj.node, f.ii = Qt.yi.Sj.stream), f.timestamp = Date.now(), a && (a.gi[c] = f, a.timestamp = f.timestamp), f;
    }, ll: function(a) {
      return a.gi ? a.gi.subarray ? a.gi.subarray(0, a.mi) : new Uint8Array(a.gi) : new Uint8Array(0);
    }, Xj: function(a, c) {
      var f = a.gi ? a.gi.length : 0;
      f >= c || (c = Math.max(c, f * (1048576 > f ? 2 : 1.125) >>> 0), f != 0 && (c = Math.max(c, 256)), f = a.gi, a.gi = new Uint8Array(c), 0 < a.mi && a.gi.set(f.subarray(0, a.mi), 0));
    }, Nk: function(a, c) {
      if (a.mi != c)
        if (c == 0)
          a.gi = null, a.mi = 0;
        else {
          var f = a.gi;
          a.gi = new Uint8Array(c), f && a.gi.set(f.subarray(0, Math.min(c, a.mi))), a.mi = c;
        }
    }, hi: { Hi: function(a) {
      var c = {};
      return c.dev = (a.mode & 61440) === 8192 ? a.id : 1, c.ino = a.id, c.mode = a.mode, c.nlink = 1, c.uid = 0, c.gid = 0, c.rdev = a.rdev, (a.mode & 61440) === 16384 ? c.size = 4096 : (a.mode & 61440) === 32768 ? c.size = a.mi : (a.mode & 61440) === 40960 ? c.size = a.link.length : c.size = 0, c.atime = new Date(a.timestamp), c.mtime = new Date(a.timestamp), c.ctime = new Date(a.timestamp), c.qk = 4096, c.blocks = Math.ceil(c.size / c.qk), c;
    }, ui: function(a, c) {
      c.mode !== void 0 && (a.mode = c.mode), c.timestamp !== void 0 && (a.timestamp = c.timestamp), c.size !== void 0 && Qt.Nk(a, c.size);
    }, lookup: function() {
      throw za[44];
    }, nj: function(a, c, f, p) {
      return Qt.createNode(a, c, f, p);
    }, rename: function(a, c, f) {
      if ((a.mode & 61440) === 16384) {
        try {
          var p = mo(c, f);
        } catch {
        }
        if (p)
          for (var v in p.gi)
            throw new Ft(55);
      }
      delete a.parent.gi[a.name], a.parent.timestamp = Date.now(), a.name = f, c.gi[f] = a, c.timestamp = a.parent.timestamp, a.parent = c;
    }, unlink: function(a, c) {
      delete a.gi[c], a.timestamp = Date.now();
    }, rmdir: function(a, c) {
      var f = mo(a, c), p;
      for (p in f.gi)
        throw new Ft(55);
      delete a.gi[c], a.timestamp = Date.now();
    }, readdir: function(a) {
      var c = [".", ".."], f;
      for (f in a.gi)
        a.gi.hasOwnProperty(f) && c.push(f);
      return c;
    }, symlink: function(a, c, f) {
      return a = Qt.createNode(a, c, 41471, 0), a.link = f, a;
    }, readlink: function(a) {
      if ((a.mode & 61440) !== 40960)
        throw new Ft(28);
      return a.link;
    } }, ii: { read: function(a, c, f, p, v) {
      var M = a.node.gi;
      if (v >= a.node.mi)
        return 0;
      if (a = Math.min(a.node.mi - v, p), 8 < a && M.subarray)
        c.set(M.subarray(v, v + a), f);
      else
        for (p = 0; p < a; p++)
          c[f + p] = M[v + p];
      return a;
    }, write: function(a, c, f, p, v, M) {
      if (c.buffer === J.buffer && (M = !1), !p)
        return 0;
      if (a = a.node, a.timestamp = Date.now(), c.subarray && (!a.gi || a.gi.subarray)) {
        if (M)
          return a.gi = c.subarray(f, f + p), a.mi = p;
        if (a.mi === 0 && v === 0)
          return a.gi = c.slice(f, f + p), a.mi = p;
        if (v + p <= a.mi)
          return a.gi.set(c.subarray(f, f + p), v), p;
      }
      if (Qt.Xj(a, v + p), a.gi.subarray && c.subarray)
        a.gi.set(c.subarray(f, f + p), v);
      else
        for (M = 0; M < p; M++)
          a.gi[v + M] = c[f + M];
      return a.mi = Math.max(a.mi, v + p), p;
    }, Li: function(a, c, f) {
      if (f === 1 ? c += a.position : f === 2 && (a.node.mode & 61440) === 32768 && (c += a.node.mi), 0 > c)
        throw new Ft(28);
      return c;
    }, Pj: function(a, c, f) {
      Qt.Xj(a.node, c + f), a.node.mi = Math.max(a.node.mi, c + f);
    }, Dj: function(a, c, f, p, v) {
      if ((a.node.mode & 61440) !== 32768)
        throw new Ft(43);
      if (a = a.node.gi, v & 2 || a.buffer !== U) {
        if ((0 < f || f + c < a.length) && (a.subarray ? a = a.subarray(f, f + c) : a = Array.prototype.slice.call(
          a,
          f,
          f + c
        )), f = !0, Ne(), c = void 0, !c)
          throw new Ft(48);
        J.set(a, c);
      } else
        f = !1, c = a.byteOffset;
      return { li: c, dl: f };
    }, ek: function(a, c, f, p) {
      return Qt.ii.write(a, c, 0, p, f, !1), 0;
    } } };
    function Bn(a, c, f) {
      var p = "al " + a;
      m(a, (v) => {
        v || Ne('Loading data file "' + a + '" failed (no arrayBuffer).'), c(new Uint8Array(v)), p && Be();
      }, () => {
        if (f)
          f();
        else
          throw 'Loading data file "' + a + '" failed.';
      }), p && He();
    }
    var Vn = null, ls = {}, qi = [], Ti = 1, $n = null, Kr = !0, Ft = null, za = {}, Hs = (a, c = {}) => {
      if (a = kn("/", a), !a)
        return { path: "", node: null };
      if (c = Object.assign({ Zj: !0, Fj: 0 }, c), 8 < c.Fj)
        throw new Ft(32);
      a = Dt(a.split("/").filter((L) => !!L), !1);
      for (var f = Vn, p = "/", v = 0; v < a.length; v++) {
        var M = v === a.length - 1;
        if (M && c.parent)
          break;
        if (f = mo(f, a[v]), p = Ht(p + "/" + a[v]), f.Xi && (!M || M && c.Zj) && (f = f.Xi.root), !M || c.wj) {
          for (M = 0; (f.mode & 61440) === 40960; )
            if (f = Z(p), p = kn(Ue(p), f), f = Hs(p, { Fj: c.Fj + 1 }).node, 40 < M++)
              throw new Ft(32);
        }
      }
      return { path: p, node: f };
    }, ui = (a) => {
      for (var c; ; ) {
        if (a === a.parent)
          return a = a.Di.dk, c ? a[a.length - 1] !== "/" ? a + "/" + c : a + c : a;
        c = c ? a.name + "/" + c : a.name, a = a.parent;
      }
    }, Vl = (a, c) => {
      for (var f = 0, p = 0; p < c.length; p++)
        f = (f << 5) - f + c.charCodeAt(p) | 0;
      return (a + f >>> 0) % $n.length;
    }, mo = (a, c) => {
      var f;
      if (f = (f = Jo(a, "x")) ? f : a.hi.lookup ? 0 : 2)
        throw new Ft(f, a);
      for (f = $n[Vl(a.id, c)]; f; f = f.Ti) {
        var p = f.name;
        if (f.parent.id === a.id && p === c)
          return f;
      }
      return a.hi.lookup(a, c);
    }, Uh = (a, c, f, p) => (a = new Sp(a, c, f, p), c = Vl(a.parent.id, a.name), a.Ti = $n[c], $n[c] = a), Td = {
      r: 0,
      "r+": 2,
      w: 577,
      "w+": 578,
      a: 1089,
      "a+": 1090
    }, jh = (a) => {
      var c = ["r", "w", "rw"][a & 3];
      return a & 512 && (c += "w"), c;
    }, Jo = (a, c) => {
      if (Kr)
        return 0;
      if (!c.includes("r") || a.mode & 292) {
        if (c.includes("w") && !(a.mode & 146) || c.includes("x") && !(a.mode & 73))
          return 2;
      } else
        return 2;
      return 0;
    }, Wh = (a, c) => {
      try {
        return mo(a, c), 20;
      } catch {
      }
      return Jo(a, "wx");
    }, Nd = (a = 0) => {
      for (; 4096 >= a; a++)
        if (!qi[a])
          return a;
      throw new Ft(33);
    }, zl = (a, c) => (te || (te = function() {
      this.ti = {};
    }, te.prototype = {}, Object.defineProperties(te.prototype, { object: {
      get: function() {
        return this.node;
      },
      set: function(f) {
        this.node = f;
      }
    }, flags: { get: function() {
      return this.ti.flags;
    }, set: function(f) {
      this.ti.flags = f;
    } }, position: { get: function() {
      return this.ti.position;
    }, set: function(f) {
      this.ti.position = f;
    } } })), a = Object.assign(new te(), a), c = Nd(c), a.fd = c, qi[c] = a), Dd = { open: (a) => {
      a.ii = ls[a.node.rdev].ii, a.ii.open && a.ii.open(a);
    }, Li: () => {
      throw new Ft(70);
    } }, Ha = (a, c) => {
      ls[a] = { ii: c };
    }, Hl = (a, c) => {
      var f = c === "/", p = !c;
      if (f && Vn)
        throw new Ft(10);
      if (!f && !p) {
        var v = Hs(c, { Zj: !1 });
        if (c = v.path, v = v.node, v.Xi)
          throw new Ft(10);
        if ((v.mode & 61440) !== 16384)
          throw new Ft(54);
      }
      c = { type: a, rl: {}, dk: c, Ik: [] }, a = a.Di(c), a.Di = c, c.root = a, f ? Vn = a : v && (v.Xi = c, v.Di && v.Di.Ik.push(c));
    }, w = (a, c, f) => {
      var p = Hs(a, { parent: !0 }).node;
      if (a = pe(a), !a || a === "." || a === "..")
        throw new Ft(28);
      var v = Wh(p, a);
      if (v)
        throw new Ft(v);
      if (!p.hi.nj)
        throw new Ft(63);
      return p.hi.nj(p, a, c, f);
    }, S = (a, c, f) => (typeof f > "u" && (f = c, c = 438), w(a, c | 8192, f)), E = (a, c) => {
      if (!kn(a))
        throw new Ft(44);
      var f = Hs(c, { parent: !0 }).node;
      if (!f)
        throw new Ft(44);
      c = pe(c);
      var p = Wh(f, c);
      if (p)
        throw new Ft(p);
      if (!f.hi.symlink)
        throw new Ft(63);
      f.hi.symlink(f, c, a);
    }, F = (a) => {
      var c = Hs(a, { parent: !0 }).node;
      if (!c)
        throw new Ft(44);
      var f = pe(a);
      a = mo(c, f);
      t: {
        try {
          var p = mo(c, f);
        } catch (M) {
          p = M.Gi;
          break t;
        }
        var v = Jo(c, "wx");
        p = v || ((p.mode & 61440) === 16384 ? 31 : 0);
      }
      if (p)
        throw new Ft(p);
      if (!c.hi.unlink)
        throw new Ft(63);
      if (a.Xi)
        throw new Ft(10);
      if (c.hi.unlink(c, f), c = Vl(a.parent.id, a.name), $n[c] === a)
        $n[c] = a.Ti;
      else
        for (c = $n[c]; c; ) {
          if (c.Ti === a) {
            c.Ti = a.Ti;
            break;
          }
          c = c.Ti;
        }
    }, Z = (a) => {
      if (a = Hs(a).node, !a)
        throw new Ft(44);
      if (!a.hi.readlink)
        throw new Ft(28);
      return kn(ui(a.parent), a.hi.readlink(a));
    }, it = (a, c) => {
      if (a = typeof a == "string" ? Hs(a, { wj: !0 }).node : a, !a.hi.ui)
        throw new Ft(63);
      a.hi.ui(a, { mode: c & 4095 | a.mode & -4096, timestamp: Date.now() });
    }, pt = (a, c, f) => {
      if (a === "")
        throw new Ft(44);
      if (typeof c == "string") {
        var p = Td[c];
        if (typeof p > "u")
          throw Error("Unknown file open mode: " + c);
        c = p;
      }
      if (f = c & 64 ? (typeof f > "u" ? 438 : f) & 4095 | 32768 : 0, typeof a == "object")
        var v = a;
      else {
        a = Ht(a);
        try {
          v = Hs(a, { wj: !(c & 131072) }).node;
        } catch {
        }
      }
      if (p = !1, c & 64)
        if (v) {
          if (c & 128)
            throw new Ft(20);
        } else
          v = w(a, f, 0), p = !0;
      if (!v)
        throw new Ft(44);
      if ((v.mode & 61440) === 8192 && (c &= -513), c & 65536 && (v.mode & 61440) !== 16384)
        throw new Ft(54);
      if (!p && (f = v ? (v.mode & 61440) === 40960 ? 32 : (v.mode & 61440) === 16384 && (jh(c) !== "r" || c & 512) ? 31 : Jo(v, jh(c)) : 44))
        throw new Ft(f);
      if (c & 512 && !p) {
        if (f = v, f = typeof f == "string" ? Hs(f, { wj: !0 }).node : f, !f.hi.ui)
          throw new Ft(63);
        if ((f.mode & 61440) === 16384)
          throw new Ft(31);
        if ((f.mode & 61440) !== 32768)
          throw new Ft(28);
        if (p = Jo(f, "w"))
          throw new Ft(p);
        f.hi.ui(f, { size: 0, timestamp: Date.now() });
      }
      return c &= -131713, v = zl({ node: v, path: ui(v), flags: c, seekable: !0, position: 0, ii: v.ii, bl: [], error: !1 }), v.ii.open && v.ii.open(v), !e.logReadFiles || c & 1 || (le || (le = {}), a in le || (le[a] = 1)), v;
    }, Mt = (a) => {
      if (a.fd === null)
        throw new Ft(8);
      a.xj && (a.xj = null);
      try {
        a.ii.close && a.ii.close(a);
      } catch (c) {
        throw c;
      } finally {
        qi[a.fd] = null;
      }
      a.fd = null;
    }, zt = (a, c, f) => {
      if (a.fd === null)
        throw new Ft(8);
      if (!a.seekable || !a.ii.Li)
        throw new Ft(70);
      if (f != 0 && f != 1 && f != 2)
        throw new Ft(28);
      a.position = a.ii.Li(a, c, f), a.bl = [];
    }, me = (a, c, f, p, v, M) => {
      if (0 > p || 0 > v)
        throw new Ft(28);
      if (a.fd === null)
        throw new Ft(8);
      if (!(a.flags & 2097155))
        throw new Ft(8);
      if ((a.node.mode & 61440) === 16384)
        throw new Ft(31);
      if (!a.ii.write)
        throw new Ft(28);
      a.seekable && a.flags & 1024 && zt(a, 0, 2);
      var L = typeof v < "u";
      if (!L)
        v = a.position;
      else if (!a.seekable)
        throw new Ft(70);
      return c = a.ii.write(a, c, f, p, v, M), L || (a.position += c), c;
    }, ii = () => {
      Ft || (Ft = function(a, c) {
        this.node = c, this.Qk = function(f) {
          this.Gi = f;
        }, this.Qk(a), this.message = "FS error";
      }, Ft.prototype = Error(), Ft.prototype.constructor = Ft, [44].forEach((a) => {
        za[a] = new Ft(a), za[a].stack = "<generic error, no stack>";
      }));
    }, Ki, vi = (a, c) => {
      var f = 0;
      return a && (f |= 365), c && (f |= 146), f;
    }, Ni = (a, c) => {
      for (a = typeof a == "string" ? a : ui(a), c = c.split("/").reverse(); c.length; ) {
        var f = c.pop();
        if (f) {
          var p = Ht(a + "/" + f);
          try {
            w(p, 16895, 0);
          } catch {
          }
          a = p;
        }
      }
      return p;
    }, ji = (a, c, f, p) => (a = Ht((typeof a == "string" ? a : ui(a)) + "/" + c), f = vi(f, p), w(a, (f !== void 0 ? f : 438) & 4095 | 32768, 0)), cs = (a, c, f, p, v, M) => {
      var L = c;
      if (a && (a = typeof a == "string" ? a : ui(a), L = c ? Ht(a + "/" + c) : a), a = vi(p, v), L = w(L, (a !== void 0 ? a : 438) & 4095 | 32768, 0), f) {
        if (typeof f == "string") {
          for (c = Array(f.length), p = 0, v = f.length; p < v; ++p)
            c[p] = f.charCodeAt(p);
          f = c;
        }
        it(L, a | 146), c = pt(L, 577), me(c, f, 0, f.length, 0, M), Mt(c), it(L, a);
      }
      return L;
    }, wn = (a, c, f, p) => {
      a = Ht((typeof a == "string" ? a : ui(a)) + "/" + c), c = vi(!!f, !!p), wn.ck || (wn.ck = 64);
      var v = wn.ck++ << 8 | 0;
      return Ha(v, { open: (M) => {
        M.seekable = !1;
      }, close: () => {
        p && p.buffer && p.buffer.length && p(10);
      }, read: (M, L, H, Q) => {
        for (var lt = 0, ht = 0; ht < Q; ht++) {
          try {
            var Tt = f();
          } catch {
            throw new Ft(29);
          }
          if (Tt === void 0 && lt === 0)
            throw new Ft(6);
          if (Tt == null)
            break;
          lt++, L[H + ht] = Tt;
        }
        return lt && (M.node.timestamp = Date.now()), lt;
      }, write: (M, L, H, Q) => {
        for (var lt = 0; lt < Q; lt++)
          try {
            p(L[H + lt]);
          } catch {
            throw new Ft(29);
          }
        return Q && (M.node.timestamp = Date.now()), lt;
      } }), S(a, c, v);
    }, _o = (a) => {
      if (!(a.Ek || a.Fk || a.link || a.gi)) {
        if (typeof XMLHttpRequest < "u")
          throw Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
        if (y)
          try {
            a.gi = $i(
              y(a.url),
              !0
            ), a.mi = a.gi.length;
          } catch {
            throw new Ft(29);
          }
        else
          throw Error("Cannot load without read() or XMLHttpRequest.");
      }
    }, qn = (a, c, f, p, v) => {
      function M() {
        this.Bj = !1, this.ti = [];
      }
      if (M.prototype.get = function(ht) {
        if (!(ht > this.length - 1 || 0 > ht)) {
          var Tt = ht % this.chunkSize;
          return this.Si(ht / this.chunkSize | 0)[Tt];
        }
      }, M.prototype.yk = function(ht) {
        this.Si = ht;
      }, M.prototype.Qj = function() {
        var ht = new XMLHttpRequest();
        if (ht.open("HEAD", f, !1), ht.send(null), !(200 <= ht.status && 300 > ht.status || ht.status === 304))
          throw Error("Couldn't load " + f + ". Status: " + ht.status);
        var Tt = Number(ht.getResponseHeader("Content-length")), Wt, et = (Wt = ht.getResponseHeader("Accept-Ranges")) && Wt === "bytes";
        ht = (Wt = ht.getResponseHeader("Content-Encoding")) && Wt === "gzip";
        var yt = 1048576;
        et || (yt = Tt);
        var qt = this;
        qt.yk((Ce) => {
          var je = Ce * yt, Oi = (Ce + 1) * yt - 1;
          if (Oi = Math.min(Oi, Tt - 1), typeof qt.ti[Ce] > "u") {
            var Bt = qt.ti;
            if (je > Oi)
              throw Error("invalid range (" + je + ", " + Oi + ") or no bytes requested!");
            if (Oi > Tt - 1)
              throw Error("only " + Tt + " bytes available! programmer error!");
            var Nt = new XMLHttpRequest();
            if (Nt.open("GET", f, !1), Tt !== yt && Nt.setRequestHeader("Range", "bytes=" + je + "-" + Oi), Nt.responseType = "arraybuffer", Nt.overrideMimeType && Nt.overrideMimeType("text/plain; charset=x-user-defined"), Nt.send(null), !(200 <= Nt.status && 300 > Nt.status || Nt.status === 304))
              throw Error("Couldn't load " + f + ". Status: " + Nt.status);
            je = Nt.response !== void 0 ? new Uint8Array(Nt.response || []) : $i(Nt.responseText || "", !0), Bt[Ce] = je;
          }
          if (typeof qt.ti[Ce] > "u")
            throw Error("doXHR failed!");
          return qt.ti[Ce];
        }), (ht || !Tt) && (yt = Tt = 1, yt = Tt = this.Si(0).length, C("LazyFiles on gzip forces download of the whole file when length is accessed")), this.nk = Tt, this.mk = yt, this.Bj = !0;
      }, typeof XMLHttpRequest < "u") {
        if (!u)
          throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
        var L = new M();
        Object.defineProperties(L, { length: { get: function() {
          return this.Bj || this.Qj(), this.nk;
        } }, chunkSize: { get: function() {
          return this.Bj || this.Qj(), this.mk;
        } } });
        var H = void 0;
      } else
        H = f, L = void 0;
      var Q = ji(a, c, p, v);
      L ? Q.gi = L : H && (Q.gi = null, Q.url = H), Object.defineProperties(Q, { mi: { get: function() {
        return this.gi.length;
      } } });
      var lt = {};
      return Object.keys(Q.ii).forEach((ht) => {
        var Tt = Q.ii[ht];
        lt[ht] = function() {
          return _o(Q), Tt.apply(null, arguments);
        };
      }), lt.read = (ht, Tt, Wt, et, yt) => {
        if (_o(Q), ht = ht.node.gi, yt >= ht.length)
          Tt = 0;
        else {
          if (et = Math.min(ht.length - yt, et), ht.slice)
            for (var qt = 0; qt < et; qt++)
              Tt[Wt + qt] = ht[yt + qt];
          else
            for (qt = 0; qt < et; qt++)
              Tt[Wt + qt] = ht.get(yt + qt);
          Tt = et;
        }
        return Tt;
      }, lt.Dj = () => {
        throw _o(Q), Ne(), new Ft(48);
      }, Q.ii = lt, Q;
    }, br = (a, c, f, p, v, M, L, H, Q, lt) => {
      function ht(Wt) {
        function et(yt) {
          lt && lt(), H || cs(a, c, yt, p, v, Q), M && M(), Be();
        }
        Rw(Wt, Tt, et, () => {
          L && L(), Be();
        }) || et(Wt);
      }
      var Tt = c ? kn(Ht(a + "/" + c)) : a;
      He(), typeof f == "string" ? Bn(f, (Wt) => ht(Wt), L) : ht(f);
    }, Xi = {}, te, le, ce = void 0;
    function Ae() {
      return ce += 4, z[ce - 4 >> 2];
    }
    function ni(a) {
      if (a = qi[a], !a)
        throw new Ft(8);
      return a;
    }
    var Di = {};
    function Pi(a) {
      for (; a.length; ) {
        var c = a.pop();
        a.pop()(c);
      }
    }
    function $e(a) {
      return this.fromWireType(z[a >> 2]);
    }
    var pi = {}, Ke = {}, ut = {};
    function Ot(a) {
      if (a === void 0)
        return "_unknown";
      a = a.replace(/[^a-zA-Z0-9_]/g, "$");
      var c = a.charCodeAt(0);
      return 48 <= c && 57 >= c ? "_" + a : a;
    }
    function jt(a, c) {
      return a = Ot(a), new Function("body", "return function " + a + `() {
    "use strict";    return body.apply(this, arguments);
};
`)(c);
    }
    function ue(a) {
      var c = Error, f = jt(a, function(p) {
        this.name = a, this.message = p, p = Error(p).stack, p !== void 0 && (this.stack = this.toString() + `
` + p.replace(/^Error(:[^\n]*)?\n/, ""));
      });
      return f.prototype = Object.create(c.prototype), f.prototype.constructor = f, f.prototype.toString = function() {
        return this.message === void 0 ? this.name : this.name + ": " + this.message;
      }, f;
    }
    var Ye = void 0;
    function li(a) {
      throw new Ye(a);
    }
    function mi(a, c, f) {
      function p(H) {
        H = f(H), H.length !== a.length && li("Mismatched type converter count");
        for (var Q = 0; Q < a.length; ++Q)
          xr(a[Q], H[Q]);
      }
      a.forEach(function(H) {
        ut[H] = c;
      });
      var v = Array(c.length), M = [], L = 0;
      c.forEach((H, Q) => {
        Ke.hasOwnProperty(H) ? v[Q] = Ke[H] : (M.push(H), pi.hasOwnProperty(H) || (pi[H] = []), pi[H].push(() => {
          v[Q] = Ke[H], ++L, L === M.length && p(v);
        }));
      }), M.length === 0 && p(v);
    }
    var Us = {};
    function Yo(a) {
      switch (a) {
        case 1:
          return 0;
        case 2:
          return 1;
        case 4:
          return 2;
        case 8:
          return 3;
        default:
          throw new TypeError("Unknown type size: " + a);
      }
    }
    var Gh = void 0;
    function hn(a) {
      for (var c = ""; A[a]; )
        c += Gh[A[a++]];
      return c;
    }
    var Ua = void 0;
    function Ve(a) {
      throw new Ua(a);
    }
    function xr(a, c, f = {}) {
      if (!("argPackAdvance" in c))
        throw new TypeError("registerType registeredInstance requires argPackAdvance");
      var p = c.name;
      if (a || Ve('type "' + p + '" must have a positive integer typeid pointer'), Ke.hasOwnProperty(a)) {
        if (f.Bk)
          return;
        Ve("Cannot register type '" + p + "' twice");
      }
      Ke[a] = c, delete ut[a], pi.hasOwnProperty(a) && (c = pi[a], delete pi[a], c.forEach((v) => v()));
    }
    function Od(a) {
      Ve(a.fi.ni.ji.name + " instance already deleted");
    }
    var Rd = !1;
    function Wg() {
    }
    function Gg(a) {
      --a.count.value, a.count.value === 0 && (a.ri ? a.wi.vi(a.ri) : a.ni.ji.vi(a.li));
    }
    function $g(a, c, f) {
      return c === f ? a : f.xi === void 0 ? null : (a = $g(a, c, f.xi), a === null ? null : f.tk(a));
    }
    var qg = {}, Ul = [];
    function Ld() {
      for (; Ul.length; ) {
        var a = Ul.pop();
        a.fi.Ri = !1, a.delete();
      }
    }
    var jl = void 0, Wl = {};
    function hw(a, c) {
      for (c === void 0 && Ve("ptr should not be undefined"); a.xi; )
        c = a.$i(c), a = a.xi;
      return Wl[c];
    }
    function $h(a, c) {
      return c.ni && c.li || li("makeClassHandle requires ptr and ptrType"), !!c.wi != !!c.ri && li("Both smartPtrType and smartPtr must be specified"), c.count = { value: 1 }, Gl(Object.create(a, { fi: { value: c } }));
    }
    function Gl(a) {
      return typeof FinalizationRegistry > "u" ? (Gl = (c) => c, a) : (Rd = new FinalizationRegistry((c) => {
        Gg(c.fi);
      }), Gl = (c) => {
        var f = c.fi;
        return f.ri && Rd.register(c, { fi: f }, c), c;
      }, Wg = (c) => {
        Rd.unregister(c);
      }, Gl(a));
    }
    function yo() {
    }
    function Kg(a, c, f) {
      if (a[c].Ei === void 0) {
        var p = a[c];
        a[c] = function() {
          return a[c].Ei.hasOwnProperty(arguments.length) || Ve("Function '" + f + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + a[c].Ei + ")!"), a[c].Ei[arguments.length].apply(this, arguments);
        }, a[c].Ei = [], a[c].Ei[p.uj] = p;
      }
    }
    function Xg(a, c) {
      e.hasOwnProperty(a) ? (Ve("Cannot register public name '" + a + "' twice"), Kg(e, a, a), e.hasOwnProperty(void 0) && Ve("Cannot register multiple overloads of a function with the same number of arguments (undefined)!"), e[a].Ei[void 0] = c) : e[a] = c;
    }
    function uw(a, c, f, p, v, M, L, H) {
      this.name = a, this.constructor = c, this.Ki = f, this.vi = p, this.xi = v, this.wk = M, this.$i = L, this.tk = H;
    }
    function qh(a, c, f) {
      for (; c !== f; )
        c.$i || Ve("Expected null or instance of " + f.name + ", got an instance of " + c.name), a = c.$i(a), c = c.xi;
      return a;
    }
    function dw(a, c) {
      return c === null ? (this.Aj && Ve("null is not a valid " + this.name), 0) : (c.fi || Ve('Cannot pass "' + Vd(c) + '" as a ' + this.name), c.fi.li || Ve("Cannot pass deleted object as a pointer of type " + this.name), qh(c.fi.li, c.fi.ni.ji, this.ji));
    }
    function fw(a, c) {
      if (c === null) {
        if (this.Aj && Ve("null is not a valid " + this.name), this.ij) {
          var f = this.Zi();
          return a !== null && a.push(this.vi, f), f;
        }
        return 0;
      }
      if (c.fi || Ve('Cannot pass "' + Vd(c) + '" as a ' + this.name), c.fi.li || Ve("Cannot pass deleted object as a pointer of type " + this.name), !this.hj && c.fi.ni.hj && Ve("Cannot convert argument of type " + (c.fi.wi ? c.fi.wi.name : c.fi.ni.name) + " to parameter type " + this.name), f = qh(c.fi.li, c.fi.ni.ji, this.ji), this.ij)
        switch (c.fi.ri === void 0 && Ve("Passing raw pointer to smart pointer is illegal"), this.Wk) {
          case 0:
            c.fi.wi === this ? f = c.fi.ri : Ve("Cannot convert argument of type " + (c.fi.wi ? c.fi.wi.name : c.fi.ni.name) + " to parameter type " + this.name);
            break;
          case 1:
            f = c.fi.ri;
            break;
          case 2:
            if (c.fi.wi === this)
              f = c.fi.ri;
            else {
              var p = c.clone();
              f = this.Mk(f, hs(function() {
                p.delete();
              })), a !== null && a.push(this.vi, f);
            }
            break;
          default:
            Ve("Unsupporting sharing policy");
        }
      return f;
    }
    function gw(a, c) {
      return c === null ? (this.Aj && Ve("null is not a valid " + this.name), 0) : (c.fi || Ve('Cannot pass "' + Vd(c) + '" as a ' + this.name), c.fi.li || Ve("Cannot pass deleted object as a pointer of type " + this.name), c.fi.ni.hj && Ve("Cannot convert argument of type " + c.fi.ni.name + " to parameter type " + this.name), qh(c.fi.li, c.fi.ni.ji, this.ji));
    }
    function Ir(a, c, f, p, v, M, L, H, Q, lt, ht) {
      this.name = a, this.ji = c, this.Aj = f, this.hj = p, this.ij = v, this.Kk = M, this.Wk = L, this.gk = H, this.Zi = Q, this.Mk = lt, this.vi = ht, v || c.xi !== void 0 ? this.toWireType = fw : (this.toWireType = p ? dw : gw, this.si = null);
    }
    function pw(a, c) {
      e.hasOwnProperty(a) || li("Replacing nonexistant public symbol"), e[a] = c, e[a].uj = void 0;
    }
    function mw(a, c) {
      var f = [];
      return function() {
        if (f.length = 0, Object.assign(f, arguments), a.includes("j")) {
          var p = e["dynCall_" + a];
          p = f && f.length ? p.apply(null, [c].concat(f)) : p.call(null, c);
        } else
          p = ot.get(c).apply(null, f);
        return p;
      };
    }
    function un(a, c) {
      a = hn(a);
      var f = a.includes("j") ? mw(a, c) : ot.get(c);
      return typeof f != "function" && Ve("unknown function pointer with signature " + a + ": " + c), f;
    }
    var Jg = void 0;
    function Yg(a) {
      a = Mp(a);
      var c = hn(a);
      return Pr(a), c;
    }
    function $l(a, c) {
      function f(M) {
        v[M] || Ke[M] || (ut[M] ? ut[M].forEach(f) : (p.push(M), v[M] = !0));
      }
      var p = [], v = {};
      throw c.forEach(f), new Jg(a + ": " + p.map(Yg).join([", "]));
    }
    function Zg(a) {
      var c = Function;
      if (!(c instanceof Function))
        throw new TypeError("new_ called with constructor type " + typeof c + " which is not a function");
      var f = jt(c.name || "unknownFunctionName", function() {
      });
      return f.prototype = c.prototype, f = new f(), a = c.apply(f, a), a instanceof Object ? a : f;
    }
    function Qg(a, c, f, p) {
      var v = c.length;
      2 > v && Ve("argTypes array size mismatch! Must at least get return value and 'this' types!");
      for (var M = c[1] !== null && !1, L = !1, H = 1; H < c.length; ++H)
        if (c[H] !== null && c[H].si === void 0) {
          L = !0;
          break;
        }
      var Q = c[0].name !== "void", lt = "", ht = "";
      for (H = 0; H < v - 2; ++H)
        lt += (H !== 0 ? ", " : "") + "arg" + H, ht += (H !== 0 ? ", " : "") + "arg" + H + "Wired";
      a = "return function " + Ot(a) + "(" + lt + `) {
if (arguments.length !== ` + (v - 2) + `) {
throwBindingError('function ` + a + " called with ' + arguments.length + ' arguments, expected " + (v - 2) + ` args!');
}
`, L && (a += `var destructors = [];
`);
      var Tt = L ? "destructors" : "null";
      for (lt = "throwBindingError invoker fn runDestructors retType classParam".split(" "), f = [Ve, f, p, Pi, c[0], c[1]], M && (a += "var thisWired = classParam.toWireType(" + Tt + `, this);
`), H = 0; H < v - 2; ++H)
        a += "var arg" + H + "Wired = argType" + H + ".toWireType(" + Tt + ", arg" + H + "); // " + c[H + 2].name + `
`, lt.push("argType" + H), f.push(c[H + 2]);
      if (M && (ht = "thisWired" + (0 < ht.length ? ", " : "") + ht), a += (Q ? "var rv = " : "") + "invoker(fn" + (0 < ht.length ? ", " : "") + ht + `);
`, L)
        a += `runDestructors(destructors);
`;
      else
        for (H = M ? 1 : 2; H < c.length; ++H)
          v = H === 1 ? "thisWired" : "arg" + (H - 2) + "Wired", c[H].si !== null && (a += v + "_dtor(" + v + "); // " + c[H].name + `
`, lt.push(v + "_dtor"), f.push(c[H].si));
      return Q && (a += `var ret = retType.fromWireType(rv);
return ret;
`), lt.push(a + `}
`), Zg(lt).apply(null, f);
    }
    function tp(a, c) {
      for (var f = [], p = 0; p < a; p++)
        f.push(St[c + 4 * p >> 2]);
      return f;
    }
    function ep(a, c, f) {
      return a instanceof Object || Ve(f + ' with invalid "this": ' + a), a instanceof c.ji.constructor || Ve(f + ' incompatible with "this" of type ' + a.constructor.name), a.fi.li || Ve("cannot call emscripten binding method " + f + " on deleted object"), qh(a.fi.li, a.fi.ni.ji, c.ji);
    }
    var Fd = [], tr = [{}, { value: void 0 }, { value: null }, { value: !0 }, { value: !1 }];
    function Bd(a) {
      4 < a && --tr[a].Gj === 0 && (tr[a] = void 0, Fd.push(a));
    }
    var er = (a) => (a || Ve("Cannot use deleted val. handle = " + a), tr[a].value), hs = (a) => {
      switch (a) {
        case void 0:
          return 1;
        case null:
          return 2;
        case !0:
          return 3;
        case !1:
          return 4;
        default:
          var c = Fd.length ? Fd.pop() : tr.length;
          return tr[c] = { Gj: 1, value: a }, c;
      }
    };
    function _w(a, c, f) {
      switch (c) {
        case 0:
          return function(p) {
            return this.fromWireType((f ? J : A)[p]);
          };
        case 1:
          return function(p) {
            return this.fromWireType((f ? R : wt)[p >> 1]);
          };
        case 2:
          return function(p) {
            return this.fromWireType((f ? z : St)[p >> 2]);
          };
        default:
          throw new TypeError("Unknown integer type: " + a);
      }
    }
    function ql(a, c) {
      var f = Ke[a];
      return f === void 0 && Ve(c + " has unknown type " + Yg(a)), f;
    }
    function Vd(a) {
      if (a === null)
        return "null";
      var c = typeof a;
      return c === "object" || c === "array" || c === "function" ? a.toString() : "" + a;
    }
    function yw(a, c) {
      switch (c) {
        case 2:
          return function(f) {
            return this.fromWireType(X[f >> 2]);
          };
        case 3:
          return function(f) {
            return this.fromWireType(At[f >> 3]);
          };
        default:
          throw new TypeError("Unknown float type: " + a);
      }
    }
    function ww(a, c, f) {
      switch (c) {
        case 0:
          return f ? function(p) {
            return J[p];
          } : function(p) {
            return A[p];
          };
        case 1:
          return f ? function(p) {
            return R[p >> 1];
          } : function(p) {
            return wt[p >> 1];
          };
        case 2:
          return f ? function(p) {
            return z[p >> 2];
          } : function(p) {
            return St[p >> 2];
          };
        default:
          throw new TypeError("Unknown integer type: " + a);
      }
    }
    var ip = typeof TextDecoder < "u" ? new TextDecoder("utf-16le") : void 0;
    function vw(a, c) {
      for (var f = a >> 1, p = f + c / 2; !(f >= p) && wt[f]; )
        ++f;
      if (f <<= 1, 32 < f - a && ip)
        return ip.decode(A.subarray(a, f));
      for (f = "", p = 0; !(p >= c / 2); ++p) {
        var v = R[a + 2 * p >> 1];
        if (v == 0)
          break;
        f += String.fromCharCode(v);
      }
      return f;
    }
    function bw(a, c, f) {
      if (f === void 0 && (f = 2147483647), 2 > f)
        return 0;
      f -= 2;
      var p = c;
      f = f < 2 * a.length ? f / 2 : a.length;
      for (var v = 0; v < f; ++v)
        R[c >> 1] = a.charCodeAt(v), c += 2;
      return R[c >> 1] = 0, c - p;
    }
    function xw(a) {
      return 2 * a.length;
    }
    function Iw(a, c) {
      for (var f = 0, p = ""; !(f >= c / 4); ) {
        var v = z[a + 4 * f >> 2];
        if (v == 0)
          break;
        ++f, 65536 <= v ? (v -= 65536, p += String.fromCharCode(55296 | v >> 10, 56320 | v & 1023)) : p += String.fromCharCode(v);
      }
      return p;
    }
    function Cw(a, c, f) {
      if (f === void 0 && (f = 2147483647), 4 > f)
        return 0;
      var p = c;
      f = p + f - 4;
      for (var v = 0; v < a.length; ++v) {
        var M = a.charCodeAt(v);
        if (55296 <= M && 57343 >= M) {
          var L = a.charCodeAt(++v);
          M = 65536 + ((M & 1023) << 10) | L & 1023;
        }
        if (z[c >> 2] = M, c += 4, c + 4 > f)
          break;
      }
      return z[c >> 2] = 0, c - p;
    }
    function Sw(a) {
      for (var c = 0, f = 0; f < a.length; ++f) {
        var p = a.charCodeAt(f);
        55296 <= p && 57343 >= p && ++f, c += 4;
      }
      return c;
    }
    function np(a, c) {
      for (var f = Array(a), p = 0; p < a; ++p)
        f[p] = ql(St[c + 4 * p >> 2], "parameter " + p);
      return f;
    }
    var Pw = {};
    function Kh(a) {
      var c = Pw[a];
      return c === void 0 ? hn(a) : c;
    }
    var zd = [];
    function sp() {
      return typeof globalThis == "object" ? globalThis : Function("return this")();
    }
    function kw(a) {
      var c = zd.length;
      return zd.push(a), c;
    }
    var rp = [];
    function Mw(a) {
      for (var c = "", f = 0; f < a; ++f)
        c += (f !== 0 ? ", " : "") + "arg" + f;
      var p = "return function emval_allocator_" + a + `(constructor, argTypes, args) {
  var HEAPU32 = getMemory();
`;
      for (f = 0; f < a; ++f)
        p += "var argType" + f + " = requireRegisteredType(HEAPU32[((argTypes)>>2)], 'parameter " + f + `');
var arg` + f + " = argType" + f + `.readValueFromPointer(args);
args += argType` + f + `['argPackAdvance'];
argTypes += 4;
`;
      return new Function("requireRegisteredType", "Module", "valueToHandle", "getMemory", p + ("var obj = new constructor(" + c + `);
return valueToHandle(obj);
}
`))(ql, e, hs, () => St);
    }
    var op = {}, Hd = [];
    function Ew(a, c) {
      if (Yh = a, Zh = c, Kl) {
        if (a == 0)
          Zo = function() {
            var p = Math.max(0, up + c - Xh()) | 0;
            setTimeout(Xl, p);
          };
        else if (a == 1)
          Zo = function() {
            Gd(Xl);
          };
        else if (a == 2) {
          if (typeof setImmediate > "u") {
            var f = [];
            addEventListener("message", (p) => {
              (p.data === "setimmediate" || p.data.target === "setimmediate") && (p.stopPropagation(), f.shift()());
            }, !0), setImmediate = function(p) {
              f.push(p), u ? (e.setImmediates === void 0 && (e.setImmediates = []), e.setImmediates.push(p), postMessage({ target: "setimmediate" })) : postMessage(
                "setimmediate",
                "*"
              );
            };
          }
          Zo = function() {
            setImmediate(Xl);
          };
        }
      }
    }
    var Xh;
    Xh = d ? () => {
      var a = process.hrtime();
      return 1e3 * a[0] + a[1] / 1e6;
    } : () => performance.now();
    function ap(a) {
      O || (e.onExit && e.onExit(a), j = !0), l(a, new It(a));
    }
    function lp(a) {
      a instanceof It || a == "unwind" || l(1, a);
    }
    function Aw(a) {
      !Kl || Ne("emscripten_set_main_loop: there can only be one main loop function at once: call emscripten_cancel_main_loop to cancel the previous one before setting a new one with different parameters."), Kl = a;
      var c = ja;
      Xl = function() {
        if (!j)
          if (0 < hp.length) {
            var f = Date.now(), p = hp.shift();
            p.kl(p.el);
            var v;
            C('main loop blocker "' + p.name + '" took ' + (Date.now() - f) + " ms"), e.setStatus && (f = e.statusMessage || "Please wait...", p = Dw, v = Nw.jl, p ? p < v ? e.setStatus(f + " (" + (v - p) + "/" + v + ")") : e.setStatus(f) : e.setStatus("")), c < ja || setTimeout(Xl, 0);
          } else
            c < ja || (jd = jd + 1 | 0, Yh == 1 && 1 < Zh && jd % Zh != 0 ? Zo() : (Yh == 0 && (up = Xh()), j || e.preMainLoop && e.preMainLoop() === !1 || (Ud(a), e.postMainLoop && e.postMainLoop()), c < ja || (typeof SDL == "object" && SDL.audio && SDL.audio.Lk && SDL.audio.Lk(), Zo())));
      };
    }
    function Ud(a) {
      if (!j)
        try {
          a();
        } catch (c) {
          lp(c);
        }
    }
    function cp(a, c) {
      setTimeout(function() {
        Ud(a);
      }, c);
    }
    function Tw(a) {
      Jh || (Jh = {}), Jh[a] || (Jh[a] = 1, d && (a = "warning: " + a), P(a));
    }
    var Jh, Zo = null, ja = 0, Kl = null, Yh = 0, Zh = 0, jd = 0, hp = [], Nw = {}, up, Xl, Dw, Wa = !1, dp = !1, Ow = [];
    function Wd() {
      function a() {
        dp = document.pointerLockElement === e.canvas || document.mozPointerLockElement === e.canvas || document.webkitPointerLockElement === e.canvas || document.msPointerLockElement === e.canvas;
      }
      if (e.preloadPlugins || (e.preloadPlugins = []), !gp) {
        gp = !0;
        try {
          $a = !0;
        } catch {
          $a = !1, P("warning: no blob constructor, cannot create blobs with mimetypes");
        }
        Kd = typeof MozBlobBuilder < "u" ? MozBlobBuilder : typeof WebKitBlobBuilder < "u" ? WebKitBlobBuilder : $a ? null : P("warning: no BlobBuilder"), wo = typeof window < "u" ? window.URL ? window.URL : window.webkitURL : void 0, e.fk || typeof wo < "u" || (P("warning: Browser does not support creating object URLs. Built-in browser image decoding will not be available."), e.fk = !0), e.preloadPlugins.push({ canHandle: function(f) {
          return !e.fk && /\.(jpg|jpeg|png|bmp)$/i.test(f);
        }, handle: function(f, p, v, M) {
          var L = null;
          if ($a)
            try {
              L = new Blob([f], { type: $d(p) }), L.size !== f.length && (L = new Blob([new Uint8Array(f).buffer], { type: $d(p) }));
            } catch (lt) {
              Tw("Blob constructor present but fails: " + lt + "; falling back to blob builder");
            }
          L || (L = new Kd(), L.append(new Uint8Array(f).buffer), L = L.getBlob());
          var H = wo.createObjectURL(L), Q = new Image();
          Q.onload = () => {
            Q.complete || Ne("Image " + p + " could not be decoded");
            var lt = document.createElement("canvas");
            lt.width = Q.width, lt.height = Q.height, lt.getContext("2d").drawImage(Q, 0, 0), wo.revokeObjectURL(H), v && v(f);
          }, Q.onerror = () => {
            C("Image " + H + " could not be decoded"), M && M();
          }, Q.src = H;
        } }), e.preloadPlugins.push({ canHandle: function(f) {
          return !e.ql && f.substr(-4) in {
            ".ogg": 1,
            ".wav": 1,
            ".mp3": 1
          };
        }, handle: function(f, p, v, M) {
          function L() {
            Q || (Q = !0, v && v(f));
          }
          function H() {
            Q || (Q = !0, new Audio(), M && M());
          }
          var Q = !1;
          if ($a) {
            try {
              var lt = new Blob([f], { type: $d(p) });
            } catch {
              return H();
            }
            lt = wo.createObjectURL(lt);
            var ht = new Audio();
            ht.addEventListener("canplaythrough", () => L(), !1), ht.onerror = function() {
              if (!Q) {
                P("warning: browser could not fully decode audio " + p + ", trying slower base64 approach");
                for (var Tt = "", Wt = 0, et = 0, yt = 0; yt < f.length; yt++)
                  for (Wt = Wt << 8 | f[yt], et += 8; 6 <= et; ) {
                    var qt = Wt >> et - 6 & 63;
                    et -= 6, Tt += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[qt];
                  }
                et == 2 ? (Tt += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[(Wt & 3) << 4], Tt += "==") : et == 4 && (Tt += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[(Wt & 15) << 2], Tt += "="), ht.src = "data:audio/x-" + p.substr(-3) + ";base64," + Tt, L();
              }
            }, ht.src = lt, cp(function() {
              L();
            }, 1e4);
          } else
            return H();
        } });
        var c = e.canvas;
        c && (c.requestPointerLock = c.requestPointerLock || c.mozRequestPointerLock || c.webkitRequestPointerLock || c.msRequestPointerLock || (() => {
        }), c.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock || document.msExitPointerLock || (() => {
        }), c.exitPointerLock = c.exitPointerLock.bind(document), document.addEventListener("pointerlockchange", a, !1), document.addEventListener("mozpointerlockchange", a, !1), document.addEventListener("webkitpointerlockchange", a, !1), document.addEventListener("mspointerlockchange", a, !1), e.elementPointerLock && c.addEventListener("click", (f) => {
          !dp && e.canvas.requestPointerLock && (e.canvas.requestPointerLock(), f.preventDefault());
        }, !1));
      }
    }
    function Rw(a, c, f, p) {
      Wd();
      var v = !1;
      return e.preloadPlugins.forEach(function(M) {
        !v && M.canHandle(c) && (M.handle(a, c, f, p), v = !0);
      }), v;
    }
    function Lw(a, c, f, p) {
      if (c && e.Wi && a == e.canvas)
        return e.Wi;
      var v;
      if (c) {
        var M = { antialias: !1, alpha: !1, Cj: typeof WebGL2RenderingContext < "u" ? 2 : 1 };
        if (p)
          for (var L in p)
            M[L] = p[L];
        if (typeof Yd < "u" && (v = _p(a, M)))
          var H = Sr[v].Qi;
      } else
        H = a.getContext("2d");
      return H ? (f && (c || typeof N > "u" || Ne("cannot set in module if GLctx is used, but we are a non-GL context that would replace it"), e.Wi = H, c && yp(v), e.wl = c, Ow.forEach(function(Q) {
        Q();
      }), Wd()), H) : null;
    }
    var fp = !1, Qh = void 0, Ga = void 0;
    function Fw(a, c) {
      function f() {
        Wa = !1;
        var M = p.parentNode;
        (document.fullscreenElement || document.mozFullScreenElement || document.msFullscreenElement || document.webkitFullscreenElement || document.webkitCurrentFullScreenElement) === M ? (p.exitFullscreen = Bw, Qh && p.requestPointerLock(), Wa = !0, Ga ? (typeof SDL < "u" && (z[SDL.screen >> 2] = St[SDL.screen >> 2] | 8388608), Yl(e.canvas), qd()) : Yl(p)) : (M.parentNode.insertBefore(p, M), M.parentNode.removeChild(M), Ga ? (typeof SDL < "u" && (z[SDL.screen >> 2] = St[SDL.screen >> 2] & -8388609), Yl(e.canvas), qd()) : Yl(p)), e.onFullScreen && e.onFullScreen(Wa), e.onFullscreen && e.onFullscreen(Wa);
      }
      Qh = a, Ga = c, typeof Qh > "u" && (Qh = !0), typeof Ga > "u" && (Ga = !1);
      var p = e.canvas;
      fp || (fp = !0, document.addEventListener("fullscreenchange", f, !1), document.addEventListener("mozfullscreenchange", f, !1), document.addEventListener("webkitfullscreenchange", f, !1), document.addEventListener("MSFullscreenChange", f, !1));
      var v = document.createElement("div");
      p.parentNode.insertBefore(v, p), v.appendChild(p), v.requestFullscreen = v.requestFullscreen || v.mozRequestFullScreen || v.msRequestFullscreen || (v.webkitRequestFullscreen ? () => v.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT) : null) || (v.webkitRequestFullScreen ? () => v.webkitRequestFullScreen(Element.ALLOW_KEYBOARD_INPUT) : null), v.requestFullscreen();
    }
    function Bw() {
      return Wa ? ((document.exitFullscreen || document.cancelFullScreen || document.mozCancelFullScreen || document.msExitFullscreen || document.webkitCancelFullScreen || function() {
      }).apply(document, []), !0) : !1;
    }
    var Jl = 0;
    function Gd(a) {
      if (typeof requestAnimationFrame == "function")
        requestAnimationFrame(a);
      else {
        var c = Date.now();
        if (Jl === 0)
          Jl = c + 1e3 / 60;
        else
          for (; c + 2 >= Jl; )
            Jl += 1e3 / 60;
        setTimeout(a, Math.max(Jl - c, 0));
      }
    }
    function Vw(a) {
      Gd(function() {
        Ud(a);
      });
    }
    function $d(a) {
      return { jpg: "image/jpeg", jpeg: "image/jpeg", png: "image/png", bmp: "image/bmp", ogg: "audio/ogg", wav: "audio/wav", mp3: "audio/mpeg" }[a.substr(a.lastIndexOf(".") + 1)];
    }
    var zw = [];
    function qd() {
      var a = e.canvas;
      zw.forEach(function(c) {
        c(a.width, a.height);
      });
    }
    function Yl(a, c, f) {
      c && f ? (a.cl = c, a.Ak = f) : (c = a.cl, f = a.Ak);
      var p = c, v = f;
      if (e.forcedAspectRatio && 0 < e.forcedAspectRatio && (p / v < e.forcedAspectRatio ? p = Math.round(v * e.forcedAspectRatio) : v = Math.round(p / e.forcedAspectRatio)), (document.fullscreenElement || document.mozFullScreenElement || document.msFullscreenElement || document.webkitFullscreenElement || document.webkitCurrentFullScreenElement) === a.parentNode && typeof screen < "u") {
        var M = Math.min(screen.width / p, screen.height / v);
        p = Math.round(p * M), v = Math.round(v * M);
      }
      Ga ? (a.width != p && (a.width = p), a.height != v && (a.height = v), typeof a.style < "u" && (a.style.removeProperty("width"), a.style.removeProperty("height"))) : (a.width != c && (a.width = c), a.height != f && (a.height = f), typeof a.style < "u" && (p != c || v != f ? (a.style.setProperty("width", p + "px", "important"), a.style.setProperty("height", v + "px", "important")) : (a.style.removeProperty("width"), a.style.removeProperty("height"))));
    }
    var gp, $a, Kd, wo;
    function Hw(a) {
      var c = a.getExtension("ANGLE_instanced_arrays");
      c && (a.vertexAttribDivisor = function(f, p) {
        c.vertexAttribDivisorANGLE(f, p);
      }, a.drawArraysInstanced = function(f, p, v, M) {
        c.drawArraysInstancedANGLE(f, p, v, M);
      }, a.drawElementsInstanced = function(f, p, v, M, L) {
        c.drawElementsInstancedANGLE(f, p, v, M, L);
      });
    }
    function Uw(a) {
      var c = a.getExtension("OES_vertex_array_object");
      c && (a.createVertexArray = function() {
        return c.createVertexArrayOES();
      }, a.deleteVertexArray = function(f) {
        c.deleteVertexArrayOES(f);
      }, a.bindVertexArray = function(f) {
        c.bindVertexArrayOES(f);
      }, a.isVertexArray = function(f) {
        return c.isVertexArrayOES(f);
      });
    }
    function jw(a) {
      var c = a.getExtension("WEBGL_draw_buffers");
      c && (a.drawBuffers = function(f, p) {
        c.drawBuffersWEBGL(f, p);
      });
    }
    var Xd = 1, ir = [], De = [], Xr = [], nr = [], js = [], Ji = [], Cr = [], Sr = [], tu = {}, Yi = [], sr = [], Zl = [], vo = [], eu = {}, pp = {}, Jd = 4;
    function Kt(a) {
      qa || (qa = a);
    }
    function bo(a) {
      for (var c = Xd++, f = a.length; f < c; f++)
        a[f] = null;
      return c;
    }
    function mp(a, c, f) {
      for (var p = "", v = 0; v < a; ++v) {
        var M = f ? z[f + 4 * v >> 2] : -1;
        p += q(z[c + 4 * v >> 2], 0 > M ? void 0 : M);
      }
      return p;
    }
    function _p(a, c) {
      a.ti || (a.ti = a.getContext, a.getContext = function(p, v) {
        return v = a.ti(p, v), p == "webgl" == v instanceof WebGLRenderingContext ? v : null;
      });
      var f = 1 < c.Cj ? a.getContext("webgl2", c) : a.getContext("webgl", c);
      return f ? Ww(f, c) : 0;
    }
    function Ww(a, c) {
      var f = bo(Sr), p = { ml: f, attributes: c, version: c.Cj, Qi: a };
      return a.canvas && (a.canvas.lk = p), Sr[f] = p, (typeof c.Wj > "u" || c.Wj) && Gw(p), f;
    }
    function yp(a) {
      return ye = Sr[a], e.Wi = N = ye && ye.Qi, !(a && !N);
    }
    function Gw(a) {
      if (a || (a = ye), !a.Ck) {
        a.Ck = !0;
        var c = a.Qi;
        Hw(c), Uw(c), jw(c), c.gl = c.getExtension("WEBGL_draw_instanced_base_vertex_base_instance"), c.nl = c.getExtension("WEBGL_multi_draw_instanced_base_vertex_base_instance"), 2 <= a.version && (c.pi = c.getExtension("EXT_disjoint_timer_query_webgl2")), (2 > a.version || !c.pi) && (c.pi = c.getExtension("EXT_disjoint_timer_query")), c.pl = c.getExtension("WEBGL_multi_draw"), (c.getSupportedExtensions() || []).forEach(function(f) {
          f.includes("lose_context") || f.includes("debug") || c.getExtension(f);
        });
      }
    }
    var Yd = {}, qa, ye, Qo = [];
    function wp(a, c, f, p) {
      N.drawElements(a, c, f, p);
    }
    function us(a, c, f, p) {
      for (var v = 0; v < a; v++) {
        var M = N[f](), L = M && bo(p);
        M ? (M.name = L, p[L] = M) : Kt(1282), z[c + 4 * v >> 2] = L;
      }
    }
    function iu(a, c, f, p, v, M, L, H) {
      c = De[c], (a = N[a](c, f)) && (p = H && st(a.name, A, H, p), v && (z[v >> 2] = p), M && (z[M >> 2] = a.size), L && (z[L >> 2] = a.type));
    }
    function Ql(a, c) {
      St[a >> 2] = c, St[a + 4 >> 2] = (c - St[a >> 2]) / 4294967296;
    }
    function ta(a, c, f) {
      if (c) {
        var p = void 0;
        switch (a) {
          case 36346:
            p = 1;
            break;
          case 36344:
            f != 0 && f != 1 && Kt(1280);
            return;
          case 34814:
          case 36345:
            p = 0;
            break;
          case 34466:
            var v = N.getParameter(34467);
            p = v ? v.length : 0;
            break;
          case 33309:
            if (2 > ye.version) {
              Kt(1282);
              return;
            }
            p = 2 * (N.getSupportedExtensions() || []).length;
            break;
          case 33307:
          case 33308:
            if (2 > ye.version) {
              Kt(1280);
              return;
            }
            p = a == 33307 ? 3 : 0;
        }
        if (p === void 0)
          switch (v = N.getParameter(a), typeof v) {
            case "number":
              p = v;
              break;
            case "boolean":
              p = v ? 1 : 0;
              break;
            case "string":
              Kt(1280);
              return;
            case "object":
              if (v === null)
                switch (a) {
                  case 34964:
                  case 35725:
                  case 34965:
                  case 36006:
                  case 36007:
                  case 32873:
                  case 34229:
                  case 36662:
                  case 36663:
                  case 35053:
                  case 35055:
                  case 36010:
                  case 35097:
                  case 35869:
                  case 32874:
                  case 36389:
                  case 35983:
                  case 35368:
                  case 34068:
                    p = 0;
                    break;
                  default:
                    Kt(1280);
                    return;
                }
              else {
                if (v instanceof Float32Array || v instanceof Uint32Array || v instanceof Int32Array || v instanceof Array) {
                  for (a = 0; a < v.length; ++a)
                    switch (f) {
                      case 0:
                        z[c + 4 * a >> 2] = v[a];
                        break;
                      case 2:
                        X[c + 4 * a >> 2] = v[a];
                        break;
                      case 4:
                        J[c + a >> 0] = v[a] ? 1 : 0;
                    }
                  return;
                }
                try {
                  p = v.name | 0;
                } catch (M) {
                  Kt(1280), P("GL_INVALID_ENUM in glGet" + f + "v: Unknown object returned from WebGL getParameter(" + a + ")! (error: " + M + ")");
                  return;
                }
              }
              break;
            default:
              Kt(1280), P("GL_INVALID_ENUM in glGet" + f + "v: Native code calling glGet" + f + "v(" + a + ") and it returns " + v + " of type " + typeof v + "!");
              return;
          }
        switch (f) {
          case 1:
            Ql(c, p);
            break;
          case 0:
            z[c >> 2] = p;
            break;
          case 2:
            X[c >> 2] = p;
            break;
          case 4:
            J[c >> 0] = p ? 1 : 0;
        }
      } else
        Kt(1281);
    }
    function vp(a, c, f, p) {
      if (f) {
        switch (c = N.getIndexedParameter(a, c), typeof c) {
          case "boolean":
            a = c ? 1 : 0;
            break;
          case "number":
            a = c;
            break;
          case "object":
            if (c === null)
              switch (a) {
                case 35983:
                case 35368:
                  a = 0;
                  break;
                default:
                  Kt(1280);
                  return;
              }
            else if (c instanceof WebGLBuffer)
              a = c.name | 0;
            else {
              Kt(1280);
              return;
            }
            break;
          default:
            Kt(1280);
            return;
        }
        switch (p) {
          case 1:
            Ql(f, a);
            break;
          case 0:
            z[f >> 2] = a;
            break;
          case 2:
            X[f >> 2] = a;
            break;
          case 4:
            J[f >> 0] = a ? 1 : 0;
            break;
          default:
            throw "internal emscriptenWebGLGetIndexed() error, bad type: " + p;
        }
      } else
        Kt(1281);
    }
    function Jr(a) {
      var c = dt(a) + 1, f = ic(c);
      return st(a, A, f, c), f;
    }
    function Zd(a) {
      return a.slice(-1) == "]" && a.lastIndexOf("[");
    }
    function Qd(a) {
      var c = a.Pi, f = a.sj, p;
      if (!c)
        for (a.Pi = c = {}, a.jk = {}, p = 0; p < N.getProgramParameter(a, 35718); ++p) {
          var v = N.getActiveUniform(a, p), M = v.name;
          v = v.size;
          var L = Zd(M);
          L = 0 < L ? M.slice(0, L) : M;
          var H = a.rj;
          for (a.rj += v, f[L] = [v, H], M = 0; M < v; ++M)
            c[H] = M, a.jk[H++] = L;
        }
    }
    function Zt(a) {
      var c = N.Uj;
      if (c) {
        var f = c.Pi[a];
        return typeof f == "number" && (c.Pi[a] = f = N.getUniformLocation(c, c.jk[a] + (0 < f ? "[" + f + "]" : ""))), f;
      }
      Kt(1282);
    }
    function tf(a, c, f, p) {
      if (f)
        if (a = De[a], Qd(a), a = N.getUniform(a, Zt(c)), typeof a == "number" || typeof a == "boolean")
          switch (p) {
            case 0:
              z[f >> 2] = a;
              break;
            case 2:
              X[f >> 2] = a;
          }
        else
          for (c = 0; c < a.length; c++)
            switch (p) {
              case 0:
                z[f + 4 * c >> 2] = a[c];
                break;
              case 2:
                X[f + 4 * c >> 2] = a[c];
            }
      else
        Kt(1281);
    }
    function nu(a, c, f, p) {
      if (f)
        if (a = N.getVertexAttrib(a, c), c == 34975)
          z[f >> 2] = a && a.name;
        else if (typeof a == "number" || typeof a == "boolean")
          switch (p) {
            case 0:
              z[f >> 2] = a;
              break;
            case 2:
              X[f >> 2] = a;
              break;
            case 5:
              z[f >> 2] = Math.fround(a);
          }
        else
          for (c = 0; c < a.length; c++)
            switch (p) {
              case 0:
                z[f + 4 * c >> 2] = a[c];
                break;
              case 2:
                X[f + 4 * c >> 2] = a[c];
                break;
              case 5:
                z[f + 4 * c >> 2] = Math.fround(a[c]);
            }
      else
        Kt(1281);
    }
    function xo(a) {
      return a -= 5120, a == 0 ? J : a == 1 ? A : a == 2 ? R : a == 4 ? z : a == 6 ? X : a == 5 || a == 28922 || a == 28520 || a == 30779 || a == 30782 ? St : wt;
    }
    function Io(a) {
      return 31 - Math.clz32(a.BYTES_PER_ELEMENT);
    }
    function tc(a, c, f, p, v) {
      a = xo(a);
      var M = Io(a), L = Jd;
      return a.subarray(v >> M, v + p * (f * ({ 5: 3, 6: 4, 8: 2, 29502: 3, 29504: 4, 26917: 2, 26918: 2, 29846: 3, 29847: 4 }[c - 6402] || 1) * (1 << M) + L - 1 & -L) >> M);
    }
    var ds = [], ec = [], su = [], $w = {}, qw = ["default", "low-power", "high-performance"], Kw = [0, typeof document < "u" ? document : 0, typeof window < "u" ? window : 0];
    function Xw(a) {
      try {
        return a ? (typeof a == "number" && (a = Kw[a] || q(a)), a === "#window" ? window : a === "#document" ? document : a === "#screen" ? screen : a === "#canvas" ? e.canvas : typeof a == "string" ? document.getElementById(a) : a) : window;
      } catch {
        return null;
      }
    }
    var ef = {};
    function bp() {
      if (!nf) {
        var a = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: o || "./this.program" }, c;
        for (c in ef)
          ef[c] === void 0 ? delete a[c] : a[c] = ef[c];
        var f = [];
        for (c in a)
          f.push(c + "=" + a[c]);
        nf = f;
      }
      return nf;
    }
    var nf;
    function xp(a, c) {
      a = new Uint8Array(a);
      var f = a.byteLength;
      if (e.bk += f + 24, 327680 >= f) {
        var p = au();
        try {
          var v = nc(f);
          A.subarray(v, v + f).set(a), c(v, f);
        } finally {
          lu(p);
        }
      } else {
        v = ic(f);
        try {
          A.subarray(v, v + f).set(a), c(v, f);
        } finally {
          Pr(v);
        }
      }
    }
    var ea = { connect: function(a, c, f) {
      if (e.vj = c, e.oj = Ka("webSocketHandlerOnMessage", null, ["number", "number", "number", "number"]), e.Mi ? e.Mi++ : e.Mi = 1, e.ik = !1, !e.worker) {
        a = new Worker(URL.createObjectURL(new Blob(['var socket;self.onmessage = function (event) {	if (event.data.constructor === ArrayBuffer) {		socket.send (event.data);	} else if (event.data[0] === "connect") {		socket = new WebSocket (event.data[1]);		socket.binaryType = "arraybuffer";		var token = event.data[2];		socket.onclose = function (event) {			self.postMessage (["close", token]);		};		socket.onerror = function (event) {			self.postMessage (["error", token]);		};		socket.onopen = function (event) {			self.postMessage (["open", token]);		};		socket.onmessage = function (event) {			self.postMessage (["data", event.data, token], [event.data]);		};	} else if (event.data[0] === "close") {		socket.close ();	}}'], { type: "application/javascript" }))), e.worker = a;
        var p = function(v, M) {
          e.oj(v, M, e.vj, 2);
        };
        a.onmessage = function(v) {
          e.$$facade && (v.data[0] === "data" ? v.data[2] === e.Mi && xp(v.data[1], p) : v.data[0] === "open" ? v.data[1] === e.Mi && (e.ik = !0, e.oj(0, 0, e.vj, 0)) : v.data[0] === "close" ? v.data[1] === e.Mi && (e.oj(0, 0, e.vj, 3), e.ki("websocket_connection_closed")) : v.data[0] === "error" && v.data[1] === e.Mi && e.ki(e.ik ? "socket_error" : "socket_open_failed"));
        };
      }
      e.worker.postMessage(["connect", q(f), e.Mi]);
    }, Jj: function(a, c) {
      e.worker && (a = new Uint8Array(A.subarray(a, a + c)).buffer, e.worker.postMessage(a, [a]));
    }, close: function() {
      e.worker && e.worker.postMessage(["close"]), e.oj = function() {
      };
    } }, ia = { connect: function(a, c, f) {
      function p(H, Q) {
        M(H, Q, c, 2);
      }
      a = q(f);
      var v = new WebSocket(a);
      e.Fi = v, v.binaryType = "arraybuffer";
      var M = Ka("webSocketHandlerOnMessage", null, ["number", "number", "number", "number"]), L = !1;
      v.onclose = function() {
        e.Fi === v && (M(0, 0, c, 3), e.ki("websocket_connection_closed"));
      }, v.onerror = function() {
        e.Fi === v && e.ki(L ? "socket_error" : "socket_open_failed");
      }, v.onopen = function() {
        e.Fi === v && (L = !0, M(0, 0, c, 0));
      }, v.onmessage = function(H) {
        e.Fi === v && xp(H.data, p);
      };
    }, Jj: function(a, c) {
      e.Fi && e.Fi.send(A.subarray(a, a + c));
    }, close: function() {
      e.Fi && e.Fi.close(), delete e.Fi;
    } };
    function ru(a) {
      return a % 4 === 0 && (a % 100 !== 0 || a % 400 === 0);
    }
    var Ip = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], Cp = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    function Jw(a, c, f, p) {
      function v(et, yt, qt) {
        for (et = typeof et == "number" ? et.toString() : et || ""; et.length < yt; )
          et = qt[0] + et;
        return et;
      }
      function M(et, yt) {
        return v(et, yt, "0");
      }
      function L(et, yt) {
        function qt(je) {
          return 0 > je ? -1 : 0 < je ? 1 : 0;
        }
        var Ce;
        return (Ce = qt(et.getFullYear() - yt.getFullYear())) === 0 && (Ce = qt(et.getMonth() - yt.getMonth())) === 0 && (Ce = qt(et.getDate() - yt.getDate())), Ce;
      }
      function H(et) {
        switch (et.getDay()) {
          case 0:
            return new Date(et.getFullYear() - 1, 11, 29);
          case 1:
            return et;
          case 2:
            return new Date(et.getFullYear(), 0, 3);
          case 3:
            return new Date(
              et.getFullYear(),
              0,
              2
            );
          case 4:
            return new Date(et.getFullYear(), 0, 1);
          case 5:
            return new Date(et.getFullYear() - 1, 11, 31);
          case 6:
            return new Date(et.getFullYear() - 1, 11, 30);
        }
      }
      function Q(et) {
        var yt = et.Ni;
        for (et = new Date(new Date(et.Oi + 1900, 0, 1).getTime()); 0 < yt; ) {
          var qt = et.getMonth(), Ce = (ru(et.getFullYear()) ? Ip : Cp)[qt];
          if (yt > Ce - et.getDate())
            yt -= Ce - et.getDate() + 1, et.setDate(1), 11 > qt ? et.setMonth(qt + 1) : (et.setMonth(0), et.setFullYear(et.getFullYear() + 1));
          else {
            et.setDate(et.getDate() + yt);
            break;
          }
        }
        return qt = new Date(et.getFullYear() + 1, 0, 4), yt = H(new Date(
          et.getFullYear(),
          0,
          4
        )), qt = H(qt), 0 >= L(yt, et) ? 0 >= L(qt, et) ? et.getFullYear() + 1 : et.getFullYear() : et.getFullYear() - 1;
      }
      var lt = z[p + 40 >> 2];
      p = { $k: z[p >> 2], Zk: z[p + 4 >> 2], pj: z[p + 8 >> 2], Nj: z[p + 12 >> 2], qj: z[p + 16 >> 2], Oi: z[p + 20 >> 2], zi: z[p + 24 >> 2], Ni: z[p + 28 >> 2], ul: z[p + 32 >> 2], Yk: z[p + 36 >> 2], al: lt ? q(lt) : "" }, f = q(f), lt = {
        "%c": "%a %b %d %H:%M:%S %Y",
        "%D": "%m/%d/%y",
        "%F": "%Y-%m-%d",
        "%h": "%b",
        "%r": "%I:%M:%S %p",
        "%R": "%H:%M",
        "%T": "%H:%M:%S",
        "%x": "%m/%d/%y",
        "%X": "%H:%M:%S",
        "%Ec": "%c",
        "%EC": "%C",
        "%Ex": "%m/%d/%y",
        "%EX": "%H:%M:%S",
        "%Ey": "%y",
        "%EY": "%Y",
        "%Od": "%d",
        "%Oe": "%e",
        "%OH": "%H",
        "%OI": "%I",
        "%Om": "%m",
        "%OM": "%M",
        "%OS": "%S",
        "%Ou": "%u",
        "%OU": "%U",
        "%OV": "%V",
        "%Ow": "%w",
        "%OW": "%W",
        "%Oy": "%y"
      };
      for (var ht in lt)
        f = f.replace(new RegExp(ht, "g"), lt[ht]);
      var Tt = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), Wt = "January February March April May June July August September October November December".split(" ");
      lt = {
        "%a": function(et) {
          return Tt[et.zi].substring(0, 3);
        },
        "%A": function(et) {
          return Tt[et.zi];
        },
        "%b": function(et) {
          return Wt[et.qj].substring(0, 3);
        },
        "%B": function(et) {
          return Wt[et.qj];
        },
        "%C": function(et) {
          return M((et.Oi + 1900) / 100 | 0, 2);
        },
        "%d": function(et) {
          return M(et.Nj, 2);
        },
        "%e": function(et) {
          return v(et.Nj, 2, " ");
        },
        "%g": function(et) {
          return Q(et).toString().substring(2);
        },
        "%G": function(et) {
          return Q(et);
        },
        "%H": function(et) {
          return M(et.pj, 2);
        },
        "%I": function(et) {
          return et = et.pj, et == 0 ? et = 12 : 12 < et && (et -= 12), M(et, 2);
        },
        "%j": function(et) {
          for (var yt = 0, qt = 0; qt <= et.qj - 1; yt += (ru(et.Oi + 1900) ? Ip : Cp)[qt++])
            ;
          return M(et.Nj + yt, 3);
        },
        "%m": function(et) {
          return M(et.qj + 1, 2);
        },
        "%M": function(et) {
          return M(et.Zk, 2);
        },
        "%n": function() {
          return `
`;
        },
        "%p": function(et) {
          return 0 <= et.pj && 12 > et.pj ? "AM" : "PM";
        },
        "%S": function(et) {
          return M(et.$k, 2);
        },
        "%t": function() {
          return "	";
        },
        "%u": function(et) {
          return et.zi || 7;
        },
        "%U": function(et) {
          return M(Math.floor((et.Ni + 7 - et.zi) / 7), 2);
        },
        "%V": function(et) {
          var yt = Math.floor((et.Ni + 7 - (et.zi + 6) % 7) / 7);
          if (2 >= (et.zi + 371 - et.Ni - 2) % 7 && yt++, yt)
            yt == 53 && (qt = (et.zi + 371 - et.Ni) % 7, qt == 4 || qt == 3 && ru(et.Oi) || (yt = 1));
          else {
            yt = 52;
            var qt = (et.zi + 7 - et.Ni - 1) % 7;
            (qt == 4 || qt == 5 && ru(et.Oi % 400 - 1)) && yt++;
          }
          return M(yt, 2);
        },
        "%w": function(et) {
          return et.zi;
        },
        "%W": function(et) {
          return M(Math.floor((et.Ni + 7 - (et.zi + 6) % 7) / 7), 2);
        },
        "%y": function(et) {
          return (et.Oi + 1900).toString().substring(2);
        },
        "%Y": function(et) {
          return et.Oi + 1900;
        },
        "%z": function(et) {
          et = et.Yk;
          var yt = 0 <= et;
          return et = Math.abs(et) / 60, (yt ? "+" : "-") + ("0000" + (et / 60 * 100 + et % 60)).slice(-4);
        },
        "%Z": function(et) {
          return et.al;
        },
        "%%": function() {
          return "%";
        }
      }, f = f.replace(/%%/g, "\0\0");
      for (ht in lt)
        f.includes(ht) && (f = f.replace(new RegExp(ht, "g"), lt[ht](p)));
      return f = f.replace(/\0\0/g, "%"), ht = $i(f, !1), ht.length > c ? 0 : (J.set(ht, a), ht.length - 1);
    }
    function sf(a, c, f, p) {
      var v = { string: (lt) => {
        var ht = 0;
        if (lt != null && lt !== 0) {
          var Tt = (lt.length << 2) + 1;
          ht = nc(Tt), st(lt, A, ht, Tt);
        }
        return ht;
      }, array: (lt) => {
        var ht = nc(lt.length);
        return J.set(lt, ht), ht;
      } };
      a = e["_" + a];
      var M = [], L = 0;
      if (p)
        for (var H = 0; H < p.length; H++) {
          var Q = v[f[H]];
          Q ? (L === 0 && (L = au()), M[H] = Q(p[H])) : M[H] = p[H];
        }
      return f = a.apply(null, M), f = function(lt) {
        return L !== 0 && lu(L), c === "string" ? q(lt) : c === "boolean" ? !!lt : lt;
      }(f);
    }
    function Ka(a, c, f, p) {
      f = f || [];
      var v = f.every((M) => M === "number" || M === "boolean");
      return c !== "string" && v && !p ? e["_" + a] : function() {
        return sf(a, c, f, arguments);
      };
    }
    function Sp(a, c, f, p) {
      a || (a = this), this.parent = a, this.Di = a.Di, this.Xi = null, this.id = Ti++, this.name = c, this.mode = f, this.hi = {}, this.ii = {}, this.rdev = p;
    }
    Object.defineProperties(Sp.prototype, { read: { get: function() {
      return (this.mode & 365) === 365;
    }, set: function(a) {
      a ? this.mode |= 365 : this.mode &= -366;
    } }, write: { get: function() {
      return (this.mode & 146) === 146;
    }, set: function(a) {
      a ? this.mode |= 146 : this.mode &= -147;
    } }, Fk: { get: function() {
      return (this.mode & 61440) === 16384;
    } }, Ek: { get: function() {
      return (this.mode & 61440) === 8192;
    } } }), ii(), $n = Array(4096), Hl(Qt, "/"), w("/tmp", 16895, 0), w("/home", 16895, 0), w("/home/web_user", 16895, 0), (() => {
      w("/dev", 16895, 0), Ha(259, { read: () => 0, write: (c, f, p, v) => v }), S("/dev/null", 259), ai(1280, zs), ai(1536, Fn), S("/dev/tty", 1280), S("/dev/tty1", 1536);
      var a = sn();
      wn("/dev", "random", a), wn("/dev", "urandom", a), w("/dev/shm", 16895, 0), w("/dev/shm/tmp", 16895, 0);
    })(), (() => {
      w("/proc", 16895, 0);
      var a = w("/proc/self", 16895, 0);
      w("/proc/self/fd", 16895, 0), Hl({ Di: () => {
        var c = Uh(a, "fd", 16895, 73);
        return c.hi = { lookup: (f, p) => {
          var v = qi[+p];
          if (!v)
            throw new Ft(8);
          return f = { parent: null, Di: { dk: "fake" }, hi: { readlink: () => v.path } }, f.parent = f;
        } }, c;
      } }, "/proc/self/fd");
    })(), e.FS_createPath = Ni, e.FS_createDataFile = cs, e.FS_createPreloadedFile = br, e.FS_unlink = F, e.FS_createLazyFile = qn, e.FS_createDevice = wn, Ye = e.InternalError = ue("InternalError");
    for (var Pp = Array(256), ou = 0; 256 > ou; ++ou)
      Pp[ou] = String.fromCharCode(ou);
    Gh = Pp, Ua = e.BindingError = ue("BindingError"), yo.prototype.isAliasOf = function(a) {
      if (!(this instanceof yo && a instanceof yo))
        return !1;
      var c = this.fi.ni.ji, f = this.fi.li, p = a.fi.ni.ji;
      for (a = a.fi.li; c.xi; )
        f = c.$i(f), c = c.xi;
      for (; p.xi; )
        a = p.$i(a), p = p.xi;
      return c === p && f === a;
    }, yo.prototype.clone = function() {
      if (this.fi.li || Od(this), this.fi.Yi)
        return this.fi.count.value += 1, this;
      var a = Gl, c = Object, f = c.create, p = Object.getPrototypeOf(this), v = this.fi;
      return a = a(f.call(c, p, { fi: { value: { count: v.count, Ri: v.Ri, Yi: v.Yi, li: v.li, ni: v.ni, ri: v.ri, wi: v.wi } } })), a.fi.count.value += 1, a.fi.Ri = !1, a;
    }, yo.prototype.delete = function() {
      this.fi.li || Od(this), this.fi.Ri && !this.fi.Yi && Ve("Object already scheduled for deletion"), Wg(this), Gg(this.fi), this.fi.Yi || (this.fi.ri = void 0, this.fi.li = void 0);
    }, yo.prototype.isDeleted = function() {
      return !this.fi.li;
    }, yo.prototype.deleteLater = function() {
      return this.fi.li || Od(this), this.fi.Ri && !this.fi.Yi && Ve("Object already scheduled for deletion"), Ul.push(this), Ul.length === 1 && jl && jl(Ld), this.fi.Ri = !0, this;
    }, e.getInheritedInstanceCount = function() {
      return Object.keys(Wl).length;
    }, e.getLiveInheritedInstances = function() {
      var a = [], c;
      for (c in Wl)
        Wl.hasOwnProperty(c) && a.push(Wl[c]);
      return a;
    }, e.flushPendingDeletes = Ld, e.setDelayFunction = function(a) {
      jl = a, Ul.length && jl && jl(Ld);
    }, Ir.prototype.xk = function(a) {
      return this.gk && (a = this.gk(a)), a;
    }, Ir.prototype.Vj = function(a) {
      this.vi && this.vi(a);
    }, Ir.prototype.argPackAdvance = 8, Ir.prototype.readValueFromPointer = $e, Ir.prototype.deleteObject = function(a) {
      a !== null && a.delete();
    }, Ir.prototype.fromWireType = function(a) {
      function c() {
        return this.ij ? $h(this.ji.Ki, { ni: this.Kk, li: f, wi: this, ri: a }) : $h(this.ji.Ki, { ni: this, li: a });
      }
      var f = this.xk(a);
      if (!f)
        return this.Vj(a), null;
      var p = hw(this.ji, f);
      if (p !== void 0)
        return p.fi.count.value === 0 ? (p.fi.li = f, p.fi.ri = a, p.clone()) : (p = p.clone(), this.Vj(a), p);
      if (p = this.ji.wk(f), p = qg[p], !p)
        return c.call(this);
      p = this.hj ? p.rk : p.pointerType;
      var v = $g(f, this.ji, p.ji);
      return v === null ? c.call(this) : this.ij ? $h(p.ji.Ki, { ni: p, li: v, wi: this, ri: a }) : $h(
        p.ji.Ki,
        { ni: p, li: v }
      );
    }, Jg = e.UnboundTypeError = ue("UnboundTypeError"), e.count_emval_handles = function() {
      for (var a = 0, c = 5; c < tr.length; ++c)
        tr[c] !== void 0 && ++a;
      return a;
    }, e.get_first_emval = function() {
      for (var a = 5; a < tr.length; ++a)
        if (tr[a] !== void 0)
          return tr[a];
      return null;
    }, e.requestFullscreen = function(a, c) {
      Fw(a, c);
    }, e.requestAnimationFrame = function(a) {
      Gd(a);
    }, e.setCanvasSize = function(a, c, f) {
      Yl(e.canvas, a, c), f || qd();
    }, e.pauseMainLoop = function() {
      Zo = null, ja++;
    }, e.resumeMainLoop = function() {
      ja++;
      var a = Yh, c = Zh, f = Kl;
      Kl = null, Aw(f), Ew(a, c), Zo();
    }, e.getUserMedia = function() {
      window.getUserMedia || (window.getUserMedia = navigator.getUserMedia || navigator.mozGetUserMedia), window.getUserMedia(void 0);
    }, e.createContext = function(a, c, f, p) {
      return Lw(a, c, f, p);
    };
    for (var N, Ps = 0; 32 > Ps; ++Ps)
      Qo.push(Array(Ps));
    var Yw = new Float32Array(288);
    for (Ps = 0; 288 > Ps; ++Ps)
      ds[Ps] = Yw.subarray(0, Ps + 1);
    var Zw = new Int32Array(288);
    for (Ps = 0; 288 > Ps; ++Ps)
      ec[Ps] = Zw.subarray(0, Ps + 1);
    var Qw = {
      Ka: function(a, c, f) {
        xt[a] = void 0;
        try {
          var p = [new Float32Array(c), new Uint16Array(f)];
        } catch {
          return 0;
        }
        return xt[a] = p, 1;
      },
      Ja: function(a, c, f, p, v) {
        xt[a] = void 0, f >>= 2, v >>= 1;
        try {
          var M = [new Float32Array(X.subarray(f, f + c)), new Uint16Array(wt.subarray(v, v + p))];
        } catch {
          return 0;
        }
        return xt[a] = M, 1;
      },
      La: function(a) {
        xt[a] = void 0;
      },
      Na: function() {
        if (Rt.length)
          return Rt.pop();
        var a = xt.length;
        return xt[a] = void 0, a;
      },
      Ma: function(a) {
        xt[a] = void 0, Rt.push(a);
      },
      Dh: function(a, c) {
        return !c || (a = xt[a], !a) ? 0 : (a = a[1], a.length ? (wt.set(a, c >> 1), 1) : 0);
      },
      Eh: function(a, c) {
        return !c || (a = xt[a], !a) ? 0 : (a = a[0], a.length ? (X.set(a, c >> 2), 1) : 0);
      },
      Gh: function(a) {
        return (a = xt[a]) ? a[1].length : 0;
      },
      Bh: function(a, c) {
        return a = xt[a], a ? (a = a[1], a.length ? (N.bufferSubData(N.ELEMENT_ARRAY_BUFFER, c, a), 1) : 0) : 0;
      },
      zh: function(a, c, f, p) {
        if (a = xt[a], !a)
          return 0;
        a = a[1];
        try {
          var v = new Uint8Array(a.buffer, c, f);
        } catch {
          return 0;
        }
        return v.length ? (N.bufferSubData(N.ELEMENT_ARRAY_BUFFER, p, v), 1) : 0;
      },
      Ch: function(a, c) {
        return a = xt[a], a ? (a = a[0], a.length ? (N.bufferSubData(N.ARRAY_BUFFER, c, a), 1) : 0) : 0;
      },
      Ah: function(a, c, f, p) {
        if (a = xt[a], !a)
          return 0;
        a = a[0];
        try {
          var v = new Uint8Array(a.buffer, c, f);
        } catch {
          return 0;
        }
        return v.length ? (N.bufferSubData(N.ARRAY_BUFFER, p, v), 1) : 0;
      },
      Fh: function(a, c, f, p) {
        return a = xt[a], a ? (a = a[0], a.length && c < a.length && a.length - c >= f ? (p >>= 2, a.set(X.subarray(p, p + f), c), 1) : 0) : 0;
      },
      Hh: function(a) {
        return (a = xt[a]) ? a[0].length : 0;
      },
      wb: function(a, c) {
        0 > a && (a += 4294967296), 0 > c && (c += 4294967296), e.ki(
          "announce_model",
          a,
          c
        );
      },
      Y: function(a, c, f) {
        var p = e.$$facade;
        if (p) {
          var v = e.callAfterMap, M = ++v.index, L = function(H) {
            p === e.$$facade && sf("callFuncWrapper", null, ["number", "number", "number"], [a, !H, c]), delete v.indexedWrappers[M];
          };
          v.indexedWrappers[M] = L, 0 <= f ? cp(L, f) : Vw(L);
        }
      },
      Td: function() {
        for (var a = e.callAfterMap, c = a.indexedWrappers, f = Object.keys(c), p = 0; p < f.length; ++p)
          c[f[p]](!0);
        a.indexedWrappers = {}, a.index = 0;
      },
      vb: function(a, c) {
        e.ki("capping_idle", !!a, c);
      },
      pb: function(a) {
        0 > a && (a += 4294967296), e.ki("data_access_attached", a);
      },
      ob: function() {
        e.ki("first_instance");
      },
      X: function(a) {
        e.ki(q(a));
      },
      ha: function(a, c) {
        c = q(c);
        try {
          var f = JSON.parse(c);
        } catch {
          f = c;
        }
        e.ki(q(a), f);
      },
      ub: function(a, c, f) {
        0 > a && (a += 4294967296), 0 > c && (c += 4294967296), 0 > f && (f += 4294967296), e.ki("inclusion", a, c, f);
      },
      nc: function(a, c, f, p) {
        e.ki("meta_data", a, c, e.HEAPU8.subarray(f, f + p));
      },
      tb: function(a, c) {
        0 > a && (a += 4294967296), c = q(c), e.ki("missing_model", a, c);
      },
      Cb: function(a) {
        e.ki("network_receive_data", a);
      },
      nb: function(a) {
        e.ki("post_draw_json", "{" + q(a) + "}");
      },
      qb: function(a, c) {
        0 > a && (a += 4294967296), 0 > c && (c += 4294967296), e.ki("priority_meta_data_sent", a, c);
      },
      rb: function(a, c, f, p) {
        0 > a && (a += 4294967296), 0 > c && (c += 4294967296), 0 > f && (f += 4294967296), 0 > p && (p += 4294967296), e.ki("remap_inclusion", a, c, f, p);
      },
      sb: function(a, c, f) {
        0 > a && (a += 4294967296), 0 > c && (c += 4294967296), 0 > f && (f += 4294967296), e.ki("remap_model", a, c, f);
      },
      h: function(a, c) {
        e.tj && (a = e.HEAP8.buffer.slice(a, c), e.tj.Ok(a));
      },
      cc: function() {
        e.ki("session_started");
      },
      xd: function() {
        e.$$setReady();
      },
      l: function(a, c, f, p) {
        Ne("Assertion failed: " + q(a) + ", at: " + [
          c ? q(c) : "unknown filename",
          f,
          p ? q(p) : "unknown function"
        ]);
      },
      ua: function(a, c, f) {
        ce = f;
        try {
          var p = ni(a);
          switch (c) {
            case 0:
              var v = Ae();
              return 0 > v ? -28 : zl(p, v).fd;
            case 1:
            case 2:
              return 0;
            case 3:
              return p.flags;
            case 4:
              return v = Ae(), p.flags |= v, 0;
            case 5:
              return v = Ae(), R[v + 0 >> 1] = 2, 0;
            case 6:
            case 7:
              return 0;
            case 16:
            case 8:
              return -28;
            case 9:
              return z[kp() >> 2] = 28, -1;
            default:
              return -28;
          }
        } catch (M) {
          if (typeof Xi > "u" || !(M instanceof Ft))
            throw M;
          return -M.Gi;
        }
      },
      Gb: function(a, c, f) {
        ce = f;
        try {
          var p = ni(a);
          switch (c) {
            case 21509:
            case 21505:
              return p.tty ? 0 : -59;
            case 21510:
            case 21511:
            case 21512:
            case 21506:
            case 21507:
            case 21508:
              return p.tty ? 0 : -59;
            case 21519:
              if (!p.tty)
                return -59;
              var v = Ae();
              return z[v >> 2] = 0;
            case 21520:
              return p.tty ? -28 : -59;
            case 21531:
              if (a = v = Ae(), !p.ii.Dk)
                throw new Ft(59);
              return p.ii.Dk(p, c, a);
            case 21523:
              return p.tty ? 0 : -59;
            case 21524:
              return p.tty ? 0 : -59;
            default:
              return -28;
          }
        } catch (M) {
          if (typeof Xi > "u" || !(M instanceof Ft))
            throw M;
          return -M.Gi;
        }
      },
      Hb: function(a, c, f, p) {
        ce = p;
        try {
          c = q(c);
          var v = c;
          if (v.charAt(0) === "/")
            c = v;
          else {
            var M = a === -100 ? "/" : ni(a).path;
            if (v.length == 0)
              throw new Ft(44);
            c = Ht(M + "/" + v);
          }
          var L = p ? Ae() : 0;
          return pt(c, f, L).fd;
        } catch (H) {
          if (typeof Xi > "u" || !(H instanceof Ft))
            throw H;
          return -H.Gi;
        }
      },
      w: function(a) {
        var c = Di[a];
        delete Di[a];
        var f = c.elements, p = f.length, v = f.map(function(H) {
          return H.zj;
        }).concat(f.map(function(H) {
          return H.Lj;
        })), M = c.Zi, L = c.vi;
        mi([a], v, function(H) {
          return f.forEach((Q, lt) => {
            var ht = H[lt], Tt = Q.Si, Wt = Q.yj, et = H[lt + p], yt = Q.Kj, qt = Q.Mj;
            Q.read = (Ce) => ht.fromWireType(Tt(Wt, Ce)), Q.write = (Ce, je) => {
              var Oi = [];
              yt(qt, Ce, et.toWireType(Oi, je)), Pi(Oi);
            };
          }), [{
            name: c.name,
            fromWireType: function(Q) {
              for (var lt = Array(p), ht = 0; ht < p; ++ht)
                lt[ht] = f[ht].read(Q);
              return L(Q), lt;
            },
            toWireType: function(Q, lt) {
              if (p !== lt.length)
                throw new TypeError("Incorrect number of tuple elements for " + c.name + ": expected=" + p + ", actual=" + lt.length);
              for (var ht = M(), Tt = 0; Tt < p; ++Tt)
                f[Tt].write(ht, lt[Tt]);
              return Q !== null && Q.push(L, ht), ht;
            },
            argPackAdvance: 8,
            readValueFromPointer: $e,
            si: L
          }];
        });
      },
      L: function(a) {
        var c = Us[a];
        delete Us[a];
        var f = c.Zi, p = c.vi, v = c.Yj, M = v.map((L) => L.zj).concat(v.map((L) => L.Lj));
        mi([a], M, (L) => {
          var H = {};
          return v.forEach((Q, lt) => {
            var ht = L[lt], Tt = Q.Si, Wt = Q.yj, et = L[lt + v.length], yt = Q.Kj, qt = Q.Mj;
            H[Q.vk] = { read: (Ce) => ht.fromWireType(Tt(Wt, Ce)), write: (Ce, je) => {
              var Oi = [];
              yt(qt, Ce, et.toWireType(Oi, je)), Pi(Oi);
            } };
          }), [{ name: c.name, fromWireType: function(Q) {
            var lt = {}, ht;
            for (ht in H)
              lt[ht] = H[ht].read(Q);
            return p(Q), lt;
          }, toWireType: function(Q, lt) {
            for (var ht in H)
              if (!(ht in lt))
                throw new TypeError('Missing field:  "' + ht + '"');
            var Tt = f();
            for (ht in H)
              H[ht].write(Tt, lt[ht]);
            return Q !== null && Q.push(p, Tt), Tt;
          }, argPackAdvance: 8, readValueFromPointer: $e, si: p }];
        });
      },
      yb: function() {
      },
      Tg: function(a, c, f, p, v) {
        var M = Yo(f);
        c = hn(c), xr(a, { name: c, fromWireType: function(L) {
          return !!L;
        }, toWireType: function(L, H) {
          return H ? p : v;
        }, argPackAdvance: 8, readValueFromPointer: function(L) {
          if (f === 1)
            var H = J;
          else if (f === 2)
            H = R;
          else if (f === 4)
            H = z;
          else
            throw new TypeError("Unknown boolean type size: " + c);
          return this.fromWireType(H[L >> M]);
        }, si: null });
      },
      _: function(a, c, f, p, v, M, L, H, Q, lt, ht, Tt, Wt) {
        ht = hn(ht), M = un(v, M), H && (H = un(L, H)), lt && (lt = un(Q, lt)), Wt = un(Tt, Wt);
        var et = Ot(ht);
        Xg(et, function() {
          $l(
            "Cannot construct " + ht + " due to unbound types",
            [p]
          );
        }), mi([a, c, f], p ? [p] : [], function(yt) {
          if (yt = yt[0], p)
            var qt = yt.ji, Ce = qt.Ki;
          else
            Ce = yo.prototype;
          yt = jt(et, function() {
            if (Object.getPrototypeOf(this) !== je)
              throw new Ua("Use 'new' to construct " + ht);
            if (Oi.Ii === void 0)
              throw new Ua(ht + " has no accessible constructor");
            var Nt = Oi.Ii[arguments.length];
            if (Nt === void 0)
              throw new Ua("Tried to invoke ctor of " + ht + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(Oi.Ii).toString() + ") parameters instead!");
            return Nt.apply(this, arguments);
          });
          var je = Object.create(Ce, { constructor: { value: yt } });
          yt.prototype = je;
          var Oi = new uw(ht, yt, je, Wt, qt, M, H, lt);
          qt = new Ir(ht, Oi, !0, !1, !1), Ce = new Ir(ht + "*", Oi, !1, !1, !1);
          var Bt = new Ir(ht + " const*", Oi, !1, !0, !1);
          return qg[a] = { pointerType: Ce, rk: Bt }, pw(et, yt), [qt, Ce, Bt];
        });
      },
      b: function(a, c, f, p, v, M, L) {
        var H = tp(f, p);
        c = hn(c), M = un(v, M), mi([], [a], function(Q) {
          function lt() {
            $l("Cannot call " + ht + " due to unbound types", H);
          }
          Q = Q[0];
          var ht = Q.name + "." + c;
          c.startsWith("@@") && (c = Symbol[c.substring(2)]);
          var Tt = Q.ji.constructor;
          return Tt[c] === void 0 ? (lt.uj = f - 1, Tt[c] = lt) : (Kg(Tt, c, ht), Tt[c].Ei[f - 1] = lt), mi([], H, function(Wt) {
            return Wt = [Wt[0], null].concat(Wt.slice(1)), Wt = Qg(ht, Wt, M, L), Tt[c].Ei === void 0 ? (Wt.uj = f - 1, Tt[c] = Wt) : Tt[c].Ei[f - 1] = Wt, [];
          }), [];
        });
      },
      ja: function(a, c, f, p, v, M) {
        0 < c || Ne();
        var L = tp(c, f);
        v = un(p, v), mi([], [a], function(H) {
          H = H[0];
          var Q = "constructor " + H.name;
          if (H.ji.Ii === void 0 && (H.ji.Ii = []), H.ji.Ii[c - 1] !== void 0)
            throw new Ua("Cannot register multiple constructors with identical number of parameters (" + (c - 1) + ") for class '" + H.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
          return H.ji.Ii[c - 1] = () => {
            $l("Cannot construct " + H.name + " due to unbound types", L);
          }, mi([], L, function(lt) {
            return lt.splice(1, 0, null), H.ji.Ii[c - 1] = Qg(Q, lt, v, M), [];
          }), [];
        });
      },
      Z: function(a, c, f, p, v, M, L, H, Q, lt) {
        c = hn(c), v = un(p, v), mi([], [a], function(ht) {
          ht = ht[0];
          var Tt = ht.name + "." + c, Wt = { get: function() {
            $l("Cannot access " + Tt + " due to unbound types", [f, L]);
          }, enumerable: !0, configurable: !0 };
          return Wt.set = Q ? () => {
            $l("Cannot access " + Tt + " due to unbound types", [f, L]);
          } : () => {
            Ve(Tt + " is a read-only property");
          }, Object.defineProperty(
            ht.ji.Ki,
            c,
            Wt
          ), mi([], Q ? [f, L] : [f], function(et) {
            var yt = et[0], qt = { get: function() {
              var je = ep(this, ht, Tt + " getter");
              return yt.fromWireType(v(M, je));
            }, enumerable: !0 };
            if (Q) {
              Q = un(H, Q);
              var Ce = et[1];
              qt.set = function(je) {
                var Oi = ep(this, ht, Tt + " setter"), Bt = [];
                Q(lt, Oi, Ce.toWireType(Bt, je)), Pi(Bt);
              };
            }
            return Object.defineProperty(ht.ji.Ki, c, qt), [];
          }), [];
        });
      },
      Sg: function(a, c) {
        c = hn(c), xr(a, { name: c, fromWireType: function(f) {
          var p = er(f);
          return Bd(f), p;
        }, toWireType: function(f, p) {
          return hs(p);
        }, argPackAdvance: 8, readValueFromPointer: $e, si: null });
      },
      K: function(a, c, f, p) {
        function v() {
        }
        f = Yo(f), c = hn(c), v.values = {}, xr(a, { name: c, constructor: v, fromWireType: function(M) {
          return this.constructor.values[M];
        }, toWireType: function(M, L) {
          return L.value;
        }, argPackAdvance: 8, readValueFromPointer: _w(c, f, p), si: null }), Xg(c, v);
      },
      v: function(a, c, f) {
        var p = ql(a, "enum");
        c = hn(c), a = p.constructor, p = Object.create(p.constructor.prototype, { value: { value: f }, constructor: { value: jt(p.name + "_" + c, function() {
        }) } }), a.values[f] = p, a[c] = p;
      },
      xa: function(a, c, f) {
        f = Yo(f), c = hn(c), xr(a, {
          name: c,
          fromWireType: function(p) {
            return p;
          },
          toWireType: function(p, v) {
            return v;
          },
          argPackAdvance: 8,
          readValueFromPointer: yw(c, f),
          si: null
        });
      },
      P: function(a, c, f, p, v) {
        c = hn(c), v === -1 && (v = 4294967295), v = Yo(f);
        var M = (H) => H;
        if (p === 0) {
          var L = 32 - 8 * f;
          M = (H) => H << L >>> L;
        }
        f = c.includes("unsigned") ? function(H, Q) {
          return Q >>> 0;
        } : function(H, Q) {
          return Q;
        }, xr(a, { name: c, fromWireType: M, toWireType: f, argPackAdvance: 8, readValueFromPointer: ww(c, v, p !== 0), si: null });
      },
      D: function(a, c, f) {
        function p(M) {
          M >>= 2;
          var L = St;
          return new v(U, L[M + 1], L[M]);
        }
        var v = [
          Int8Array,
          Uint8Array,
          Int16Array,
          Uint16Array,
          Int32Array,
          Uint32Array,
          Float32Array,
          Float64Array
        ][c];
        f = hn(f), xr(a, { name: f, fromWireType: p, argPackAdvance: 8, readValueFromPointer: p }, { Bk: !0 });
      },
      ia: function(a, c, f, p, v, M, L, H, Q, lt, ht, Tt) {
        f = hn(f), M = un(v, M), H = un(L, H), lt = un(Q, lt), Tt = un(ht, Tt), mi([a], [c], function(Wt) {
          return Wt = Wt[0], [new Ir(f, Wt.ji, !1, !1, !0, Wt, p, M, H, lt, Tt)];
        });
      },
      wa: function(a, c) {
        c = hn(c);
        var f = c === "std::string";
        xr(a, { name: c, fromWireType: function(p) {
          var v = St[p >> 2], M = p + 4;
          if (f)
            for (var L = M, H = 0; H <= v; ++H) {
              var Q = M + H;
              if (H == v || A[Q] == 0) {
                if (L = q(L, Q - L), lt === void 0)
                  var lt = L;
                else
                  lt += "\0", lt += L;
                L = Q + 1;
              }
            }
          else {
            for (lt = Array(v), H = 0; H < v; ++H)
              lt[H] = String.fromCharCode(A[M + H]);
            lt = lt.join("");
          }
          return Pr(p), lt;
        }, toWireType: function(p, v) {
          v instanceof ArrayBuffer && (v = new Uint8Array(v));
          var M = typeof v == "string";
          M || v instanceof Uint8Array || v instanceof Uint8ClampedArray || v instanceof Int8Array || Ve("Cannot pass non-string to std::string");
          var L = f && M ? dt(v) : v.length, H = ic(4 + L + 1), Q = H + 4;
          if (St[H >> 2] = L, f && M)
            st(v, A, Q, L + 1);
          else if (M)
            for (M = 0; M < L; ++M) {
              var lt = v.charCodeAt(M);
              255 < lt && (Pr(Q), Ve("String has UTF-16 code units that do not fit in 8 bits")), A[Q + M] = lt;
            }
          else
            for (M = 0; M < L; ++M)
              A[Q + M] = v[M];
          return p !== null && p.push(Pr, H), H;
        }, argPackAdvance: 8, readValueFromPointer: $e, si: function(p) {
          Pr(p);
        } });
      },
      ka: function(a, c, f) {
        if (f = hn(f), c === 2)
          var p = vw, v = bw, M = xw, L = () => wt, H = 1;
        else
          c === 4 && (p = Iw, v = Cw, M = Sw, L = () => St, H = 2);
        xr(a, { name: f, fromWireType: function(Q) {
          for (var lt = St[Q >> 2], ht = L(), Tt, Wt = Q + 4, et = 0; et <= lt; ++et) {
            var yt = Q + 4 + et * c;
            (et == lt || ht[yt >> H] == 0) && (Wt = p(Wt, yt - Wt), Tt === void 0 ? Tt = Wt : (Tt += "\0", Tt += Wt), Wt = yt + c);
          }
          return Pr(Q), Tt;
        }, toWireType: function(Q, lt) {
          typeof lt != "string" && Ve("Cannot pass non-string to C++ string type " + f);
          var ht = M(lt), Tt = ic(4 + ht + c);
          return St[Tt >> 2] = ht >> H, v(lt, Tt + 4, ht + c), Q !== null && Q.push(Pr, Tt), Tt;
        }, argPackAdvance: 8, readValueFromPointer: $e, si: function(Q) {
          Pr(Q);
        } });
      },
      x: function(a, c, f, p, v, M) {
        Di[a] = { name: hn(c), Zi: un(f, p), vi: un(v, M), elements: [] };
      },
      i: function(a, c, f, p, v, M, L, H, Q) {
        Di[a].elements.push({ zj: c, Si: un(f, p), yj: v, Lj: M, Kj: un(L, H), Mj: Q });
      },
      M: function(a, c, f, p, v, M) {
        Us[a] = { name: hn(c), Zi: un(f, p), vi: un(
          v,
          M
        ), Yj: [] };
      },
      z: function(a, c, f, p, v, M, L, H, Q, lt) {
        Us[a].Yj.push({ vk: hn(c), zj: f, Si: un(p, v), yj: M, Lj: L, Kj: un(H, Q), Mj: lt });
      },
      Ug: function(a, c) {
        c = hn(c), xr(a, { Gk: !0, name: c, argPackAdvance: 0, fromWireType: function() {
        }, toWireType: function() {
        } });
      },
      Vg: function(a) {
        do {
          var c = St[a >> 2];
          a += 4;
          var f = St[a >> 2];
          a += 4;
          var p = St[a >> 2];
          a += 4, c = q(c), Ni("/", Ue(c)), cs(c, null, J.subarray(p, p + f), !0, !0, !0);
        } while (St[a >> 2]);
      },
      Db: function() {
        return !0;
      },
      p: function(a, c, f) {
        a = er(a), c = ql(c, "emval::as");
        var p = [], v = hs(p);
        return St[f >> 2] = v, c.toWireType(
          p,
          a
        );
      },
      j: function(a, c, f, p) {
        a = er(a), f = np(c, f);
        for (var v = Array(c), M = 0; M < c; ++M) {
          var L = f[M];
          v[M] = L.readValueFromPointer(p), p += L.argPackAdvance;
        }
        return a = a.apply(void 0, v), hs(a);
      },
      Q: function(a, c, f, p, v) {
        a = zd[a], c = er(c), f = Kh(f);
        var M = [];
        return St[p >> 2] = hs(M), a(c, f, M, v);
      },
      a: Bd,
      J: function(a) {
        return a === 0 ? hs(sp()) : (a = Kh(a), hs(sp()[a]));
      },
      R: function(a, c) {
        var f = np(a, c), p = f[0];
        c = p.name + "_$" + f.slice(1).map(function(ht) {
          return ht.name;
        }).join("_") + "$";
        var v = rp[c];
        if (v !== void 0)
          return v;
        v = ["retType"];
        for (var M = [p], L = "", H = 0; H < a - 1; ++H)
          L += (H !== 0 ? ", " : "") + "arg" + H, v.push("argType" + H), M.push(f[1 + H]);
        var Q = "return function " + Ot("methodCaller_" + c) + `(handle, name, destructors, args) {
`, lt = 0;
        for (H = 0; H < a - 1; ++H)
          Q += "    var arg" + H + " = argType" + H + ".readValueFromPointer(args" + (lt ? "+" + lt : "") + `);
`, lt += f[H + 1].argPackAdvance;
        for (Q += "    var rv = handle[name](" + L + `);
`, H = 0; H < a - 1; ++H)
          f[H + 1].deleteObject && (Q += "    argType" + H + ".deleteObject(arg" + H + `);
`);
        return p.Gk || (Q += `    return retType.toWireType(destructors, rv);
`), v.push(Q + `};
`), a = Zg(v).apply(null, M), v = kw(a), rp[c] = v;
      },
      aa: function(a) {
        return a = Kh(a), hs(e[a]);
      },
      o: function(a, c) {
        return a = er(a), c = er(c), hs(a[c]);
      },
      d: function(a) {
        4 < a && (tr[a].Gj += 1);
      },
      S: function(a, c, f, p) {
        a = er(a);
        var v = op[c];
        return v || (v = Mw(c), op[c] = v), v(a, f, p);
      },
      u: function() {
        return hs([]);
      },
      f: function(a) {
        return hs(Kh(a));
      },
      B: function() {
        return hs({});
      },
      m: function(a) {
        var c = er(a);
        Pi(c), Bd(a);
      },
      g: function(a, c, f) {
        a = er(a), c = er(c), f = er(f), a[c] = f;
      },
      e: function(a, c) {
        return a = ql(a, "_emval_take_value"), a = a.readValueFromPointer(c), hs(a);
      },
      c: function() {
        Ne("");
      },
      da: function(a, c, f) {
        Hd.length = 0;
        var p;
        for (f >>= 2; p = A[c++]; )
          f += p != 105 & f, Hd.push(p == 105 ? z[f] : At[f++ >> 1]), ++f;
        return bt[a].apply(null, Hd);
      },
      Id: function(a, c, f) {
        var p = e.canvas;
        z[a >> 2] = p.width, z[c >> 2] = p.height, z[f >> 2] = Wa ? 1 : 0;
      },
      A: Xh,
      yg: function(a) {
        N.activeTexture(a);
      },
      xg: function(a, c) {
        N.attachShader(De[a], Ji[c]);
      },
      Bd: function(a, c) {
        N.beginQuery(a, Yi[c]);
      },
      Og: function(a, c) {
        N.pi.beginQueryEXT(a, Yi[c]);
      },
      hd: function(a) {
        N.beginTransformFeedback(a);
      },
      wg: function(a, c, f) {
        N.bindAttribLocation(De[a], c, q(f));
      },
      vg: function(a, c) {
        a == 35051 ? N.Ji = c : a == 35052 && (N.oi = c), N.bindBuffer(a, ir[c]);
      },
      ed: function(a, c, f) {
        N.bindBufferBase(a, c, ir[f]);
      },
      fd: function(a, c, f, p, v) {
        N.bindBufferRange(a, c, ir[f], p, v);
      },
      ug: function(a, c) {
        N.bindFramebuffer(a, Xr[c]);
      },
      tg: function(a, c) {
        N.bindRenderbuffer(a, nr[c]);
      },
      ic: function(a, c) {
        N.bindSampler(a, sr[c]);
      },
      sg: function(a, c) {
        N.bindTexture(a, js[c]);
      },
      $b: function(a, c) {
        N.bindTransformFeedback(a, Zl[c]);
      },
      md: function(a) {
        N.bindVertexArray(Cr[a]);
      },
      Gg: function(a) {
        N.bindVertexArray(Cr[a]);
      },
      rg: function(a, c, f, p) {
        N.blendColor(a, c, f, p);
      },
      qg: function(a) {
        N.blendEquation(a);
      },
      pg: function(a, c) {
        N.blendEquationSeparate(a, c);
      },
      og: function(a, c) {
        N.blendFunc(a, c);
      },
      ng: function(a, c, f, p) {
        N.blendFuncSeparate(a, c, f, p);
      },
      pd: function(a, c, f, p, v, M, L, H, Q, lt) {
        N.blitFramebuffer(a, c, f, p, v, M, L, H, Q, lt);
      },
      mg: function(a, c, f, p) {
        2 <= ye.version ? f && c ? N.bufferData(a, A, p, f, c) : N.bufferData(a, c, p) : N.bufferData(a, f ? A.subarray(f, f + c) : c, p);
      },
      lg: function(a, c, f, p) {
        2 <= ye.version ? f && N.bufferSubData(a, c, A, p, f) : N.bufferSubData(a, c, A.subarray(p, p + f));
      },
      kg: function(a) {
        return N.checkFramebufferStatus(a);
      },
      jg: function(a) {
        N.clear(a);
      },
      Hc: function(a, c, f, p) {
        N.clearBufferfi(a, c, f, p);
      },
      Ic: function(a, c, f) {
        N.clearBufferfv(a, c, X, f >> 2);
      },
      Lc: function(a, c, f) {
        N.clearBufferiv(a, c, z, f >> 2);
      },
      Kc: function(a, c, f) {
        N.clearBufferuiv(a, c, St, f >> 2);
      },
      ig: function(a, c, f, p) {
        N.clearColor(a, c, f, p);
      },
      hg: function(a) {
        N.clearDepth(a);
      },
      gg: function(a) {
        N.clearStencil(a);
      },
      sc: function(a, c, f, p) {
        return N.clientWaitSync(vo[a], c, (f >>> 0) + 4294967296 * p);
      },
      fg: function(a, c, f, p) {
        N.colorMask(!!a, !!c, !!f, !!p);
      },
      eg: function(a) {
        N.compileShader(Ji[a]);
      },
      dg: function(a, c, f, p, v, M, L, H) {
        2 <= ye.version ? N.oi || !L ? N.compressedTexImage2D(a, c, f, p, v, M, L, H) : N.compressedTexImage2D(a, c, f, p, v, M, A, H, L) : N.compressedTexImage2D(a, c, f, p, v, M, H ? A.subarray(H, H + L) : null);
      },
      Gd: function(a, c, f, p, v, M, L, H, Q) {
        N.oi ? N.compressedTexImage3D(a, c, f, p, v, M, L, H, Q) : N.compressedTexImage3D(a, c, f, p, v, M, L, A, Q, H);
      },
      cg: function(a, c, f, p, v, M, L, H, Q) {
        2 <= ye.version ? N.oi || !H ? N.compressedTexSubImage2D(a, c, f, p, v, M, L, H, Q) : N.compressedTexSubImage2D(a, c, f, p, v, M, L, A, Q, H) : N.compressedTexSubImage2D(a, c, f, p, v, M, L, Q ? A.subarray(
          Q,
          Q + H
        ) : null);
      },
      Fd: function(a, c, f, p, v, M, L, H, Q, lt, ht) {
        N.oi ? N.compressedTexSubImage3D(a, c, f, p, v, M, L, H, Q, lt, ht) : N.compressedTexSubImage3D(a, c, f, p, v, M, L, H, Q, A, ht, lt);
      },
      Fc: function(a, c, f, p, v) {
        N.copyBufferSubData(a, c, f, p, v);
      },
      bg: function(a, c, f, p, v, M, L, H) {
        N.copyTexImage2D(a, c, f, p, v, M, L, H);
      },
      ag: function(a, c, f, p, v, M, L, H) {
        N.copyTexSubImage2D(a, c, f, p, v, M, L, H);
      },
      Hd: function(a, c, f, p, v, M, L, H, Q) {
        N.copyTexSubImage3D(a, c, f, p, v, M, L, H, Q);
      },
      $f: function() {
        var a = bo(De), c = N.createProgram();
        return c.name = a, c.Ci = c.Ai = c.Bi = 0, c.rj = 1, De[a] = c, a;
      },
      _f: function(a) {
        var c = bo(Ji);
        return Ji[c] = N.createShader(a), c;
      },
      Zf: function(a) {
        N.cullFace(a);
      },
      Yf: function(a, c) {
        for (var f = 0; f < a; f++) {
          var p = z[c + 4 * f >> 2], v = ir[p];
          v && (N.deleteBuffer(v), v.name = 0, ir[p] = null, p == N.Ji && (N.Ji = 0), p == N.oi && (N.oi = 0));
        }
      },
      Xf: function(a, c) {
        for (var f = 0; f < a; ++f) {
          var p = z[c + 4 * f >> 2], v = Xr[p];
          v && (N.deleteFramebuffer(v), v.name = 0, Xr[p] = null);
        }
      },
      Wf: function(a) {
        if (a) {
          var c = De[a];
          c ? (N.deleteProgram(c), c.name = 0, De[a] = null) : Kt(1281);
        }
      },
      Dd: function(a, c) {
        for (var f = 0; f < a; f++) {
          var p = z[c + 4 * f >> 2], v = Yi[p];
          v && (N.deleteQuery(v), Yi[p] = null);
        }
      },
      Qg: function(a, c) {
        for (var f = 0; f < a; f++) {
          var p = z[c + 4 * f >> 2], v = Yi[p];
          v && (N.pi.deleteQueryEXT(v), Yi[p] = null);
        }
      },
      Vf: function(a, c) {
        for (var f = 0; f < a; f++) {
          var p = z[c + 4 * f >> 2], v = nr[p];
          v && (N.deleteRenderbuffer(v), v.name = 0, nr[p] = null);
        }
      },
      kc: function(a, c) {
        for (var f = 0; f < a; f++) {
          var p = z[c + 4 * f >> 2], v = sr[p];
          v && (N.deleteSampler(v), v.name = 0, sr[p] = null);
        }
      },
      Uf: function(a) {
        if (a) {
          var c = Ji[a];
          c ? (N.deleteShader(c), Ji[a] = null) : Kt(1281);
        }
      },
      tc: function(a) {
        if (a) {
          var c = vo[a];
          c ? (N.deleteSync(c), c.name = 0, vo[a] = null) : Kt(1281);
        }
      },
      Tf: function(a, c) {
        for (var f = 0; f < a; f++) {
          var p = z[c + 4 * f >> 2], v = js[p];
          v && (N.deleteTexture(v), v.name = 0, js[p] = null);
        }
      },
      _b: function(a, c) {
        for (var f = 0; f < a; f++) {
          var p = z[c + 4 * f >> 2], v = Zl[p];
          v && (N.deleteTransformFeedback(v), v.name = 0, Zl[p] = null);
        }
      },
      ld: function(a, c) {
        for (var f = 0; f < a; f++) {
          var p = z[c + 4 * f >> 2];
          N.deleteVertexArray(Cr[p]), Cr[p] = null;
        }
      },
      Fg: function(a, c) {
        for (var f = 0; f < a; f++) {
          var p = z[c + 4 * f >> 2];
          N.deleteVertexArray(Cr[p]), Cr[p] = null;
        }
      },
      Sf: function(a) {
        N.depthFunc(a);
      },
      Rf: function(a) {
        N.depthMask(!!a);
      },
      Qf: function(a, c) {
        N.depthRange(a, c);
      },
      Pf: function(a, c) {
        N.detachShader(De[a], Ji[c]);
      },
      Of: function(a) {
        N.disable(a);
      },
      Nf: function(a) {
        N.disableVertexAttribArray(a);
      },
      Mf: function(a, c, f) {
        N.drawArrays(a, c, f);
      },
      xc: function(a, c, f, p) {
        N.drawArraysInstanced(a, c, f, p);
      },
      Bg: function(a, c, f, p) {
        N.drawArraysInstanced(a, c, f, p);
      },
      Kb: function(a, c, f, p) {
        N.drawArraysInstanced(a, c, f, p);
      },
      Pd: function(a, c, f, p) {
        N.drawArraysInstanced(a, c, f, p);
      },
      Lb: function(a, c, f, p) {
        N.drawArraysInstanced(a, c, f, p);
      },
      wd: function(a, c) {
        for (var f = Qo[a], p = 0; p < a; p++)
          f[p] = z[c + 4 * p >> 2];
        N.drawBuffers(f);
      },
      Nd: function(a, c) {
        for (var f = Qo[a], p = 0; p < a; p++)
          f[p] = z[c + 4 * p >> 2];
        N.drawBuffers(f);
      },
      Cg: function(a, c) {
        for (var f = Qo[a], p = 0; p < a; p++)
          f[p] = z[c + 4 * p >> 2];
        N.drawBuffers(f);
      },
      Lf: function(a, c, f, p) {
        N.drawElements(a, c, f, p);
      },
      wc: function(a, c, f, p, v) {
        N.drawElementsInstanced(a, c, f, p, v);
      },
      Ag: function(a, c, f, p, v) {
        N.drawElementsInstanced(a, c, f, p, v);
      },
      Ib: function(a, c, f, p, v) {
        N.drawElementsInstanced(a, c, f, p, v);
      },
      Jb: function(a, c, f, p, v) {
        N.drawElementsInstanced(a, c, f, p, v);
      },
      Od: function(a, c, f, p, v) {
        N.drawElementsInstanced(
          a,
          c,
          f,
          p,
          v
        );
      },
      Ld: function(a, c, f, p, v, M) {
        wp(a, p, v, M);
      },
      Kf: function(a) {
        N.enable(a);
      },
      Jf: function(a) {
        N.enableVertexAttribArray(a);
      },
      Ad: function(a) {
        N.endQuery(a);
      },
      Ng: function(a) {
        N.pi.endQueryEXT(a);
      },
      gd: function() {
        N.endTransformFeedback();
      },
      vc: function(a, c) {
        return (a = N.fenceSync(a, c)) ? (c = bo(vo), a.name = c, vo[c] = a, c) : 0;
      },
      If: function() {
        N.finish();
      },
      Hf: function() {
        N.flush();
      },
      Gf: function(a, c, f, p) {
        N.framebufferRenderbuffer(a, c, f, nr[p]);
      },
      Ff: function(a, c, f, p, v) {
        N.framebufferTexture2D(a, c, f, js[p], v);
      },
      nd: function(a, c, f, p, v) {
        N.framebufferTextureLayer(
          a,
          c,
          js[f],
          p,
          v
        );
      },
      Ef: function(a) {
        N.frontFace(a);
      },
      Df: function(a, c) {
        us(a, c, "createBuffer", ir);
      },
      Bf: function(a, c) {
        us(a, c, "createFramebuffer", Xr);
      },
      Ed: function(a, c) {
        us(a, c, "createQuery", Yi);
      },
      Rg: function(a, c) {
        for (var f = 0; f < a; f++) {
          var p = N.pi.createQueryEXT();
          if (!p) {
            for (Kt(1282); f < a; )
              z[c + 4 * f++ >> 2] = 0;
            break;
          }
          var v = bo(Yi);
          p.name = v, Yi[v] = p, z[c + 4 * f >> 2] = v;
        }
      },
      Af: function(a, c) {
        us(a, c, "createRenderbuffer", nr);
      },
      lc: function(a, c) {
        us(a, c, "createSampler", sr);
      },
      zf: function(a, c) {
        us(a, c, "createTexture", js);
      },
      Zb: function(a, c) {
        us(
          a,
          c,
          "createTransformFeedback",
          Zl
        );
      },
      kd: function(a, c) {
        us(a, c, "createVertexArray", Cr);
      },
      Eg: function(a, c) {
        us(a, c, "createVertexArray", Cr);
      },
      Cf: function(a) {
        N.generateMipmap(a);
      },
      yf: function(a, c, f, p, v, M, L) {
        iu("getActiveAttrib", a, c, f, p, v, M, L);
      },
      xf: function(a, c, f, p, v, M, L) {
        iu("getActiveUniform", a, c, f, p, v, M, L);
      },
      Ac: function(a, c, f, p, v) {
        a = De[a], (a = N.getActiveUniformBlockName(a, c)) && (v && 0 < f ? (f = st(a, A, v, f), p && (z[p >> 2] = f)) : p && (z[p >> 2] = 0));
      },
      Bc: function(a, c, f, p) {
        if (p) {
          if (a = De[a], f == 35393)
            f = N.getActiveUniformBlockName(a, c), z[p >> 2] = f.length + 1;
          else if (a = N.getActiveUniformBlockParameter(a, c, f), a !== null)
            if (f == 35395)
              for (f = 0; f < a.length; f++)
                z[p + 4 * f >> 2] = a[f];
            else
              z[p >> 2] = a;
        } else
          Kt(1281);
      },
      Dc: function(a, c, f, p, v) {
        if (v)
          if (0 < c && f == 0)
            Kt(1281);
          else {
            a = De[a];
            for (var M = [], L = 0; L < c; L++)
              M.push(z[f + 4 * L >> 2]);
            if (a = N.getActiveUniforms(a, M, p))
              for (c = a.length, L = 0; L < c; L++)
                z[v + 4 * L >> 2] = a[L];
          }
        else
          Kt(1281);
      },
      wf: function(a, c, f, p) {
        a = N.getAttachedShaders(De[a]);
        var v = a.length;
        for (v > c && (v = c), z[f >> 2] = v, c = 0; c < v; ++c)
          z[p + 4 * c >> 2] = Ji.indexOf(a[c]);
      },
      vf: function(a, c) {
        return N.getAttribLocation(
          De[a],
          q(c)
        );
      },
      uf: function(a, c) {
        ta(a, c, 4);
      },
      mc: function(a, c, f) {
        f ? Ql(f, N.getBufferParameter(a, c)) : Kt(1281);
      },
      tf: function(a, c, f) {
        f ? z[f >> 2] = N.getBufferParameter(a, c) : Kt(1281);
      },
      sf: function() {
        var a = N.getError() || qa;
        return qa = 0, a;
      },
      rf: function(a, c) {
        ta(a, c, 2);
      },
      Uc: function(a, c) {
        return N.getFragDataLocation(De[a], q(c));
      },
      qf: function(a, c, f, p) {
        a = N.getFramebufferAttachmentParameter(a, c, f), (a instanceof WebGLRenderbuffer || a instanceof WebGLTexture) && (a = a.name | 0), z[p >> 2] = a;
      },
      oc: function(a, c, f) {
        vp(a, c, f, 1);
      },
      qc: function(a, c) {
        ta(
          a,
          c,
          1
        );
      },
      id: function(a, c, f) {
        vp(a, c, f, 0);
      },
      pf: function(a, c) {
        ta(a, c, 0);
      },
      Ob: function(a, c, f, p, v) {
        if (0 > p)
          Kt(1281);
        else if (v) {
          if (a = N.getInternalformatParameter(a, c, f), a !== null)
            for (c = 0; c < a.length && c < p; ++c)
              z[v + 4 * c >> 2] = a[c];
        } else
          Kt(1281);
      },
      Vb: function() {
        Kt(1282);
      },
      nf: function(a, c, f, p) {
        a = N.getProgramInfoLog(De[a]), a === null && (a = "(unknown error)"), c = 0 < c && p ? st(a, A, p, c) : 0, f && (z[f >> 2] = c);
      },
      of: function(a, c, f) {
        if (f)
          if (a >= Xd)
            Kt(1281);
          else if (a = De[a], c == 35716)
            a = N.getProgramInfoLog(a), a === null && (a = "(unknown error)"), z[f >> 2] = a.length + 1;
          else if (c == 35719) {
            if (!a.Ci)
              for (c = 0; c < N.getProgramParameter(a, 35718); ++c)
                a.Ci = Math.max(a.Ci, N.getActiveUniform(a, c).name.length + 1);
            z[f >> 2] = a.Ci;
          } else if (c == 35722) {
            if (!a.Ai)
              for (c = 0; c < N.getProgramParameter(a, 35721); ++c)
                a.Ai = Math.max(a.Ai, N.getActiveAttrib(a, c).name.length + 1);
            z[f >> 2] = a.Ai;
          } else if (c == 35381) {
            if (!a.Bi)
              for (c = 0; c < N.getProgramParameter(a, 35382); ++c)
                a.Bi = Math.max(a.Bi, N.getActiveUniformBlockName(a, c).length + 1);
            z[f >> 2] = a.Bi;
          } else
            z[f >> 2] = N.getProgramParameter(a, c);
        else
          Kt(1281);
      },
      Ig: function(a, c, f) {
        if (f) {
          a = Yi[a], c = 2 > ye.version ? N.pi.getQueryObjectEXT(a, c) : N.getQueryParameter(a, c);
          var p;
          typeof c == "boolean" ? p = c ? 1 : 0 : p = c, Ql(f, p);
        } else
          Kt(1281);
      },
      Kg: function(a, c, f) {
        if (f) {
          a = N.pi.getQueryObjectEXT(Yi[a], c);
          var p;
          typeof a == "boolean" ? p = a ? 1 : 0 : p = a, z[f >> 2] = p;
        } else
          Kt(1281);
      },
      Hg: function(a, c, f) {
        if (f) {
          a = Yi[a], c = 2 > ye.version ? N.pi.getQueryObjectEXT(a, c) : N.getQueryParameter(a, c);
          var p;
          typeof c == "boolean" ? p = c ? 1 : 0 : p = c, Ql(f, p);
        } else
          Kt(1281);
      },
      yd: function(a, c, f) {
        if (f) {
          a = N.getQueryParameter(Yi[a], c);
          var p;
          typeof a == "boolean" ? p = a ? 1 : 0 : p = a, z[f >> 2] = p;
        } else
          Kt(1281);
      },
      Jg: function(a, c, f) {
        if (f) {
          a = N.pi.getQueryObjectEXT(Yi[a], c);
          var p;
          typeof a == "boolean" ? p = a ? 1 : 0 : p = a, z[f >> 2] = p;
        } else
          Kt(1281);
      },
      zd: function(a, c, f) {
        f ? z[f >> 2] = N.getQuery(a, c) : Kt(1281);
      },
      Lg: function(a, c, f) {
        f ? z[f >> 2] = N.pi.getQueryEXT(a, c) : Kt(1281);
      },
      mf: function(a, c, f) {
        f ? z[f >> 2] = N.getRenderbufferParameter(a, c) : Kt(1281);
      },
      bc: function(a, c, f) {
        f ? X[f >> 2] = N.getSamplerParameter(sr[a], c) : Kt(1281);
      },
      dc: function(a, c, f) {
        f ? z[f >> 2] = N.getSamplerParameter(sr[a], c) : Kt(1281);
      },
      kf: function(a, c, f, p) {
        a = N.getShaderInfoLog(Ji[a]), a === null && (a = "(unknown error)"), c = 0 < c && p ? st(a, A, p, c) : 0, f && (z[f >> 2] = c);
      },
      jf: function(a, c, f, p) {
        a = N.getShaderPrecisionFormat(a, c), z[f >> 2] = a.rangeMin, z[f + 4 >> 2] = a.rangeMax, z[p >> 2] = a.precision;
      },
      hf: function(a, c, f, p) {
        (a = N.getShaderSource(Ji[a])) && (c = 0 < c && p ? st(a, A, p, c) : 0, f && (z[f >> 2] = c));
      },
      lf: function(a, c, f) {
        f ? c == 35716 ? (a = N.getShaderInfoLog(Ji[a]), a === null && (a = "(unknown error)"), z[f >> 2] = a ? a.length + 1 : 0) : c == 35720 ? (a = N.getShaderSource(Ji[a]), z[f >> 2] = a ? a.length + 1 : 0) : z[f >> 2] = N.getShaderParameter(
          Ji[a],
          c
        ) : Kt(1281);
      },
      gf: function(a) {
        var c = eu[a];
        if (!c) {
          switch (a) {
            case 7939:
              c = N.getSupportedExtensions() || [], c = c.concat(c.map(function(p) {
                return "GL_" + p;
              })), c = Jr(c.join(" "));
              break;
            case 7936:
            case 7937:
            case 37445:
            case 37446:
              (c = N.getParameter(a)) || Kt(1280), c = c && Jr(c);
              break;
            case 7938:
              c = N.getParameter(7938), c = 2 <= ye.version ? "OpenGL ES 3.0 (" + c + ")" : "OpenGL ES 2.0 (" + c + ")", c = Jr(c);
              break;
            case 35724:
              c = N.getParameter(35724);
              var f = c.match(/^WebGL GLSL ES ([0-9]\.[0-9][0-9]?)(?:$| .*)/);
              f !== null && (f[1].length == 3 && (f[1] += "0"), c = "OpenGL ES GLSL ES " + f[1] + " (" + c + ")"), c = Jr(c);
              break;
            default:
              Kt(1280);
          }
          eu[a] = c;
        }
        return c;
      },
      Gc: function(a, c) {
        if (2 > ye.version)
          return Kt(1282), 0;
        var f = pp[a];
        if (f)
          return 0 > c || c >= f.length ? (Kt(1281), 0) : f[c];
        switch (a) {
          case 7939:
            return f = N.getSupportedExtensions() || [], f = f.concat(f.map(function(p) {
              return "GL_" + p;
            })), f = f.map(function(p) {
              return Jr(p);
            }), f = pp[a] = f, 0 > c || c >= f.length ? (Kt(1281), 0) : f[c];
          default:
            return Kt(1280), 0;
        }
      },
      pc: function(a, c, f, p, v) {
        0 > f ? Kt(1281) : v ? (a = N.getSyncParameter(vo[a], c), a !== null && (z[v >> 2] = a, p && (z[p >> 2] = 1))) : Kt(1281);
      },
      ff: function(a, c, f) {
        f ? X[f >> 2] = N.getTexParameter(a, c) : Kt(1281);
      },
      ef: function(a, c, f) {
        f ? z[f >> 2] = N.getTexParameter(a, c) : Kt(1281);
      },
      bd: function(a, c, f, p, v, M, L) {
        a = De[a], (a = N.getTransformFeedbackVarying(a, c)) && (L && 0 < f ? (f = st(a.name, A, L, f), p && (z[p >> 2] = f)) : p && (z[p >> 2] = 0), v && (z[v >> 2] = a.size), M && (z[M >> 2] = a.type));
      },
      Cc: function(a, c) {
        return N.getUniformBlockIndex(De[a], q(c));
      },
      Ec: function(a, c, f, p) {
        if (p)
          if (0 < c && (f == 0 || p == 0))
            Kt(1281);
          else {
            a = De[a];
            for (var v = [], M = 0; M < c; M++)
              v.push(q(z[f + 4 * M >> 2]));
            if (a = N.getUniformIndices(
              a,
              v
            ))
              for (c = a.length, M = 0; M < c; M++)
                z[p + 4 * M >> 2] = a[M];
          }
        else
          Kt(1281);
      },
      bf: function(a, c) {
        if (c = q(c), a = De[a]) {
          Qd(a);
          var f = a.Pi, p = 0, v = c, M = Zd(c);
          if (0 < M && (p = parseInt(c.slice(M + 1)) >>> 0, v = c.slice(0, M)), (v = a.sj[v]) && p < v[0] && (p += v[1], f[p] = f[p] || N.getUniformLocation(a, c)))
            return p;
        } else
          Kt(1281);
        return -1;
      },
      df: function(a, c, f) {
        tf(a, c, f, 2);
      },
      cf: function(a, c, f) {
        tf(a, c, f, 0);
      },
      Vc: function(a, c, f) {
        tf(a, c, f, 0);
      },
      $c: function(a, c, f) {
        nu(a, c, f, 0);
      },
      _c: function(a, c, f) {
        nu(a, c, f, 0);
      },
      _e: function(a, c, f) {
        f ? z[f >> 2] = N.getVertexAttribOffset(a, c) : Kt(1281);
      },
      af: function(a, c, f) {
        nu(a, c, f, 2);
      },
      $e: function(a, c, f) {
        nu(a, c, f, 5);
      },
      Ze: function(a, c) {
        N.hint(a, c);
      },
      Sb: function(a, c, f) {
        for (var p = Qo[c], v = 0; v < c; v++)
          p[v] = z[f + 4 * v >> 2];
        N.invalidateFramebuffer(a, p);
      },
      Rb: function(a, c, f, p, v, M, L) {
        for (var H = Qo[c], Q = 0; Q < c; Q++)
          H[Q] = z[f + 4 * Q >> 2];
        N.invalidateSubFramebuffer(a, H, p, v, M, L);
      },
      Ye: function(a) {
        return (a = ir[a]) ? N.isBuffer(a) : 0;
      },
      Xe: function(a) {
        return N.isEnabled(a);
      },
      We: function(a) {
        return (a = Xr[a]) ? N.isFramebuffer(a) : 0;
      },
      Ve: function(a) {
        return (a = De[a]) ? N.isProgram(a) : 0;
      },
      Cd: function(a) {
        return (a = Yi[a]) ? N.isQuery(a) : 0;
      },
      Pg: function(a) {
        return (a = Yi[a]) ? N.pi.isQueryEXT(a) : 0;
      },
      Ue: function(a) {
        return (a = nr[a]) ? N.isRenderbuffer(a) : 0;
      },
      jc: function(a) {
        return (a = sr[a]) ? N.isSampler(a) : 0;
      },
      Te: function(a) {
        return (a = Ji[a]) ? N.isShader(a) : 0;
      },
      uc: function(a) {
        return N.isSync(vo[a]);
      },
      Se: function(a) {
        return (a = js[a]) ? N.isTexture(a) : 0;
      },
      Yb: function(a) {
        return N.isTransformFeedback(Zl[a]);
      },
      jd: function(a) {
        return (a = Cr[a]) ? N.isVertexArray(a) : 0;
      },
      Dg: function(a) {
        return (a = Cr[a]) ? N.isVertexArray(a) : 0;
      },
      Re: function(a) {
        N.lineWidth(a);
      },
      Qe: function(a) {
        a = De[a], N.linkProgram(a), a.Pi = 0, a.sj = {};
      },
      Xb: function() {
        N.pauseTransformFeedback();
      },
      Pe: function(a, c) {
        a == 3317 && (Jd = c), N.pixelStorei(a, c);
      },
      Oe: function(a, c) {
        N.polygonOffset(a, c);
      },
      Ub: function() {
        Kt(1280);
      },
      Tb: function() {
        Kt(1280);
      },
      Mg: function(a, c) {
        N.pi.queryCounterEXT(Yi[a], c);
      },
      Md: function(a) {
        N.readBuffer(a);
      },
      Ne: function(a, c, f, p, v, M, L) {
        if (2 <= ye.version)
          if (N.Ji)
            N.readPixels(a, c, f, p, v, M, L);
          else {
            var H = xo(M);
            N.readPixels(a, c, f, p, v, M, H, L >> Io(H));
          }
        else
          (L = tc(M, v, f, p, L)) ? N.readPixels(a, c, f, p, v, M, L) : Kt(1280);
      },
      Me: function() {
      },
      Le: function(a, c, f, p) {
        N.renderbufferStorage(a, c, f, p);
      },
      od: function(a, c, f, p, v) {
        N.renderbufferStorageMultisample(a, c, f, p, v);
      },
      Wb: function() {
        N.resumeTransformFeedback();
      },
      Ke: function(a, c) {
        N.sampleCoverage(a, !!c);
      },
      fc: function(a, c, f) {
        N.samplerParameterf(sr[a], c, f);
      },
      ec: function(a, c, f) {
        N.samplerParameterf(sr[a], c, X[f >> 2]);
      },
      hc: function(a, c, f) {
        N.samplerParameteri(sr[a], c, f);
      },
      gc: function(a, c, f) {
        N.samplerParameteri(sr[a], c, z[f >> 2]);
      },
      Je: function(a, c, f, p) {
        N.scissor(a, c, f, p);
      },
      Ie: function() {
        Kt(1280);
      },
      He: function(a, c, f, p) {
        c = mp(c, f, p), N.shaderSource(Ji[a], c);
      },
      Ge: function(a, c, f) {
        N.stencilFunc(a, c, f);
      },
      Fe: function(a, c, f, p) {
        N.stencilFuncSeparate(a, c, f, p);
      },
      Ee: function(a) {
        N.stencilMask(a);
      },
      De: function(a, c) {
        N.stencilMaskSeparate(a, c);
      },
      Ce: function(a, c, f) {
        N.stencilOp(a, c, f);
      },
      Be: function(a, c, f, p) {
        N.stencilOpSeparate(a, c, f, p);
      },
      Ae: function(a, c, f, p, v, M, L, H, Q) {
        if (2 <= ye.version)
          if (N.oi)
            N.texImage2D(a, c, f, p, v, M, L, H, Q);
          else if (Q) {
            var lt = xo(H);
            N.texImage2D(a, c, f, p, v, M, L, H, lt, Q >> Io(lt));
          } else
            N.texImage2D(
              a,
              c,
              f,
              p,
              v,
              M,
              L,
              H,
              null
            );
        else
          N.texImage2D(a, c, f, p, v, M, L, H, Q ? tc(H, L, p, v, Q) : null);
      },
      Kd: function(a, c, f, p, v, M, L, H, Q, lt) {
        if (N.oi)
          N.texImage3D(a, c, f, p, v, M, L, H, Q, lt);
        else if (lt) {
          var ht = xo(Q);
          N.texImage3D(a, c, f, p, v, M, L, H, Q, ht, lt >> Io(ht));
        } else
          N.texImage3D(a, c, f, p, v, M, L, H, Q, null);
      },
      ze: function(a, c, f) {
        N.texParameterf(a, c, f);
      },
      ye: function(a, c, f) {
        N.texParameterf(a, c, X[f >> 2]);
      },
      xe: function(a, c, f) {
        N.texParameteri(a, c, f);
      },
      we: function(a, c, f) {
        N.texParameteri(a, c, z[f >> 2]);
      },
      Qb: function(a, c, f, p, v) {
        N.texStorage2D(a, c, f, p, v);
      },
      Pb: function(a, c, f, p, v, M) {
        N.texStorage3D(a, c, f, p, v, M);
      },
      ve: function(a, c, f, p, v, M, L, H, Q) {
        if (2 <= ye.version)
          if (N.oi)
            N.texSubImage2D(a, c, f, p, v, M, L, H, Q);
          else if (Q) {
            var lt = xo(H);
            N.texSubImage2D(a, c, f, p, v, M, L, H, lt, Q >> Io(lt));
          } else
            N.texSubImage2D(a, c, f, p, v, M, L, H, null);
        else
          lt = null, Q && (lt = tc(H, L, v, M, Q)), N.texSubImage2D(a, c, f, p, v, M, L, H, lt);
      },
      Jd: function(a, c, f, p, v, M, L, H, Q, lt, ht) {
        if (N.oi)
          N.texSubImage3D(a, c, f, p, v, M, L, H, Q, lt, ht);
        else if (ht) {
          var Tt = xo(lt);
          N.texSubImage3D(a, c, f, p, v, M, L, H, Q, lt, Tt, ht >> Io(Tt));
        } else
          N.texSubImage3D(
            a,
            c,
            f,
            p,
            v,
            M,
            L,
            H,
            Q,
            lt,
            null
          );
      },
      dd: function(a, c, f, p) {
        a = De[a];
        for (var v = [], M = 0; M < c; M++)
          v.push(q(z[f + 4 * M >> 2]));
        N.transformFeedbackVaryings(a, v, p);
      },
      ue: function(a, c) {
        N.uniform1f(Zt(a), c);
      },
      te: function(a, c, f) {
        if (2 <= ye.version)
          c && N.uniform1fv(Zt(a), X, f >> 2, c);
        else {
          if (288 >= c)
            for (var p = ds[c - 1], v = 0; v < c; ++v)
              p[v] = X[f + 4 * v >> 2];
          else
            p = X.subarray(f >> 2, f + 4 * c >> 2);
          N.uniform1fv(Zt(a), p);
        }
      },
      se: function(a, c) {
        N.uniform1i(Zt(a), c);
      },
      re: function(a, c, f) {
        if (2 <= ye.version)
          c && N.uniform1iv(Zt(a), z, f >> 2, c);
        else {
          if (288 >= c)
            for (var p = ec[c - 1], v = 0; v < c; ++v)
              p[v] = z[f + 4 * v >> 2];
          else
            p = z.subarray(f >> 2, f + 4 * c >> 2);
          N.uniform1iv(Zt(a), p);
        }
      },
      Tc: function(a, c) {
        N.uniform1ui(Zt(a), c);
      },
      Pc: function(a, c, f) {
        c && N.uniform1uiv(Zt(a), St, f >> 2, c);
      },
      qe: function(a, c, f) {
        N.uniform2f(Zt(a), c, f);
      },
      pe: function(a, c, f) {
        if (2 <= ye.version)
          c && N.uniform2fv(Zt(a), X, f >> 2, 2 * c);
        else {
          if (144 >= c)
            for (var p = ds[2 * c - 1], v = 0; v < 2 * c; v += 2)
              p[v] = X[f + 4 * v >> 2], p[v + 1] = X[f + (4 * v + 4) >> 2];
          else
            p = X.subarray(f >> 2, f + 8 * c >> 2);
          N.uniform2fv(Zt(a), p);
        }
      },
      oe: function(a, c, f) {
        N.uniform2i(Zt(a), c, f);
      },
      ne: function(a, c, f) {
        if (2 <= ye.version)
          c && N.uniform2iv(
            Zt(a),
            z,
            f >> 2,
            2 * c
          );
        else {
          if (144 >= c)
            for (var p = ec[2 * c - 1], v = 0; v < 2 * c; v += 2)
              p[v] = z[f + 4 * v >> 2], p[v + 1] = z[f + (4 * v + 4) >> 2];
          else
            p = z.subarray(f >> 2, f + 8 * c >> 2);
          N.uniform2iv(Zt(a), p);
        }
      },
      Sc: function(a, c, f) {
        N.uniform2ui(Zt(a), c, f);
      },
      Oc: function(a, c, f) {
        c && N.uniform2uiv(Zt(a), St, f >> 2, 2 * c);
      },
      me: function(a, c, f, p) {
        N.uniform3f(Zt(a), c, f, p);
      },
      le: function(a, c, f) {
        if (2 <= ye.version)
          c && N.uniform3fv(Zt(a), X, f >> 2, 3 * c);
        else {
          if (96 >= c)
            for (var p = ds[3 * c - 1], v = 0; v < 3 * c; v += 3)
              p[v] = X[f + 4 * v >> 2], p[v + 1] = X[f + (4 * v + 4) >> 2], p[v + 2] = X[f + (4 * v + 8) >> 2];
          else
            p = X.subarray(f >> 2, f + 12 * c >> 2);
          N.uniform3fv(Zt(a), p);
        }
      },
      ke: function(a, c, f, p) {
        N.uniform3i(Zt(a), c, f, p);
      },
      je: function(a, c, f) {
        if (2 <= ye.version)
          c && N.uniform3iv(Zt(a), z, f >> 2, 3 * c);
        else {
          if (96 >= c)
            for (var p = ec[3 * c - 1], v = 0; v < 3 * c; v += 3)
              p[v] = z[f + 4 * v >> 2], p[v + 1] = z[f + (4 * v + 4) >> 2], p[v + 2] = z[f + (4 * v + 8) >> 2];
          else
            p = z.subarray(f >> 2, f + 12 * c >> 2);
          N.uniform3iv(Zt(a), p);
        }
      },
      Rc: function(a, c, f, p) {
        N.uniform3ui(Zt(a), c, f, p);
      },
      Nc: function(a, c, f) {
        c && N.uniform3uiv(Zt(a), St, f >> 2, 3 * c);
      },
      ie: function(a, c, f, p, v) {
        N.uniform4f(Zt(a), c, f, p, v);
      },
      he: function(a, c, f) {
        if (2 <= ye.version)
          c && N.uniform4fv(Zt(a), X, f >> 2, 4 * c);
        else {
          if (72 >= c) {
            var p = ds[4 * c - 1], v = X;
            f >>= 2;
            for (var M = 0; M < 4 * c; M += 4) {
              var L = f + M;
              p[M] = v[L], p[M + 1] = v[L + 1], p[M + 2] = v[L + 2], p[M + 3] = v[L + 3];
            }
          } else
            p = X.subarray(f >> 2, f + 16 * c >> 2);
          N.uniform4fv(Zt(a), p);
        }
      },
      ge: function(a, c, f, p, v) {
        N.uniform4i(Zt(a), c, f, p, v);
      },
      fe: function(a, c, f) {
        if (2 <= ye.version)
          c && N.uniform4iv(Zt(a), z, f >> 2, 4 * c);
        else {
          if (72 >= c)
            for (var p = ec[4 * c - 1], v = 0; v < 4 * c; v += 4)
              p[v] = z[f + 4 * v >> 2], p[v + 1] = z[f + (4 * v + 4) >> 2], p[v + 2] = z[f + (4 * v + 8) >> 2], p[v + 3] = z[f + (4 * v + 12) >> 2];
          else
            p = z.subarray(f >> 2, f + 16 * c >> 2);
          N.uniform4iv(Zt(a), p);
        }
      },
      Qc: function(a, c, f, p, v) {
        N.uniform4ui(Zt(a), c, f, p, v);
      },
      Mc: function(a, c, f) {
        c && N.uniform4uiv(Zt(a), St, f >> 2, 4 * c);
      },
      zc: function(a, c, f) {
        a = De[a], N.uniformBlockBinding(a, c, f);
      },
      ee: function(a, c, f, p) {
        if (2 <= ye.version)
          c && N.uniformMatrix2fv(Zt(a), !!f, X, p >> 2, 4 * c);
        else {
          if (72 >= c)
            for (var v = ds[4 * c - 1], M = 0; M < 4 * c; M += 4)
              v[M] = X[p + 4 * M >> 2], v[M + 1] = X[p + (4 * M + 4) >> 2], v[M + 2] = X[p + (4 * M + 8) >> 2], v[M + 3] = X[p + (4 * M + 12) >> 2];
          else
            v = X.subarray(p >> 2, p + 16 * c >> 2);
          N.uniformMatrix2fv(Zt(a), !!f, v);
        }
      },
      vd: function(a, c, f, p) {
        c && N.uniformMatrix2x3fv(
          Zt(a),
          !!f,
          X,
          p >> 2,
          6 * c
        );
      },
      td: function(a, c, f, p) {
        c && N.uniformMatrix2x4fv(Zt(a), !!f, X, p >> 2, 8 * c);
      },
      de: function(a, c, f, p) {
        if (2 <= ye.version)
          c && N.uniformMatrix3fv(Zt(a), !!f, X, p >> 2, 9 * c);
        else {
          if (32 >= c)
            for (var v = ds[9 * c - 1], M = 0; M < 9 * c; M += 9)
              v[M] = X[p + 4 * M >> 2], v[M + 1] = X[p + (4 * M + 4) >> 2], v[M + 2] = X[p + (4 * M + 8) >> 2], v[M + 3] = X[p + (4 * M + 12) >> 2], v[M + 4] = X[p + (4 * M + 16) >> 2], v[M + 5] = X[p + (4 * M + 20) >> 2], v[M + 6] = X[p + (4 * M + 24) >> 2], v[M + 7] = X[p + (4 * M + 28) >> 2], v[M + 8] = X[p + (4 * M + 32) >> 2];
          else
            v = X.subarray(p >> 2, p + 36 * c >> 2);
          N.uniformMatrix3fv(Zt(a), !!f, v);
        }
      },
      ud: function(a, c, f, p) {
        c && N.uniformMatrix3x2fv(Zt(a), !!f, X, p >> 2, 6 * c);
      },
      rd: function(a, c, f, p) {
        c && N.uniformMatrix3x4fv(Zt(a), !!f, X, p >> 2, 12 * c);
      },
      ce: function(a, c, f, p) {
        if (2 <= ye.version)
          c && N.uniformMatrix4fv(Zt(a), !!f, X, p >> 2, 16 * c);
        else {
          if (18 >= c) {
            var v = ds[16 * c - 1], M = X;
            p >>= 2;
            for (var L = 0; L < 16 * c; L += 16) {
              var H = p + L;
              v[L] = M[H], v[L + 1] = M[H + 1], v[L + 2] = M[H + 2], v[L + 3] = M[H + 3], v[L + 4] = M[H + 4], v[L + 5] = M[H + 5], v[L + 6] = M[H + 6], v[L + 7] = M[H + 7], v[L + 8] = M[H + 8], v[L + 9] = M[H + 9], v[L + 10] = M[H + 10], v[L + 11] = M[H + 11], v[L + 12] = M[H + 12], v[L + 13] = M[H + 13], v[L + 14] = M[H + 14], v[L + 15] = M[H + 15];
            }
          } else
            v = X.subarray(p >> 2, p + 64 * c >> 2);
          N.uniformMatrix4fv(Zt(a), !!f, v);
        }
      },
      sd: function(a, c, f, p) {
        c && N.uniformMatrix4x2fv(Zt(a), !!f, X, p >> 2, 8 * c);
      },
      qd: function(a, c, f, p) {
        c && N.uniformMatrix4x3fv(Zt(a), !!f, X, p >> 2, 12 * c);
      },
      be: function(a) {
        a = De[a], N.useProgram(a), N.Uj = a;
      },
      ae: function(a) {
        N.validateProgram(De[a]);
      },
      $d: function(a, c) {
        N.vertexAttrib1f(a, c);
      },
      _d: function(a, c) {
        N.vertexAttrib1f(a, X[c >> 2]);
      },
      Zd: function(a, c, f) {
        N.vertexAttrib2f(a, c, f);
      },
      Yd: function(a, c) {
        N.vertexAttrib2f(a, X[c >> 2], X[c + 4 >> 2]);
      },
      Xd: function(a, c, f, p) {
        N.vertexAttrib3f(a, c, f, p);
      },
      Wd: function(a, c) {
        N.vertexAttrib3f(a, X[c >> 2], X[c + 4 >> 2], X[c + 8 >> 2]);
      },
      Vd: function(a, c, f, p, v) {
        N.vertexAttrib4f(a, c, f, p, v);
      },
      Ud: function(a, c) {
        N.vertexAttrib4f(a, X[c >> 2], X[c + 4 >> 2], X[c + 8 >> 2], X[c + 12 >> 2]);
      },
      ac: function(a, c) {
        N.vertexAttribDivisor(a, c);
      },
      zg: function(a, c) {
        N.vertexAttribDivisor(a, c);
      },
      Mb: function(a, c) {
        N.vertexAttribDivisor(a, c);
      },
      Qd: function(a, c) {
        N.vertexAttribDivisor(a, c);
      },
      Nb: function(a, c) {
        N.vertexAttribDivisor(a, c);
      },
      Zc: function(a, c, f, p, v) {
        N.vertexAttribI4i(a, c, f, p, v);
      },
      Xc: function(a, c) {
        N.vertexAttribI4i(a, z[c >> 2], z[c + 4 >> 2], z[c + 8 >> 2], z[c + 12 >> 2]);
      },
      Yc: function(a, c, f, p, v) {
        N.vertexAttribI4ui(a, c, f, p, v);
      },
      Wc: function(a, c) {
        N.vertexAttribI4ui(a, St[c >> 2], St[c + 4 >> 2], St[c + 8 >> 2], St[c + 12 >> 2]);
      },
      ad: function(a, c, f, p, v) {
        N.vertexAttribIPointer(a, c, f, p, v);
      },
      Sd: function(a, c, f, p, v, M) {
        N.vertexAttribPointer(a, c, f, !!p, v, M);
      },
      Rd: function(a, c, f, p) {
        N.viewport(a, c, f, p);
      },
      rc: function(a, c, f, p) {
        N.waitSync(vo[a], c, (f >>> 0) + 4294967296 * p);
      },
      Eb: function(a) {
        var c = A.length;
        if (a >>>= 0, 2147483648 < a)
          return !1;
        for (var f = 1; 4 >= f; f *= 2) {
          var p = c * (1 + 0.2 / f);
          p = Math.min(p, a + 100663296);
          var v = Math;
          p = Math.max(a, p), v = v.min.call(v, 2147483648, p + (65536 - p % 65536) % 65536);
          t: {
            try {
              B.grow(v - U.byteLength + 65535 >>> 16), at();
              var M = 1;
              break t;
            } catch {
            }
            M = void 0;
          }
          if (M)
            return !0;
        }
        return !1;
      },
      va: function(a, c) {
        return c >>= 2, c = { alpha: !!z[c], depth: !!z[c + 1], stencil: !!z[c + 2], antialias: !!z[c + 3], premultipliedAlpha: !!z[c + 4], preserveDrawingBuffer: !!z[c + 5], powerPreference: qw[z[c + 6]], failIfMajorPerformanceCaveat: !!z[c + 7], Cj: z[c + 8], ol: z[c + 9], Wj: z[c + 10], uk: z[c + 11], sl: z[c + 12], tl: z[c + 13] }, typeof a == "number" && (a = q(a)), a = a && a !== "#canvas" ? typeof Yd < "u" && tu[a] ? tu[a] : Xw(a) : typeof Yd < "u" && tu.canvas ? tu.canvas : e.canvas, !a || c.uk ? 0 : _p(a, c);
      },
      yc: function(a) {
        if (ye == a && (ye = 0), ye === Sr[a] && (ye = null), typeof $w == "object") {
          for (var c = Sr[a].Qi.canvas, f = 0; f < su.length; ++f)
            if (su[f].target == c) {
              var p = f--, v = su[p];
              v.target.removeEventListener(v.il, v.hl, v.vl), su.splice(p, 1);
            }
        }
        Sr[a] && Sr[a].Qi.canvas && (Sr[a].Qi.canvas.lk = void 0), Sr[a] = null;
      },
      cd: function(a) {
        a >>= 2;
        for (var c = 0; 14 > c; ++c)
          z[a + c] = 0;
        z[a] = z[a + 1] = z[a + 3] = z[a + 4] = z[a + 8] = z[a + 10] = 1;
      },
      Jc: function(a) {
        return yp(a) ? 0 : -5;
      },
      Ab: function(a, c) {
        var f = 0;
        return bp().forEach(function(p, v) {
          var M = c + f;
          for (v = St[a + 4 * v >> 2] = M, M = 0; M < p.length; ++M)
            J[v++ >> 0] = p.charCodeAt(M);
          J[v >> 0] = 0, f += p.length + 1;
        }), 0;
      },
      Bb: function(a, c) {
        var f = bp();
        St[a >> 2] = f.length;
        var p = 0;
        return f.forEach(function(v) {
          p += v.length + 1;
        }), St[c >> 2] = p, 0;
      },
      la: ap,
      sa: function(a) {
        try {
          var c = ni(a);
          return Mt(c), 0;
        } catch (f) {
          if (typeof Xi > "u" || !(f instanceof Ft))
            throw f;
          return f.Gi;
        }
      },
      Fb: function(a, c, f, p) {
        try {
          t: {
            var v = ni(a);
            a = c;
            for (var M = c = 0; M < f; M++) {
              var L = St[a >> 2], H = St[a + 4 >> 2];
              a += 8;
              var Q = v, lt = L, ht = H, Tt = void 0, Wt = J;
              if (0 > ht || 0 > Tt)
                throw new Ft(28);
              if (Q.fd === null)
                throw new Ft(8);
              if ((Q.flags & 2097155) === 1)
                throw new Ft(8);
              if ((Q.node.mode & 61440) === 16384)
                throw new Ft(31);
              if (!Q.ii.read)
                throw new Ft(28);
              var et = typeof Tt < "u";
              if (!et)
                Tt = Q.position;
              else if (!Q.seekable)
                throw new Ft(70);
              var yt = Q.ii.read(Q, Wt, lt, ht, Tt);
              et || (Q.position += yt);
              var qt = yt;
              if (0 > qt) {
                var Ce = -1;
                break t;
              }
              if (c += qt, qt < H)
                break;
            }
            Ce = c;
          }
          return St[p >> 2] = Ce, 0;
        } catch (je) {
          if (typeof Xi > "u" || !(je instanceof Ft))
            throw je;
          return je.Gi;
        }
      },
      xb: function(a, c, f, p, v) {
        try {
          if (c = f + 2097152 >>> 0 < 4194305 - !!c ? (c >>> 0) + 4294967296 * f : NaN, isNaN(c))
            return 61;
          var M = ni(a);
          return zt(M, c, p), nt = [M.position >>> 0, (W = M.position, 1 <= +Math.abs(W) ? 0 < W ? (Math.min(+Math.floor(W / 4294967296), 4294967295) | 0) >>> 0 : ~~+Math.ceil((W - +(~~W >>> 0)) / 4294967296) >>> 0 : 0)], z[v >> 2] = nt[0], z[v + 4 >> 2] = nt[1], M.xj && c === 0 && p === 0 && (M.xj = null), 0;
        } catch (L) {
          if (typeof Xi > "u" || !(L instanceof Ft))
            throw L;
          return L.Gi;
        }
      },
      ta: function(a, c, f, p) {
        try {
          t: {
            var v = ni(a);
            a = c;
            for (var M = c = 0; M < f; M++) {
              var L = St[a >> 2], H = St[a + 4 >> 2];
              a += 8;
              var Q = me(v, J, L, H);
              if (0 > Q) {
                var lt = -1;
                break t;
              }
              c += Q;
            }
            lt = c;
          }
          return St[p >> 2] = lt, 0;
        } catch (ht) {
          if (typeof Xi > "u" || !(ht instanceof Ft))
            throw ht;
          return ht.Gi;
        }
      },
      ga: function(a) {
        N.activeTexture(a);
      },
      oa: function(a, c) {
        N.attachShader(De[a], Ji[c]);
      },
      _g: function(a, c) {
        N.beginQuery(a, Yi[c]);
      },
      ca: function(a, c) {
        a == 35051 ? N.Ji = c : a == 35052 && (N.oi = c), N.bindBuffer(a, ir[c]);
      },
      fa: function(a, c) {
        N.bindFramebuffer(a, Xr[c]);
      },
      eb: function(a, c) {
        N.bindRenderbuffer(
          a,
          nr[c]
        );
      },
      ib: function(a, c) {
        N.bindTexture(a, js[c]);
      },
      Wa: function(a, c) {
        N.blendFunc(a, c);
      },
      Xa: function(a, c, f, p) {
        N.blendFuncSeparate(a, c, f, p);
      },
      xh: function(a, c, f, p) {
        2 <= ye.version ? f && c ? N.bufferData(a, A, p, f, c) : N.bufferData(a, c, p) : N.bufferData(a, f ? A.subarray(f, f + c) : c, p);
      },
      wh: function(a, c, f, p) {
        2 <= ye.version ? f && N.bufferSubData(a, c, A, p, f) : N.bufferSubData(a, c, A.subarray(p, p + f));
      },
      s: function(a) {
        N.clear(a);
      },
      Za: function(a, c, f, p) {
        N.clearColor(a, c, f, p);
      },
      Ya: function(a) {
        N.clearStencil(a);
      },
      ab: function(a, c, f, p) {
        N.colorMask(
          !!a,
          !!c,
          !!f,
          !!p
        );
      },
      oh: function(a) {
        N.compileShader(Ji[a]);
      },
      Ia: function() {
        var a = bo(De), c = N.createProgram();
        return c.name = a, c.Ci = c.Ai = c.Bi = 0, c.rj = 1, De[a] = c, a;
      },
      qh: function(a) {
        var c = bo(Ji);
        return Ji[c] = N.createShader(a), c;
      },
      gb: function(a, c) {
        for (var f = 0; f < a; f++) {
          var p = z[c + 4 * f >> 2], v = ir[p];
          v && (N.deleteBuffer(v), v.name = 0, ir[p] = null, p == N.Ji && (N.Ji = 0), p == N.oi && (N.oi = 0));
        }
      },
      cb: function(a, c) {
        for (var f = 0; f < a; ++f) {
          var p = z[c + 4 * f >> 2], v = Xr[p];
          v && (N.deleteFramebuffer(v), v.name = 0, Xr[p] = null);
        }
      },
      nh: function(a) {
        if (a) {
          var c = De[a];
          c ? (N.deleteProgram(c), c.name = 0, De[a] = null) : Kt(1281);
        }
      },
      $g: function(a, c) {
        for (var f = 0; f < a; f++) {
          var p = z[c + 4 * f >> 2], v = Yi[p];
          v && (N.deleteQuery(v), Yi[p] = null);
        }
      },
      db: function(a, c) {
        for (var f = 0; f < a; f++) {
          var p = z[c + 4 * f >> 2], v = nr[p];
          v && (N.deleteRenderbuffer(v), v.name = 0, nr[p] = null);
        }
      },
      rh: function(a) {
        if (a) {
          var c = Ji[a];
          c ? (N.deleteShader(c), Ji[a] = null) : Kt(1281);
        }
      },
      hb: function(a, c) {
        for (var f = 0; f < a; f++) {
          var p = z[c + 4 * f >> 2], v = js[p];
          v && (N.deleteTexture(v), v.name = 0, js[p] = null);
        }
      },
      Va: function(a) {
        N.depthFunc(a);
      },
      $a: function(a) {
        N.depthMask(!!a);
      },
      Ua: function(a, c) {
        N.depthRange(a, c);
      },
      Oa: function(a) {
        N.disable(a);
      },
      I: function(a) {
        N.disableVertexAttribArray(a);
      },
      U: function(a, c, f) {
        N.drawArrays(a, c, f);
      },
      Ba: function(a, c, f, p) {
        N.drawArraysInstanced(a, c, f, p);
      },
      fh: function(a, c) {
        for (var f = Qo[a], p = 0; p < a; p++)
          f[p] = z[c + 4 * p >> 2];
        N.drawBuffers(f);
      },
      Ga: wp,
      Ca: function(a, c, f, p, v) {
        N.drawElementsInstanced(a, c, f, p, v);
      },
      Pa: function(a) {
        N.enable(a);
      },
      E: function(a) {
        N.enableVertexAttribArray(a);
      },
      Zg: function(a) {
        N.endQuery(a);
      },
      ih: function() {
        N.finish();
      },
      Ea: function(a, c, f, p) {
        N.framebufferRenderbuffer(
          a,
          c,
          f,
          nr[p]
        );
      },
      eh: function(a, c, f, p, v) {
        N.framebufferTexture2D(a, c, f, js[p], v);
      },
      _a: function(a) {
        N.frontFace(a);
      },
      yh: function(a, c) {
        us(a, c, "createBuffer", ir);
      },
      Fa: function(a, c) {
        us(a, c, "createFramebuffer", Xr);
      },
      ah: function(a, c) {
        us(a, c, "createQuery", Yi);
      },
      hh: function(a, c) {
        us(a, c, "createRenderbuffer", nr);
      },
      th: function(a, c) {
        us(a, c, "createTexture", js);
      },
      vh: function(a) {
        N.generateMipmap(a);
      },
      kh: function(a, c, f, p, v, M, L) {
        iu("getActiveAttrib", a, c, f, p, v, M, L);
      },
      jh: function(a, c, f, p, v, M, L) {
        iu("getActiveUniform", a, c, f, p, v, M, L);
      },
      mh: function(a, c) {
        return N.getAttribLocation(De[a], q(c));
      },
      kb: function(a, c) {
        ta(a, c, 4);
      },
      mb: function() {
        var a = N.getError() || qa;
        return qa = 0, a;
      },
      W: function(a, c) {
        ta(a, c, 2);
      },
      n: function(a, c) {
        ta(a, c, 0);
      },
      ba: function(a, c, f) {
        if (f)
          if (a >= Xd)
            Kt(1281);
          else if (a = De[a], c == 35716)
            a = N.getProgramInfoLog(a), a === null && (a = "(unknown error)"), z[f >> 2] = a.length + 1;
          else if (c == 35719) {
            if (!a.Ci)
              for (c = 0; c < N.getProgramParameter(a, 35718); ++c)
                a.Ci = Math.max(a.Ci, N.getActiveUniform(a, c).name.length + 1);
            z[f >> 2] = a.Ci;
          } else if (c == 35722) {
            if (!a.Ai)
              for (c = 0; c < N.getProgramParameter(a, 35721); ++c)
                a.Ai = Math.max(a.Ai, N.getActiveAttrib(a, c).name.length + 1);
            z[f >> 2] = a.Ai;
          } else if (c == 35381) {
            if (!a.Bi)
              for (c = 0; c < N.getProgramParameter(a, 35382); ++c)
                a.Bi = Math.max(a.Bi, N.getActiveUniformBlockName(a, c).length + 1);
            z[f >> 2] = a.Bi;
          } else
            z[f >> 2] = N.getProgramParameter(a, c);
        else
          Kt(1281);
      },
      za: function(a, c, f) {
        if (f) {
          a = N.getQueryParameter(Yi[a], c);
          var p;
          typeof a == "boolean" ? p = a ? 1 : 0 : p = a, z[f >> 2] = p;
        } else
          Kt(1281);
      },
      lb: function(a, c, f, p) {
        a = N.getShaderPrecisionFormat(a, c), z[f >> 2] = a.rangeMin, z[f + 4 >> 2] = a.rangeMax, z[p >> 2] = a.precision;
      },
      ra: function(a) {
        var c = eu[a];
        if (!c) {
          switch (a) {
            case 7939:
              c = N.getSupportedExtensions() || [], c = c.concat(c.map(function(p) {
                return "GL_" + p;
              })), c = Jr(c.join(" "));
              break;
            case 7936:
            case 7937:
            case 37445:
            case 37446:
              (c = N.getParameter(a)) || Kt(1280), c = c && Jr(c);
              break;
            case 7938:
              c = N.getParameter(7938), c = 2 <= ye.version ? "OpenGL ES 3.0 (" + c + ")" : "OpenGL ES 2.0 (" + c + ")", c = Jr(c);
              break;
            case 35724:
              c = N.getParameter(35724);
              var f = c.match(/^WebGL GLSL ES ([0-9]\.[0-9][0-9]?)(?:$| .*)/);
              f !== null && (f[1].length == 3 && (f[1] += "0"), c = "OpenGL ES GLSL ES " + f[1] + " (" + c + ")"), c = Jr(c);
              break;
            default:
              Kt(1280);
          }
          eu[a] = c;
        }
        return c;
      },
      lh: function(a, c) {
        if (c = q(c), a = De[a]) {
          Qd(a);
          var f = a.Pi, p = 0, v = c, M = Zd(c);
          if (0 < M && (p = parseInt(c.slice(M + 1)) >>> 0, v = c.slice(0, M)), (v = a.sj[v]) && p < v[0] && (p += v[1], f[p] = f[p] || N.getUniformLocation(a, c)))
            return p;
        } else
          Kt(1281);
        return -1;
      },
      O: function(a) {
        return N.isEnabled(a);
      },
      Ha: function(a) {
        a = De[a], N.linkProgram(a), a.Pi = 0, a.sj = {};
      },
      bb: function(a, c) {
        a == 3317 && (Jd = c), N.pixelStorei(a, c);
      },
      Ta: function(a, c) {
        N.polygonOffset(a, c);
      },
      dh: function(a, c, f, p, v, M, L) {
        if (2 <= ye.version)
          if (N.Ji)
            N.readPixels(a, c, f, p, v, M, L);
          else {
            var H = xo(M);
            N.readPixels(a, c, f, p, v, M, H, L >> Io(H));
          }
        else
          (L = tc(M, v, f, p, L)) ? N.readPixels(a, c, f, p, v, M, L) : Kt(1280);
      },
      gh: function(a, c, f, p) {
        N.renderbufferStorage(a, c, f, p);
      },
      Sa: function(a, c, f, p) {
        N.scissor(a, c, f, p);
      },
      ph: function(a, c, f, p) {
        c = mp(c, f, p), N.shaderSource(Ji[a], c);
      },
      ea: function(a, c, f) {
        N.stencilFunc(a, c, f);
      },
      V: function(a, c, f, p) {
        N.stencilFuncSeparate(a, c, f, p);
      },
      Ra: function(a) {
        N.stencilMask(a);
      },
      qa: function(a, c) {
        N.stencilMaskSeparate(a, c);
      },
      Qa: function(a, c, f) {
        N.stencilOp(a, c, f);
      },
      pa: function(a, c, f, p) {
        N.stencilOpSeparate(a, c, f, p);
      },
      $: function(a, c, f, p, v, M, L, H, Q) {
        if (2 <= ye.version)
          if (N.oi)
            N.texImage2D(a, c, f, p, v, M, L, H, Q);
          else if (Q) {
            var lt = xo(H);
            N.texImage2D(a, c, f, p, v, M, L, H, lt, Q >> Io(lt));
          } else
            N.texImage2D(a, c, f, p, v, M, L, H, null);
        else
          N.texImage2D(a, c, f, p, v, M, L, H, Q ? tc(H, L, p, v, Q) : null);
      },
      uh: function(a, c, f) {
        N.texParameterf(a, c, f);
      },
      G: function(a, c, f) {
        N.texParameteri(a, c, f);
      },
      q: function(a, c) {
        N.uniform1f(Zt(a), c);
      },
      N: function(a, c, f) {
        if (2 <= ye.version)
          c && N.uniform1fv(Zt(a), X, f >> 2, c);
        else {
          if (288 >= c)
            for (var p = ds[c - 1], v = 0; v < c; ++v)
              p[v] = X[f + 4 * v >> 2];
          else
            p = X.subarray(f >> 2, f + 4 * c >> 2);
          N.uniform1fv(Zt(a), p);
        }
      },
      k: function(a, c) {
        N.uniform1i(Zt(a), c);
      },
      y: function(a, c, f) {
        N.uniform2f(Zt(a), c, f);
      },
      Da: function(a, c, f) {
        if (2 <= ye.version)
          c && N.uniform2fv(Zt(a), X, f >> 2, 2 * c);
        else {
          if (144 >= c)
            for (var p = ds[2 * c - 1], v = 0; v < 2 * c; v += 2)
              p[v] = X[f + 4 * v >> 2], p[v + 1] = X[f + (4 * v + 4) >> 2];
          else
            p = X.subarray(f >> 2, f + 8 * c >> 2);
          N.uniform2fv(Zt(a), p);
        }
      },
      ch: function(a, c, f) {
        N.uniform2i(Zt(a), c, f);
      },
      ma: function(a, c, f, p) {
        N.uniform3f(Zt(a), c, f, p);
      },
      F: function(a, c, f) {
        if (2 <= ye.version)
          c && N.uniform3fv(Zt(a), X, f >> 2, 3 * c);
        else {
          if (96 >= c)
            for (var p = ds[3 * c - 1], v = 0; v < 3 * c; v += 3)
              p[v] = X[f + 4 * v >> 2], p[v + 1] = X[f + (4 * v + 4) >> 2], p[v + 2] = X[f + (4 * v + 8) >> 2];
          else
            p = X.subarray(f >> 2, f + 12 * c >> 2);
          N.uniform3fv(Zt(a), p);
        }
      },
      T: function(a, c, f, p, v) {
        N.uniform4f(Zt(a), c, f, p, v);
      },
      r: function(a, c, f) {
        if (2 <= ye.version)
          c && N.uniform4fv(Zt(a), X, f >> 2, 4 * c);
        else {
          if (72 >= c) {
            var p = ds[4 * c - 1], v = X;
            f >>= 2;
            for (var M = 0; M < 4 * c; M += 4) {
              var L = f + M;
              p[M] = v[L], p[M + 1] = v[L + 1], p[M + 2] = v[L + 2], p[M + 3] = v[L + 3];
            }
          } else
            p = X.subarray(f >> 2, f + 16 * c >> 2);
          N.uniform4fv(Zt(a), p);
        }
      },
      na: function(a, c, f, p) {
        if (2 <= ye.version)
          c && N.uniformMatrix3fv(Zt(a), !!f, X, p >> 2, 9 * c);
        else {
          if (32 >= c)
            for (var v = ds[9 * c - 1], M = 0; M < 9 * c; M += 9)
              v[M] = X[p + 4 * M >> 2], v[M + 1] = X[p + (4 * M + 4) >> 2], v[M + 2] = X[p + (4 * M + 8) >> 2], v[M + 3] = X[p + (4 * M + 12) >> 2], v[M + 4] = X[p + (4 * M + 16) >> 2], v[M + 5] = X[p + (4 * M + 20) >> 2], v[M + 6] = X[p + (4 * M + 24) >> 2], v[M + 7] = X[p + (4 * M + 28) >> 2], v[M + 8] = X[p + (4 * M + 32) >> 2];
          else
            v = X.subarray(p >> 2, p + 36 * c >> 2);
          N.uniformMatrix3fv(Zt(a), !!f, v);
        }
      },
      t: function(a, c, f, p) {
        if (2 <= ye.version)
          c && N.uniformMatrix4fv(Zt(a), !!f, X, p >> 2, 16 * c);
        else {
          if (18 >= c) {
            var v = ds[16 * c - 1], M = X;
            p >>= 2;
            for (var L = 0; L < 16 * c; L += 16) {
              var H = p + L;
              v[L] = M[H], v[L + 1] = M[H + 1], v[L + 2] = M[H + 2], v[L + 3] = M[H + 3], v[L + 4] = M[H + 4], v[L + 5] = M[H + 5], v[L + 6] = M[H + 6], v[L + 7] = M[H + 7], v[L + 8] = M[H + 8], v[L + 9] = M[H + 9], v[L + 10] = M[H + 10], v[L + 11] = M[H + 11], v[L + 12] = M[H + 12], v[L + 13] = M[H + 13], v[L + 14] = M[H + 14], v[L + 15] = M[H + 15];
            }
          } else
            v = X.subarray(p >> 2, p + 64 * c >> 2);
          N.uniformMatrix4fv(Zt(a), !!f, v);
        }
      },
      fb: function(a) {
        a = De[a], N.useProgram(a), N.Uj = a;
      },
      Aa: function(a, c) {
        N.vertexAttrib1f(a, c);
      },
      bh: function(a, c, f, p, v) {
        N.vertexAttrib4f(a, c, f, p, v);
      },
      H: function(a, c) {
        N.vertexAttribDivisor(a, c);
      },
      C: function(a, c, f, p, v, M) {
        N.vertexAttribPointer(a, c, f, !!p, v, M);
      },
      jb: function(a, c, f, p) {
        N.viewport(a, c, f, p);
      },
      sh: function(a, c, f, p, v) {
        Wd(), a = A.subarray(a, a + c), c = null, f = ["image/jpeg", "image/png", "image/gif", "image/bmp", "image/svg+xml"][f];
        var M = [N.LUMINANCE, N.LUMINANCE_ALPHA, N.RGB, N.RGBA][p - 1];
        if (M === void 0 && (M = N.RGBA), $a)
          try {
            c = new Blob([a], { type: f }), c.size !== a.length && (c = new Blob(
              [new Uint8Array(a).buffer],
              { type: f }
            ));
          } catch {
          }
        c || (f = new Kd(), f.append(new Uint8Array(a).buffer), c = f.getBlob());
        var L = Ka("wrapperTexturePreLoad", "number", ["number", "number", "number", "number"]), H = Ka("wrapperTexturePostLoad", null, ["number", "number", "number"]), Q = Ka("wrapperTextureOnError", null, ["number", "number"]), lt = wo.createObjectURL(c), ht = document.createElement("img"), Tt = e.$$facade;
        ht.onload = function() {
          if (Tt === e.$$facade) {
            var Wt = 1;
            L && (Wt = L(v, ht.width, ht.height, p));
            var et = 0;
            if (Wt)
              try {
                N.texImage2D(N.TEXTURE_2D, 0, M, M, N.UNSIGNED_BYTE, ht), et = 1;
              } catch {
              }
            H && H(0, v, et);
          } else
            H && H(1, v, 0);
          wo.revokeObjectURL(lt);
        }, ht.onerror = function() {
          Tt === e.$$facade ? Q && Q(0, v) : Q && Q(1, v), wo.revokeObjectURL(lt);
        }, ht.src = lt;
      },
      ya: function() {
        return e.bj ? ea.close.apply(ea, arguments) : ia.close.apply(ia, arguments);
      },
      Yg: function() {
        window.addEventListener("beforeunload", function() {
          e.bj ? ea.close() : ia.close();
        });
      },
      Xg: function(a, c, f) {
        return e.bk = 0, self.bowser.chrome && 0 > self.bowser.compareVersions([self.bowser.version, "68"]) && (e.bj = !0), e.bj ? ea.connect.apply(ea, arguments) : ia.connect.apply(
          ia,
          arguments
        );
      },
      Wg: function(a, c) {
        return e.bj ? ea.Jj.apply(ea, arguments) : ia.Jj.apply(ia, arguments);
      },
      zb: function(a, c, f, p) {
        return Jw(a, c, f, p);
      }
    };
    (function() {
      function a(v) {
        e.asm = v.exports, B = e.asm.Ih, at(), ot = e.asm.Kh, Pt.unshift(e.asm.Jh), Be();
      }
      function c(v) {
        a(v.instance);
      }
      function f(v) {
        return $().then(function(M) {
          return WebAssembly.instantiate(M, p);
        }).then(function(M) {
          return M;
        }).then(v, function(M) {
          P("failed to asynchronously prepare wasm: " + M), Ne(M);
        });
      }
      var p = { a: Qw };
      if (He(), e.instantiateWasm)
        try {
          return e.instantiateWasm(p, a);
        } catch (v) {
          P("Module.instantiateWasm callback failed with error: " + v), n(v);
        }
      return function() {
        return k || typeof WebAssembly.instantiateStreaming != "function" || cn() || T.startsWith("file://") || d || typeof fetch != "function" ? f(c) : fetch(T, { credentials: "same-origin" }).then(function(v) {
          return WebAssembly.instantiateStreaming(v, p).then(c, function(M) {
            return P("wasm streaming compile failed: " + M), P("falling back to ArrayBuffer instantiation"), f(c);
          });
        });
      }().catch(n), {};
    })(), e.___wasm_call_ctors = function() {
      return (e.___wasm_call_ctors = e.asm.Jh).apply(null, arguments);
    }, e._callFuncWrapper = function() {
      return (e._callFuncWrapper = e.asm.Lh).apply(null, arguments);
    }, e._main = function() {
      return (e._main = e.asm.Mh).apply(null, arguments);
    }, e._wrapperTexturePreLoad = function() {
      return (e._wrapperTexturePreLoad = e.asm.Nh).apply(null, arguments);
    }, e._wrapperTexturePostLoad = function() {
      return (e._wrapperTexturePostLoad = e.asm.Oh).apply(null, arguments);
    }, e._wrapperTextureOnError = function() {
      return (e._wrapperTextureOnError = e.asm.Ph).apply(null, arguments);
    };
    var Pr = e._free = function() {
      return (Pr = e._free = e.asm.Qh).apply(null, arguments);
    }, kp = e.___errno_location = function() {
      return (kp = e.___errno_location = e.asm.Rh).apply(null, arguments);
    }, ic = e._malloc = function() {
      return (ic = e._malloc = e.asm.Sh).apply(null, arguments);
    };
    e._webSocketHandlerOnMessage = function() {
      return (e._webSocketHandlerOnMessage = e.asm.Th).apply(null, arguments);
    };
    var Mp = e.___getTypeName = function() {
      return (Mp = e.___getTypeName = e.asm.Uh).apply(null, arguments);
    };
    e.__embind_initialize_bindings = function() {
      return (e.__embind_initialize_bindings = e.asm.Vh).apply(null, arguments);
    };
    var au = e.stackSave = function() {
      return (au = e.stackSave = e.asm.Wh).apply(null, arguments);
    }, lu = e.stackRestore = function() {
      return (lu = e.stackRestore = e.asm.Xh).apply(null, arguments);
    }, nc = e.stackAlloc = function() {
      return (nc = e.stackAlloc = e.asm.Yh).apply(null, arguments);
    };
    e.dynCall_viiijiiiiiiiiiii = function() {
      return (e.dynCall_viiijiiiiiiiiiii = e.asm.Zh).apply(null, arguments);
    }, e.dynCall_iij = function() {
      return (e.dynCall_iij = e.asm._h).apply(null, arguments);
    }, e.dynCall_iiiiiijii = function() {
      return (e.dynCall_iiiiiijii = e.asm.$h).apply(null, arguments);
    }, e.dynCall_jiji = function() {
      return (e.dynCall_jiji = e.asm.ai).apply(null, arguments);
    }, e.dynCall_viijii = function() {
      return (e.dynCall_viijii = e.asm.bi).apply(null, arguments);
    }, e.dynCall_iiiiij = function() {
      return (e.dynCall_iiiiij = e.asm.ci).apply(null, arguments);
    }, e.dynCall_iiiiijj = function() {
      return (e.dynCall_iiiiijj = e.asm.di).apply(null, arguments);
    }, e.dynCall_iiiiiijj = function() {
      return (e.dynCall_iiiiiijj = e.asm.ei).apply(null, arguments);
    }, e.___emscripten_embedded_file_data = 662400, e.addRunDependency = He, e.removeRunDependency = Be, e.FS_createPath = Ni, e.FS_createDataFile = cs, e.FS_createPreloadedFile = br, e.FS_createLazyFile = qn, e.FS_createDevice = wn, e.FS_unlink = F, e.ccall = sf, e.cwrap = Ka;
    var cu;
    xe = function a() {
      cu || Ep(), cu || (xe = a);
    };
    function Ep() {
      function a() {
        if (!cu && (cu = !0, e.calledRun = !0, !j)) {
          if (e.noFSInit || Ki || (Ki = !0, ii(), e.stdin = e.stdin, e.stdout = e.stdout, e.stderr = e.stderr, e.stdin ? wn("/dev", "stdin", e.stdin) : E("/dev/tty", "/dev/stdin"), e.stdout ? wn("/dev", "stdout", null, e.stdout) : E("/dev/tty", "/dev/stdout"), e.stderr ? wn("/dev", "stderr", null, e.stderr) : E("/dev/tty1", "/dev/stderr"), pt("/dev/stdin", 0), pt("/dev/stdout", 1), pt("/dev/stderr", 1)), Kr = !1, rt(Pt), rt(Lt), i(e), e.onRuntimeInitialized && e.onRuntimeInitialized(), Ap) {
            var c = e._main;
            try {
              var f = c(0, 0);
              ap(f, !0);
            } catch (p) {
              lp(p);
            }
          }
          if (e.postRun)
            for (typeof e.postRun == "function" && (e.postRun = [e.postRun]); e.postRun.length; )
              c = e.postRun.shift(), Je.unshift(c);
          rt(Je);
        }
      }
      if (!(0 < re)) {
        if (e.preRun)
          for (typeof e.preRun == "function" && (e.preRun = [e.preRun]); e.preRun.length; )
            Bi();
        rt(Ut), 0 < re || (e.setStatus ? (e.setStatus("Running..."), setTimeout(function() {
          setTimeout(function() {
            e.setStatus("");
          }, 1), a();
        }, 1)) : a());
      }
    }
    if (e.preInit)
      for (typeof e.preInit == "function" && (e.preInit = [e.preInit]); 0 < e.preInit.length; )
        e.preInit.pop()();
    var Ap = !0;
    return e.noInitialRun && (Ap = !1), Ep(), t.ready;
  };
})();
window.bowser = mv;
const gn = class gn {
  // store instance arguments and return empty base object that will
  // be populated asynchronously
  static async createInstance(t) {
    const e = {
      isWrapper: !0,
      base: {},
      args: t,
      enginePath: t.enginePath ?? gn.defaultEnginePath
    };
    return await gn.createScInstance(e), e.base;
  }
  static catchExceptions(t, e) {
    return function(...i) {
      try {
        e.apply(this, i);
      } catch (n) {
        console.log("Unhandled exception in " + t + "():"), console.log(n);
      }
    };
  }
  static getElement(t) {
    return typeof t != "string" ? t : document.getElementById(t);
  }
  static getAvailableCore() {
    for (const t of gn.core_pool)
      if (t.$$available)
        return t;
    return null;
  }
  static async getWasmBinary(t) {
    if (gn.defaultBinary)
      return gn.defaultBinary;
    const e = new URL((t || "") + "/engine.esm.wasm", window.location.toString()), i = await fetch(e);
    if (!i.ok)
      return;
    const n = await i.arrayBuffer();
    return new Uint8Array(n);
  }
  static createRenderCanvas(t) {
    const e = t.containers.get(Me.Default);
    let i = new OffscreenCanvas(
      e.clientWidth,
      e.clientHeight
    );
    return i.getContext("webgl2") || (console.debug(
      "WebGL2 context not supported with OffscreenCanvas, fallback with HTMLCanvasElement"
    ), i = document.createElement("canvas"), i.width = e.clientWidth, i.height = e.clientHeight), i;
  }
  static createCore(t, e) {
    console.assert(t.canvas !== void 0);
    const i = {
      $$available: !1,
      $$facade: t,
      callAfterMap: { index: 0, indexedWrappers: {} },
      canvas: t.canvas,
      wasmBinary: e
    };
    return gn.core_pool.push(i), i;
  }
  static async getCore(t, e) {
    let i = gn.getAvailableCore();
    const n = !i;
    if (n ? t.canvas = gn.createRenderCanvas(t) : t.canvas = i == null ? void 0 : i.canvas, i === null) {
      const r = await gn.getWasmBinary(e.enginePath);
      if (r === void 0)
        throw typeof e.onError == "function" && e.onError("Unable to load engine binary"), "Unable to load engine binary";
      i = gn.createCore(t, r);
    }
    return i.$$available = !1, i.$$facade = t, i.$$onReady = gn.catchExceptions("onReady", function() {
      const r = e.onReady;
      typeof r == "function" && r(t);
    }), typeof e.onError == "function" && (i.onAbort = gn.catchExceptions("onError", function(r) {
      e.onError("fatal error: see console " + r);
    })), typeof e.enginePath == "string" && (i.locateFile = (r) => `${e.enginePath}/${r}`), { core: i, isNew: n };
  }
  static getFacade(t) {
    let e, i;
    e = t.base, i = t.args;
    const n = gn.getElement(i.container);
    if (!n)
      throw new TypeError("'container' argument is missing or invalid");
    e.containers = /* @__PURE__ */ new Map(), e.containers.set(Me.Default, n);
    const r = this.createWrapper();
    return e.wrappers = /* @__PURE__ */ new Map(), e.wrappers.set(Me.Default, r), { facade: e, args: i };
  }
  static setupNewView(t, e, i) {
    const n = gn.getElement(i), r = this.createWrapper();
    if (t.wrappers.set(e, r), !n)
      throw new TypeError("'container' argument is missing or invalid");
    t.containers.set(e, n), this.createSubContainer(t, e);
  }
  static createWrapper() {
    const t = document.createElement("div");
    return t.setAttribute(
      "style",
      "position: absolute; overflow: hidden; width: 100%; height: 100%; padding: 0; margin: 0; border: 0;"
    ), t;
  }
  static createSubContainer(t, e) {
    const i = document.createElement("div");
    i.setAttribute(
      "style",
      "position: relative; overflow: hidden; width: 100%; height: 100%; padding: 0; margin: 0; border: 0;"
    );
    const n = document.createElement("div");
    n.setAttribute(
      "style",
      "position: absolute; top: 0; left: 0; width: 100%; height: 100%; padding: 0; margin: 0; border: 0;"
    ), n.onmousedown = function(l) {
      l.preventDefault();
    }, n.oncontextmenu = function(l) {
      l.preventDefault();
    };
    const r = t.wrappers.get(e);
    i.appendChild(r), i.appendChild(n);
    const o = t.containers.get(e);
    return o.innerHTML = "", o.appendChild(i), i;
  }
  static async createScInstance(t) {
    const { facade: e, args: i } = gn.getFacade(t), { core: n, isNew: r } = await gn.getCore(e, i);
    return gn.createSubContainer(e, Me.Default), r ? _v(n) : setTimeout(function() {
      n.$$setReady && n.$$setReady();
    }), e;
  }
};
gn.core_pool = [];
let ro = gn;
const UC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AntiAliasingMode: ol,
  AttachScope: Ia,
  BimMask: mn,
  BimType: Pc,
  BlurIntervalUnit: kc,
  ColorType: An,
  CullingVectorSpace: Fm,
  CuttingSectionKey: rl,
  DataKey: zu,
  DrawMode: dr,
  DrawStrategy: Bm,
  ElementMask: Vm,
  ElementType: an,
  GroupKey: Nm,
  HighlightFilter: Or,
  HighlightMode: Uu,
  ImageFormat: ko,
  ImageKey: Dm,
  InclusionKey: Ei,
  InstanceKey: ag,
  Key: og,
  LightKey: Om,
  LightSpace: Lm,
  LightType: Hu,
  LinePatternLengthUnit: zm,
  MasterModelKey: Ur,
  MatrixKey: Rm,
  MeshKey: Sc,
  ModelKey: xs,
  OverlayAnchor: ur,
  OverlayUnit: al,
  PointShape: Hm,
  PointSizeUnit: Um,
  Projection: Jc,
  SessionType: en,
  SetVisibility: oo,
  SimpleReflectionAttenuationUnit: lg,
  SmaaQuality: jm,
  StateFailure: cg,
  StreamcacheModule: ro,
  TextureInterpolation: ju,
  TextureMipMapping: Wu,
  TextureModifier: Mc,
  TextureParameterization: Gu,
  TextureTiling: $u,
  TransparencyMode: Wm,
  UnspecifiedMeasurementUnit: Ns,
  ViewKey: Me,
  XRayGroup: qu,
  getStateFailure: Gm,
  isError: ha
}, Symbol.toStringTag, { value: "Module" }));
function gd(s) {
  const t = /* @__PURE__ */ new Map();
  return s.forEach((e, i) => {
    t.set(i, e);
  }), t;
}
function yv(s) {
  const t = /* @__PURE__ */ new Set();
  return s.forEach((e) => {
    t.add(e);
  }), t;
}
function Ec(s) {
  const t = /* @__PURE__ */ new Set();
  for (const e of s)
    t.add(e);
  return t;
}
function ao(s) {
  const t = [];
  return s.forEach((e) => {
    t.push(e);
  }), t;
}
function Sf(s, t) {
  const e = ao(s).filter((i) => !t.has(i));
  return Ec(e);
}
function Ku(s) {
  const t = {
    origin: [],
    direction: []
  };
  return s.origin.toArray(t.origin), s.direction.toArray(t.direction), t;
}
function gu(s) {
  const t = new kb();
  return t.pos1.fromArray(s.point1), t.pos2.fromArray(s.point2), t.distance = s.distance, t;
}
function ne(s, t) {
  return (s & t) === t;
}
function pa(s, t, e) {
  return e ? s | t : s & ~t;
}
function wv(s) {
  let t = "";
  const e = s.byteLength;
  for (let i = 0; i < e; i++)
    t += String.fromCharCode(s[i]);
  return window.btoa(t);
}
function Dp(s) {
  let t = Math.abs(s.x), e = Math.abs(s.y), i = Math.abs(s.z);
  return t = +t.toFixed(6), e = +e.toFixed(6), i = +i.toFixed(6), t > e && t > i ? new _(1, 0, 0) : e > t && e > i ? new _(0, 1, 0) : i > t && i > e ? new _(0, 0, 1) : null;
}
function Yc(s) {
  return JSON.parse(JSON.stringify(s));
}
function vv(s, t) {
  for (const e in s)
    Object.prototype.hasOwnProperty.call(s, e) && (t[e] = s[e]);
}
function ll(s, t) {
  return s === void 0 ? t : s;
}
function Zc(s, t) {
  const e = s.length > t.length ? s.length : t.length;
  for (let i = 0; i < e; ++i) {
    const n = s[i] || 0, r = t[i] || 0;
    if (n > r)
      return !0;
    if (n < r)
      return !1;
  }
  return !0;
}
function Km(s) {
  if (s.length === 0)
    return "";
  let t = `${s[0]}`;
  for (let e = 1; e < s.length; ++e)
    t += `.${s[e]}`;
  return t;
}
function bv() {
  return window.crypto || window.msCrypto;
}
const xv = "²", Iv = "³";
function Op(s) {
  if (s instanceof Map)
    return s;
  const t = /* @__PURE__ */ new Map(), e = Object.keys(s);
  for (const i of e) {
    const n = s[i];
    t.set(parseInt(i, 10), n);
  }
  return t;
}
const Xm = /* @__PURE__ */ new Map();
function as(s, t) {
  Xm.set(s, t);
}
function hg(s) {
  return Xm.get(s);
}
const Ts = -1;
function Dl(s) {
  return console.assert(s !== Ts), s > Ts;
}
function Cv(s) {
  return console.assert(Dl(s)), s;
}
function Ko(s, t) {
  return Dl(s) ? Gi(t).toRuntimeId(s) : s;
}
class ug {
  static parseXml(t) {
    console.assert(t.localName === "Material");
    let e = null, i = null;
    const n = t.getAttribute("Color");
    if (n !== null) {
      const r = n.split(" ");
      if (r.length !== 4)
        throw new si('Expected "Color" attribute to have four channel components.');
      const o = parseFloat(r[0]), l = parseFloat(r[1]), h = parseFloat(r[2]), u = parseFloat(r[3]);
      e = new vt(o, l, h), i = u;
    }
    return new ug(e, i);
  }
  constructor(t, e) {
    t !== null && (this._color = t), e !== null && (this._alpha = e);
  }
  getColor() {
    return this._color !== void 0 ? this._color : null;
  }
  getAlpha() {
    return this._alpha !== void 0 ? this._alpha : null;
  }
}
var ei = /* @__PURE__ */ ((s) => (s[s.Id = 1] = "Id", s[s.Name = 2] = "Name", s[s.Visiblity = 4] = "Visiblity", s[s.Transform = 8] = "Transform", s[s.SubNodes = 16] = "SubNodes", s[s.Instance = 32] = "Instance", s[s.InstanceQuickAccess = 64] = "InstanceQuickAccess", s[s.BodyInstances = 128] = "BodyInstances", s[s.Attributes = 256] = "Attributes", s[s.PartDataLink = 512] = "PartDataLink", s[s.Bodies = 1024] = "Bodies", s[s.FaceMeasurement = 2048] = "FaceMeasurement", s[s.EdgeMeasurement = 4096] = "EdgeMeasurement", s[s.MeshKey = 8192] = "MeshKey", s[s.Unit = 16384] = "Unit", s[s.Views = 32768] = "Views", s[s.Pmis = 65536] = "Pmis", s[s.ScInclusionKey = 131072] = "ScInclusionKey", s[s.ScInstanceKey = 262144] = "ScInstanceKey", s[s.ExternalModel = 524288] = "ExternalModel", s[s.PhysicalProperties = 1048576] = "PhysicalProperties", s[s.VersionNumber = 2097152] = "VersionNumber", s[s.ProductBits = 4194304] = "ProductBits", s[s.Header = 8388608] = "Header", s[s.FrontUpVector = 16777216] = "FrontUpVector", s[s.ExchangeId = 33554432] = "ExchangeId", s[s.LayerId = 67108864] = "LayerId", s[s.LayerList = 134217728] = "LayerList", s[s.Filters = 268435456] = "Filters", s[s.UserData = 536870912] = "UserData", s[s.UseNodeParseBits2 = 1073741824] = "UseNodeParseBits2", s))(ei || {}), _r = /* @__PURE__ */ ((s) => (s[s.FaceAttributes = 1] = "FaceAttributes", s[s.EdgeAttributes = 2] = "EdgeAttributes", s[s.OriginalName = 4] = "OriginalName", s[s.GenericTypes = 8] = "GenericTypes", s[s.GenericTypeId = 16] = "GenericTypeId", s[s.GenericId = 32] = "GenericId", s[s.DoublePrecisionMatrices = 64] = "DoublePrecisionMatrices", s[s.PointAttributes = 128] = "PointAttributes", s[s.Relationships = 256] = "Relationships", s[s.Modifiers = 512] = "Modifiers", s))(_r || {}), vn = /* @__PURE__ */ ((s) => (s[s.Name = 1] = "Name", s[s.Camera = 2] = "Camera", s[s.Pmi = 4] = "Pmi", s[s.Frame = 8] = "Frame", s[s.ShowNodes = 16] = "ShowNodes", s[s.HideNodes = 32] = "HideNodes", s[s.MoveNodes = 64] = "MoveNodes", s[s.CuttingPlanes = 128] = "CuttingPlanes", s[s.IsAnnotationView = 256] = "IsAnnotationView", s[s.IsNotCameraSet = 512] = "IsNotCameraSet", s[s.IsNotPmiFilteringSet = 1024] = "IsNotPmiFilteringSet", s[s.IsNotGeomFilteringSet = 2048] = "IsNotGeomFilteringSet", s[s.IsNotCrosssectionSet = 4096] = "IsNotCrosssectionSet", s[s.IsNotExplosionSet = 8192] = "IsNotExplosionSet", s[s.IsCombineState = 16384] = "IsCombineState", s[s.IsPerspective = 32768] = "IsPerspective", s[s.IsDefaultView = 65536] = "IsDefaultView", s[s.ViewFilters = 131072] = "ViewFilters", s))(vn || {}), la = /* @__PURE__ */ ((s) => (s[s.Name = 1] = "Name", s[s.TopoRef = 2] = "TopoRef", s[s.Attributes = 4] = "Attributes", s[s.InitiallyHidden = 8] = "InitiallyHidden", s[s.HasMultipleBodies = 16] = "HasMultipleBodies", s[s.ExchangeId = 32] = "ExchangeId", s))(la || {}), dc = /* @__PURE__ */ ((s) => (s[s.Name = 1] = "Name", s[s.LayerItem = 2] = "LayerItem", s[s.EntityItem = 4] = "EntityItem", s[s.ScId = 8] = "ScId", s))(dc || {}), Jm = /* @__PURE__ */ ((s) => (s[s.Name = 1] = "Name", s))(Jm || {}), Pf = /* @__PURE__ */ ((s) => (s[s.ValueName = 1] = "ValueName", s[s.Units = 2] = "Units", s))(Pf || {}), Cu = /* @__PURE__ */ ((s) => (s[s.Type = 1] = "Type", s[s.Related = 2] = "Related", s[s.Relating = 4] = "Relating", s))(Cu || {}), Dn = /* @__PURE__ */ ((s) => (s[s.BeforeAction = 0] = "BeforeAction", s[s.AfterAction = 1] = "AfterAction", s))(Dn || {});
function Sv(s, t) {
  let e = 0;
  for (let i = 0; i < s.length; ++i) {
    const n = s[i];
    t(n) && (s[e++] = n);
  }
  s.length = e;
}
class Is {
  /**
   * Creates a new lazy value, which is the result of the supplied function
   * once the lazy value is forced.
   */
  static create(t) {
    return new Is(t);
  }
  constructor(t) {
    this._deferredValue = t;
  }
  /**
   * Forces the lazy value given at construction and returns it.
   */
  get() {
    return this._deferredValue !== null && (this._resolvedValue = this._deferredValue(), this._deferredValue = null), this._resolvedValue;
  }
}
const Pv = 1024;
class Rp {
  constructor() {
    this.items = [], this.next = null;
  }
}
class Ym {
  constructor() {
    this.clear();
  }
  clear() {
    this._head = new Rp(), this._tail = this._head, this._size = 0;
  }
  get length() {
    return this._size;
  }
  push(t) {
    if (++this._size, this._tail.items.length === Pv) {
      const e = new Rp();
      this._tail.next = e, this._tail = e;
    }
    this._tail.items.push(t);
  }
  pop() {
    console.assert(this._size > 0), console.assert(this._head.items.length > 0), --this._size;
    const t = this._head.items.shift();
    if (this._head.items.length === 0) {
      const e = this._head.next;
      e === null ? console.assert(this._head === this._tail) : this._head = e;
    }
    return t;
  }
}
function wi() {
  let s, t;
  const e = new Promise((i, n) => {
    s = i, t = n;
  });
  return e.resolve = s, e.reject = t, e;
}
class Ac {
  /**
   * Creates a new [ActionQueue]
   * @param maxActivePromises Max number of promises to leave open before they begin getting deferred
   * @param suppressFailures Whether or not rejected promises and actions that throw cause the queue to fail
   */
  constructor(t, e) {
    this._failed = !1, this._failureError = null, this._activePromiseCount = 0, this._idlePromise = null, console.assert(t > 0, "Don't create a non-progressible queue."), this._maxActivePromises = t, this._suppressFailures = e, this._deferredActions = new Ym();
  }
  /**
   * Returns `true` if there are no actions waiting to be evaluated
   * @returns Boolean indicating idle status
   */
  isIdle() {
    return this._activePromiseCount === 0;
  }
  /**
   * Returns a `Promise<void>` that resolves when all actions have been completed or rejects if there
   * was a failure
   *
   * It should be noted that if the queue is configured not to suppress failures and an action throws an error,
   * any deferred actions (actions that were queued but not active at the time of the failure) will be
   * cleared from the queue and will not be evaluated
   * @returns A promise that resolves/rejects when all actions have been completed
   */
  async waitForIdle() {
    if (this.isIdle()) {
      if (this._failed)
        throw this._failureError;
      return;
    }
    return this._idlePromise === null && (this._idlePromise = wi()), this._idlePromise;
  }
  /**
   * Pushes a new [ActionLike] to be evaluated onto the queue
   * @param action
   */
  push(t) {
    typeof t == "function" && (t = Is.create(t)), this._activePromiseCount < this._maxActivePromises ? (console.assert(this._deferredActions.length === 0), this._immediateAction(t)) : this._deferredActions.push(t);
  }
  _immediateAction(t) {
    if (this._failed)
      return console.assert(this._deferredActions.length === 0), !0;
    let e;
    try {
      e = t.get();
    } catch (i) {
      this._suppressFailures || (this._failed = !0, this._failureError = i, this._deferredActions.clear());
    }
    return e === void 0 ? !0 : (++this._activePromiseCount, e.then((i) => (this._finalizePromise(), i)).catch((i) => {
      throw this._finalizePromise(), i;
    }), !1);
  }
  _finalizePromise() {
    if (--this._activePromiseCount, this._failed && console.assert(this._deferredActions.length === 0), this._deferredActions.length > 0)
      do {
        const t = this._deferredActions.pop();
        if (!this._immediateAction(t))
          break;
      } while (this._deferredActions.length > 0);
    this._tryActivateIdlePromise();
  }
  _tryActivateIdlePromise() {
    this._activePromiseCount === 0 && (console.assert(this._deferredActions.length === 0), this._idlePromise !== null && (this._failed ? this._idlePromise.reject(this._failureError) : this._idlePromise.resolve(), this._idlePromise = null));
  }
}
class fo {
  /**
   * Creates a new `CurrentAction`.
   * @param suppressFailures Controls whether or not thrown action errors cause `waitForIdle` to throw.
   */
  constructor(t) {
    this._active = null, this._pending = null, this._idlePromise = null, this._suppressFailures = t;
  }
  /**
   * Queries the idle state of this object.
   * @return `true` if there are no executing actions and `false` otherwise.
   */
  isIdle() {
    return this._active === null;
  }
  /**
   * Creates `Promise` that can be used to wait for this object to become idle.
   *
   * If this object was created with `suppressFailures`, then the returned `Promise`
   * never throws. Otherwise action failures (from `this.set`) propagate to the returned `Promise`.
   *
   * @return The idle `Promise`.
   */
  waitForIdle() {
    return this.isIdle() ? Promise.resolve() : (this._idlePromise === null && (this._idlePromise = wi()), this._idlePromise);
  }
  /**
   * Sets the action to execute to the one supplied.
   *
   * If this object is idle, then the action is immediately executed,
   * and this object is no longer as long as the action is running.
   *
   * Otherwise if the object is not idle, then action becomes pended
   * and will execute after the current one finishes. If an action is
   * already pended, then the prior pending action is replaced by the
   * newly supplied action and is discarded.
   *
   * @param action
   */
  set(t) {
    if (typeof t == "function" && (t = Is.create(t)), this._active === null) {
      let e;
      try {
        e = t.get();
      } catch (i) {
        return this._advance(!this._suppressFailures, i);
      }
      if (e === void 0)
        return this._advance(!1, null);
      this._active = e.then(() => {
        this._advance(!1, null);
      }).catch((i) => {
        this._advance(!this._suppressFailures, i);
      });
    } else
      this._pending = t;
  }
  _advance(t, e) {
    if (this._active = null, t && (this._pending = null), this._pending === null)
      this._idlePromise !== null && (t ? this._idlePromise.reject(e) : this._idlePromise.resolve(), this._idlePromise = null);
    else {
      const i = this._pending;
      this._pending = null, this.set(i);
    }
  }
  /**
   * Clears and discards any pending actions. If an action is
   * currently being executed, it remains unaffected by this.
   */
  clear() {
    this._pending = null;
  }
}
function Ge(s) {
  return Promise.all(s);
}
class kv {
  constructor(t) {
    this.promise = wi(), this.ids = t;
  }
}
class Mv {
  constructor() {
    this._aliasMap = /* @__PURE__ */ new Map(), this._callbackMap = /* @__PURE__ */ new Map(), this._activeTriggerDepth = 0, this._pendingClearUnboundFilteredNames = /* @__PURE__ */ new Set(), this._aliasMap.set("sceneRendered", "frameDrawn");
  }
  _filterName(t) {
    const e = this._aliasMap.get(t);
    return e === void 0 ? t : e;
  }
  bind(t, e) {
    const i = Object.keys(t);
    for (const n of i) {
      const r = t[n];
      if (typeof r == "function") {
        const o = this._filterName(n), l = this._callbackMap.get(o);
        l === void 0 ? this._callbackMap.set(o, [r]) : e ? l.unshift(r) : l.push(r);
      }
    }
  }
  unbind(t) {
    const e = Object.keys(t);
    for (const i of e) {
      const n = this._filterName(i), r = this._callbackMap.get(n);
      if (r !== void 0) {
        const o = t[i];
        for (let l = 0; l < r.length; l++)
          r[l] === o && (r[l] = null, this._pendingClearUnboundFilteredNames.add(n));
      }
    }
    this._clearUnboundCallbacks();
  }
  _clearUnboundCallbacks() {
    this._pendingClearUnboundFilteredNames.size !== 0 && this._activeTriggerDepth === 0 && (this._pendingClearUnboundFilteredNames.forEach((t) => {
      let e = this._callbackMap.get(t);
      e !== void 0 && (e = e.filter((i) => i !== null), e.length === 0 ? this._callbackMap.delete(t) : this._callbackMap.set(t, e));
    }), this._pendingClearUnboundFilteredNames.clear());
  }
  async promiseTrigger(t, e, ...i) {
    console.assert(t !== e);
    try {
      await this._unsafePromiseTrigger(t, i);
    } catch (n) {
      console.error(`Rejected promise in '${t}' callback:`, n);
    } finally {
      e !== null && this.unsafeTrigger(e, i);
    }
  }
  // Unsafe from a type safety point of view.
  _unsafePromiseTrigger(t, e) {
    const i = this._filterName(t), n = this._callbackMap.get(i), r = [];
    if (n !== void 0) {
      ++this._activeTriggerDepth;
      for (const o of n)
        if (o !== null)
          try {
            r.push(o(...e ?? []));
          } catch (l) {
            console.error(`Unhandled exception in '${t}' callback:`, l);
          }
      --this._activeTriggerDepth, this._clearUnboundCallbacks();
    }
    return Ge(r);
  }
  trigger(t, ...e) {
    this.unsafeTrigger(t, e);
  }
  // Unsafe from a type safety point of view.
  unsafeTrigger(t, e) {
    const i = this._filterName(t), n = this._callbackMap.get(i);
    if (n !== void 0) {
      ++this._activeTriggerDepth;
      for (const r of n)
        if (r !== null)
          try {
            r(...e ?? []);
          } catch (o) {
            console.error(`Unhandled exception in '${t}' callback:`, o);
          }
      --this._activeTriggerDepth, this._clearUnboundCallbacks();
    }
  }
}
var Zm = /* @__PURE__ */ ((s) => (s[s.Undefined = 0] = "Undefined", s[s.Line = 1] = "Line", s[s.Circle = 2] = "Circle", s[s.Other = 6] = "Other", s))(Zm || {}), Qm = /* @__PURE__ */ ((s) => (s[s.Undefined = 0] = "Undefined", s[s.Cylinder = 3] = "Cylinder", s[s.Plane = 4] = "Plane", s[s.Cone = 5] = "Cone", s[s.Other = 6] = "Other", s[s.Sphere = 7] = "Sphere", s[s.Torus = 8] = "Torus", s[s.Blend01 = 9] = "Blend01", s[s.Blend02 = 10] = "Blend02", s[s.Blend03 = 11] = "Blend03", s[s.Nurbs = 12] = "Nurbs", s[s.Cylindrical = 13] = "Cylindrical", s[s.Offset = 14] = "Offset", s[s.Pipe = 15] = "Pipe", s[s.Ruled = 16] = "Ruled", s[s.Revolution = 17] = "Revolution", s[s.Extrusion = 18] = "Extrusion", s[s.FromCurves = 19] = "FromCurves", s[s.Transform = 20] = "Transform", s))(Qm || {});
let yh = class kf {
  constructor(t) {
    this.length = t;
  }
  static fromJson(t) {
    return new kf(t.length);
  }
  copy() {
    return new kf(this.length);
  }
  type() {
    return 1;
  }
}, Ol = class Mf {
  constructor(t, e, i) {
    this.radius = t, this.origin = e.copy(), this.normal = i.copy();
  }
  static fromJson(t) {
    const e = t.radius, i = new _(t.origin.x, t.origin.y, t.origin.z), n = new _(t.normal.x, t.normal.y, t.normal.z);
    return new Mf(e, i, n);
  }
  copy() {
    return new Mf(this.radius, this.origin, this.normal);
  }
  type() {
    return 2;
  }
};
class Ho {
  constructor(t) {
    this.length = t;
  }
  static fromJson(t) {
    return new Ho(t.length);
  }
  copy() {
    return new Ho(this.length);
  }
  type() {
    return 6;
  }
}
class wh {
  copy() {
    return new wh();
  }
  type() {
    return 6;
  }
}
class Li {
  constructor(t, e, i) {
    this.radius = t, this.origin = e.copy(), this.normal = i.copy();
  }
  static fromJson(t) {
    const e = t.radius, i = new _(t.origin.x, t.origin.y, t.origin.z), n = new _(t.normal.x, t.normal.y, t.normal.z);
    return new Li(e, i, n);
  }
  copy() {
    return new Li(this.radius, this.origin, this.normal);
  }
  type() {
    return 3;
  }
}
class Wi {
  constructor(t, e) {
    this.origin = t.copy(), this.normal = e.copy();
  }
  static fromJson(t) {
    const e = new _(t.origin.x, t.origin.y, t.origin.z), i = new _(t.normal.x, t.normal.y, t.normal.z);
    return new Wi(e, i);
  }
  copy() {
    return new Wi(this.origin, this.normal);
  }
  type() {
    return 4;
  }
}
class Ca {
  constructor(t, e, i, n) {
    this.radius = t, this.origin = e.copy(), this.normal = i.copy(), this.halfAngle = n;
  }
  static fromJson(t) {
    const e = t.radius, i = t.halfAngle, n = new _(t.origin.x, t.origin.y, t.origin.z), r = new _(t.normal.x, t.normal.y, t.normal.z);
    return new Ca(e, n, r, i);
  }
  copy() {
    return new Ca(this.radius, this.origin, this.normal, this.halfAngle);
  }
  type() {
    return 5;
  }
}
class Sa {
  constructor(t, e, i) {
    this.radius = t, this.origin = e.copy(), this.normal = i.copy();
  }
  static fromJson(t) {
    const e = t.radius, i = new _(t.origin.x, t.origin.y, t.origin.z), n = new _(t.normal.x, t.normal.y, t.normal.z);
    return new Sa(e, i, n);
  }
  copy() {
    return new Sa(this.radius, this.origin, this.normal);
  }
  type() {
    return 7;
  }
}
class Pa {
  constructor(t, e, i, n) {
    this.majorRadius = t, this.minorRadius = e, this.origin = i.copy(), this.normal = n.copy();
  }
  static fromJson(t) {
    const e = new _(t.origin.x, t.origin.y, t.origin.z), i = new _(t.normal.x, t.normal.y, t.normal.z), n = t.majRadius, r = t.minRadius;
    return new Pa(n, r, e, i);
  }
  copy() {
    return new Pa(this.majorRadius, this.minorRadius, this.origin, this.normal);
  }
  type() {
    return 8;
  }
}
class vh {
  copy() {
    return new vh();
  }
  type() {
    return 9;
  }
}
class bh {
  copy() {
    return new bh();
  }
  type() {
    return 10;
  }
}
class xh {
  copy() {
    return new xh();
  }
  type() {
    return 11;
  }
}
class Ih {
  copy() {
    return new Ih();
  }
  type() {
    return 12;
  }
}
class Ch {
  copy() {
    return new Ch();
  }
  type() {
    return 13;
  }
}
class Sh {
  copy() {
    return new Sh();
  }
  type() {
    return 14;
  }
}
class Ph {
  copy() {
    return new Ph();
  }
  type() {
    return 15;
  }
}
class kh {
  copy() {
    return new kh();
  }
  type() {
    return 16;
  }
}
class Mh {
  copy() {
    return new Mh();
  }
  type() {
    return 17;
  }
}
class Eh {
  copy() {
    return new Eh();
  }
  type() {
    return 18;
  }
}
class Ah {
  copy() {
    return new Ah();
  }
  type() {
    return 19;
  }
}
class Th {
  copy() {
    return new Th();
  }
  type() {
    return 20;
  }
}
function pd() {
  let s, t;
  const e = new Promise((i, n) => {
    s = (r) => {
      e.state = jr.Resolved, i(r);
    }, t = (r) => {
      e.state = jr.Rejected, n(r);
    };
  });
  return e.state = jr.Pending, e.resolve = s, e.reject = t, e;
}
function No(s, t) {
  const e = new Promise((i, n) => {
    t.then(() => {
      e.isReady = !0, i(s);
    }, n);
  });
  return e.unsafeValue = s, e.readyPromise = t, e.isReady = !1, e;
}
class Cs {
  constructor() {
    this._faceMeshData = [], this._pointMeshData = [], this._polylineMeshData = [], this._faceWinding = Zs.CounterClockwise, this._backfacesEnabled = !1, this._isManifold = !1;
  }
  /**
   * Adds face data to the mesh. Note that the arrays passed into this function are not copied and should remain unchanged until the mesh has been created.
   * When adding vertex data into the mesh using this method, it is important to note that the data is interpreted as triangles in which each vertex must be explicitly enumerated.
   * @param vertexData floating point data describing the points in space for the faces to be added to the mesh
   * @param normalData normals for the corresponding vertex data points.
   * @param rgba32data colors for the corresponding vertex data points (four bytes per rbga).
   * @param uvs texture parameters for the corresponding vertex data points.
   * @param bits bitmask associated with the face.
   */
  addFaces(t, e, i, n, r = 0) {
    this._faceMeshData.push(new Ev(t, e, i, n, r));
  }
  /**
   * Adds point data to the mesh. Note that the arrays passed into this function are not copied and should remain unchanged until the mesh has been created.
   * @param pointData floating point data describing the points to be added to the mesh
   * @param rgba32data colors for the corresponding vertex data points (four bytes per rbga).
   * @param bits bitmask associated with the point.
   */
  addPoints(t, e, i = 0) {
    this._pointMeshData.push(new Tv(t, e, i));
  }
  /**
   * Adds polyline data to the mesh.Note that the arrays passed into this function are not copied and should remain unchanged until the mesh has been created.
   * @param polylineData floating point data describing the polyline to be added to the mesh
   * @param rgba32data colors for the corresponding vertex data points (four bytes per rbga).
   * @param bits bitmask associated with the line.
   */
  addPolyline(t, e, i = 0) {
    this._polylineMeshData.push(new Av(t, e, i));
  }
  /**
   * Removes all data from the object.
   */
  clear() {
    this._faceMeshData.length = 0, this._pointMeshData.length = 0, this._polylineMeshData.length = 0;
  }
  /**
   * Sets the face winding to be used for this mesh. The default value is CounterClockwise.
   * @param faceWinding the face winding to use for mesh geometry.
   */
  setFaceWinding(t) {
    this._faceWinding = t;
  }
  /**
   * Gets the face winding used for this mesh.
   */
  getFaceWinding() {
    return this._faceWinding;
  }
  /**
   * Sets whether backfaces should be enabled for this geometry. The default value is false.
   * Setting this to true for geometry with a large amount of faces may affect performance.
   * @param backfacesEnabled indicated whether backfaces should be enabled for this geometry.
   */
  setBackfacesEnabled(t) {
    this._backfacesEnabled = t;
  }
  /**
   * Gets whether backfaces are enabled for this geometry
   * @returns value indicting whether backfaces are enabled for this geometry.
   */
  getBackfacesEnabled() {
    return this._backfacesEnabled;
  }
  /**
   * Sets whether the mesh is a manifold one or not (if the mesh is not set as manifold, then capping won't happen while cutting).
   * @param isManifold indicated whether or not it's a manifold mesh.
   */
  setManifold(t) {
    this._isManifold = t;
  }
  /**
   * Gets if the mesh is set as manifold.
   * @returns value indicating whether or not it's a manifold mesh.
   */
  isManifold() {
    return this._isManifold;
  }
  /** @hidden */
  _getFaceData() {
    return this._faceMeshData;
  }
  /** @hidden */
  _getPointData() {
    return this._pointMeshData;
  }
  /** @hidden */
  _getPolylineData() {
    return this._polylineMeshData;
  }
}
class Qs {
  /**
   * Creates a new MeshInstanceData object.
   * @param meshId the [[MeshId]] of the mesh to instantiate
   * @param matrix a matrix that will be applied to this instance
   * @param instanceName a name that will be visible when querying the model hierarchy
   * @param faceColor the color for faces of this instance
   * @param lineColor the color for lines of this instance
   * @param pointColor the color for points of this instance
   * @param creationFlags additional options that can be used to alter the behavior of this instance
   */
  constructor(t, e, i, n, r, o, l) {
    this._meshId = null, this._matrix = null, this._faceColor = null, this._lineColor = null, this._pointColor = null, this._instanceName = null, this._faceOpacity = 1, this._lineOpacity = 1, this._pointOpacity = 1, this._creationFlags = ee.None, this.overlayId = { viewKey: Me.Default, overayIndex: 0 }, t && (this._meshId = t.slice()), e && (this._matrix = e.copy()), i && (this._instanceName = i), n && (this._faceColor = n.copy()), r && (this._lineColor = r.copy()), o && (this._pointColor = o.copy()), l && (this._creationFlags = l);
  }
  /**
   * Creates a copy of this MeshInstanceData.
   * @returns Copy of this MeshInstanceData object.
   */
  copy() {
    const t = new Qs(
      this.getMeshId(),
      this.getMatrix(),
      this.getInstanceName(),
      this.getFaceColor(),
      this.getLineColor(),
      this.getPointColor(),
      this.getCreationFlags()
    );
    return t.setPointOpacity(this.getOpacity()), t.setLineOpacity(this.getLineOpacity()), t.setOpacity(this.getOpacity()), t.overlayId = Object.assign({}, this.overlayId), t;
  }
  /**
   * Resets all fields of this object.
   */
  clear() {
    this._meshId = null, this._matrix = null, this._faceColor = null, this._lineColor = null, this._pointColor = null, this._instanceName = null, this._faceOpacity = 1, this._lineOpacity = 1, this._pointOpacity = 1, this._creationFlags = ee.None, this.overlayId = { viewKey: Me.Default, overayIndex: 0 };
  }
  /**
   * Gets the [[MeshId]] of the mesh to use for this instance.
   * [[MeshId]]s are created with [[Model.createMesh]] or retrieved with [[Model.getMeshIds]].
   * @returns the mesh ID to use for this instance.
   */
  getMeshId() {
    return this._meshId !== null ? this._meshId.slice() : null;
  }
  /**
   * Sets the [[MeshId]] of the mesh to use for the instance.
   * [[MeshId]]s are created with [[Model.createMesh]] or retrieved with [[Model.getMeshIds]].
   * @param meshId the [[MeshId]] to use.
   */
  setMeshId(t) {
    this._meshId = t.slice();
  }
  /**
   * Gets the matrix to apply to this instance.
   * @returns the current matrix that will be applied to this instance upon creation.
   */
  getMatrix() {
    return this._matrix !== null ? this._matrix.copy() : null;
  }
  /**
   * Gets the mesh instance creation flags (SuppressCameraScale, DoNotExplode, DoNotLight...)
   * @returns the mesh instance creation flags (null if none set)
   */
  getCreationFlags() {
    return this._creationFlags;
  }
  /**
   * Sets the mesh instance creation flags (SuppressCameraScale, DoNotExplode, DoNotLight...)
   * @param flags creation flags
   */
  setCreationFlags(t) {
    this._creationFlags = t;
  }
  /**
   * Sets the matrix that will be applied to this instance.
   * @param matrix the matrix to apply.
   */
  setMatrix(t) {
    this._matrix = t.copy();
  }
  /**
   * Gets the name that will be applied to the instance.
   * @returns the instance name.
   */
  getInstanceName() {
    return this._instanceName;
  }
  /**
   * Sets the name that will be assigned to this instance. This name will be visible when querying the model hierarchy.
   * @param instanceName the name to assign to this instance.
   */
  setInstanceName(t) {
    this._instanceName = t;
  }
  /**
   * Sets the color for face elements in this instance.
   * @param faceColor the color to apply to face elements.
   */
  setFaceColor(t) {
    this._faceColor = t.copy();
  }
  /**
   * Gets the color for face elements in this instance.
   * @returns the color for face elements.
   */
  getFaceColor() {
    return this._faceColor !== null ? this._faceColor.copy() : null;
  }
  /**
   * Sets the color for line elements in this instance.
   * @param lineColor the color to apply to line elements.
   */
  setLineColor(t) {
    this._lineColor = t.copy();
  }
  /**
   * Gets the color for line elements in this instance.
   * @returns the color for line elements.
   */
  getLineColor() {
    return this._lineColor !== null ? this._lineColor.copy() : null;
  }
  /**
   * Sets the color for point elements in this instance.
   * @param pointColor the color to apply to point elements.
   */
  setPointColor(t) {
    this._pointColor = t.copy();
  }
  /**
   * Gets the color for point elements in this instance.
   * @returns the color for point elements.
   */
  getPointColor() {
    return this._pointColor !== null ? this._pointColor.copy() : null;
  }
  /**
   * Sets the point opacity for this instance.
   * @param pointOpacity opacity value to set.
   */
  setPointOpacity(t) {
    this._pointOpacity = t;
  }
  /**
   * Gets the point opacity value for this instance.
   * @returns the point opacity value for this instance.
   */
  getPointOpacity() {
    return this._pointOpacity;
  }
  /**
   * Sets the line opacity for this instance.
   * @param lineOpacity opacity value to set.
   */
  setLineOpacity(t) {
    this._lineOpacity = t;
  }
  /**
   * Gets the line opacity value for this instance.
   * @returns the line opacity value for this instance.
   */
  getLineOpacity() {
    return this._lineOpacity;
  }
  /**
   * Sets the face opacity for this instance.
   * @param faceOpacity opacity value to set.
   */
  setOpacity(t) {
    this._faceOpacity = t;
  }
  /**
   * Gets the face opacity value for this instance.
   * @returns the face opacity value for this instance.
   */
  getOpacity() {
    return this._faceOpacity;
  }
  /**
   * Sets the overlay index for this instance but doesn't change the associated view.
   * @param overlayIndex overlay index to set.
   * @deprecated use [[overlayId]] instead.
   */
  setOverlayIndex(t) {
    this.overlayId.overayIndex = t;
  }
  /**
   * Gets the overlay index for this instance.
   * @returns the overlay index for this instance, but not the associated view.
   * @deprecated use [[overlayId]] instead.
   */
  getOverlayIndex() {
    return this.overlayId.overayIndex;
  }
}
class Ev {
  constructor(t, e, i, n, r = 0) {
    this.vertexData = t, this.normalData = e, this.rgba32data = i, this.uvData = n, this.bits = r;
  }
}
class Av {
  constructor(t, e, i = 0) {
    this.vertexData = t, this.rgba32data = e, this.bits = i;
  }
}
class Tv {
  constructor(t, e, i = 0) {
    this.vertexData = t, this.rgba32data = e, this.bits = i;
  }
}
function t_() {
  const s = (1 + Math.sqrt(5)) / 2, t = Math.sqrt(10 + 2 * Math.sqrt(5)) / (4 * s), e = t / 2, i = t / (2 * s), n = [];
  n[0] = new _(-i, e, 0), n[1] = new _(i, e, 0), n[2] = new _(-i, -e, 0), n[3] = new _(i, -e, 0), n[4] = new _(0, -i, e), n[5] = new _(0, i, e), n[6] = new _(0, -i, -e), n[7] = new _(0, i, -e), n[8] = new _(e, 0, -i), n[9] = new _(e, 0, i), n[10] = new _(-e, 0, -i), n[11] = new _(-e, 0, i);
  for (const g of n)
    g.normalize();
  let r = [
    [0, 11, 5],
    [0, 5, 1],
    [0, 1, 7],
    [0, 7, 10],
    [0, 10, 11],
    [1, 5, 9],
    [5, 11, 4],
    [11, 10, 2],
    [10, 7, 6],
    [7, 1, 8],
    [3, 9, 4],
    [3, 4, 2],
    [3, 2, 6],
    [3, 6, 8],
    [3, 8, 9],
    [4, 9, 5],
    [2, 4, 11],
    [6, 2, 10],
    [8, 6, 7],
    [9, 8, 1]
  ], o = 12;
  const l = 2;
  for (let g = 0; g < l; g++) {
    const y = [];
    r.map((m) => {
      const x = n[m[0]], b = n[m[1]], I = n[m[2]];
      n[o++] = new _(x.x + b.x, x.y + b.y, x.z + b.z).scale(0.5).normalize(), n[o++] = new _(b.x + I.x, b.y + I.y, b.z + I.z).scale(0.5).normalize(), n[o++] = new _(I.x + x.x, I.y + x.y, I.z + x.z).scale(0.5).normalize(), y.push([m[0], o - 3, o - 1]), y.push([o - 3, o - 2, o - 1]), y.push([o - 3, m[1], o - 2]), y.push([o - 2, m[2], o - 1]);
    }), r = y;
  }
  const h = [], u = [];
  for (const g of r)
    for (let y = 0; y < 3; y++) {
      const m = g[y];
      h.push(n[m].x), h.push(n[m].y), h.push(n[m].z);
      const x = n[m].normalize();
      u.push(x.x), u.push(x.y), u.push(x.z);
    }
  const d = new Cs();
  return d.addFaces(h, u), d.setFaceWinding(Zs.CounterClockwise), d;
}
function dg(s, t, e, i, n, r) {
  const o = new mt(), l = Dv(
    i,
    t,
    e + r,
    n,
    o
  ), h = Nv(s, t, e, o), u = Ov(
    s,
    i,
    t,
    e,
    r
  ), d = l[0].concat(h[0]).concat(u[0]), g = l[1].concat(h[1]).concat(u[1]), y = new Cs();
  return y.setFaceWinding(Zs.Clockwise), y.addFaces(d, g), y;
}
function e_(s) {
  const t = Math.PI * 2 / s, e = [];
  for (let i = 0; i < s; i++) {
    const n = i * t, r = Math.cos(n), o = Math.sin(n);
    e.push(r), e.push(o);
  }
  return e;
}
function Mo(s, t, e, i = 1) {
  let n = _.cross(e, new _(0, 1, 0));
  n.length() < 1e-3 && (n = _.cross(e, new _(0, 0, 1)));
  const r = _.cross(n, e), o = Math.PI * 2 / s, l = [];
  for (let h = 0; h < s; h++) {
    const u = h * o, d = Math.sin(u), g = Math.cos(u), y = n.copy().scale(d).add(r.copy().scale(g)).scale(i).add(t);
    l.push(y);
  }
  return l;
}
function i_(s, t, e, i) {
  const o = [], l = [];
  let h;
  for (let k = 0; k < s.length - 3; k += 3) {
    const O = new _(s[k], s[k + 1], s[k + 2]), B = new _(s[k + 3], s[k + 4], s[k + 5]), j = Mo(e, O, t, i), V = Mo(e, B, t, i);
    h = Su(O, B, j, V, !1), Array.prototype.push.apply(o, h[0]), Array.prototype.push.apply(l, h[1]);
  }
  const u = s.length;
  let d = new _(s[u - 3], s[u - 2], s[u - 1]), g = d.copy().subtract(new _(s[u - 6], s[u - 5], s[u - 4])).normalize(), y = Mo(
    e * 2,
    d,
    t,
    i
  ), m = d.copy().add(g.copy().scale(2 / 3)), x = Mo(
    e * 2,
    m,
    t,
    i * 2
  ), b = m.copy().add(g.copy().scale(2));
  h = Su(
    d,
    m,
    y,
    x,
    !1
  ), Array.prototype.push.apply(o, h[0]), Array.prototype.push.apply(l, h[1]);
  for (let k = 0; k < y.length; k++) {
    const O = (k + 1) % y.length;
    o.push(b), o.push(x[k]), o.push(x[O]);
    const B = x[k].copy().subtract(m).normalize().add(b.copy().normalize()).normalize();
    l.push(B), l.push(B), l.push(B);
  }
  d = new _(s[0], s[1], s[2]), g = d.copy().subtract(new _(s[3], s[4], s[5])).normalize(), y = Mo(
    e * 2,
    d,
    t,
    i
  ), m = d.copy().add(g.copy().scale(2 / 3)), x = Mo(
    e * 2,
    m,
    t,
    i * 2
  ), b = m.copy().add(g.copy().scale(2)), h = Su(
    m,
    d,
    x,
    y,
    !1
  ), Array.prototype.push.apply(o, h[0]), Array.prototype.push.apply(l, h[1]);
  for (let k = 0; k < y.length; k++) {
    const O = (k + 1) % y.length;
    o.push(b), o.push(x[O]), o.push(x[k]);
    const B = x[k].copy().subtract(m).normalize().add(b.copy().normalize()).normalize();
    l.push(B), l.push(B), l.push(B);
  }
  const I = [], C = [];
  for (let k = 0; k < o.length; k++) {
    const O = o[k];
    I.push(O.x), I.push(O.y), I.push(O.z);
    const B = l[k];
    C.push(B.x), C.push(B.y), C.push(B.z);
  }
  const P = new Cs();
  return P.setFaceWinding(Zs.CounterClockwise), P.addFaces(I, C), P;
}
function Su(s, t, e, i, n) {
  const r = [], o = [];
  for (let l = 0; l < e.length; l++) {
    const h = (l + 1) % e.length;
    r.push(e[l]), r.push(e[h]), r.push(i[l]), r.push(e[h]), r.push(i[h]), r.push(i[l]), o.push(_.subtract(e[l], s)), o.push(_.subtract(e[h], s)), o.push(_.subtract(i[l], t)), o.push(_.subtract(e[h], s)), o.push(_.subtract(i[h], t)), o.push(_.subtract(i[l], t));
  }
  if (n) {
    const l = _.subtract(s, t);
    for (const h of o)
      h.add(l).normalize();
  }
  return [r, o];
}
function Nv(s, t, e, i) {
  const n = [], r = [], o = e_(t), l = o;
  for (let y = 0; y < l.length; y++)
    l[y] *= s;
  const h = [], u = [];
  for (let y = 0; y < l.length; y += 2) {
    const m = l[y], x = l[y + 1], b = (y + 2) % l.length, I = l[b], C = l[b + 1], P = o[y], k = o[y + 1], O = o[b], B = o[b + 1];
    h[0] = new _(m, e, x), h[1] = new _(m, 0, x), h[2] = new _(I, 0, C), h[3] = new _(I, 0, C), h[4] = new _(I, e, C), h[5] = new _(m, e, x), u[0] = new _(P, 0, k), u[1] = new _(P, 0, k), u[2] = new _(O, 0, B), u[3] = new _(O, 0, B), u[4] = new _(O, 0, B), u[5] = new _(P, 0, k);
    for (let j = 0; j < h.length; j++) {
      const V = i.transform(h[j]);
      n.push(V);
      const Y = i.transform(u[j]);
      r.push(Y);
    }
    h[0] = new _(I, 0, C), h[1] = new _(m, 0, x), h[2] = _.zero(), u[0] = new _(0, -1, 0), u[1] = new _(0, -1, 0), u[2] = new _(0, -1, 0);
    for (let j = 0; j < 3; j++) {
      const V = i.transform(h[j]);
      n.push(V);
      const Y = i.transform(u[j]);
      r.push(Y);
    }
  }
  const d = [], g = [];
  for (let y = 0; y < n.length; y++) {
    const m = n[y];
    d.push(m.x), d.push(m.y), d.push(m.z);
    const x = r[y];
    g.push(x.x), g.push(x.y), g.push(x.z);
  }
  return [d, g];
}
function Dv(s, t, e, i, n) {
  const r = e_(t), o = r;
  for (let b = 0; b < o.length; b++)
    o[b] *= s;
  const l = new _(0, e + i, 0), h = new _(0, e, 0), u = n.transform(l), d = n.transform(h), g = [], y = [];
  for (let b = 0; b < o.length; b += 2) {
    const I = o[b], C = o[b + 1], P = (b + 2) % o.length, k = o[P], O = o[P + 1], B = r[b], j = r[b + 1], V = r[P], Y = r[P + 1], q = new _(I, e, C), st = new _(k, e, O), dt = n.transform(q), U = n.transform(st);
    g.push(u), g.push(dt), g.push(U);
    const J = new _(0, 1, 0), A = new _(B, 0, j), R = new _(V, 0, Y), wt = n.transform(J), z = n.transform(A), St = n.transform(R);
    y.push(wt), y.push(z), y.push(St);
    const X = new _(I, e, C), At = new _(k, e, O), at = n.transform(X), ot = n.transform(At);
    g.push(d), g.push(ot), g.push(at);
    const Ut = new _(0, -1, 0), Pt = n.transform(Ut);
    y.push(Pt), y.push(Pt), y.push(Pt);
  }
  const m = [], x = [];
  for (let b = 0; b < g.length; b++) {
    const I = g[b];
    m.push(I.x), m.push(I.y), m.push(I.z);
    const C = y[b];
    x.push(C.x), x.push(C.y), x.push(C.z);
  }
  return [m, x];
}
function Ov(s, t, e, i, n) {
  const r = new _(0, 0, i), o = new _(0, 0, i + n), l = new _(0, 0, 1), h = Mo(e, r, l, s), u = Mo(e, o, l, t), d = Su(r, o, h, u, !0), g = [], y = [];
  for (let m = 0; m < d[0].length; m++)
    g.push(d[0][m].x), g.push(d[0][m].z), g.push(d[0][m].y), y.push(d[1][m].x), y.push(d[1][m].z), y.push(d[1][m].y);
  return [g, y];
}
function Rv(s) {
}
function $r(s) {
  throw new oi();
}
class Lv {
  constructor(t, e) {
    this._state = t, this._reducer = e;
  }
  /**
   * Handle an action and update the state
   *
   * @param evt The action to handle
   * @param payload The payload if any
   */
  handle(t, e) {
    this._state = this._reducer(this._state, { name: t, payload: e });
  }
}
function md(s) {
  return new Promise((t) => {
    setTimeout(t, s);
  });
}
function Fv(s, ...t) {
  return setTimeout(s, 0, ...t);
}
function Bv(s, t) {
  return s === t;
}
function Vv(s) {
  return s instanceof yh;
}
function zv(s) {
  return s instanceof Ol;
}
function Hv(s) {
  return s instanceof Ho;
}
function Uv(s) {
  return s instanceof Wi;
}
function jv(s) {
  return s instanceof Li || s instanceof Wi || s instanceof Ca || s instanceof Sa || s instanceof Pa || s instanceof vh || s instanceof bh || s instanceof xh || s instanceof Ih || s instanceof Ch || s instanceof Sh || s instanceof Ph || s instanceof kh || s instanceof Mh || s instanceof Eh || s instanceof Ah || s instanceof Th || s instanceof wh;
}
class Xo {
  constructor() {
    this._timerId = null, this._action = null, this._beforeActionIdlePromise = null, this._afterActionIdlePromise = null;
  }
  /**
   * Returns true if no pending action exists and false otherwise.
   */
  isIdle(t) {
    return t === Dn.BeforeAction ? this._timerId === null : this._action === null;
  }
  /**
   * Returns a promise that resolves when the timer becomes (or already is) idle.
   */
  waitForIdle(t) {
    return t === Dn.BeforeAction ? this._timerId === null ? Promise.resolve() : (this._beforeActionIdlePromise === null && (this._beforeActionIdlePromise = wi()), this._beforeActionIdlePromise) : this._action === null ? Promise.resolve() : (this._afterActionIdlePromise === null && (this._afterActionIdlePromise = wi()), this._afterActionIdlePromise);
  }
  _triggerIdlePromise(t) {
    t === Dn.BeforeAction ? this._beforeActionIdlePromise !== null && (this._beforeActionIdlePromise.resolve(), this._beforeActionIdlePromise = null) : this._afterActionIdlePromise !== null && (this._afterActionIdlePromise.resolve(), this._afterActionIdlePromise = null);
  }
  _clearTimeout() {
    this._timerId !== null && (clearTimeout(this._timerId), this._timerId = null);
  }
  /**
   * Clears the pending action if it exists.
   */
  clear() {
    this._clearTimeout(), this._triggerIdlePromise(Dn.BeforeAction), this._action = null, this._triggerIdlePromise(Dn.AfterAction);
  }
  /**
   * Sets a new delayed action. If one is already pending before this call is made, it gets cleared.
   * @param delay The delay in milliseconds to pend the action.
   * @param action The action to pend.
   */
  set(t, e) {
    this._clearTimeout(), this._action = e, this._timerId = setTimeout(() => {
      this._timerId = null, this._triggerIdlePromise(Dn.BeforeAction);
      const i = this._afterActionIdlePromise;
      this._afterActionIdlePromise = null, this._action(), this._timerId === null && (this._action = null), i !== null && i.resolve();
    }, t);
  }
}
function Wv() {
  const s = new Xo();
  s.set(0, () => {
    s.set(0, () => {
    }), s.waitForIdle(Dn.AfterAction).then(() => {
      console.log("inner-1");
    }), s.clear(), s.waitForIdle(Dn.AfterAction).then(() => {
      console.log("inner-2");
    }), s.set(0, () => {
    }), s.waitForIdle(Dn.AfterAction).then(() => {
      console.log("inner-3");
    });
  }), s.waitForIdle(Dn.AfterAction).then(() => {
    console.log("outer");
  });
}
const jC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ActionQueue: Ac,
  CurrentAction: fo,
  Lazy: Is,
  StateMachine: Lv,
  Timer: Xo,
  TimerIdleType: Dn,
  TypeAssert: Rv,
  TypeAssertNever: $r,
  _timerStressTest: Wv,
  copyMap: gd,
  copySet: yv,
  createCylinderMeshDataFromArc: i_,
  createOpenPromise: wi,
  createTrackedOpenPromise: pd,
  createUnsafePromise: No,
  delayCall: Fv,
  exchangeIdEqual: Bv,
  filterInPlace: Sv,
  generateConeCylinderMeshData: dg,
  generateSphereMeshData: t_,
  isCircleElement: zv,
  isFace: jv,
  isLineElement: Vv,
  isOtherEdgeElement: Hv,
  isPlaneElement: Uv,
  setSubtraction: Sf,
  setToArray: ao,
  sleep: md,
  toSet: Ec,
  waitForAll: Ge
}, Symbol.toStringTag, { value: "Module" }));
var jr = /* @__PURE__ */ ((s) => (s[s.Pending = 0] = "Pending", s[s.Resolved = 1] = "Resolved", s[s.Rejected = 2] = "Rejected", s))(jr || {}), ws = /* @__PURE__ */ ((s) => (s[s.Direct = 0] = "Direct", s[s.Indirect = 1] = "Indirect", s))(ws || {}), Pu = /* @__PURE__ */ ((s) => (s[s.X = 2] = "X", s[s.Y = 4] = "Y", s[s.Z = 8] = "Z", s))(Pu || {}), ku = /* @__PURE__ */ ((s) => (s[s.X = 16] = "X", s[s.Y = 32] = "Y", s[s.Z = 64] = "Z", s))(ku || {}), fc = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.EyeX_UpY = 34] = "EyeX_UpY", s[s.EyeX_UpZ = 66] = "EyeX_UpZ", s[s.EyeY_UpX = 20] = "EyeY_UpX", s[s.EyeY_UpZ = 68] = "EyeY_UpZ", s[s.EyeZ_UpX = 24] = "EyeZ_UpX", s[s.EyeZ_UpY = 40] = "EyeZ_UpY", s))(fc || {}), $s = /* @__PURE__ */ ((s) => (s[s.StemHeight = 2] = "StemHeight", s[s.CapHeight = 0.5] = "CapHeight", s[s.TaperHeight = 0.1] = "TaperHeight", s[s.SegmentCount = 20] = "SegmentCount", s[s.CylinderRadius = 0.2] = "CylinderRadius", s[s.ConeBaseRadius = 0.4] = "ConeBaseRadius", s[s.LetterOffsetPos = 0.6] = "LetterOffsetPos", s[s.LetterWidth = 0.3] = "LetterWidth", s[s.LetterHeight = 0.5] = "LetterHeight", s))($s || {}), Jn = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.Position = 1] = "Position", s[s.Target = 2] = "Target", s[s.Up = 4] = "Up", s[s.Width = 8] = "Width", s[s.Height = 16] = "Height", s[s.Projection = 32] = "Projection", s[s.NearLimit = 64] = "NearLimit", s))(Jn || {}), Xu = /* @__PURE__ */ ((s) => (s[s.Attachment = 0] = "Attachment", s[s.Model = 1] = "Model", s))(Xu || {}), Ju = /* @__PURE__ */ ((s) => (s[s.AllKeys = 0] = "AllKeys", s[s.KeyCountOnly = 1] = "KeyCountOnly", s))(Ju || {}), gc = /* @__PURE__ */ ((s) => (s[s.Add = 0] = "Add", s[s.Update = 1] = "Update", s))(gc || {}), pc = /* @__PURE__ */ ((s) => (s[s.MetaData = 0] = "MetaData", s[s.Count = 1] = "Count", s))(pc || {}), n_ = /* @__PURE__ */ ((s) => (s[s.SelectionBitsFaceHasMeasurementData = 1] = "SelectionBitsFaceHasMeasurementData", s[s.SelectionBitsFacePlanar = 2] = "SelectionBitsFacePlanar", s[s.SelectionBitsEdgeHasMeasurementData = 4] = "SelectionBitsEdgeHasMeasurementData", s))(n_ || {}), Mu = /* @__PURE__ */ ((s) => (s[s.Outside = 0] = "Outside", s[s.PartiallyInside = 1] = "PartiallyInside", s[s.FullyInside = 2] = "FullyInside", s))(Mu || {}), s_ = /* @__PURE__ */ ((s) => (s[s.Unsent = 0] = "Unsent", s[s.Opened = 1] = "Opened", s[s.HeadersRecieved = 2] = "HeadersRecieved", s[s.Loading = 3] = "Loading", s[s.Done = 4] = "Done", s))(s_ || {}), r_ = /* @__PURE__ */ ((s) => (s[s.Ok = 200] = "Ok", s))(r_ || {});
class Cn {
  constructor() {
    this._position = new _(0, 0, 1), this._target = _.zero(), this._up = new _(0, 1, 0), this._width = 0, this._height = 0, this._projection = ri.Orthographic, this._nearLimit = 0.01, this._cameraFlags = Jn.None;
  }
  /** @hidden */
  _clearFlags() {
    this._cameraFlags = Jn.None;
  }
  /** @hidden */
  _getFlags() {
    return this._cameraFlags;
  }
  /**
   * Creates a copy of the camera.
   * @returns new object initialized with the current values of this camera
   */
  copy() {
    return Cn.create(
      this._position,
      this._target,
      this._up,
      this._projection,
      this._width,
      this._height,
      this._nearLimit
    );
  }
  /**
   * Sets the camera position
   * @param position the new camera position
   */
  setPosition(t) {
    this._position.assign(t), this._cameraFlags |= Jn.Position;
  }
  /**
   * gets the camera position
   * @returns the camera position
   */
  getPosition() {
    return this._position.copy();
  }
  /**
   * Sets the camera target
   * @param target the new camera target
   */
  setTarget(t) {
    this._target.assign(t), this._cameraFlags |= Jn.Target;
  }
  /**
   * gets the camera target
   * @returns the camera target
   */
  getTarget() {
    return this._target.copy();
  }
  /**
   * Sets the camera up vector
   * @param up the new camera up vector
   */
  setUp(t) {
    this._up.assign(t), this._cameraFlags |= Jn.Up;
  }
  /**
   * gets the camera up vector
   * @returns the camera up vector
   */
  getUp() {
    return this._up.copy();
  }
  /**
   * Sets the camera width
   * @param width the new camera width
   */
  setWidth(t) {
    this._width = t, this._cameraFlags |= Jn.Width;
  }
  /**
   * gets the camera width
   * @returns the camera width
   */
  getWidth() {
    return this._width;
  }
  /**
   * Sets the camera height
   * @param height the new camera height
   */
  setHeight(t) {
    this._height = t, this._cameraFlags |= Jn.Height;
  }
  /**
   * gets the camera height
   * @returns the camera width
   */
  getHeight() {
    return this._height;
  }
  /**
   * Sets the camera projection
   * @param projection the new camera Projection
   */
  setProjection(t) {
    this._projection = t, this._cameraFlags |= Jn.Projection;
  }
  /**
   * gets the camera projection
   * @returns the camera projection
   */
  getProjection() {
    return this._projection;
  }
  /**
   * Sets the camera near clipping limit
   * @param nearLimit the new camera near clipping limit
   */
  setNearLimit(t) {
    this._nearLimit = t, this._cameraFlags |= Jn.NearLimit;
  }
  /**
   * gets the camera near clipping limit
   * @returns the camera near clipping limit
   */
  getNearLimit() {
    return this._nearLimit;
  }
  /**
   * Returns checks for equality with another camera
   * @param cam the camera to compare against
   */
  equals(t) {
    return this._position.equals(t._position) && this._target.equals(t._target) && this._up.equals(t._up) && this._width === t._width && this._height === t._height && this._projection === t._projection && this._nearLimit === t._nearLimit;
  }
  /**
   * Returns checks for equality with another camera with tolerance
   * @param cam the camera to compare against
   * @param tolerance floating point tolerance
   */
  equalsWithTolerance(t, e) {
    const i = (n, r) => Math.abs(n - r) < e;
    return this._position.equalsWithTolerance(t._position, e) && this._target.equalsWithTolerance(t._target, e) && this._up.equalsWithTolerance(t._up, e) && i(this._width, t._width) && i(this._height, t._height) && i(this._projection, t._projection) && i(this._nearLimit, t._nearLimit);
  }
  /**
   * Move the camera along a delta
   * @param delta
   */
  dolly(t) {
    this._position.subtract(t), this._target.subtract(t);
  }
  /**
   * Finds the intersection point with the camera plane
   * @param point
   * @param view
   */
  getCameraPlaneIntersectionPoint(t, e) {
    const i = _.subtract(this._position, this._target).normalize(), n = ln.createFromPointAndNormal(this._target, i), r = e.raycastFromPoint(t);
    if (r === null)
      return null;
    const o = _.zero();
    return n.intersectsRay(r, o) ? o : null;
  }
  /**
   * Returns the camera's view matrix. This matrix places the camera at
   * `<0,0,0>`, with the negative z-axis pointing toward the camera's
   * target and the y-axis in the direction of the camera's up-vector.
   * @param viewer The [[WebViewer]] for which the matrix should be valid.
   */
  getViewMatrix(t) {
    return t._getScEngine().getViewMatrix(this);
  }
  /**
   * Returns the camera's projection matrix.
   * @param viewer The [[WebViewer]] for which the matrix should be valid.
   * @param view the [[View]] to use when calculating projection effects. Uses default view if undefined
   */
  getProjectionMatrix(t, e) {
    return e = e ?? t.view, t._getScEngine().getProjectionMatrix(this, e.id);
  }
  /**
   * Returns the camera's projection matrix multiplied by its view matrix.
   * @param viewer The [[WebViewer]] for which the matrix should be valid.
   * @param view the [[View]] to use when calculating projection effects. Uses default view if undefined
   */
  getFullMatrix(t, e) {
    return e = e ?? t.view, t._getScEngine().getFullCameraMatrix(this, e.id);
  }
  /**
   * Creates a new camera object with the given parameters.
   * @param pos the camera position.
   * @param tar the camera target.
   * @param up the camera up vector.
   * @param projection the camera projection mode.
   * @param width camera view width.
   * @param height camera view height.
   * @param nearLimit the camera near limit.
   * @returns a new camera object.
   */
  static create(t, e, i, n, r, o, l) {
    const h = new Cn();
    return h._position.assign(t), h._target.assign(e), h._up.assign(i), h._projection = n, h._width = r, h._height = o, l !== void 0 && (h._nearLimit = l), h;
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      position: this._position.toJson(),
      target: this._target.toJson(),
      up: this._up.toJson(),
      width: this._width,
      height: this._height,
      projection: this._projection,
      nearLimit: this._nearLimit,
      className: "Communicator.Camera"
    };
  }
  /**
   * Creates a new [[Camera]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t) {
    const e = t, i = _.fromJson(e.position), n = _.fromJson(e.target), r = _.fromJson(e.up);
    return Cn.create(
      i,
      n,
      r,
      e.projection,
      e.width,
      e.height,
      e.nearLimit
    );
  }
  transform(t) {
    if (t.isIdentity())
      return this.copy();
    const e = Math.abs(this._width), i = Math.abs(this._height), n = this.getUp().normalize().scale(i), r = _.subtract(this._position, this._target), o = _.cross(n, r).normalize().scale(e), l = this.getTarget(), h = _.add(l, o), u = _.add(l, n), d = _.add(l, r);
    t.transform(l, l), t.transform(h, h), t.transform(u, u), t.transform(d, d);
    const g = _.subtract(h, l), y = _.subtract(u, l), m = _.subtract(d, l), x = _.add(l, m), b = l, I = y.copy().normalize();
    let C = g.length(), P = y.length();
    return this._width < 0 && (C = -C), this._height < 0 && (P = -P), Cn.create(
      x,
      b,
      I,
      this._projection,
      C,
      P,
      this._nearLimit
    );
  }
}
function Gv(s) {
  if (typeof window < "u" && s.length < 8192 && "escape" in window) {
    let l;
    try {
      const h = String.fromCharCode.apply(null, s), u = window.escape(h);
      l = decodeURIComponent(u);
    } catch {
      l = "";
    }
    return l;
  }
  let t, e, i, n, r;
  t = "";
  const o = s.length;
  for (e = 0; e < o; )
    switch (i = s[e++], i >> 4) {
      case 0:
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
      case 6:
      case 7:
        t += String.fromCharCode(i);
        break;
      case 12:
      case 13:
        n = s[e++], t += String.fromCharCode((i & 31) << 6 | n & 63);
        break;
      case 14:
        n = s[e++], r = s[e++], t += String.fromCharCode(
          (i & 15) << 12 | (n & 63) << 6 | (r & 63) << 0
        );
        break;
    }
  return t;
}
const $v = /^\d+$/;
function o_(s) {
  return $v.test(s);
}
const pu = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz`~!@#$%^&*()_+-=[]{};:'\",.<>\\|/?".split(
  ""
);
function af(s) {
  if (console.assert(s >= 0), s === 0)
    return pu[0];
  const t = [];
  for (; s !== 0; ) {
    const e = Math.floor(s / pu.length), i = s % pu.length, n = pu[i];
    t.push(n), s = e;
  }
  return t.join("");
}
const qv = ["0000000", "000000", "00000", "0000", "000", "00", "0", ""];
function Kv(s) {
  const t = s.toString(16);
  return qv[t.length - 1] + t;
}
class gi {
  static _parseUint_32(t) {
    if (!o_(t))
      return null;
    const e = parseInt(t, 10);
    return e <= 4294967295 ? e : null;
  }
  static _parseFloat(t) {
    const e = parseFloat(t);
    return isNaN(e) ? null : e;
  }
  static parseFloat(t, e) {
    const i = t.getAttribute(e);
    return i === null ? null : this._parseFloat(i);
  }
  static _parseScKey(t, e) {
    const i = t.getAttribute(e);
    return i === null ? null : this._parseUint_32(i);
  }
  static parseDataKey(t, e) {
    return this._parseScKey(t, e);
  }
  static parseMeshKey(t, e) {
    return this._parseScKey(t, e);
  }
  static parseInstanceKeyFromInc(t, e) {
    const i = t.getAttribute(e);
    if (i === null)
      return null;
    const n = i.split(" ");
    return n.length !== 2 || this._parseUint_32(n[0]) === null ? null : this._parseUint_32(n[1]);
  }
  static parseNodeId(t, e) {
    const i = t.getAttribute(e);
    return i === null ? null : this._parseUint_32(i);
  }
  static parseLayerId(t, e) {
    const i = t.getAttribute(e);
    return i === null ? null : this._parseUint_32(i);
  }
  static parseUint(t, e) {
    const i = t.getAttribute(e);
    return i === null ? null : this._parseUint_32(i);
  }
  static parseUints(t, e) {
    const i = t.getAttribute(e);
    if (i === null)
      return null;
    const n = [], r = i.match(/[0-9]+/g) || [];
    for (const o of r) {
      const l = this._parseUint_32(o);
      if (l === null)
        return null;
      n.push(l);
    }
    return n;
  }
  static parseFloats(t, e) {
    const i = t.getAttribute(e);
    if (i === null)
      return null;
    const n = [], r = i.match(/\S+/g) || [];
    for (const o of r) {
      const l = this._parseFloat(o);
      if (l === null)
        return null;
      n.push(l);
    }
    return n;
  }
  static parseNodeIds(t, e) {
    return this.parseUints(t, e);
  }
  static _parsePoint3(t, e) {
    const i = t.getAttribute(e);
    if (i === null)
      return null;
    const n = i.split(" ");
    if (n.length !== 3)
      return null;
    const r = [];
    for (const o of n) {
      const l = Number(o);
      if (isNaN(l))
        return null;
      r.push(l);
    }
    return new _(r[0], r[1], r[2]);
  }
  static parseBounding(t, e) {
    const i = t.getElementsByTagName(e);
    if (i.length !== 1)
      return null;
    const n = i[0], r = this._parsePoint3(n, "Min");
    if (r === null)
      return null;
    const o = this._parsePoint3(n, "Max");
    return o === null ? null : new yn(r, o);
  }
  static parseCamera(t) {
    const e = gi.parseUint(t, "Projection");
    if (e === null)
      return null;
    const i = t.getAttribute("field");
    if (i === null)
      return null;
    const n = i.split(" ");
    if (n.length !== 2)
      return null;
    const r = parseFloat(n[0]), o = parseFloat(n[1]), l = t.getAttribute("definition");
    if (l === null)
      return null;
    const h = l.split(" ");
    if (h.length !== 9)
      return null;
    const u = (m, x) => new _(
      parseFloat(m[x]),
      parseFloat(m[x + 1]),
      parseFloat(m[x + 2])
    ), d = u(h, 0), g = u(h, 3), y = u(h, 6);
    return Cn.create(d, g, y, e, r, o);
  }
}
class Qc {
  constructor() {
    this.isInclusive = !1, this.ids = [];
  }
  static parseBinary(t) {
    const e = new Qc();
    e.isInclusive = t.parseBoolean();
    const i = t.parseCount_32();
    for (let n = 0; n < i; n++)
      e.ids.push(t.parseNodeId());
    return e;
  }
  static parseXml(t) {
    const e = new Qc();
    e.isInclusive = t.getAttribute("Inclusive") === "1";
    const i = gi.parseNodeIds(t, "Ids");
    if (i !== null) {
      e.ids = i;
      const n = t.getAttribute("Count");
      if (n !== null) {
        const r = parseInt(n, 10);
        console.assert(r === e.ids.length);
      }
    } else
      console.error("'Entities' tag has missing or malformed 'Ids' attribute");
    return e;
  }
}
class th {
  constructor() {
    this.isInclusive = !1, this.authoredIds = [];
  }
  static parseBinary(t) {
    const e = new th();
    e.isInclusive = t.parseBoolean();
    const i = t.parseCount_32();
    for (let n = 0; n < i; n++)
      e.authoredIds.push(t.parseLayerId());
    return e;
  }
  static parseXml(t) {
    const e = new th();
    e.isInclusive = t.getAttribute("Inclusive") === "1";
    const i = gi.parseUints(t, "Ids");
    if (i !== null) {
      e.authoredIds = i;
      const n = t.getAttribute("Count");
      if (n !== null) {
        const r = parseInt(n, 10);
        console.assert(r === e.authoredIds.length);
      }
    } else
      console.error("'Layers' tag has missing or malformed 'Ids' attribute");
    return e;
  }
}
class eh {
  constructor() {
    this.isDisplayfilter = !1, this.name = null, this.isActive = !1, this.layers = null, this.entities = null, this.scId = null;
  }
  static parseBinary(t) {
    const e = new eh();
    let i = null, n = null;
    const r = t.parseLayerParseBits();
    return e.isDisplayfilter = t.parseBoolean(), ne(r, dc.ScId) && (e.scId = t.parseUInt32()), ne(r, dc.Name) && (e.name = t.parseCString()), e.isActive = t.parseBoolean(), ne(r, dc.LayerItem) && (i = th.parseBinary(t)), ne(r, dc.EntityItem) && (n = Qc.parseBinary(t)), e.layers = i, e.entities = n, e;
  }
  static parseXml(t) {
    const e = new eh(), i = t.getAttribute("Name");
    i !== null && (e.name = i), e.isDisplayfilter = t.getAttribute("Display") === "1", e.isActive = t.getAttribute("Active") === "1";
    for (let n = t.firstElementChild; n !== null; n = n.nextElementSibling)
      n.localName === "Layers" ? (console.assert(e.layers === null), e.layers = th.parseXml(n)) : n.localName === "Entities" ? (console.assert(e.entities === null), e.entities = Qc.parseXml(n)) : console.error(`Unknown tag: ${t.localName}`);
    return e;
  }
}
var Bo = /* @__PURE__ */ ((s) => (s[s.Undefined = 0] = "Undefined", s[s.Unconnected = 1] = "Unconnected", s[s.Connected = 2] = "Connected", s))(Bo || {});
class fg {
  constructor() {
    this.relationships = [];
  }
  static parseBinary(t, e) {
    const i = new fg(), n = e.parseCount_32();
    for (let r = 0; r < n; r++) {
      let o = Bo.Undefined;
      const l = e.parseCString(), h = e.parseCString();
      e.parseBoolean() ? (o = Bo.Connected, ka.registerBimId(l, t)) : o = Bo.Unconnected, i.relationships.push({
        category: o,
        id: l,
        name: h
      });
    }
    return i;
  }
}
class Yu {
  constructor() {
    this.relationElt = {
      id: "",
      name: "",
      category: Bo.Undefined
    };
  }
  static parseBinary(t, e) {
    const i = new Yu();
    return i.relationElt.id = e.parseCString(), i.relationElt.name = e.parseCString(), e.parseBoolean() ? (i.relationElt.category = Bo.Connected, ka.registerBimId(i.relationElt.id, t)) : i.relationElt.category = Bo.Unconnected, i;
  }
  //TODO with the writer
  static parseXml(t) {
    return new Yu();
  }
}
class ka {
  constructor() {
    this.type = P_.Undefined, this.related = null, this.relating = null;
  }
  static registerBimId(t, e) {
    const i = e.toRuntimeId(parseInt(t, 10));
    i !== null && e.addBimIdToMap(t, i);
  }
  static parseBinary(t, e) {
    const i = new ka(), n = e.parseRelationshipParseBits();
    return ne(n, Cu.Type) && (i.type = e.parseCount_32()), ne(n, Cu.Relating) && (i.relating = Yu.parseBinary(t, e)), ne(n, Cu.Related) && (i.related = fg.parseBinary(t, e)), i;
  }
  //TODO with the writer
  static parseXml(t) {
    const e = new ka(), i = t.getAttribute("Type");
    return i !== null && (e.type = Number(i)), e;
  }
}
class gr {
  static parseBinary(t) {
    let e = null;
    const i = t.getHeader();
    let n = 0;
    i !== null && i.supportsAttributeBits() && (n = t.parseAttributeParseBits());
    const r = t.parseCString();
    ne(n, Pf.ValueName) && (e = t.parseCString());
    const o = t.parseAttributeType(), l = t.parseCString();
    let h = [];
    return ne(n, Pf.Units) && (h = t.parseUnits()), new gr(o, r, e, l, h);
  }
  static parseXml(t) {
    console.assert(t.localName === "Attr");
    let e = zr.Undefined, i = "", n = "";
    const r = [], o = t.getAttribute("ValueName"), l = t.getAttribute("Name");
    if (l !== null && (i = l, i === "__PRC_RESERVED_ATTRIBUTE_A3DF_ProductInformation"))
      return new gr(e, i, o, n, r);
    const h = t.getAttribute("Type");
    if (h !== null)
      switch (h) {
        case "i":
          e = zr.Int;
          break;
        case "f":
          e = zr.Float;
          break;
        case "t":
          e = zr.Time;
          break;
        case "s":
          e = zr.String;
          break;
      }
    const u = t.getAttribute("Value");
    return u !== null && (n = u), new gr(e, i, o, n, r);
  }
  constructor(t, e, i, n, r) {
    this._type = t, this._valueName = i, this._title = e, this._value = n, this._unit = r;
  }
  getType() {
    return this._type;
  }
  getValueName() {
    return this._valueName;
  }
  getTitle() {
    return this._title;
  }
  getValue() {
    return this._value;
  }
  getUnit() {
    return dv(this._unit);
  }
  copy() {
    let t = null;
    return this._valueName !== null && (t = this._valueName.slice()), new gr(
      this._type,
      this._title.slice(),
      t,
      this._value.slice(),
      this._unit.slice()
    );
  }
}
let Wn = class a_ {
  static parseBinary(t) {
    return t.parseMatrix();
  }
  static parseXml(t) {
    console.assert(t.localName === "Transformation");
    const e = [], i = t.getAttribute("RelativeTransfo");
    if (i !== null) {
      const n = i.split(" ");
      console.assert(n.length === 16);
      for (let r = 0; r < 16; ++r) {
        const o = parseFloat(n[r]);
        console.assert(!isNaN(o)), e.push(o);
      }
    }
    return e;
  }
  static getIdentity() {
    return [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
  }
  static copy(t) {
    return t.slice();
  }
  static isIdentity(t) {
    return t[0] === 1 && t[1] === 0 && t[2] === 0 && t[3] === 0 && t[4] === 0 && t[5] === 1 && t[6] === 0 && t[7] === 0 && t[8] === 0 && t[9] === 0 && t[10] === 1 && t[11] === 0 && t[12] === 0 && t[13] === 0 && t[14] === 0 && t[15] === 1;
  }
  static multiply(t, e) {
    const i = a_.getIdentity();
    return i[0] = t[0] * e[0] + t[1] * e[4] + t[2] * e[8] + t[3] * e[12], i[1] = t[0] * e[1] + t[1] * e[5] + t[2] * e[9] + t[3] * e[13], i[2] = t[0] * e[2] + t[1] * e[6] + t[2] * e[10] + t[3] * e[14], i[3] = t[0] * e[3] + t[1] * e[7] + t[2] * e[11] + t[3] * e[15], i[4] = t[4] * e[0] + t[5] * e[4] + t[6] * e[8] + t[7] * e[12], i[5] = t[4] * e[1] + t[5] * e[5] + t[6] * e[9] + t[7] * e[13], i[6] = t[4] * e[2] + t[5] * e[6] + t[6] * e[10] + t[7] * e[14], i[7] = t[4] * e[3] + t[5] * e[7] + t[6] * e[11] + t[7] * e[15], i[8] = t[8] * e[0] + t[9] * e[4] + t[10] * e[8] + t[11] * e[12], i[9] = t[8] * e[1] + t[9] * e[5] + t[10] * e[9] + t[11] * e[13], i[10] = t[8] * e[2] + t[9] * e[6] + t[10] * e[10] + t[11] * e[14], i[11] = t[8] * e[3] + t[9] * e[7] + t[10] * e[11] + t[11] * e[15], i[12] = t[12] * e[0] + t[13] * e[4] + t[14] * e[8] + t[15] * e[12], i[13] = t[12] * e[1] + t[13] * e[5] + t[14] * e[9] + t[15] * e[13], i[14] = t[12] * e[2] + t[13] * e[6] + t[14] * e[10] + t[15] * e[14], i[15] = t[12] * e[3] + t[13] * e[7] + t[14] * e[11] + t[15] * e[15], i;
  }
  constructor() {
  }
};
const Lp = zi.InitiallyShown;
let Uo = class {
  /**
   * Parses the `NodeInfo` for a node without inserting it into the tree.
   */
  static parseXml(t, e, i) {
    let n = gi.parseNodeId(e, "Id");
    n === null && (console.assert(!1), n = t.generateDynamicNodeId());
    const r = e.getAttribute("Name");
    let o = null;
    const l = [];
    let h = e.firstElementChild;
    for (; h !== null; ) {
      if (h.localName === "Transformation")
        console.assert(o === null), o = Wn.parseXml(h), Wn.isIdentity(o) && (o = null);
      else if (h.localName === "Attributes") {
        let g = h.firstElementChild;
        for (; g !== null; ) {
          console.assert(g.localName === "Attr");
          const y = gr.parseXml(g);
          l.push(y), g = g.nextElementSibling;
        }
      }
      h = h.nextElementSibling;
    }
    const u = e.getAttribute("ExchangeId"), d = i.ignoreLayers ? null : gi.parseLayerId(e, "LayerId");
    return {
      nodeId: n,
      bits: Lp,
      name: r,
      localTransform: o,
      attributes: l,
      header: Ys.dynamic,
      exchangeId: u,
      layerId: d,
      genericTypeId: null,
      genericId: null,
      userDatas: null
    };
  }
  /**
   * Parses the `NodeInfo` for a node without inserting it into the tree.
   */
  static parseBinary(t, e, i, n) {
    let r;
    i.hasBits1(ei.Id) ? r = e.parseNodeId() : (console.assert(!1), r = t.generateDynamicNodeId());
    const o = i.hasBits1(ei.Name) ? e.parseCString() : null;
    let l = Lp;
    if (i.hasBits1(ei.Visiblity)) {
      const b = e.parseVisibility();
      b.shown || (l &= ~zi.InitiallyShown), b.removed && (l |= zi.InitiallyRemoved);
    }
    let h = null;
    i.hasBits1(ei.Transform) && (h = Wn.parseBinary(e), Wn.isIdentity(h) && (h = null));
    let u = null;
    i.hasBits1(ei.Attributes) && (u = e.parseDataKey());
    const d = i.hasBits1(ei.ExchangeId) ? e.parseCString() : null;
    let g = null;
    if (i.hasBits1(ei.LayerId)) {
      const b = e.parseLayerId();
      n.ignoreLayers || (g = b);
    }
    let y = null;
    if (i.hasBits2(_r.GenericTypeId)) {
      const b = e.parseGenericTypeId();
      n.ignoreGenericTypes || (y = b);
    }
    let m = null;
    i.hasBits2(_r.GenericId) && (m = e.parseGenericId());
    let x = null;
    if (i.hasBits1(ei.UserData)) {
      x = /* @__PURE__ */ new Map();
      const b = e.parseCount_32();
      for (let I = 0; I < b; ++I) {
        const C = e.parseUserDataIndex(), P = e.parseCount_32(), k = e.parseBytes(P);
        x.set(C, k);
      }
    }
    return {
      nodeId: r,
      bits: l,
      name: o,
      localTransform: h,
      attributes: u !== null ? u : [],
      header: e.getHeader(),
      exchangeId: d,
      layerId: g,
      genericTypeId: y,
      genericId: m,
      userDatas: x
    };
  }
  constructor() {
    console.assert(!1);
  }
};
function Xv(s, t) {
  const e = typeof s == "number";
  return e === (typeof t == "number") ? s < t ? -1 : s > t ? 1 : 0 : e ? -1 : 1;
}
class Ro {
  /**
   * Creates a new lazy value, which is the result of the supplied function
   * once the lazy value is forced (or the value itself if a `T` is directly supplied).
   */
  static create(t) {
    return new Ro(t);
  }
  constructor(t) {
    this._value = t;
  }
  /**
   * Forces the lazy value given at construction and returns it.
   */
  get() {
    return typeof this._value == "function" && (this._value = this._value()), this._value;
  }
}
class jn {
  /**
   * Creates a new lazy value, which is the result of the supplied function
   * once the lazy value is forced (or the value itself if a `T` is directly supplied).
   */
  static create(t) {
    return new jn(t);
  }
  constructor(t) {
    typeof t == "function" && (t = Ro.create(t)), t instanceof Promise && (t = this._rectifyResult(t)), this._value = t;
  }
  /**
   * Returns whether or not this has been both forced (lazy).
   * This says nothing about resolution (promise).
   */
  isUnforced() {
    return this._value instanceof Ro;
  }
  /**
   * Returns whether or not this has been both forced (lazy) and resolved (promise).
   */
  isResolved() {
    return !(this._value instanceof Ro) && !(this._value instanceof Promise);
  }
  /**
   * Returns the final promised value synchronously.
   *
   * This is only legal to call if `isResolved()` returns `true`.
   *
   */
  getResolved() {
    return console.assert(this.isResolved()), this._value;
  }
  /**
   * Forces the lazy promise and then delegates to the forced promise's `then()` method.
   *
   * Note: This intentionally returns a normal `Promise`, not a `LazyPromise`.
   */
  then(t, e) {
    return this._value instanceof Ro && (this._value = this._rectifyResult(this._value.get())), this._value instanceof Promise ? this._value.then(t, e) : (this._value, Promise.resolve(this._value).then(t, e));
  }
  _rectifyResult(t) {
    return t instanceof Promise ? t.then((e) => (this._value = e, e)) : t;
  }
}
function Jv(s) {
  return s == null;
}
function hi(s) {
  return Array.isArray(s) ? s.slice() : s == null ? [] : [s];
}
function vs(s) {
  return s.length === 0 ? null : s.length === 1 ? s[0] : s;
}
function Yn(s, t) {
  return s ? Array.isArray(s) ? (s.push(t), s) : [s, t] : t;
}
class ts {
  constructor(t, e, i) {
    if (this._bits = 0, this._nodeId = i.nodeId, this._bits = i.bits, i.name !== null && (this._name = i.name), i.localTransform !== null && (this._localTransform = Wn.copy(i.localTransform)), typeof i.attributes == "number") {
      const n = i.attributes;
      this._lazyAttributes = ts._lazyLoadAttributes(
        t,
        e,
        n,
        i.header
      );
    } else
      i.attributes.length > 0 && (this._lazyAttributes = jn.create(i.attributes));
    i.exchangeId !== null && (this._exchangeId = i.exchangeId), i.layerId !== null && (this._layerId = i.layerId), i.genericTypeId !== null && (this._genericTypeId = i.genericTypeId), i.genericId !== null && (this._genericId = i.genericId), i.userDatas !== null && (this._userDatas = gd(i.userDatas));
  }
  static _lazyLoadAttributes(t, e, i, n) {
    return jn.create(async () => {
      const r = t.getAbstractScEngine(), o = await t.enqueue(() => r.safeGetMetaData(e, i)), l = [];
      if (o !== null) {
        const h = new va(n, o), u = new rh(h);
        for (; u.hasNext(); ) {
          const d = gr.parseBinary(u);
          l.push(d);
        }
      }
      return l;
    });
  }
  hasAuthoredId() {
    return Dl(this._nodeId);
  }
  getAuthoredId() {
    return Cv(this._nodeId);
  }
  getName() {
    return this._name !== void 0 ? this._name : null;
  }
  getExchangeId() {
    return this._exchangeId ?? null;
  }
  getAuthoredLayerId() {
    return this._layerId !== void 0 ? this._layerId : null;
  }
  getGenericTypeId() {
    return this._genericTypeId !== void 0 ? this._genericTypeId : null;
  }
  getGenericId() {
    return this._genericId !== void 0 ? this._genericId : null;
  }
  _hasBits(t) {
    return ne(this._bits, t);
  }
  isLoaded() {
    return this._hasBits(zi.IsLoaded);
  }
  markLoaded() {
    this._bits |= zi.IsLoaded;
  }
  _setVisibility(t) {
    this._bits |= zi.IsShownSpecified, t ? this._bits |= zi.IsShown : this._bits &= ~zi.IsShown;
  }
  isVisible() {
    return this._hasBits(zi.IsShownSpecified) ? this._hasBits(zi.IsShown) : this.isInitiallyShown();
  }
  isInitiallyShown() {
    return this._hasBits(zi.InitiallyRemoved) ? !1 : this._hasBits(zi.InitiallyShown);
  }
  _toAffineTransformation(t) {
    const e = t.slice();
    return e[3] = 0, e[7] = 0, e[11] = 0, e[15] = 1, e;
  }
  setLocalTransformAsInitial(t) {
    this._localTransform = this._toAffineTransformation(t);
  }
  overrideLocalTransform(t) {
    this._localTransformOverride = this._toAffineTransformation(t);
  }
  hasLocalTransformOverride() {
    return this._localTransformOverride !== void 0;
  }
  removeLocalTransformOverride() {
    console.assert(this._localTransformOverride !== void 0), delete this._localTransformOverride;
  }
  getLocalTransform() {
    return this._localTransformOverride !== void 0 ? this._localTransformOverride : this._localTransform !== void 0 ? this._localTransform : null;
  }
  async getAttributes() {
    return this._lazyAttributes !== void 0 ? this._lazyAttributes.then((t) => {
      if (this._lazyAttributes !== void 0) {
        for (const e of t)
          this.addAttribute(e);
        delete this._lazyAttributes;
      }
      return this.getAttributes();
    }) : hi(this._attributes);
  }
  addAttribute(t) {
    this._attributes = Yn(this._attributes, t);
  }
  getUserDataIndices() {
    const t = [];
    return this._userDatas !== void 0 && this._userDatas.forEach((e, i) => {
      t.push(i);
    }), t.sort(Xv);
  }
  getUserData(t) {
    if (this._userDatas !== void 0) {
      const e = this._userDatas.get(t);
      if (e !== void 0)
        return e;
    }
    throw new xg(t);
  }
}
class wl {
  static parseBinary(t) {
    const e = t.parseInstanceKey(), i = t.parsePmiTopoRef(), n = t.parseIndex_32();
    return {
      bodyInstanceKey: e,
      topoItemType: i,
      itemIndex: n
    };
  }
  static reify(t, e) {
    const i = t.getInclusionKey();
    return new wl(
      i,
      e.bodyInstanceKey,
      e.topoItemType,
      e.itemIndex
    );
  }
  static fromBodyInstance(t, e, i) {
    const n = t.getInstanceInc();
    return new wl(n[0], n[1], e, i);
  }
  constructor(t, e, i, n) {
    this._inclusionKey = t, this._bodyInstanceKey = e, this._topoItemType = i, this._itemIndex = n;
  }
  getBodyInstanceInc() {
    return [this._inclusionKey, this._bodyInstanceKey];
  }
  getTopoItemType() {
    return this._topoItemType;
  }
  getItemIndex() {
    return this._itemIndex;
  }
}
const Ug = class Ug {
  static parseBinary(t) {
    const e = t.parseLayerParseBits(), i = t.parseLayerId();
    let n = null;
    return ne(e, Jm.Name) && (n = t.parseCString()), {
      id: i,
      name: n
    };
  }
  static parseXml(t) {
    const e = t.getAttribute("Name"), i = gi.parseUint(t, "Id");
    return i === null ? (console.error("'Layer' tag missing 'Id' attribute"), null) : {
      id: i,
      name: e
    };
  }
  constructor(t, e, i, n) {
    this.id = t, this.name = e, this.nodes = i, this.treeNodes = n;
  }
};
Ug.NoLayerId = -1;
let lo = Ug;
class Rl extends ts {
  constructor(t, e, i, n) {
    super(t, e, n.nodeInfo), this._bits |= n.bits, this._modifiers = n.modifierbits, this._parent = i, this._instanceKey = n.instanceKey;
    const r = this.getAuthoredLayerId();
    r !== null && t.registerNodeInLayer(this, r), r !== null && !this.isOutOfHierarchy() && t.registerTreeNodeInLayer(this, r), r === null && !this.isOutOfHierarchy() && Dl(n.nodeInfo.nodeId) && (t.registerNodeInLayer(this, lo.NoLayerId), t.registerTreeNodeInLayer(this, lo.NoLayerId));
  }
  setRequested() {
    this._bits |= Br.Requested;
  }
  isRequested() {
    return this._hasBits(Br.Requested);
  }
  isOutOfHierarchy() {
    return this._hasBits(Br.OutOfHierarchy);
  }
  preventFromResetting() {
    return this._hasBits(Br.PreventFromResetting);
  }
  isImplicitBody() {
    return this._hasBits(Br.ImplicitBody);
  }
  getParent() {
    return this._parent;
  }
  getInstanceKey() {
    return this._instanceKey;
  }
  hasModifiers() {
    return this._modifiers != 0;
  }
  ignoreParentScale() {
    return ne(this._modifiers, If.IgnoreParentScale);
  }
  ignoreParentRotation() {
    return ne(this._modifiers, If.IgnoreParentRotation);
  }
}
class Ui extends Rl {
  static parseXml(t, e, i, n) {
    const r = Uo.parseXml(t, e, n), o = gi.parseInstanceKeyFromInc(e, "MeshInstanceKey");
    if (o === null)
      throw new si('Expected "MeshInstanceKey" attribute.');
    return {
      nodeInfo: r,
      inclusionKey: i,
      instanceKey: o,
      bits: 0,
      modifierbits: 0
    };
  }
  static parseBinary(t, e, i, n) {
    const r = Fi(e), o = r.getRemapper(), l = r.getMasterModelKey(), h = i.parseNodeParseBits(), u = Uo.parseBinary(t, i, h, n);
    let d;
    if (h.hasBits1(ei.ScInclusionKey) ? d = i.parseInclusionKey(o, l) : d = e.getInclusionKey(), !h.hasBits1(ei.ScInstanceKey))
      throw new Ea('Expected "ScInstanceKey" in binary data.');
    const g = i.parseInstanceKey();
    let y = 0;
    return h.hasBits2(_r.Modifiers) && (y = i.parseModifiers()), {
      nodeInfo: u,
      inclusionKey: d,
      instanceKey: g,
      bits: 0,
      modifierbits: y
    };
  }
  static reify(t, e, i, n) {
    const r = Fi(i), o = new Ui(t, e, i, n);
    return r.attachedInvisibly() && o.setVisibility(!1), o;
  }
  static createDynamic(t, e, i, n, r, o, l, h) {
    const u = Gi(o), g = Fi(u).getMasterModelKey(), x = {
      nodeInfo: {
        nodeId: t.massageAuthoredUserId(u, n),
        bits: l,
        name: r,
        localTransform: null,
        attributes: [],
        header: Ys.dynamic,
        exchangeId: null,
        layerId: null,
        genericTypeId: null,
        genericId: null,
        userDatas: null
      },
      inclusionKey: e,
      instanceKey: i,
      bits: h,
      modifierbits: 0
    };
    return new Ui(t, g, o, x);
  }
  constructor(t, e, i, n) {
    super(t, e, i, n), t.registerBodyInstance(this, n.inclusionKey);
  }
  getName() {
    const t = super.getName();
    if (t !== null)
      return t;
    const i = this.getParent().getBodyInstances();
    if (i.length > 1) {
      for (let n = 0; n < i.length; ++n) {
        const r = i[n];
        if (this === r)
          return `body ${n + 1}`;
      }
      console.assert(!1);
    }
    return "body";
  }
  getInstanceInc() {
    const t = this._instanceKey;
    let e = Ei.Local;
    return (this.hasAuthoredId() || this.isImplicitBody()) && (e = Gi(this).getInclusionKey()), [e, t];
  }
  setVisibility(t) {
    t !== this.isVisible() && this.getParent().markBranchVisibilityDirty(), this._setVisibility(t);
  }
  getRuntimeId() {
    return Ko(this._nodeId, this);
  }
}
class Bs extends Rl {
  static parseBinary(t, e, i, n, r) {
    let o = Ui.parseBinary(t, e, i, r);
    if (n) {
      let l = o.nodeInfo, h = l.bits;
      h &= ~zi.InitiallyShown, l = { ...l, bits: h }, o = { ...o, nodeInfo: l };
    }
    return o;
  }
  static reify(t, e, i, n) {
    const r = Fi(i), o = new Bs(t, e, i, n);
    return r.attachedInvisibly() && o.setVisibility(!1), o;
  }
  constructor(t, e, i, n) {
    super(t, e, i, n), this._modifiers = n.modifierbits, t.registerPmiBody(this, n.inclusionKey);
  }
  getName() {
    const t = super.getName();
    return t !== null ? t : "PMI body";
  }
  getInstanceInc() {
    const t = this._instanceKey;
    let e = Ei.Local;
    return (this.hasAuthoredId() || this.isImplicitBody()) && (e = Gi(this).getInclusionKey()), [e, t];
  }
  setVisibility(t) {
    t !== this.isVisible() && this.getParent().getParent().markBranchVisibilityDirty(), this._setVisibility(t);
  }
  getRuntimeId() {
    return Ko(this._nodeId, this);
  }
}
class Yv {
  constructor(t) {
    this.faceIds = [], this.edgeIds = [], this.body = t;
  }
}
class Sn extends ts {
  static parseBinary(t, e, i, n) {
    const r = i.parsePmiParseBits(), o = i.parseNodeId();
    let l = null;
    ne(r, la.Name) && (l = i.parseCString());
    let h = null;
    ne(r, la.ExchangeId) && (h = i.parseCString());
    let u = null;
    ne(r, la.Attributes) && (u = i.parseDataKey());
    let d = 1;
    ne(r, la.HasMultipleBodies) && (d = i.parseCount_32());
    const g = [], y = ne(r, la.InitiallyHidden);
    for (let C = 0; C < d; ++C) {
      const P = Bs.parseBinary(
        t,
        e,
        i,
        y,
        n
      );
      g.push(P);
    }
    const m = g.length > 0 ? ne(g[0].nodeInfo.bits, zi.InitiallyShown) : !1, x = i.parsePmiType(), b = i.parsePmiSubType(), I = [];
    if (ne(r, la.TopoRef)) {
      const C = i.parseCount_32();
      for (let P = 0; P < C; ++P) {
        const k = wl.parseBinary(i);
        I.push(k);
      }
    }
    return {
      nodeId: o,
      name: l,
      attributesDataKey: u,
      pmiBodyInfos: g,
      initiallyShown: m,
      pmiType: x,
      pmiSubType: b,
      topoRefInfos: I,
      topoRefs: [],
      exchangeId: h
    };
  }
  static reify(t, e, i, n) {
    const r = Fi(e), o = new Sn(t, e, i, n);
    return r.attachedInvisibly() && o.setVisibility(!1), o;
  }
  static createDynamic(t, e, i, n, r, o, l, h) {
    const d = {
      nodeId: t.generateDynamicNodeId(),
      name: n,
      attributesDataKey: null,
      pmiBodyInfos: l,
      initiallyShown: !0,
      pmiType: r,
      pmiSubType: o,
      topoRefInfos: [],
      topoRefs: h,
      exchangeId: null
    };
    return new Sn(t, e, d, i);
  }
  constructor(t, e, i, n) {
    const o = Fi(e).getMasterModelKey();
    let l = 0;
    i.initiallyShown && (l |= zi.InitiallyShown);
    const h = {
      nodeId: i.nodeId,
      bits: l,
      name: i.name,
      localTransform: null,
      attributes: i.attributesDataKey ? i.attributesDataKey : [],
      header: Ys.dynamic,
      exchangeId: null,
      layerId: null,
      genericTypeId: null,
      genericId: null,
      userDatas: null
    };
    super(t, o, h), this._bits |= Br.PreventFromResetting, this._parent = n, this._packed = Sn._pack(i.pmiType, i.pmiSubType);
    for (const u of i.pmiBodyInfos) {
      const d = this._loadPmiBody(t, o, u);
      this._pmiBodies = Yn(this._pmiBodies, d), d.markLoaded();
    }
    if (i.topoRefInfos.length > 0 && (this._topoRefs = Sn._loadTopoRefs(e, i.topoRefInfos)), i.topoRefs.length > 0)
      if (this._topoRefs === void 0)
        this._topoRefs = i.topoRefs.slice();
      else
        for (const u of i.topoRefs)
          this._topoRefs.push(u);
    t.registerPmi(this);
  }
  static _loadTopoRefs(t, e) {
    const i = [];
    for (const n of e) {
      const r = wl.reify(t, n);
      i.push(r);
    }
    return i;
  }
  _loadPmiBody(t, e, i) {
    return Bs.reify(t, e, this, i);
  }
  getPmiBodies() {
    return hi(this._pmiBodies);
  }
  static _pack(t, e) {
    return t + 100 * e;
  }
  getPmiType() {
    return this._packed % 100;
  }
  getPmiSubType() {
    return Math.floor(this._packed / 100) % 100;
  }
  getParent() {
    return this._parent;
  }
  getRuntimeId() {
    return Ko(this._nodeId, this);
  }
  getBranchVisibility() {
    let t = this.isVisible() ? de.Shown : de.Hidden;
    for (const e of hi(this._pmiBodies))
      e.isOutOfHierarchy() || (t |= e.isVisible() ? de.Shown : de.Hidden);
    return t;
  }
  setVisibility(t) {
    this._setVisibility(t);
  }
  getPmiTopologyReferences(t) {
    if (this._topoRefs === void 0)
      return [];
    const e = /* @__PURE__ */ new Map();
    for (const n of this._topoRefs) {
      const r = n.getBodyInstanceInc(), o = t.lookupAnyBodyByInstanceInc(r[0], r[1]);
      if (o === null)
        continue;
      let l = e.get(o);
      switch (l === void 0 && (l = new Yv(o), e.set(o, l)), n.getTopoItemType()) {
        case ch.Face:
          l.faceIds.push(n.getItemIndex());
          break;
        case ch.Edge:
          l.edgeIds.push(n.getItemIndex());
          break;
      }
    }
    const i = [];
    return e.forEach((n) => {
      i.push(n);
    }), i;
  }
}
class wa {
  static parseBinary(t) {
    const e = t.parseFloat_64(), i = t.parseFloat_64(), n = t.parsePoint3_64();
    return new wa(e, i, n);
  }
  constructor(t, e, i) {
    this.surfaceArea = t, this.volume = e, this.centerOfGravity = i;
  }
}
function Zv(s) {
  const t = Qm;
  switch (s.parseFaceType()) {
    case t.Cylinder:
      return Qv.parseBinary(s);
    case t.Plane:
      return t0.parseBinary(s);
    case t.Cone:
      return e0.parseBinary(s);
    case t.Other:
      return s0.parseBinary(s);
    case t.Sphere:
      return i0.parseBinary(s);
    case t.Torus:
      return n0.parseBinary(s);
    case t.Blend01:
      return r0.parseBinary(s);
    case t.Blend02:
      return o0.parseBinary(s);
    case t.Blend03:
      return a0.parseBinary(s);
    case t.Nurbs:
      return l0.parseBinary(s);
    case t.Cylindrical:
      return c0.parseBinary(s);
    case t.Offset:
      return h0.parseBinary(s);
    case t.Pipe:
      return u0.parseBinary(s);
    case t.Ruled:
      return d0.parseBinary(s);
    case t.Revolution:
      return f0.parseBinary(s);
    case t.Extrusion:
      return g0.parseBinary(s);
    case t.FromCurves:
      return p0.parseBinary(s);
    case t.Transform:
      return m0.parseBinary(s);
    default:
      throw new Ea("Unexpected measurement face type.");
  }
}
class Qv {
  static parseBinary(t) {
    const e = t.parseFloat_32(), i = t.parsePoint3_32(), n = t.parsePoint3_32();
    return new Li(e, i, n);
  }
}
class t0 {
  static parseBinary(t) {
    const e = t.parsePoint3_32(), i = t.parsePoint3_32();
    return new Wi(e, i);
  }
}
class e0 {
  static parseBinary(t) {
    const e = t.parseFloat_32(), i = t.parsePoint3_32(), n = t.parsePoint3_32(), r = t.parseFloat_32();
    return new Ca(e, i, n, r);
  }
}
class i0 {
  static parseBinary(t) {
    const e = t.parseFloat_32(), i = t.parsePoint3_32(), n = t.parsePoint3_32();
    return new Sa(e, i, n);
  }
}
class n0 {
  static parseBinary(t) {
    const e = t.parseFloat_32(), i = t.parseFloat_32(), n = t.parsePoint3_32(), r = t.parsePoint3_32();
    return new Pa(e, i, n, r);
  }
}
let s0 = class {
  static parseBinary(t) {
    return new wh();
  }
};
class r0 {
  static parseBinary(t) {
    return new vh();
  }
}
class o0 {
  static parseBinary(t) {
    return new bh();
  }
}
class a0 {
  static parseBinary(t) {
    return new xh();
  }
}
class l0 {
  static parseBinary(t) {
    return new Ih();
  }
}
class c0 {
  static parseBinary(t) {
    return new Ch();
  }
}
let h0 = class {
  static parseBinary(t) {
    return new Sh();
  }
};
class u0 {
  static parseBinary(t) {
    return new Ph();
  }
}
class d0 {
  static parseBinary(t) {
    return new kh();
  }
}
class f0 {
  static parseBinary(t) {
    return new Mh();
  }
}
class g0 {
  static parseBinary(t) {
    return new Eh();
  }
}
class p0 {
  static parseBinary(t) {
    return new Ah();
  }
}
let m0 = class {
  static parseBinary(t) {
    return new Th();
  }
};
function _0(s) {
  const t = Zm;
  switch (s.parseEdgeType()) {
    case t.Line:
      return y0.parseBinary(s);
    case t.Circle:
      return w0.parseBinary(s);
    case t.Other:
      return v0.parseBinary(s);
    default:
      throw new Ea("Unexpected measurement edge type.");
  }
}
let y0 = class {
  static parseBinary(t) {
    const e = t.parseFloat_32();
    return new yh(e);
  }
}, w0 = class {
  static parseBinary(t) {
    const e = t.parseFloat_32(), i = t.parsePoint3_32(), n = t.parsePoint3_32();
    return new Ol(e, i, n);
  }
};
class v0 {
  static parseBinary(t) {
    const e = t.parseFloat_32();
    return new Ho(e);
  }
}
class Tc {
  constructor(t) {
    this.attributes = t;
  }
  copy() {
    return new Tc(this.attributes.map((t) => t.copy()));
  }
}
function rc(s, t) {
  return s !== void 0 && t < s.length ? s[t] : null;
}
function Fp(s, t, e) {
  return s === void 0 && (s = []), s.length = Math.max(s.length, t + 1), s[t] = e, s;
}
var el = /* @__PURE__ */ ((s) => (s[s.Unknown = 0] = "Unknown", s[s.BRep = 1] = "BRep", s[s.Tessellation = 2] = "Tessellation", s[s.Wireframe = 3] = "Wireframe", s[s.PointCloud = 4] = "PointCloud", s))(el || {});
class tn extends ts {
  static parseXml(t, e, i) {
    const n = Uo.parseXml(t, e, i), r = gi.parseMeshKey(e, "TCKey_Mesh");
    return {
      nodeInfo: n,
      meshKey: r,
      bodyType: 0,
      faceMeasurementProps: [],
      edgeMeasurementProps: [],
      physicalProps: null,
      faceAttributes: [],
      edgeAttributes: [],
      pointAttributes: []
    };
  }
  static parseBinary(t, e, i) {
    const n = e.parseNodeParseBits(), r = Uo.parseBinary(t, e, n, i), o = e.parseBodyType();
    let l = null;
    n.hasBits1(ei.MeshKey) && (l = e.parseMeshKey());
    const h = [];
    if (n.hasBits1(ei.FaceMeasurement)) {
      const x = e.parseCount_32();
      for (let b = 0; b < x; ++b) {
        const I = Zv(e);
        h.push(I);
      }
    }
    const u = [];
    if (n.hasBits1(ei.EdgeMeasurement)) {
      const x = e.parseCount_32();
      for (let b = 0; b < x; ++b) {
        const I = _0(e);
        u.push(I);
      }
    }
    let d = null;
    n.hasBits1(ei.PhysicalProperties) && (d = wa.parseBinary(e));
    const g = [];
    if (n.hasBits2(_r.FaceAttributes)) {
      const x = e.parseCount_32();
      for (let b = 0; b < x; b++) {
        const I = [], C = e.parseCount_32();
        for (let P = 0; P < C; P++) {
          const k = gr.parseBinary(e);
          k.getType() !== zr.Ignored && I.push(k);
        }
        g.push(I.length > 0 ? new Tc(I) : null);
      }
    }
    const y = [];
    if (n.hasBits2(_r.EdgeAttributes)) {
      const x = e.parseCount_32();
      for (let b = 0; b < x; b++) {
        const I = [], C = e.parseCount_32();
        for (let P = 0; P < C; P++) {
          const k = gr.parseBinary(e);
          k.getType() !== zr.Ignored && I.push(k);
        }
        y.push(I.length > 0 ? new Tc(I) : null);
      }
    }
    const m = [];
    if (n.hasBits2(_r.PointAttributes)) {
      const x = e.parseCount_32();
      for (let b = 0; b < x; b++) {
        const I = [], C = e.parseCount_32();
        for (let P = 0; P < C; P++) {
          const k = gr.parseBinary(e);
          k.getType() !== zr.Ignored && I.push(k);
        }
        m.push(I.length > 0 ? new Tc(I) : null);
      }
    }
    return {
      nodeInfo: r,
      meshKey: l,
      bodyType: o,
      faceMeasurementProps: h,
      edgeMeasurementProps: u,
      physicalProps: d,
      faceAttributes: g,
      edgeAttributes: y,
      pointAttributes: m
    };
  }
  static reify(t, e, i, n) {
    return new tn(t, e, i, n);
  }
  static createDynamic(t, e, i, n, r) {
    const o = r.getInclusionContextForNodeId(), u = {
      nodeInfo: {
        nodeId: t.massageAuthoredUserId(o, e),
        bits: zi.InitiallyShown,
        name: i,
        localTransform: null,
        attributes: [],
        header: Ys.dynamic,
        exchangeId: null,
        layerId: null,
        genericTypeId: null,
        genericId: null,
        userDatas: null
      },
      meshKey: null,
      bodyType: 0,
      faceMeasurementProps: [],
      edgeMeasurementProps: [],
      physicalProps: null,
      faceAttributes: [],
      edgeAttributes: [],
      pointAttributes: []
    };
    return new tn(t, n, u, r);
  }
  constructor(t, e, i, n) {
    if (super(t, e, i.nodeInfo), this._parent = n, this._bodyType = i.bodyType, i.faceMeasurementProps.length > 0 && (this._faceMeasurementProps = i.faceMeasurementProps.slice()), i.edgeMeasurementProps.length > 0 && (this._edgeMeasurementProps = i.edgeMeasurementProps.slice()), i.physicalProps !== null && (this._physicalProps = i.physicalProps), i.faceAttributes.length > 0) {
      this._faceAttributes = [];
      for (const r of i.faceAttributes)
        this._faceAttributes.push(r === null ? null : r.copy());
    }
    if (i.edgeAttributes.length > 0) {
      this._edgeAttributes = [];
      for (const r of i.edgeAttributes)
        this._edgeAttributes.push(r === null ? null : r.copy());
    }
    if (i.pointAttributes.length > 0) {
      this._pointAttributes = [];
      for (const r of i.pointAttributes)
        this._pointAttributes.push(r === null ? null : r.copy());
    }
    t.registerRepresentationItem(this);
  }
  setPhysicalProperties(t) {
    this._physicalProps = t;
  }
  getPhysicalProperties() {
    return this._physicalProps !== void 0 ? this._physicalProps : null;
  }
  getParent() {
    return this._parent;
  }
  getFaceCount() {
    return this._faceMeasurementProps !== void 0 ? this._faceMeasurementProps.length : 0;
  }
  getEdgeCount() {
    return this._edgeMeasurementProps !== void 0 ? this._edgeMeasurementProps.length : 0;
  }
  getFaceAttributes(t) {
    return rc(this._faceAttributes, t);
  }
  getEdgeAttributes(t) {
    return rc(this._edgeAttributes, t);
  }
  getPointAttributes(t) {
    return rc(this._pointAttributes, t);
  }
  getFaceMeasurementProperty(t) {
    return rc(this._faceMeasurementProps, t);
  }
  getEdgeMeasurementProperty(t) {
    return rc(this._edgeMeasurementProps, t);
  }
  setFaceMeasurementProperty(t, e) {
    this._faceMeasurementProps = Fp(this._faceMeasurementProps, t, e.copy());
  }
  setEdgeMeasurementProperty(t, e) {
    this._edgeMeasurementProps = Fp(this._edgeMeasurementProps, t, e.copy());
  }
  getBodyType() {
    return this._bodyType;
  }
  getRuntimeId() {
    return Ko(this._nodeId, this._parent.getInclusionContextForNodeId());
  }
}
class ns extends ts {
  static parseXml(t, e, i) {
    let n = Uo.parseXml(t, e, i);
    if (n.name === null) {
      const l = e.getAttribute("FilePath");
      l !== null && (n = { ...n, name: l });
    }
    const r = [];
    let o = e.firstElementChild;
    for (; o !== null; ) {
      if (o.localName === "Body") {
        const l = tn.parseXml(t, o, i);
        r.push(l);
      }
      o = o.nextElementSibling;
    }
    return {
      nodeInfo: n,
      repItemInfos: r
    };
  }
  static parseBinary(t, e, i) {
    const n = e.parseNodeParseBits(), r = Uo.parseBinary(t, e, n, i), o = [];
    if (n.hasBits1(ei.Bodies)) {
      const l = e.parseCount_32();
      for (let h = 0; h < l; ++h) {
        const u = tn.parseBinary(t, e, i);
        o.push(u);
      }
    }
    return {
      nodeInfo: r,
      repItemInfos: o
    };
  }
  static reify(t, e, i, n) {
    return new ns(t, e, i, n);
  }
  static createDynamic(t, e, i) {
    const n = t.getRootNode(), r = Gi(n), h = {
      nodeInfo: {
        nodeId: t.massageAuthoredUserId(r, e),
        bits: zi.InitiallyShown,
        name: i,
        localTransform: null,
        attributes: [],
        header: Ys.dynamic,
        exchangeId: null,
        layerId: null,
        genericTypeId: null,
        genericId: null,
        userDatas: null
      },
      repItemInfos: []
    };
    return new ns(t, r, xs.Local, h);
  }
  static createMissing(t) {
    const e = this.createDynamic(t, null, null);
    return e._bits |= Cf.IsMissing, e;
  }
  isMissing() {
    return this._hasBits(Cf.IsMissing);
  }
  constructor(t, e, i, n) {
    const r = i;
    if (super(t, r, n.nodeInfo), this._inclusionContextForNodeId = e, this._modelKey = i, n.repItemInfos.length > 0) {
      const o = this._loadRepresentationItems(
        t,
        r,
        n.repItemInfos
      );
      this._repItems = vs(o);
    }
    t.registerPartDefinition(this);
  }
  _loadRepresentationItems(t, e, i) {
    const n = [];
    for (const r of i) {
      const o = tn.reify(t, e, r, this);
      this._addRepresentationItem(o), n.push(o);
    }
    return n;
  }
  getRuntimeId() {
    return Ko(this._nodeId, this._inclusionContextForNodeId);
  }
  getInclusionContextForNodeId() {
    return this._inclusionContextForNodeId;
  }
  addReferrer(t) {
    const e = Js(t), i = Js(this._inclusionContextForNodeId);
    console.assert(e === i), this._referrers = Yn(this._referrers, t);
  }
  createRepItem(t, e) {
    const i = this._modelKey, n = tn.createDynamic(
      t,
      e,
      null,
      i,
      this
    );
    return this._addRepresentationItem(n), n;
  }
  _addRepresentationItem(t) {
    this._repItems = Yn(this._repItems, t);
  }
  getRepresentationItems() {
    return hi(this._repItems);
  }
  getReferrers() {
    return hi(this._referrers);
  }
  removeAllReferrers() {
    const t = this.getReferrers();
    for (const e of t) {
      const i = e.removePartDefinition();
      console.assert(this === i);
    }
    delete this._referrers;
  }
  getModelKey() {
    return this._modelKey;
  }
}
class ma {
  static pushRelatedItemFromParser(t) {
    const e = [];
    for (const i of t.relationships)
      e.push({
        category: i.category,
        id: i.id,
        name: i.name
      });
    return e;
  }
  static addFromRelatingElt(t, e) {
    const i = t.related, n = t.type;
    if (n != null)
      if (!e.has(n) && i !== null)
        e.set(n, {
          related: this.pushRelatedItemFromParser(i),
          relating: []
        });
      else {
        const r = t.related;
        if (r !== null)
          for (const o of r.relationships) {
            const l = e.get(n);
            l !== void 0 && this.findBimObjectInArray(l.related, {
              id: o.id,
              category: o.category,
              name: o.name
            }) === !1 && l.related.push({
              id: o.id,
              category: o.category,
              name: o.name
            });
          }
      }
  }
  static findBimObjectInArray(t, e) {
    for (const i of t)
      if (i.category === e.category && i.name === e.name && i.id === e.id)
        return !0;
    return !1;
  }
  static addFromRelatedElt(t, e) {
    const i = t.type;
    i !== null && !e.has(i) && t.relating !== null && e.set(i, {
      related: [],
      relating: [
        {
          category: t.relating.relationElt.category,
          id: t.relating.relationElt.id,
          name: t.relating.relationElt.name
        }
      ]
    });
  }
  static findIndexInRelated(t, e) {
    let i = -1, n = 0;
    for (const r of e) {
      if (r.id === t) {
        i = n;
        break;
      }
      n++;
    }
    return i;
  }
}
class co extends Rl {
  static parseXml(t, e, i, n) {
    return Ui.parseXml(t, e, i, n);
  }
  static parseBinary(t, e, i, n) {
    return Ui.parseBinary(t, e, i, n);
  }
  static reify(t, e, i, n) {
    const r = Fi(i), o = new co(t, e, i, n);
    return r.attachedInvisibly() && o.setVisibility(!1), o;
  }
  constructor(t, e, i, n) {
    super(t, e, i, n), this._bits &= ~zi.InitiallyShown, t.registerViewFrame(this, n.inclusionKey);
  }
  getName() {
    const t = this.getName();
    return t !== null ? t : "CAD View frame";
  }
  getInstanceInc() {
    const t = this._instanceKey;
    let e = Ei.Local;
    return (this.hasAuthoredId() || this.isImplicitBody()) && (e = Gi(this).getInclusionKey()), [e, t];
  }
  setVisibility(t) {
    t !== this.isVisible() && this.getParent().getParent().markBranchVisibilityDirty(), this._setVisibility(t);
  }
  getRuntimeId() {
    return Ko(this._nodeId, this);
  }
}
var Vt = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.LoadedNodesOnly = 1] = "LoadedNodesOnly", s))(Vt || {});
class l_ {
  constructor(t) {
    this._configuration = t.configuration, this._visibilityFormatter = t.visibilityFormatter, this._resetNonAffectedToDefault = t.resetNonAffectedToDefault, this._resetNonAffectedPmiToDefault = t.resetNonAffectedPmiToDefault, this._state = {
      currentNode: null,
      nodeConfiguration: null,
      appliedVisibility: null,
      inheritedVisibilityStack: [],
      bodiesToShow: [],
      bodiesToHide: []
    }, this.enterProductOccurrence = this.enterProductOccurrence.bind(this), this.leaveProductOccurrence = this.leaveProductOccurrence.bind(this), this.enterAnyBody = this.enterAnyBody.bind(this), this.leaveAnyBody = this.leaveAnyBody.bind(this), this.enterCadView = this.enterCadView.bind(this), this.leaveCadView = this.leaveCadView.bind(this), this.enterPmi = this.enterPmi.bind(this), this.leavePmi = this.leavePmi.bind(this);
  }
  /**
   * Get the visibility formatter of the updater.
   */
  get visibilityFormatter() {
    return this._visibilityFormatter;
  }
  /**
   * Set the visibility formatter of the updater.
   * @param func the formatter to use.
   */
  set visibilityFormatter(t) {
    this._visibilityFormatter = t;
  }
  /**
   * The currently visited node
   */
  get currentNode() {
    return this._state.currentNode;
  }
  /**
   * Getter for the visitor's configuration
   */
  get configuration() {
    return this._configuration;
  }
  /**
   * Getter for the current node's configuration
   */
  get nodeConfiguration() {
    return this._state.nodeConfiguration;
  }
  /**
   * Getter for the output visibility for the current node
   */
  get appliedVisibility() {
    return this._state.appliedVisibility;
  }
  /**
   * Getter for the visitor's state
   */
  get state() {
    return this._state;
  }
  /**
   * Getter for the visit result
   *
   * Mainly the bodies to update.
   */
  get result() {
    return {
      bodies: {
        hide: this._state.bodiesToHide,
        show: this._state.bodiesToShow
      }
    };
  }
  /**
   * Update the visitor state and set the node visibility
   * @param node the node to update
   */
  _updateNodeVisibility(t) {
    this._updateVisitorState(t, !1);
    const e = this.appliedVisibility;
    e !== null && t.setVisibility(e);
  }
  /**
   * Get the visibility config for the current node
   * it contains several fields:
   * explicitVisibility: the value of the node from the visibilityFormatter for the current
   * node, if any visible: whether or not the current node is visible initiallyShown: the node
   * initial visibility
   * initiallyOrConfigurationShown: if configuration.initially.shown is true it
   * returns initiallyShown, otherwise it return initiallyShown or true if the configuration
   * is on the same branch.
   * @returns The current node visibility config
   */
  _getVisibilityConfig() {
    const t = this.currentNode, e = t.isInitiallyShown();
    let i = e;
    return !this._configuration.initially.shown && this._configuration.filterByConfiguration && (i = i || !this._configuration.containsAnyConfig || this._configuration.containsCurrentConfig), {
      explicitVisibility: this._visibilityFormatter ? this._visibilityFormatter(t) : void 0,
      visible: t.isVisible(),
      initiallyShown: e,
      initiallyOrConfigurationShown: i
    };
  }
  /**
   * Get the visibility for a PmiBody node
   *
   * For PMI we allow to switch them to visible if you just set the visibility on the PMI
   * (not its body instance subnode), it's because we don't display the PMI body instance in
   * the tree anymore.
   * @returns true or null
   */
  _getPmiBodyVisibility() {
    const e = this.currentNode.getParent();
    return this._visibilityFormatter && this._visibilityFormatter(e) === !0 ? !0 : null;
  }
  /**
   * If a node is initially hidden and has no explicit visibility set then we keep it
   * hidden by returning null, except for a some exceptions like PmiBody nodes.
   * @returns Null for regular node a boolean otherwise.
   */
  _getInitiallyHiddenNodeVisibility() {
    return this.currentNode instanceof Bs ? this._getPmiBodyVisibility() : null;
  }
  /**
   * Get the inherited visibility value of the node
   * @returns The inherited visibility value of the node if it's different than its current visibility or null
   */
  _getInheritedVisibility() {
    const t = this._state.inheritedVisibilityStack[this._state.inheritedVisibilityStack.length - 1];
    return t !== this.nodeConfiguration.visible ? t && !this.nodeConfiguration.initiallyShown && this._configuration.initially.immutableHidden ? this._getInitiallyHiddenNodeVisibility() : t : null;
  }
  /**
   * When a node is not affected by the traversal, it visibility status is reinitialized if
   * resetNonAffectedToDefault is set and if its not already set to the expected value.
   * When resetNonAffectedPmiToDefault is defined it will be applied on pmis in place of resetNonAffectedToDefault, if it's not defined pmis follow resetNonAffectedToDefault
   * @returns The new visibility status if it's different from the current, null otherwise
   */
  _handleNonAffectedNodeVisibility() {
    return typeof this._resetNonAffectedPmiToDefault < "u" && this.state.currentNode !== null && (this.state.currentNode instanceof Sn || this.state.currentNode instanceof Bs) ? this._resetNonAffectedPmiToDefault && this.nodeConfiguration.visible !== this.nodeConfiguration.initiallyOrConfigurationShown ? this._state.nodeConfiguration.initiallyOrConfigurationShown : null : this._resetNonAffectedToDefault && this.nodeConfiguration.visible !== this.nodeConfiguration.initiallyOrConfigurationShown ? this._state.nodeConfiguration.initiallyOrConfigurationShown : null;
  }
  /**
   * Get the visibility status of the current node
   * @param preventFromResetting whether or not unaffected node will be reinitialized
   * @returns The new visibility status of the node if it's different from the current one, null otherwise
   */
  _getNodeVisibility(t) {
    return this.nodeConfiguration && this.nodeConfiguration.explicitVisibility !== void 0 ? this.nodeConfiguration.explicitVisibility : Do(this.currentNode) ? null : this._configuration.node !== void 0 && this._configuration.filterByConfiguration && this._configuration.containsAnyConfig && !this._configuration.containsCurrentConfig ? !1 : this._state.inheritedVisibilityStack.length > 0 ? this._getInheritedVisibility() : t ? null : this._handleNonAffectedNodeVisibility();
  }
  /**
   * Update the state of the visitor.
   * It set the given node as the current node, generates it visibility config, update the
   * hierarchy and compute the new visibility status.
   * @param node The current node to visit
   * @param preventFromResetting whether or not to reinitialize the node if its not affected.
   */
  _updateVisitorState(t, e) {
    this._state.currentNode = t, this._state.nodeConfiguration = this._getVisibilityConfig(), this._state.nodeConfiguration.explicitVisibility !== void 0 ? this._state.inheritedVisibilityStack.push(this._state.nodeConfiguration.explicitVisibility) : this._state.inheritedVisibilityStack.length > 0 && this._state.inheritedVisibilityStack.push(
      this._state.inheritedVisibilityStack[this._state.inheritedVisibilityStack.length - 1]
    ), this._state.appliedVisibility = this._getNodeVisibility(e);
  }
  /**
   * When the node is left it's popped out of the hierarchy
   */
  leaveNode() {
    this._state.inheritedVisibilityStack.length > 0 && this._state.inheritedVisibilityStack.pop();
  }
  /**
   * Check whether or not the current node is the configuration node and update the visibility.
   * If it is the configuration node it tags the config so the visitor knows the current
   * branch contains the configuration node.
   *
   * @param node the current node
   */
  enterProductOccurrence(t) {
    t.isAConfigurationNode() && (this._configuration.containsAnyConfig = !0, this._configuration.node === t && (this._configuration.containsCurrentConfig = !0)), this._updateNodeVisibility(t);
  }
  /**
   * Check whether or not the current node is the configuration node and update the visibility.
   * If it is the configuration node it removes the tag so the visitor knows the current
   * branch does not contains the configuration node anymore.
   * @param node
   */
  leaveProductOccurrence(t) {
    this.leaveNode(), t.isAConfigurationNode() && (this._configuration.containsAnyConfig = !1, this._configuration.node === t && (this._configuration.containsCurrentConfig = !1));
  }
  /**
   * Updates visibility for Pmi node
   * @param pmi the current Pmi Node
   */
  enterPmi(t) {
    this._updateNodeVisibility(t);
  }
  /**
   * Pops Pmi from hierarchy
   * @param _ not used
   */
  leavePmi(t) {
    this.leaveNode();
  }
  /**
   * Updates visibility for CadView node
   * @param cadView the current CadView Node
   */
  enterCadView(t) {
    this._updateNodeVisibility(t);
  }
  /**
   * Pops CadView from hierarchy
   * @param _ not used
   */
  leaveCadView(t) {
    this.leaveNode();
  }
  /**
   * Updates the visitor's state and apply the new visibility status if any. If the Visibility
   * changes the body is stored in the list of the bodies to hide or to show depending of it's
   * new status.
   * @param body the current AnyBody node
   */
  enterAnyBody(t) {
    const e = t.preventFromResetting();
    this._updateVisitorState(t, e);
    const i = this.appliedVisibility;
    i !== null && (t.setVisibility(i), i ? this._state.bodiesToShow.push(t) : this._state.bodiesToHide.push(t));
  }
  /**
   * Pops AnyBody from hierarchy
   * @param _ not used
   */
  leaveAnyBody(t) {
    return this.leaveNode();
  }
}
class b0 extends l_ {
  constructor(t) {
    super(t), this.enterProductOccurrence = this.enterProductOccurrence.bind(this);
  }
  /**
   * Check whether or not the current node is the configuration node and update the visitor
   * status without updating the node visibility status.
   * If it is the configuration node it tags the config so the visitor knows the current
   * branch contains the configuration node.
   *
   * @param node the current ProductOccurence
   */
  enterProductOccurrence(t) {
    t.isAConfigurationNode() && (this.configuration.containsAnyConfig = !0, this.configuration.node === t && (this.configuration.containsCurrentConfig = !0)), this._updateVisitorState(t, !0);
  }
}
async function c_(s, t = !1) {
  const e = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set(), n = (l) => t ? l.isInitiallyShown() : l.isVisible(), r = {
    enterAnyBody: (l) => {
      if (l instanceof Ui) {
        const h = l.getRuntimeId();
        n(l) ? e.add(h) : i.add(h);
      }
    }
  };
  await Ln.walk(r, s, Vt.None);
  const o = e.size >= i.size;
  return new Eb(o, o ? i : e);
}
function Zu(s) {
  const t = [];
  for (const e of s) {
    const i = e.getInstanceInc();
    t.push(i[0], i[1]);
  }
  return t;
}
function Bp(s) {
  const t = [];
  for (const e of s) {
    const i = e.getRuntimeId();
    t.push(i);
  }
  return t;
}
class h_ {
  constructor(t) {
    this._assemblyTree = t.assemblyTree, this._engine = t.engine, this._callbackManager = t.callbackManager, this._startNode = t.startNode, this._setVisibility = t.setVisibility, this._initiallyHiddenStayHidden = t.initiallyHiddenStayHidden, this._configurationNode = t.configurationNode, this._configuration = null;
  }
  /**
   * Get the visibility formatter for the given attach context
   * @param attachContext the attach context
   * @param setVisibility the visibility directive to apply
   * @returns the default formatter for attach context
   */
  static getAttachContextFormatter(t, e) {
    return (i) => {
      if (i instanceof _e && t.getChildren().indexOf(i) !== -1)
        switch (e) {
          case oo.Hide:
            return !1;
          case oo.Show:
            return !0;
          case oo.Initial:
            return;
        }
    };
  }
  /**
   * Get the updater configuration
   */
  get configuration() {
    return this._configuration;
  }
  /**
   * Generates the configuration for the updater
   *
   * Determine if the configuration we're activating has initially visible nodes or not.
   *
   * It also checks whether the configuration node is an ancestor of the start node. In this
   * case it tags the configuration so it knows the current branch contains the configuration.
   *
   * In the case of older SCs (pre 2022 SP1) non-default configurations had all their nodes
   * set to initially hidden. Since then that has been changed so that the initial visibility states
   * of nodes under configurations reflects their visibility when the configuration is activated.
   * Thus, we need to know which of those cases we're dealing with, by checking for any nodes set to be
   * initially shown.
   *
   * If we're working with configurations we may need to show initially hidden nodes
   * regardless of assembly tree settings.
   * We want to reveal hidden nodes if the configuration has marked them as hidden.
   * See comment the comment above for more details.
   *
   * @returns a promise resolving with the configuration
   */
  async _generateConfig() {
    let t = !1, e = !1, i = !1, n = !1;
    if (this._configurationNode) {
      console.assert(this._configurationNode.isAConfigurationNode()), t = !0;
      const r = await c_(this._configurationNode, !0);
      if ((r.defaultVisibility || r.visibilityExceptions.size !== 0) && (n = !0), !(this._startNode instanceof Pn)) {
        let o = this._startNode;
        for (; o !== null; ) {
          if (o instanceof _e && o.isAConfigurationNode()) {
            i = !0, o === this._configurationNode && (e = !0);
            break;
          }
          const l = o.getParent();
          if (!(l instanceof _e))
            break;
          o = l;
        }
      }
    }
    return this._initiallyHiddenStayHidden === void 0 && (this._configurationNode !== void 0 ? this._initiallyHiddenStayHidden = n : this._initiallyHiddenStayHidden = this._assemblyTree.getInitiallyHiddenStayHidden()), {
      filterByConfiguration: t,
      containsCurrentConfig: e,
      containsAnyConfig: i,
      node: this._configurationNode,
      setVisibility: this._setVisibility,
      initially: {
        shown: n,
        immutableHidden: this._initiallyHiddenStayHidden
      }
    };
  }
  /**
   * Update the visibility of the bodies in the graphic engine.
   *
   * Once the assembly tree has been updated we need to tell the engine that some instances
   * need to be updated so that it can refresh the view.
   *
   * @param bodies the lists of the bodies to show and to hide
   */
  _applyVisibilities(t) {
    if (this._setVisibility) {
      const e = this._startNode.getAttachScope();
      console.assert(e !== Ia.OfInitialEmptyModel), this._engine.setVisibilityByAttachment(e, this._setVisibility);
    } else {
      const e = Zu(t.show), i = Zu(t.hide);
      if (this._engine.pauseAllRendering(), this._engine.setPartVisibility(e, !0, !0), this._engine.setPartVisibility(i, !1, !0), this._engine.resumeAllRendering(), this._callbackManager) {
        const n = Bp(t.show), r = Bp(t.hide);
        this._callbackManager.trigger("visibilityChanged", n, r);
      }
    }
  }
  /**
   * Traverse the assembly tree within a walker to to allow the given visitor to update it.
   * @param visitor The visitor that will update the assembly tree
   * @param {optional} startNode The root of the traversal, default: the updater startNode
   */
  async traverse(t, e) {
    await Ln.walk(t, e || this._startNode, Vt.None);
  }
  /**
   * Initialize the configuration and the attach context if needed
   */
  async init() {
    this._startNode instanceof Pn || console.assert(this._setVisibility === void 0), this._configuration = await this._generateConfig();
  }
  /**
   * Not effect.
   * To allow inheriting classes to cool down or check result after the update.
   */
  async quit() {
  }
  /**
   * Update the assembly tree and the view using the given visitor.
   * @param visitor the Visitor that will update the assembly tree.
   */
  async update(t, e, ...i) {
    const n = new t({ ...e, configuration: this.configuration }, ...i);
    return await this.traverse(n), this._applyVisibilities(n.result.bodies), n;
  }
  /**
   * Update the assembly tree separately with each node as start node
   * @param visitor the visitor used to update the assembly.
   * @param nodeVisibilities the node roots and their visible status.
   */
  async updatePerNode(t, e, i, ...n) {
    const r = new t({ ...i, configuration: this.configuration }, ...n);
    return e.forEach(async (o, l) => {
      const h = r.visibilityFormatter;
      r.visibilityFormatter = (u) => u === u ? o : h ? h(u) : void 0, await this.traverse(r, l), r.visibilityFormatter = h;
    }), this._applyVisibilities(r.result.bodies), r;
  }
}
async function x0(s) {
  return gg({
    ...s,
    startNode: s.attachContext,
    visibilityFormatter: h_.getAttachContextFormatter(
      s.attachContext,
      s.setVisibility
    ),
    resetNonAffectedToDefault: s.setVisibility === oo.Initial,
    initiallyHiddenStayHidden: s.setVisibility !== oo.Show
  });
}
async function Ef(s) {
  return gg(s);
}
async function I0(s) {
  return gg({
    ...s,
    visitorType: b0
  });
}
async function gg(s, ...t) {
  const e = new h_({
    assemblyTree: s.assemblyTree,
    engine: s.engine,
    callbackManager: s.callbackManager,
    startNode: s.startNode,
    setVisibility: s.setVisibility !== null ? s.setVisibility : void 0,
    initiallyHiddenStayHidden: s.initiallyHiddenStayHidden,
    configurationNode: s.configurationNode
  });
  await e.init();
  const i = await e.update(
    s.visitorType || l_,
    {
      visibilityFormatter: s.visibilityFormatter,
      resetNonAffectedToDefault: s.resetNonAffectedToDefault,
      resetNonAffectedPmiToDefault: s.resetNonAffectedPmiToDefault
    },
    ...t
  );
  console.assert(i.state.inheritedVisibilityStack.length === 0), await e.quit();
}
async function C0(s, t) {
  const e = [], i = [], n = {
    enterAnyBody: (l) => {
      if (l instanceof Bs || l instanceof co) {
        const h = l.isVisible();
        l.setVisibility(h), h ? e.push(l) : i.push(l);
      }
    }
  };
  await Ln.walk(n, t, Vt.None);
  const r = Zu(e), o = Zu(i);
  s.pauseAllRendering(), s.synchronizeVisibilities(r, !0), s.synchronizeVisibilities(o, !1), s.resumeAllRendering();
}
const Za = 0, lf = (s) => (s + 1 >>> 1) - 1, mu = (s) => (s << 1) + 1, oc = (s) => s + 1 << 1;
class S0 {
  constructor(t) {
    this._heap = [], this._comparator = t;
  }
  clear() {
    this._heap.length = 0;
  }
  get length() {
    return this._heap.length;
  }
  peek() {
    return this._heap[Za];
  }
  push(t) {
    this._heap.push(t), this._siftUp();
  }
  pop() {
    const t = this.peek(), e = this.length - 1;
    return e > Za && this._swap(Za, e), this._heap.pop(), this._siftDown(), t;
  }
  replace(t) {
    const e = this.peek();
    return this._heap[Za] = t, this._siftDown(), e;
  }
  _greater(t, e) {
    return this._comparator(this._heap[t], this._heap[e]);
  }
  _swap(t, e) {
    [this._heap[t], this._heap[e]] = [this._heap[e], this._heap[t]];
  }
  _siftUp() {
    let t = this.length - 1;
    for (; t > Za && this._greater(t, lf(t)); )
      this._swap(t, lf(t)), t = lf(t);
  }
  _siftDown() {
    let t = Za;
    for (; mu(t) < this.length && this._greater(mu(t), t) || oc(t) < this.length && this._greater(oc(t), t); ) {
      const e = oc(t) < this.length && this._greater(oc(t), mu(t)) ? oc(t) : mu(t);
      this._swap(t, e), t = e;
    }
  }
}
class u_ {
  constructor(t, e, i) {
    this._lazyPromise = t, this._wrapperPromise = e, i !== null && (this.compareValue = i);
  }
  kill() {
    this._lazyPromise = null;
  }
  /*
   * Causes this promise to be killed, and the associated open promise to be resolved.
   * This allows anything waiting on the associated open promise to resolve.
   */
  cancel(t) {
    this._lazyPromise = null, this._wrapperPromise.resolve(t);
  }
  fetch(t, e) {
    this._lazyPromise === null ? (this._wrapperPromise.reject(null), setTimeout(e, 0)) : t(this._lazyPromise).then((i) => {
      this._wrapperPromise.resolve(i);
    }).catch((i) => {
      this._wrapperPromise.reject(i);
    });
  }
}
class d_ {
  constructor(t, e, i) {
    this._failed = !1, this._failureError = null, this._activePromiseCount = 0, this._idlePromise = null, this._latestPromise = Promise.resolve(), this._needsResorting = !1, console.assert(t > 0, "Don't create a non-progressible queue."), this._maxActivePromises = t, this._deferredPromises = e, this._failureFailsAll = i;
  }
  maxActivePromises() {
    return this._maxActivePromises;
  }
  activePromiseCount() {
    return this._activePromiseCount;
  }
  isIdle() {
    return this._activePromiseCount === 0;
  }
  async waitForIdle() {
    if (this.isIdle()) {
      if (this._failureFailsAll && this._failed)
        throw this._failureError;
      return;
    }
    return this._idlePromise === null && (this._idlePromise = wi()), this._idlePromise;
  }
  killDeferred() {
    const t = [];
    for (; this._deferredPromises.length > 0; ) {
      const e = this._dequeue();
      e.kill(), t.push(e);
    }
    for (const e of t)
      this._queue(e);
  }
  _push(t, e) {
    typeof t == "function" && (t = Is.create(t));
    let i;
    return this._activePromiseCount < this._maxActivePromises ? i = this._immediatePromise(t) : i = this._deferPromise(t, e), this._latestPromise = i, i;
  }
  _resort() {
    console.assert(this._needsResorting), this._needsResorting = !1;
    const t = this._drainQueue();
    for (const e of t)
      this._queue(e);
  }
  _drainQueue() {
    const t = [];
    for (; this._deferredPromises.length > 0; ) {
      const e = this._dequeue();
      t.push(e);
    }
    return t;
  }
  _deferPromise(t, e) {
    const i = wi(), n = new u_(t, i, e);
    return this._queue(n), i;
  }
  async _immediatePromise(t) {
    if (this._failureFailsAll && this._failed)
      throw this._failureError;
    ++this._activePromiseCount;
    try {
      const e = await t.get();
      return this._finalizePromise(), e;
    } catch (e) {
      throw this._failureFailsAll && !this._failed && (this._failed = !0, this._failureError = e, this._idlePromise !== null && this._idlePromise.reject(e)), this._finalizePromise(), e;
    }
  }
  // Kicks off the next item in the queue.
  // Precondition: _deferredPromises.length > 0 && _activePromiseCount < _maxActivePromises
  _fetchNext() {
    this._dequeue().fetch(
      (t) => this._immediatePromise(t),
      () => {
        this._finalizePromise();
      }
    );
  }
  _finalizePromise() {
    --this._activePromiseCount, this._deferredPromises.length > 0 ? (this._needsResorting && this._resort(), this._fetchNext()) : this._activePromiseCount === 0 && (this._idlePromise !== null && (this._failureFailsAll && this._failed ? this._idlePromise.reject(this._failureError) : this._idlePromise.resolve(), this._idlePromise = null), this._latestPromise = Promise.resolve());
  }
}
class jo extends d_ {
  _queue(t) {
    this._deferredPromises.push(t);
  }
  _dequeue() {
    return this._deferredPromises.pop();
  }
  constructor(t, e) {
    super(t, new Ym(), e);
  }
  push(t) {
    return this._push(t, null);
  }
  async waitOnLatest() {
    await this._latestPromise;
  }
}
class f_ extends d_ {
  _queue(t) {
    this._deferredPromises.push(t);
  }
  _dequeue() {
    return this._deferredPromises.pop();
  }
  constructor(t, e, i) {
    const n = (o, l) => e(o.compareValue, l.compareValue), r = new S0(n);
    super(t, r, i);
  }
  push(t, e) {
    return this._push(t, e);
  }
  markDirty() {
    this._needsResorting = !0;
  }
}
class P0 extends jo {
  _queue(t) {
    this._deferredPromises.clear(), this._deferredPromises.push(t);
  }
  constructor(t) {
    super(1, t);
  }
}
class k0 extends f_ {
  constructor(t, e, i, n, r) {
    super(i, n, r), this._cutoffAttachments = [], this._attachPriorityManager = e, this._cutoffScale = t;
  }
  setCutoffScale(t) {
    this._cutoffScale = Math.max(Math.min(t, 2), 0);
  }
  cutoffEnabled() {
    return this._cutoffScale !== 0;
  }
  isEmpty() {
    return this._cutoffAttachments.length === 0 && this._deferredPromises.length === 0;
  }
  /*
   * This method will effectively 'cancel' a pending loadSubtreebyXXX operation.
   * The difference between this and the base implementation is that all deferred promises will acually be resolved.
   * This allows for the promise returned by the initial method invocation to resolve when in stream cutoff mode if all items never passed the cutoff test.
   */
  killDeferred() {
    const t = this._drainQueue(), e = this._cutoffAttachments;
    this._cutoffAttachments = [];
    for (const i of t)
      i.cancel(null);
    for (const i of e)
      i.cancel(null);
  }
  /*
   * gets the calculated cutoff value from the attachPriorityManager.
   * Attachments must have a projected size equal to or grater than this value with the current camerta to be considered for fetching.
   * The value returned takes into account the sorting method implemented by the PriorityPromiseQueue
   */
  _getCutoffValue() {
    return this._cutoffScale * -this._attachPriorityManager.getCalculatedCutoff() - 1;
  }
  /*
   * Main entrypoint for items into the prefetch queue.  If cutoff is disabled, then the default behavior will be used and all items streamed.
   * When cutoff scale is enabled, then an items projected size will determine if it is enqueued for fetching or held back for reconsideration on camera update.
   */
  push(t, e) {
    if (!this.cutoffEnabled())
      return this._push(t, e);
    const i = this._attachPriorityManager.getPriorityCompareValue(e), n = this._getCutoffValue();
    if (i > n) {
      typeof t == "function" && (t = Is.create(t));
      const r = wi(), o = new u_(t, r, e);
      return this._cutoffAttachments.push(o), r;
    } else
      return this._push(t, e);
  }
  /*
   * Override method which will apply the cutoff scale logic on all items currently needing to be fetched.
   * This may cause some items which were in the queue to be held back, and new items cycled in to be fetched based on
   * their projected size and the current camera.
   */
  _resort() {
    if (!this.cutoffEnabled()) {
      super._resort();
      return;
    }
    this._needsResorting = !1;
    const t = this._drainQueue(), e = this._cutoffAttachments;
    this._cutoffAttachments = [], this._updateDeferredPromiseArray(t), this._updateDeferredPromiseArray(e);
  }
  /*
   * If the queue has deferred promises left, it will automatically be resorted by the PromiseQueueImpl when the next promise finalizes.
   * Otherwise, we want to force a resort now and kick off the next attachment fetch
   */
  update() {
    if (!this.cutoffEnabled()) {
      this.markDirty();
      return;
    }
    this._cutoffAttachments.length > 0 && (this._resort(), this._refillQueue());
  }
  _refillQueue() {
    const t = Math.min(
      this.maxActivePromises() - this.activePromiseCount(),
      this._deferredPromises.length
    );
    for (let e = 0; e < t; e++)
      this._fetchNext();
  }
  /*
   * This method will scan an array of deferred promises and either place them in the queue to be fetched if they pass the cutoff scale test.
   * items which do not make the cut will be held back for reconsideration when the camera is updated again.
   */
  _updateDeferredPromiseArray(t) {
    for (const e of t) {
      const i = this._attachPriorityManager.getPriorityCompareValue(
        e.compareValue
      ), n = this._getCutoffValue();
      i > n ? this._cutoffAttachments.push(e) : this._queue(e);
    }
  }
}
async function mc(s, t, e, i) {
  const n = [], r = [], o = [], l = /* @__PURE__ */ new Set(), h = (m, x) => {
    if (!m.hasModifiers())
      return x;
    const b = m.getLocalTransform();
    if (b != null) {
      let I = x;
      if (m.ignoreParentScale() && m.ignoreParentRotation())
        x = Wn.copy(b);
      else if (m.ignoreParentScale()) {
        let C = new _(x[0], x[1], x[2]).length(), P = new _(b[0], b[1], b[2]).length();
        if (C > 0) {
          const k = P / C, O = new mt();
          O.setScaleComponent(k, k, k), x = Wn.multiply(x, O.m);
        }
      } else {
        let C = new _(x[0], x[1], x[2]).length();
        if (C > 0) {
          const P = C, k = new mt();
          k.setScaleComponent(P, P, P), x = k.m;
        }
      }
      x[12] = I[12], x[13] = I[13], x[14] = I[14];
    }
    return x;
  }, u = (m) => {
    if (l.has(m))
      return !1;
    l.add(m);
    const x = m.getLocalTransform();
    if (x !== null) {
      let b = n[n.length - 1];
      b = Wn.multiply(x, b), n.push(b);
    }
    return !0;
  }, d = (m) => {
    m.getLocalTransform() !== null && (console.assert(n.length > 1), n.pop());
  }, g = {
    followProductOccurrence: u,
    leaveProductOccurrence: d,
    followPmi: u,
    leavePmi: d,
    followCadView: u,
    leaveCadView: d,
    followAnyBody: u,
    enterAnyBody: (m) => {
      if (!m.isOutOfHierarchy() || i) {
        const x = m.getInstanceInc();
        o.push(x[0], x[1]);
        const b = h(m, n[n.length - 1]);
        r.push(mt.createFromArray(b));
      }
    },
    leaveAnyBody: d
  }, y = new jo(1, !0);
  for (const m of e) {
    const x = Is.create(async () => {
      console.assert(n.length === 0);
      const b = oh(m.getParent());
      n.push(b), await Ln.walk(g, m, Vt.None), console.assert(n.length === 1), n.pop();
    });
    y.push(x);
  }
  await y.waitForIdle(), console.assert(2 * r.length === o.length), s.setMatrices(o, r), t.trigger("_updateTransform", i);
}
function _u(s) {
  return s.isLoaded();
}
function Qa() {
  return !0;
}
function Gs() {
}
class g_ {
  constructor(t, e) {
    this.followProductOccurrence = Qa, this.enterProductOccurrence = Gs, this.leaveProductOccurrence = Gs, this.followPartDefinition = Qa, this.enterPartDefinition = Gs, this.leavePartDefinition = Gs, this.followRepresentationItem = Qa, this.enterRepresentationItem = Gs, this.leaveRepresentationItem = Gs, this.followAnyBody = Qa, this.enterAnyBody = Gs, this.leaveAnyBody = Gs, this.followCadView = Qa, this.enterCadView = Gs, this.leaveCadView = Gs, this.followPmi = Qa, this.enterPmi = Gs, this.leavePmi = Gs, e === Vt.LoadedNodesOnly && (console.assert(t.followProductOccurrence === void 0), console.assert(t.followAnyBody === void 0), console.assert(t.followCadView === void 0), console.assert(t.followPmi === void 0), this.followProductOccurrence = _u, this.followAnyBody = _u, this.followCadView = _u, this.followPmi = _u), t.followProductOccurrence !== void 0 && (this.followProductOccurrence = t.followProductOccurrence), t.enterProductOccurrence !== void 0 && (this.enterProductOccurrence = t.enterProductOccurrence), t.leaveProductOccurrence !== void 0 && (this.leaveProductOccurrence = t.leaveProductOccurrence), t.followPartDefinition !== void 0 && (this.followPartDefinition = t.followPartDefinition), t.enterPartDefinition !== void 0 && (this.enterPartDefinition = t.enterPartDefinition), t.leavePartDefinition !== void 0 && (this.leavePartDefinition = t.leavePartDefinition), t.followRepresentationItem !== void 0 && (this.followRepresentationItem = t.followRepresentationItem), t.enterRepresentationItem !== void 0 && (this.enterRepresentationItem = t.enterRepresentationItem), t.leaveRepresentationItem !== void 0 && (this.leaveRepresentationItem = t.leaveRepresentationItem), t.followAnyBody !== void 0 && (this.followAnyBody = t.followAnyBody), t.enterAnyBody !== void 0 && (this.enterAnyBody = t.enterAnyBody), t.leaveAnyBody !== void 0 && (this.leaveAnyBody = t.leaveAnyBody), t.followCadView !== void 0 && (this.followCadView = t.followCadView), t.enterCadView !== void 0 && (this.enterCadView = t.enterCadView), t.leaveCadView !== void 0 && (this.leaveCadView = t.leaveCadView), t.followPmi !== void 0 && (this.followPmi = t.followPmi), t.enterPmi !== void 0 && (this.enterPmi = t.enterPmi), t.leavePmi !== void 0 && (this.leavePmi = t.leavePmi);
  }
}
class Nh {
  static walk(t, e, i) {
    if (i === Vt.LoadedNodesOnly && !e.isLoaded())
      return;
    const n = new Nh(t, i);
    return e instanceof _e ? n._walkProductOccurrence(e) : e instanceof Sn ? n._walkPmi(e) : e instanceof ss ? n._walkCadView(e) : n._walkAnyBody(e);
  }
  constructor(t, e) {
    this._visitor = new g_(t, e);
  }
  _walkRepresentationItem(t) {
    console.assert(t.isLoaded()), this._visitor.followRepresentationItem(t) && (this._visitor.enterRepresentationItem(t), this._visitor.leaveRepresentationItem(t));
  }
  _walkPartDefinition(t) {
    if (console.assert(t.isLoaded()), this._visitor.followPartDefinition(t)) {
      this._visitor.enterPartDefinition(t);
      const e = t.getRepresentationItems();
      for (const i of e)
        this._walkRepresentationItem(i);
      this._visitor.leavePartDefinition(t);
    }
  }
  _walkAnyBody(t) {
    console.assert(t.isLoaded()), this._visitor.followAnyBody(t) && (this._visitor.enterAnyBody(t), this._visitor.leaveAnyBody(t));
  }
  _walkPmi(t) {
    if (console.assert(t.isLoaded()), this._visitor.followPmi(t)) {
      this._visitor.enterPmi(t);
      for (const e of t.getPmiBodies())
        this._walkAnyBody(e);
      this._visitor.leavePmi(t);
    }
  }
  _walkCadView(t) {
    if (console.assert(t.isLoaded()), this._visitor.followCadView(t)) {
      this._visitor.enterCadView(t);
      const e = t.getViewFrame();
      e !== null && this._walkAnyBody(e), this._visitor.leaveCadView(t);
    }
  }
  _walkProductOccurrence(t) {
    if (console.assert(t.isLoaded()), this._visitor.followProductOccurrence(t)) {
      this._visitor.enterProductOccurrence(t);
      const e = t.getPartDefinitionSync();
      e !== null && this._walkPartDefinition(e);
      const i = t.getChildrenSync();
      for (const l of i)
        this._walkProductOccurrence(l);
      const n = t.getBodyInstances();
      for (const l of n)
        this._walkAnyBody(l);
      const r = t.getPmis();
      for (const l of r)
        this._walkPmi(l);
      const o = t.getCadViews();
      for (const l of o)
        this._walkCadView(l);
      this._visitor.leaveProductOccurrence(t);
    }
  }
}
function p_(s, t, e, i, n, r) {
  const o = [], h = {
    enterAnyBody: (d) => {
      if (n.has(d))
        return;
      if (n.add(d), d instanceof Ui) {
        if (!ne(e, $t.BodyInstance) || d.isOutOfHierarchy() && !i)
          return;
      } else if (d instanceof Bs) {
        if (!ne(e, $t.PmiBody))
          return;
      } else if (!ne(e, $t.ViewFrame))
        return;
      const g = d.getInstanceInc();
      o.push(g[0], g[1]);
    }
  }, u = s.walk(h, t, r);
  return u ? u.then(() => o) : o;
}
function m_(s, t, e, i) {
  return p_(
    Ln,
    s,
    t,
    e,
    i,
    Vt.None
  );
}
function ih(s, t, e, i, n) {
  return p_(
    Nh,
    s,
    t,
    e,
    i,
    n
  );
}
function __(s, t, e, i) {
  let n = null;
  const r = /* @__PURE__ */ new Set();
  for (const o of t) {
    const l = s.lookupAnyTreeNode(o);
    if (l === null)
      throw new Ds(o);
    const h = Do(l), u = ih(
      l,
      e,
      h,
      r,
      i
    );
    if (n === null)
      n = u;
    else
      for (const d of u)
        n.push(d);
  }
  return n !== null ? n : [];
}
async function y_(s, t, e, i, n, r) {
  const o = __(
    s,
    e,
    i,
    Vt.None
  );
  if (o.length === 0)
    throw new oe("Cannot get the bounding of node without geometry.");
  return t.getPartsBounding(o, n, r);
}
function M0(s, t) {
  const e = new jo(1, !0);
  e.push(() => s.clear());
  for (const i of t)
    e.push(() => s.addPlane(i, null));
  return e.waitForIdle();
}
function E0(s, t, e) {
  const i = e.getRuntimeId(), n = s.get(i);
  n !== void 0 ? (e.overrideLocalTransform(n), t.push(e)) : e.hasLocalTransformOverride() && (e.removeLocalTransformOverride(), t.push(e));
}
function A0(s, t) {
  t.hasLocalTransformOverride() && (t.removeLocalTransformOverride(), s.push(t));
}
class ss extends ts {
  static parseXml(t, e, i, n) {
    let r = 0;
    const o = gi.parseNodeId(e, "Id");
    if (o === null)
      throw new si('Expected "Id" attribute.');
    const l = e.getAttribute("Name");
    if (l === null)
      throw new si('Expected "Name" attribute');
    const h = (Y, q, st, dt) => {
      const U = Y.getAttribute("Enabled");
      if (U === null)
        throw new si(`Expected ${st} attribute`);
      return q = pa(q, dt, U === "1"), q;
    }, u = e.getAttribute("isAnnotationView");
    u === null ? r = pa(r, Ii.IsAnnotationView, !1) : r = pa(r, Ii.IsAnnotationView, u === "true");
    let d = null, g = null, y = [], m = [], x = [], b = [], I = /* @__PURE__ */ new Map(), C = [];
    const P = (Y) => {
      const q = gi.parseUint(Y, "Projection");
      if (q === null)
        throw new si('Expected "Projection" attribute');
      const st = Y.getAttribute("field");
      if (st === null)
        throw new si('Expected "field" attribute');
      const dt = st.split(" ");
      if (dt.length !== 2)
        throw new si("Expected 2 field values");
      const U = parseFloat(dt[0]), J = parseFloat(dt[1]), A = Y.getAttribute("definition");
      if (A === null)
        throw new si('Expected "definition" attribute');
      const R = A.split(" ");
      if (R.length !== 9)
        throw new si("Expected 9 definition values");
      const wt = (At, at) => new _(
        parseFloat(At[at]),
        parseFloat(At[at + 1]),
        parseFloat(At[at + 2])
      ), z = wt(R, 0), St = wt(R, 3), X = wt(R, 6);
      return Cn.create(z, St, X, q, U, J);
    }, k = (Y) => {
      if (gi.parseUint(Y, "Count") === null)
        throw new si('Expected "Count" attribute');
      const st = gi.parseUints(Y, "FilterIds");
      if (st === null)
        throw new si('Expected "FilterIds" attribute');
      return st;
    }, O = (Y) => {
      const q = [];
      if (gi.parseUint(Y, "Count") === null)
        throw new si('Expected "PMIToShow Count" attribute');
      const dt = gi.parseNodeIds(Y, "IDs");
      if (dt === null)
        throw new si('Expected "PMIToShow Ids" attribute');
      for (let U = 0; U < dt.length; U += 2)
        q.push(dt[U + 1]);
      return q;
    }, B = (Y) => {
      const q = [], st = gi.parseUint(Y, "Count");
      if (st === null)
        throw new si('Expected "ClipPlanes Count" attribute');
      const dt = gi.parseFloats(Y, "Plane");
      if (dt === null)
        throw new si('Expected "Plane" attribute');
      if (dt.length / 4 !== st)
        throw new si(`Expected ${st} Planes`);
      for (let U = 0; U < dt.length; U += 4)
        q.push(
          ln.createFromCoefficients(dt[U], dt[U + 1], dt[U + 2], dt[U + 3])
        );
      return q;
    }, j = (Y) => {
      const q = /* @__PURE__ */ new Map(), st = gi.parseUint(Y, "Count");
      if (st === null)
        throw new si('Expected "IDLocalTransform Count" attribute');
      const dt = gi.parseFloats(Y, "IDTransform");
      if (dt === null)
        throw new si('Expected "IDTransform" attribute');
      {
        if (dt.length / 13 !== st)
          throw new si(`Expected ${st} IDTransform values`);
        const U = (J, A) => {
          const R = Wn.getIdentity();
          return R[1] = J[A + 1], R[2] = J[A + 2], R[3] = J[A + 3], R[4] = J[A + 4], R[6] = J[A + 5], R[7] = J[A + 6], R[8] = J[A + 7], R[9] = J[A + 8], R[11] = J[A + 9], R[12] = J[A + 10], R[13] = J[A + 11], R[14] = J[A + 12], R;
        };
        for (let J = 0; J < dt.length; J += 13) {
          const A = dt[J], R = U(dt, J);
          q.set(A, R);
        }
      }
      return q;
    };
    let V = e.firstElementChild;
    for (; V !== null; )
      V.localName === "Camera" ? (console.assert(d === null), d = P(V)) : V.localName === "Frame" ? g = co.parseXml(
        t,
        V,
        i.getInclusionKey(),
        n
      ) : V.localName === "PMIToShow" ? y = O(V) : V.localName === "InstanceToShow" ? m = gi.parseNodeIds(V, "IDs") : V.localName === "InstanceToHide" ? x = gi.parseNodeIds(V, "IDs") : V.localName === "ClipPlanes" ? C = B(V) : V.localName === "IDLocalTransform" ? I = j(V) : V.localName === "IsCameraSet" ? r = h(
        V,
        r,
        "IsCameraSet",
        Ii.IsCameraSet
      ) : V.localName === "IsPMIFilteringSet" ? r = h(
        V,
        r,
        "IsPMIFilteringSet",
        Ii.IsPmiFilteringSet
      ) : V.localName === "IsGeomFilteringSet" ? r = h(
        V,
        r,
        "IsGeomFilteringSet",
        Ii.IsGeomFilteringSet
      ) : V.localName === "IsCrosssectionSet" ? r = h(
        V,
        r,
        "IsCrosssectionSet",
        Ii.IsCrossSectionSet
      ) : V.localName === "IsExplosionSet" ? r = h(
        V,
        r,
        "IsExplosionSet",
        Ii.IsExplosionSet
      ) : V.localName === "IsCombineState" ? r = h(
        V,
        r,
        "IsCombineState",
        Ii.IsCombineState
      ) : V.localName === "Filters" && (b = k(V)), V = V.nextElementSibling;
    return {
      nodeId: o,
      name: l,
      camera: d,
      instanceMarkupKeysToShow: y,
      viewFrameInfo: g,
      nodesToShow: m ?? [],
      nodesToHide: x ?? [],
      filters: b ?? [],
      transformMap: I,
      cuttingPlanes: C,
      bits: r
    };
  }
  static parseBinary(t, e, i, n) {
    const r = i.parseViewParseBits(), o = i.parseNodeId();
    let l = null;
    ne(r, vn.Name) && (l = i.parseCString());
    let h = 0, u = !1;
    ne(r, vn.IsAnnotationView) ? (u = !0, l += " # Annotation View") : l !== null && l.indexOf("# Annotation View") >= 0 && (u = !0), u && (h |= Ii.IsAnnotationView), ne(r, vn.IsNotPmiFilteringSet) || (h |= Ii.IsPmiFilteringSet), ne(r, vn.IsNotGeomFilteringSet) || (h |= Ii.IsGeomFilteringSet), ne(r, vn.IsNotCrosssectionSet) || (h |= Ii.IsCrossSectionSet), ne(r, vn.IsNotExplosionSet) || (h |= Ii.IsExplosionSet), ne(r, vn.IsCombineState) && (h |= Ii.IsCombineState), ne(r, vn.IsDefaultView) && (h |= Ii.IsDefaultView);
    const d = ne(r, vn.IsPerspective);
    d && (h |= Ii.IsPerspective);
    let g = null;
    if (ne(r, vn.Camera)) {
      const k = d ? ri.Perspective : ri.Orthographic, O = i.parsePoint3_32(), B = i.parsePoint3_32(), j = i.parsePoint3_32(), V = i.parseFloat_32(), Y = i.parseFloat_32();
      ne(r, vn.IsNotCameraSet) || (h |= Ii.IsCameraSet, g = Cn.create(O, B, j, k, V, Y), (V < 0 || Y < 0) && (h |= Ii.HasDynamicFrame));
    }
    const y = [];
    if (ne(r, vn.Pmi)) {
      const k = i.parseCount_32();
      for (let O = 0; O < k; ++O) {
        const B = i.parseInstanceKey();
        y.push(B);
      }
    }
    let m = null;
    ne(r, vn.Frame) && (m = co.parseBinary(t, e, i, n));
    const x = [];
    if (ne(r, vn.ShowNodes)) {
      const k = i.parseCount_32();
      for (let O = 0; O < k; ++O) {
        const B = i.parseNodeId();
        x.push(B);
      }
    }
    const b = [];
    if (ne(r, vn.HideNodes)) {
      const k = i.parseCount_32();
      for (let O = 0; O < k; ++O) {
        const B = i.parseNodeId();
        b.push(B);
      }
    }
    const I = new Array();
    if (ne(r, vn.ViewFilters)) {
      const k = i.parseCount_32();
      for (let O = 0; O < k; ++O) {
        const B = i.parseUInt32();
        I.push(B);
      }
    }
    const C = /* @__PURE__ */ new Map();
    if (ne(r, vn.MoveNodes)) {
      const k = i.parseCount_32();
      for (let O = 0; O < k; ++O) {
        const B = i.parseNodeId(), j = Wn.parseBinary(i);
        C.set(B, j);
      }
    }
    const P = [];
    if (ne(r, vn.CuttingPlanes)) {
      const k = i.parseCount_32();
      for (let O = 0; O < k; ++O) {
        const B = i.parsePlane3_32();
        P.push(B);
      }
    }
    return {
      nodeId: o,
      name: l,
      camera: g,
      instanceMarkupKeysToShow: y,
      viewFrameInfo: m,
      nodesToShow: x,
      nodesToHide: b,
      filters: I,
      transformMap: C,
      cuttingPlanes: P,
      bits: h
    };
  }
  static reify(t, e, i, n) {
    const r = Fi(e), o = new ss(t, e, i, 0, n);
    return r.attachedInvisibly() && o.setVisibility(!1), o;
  }
  static createDynamic(t, e, i, n, r, o, l, h, u) {
    const d = Gi(e), g = t.generateDynamicNodeId(), y = [];
    let m = Ii.IsCameraSet;
    if (r != null) {
      m = pa(m, Ii.IsPmiFilteringSet, !0);
      for (const I of r)
        for (const C of I.getPmiBodies()) {
          const P = Gi(C);
          console.assert(d === P);
          const O = C.getInstanceInc()[1];
          y.push(O);
        }
    }
    const x = {
      nodeId: g,
      name: i,
      camera: n,
      instanceMarkupKeysToShow: y,
      viewFrameInfo: null,
      nodesToShow: o,
      nodesToHide: l,
      filters: [],
      transformMap: h,
      cuttingPlanes: u !== null ? [u] : [],
      bits: m
    };
    return new ss(
      t,
      d,
      x,
      1,
      e
    );
  }
  static isAuthoredViewInfo(t, e) {
    return e === 0;
  }
  constructor(t, e, i, n, r) {
    const l = Fi(e).getMasterModelKey(), h = {
      nodeId: i.nodeId,
      bits: 0,
      name: i.name,
      localTransform: null,
      attributes: [],
      header: Ys.dynamic,
      exchangeId: null,
      layerId: null,
      genericTypeId: null,
      genericId: null,
      userDatas: null
    };
    if (super(t, l, h), this._parent = r, this._bits |= i.bits, i.camera !== null && (this._camera = {
      initial: i.camera.copy(),
      derived: i.camera.copy()
    }), i.filters.length > 0 && (this._filters = i.filters), this._instanceMarkupKeysToShow = Ec(i.instanceMarkupKeysToShow), ss.isAuthoredViewInfo(i, n) ? (this._nodesToShow = ss._toRuntimeIds(e, i.nodesToShow), this._nodesToHide = ss._toRuntimeIds(e, i.nodesToHide), i.transformMap.size > 0 && (this._transformMap = /* @__PURE__ */ new Map(), i.transformMap.forEach((u, d) => {
      const g = e.toRuntimeId(d);
      this._transformMap.set(g, Wn.copy(u));
    }))) : (this._nodesToShow = Ec(i.nodesToShow), this._nodesToHide = Ec(i.nodesToHide), i.transformMap.size > 0 && (this._transformMap = gd(i.transformMap))), i.viewFrameInfo !== null && (this._viewFrame = this._loadViewFrame(t, l, i.viewFrameInfo)), i.cuttingPlanes.length > 0) {
      this._cuttingPlanes = vs(i.cuttingPlanes);
      let u = 1;
      const d = Hp(this), g = Fi(d), y = pr(g);
      if (y) {
        const m = d.getMeasurementUnit(), x = y.getMeasurementUnit();
        m !== x && (u = m / x);
      }
      u !== 1 && hi(this._cuttingPlanes).forEach((m) => {
        m.d *= u;
      });
    }
    t.registerCadView(this);
  }
  getFilters() {
    return this._filters !== void 0 ? this._filters : null;
  }
  static _toRuntimeIds(t, e) {
    const i = /* @__PURE__ */ new Set();
    for (const n of e) {
      const r = t.toRuntimeId(n);
      i.add(r);
    }
    return i;
  }
  _loadViewFrame(t, e, i) {
    return co.reify(t, e, this, i);
  }
  getViewFrame() {
    return this._viewFrame ?? null;
  }
  getParent() {
    return this._parent;
  }
  getRuntimeId() {
    return Ko(this._nodeId, this);
  }
  getBranchVisibility() {
    let t = this.isVisible() ? de.Shown : de.Hidden;
    return this._viewFrame !== void 0 && !this._viewFrame.isOutOfHierarchy() && (t |= this._viewFrame.isVisible() ? de.Shown : de.Hidden), t;
  }
  setVisibility(t) {
    this._setVisibility(t);
  }
  isPmiFilteringSet() {
    return this._hasBits(Ii.IsPmiFilteringSet);
  }
  isDefaultView() {
    return this._hasBits(Ii.IsDefaultView);
  }
  IsCombineState() {
    return this._hasBits(Ii.IsCombineState);
  }
  deactivate(t) {
    return t.clearAllCuttingSections();
  }
  async _replaceCuttingPlanes(t, e) {
    await t.clearAllCuttingSections();
    const i = t.getCuttingSectionCount();
    if (e.length > i)
      throw new oe(
        `System does not support more than ${i} cutting planes in a CadView`
      );
    const n = e.reduce(
      (r, o, l) => {
        const h = t.getCuttingSection(l);
        return console.assert(h !== null), r.push(M0(h, [o])), r;
      },
      []
    );
    await Promise.all(n), await t.activateCuttingSections();
  }
  async activate(t, e, i, n, r, o, l, h) {
    return await this._activateView(
      t,
      e,
      i,
      n,
      h
    ), this._activateCamera(t, e, r, o, l);
  }
  // XXX: I have doubts that this is implemented correctly. Intentionally matching old behavior for now.
  async _activateView(t, e, i, n, r) {
    const o = t.getRootNode();
    r !== null && console.assert(r.isAConfigurationNode());
    const l = (r == null ? void 0 : r.getRuntimeId()) ?? Ts;
    let h = Ts;
    const u = /* @__PURE__ */ new Map(), d = [], g = [];
    let y = A0;
    this._transformMap !== void 0 && (y = (C, P) => {
      E0(this._transformMap, C, P);
    });
    const m = {
      enterProductOccurrence: (C) => {
        const P = C;
        P.isAConfigurationNode() && (h = P.getRuntimeId());
        const k = h, O = P.forEachPmi((B) => {
          const j = B.getPmiBodies();
          if (j.length !== 0 && this.isPmiFilteringSet()) {
            let V = !1;
            for (const Y of j) {
              const st = Y.getInstanceInc()[1];
              if (this._instanceMarkupKeysToShow.has(st)) {
                V = !0;
                break;
              }
            }
            r !== null && (V = V && (k === l || k === Ts)), u.set(B, V);
            for (const Y of j)
              u.set(Y, V);
          }
        }).then(() => {
          const B = P.getRuntimeId();
          return this._nodesToHide.has(B) || P.isADrawingSheetNode() ? u.set(P, !1) : this._nodesToShow.has(B) && (r !== null ? u.set(
            P,
            k === l || k === Ts
          ) : u.set(P, !0)), y(d, P), P.forEachCadView((j) => {
            const V = j;
            if (V._viewFrame !== void 0) {
              let Y = V === this;
              r !== null && (Y = Y && (k === l || k === Ts)), u.set(j, Y), u.set(V._viewFrame, Y);
            }
          });
        });
        g.push(O);
      },
      leaveProductOccurrence: (C) => {
        C.isAConfigurationNode() && (h = Ts);
      },
      enterAnyBody: (C) => {
        if (C.isOutOfHierarchy())
          return;
        y(d, C);
        let P = C.getParent();
        for (; P !== null && !(P instanceof Sn); ) {
          const O = P.getRuntimeId();
          if (this._nodesToHide.has(O)) {
            u.set(P, !1);
            break;
          } else if (this._nodesToShow.has(O)) {
            u.set(P, !0);
            break;
          }
          P = I_(P.getParent());
        }
        const k = C.getRuntimeId();
        this._nodesToShow.has(k) ? u.set(C, !0) : this._nodesToHide.has(k) && u.set(C, !1), r !== null && h !== Ts && h !== l && u.set(C, !1);
      }
    };
    await Ln.walk(m, o, Vt.None), await Promise.all(g);
    const x = [];
    let b = Ef({
      assemblyTree: t,
      engine: e,
      startNode: o,
      visibilityFormatter: (C) => u.get(C),
      resetNonAffectedToDefault: !0,
      resetNonAffectedPmiToDefault: this.isPmiFilteringSet(),
      configurationNode: r ?? void 0,
      callbackManager: i,
      initiallyHiddenStayHidden: !1
    });
    x.push(b), b = mc(e, i, d, !1), x.push(b), await Ge(x);
    const I = hi(this._cuttingPlanes);
    await this._replaceCuttingPlanes(n, I);
  }
  async _activateCamera(t, e, i, n, r) {
    const o = this._camera;
    if (o === void 0) {
      t.disableAutomaticFitWorld() || await i.fitWorld(n);
      return;
    }
    if (!r)
      return i._setCameraPromise(o.initial, n);
    const l = Hp(this), h = Fi(l), u = pr(h);
    let d = mt.createFromArray(oh(h));
    if (u !== null) {
      const g = l.getMeasurementUnit(), y = u.getMeasurementUnit();
      if (g !== y) {
        const m = g / y, x = new mt();
        x.setScaleComponent(m, m, m), d = mt.multiply(x, d);
      }
    }
    if (o.derived = o.initial.transform(d), this._hasBits(Ii.HasDynamicFrame)) {
      const y = this._viewFrame !== void 0 ? await y_(
        t,
        e,
        [this._viewFrame.getRuntimeId()],
        $t.All,
        !1,
        !1
      ) : await e.getModelBounding(!0, !1, !1), m = _.subtract(o.derived.getTarget(), o.derived.getPosition()), x = y.extents().length(), b = m.copy().normalize().scale(x), I = y.center(), C = _.subtract(I, b);
      return o.derived.setPosition(C), o.derived.setTarget(I), o.derived.setWidth(x), o.derived.setHeight(x), i._setCameraPromise(o.derived, n);
    } else if (o.derived.getProjection() === ri.Orthographic) {
      const g = _.subtract(
        o.derived.getTarget(),
        o.derived.getPosition()
      ), y = await e.getModelBounding(!0, !1, !1), m = _.subtract(y.center(), o.derived.getPosition()), x = 1 / g.length(), b = x * _.dot(g, m);
      if (b > 0) {
        g.scale(x);
        const I = Math.max(o.derived.getWidth(), o.derived.getHeight()), C = _.add(
          o.derived.getPosition(),
          _.scale(g, b)
        ), P = _.subtract(
          C,
          _.scale(g, 2.5 * I)
        );
        o.derived.setPosition(P), o.derived.setTarget(C);
      }
      return i._setCameraPromise(o.derived, n);
    } else if (o.derived.getProjection() === ri.Perspective) {
      const y = await e.getModelBounding(!0, !1, !1), m = _.subtract(y.max, y.min).length(), x = _.subtract(
        o.derived.getTarget(),
        o.derived.getPosition()
      ), b = x.length(), I = b / m;
      if (m === 0 || I > 0.01)
        return i._setCameraPromise(o.derived, n);
      const C = m * 0.01 * 1.001, P = o.derived.getWidth() / b, k = o.derived.getHeight() / b, O = P * C, B = k * C, j = x.copy().normalize().scale(C), V = _.add(o.derived.getPosition(), j);
      return o.derived.setTarget(V), o.derived.setWidth(O), o.derived.setHeight(B), i._setCameraPromise(o.derived, n);
    } else
      return i._setCameraPromise(o.derived, n);
  }
  hasPmi(t) {
    const e = Gi(this).getInclusionKey(), i = Gi(t).getInclusionKey();
    if (e !== i)
      return !1;
    for (const n of t.getPmiBodies()) {
      const r = n.getInstanceInc()[1];
      if (this._instanceMarkupKeysToShow.has(r))
        return !0;
    }
    return !1;
  }
  isAnnotationView() {
    return this._hasBits(Ii.IsAnnotationView);
  }
  isCombineStateView() {
    return this._hasBits(Ii.IsCombineState);
  }
  setViewFrame(t) {
    console.assert(this._viewFrame === void 0), this._viewFrame = t;
  }
}
class Ln {
  static walk(t, e, i) {
    if (i === Vt.LoadedNodesOnly && !e.isLoaded())
      return Promise.resolve();
    const n = new Ln(t, i);
    if (e instanceof ts)
      return n._walkAnyTreeNode(e);
    {
      const r = new Ac(1, !1), o = e.getChildren();
      for (const l of o)
        r.push(() => n._walkAnyTreeNode(l));
      return r.waitForIdle();
    }
  }
  static forceLazyPromises(t) {
    return this.walk({}, t, Vt.None);
  }
  constructor(t, e) {
    this._visitor = new g_(t, e);
  }
  _walkAnyTreeNode(t) {
    let e;
    return t instanceof _e ? e = this._walkProductOccurrence(t) : t instanceof Sn ? e = this._walkPmi(t) : t instanceof ss ? e = this._walkCadView(t) : e = this._walkAnyBody(t), e === void 0 ? Promise.resolve() : e;
  }
  _walkRepresentationItem(t) {
    this._visitor.followRepresentationItem(t) && (this._visitor.enterRepresentationItem(t), this._visitor.leaveRepresentationItem(t));
  }
  _walkPartDefinition(t) {
    if (this._visitor.followPartDefinition(t)) {
      this._visitor.enterPartDefinition(t);
      const e = t.getRepresentationItems();
      for (const i of e)
        this._walkRepresentationItem(i);
      this._visitor.leavePartDefinition(t);
    }
  }
  _walkAnyBody(t) {
    this._visitor.followAnyBody(t) && (this._visitor.enterAnyBody(t), this._visitor.leaveAnyBody(t));
  }
  _walkPmi(t) {
    if (this._visitor.followPmi(t)) {
      this._visitor.enterPmi(t);
      for (const e of t.getPmiBodies())
        this._walkAnyBody(e);
      this._visitor.leavePmi(t);
    }
  }
  _walkCadView(t) {
    if (this._visitor.followCadView(t)) {
      this._visitor.enterCadView(t);
      const e = t.getViewFrame();
      e !== null && this._walkAnyBody(e), this._visitor.leaveCadView(t);
    }
  }
  _walkProductOccurrence(t) {
    const e = new Ac(1, !1);
    if (this._visitor.followProductOccurrence(t)) {
      this._visitor.enterProductOccurrence(t);
      const i = t.getRawPartDefinition();
      i !== null && (i instanceof jn ? e.push(() => {
        if (i.isResolved())
          return this._walkPartDefinition(i.getResolved());
      }) : e.push(() => i.then((h) => {
        if (h !== null) {
          const u = h.value;
          if (u.isResolved())
            return this._walkPartDefinition(u.getResolved());
        }
        return Promise.resolve();
      })));
      const n = t.tryGetChildrenSync();
      if (n !== null)
        for (const h of n)
          e.push(() => this._walkProductOccurrence(h));
      else
        e.push(() => t.getChildren().then((h) => {
          if (h.length === 0)
            return;
          const u = new Ac(1, !1);
          for (const d of h)
            u.push(() => this._walkProductOccurrence(d));
          if (!u.isIdle())
            return u.waitForIdle();
        }));
      const r = t.getBodyInstances();
      for (const h of r)
        e.push(() => this._walkAnyBody(h));
      const o = t.getPmis();
      for (const h of o)
        e.push(() => this._walkPmi(h));
      const l = t.getCadViews();
      for (const h of l)
        e.push(() => this._walkCadView(h));
      e.push(() => this._visitor.leaveProductOccurrence(t));
    }
    if (!e.isIdle())
      return e.waitForIdle();
  }
}
function w_(s) {
  const t = s.getPrototype();
  if (t === null)
    return;
  let e;
  const i = t.getProductOccurrence();
  return i.isResolved() ? e = Af(i.getResolved()) : e = i.then(Af), e.then(() => {
    console.assert(i.isResolved()), i.getResolved().markLoaded();
  });
}
async function Af(s) {
  const t = [], e = {
    enterProductOccurrence: (i) => {
      const n = w_(i);
      n !== void 0 && t.push(n);
    }
  };
  return await Ln.walk(e, s, Vt.None), Ge(t);
}
function Vp(s) {
  s.markLoaded();
  const t = s.getRepresentationItems();
  for (const e of t)
    e.markLoaded();
}
function zp(s) {
  const t = s.getRawPartDefinition();
  if (t !== null)
    return t instanceof jn ? t.isResolved() ? void 0 : t.then(Vp) : t.then((e) => {
      if (e === null)
        return;
      const i = e.value;
      if (!i.isResolved())
        return i.then(Vp);
    });
}
function nh(s) {
  const t = w_(s);
  return t !== void 0 ? t.then(() => zp(s)) : zp(s);
}
async function T0(s) {
  const t = [], e = {
    enterProductOccurrence: (i) => {
      const n = nh(i);
      n !== void 0 && t.push(n);
    }
  };
  return await Ln.walk(e, s, Vt.None), Ge(t);
}
class pg {
  constructor(t) {
    this._referrers = null, this._prototype = t;
  }
  _addReferrer(t) {
    this._referrers = Yn(this._referrers, t);
  }
  _getReferrers() {
    return hi(this._referrers);
  }
  _getPrototype() {
    return this._prototype;
  }
  _removeReferrer(t) {
    let e = !1, i = hi(this._referrers);
    return i = i.filter((n) => n === t ? (e = !0, !1) : !0), e ? (i.length === 0 ? this._referrers = null : this._referrers = vs(i), !0) : !1;
  }
  async _purgeContents() {
    this._prototype.isUnforced() || await (await this._prototype).purgeContents();
  }
  _isLoaded() {
    return this._prototype.isResolved() && this._prototype.getResolved().isLoaded();
  }
}
class cl {
  constructor(t, e) {
    t instanceof pg && (t = Ro.create(t)), this._shared = t, this._inclusionContext = e;
  }
  getInclusionContext() {
    return this._inclusionContext;
  }
  addReferrer(t) {
    this._shared.get()._addReferrer(t);
  }
  getReferrers() {
    return this._shared.get()._getReferrers();
  }
  getProductOccurrence() {
    return this._shared.get()._getPrototype();
  }
  removeReferrer(t) {
    if (this._shared.get()._removeReferrer(t)) {
      const e = t.removePrototype();
      return console.assert(this === e), !0;
    }
    return !1;
  }
  removeAllReferrers() {
    const t = this.getReferrers();
    for (const e of t)
      this.removeReferrer(e) || console.assert(!1);
  }
  purgeContents() {
    return this._shared.get()._purgeContents();
  }
  isLoaded() {
    return this._shared.get()._isLoaded();
  }
}
function sh(s) {
  return "modelName" in s;
}
function N0(s) {
  return !sh(s);
}
function v_(s) {
  return s.config.implicitlyLoadXmlExternalModels || N0(s);
}
class mg {
  static create(t) {
    return new mg(t);
  }
  constructor(t) {
    this.value = t;
  }
}
function _g(s) {
  if (s.length === 0)
    return;
  const t = s[0].getBranchVisibility();
  for (let e = 1, i = s.length; e < i; ++e)
    if (t !== s[e].getBranchVisibility())
      return de.Mixed;
  return t;
}
function D0(s) {
  const t = s.getBodyInstances();
  if (t.length === 0)
    return;
  const e = t[0].isVisible();
  for (let i = 1, n = t.length; i < n; ++i)
    if (e !== t[i].isVisible())
      return de.Mixed;
  return e ? de.Shown : de.Hidden;
}
function O0(s) {
  return _g(s.getChildrenSync());
}
function R0(s) {
  return _g(s.getPmis());
}
function L0(s) {
  return _g(s.getCadViews());
}
function F0(s) {
  const t = s.isVisible() ? de.Shown : de.Hidden, e = O0(s);
  if (e !== void 0 && e !== t)
    return de.Mixed;
  const i = D0(s);
  if (i !== void 0 && i !== t)
    return de.Mixed;
  const n = R0(s);
  if (n !== void 0 && n !== t)
    return de.Mixed;
  const r = L0(s);
  return r !== void 0 && r !== t ? de.Mixed : e === void 0 && i === void 0 && n === void 0 && r === void 0 ? null : t;
}
const B0 = -2;
function tl(s, t) {
  const e = [];
  for (const i of s) {
    const n = t(i);
    n && e.push(n);
  }
  return Ge(e);
}
var Tf = /* @__PURE__ */ ((s) => (s[s.NodeTypeDrawingSheet = 6] = "NodeTypeDrawingSheet", s))(Tf || {}), ci = ((s) => (s[s.IsAConfigurationNode = fi.IsAConfigurationNode] = "IsAConfigurationNode", s[s.NodeTypeProduct = fi.NodeTypeProduct] = "NodeTypeProduct", s[s.NodeTypeGroup = fi.NodeTypeGroup] = "NodeTypeGroup", s[s.NodeTypeDrawingSheet = fi.NodeTypeDrawingSheet] = "NodeTypeDrawingSheet", s[s.NodeTypeDrawingView = fi.NodeTypeDrawingView] = "NodeTypeDrawingView", s[s.IsADefaultNodeType = fi.IsADefaultNodeType] = "IsADefaultNodeType", s[s.BranchVisibilityHidden = fi.BranchVisibilityHidden] = "BranchVisibilityHidden", s[s.BranchVisibilityShown = fi.BranchVisibilityShown] = "BranchVisibilityShown", s[s.BranchVisibilityDirty = fi.BranchVisibilityDirty] = "BranchVisibilityDirty", s[s.IsMissing = fi.IsMissing] = "IsMissing", s[s.OutOfHierarchy = fi.OutOfHierarchy] = "OutOfHierarchy", s[s.IsExternalModelRoot = fi.IsExternalModelRoot] = "IsExternalModelRoot", s))(ci || {});
class _e extends ts {
  static parseXml(t, e, i, n, r) {
    const o = i.getInclusionKey(), l = Uo.parseXml(e, n, t), h = gi.parseFloat(n, "Unit"), u = [], d = [], g = [], y = [], m = [], x = [];
    let b = null, I = null, C = null, P = n.firstElementChild;
    for (; P !== null; ) {
      if (P.localName === "PartDefinition") {
        b = ns.parseXml(e, P, t);
        break;
      } else if (P.localName === "BodyInstance") {
        const k = Ui.parseXml(
          e,
          P,
          o,
          t
        );
        u.push(k);
      } else if (P.localName === "Material")
        console.assert(I === null), I = ug.parseXml(P);
      else if (P.localName === "ExternalModel") {
        console.assert(C === null);
        const k = P.getAttribute("Name");
        if (k !== null) {
          const O = gi.parseFloat(P, "Unit"), B = gi.parseBounding(P, "BoundingBox"), j = 0, V = gi.parseUint(P, "CancelUnitScale") === 1;
          C = {
            config: t,
            modelName: k,
            bounding: B,
            measurementUnit: O,
            toAttachData: r,
            reservedNodeIdOffset: j,
            cancelUnitScale: V
          };
        }
      } else if (P.localName === "CADView" && !t.ignoreCadViews) {
        const k = ss.parseXml(e, P, i, t);
        x.push(k);
      } else if (P.localName === "Filter" && !t.ignoreFilters)
        d.push(eh.parseXml(P));
      else if (P.localName === "Layer" && !t.ignoreLayers) {
        const k = lo.parseXml(P);
        k !== null && g.push(k);
      } else if (P.localName === "Relationships" && !t.ignoreBimRelationships) {
        const k = ka.parseXml(P);
        if (k !== null && y.push(k), k.related !== null)
          for (const O of k.related.relationships)
            ma.findBimObjectInArray(m, O) === !1 && m.push(O);
        k.relating !== null && ma.findBimObjectInArray(
          m,
          k.relating.relationElt
        ) === !1 && m.push(k.relating.relationElt);
      }
      P = P.nextElementSibling;
    }
    return {
      nodeInfo: l,
      productBits: 0,
      childDataKeys: [],
      prototypeDataKey: null,
      partDefinition: b,
      quickAccessPartDefinitionDataId: null,
      externalModelInfo: C,
      bodyInstanceInfos: u,
      cadViewInfos: x,
      pmiInfos: [],
      measurementUnit: h,
      simpleMaterial: I,
      layerInfos: g,
      filters: d,
      relationships: y,
      bimInfos: m
    };
  }
  static parseBinary(t, e, i, n) {
    const r = Fi(i), o = r.getRemapper(), l = n.parseNodeParseBits();
    if (l.hasBits1(ei.VersionNumber) && n.parseAssemblyDataVersion(2), l.hasBits2(_r.GenericTypes)) {
      const V = n.parseGenericTypes();
      t.ignoreGenericTypes || r.setGenericTypeMaps(V);
    }
    const h = Uo.parseBinary(e, n, l, t);
    let u = 0;
    l.hasBits1(ei.ProductBits) && (u = n.parseProductBits());
    const d = [];
    if (l.hasBits1(ei.SubNodes)) {
      const V = n.parseCount_32();
      for (let Y = 0; Y < V; ++Y) {
        const q = n.parseDataKey();
        d.push(q);
      }
    }
    let g = null, y = null;
    if (l.hasBits1(ei.Instance) && (g = n.parseDataKey(), l.hasBits1(ei.InstanceQuickAccess))) {
      const V = n.parseModelKey(o);
      console.assert(V !== xs.Local);
      const Y = n.parseDataKey();
      y = [V, Y];
    }
    const m = [];
    if (l.hasBits1(ei.BodyInstances)) {
      const V = n.parseCount_32();
      for (let Y = 0; Y < V; ++Y) {
        const q = Ui.parseBinary(
          e,
          i,
          n,
          t
        );
        m.push(q);
      }
    }
    let x = null;
    if (l.hasBits1(ei.ExternalModel)) {
      const V = n.parseModelKey(o);
      console.assert(V !== xs.Local);
      const Y = n.parseInclusionKey(o, V);
      x = {
        config: t,
        inclusionKey: Y,
        modelKey: V
      };
    }
    let b = null;
    if (l.hasBits1(ei.PartDataLink)) {
      let V = n.parseModelKey(o);
      V === xs.Local && (V = r.getMasterModelKey());
      const Y = n.parseDataKey();
      b = [V, Y];
    }
    const I = [];
    if (l.hasBits1(ei.Views)) {
      const V = n.parseCount_32();
      for (let Y = 0; Y < V; ++Y) {
        const q = ss.parseBinary(e, i, n, t);
        t.ignoreCadViews || I.push(q);
      }
    }
    const C = [];
    if (l.hasBits1(ei.Pmis)) {
      const V = n.parseCount_32();
      for (let Y = 0; Y < V; ++Y) {
        const q = Sn.parseBinary(e, i, n, t);
        C.push(q);
      }
    }
    let P = null;
    if (l.hasBits1(ei.Unit) && (P = n.parseFloat_64()), l.hasBits1(ei.FrontUpVector)) {
      const V = n.parsePoint3_64(), Y = n.parsePoint3_64();
      e.setViewAxes(V, Y);
    }
    const k = [];
    if (l.hasBits1(ei.LayerList)) {
      const V = n.parseCount_32();
      for (let Y = 0; Y < V; ++Y) {
        const q = lo.parseBinary(n);
        t.ignoreLayers || k.push(q);
      }
    }
    const O = [];
    if (l.hasBits1(ei.Filters)) {
      const V = n.parseCount_32();
      for (let Y = 0; Y < V; ++Y) {
        const q = eh.parseBinary(n);
        t.ignoreFilters || O.push(q);
      }
    }
    const B = [], j = [];
    if (l.hasBits2(_r.Relationships)) {
      const V = n.parseCount_32();
      for (let Y = 0; Y < V; ++Y) {
        const q = ka.parseBinary(i, n);
        if (t.ignoreBimRelationships || B.push(q), q.relating !== null && !t.ignoreBimRelationships && (ma.findBimObjectInArray(j, q.relating.relationElt) === !1 && j.push(q.relating.relationElt), q.related !== null))
          for (const st of q.related.relationships)
            ma.findBimObjectInArray(j, st) === !1 && j.push(st);
      }
    }
    return {
      nodeInfo: h,
      productBits: u,
      childDataKeys: d,
      prototypeDataKey: g,
      partDefinition: b,
      quickAccessPartDefinitionDataId: y,
      externalModelInfo: x,
      bodyInstanceInfos: m,
      cadViewInfos: I,
      pmiInfos: C,
      measurementUnit: P,
      simpleMaterial: null,
      layerInfos: k,
      filters: O,
      relationships: B,
      bimInfos: j
    };
  }
  /**
   * Like `reify` but with a synchronous return result.
   *
   * Usage requirements:
   *      - `info.childDataKeys` must be empty.
   *      - `info.externalModelInfo` must be `null`.
   */
  static reifySync(t, e, i, n, r, o) {
    console.assert(r.childDataKeys.length === 0), console.assert(r.externalModelInfo === null);
    const l = Fi(n), h = new _e(
      null,
      t,
      e,
      i,
      n,
      o,
      r
    );
    return l.attachedInvisibly() && h.setVisibility(!1), h;
  }
  static async reify(t, e, i, n, r, o) {
    const l = wi(), h = new _e(
      l,
      t,
      e,
      i,
      n,
      o,
      r
    );
    return await l, h;
  }
  static createDynamic(t, e, i, n, r, o, l = !1, h = null) {
    const u = Gi(e), d = t.massageAuthoredUserId(u, n), g = o ? zi.InitiallyShown : 0, y = {
      nodeId: d,
      bits: g,
      name: i,
      localTransform: r,
      attributes: [],
      header: Ys.dynamic,
      exchangeId: null,
      layerId: null,
      genericTypeId: null,
      genericId: null,
      userDatas: null
    }, m = l ? ci.OutOfHierarchy : 0, x = {
      nodeInfo: y,
      productBits: m,
      childDataKeys: [],
      prototypeDataKey: null,
      partDefinition: null,
      quickAccessPartDefinitionDataId: null,
      bodyInstanceInfos: [],
      externalModelInfo: null,
      cadViewInfos: [],
      pmiInfos: [],
      measurementUnit: h,
      simpleMaterial: null,
      layerInfos: [],
      filters: [],
      relationships: [],
      bimInfos: []
    }, b = new Ma();
    return b.attachInvisibly = !o, new _e(
      null,
      b,
      null,
      t,
      u,
      e,
      x
    );
  }
  static createMissing(t, e) {
    const i = this.createDynamic(t, e, "Missing", null, null, !1);
    return i._bits |= ci.IsMissing, i;
  }
  isMissing() {
    return this._hasBits(ci.IsMissing);
  }
  static _amendInfo(t, e) {
    if (e.nodeInfo.name !== null)
      return e;
    let i = null;
    if (ne(e.productBits, ci.NodeTypeProduct) ? i = t.generateProductName() : ne(e.productBits, ci.NodeTypeGroup) ? i = t.generateGroupName() : ne(e.productBits, ci.NodeTypeDrawingSheet) ? i = t.generateDrawingSheetName() : ne(e.productBits, ci.NodeTypeDrawingView) && (i = t.generateDrawingViewName()), i === null)
      return e;
    const n = { ...e.nodeInfo, name: i };
    return { ...e, nodeInfo: n };
  }
  constructor(t, e, i, n, r, o, l) {
    l = _e._amendInfo(n, l);
    const h = Fi(r), u = h.getMasterModelKey(), d = Js(h);
    super(n, u, l.nodeInfo), this._parent = o, this._bits |= l.productBits | ci.BranchVisibilityDirty;
    const g = l.nodeInfo.header, y = [];
    if (l.prototypeDataKey !== null && (console.assert(i !== null), this._prototypeContext = this._loadPrototypeContext(
      e,
      i,
      n,
      r,
      l.prototypeDataKey,
      g
    )), console.assert(l.quickAccessPartDefinitionDataId === null || l.partDefinition === null), l.partDefinition !== null ? Array.isArray(l.partDefinition) ? this._partDefinition = this._lazyLoadPartDefinitionById(
      n,
      r,
      l.partDefinition,
      g,
      e
    ) : this._partDefinition = this._lazyLoadPartDefinitionByInfo(
      n,
      r,
      l.partDefinition,
      u
    ) : l.quickAccessPartDefinitionDataId !== null && (this._partDefinition = this._lazyLoadPartDefinitionById(
      n,
      r,
      l.quickAccessPartDefinitionDataId,
      g,
      e
    )), l.childDataKeys.length > 0) {
      console.assert(i !== null);
      const x = (async () => {
        const b = await this._loadProductOccurrences(
          e,
          i,
          n,
          r,
          l.childDataKeys,
          g
        );
        this._children = vs(b);
      })();
      y.push(x);
    }
    if (l.bodyInstanceInfos.length > 0) {
      const x = this._loadBodyInstances(
        n,
        u,
        l.bodyInstanceInfos
      );
      this._bodyInstances = vs(x);
    }
    if (l.cadViewInfos.length > 0) {
      const x = this._loadCadViews(n, r, l.cadViewInfos);
      this._cadViews = vs(x);
    }
    if (l.pmiInfos.length > 0) {
      const x = this._loadPmis(n, r, l.pmiInfos);
      this._pmis = vs(x);
    }
    if (l.measurementUnit !== null && (this._measurementUnit = l.measurementUnit), l.externalModelInfo !== null)
      if (console.assert(t !== null), console.assert(i !== null), v_(l.externalModelInfo)) {
        const x = this._loadAndAttachExternalModel(
          i,
          r,
          l.externalModelInfo
        );
        y.push(x);
      } else
        this._pendingExternalModels = Yn(this._pendingExternalModels, l.externalModelInfo);
    for (const x of l.layerInfos) {
      const b = d.getRuntimeLayerId(x.id);
      b === null ? n.createLayer(x.id, x.name, d) : x.name !== null && n.updateLayerName(b, x.name);
    }
    for (const x of l.filters)
      n.addFilter(x, d);
    for (const x of l.relationships)
      r.addRelationship(x);
    for (const x of l.bimInfos)
      r.addBimInfos(x);
    const m = this.getAuthoredLayerId();
    if (m !== null && (n.registerNodeInLayer(this, m), this.isOutOfHierarchy() || n.registerTreeNodeInLayer(this, m)), n.registerProductOccurrence(this), t === null) {
      if (y.length > 0)
        throw new oi();
    } else
      t.resolve(Ge(y));
  }
  async _loadExternalModel(t, e, i) {
    if (sh(i))
      return t.attachByExternalModelInfo(i, this, e);
    const n = this.getAuthoredId();
    return Js(e).handleExternalModel(n, e, i.inclusionKey) ? t.attachByExternalModelInfo(i, this, e) : null;
  }
  async _loadAndAttachExternalModel(t, e, i) {
    const n = await this._loadExternalModel(
      t,
      e,
      i
    );
    return n !== null && this.addAttachContext(n), n;
  }
  async loadPendingExternalModels(t) {
    if (!this.hasPendingExternalModels())
      return [];
    const e = Gi(this), i = [];
    for (const r of hi(this._pendingExternalModels)) {
      const o = this._loadAndAttachExternalModel(t, e, r);
      i.push(o);
    }
    delete this._pendingExternalModels;
    const n = [];
    for (const r of await Promise.all(i))
      r !== null && n.push(r);
    return n;
  }
  _lazyLoadPartDefinitionByInfo(t, e, i, n) {
    const r = n, o = ns.reify(t, e, r, i);
    return jn.create(o);
  }
  _lazyLoadPartDefinitionById(t, e, i, n, r) {
    const o = t.getAbstractScEngine(), l = Js(e);
    let h = t.lookupPartDefinitionByDataId(
      l,
      i[0],
      i[1]
    );
    return h !== null ? jn.create(async () => {
      const u = await h;
      return u.addReferrer(this), u;
    }) : (h = jn.create(async () => {
      const u = i[0], d = i[1], g = await t.enqueue(() => o.safeGetMetaData(u, d));
      if (g !== null) {
        const y = new va(n, g), m = new rh(y), x = ns.parseBinary(t, m, r), b = ns.reify(t, e, u, x);
        return b.addReferrer(this), b;
      }
      return ns.createMissing(t);
    }), t.registerPartDefinitionByDataId(
      l,
      i[0],
      i[1],
      h
    ), h);
  }
  static async _loadProductOccurrence(t, e, i, n, r, o) {
    const l = new rh(r), h = _e.parseBinary(t, i, n, l);
    return _e.reify(
      t,
      e,
      i,
      n,
      h,
      o
    );
  }
  _loadPrototypeContext(t, e, i, n, r, o) {
    const l = Fi(n), h = Js(l), d = l.getMasterModelKey(), g = {
      prototypeContext: null,
      sharedPrototypeContext: i.lookupPrototypeByDataId(
        h,
        d,
        r
      )
    };
    if (g.sharedPrototypeContext === null) {
      const y = jn.create(async () => {
        const m = i.getAbstractScEngine(), x = await i.enqueue(() => m.safeGetMetaData(d, r));
        if (x !== null) {
          const b = new va(o, x);
          return _e._loadProductOccurrence(
            t,
            e,
            i,
            n,
            b,
            g.prototypeContext
          );
        }
        return _e.createMissing(i, g.prototypeContext);
      });
      g.sharedPrototypeContext = new pg(y), i.registerPrototypeByDataId(
        h,
        d,
        r,
        g.sharedPrototypeContext
      );
    }
    return g.prototypeContext = new cl(g.sharedPrototypeContext, n), g.prototypeContext.addReferrer(this), g.prototypeContext;
  }
  async _loadProductOccurrences(t, e, i, n, r, o) {
    const u = Fi(n).getMasterModelKey(), d = i.getAbstractScEngine(), g = await i.enqueue(() => d.safeGetMetaDatas(u, r)), y = [];
    for (let m = 0; m < r.length; ++m) {
      let x;
      if (g !== null) {
        const b = g[m];
        g[m] = new Uint8Array(0);
        const I = new va(o, b);
        x = await _e._loadProductOccurrence(
          t,
          e,
          i,
          n,
          I,
          this
        );
        const C = e.onLoadChildProductOccurrence();
        C && await C;
      } else
        x = _e.createMissing(i, this);
      y.push(x);
    }
    return y;
  }
  _loadBodyInstances(t, e, i) {
    const n = [];
    for (const r of i) {
      const o = Ui.reify(t, e, this, r);
      n.push(o);
    }
    return n;
  }
  _loadCadViews(t, e, i) {
    const n = [];
    for (const r of i) {
      const o = ss.reify(t, e, r, this);
      n.push(o), o.markLoaded();
    }
    return n;
  }
  _loadPmis(t, e, i) {
    const n = [];
    for (const r of i) {
      const o = Sn.reify(t, e, r, this);
      n.push(o);
    }
    return n;
  }
  getParent() {
    return this._parent;
  }
  getRuntimeId() {
    return Ko(this._nodeId, this);
  }
  isAbsoluteRoot() {
    return this._nodeId === B0;
  }
  getPrototype() {
    return this._prototypeContext !== void 0 ? this._prototypeContext : null;
  }
  isAConfigurationNode() {
    return this._hasBits(ci.IsAConfigurationNode);
  }
  isADefaultNode() {
    return this._hasBits(ci.IsADefaultNodeType);
  }
  isAProductNode() {
    return ne(this._bits, ci.NodeTypeProduct);
  }
  isAGroupNode() {
    return ne(this._bits, ci.NodeTypeGroup);
  }
  isADrawingSheetNode() {
    return ne(this._bits, ci.NodeTypeDrawingSheet);
  }
  isADrawingViewNode() {
    return ne(this._bits, ci.NodeTypeDrawingView);
  }
  addProductOccurrence(t) {
    console.assert(t.getParent() === this), this._children = Yn(this._children, t), this._itemWasAdded();
  }
  addBodyInstance(t) {
    console.assert(t.getParent() === this), this._bodyInstances = Yn(this._bodyInstances, t), this._itemWasAdded();
  }
  addCadView(t) {
    console.assert(t.getParent() === this), this._cadViews = Yn(this._cadViews, t), this._itemWasAdded();
  }
  addPmi(t) {
    console.assert(t.getParent() === this), this._pmis = Yn(this._pmis, t), this._itemWasAdded();
  }
  addLoadContext(t) {
    console.assert(t.getParent() === this), this._childContexts = Yn(this._childContexts, t), this._itemWasAdded();
  }
  addAttachContext(t) {
    console.assert(t.getParent() === this), this._childContexts = Yn(this._childContexts, t), this._itemWasAdded();
  }
  _followPrototypesWhileEmpty() {
    if (this._prototypeContext === void 0 || this._children !== void 0 || this._childContexts !== void 0)
      return this;
    const t = this._prototypeContext.getProductOccurrence();
    return t.isResolved() ? t.getResolved()._followPrototypesWhileEmpty() : this;
  }
  // Boxed because [[Promise.resolve<Thenable<T>>(x) => Promise<T>]], not [[Promise<<Thenable<T>>>]].
  getRawPartDefinition() {
    if (this._partDefinition !== void 0)
      return this._partDefinition;
    if (this._prototypeContext !== void 0) {
      const t = this._prototypeContext.getProductOccurrence();
      return t.isResolved() ? t.getResolved().getRawPartDefinition() : null;
    }
    return null;
  }
  // Boxed because [[Promise.resolve<Thenable<T>>(x) => Promise<T>]], not [[Promise<<Thenable<T>>>]].
  async getPartDefinition() {
    const t = this.getRawPartDefinition();
    return t instanceof jn ? mg.create(t) : t instanceof Promise ? t : null;
  }
  getPartDefinitionSync() {
    if (console.assert(this.isLoaded()), this._partDefinition !== void 0 && this._partDefinition.isResolved())
      return this._partDefinition.getResolved();
    if (this._prototypeContext !== void 0) {
      const t = this._prototypeContext.getProductOccurrence();
      if (t.isResolved())
        return t.getResolved().getPartDefinitionSync();
    }
    return null;
  }
  getChildContexts() {
    return hi(this._childContexts);
  }
  _getChildren() {
    const t = hi(this._children), e = hi(this._childContexts);
    for (const i of e)
      t.push(...i.getChildren());
    return t;
  }
  async getChildren() {
    return (await this._followPrototypesWhileEmpty())._getChildren();
  }
  getChildrenSync() {
    console.assert(this.isLoaded());
    const t = this.tryGetChildrenSync();
    if (t === null)
      throw new oi();
    return t;
  }
  tryGetChildrenSync() {
    const t = this._followPrototypesWhileEmpty();
    return t instanceof Promise ? null : t._getChildren();
  }
  async forEachChild(t) {
    const e = await this.getChildren();
    return tl(e, t);
  }
  forEachBodyInstance(t) {
    const e = this.getBodyInstances();
    return tl(e, t);
  }
  forEachPmi(t) {
    const e = this.getPmis();
    return tl(e, t);
  }
  forEachCadView(t) {
    const e = this.getCadViews();
    return tl(e, t);
  }
  hasBodyInstances() {
    return this._bodyInstances !== void 0;
  }
  getBodyInstances() {
    return hi(this._bodyInstances);
  }
  getCadViews() {
    return hi(this._cadViews);
  }
  getPmis() {
    return hi(this._pmis);
  }
  setMeasurementUnit(t) {
    this._measurementUnit = t;
  }
  unsetMeasurementUnit() {
    this._measurementUnit = void 0;
  }
  hasMeasurementUnit() {
    return this._measurementUnit !== void 0;
  }
  getMeasurementUnit() {
    let t = this;
    do {
      if (t._measurementUnit !== void 0)
        return t._measurementUnit;
      t = pr(t._parent);
    } while (t !== null);
    return 1;
  }
  async getPhysicalProperties(t) {
    const e = async () => {
      if (Array.isArray(this._children)) {
        const y = [];
        for (const P of this._children)
          await nh(P), y.push(await P.getPhysicalProperties(t));
        if (!y.some((P) => P !== null))
          return null;
        let m = 0, x = 0;
        const b = _.zero();
        let I = 0;
        if (y.forEach((P) => {
          P !== null && (I += 1, m += P.volume, x += P.surfaceArea, b.add(P.centerOfGravity));
        }), I === 0)
          return null;
        const C = _.scale(b, 1 / I);
        return Promise.resolve(new wa(x, m, C));
      }
      return this._children instanceof _e ? (await nh(this._children), this._children.getPhysicalProperties(t)) : null;
    }, i = await this.getPartDefinition();
    if (i === null)
      return t ? e() : null;
    const r = (await i.value).getRepresentationItems();
    if (r.length === 0)
      return t ? e() : null;
    let o = 0, l = 0;
    const h = _.zero();
    let u = 0;
    for (const y of r) {
      const m = y.getPhysicalProperties();
      m !== null && (o += m.volume, l += m.surfaceArea, h.add(m.centerOfGravity), u++);
    }
    u !== 0 && h.scale(1 / u);
    const d = new wa(l, o, h), g = await e();
    return g !== null ? new wa(
      d.surfaceArea + g.surfaceArea,
      d.volume + g.volume,
      _.add(d.centerOfGravity, g.centerOfGravity).scale(0.5)
    ) : d;
  }
  setPartDefinition(t) {
    console.assert(this._partDefinition === void 0), this._partDefinition = jn.create(t);
  }
  setPrototype(t) {
    console.assert(this._prototypeContext === void 0), this._prototypeContext = t, this._markBranchVisibilityDirty(!1);
  }
  removePrototype() {
    if (this._prototypeContext === void 0)
      throw new oi();
    const t = this._prototypeContext;
    return delete this._prototypeContext, this._markBranchVisibilityDirty(!1), t;
  }
  getBranchVisibility() {
    return this._updateBranchVisibility(), this._getBranchVisibility();
  }
  _getBranchVisibility() {
    let t = this.isVisible() ? de.Shown : de.Hidden;
    return this._hasBits(ci.BranchVisibilityShown) && t !== de.Shown && (t = de.Mixed), this._hasBits(ci.BranchVisibilityHidden) && t !== de.Hidden && (t = de.Mixed), t;
  }
  _setBranchVisibility(t) {
    const e = this.isVisible();
    console.assert(e ? t !== de.Hidden : t === de.Hidden), this._bits &= ~(ci.BranchVisibilityHidden | ci.BranchVisibilityShown), (t === de.Hidden || t === de.Mixed) && (this._bits |= ci.BranchVisibilityHidden), (ne(t, de.Shown) || t === de.Mixed) && (this._bits |= ci.BranchVisibilityShown);
  }
  _updateBranchVisibility() {
    if (!this._hasBits(ci.BranchVisibilityDirty))
      return;
    let t = this.isVisible() ? de.Shown : de.Hidden;
    const e = this._getSubBranchVisibilities();
    e !== null && e !== t && (t = de.Mixed), this._setBranchVisibility(t), this._bits &= ~ci.BranchVisibilityDirty;
  }
  _getSubBranchVisibilities() {
    return F0(this);
  }
  _itemWasAdded() {
    this._getBranchVisibility() !== de.Mixed && this._markBranchVisibilityDirty(!0);
  }
  _onItemRemoved() {
    this._getBranchVisibility() !== de.Hidden && this._markBranchVisibilityDirty(!1);
  }
  markBranchVisibilityDirty() {
    this._markBranchVisibilityDirty(!1);
  }
  _markBranchVisibilityDirty(t) {
    if (!this._hasBits(ci.BranchVisibilityDirty) && !(t && this._getBranchVisibility() === de.Mixed))
      if (this._bits |= ci.BranchVisibilityDirty, this._parent instanceof cl) {
        const e = this._parent.getReferrers();
        for (const i of e)
          i._markBranchVisibilityDirty(t);
      } else {
        const e = pr(this._parent);
        if (e !== null)
          return e._markBranchVisibilityDirty(t);
      }
  }
  setVisibility(t) {
    this.isVisible() !== t && (this._setVisibility(t), this._markBranchVisibilityDirty(!1));
  }
  _removeDirectChild(t) {
    let e = hi(this._children);
    const i = e.length;
    return e = e.filter((n) => n !== t), e.length === i ? !1 : (e.length === 0 ? delete this._children : this._children = vs(e), this._onItemRemoved(), !0);
  }
  _removeIndirectChild(t) {
    let e = !1, i = hi(this._childContexts);
    for (const n of i)
      if (n.removeProductOccurrence(t)) {
        e = !0;
        break;
      }
    return e ? (i = i.filter((n) => n.hasChildren()), i.length === 0 ? delete this._childContexts : this._childContexts = vs(i), this._onItemRemoved(), !0) : !1;
  }
  removeProductOccurrence(t) {
    return this._removeDirectChild(t) ? !0 : this._removeIndirectChild(t);
  }
  removePmi(t) {
    let e = hi(this._pmis);
    const i = e.length;
    return e = e.filter((n) => n !== t), e.length === i ? !1 : (e.length === 0 ? delete this._pmis : this._pmis = vs(e), this._onItemRemoved(), !0);
  }
  removeBodyInstance(t) {
    let e = hi(this._bodyInstances);
    const i = e.length;
    return e = e.filter((n) => n !== t), e.length === i ? !1 : (e.length === 0 ? delete this._bodyInstances : this._bodyInstances = vs(e), this._onItemRemoved(), !0);
  }
  purgeContents() {
    this._markBranchVisibilityDirty(!1);
    const t = [];
    let e;
    this._partDefinition !== void 0 && (this._partDefinition.isUnforced() || (e = this._partDefinition.then((r) => {
      r.removeAllReferrers(), delete this._partDefinition;
    }), t.push(e))), this._prototypeContext !== void 0 && (e = this._prototypeContext.purgeContents(), t.push(e), this._prototypeContext.removeReferrer(this), delete this._prototypeContext);
    const i = hi(this._children);
    e = tl(i, (r) => r.purgeContents()), t.push(e), delete this._children;
    const n = hi(this._childContexts);
    return e = tl(n, (r) => r.purgeContents()), t.push(e), delete this._childContexts, delete this._bodyInstances, delete this._cadViews, delete this._pmis, delete this._measurementUnit, Ge(t);
  }
  removePartDefinition() {
    if (this._partDefinition === void 0 || !this._partDefinition.isResolved())
      throw new oi();
    const t = this._partDefinition;
    return delete this._partDefinition, t.getResolved();
  }
  isOutOfHierarchy() {
    return this._hasBits(ci.OutOfHierarchy);
  }
  markIsExternalModelRoot(t) {
    console.assert(!this._hasBits(ci.IsExternalModelRoot)), this._bits |= ci.IsExternalModelRoot, t.markSeenExternalModel();
  }
  isExternalModelRoot() {
    return this._hasBits(ci.IsExternalModelRoot);
  }
  addPendingExternalModel(t) {
    this._pendingExternalModels = Yn(this._pendingExternalModels, t);
  }
  hasPendingExternalModels() {
    return !Jv(this._pendingExternalModels);
  }
}
class b_ {
  constructor() {
    this._leftToRight = /* @__PURE__ */ new Map(), this._rightToLeft = /* @__PURE__ */ new Map();
  }
  set(t, e) {
    this._leftToRight.set(t, e), this._rightToLeft.set(e, t);
  }
  getLeft(t) {
    return this._rightToLeft.get(t);
  }
  getRight(t) {
    return this._leftToRight.get(t);
  }
}
class x_ {
  constructor() {
    this._bits1 = 0, this._bits2 = 0;
  }
  hasBits1(t) {
    return ne(this._bits1, t);
  }
  hasBits2(t) {
    return ne(this._bits2, t);
  }
  parseBits1(t) {
    this._bits1 = t.parseIndex_32();
  }
  parseBits2(t) {
    this.hasBits1(ei.UseNodeParseBits2) && (this._bits2 = t.parseIndex_32());
  }
}
class V0 {
  constructor(t, e) {
    this.shown = t, this.removed = e;
  }
}
class rh {
  constructor(t) {
    this._bytes = t.bytes, this._header = t.header, this._dataView = new DataView(
      this._bytes.buffer,
      this._bytes.byteOffset,
      this._bytes.byteLength
    ), this._currentPos = 0;
  }
  hasNext() {
    return this._currentPos < this._bytes.length;
  }
  parseCount_32() {
    return this._parseUint_32();
  }
  parseIndex_32() {
    return this._parseUint_32();
  }
  parseAssemblyDataVersion(t) {
    const e = [];
    for (let i = 0; i < t; ++i)
      e.push(this._parseUint_32());
    return e;
  }
  parseAssemblyDataHeaderVersion() {
    return this._parseUint_32();
  }
  parseVisibility() {
    let t;
    ((r) => {
      r[r.Removed = 1] = "Removed", r[r.Shown = 2] = "Shown";
    })(t || (t = {}));
    const e = this._parseInt_8(), i = ne(
      e,
      2
      /* Shown */
    ), n = ne(
      e,
      1
      /* Removed */
    );
    return new V0(i, n);
  }
  parseProductBits() {
    let t = this._parseUint_8();
    return this._header !== null && this._header.headerVersion >= 2 || !ne(t, Tf.NodeTypeDrawingSheet) || (t &= ~Tf.NodeTypeDrawingSheet, t |= ci.NodeTypeDrawingSheet), t;
  }
  parseUnits() {
    const t = this.parseInt32(), e = [];
    for (let i = 0; i < t; i++) {
      const n = this.parseUInt32(), r = this.parseInt32(), o = this.parseFloat_64();
      e.push({
        basicUnit: n,
        exponent: r,
        factor: o
      });
    }
    return e;
  }
  parseCString() {
    const t = this._currentPos;
    let e = this._bytes[this._currentPos++];
    for (; e !== 0; )
      e = this._bytes[this._currentPos++];
    return Gv(this._bytes.subarray(t, this._currentPos - 1));
  }
  parseUInt32() {
    return this._parseUint_32();
  }
  parseInt32() {
    return this._parseInt_32();
  }
  parseBytes(t) {
    const e = this._currentPos;
    this._currentPos += t;
    const i = this._bytes.subarray(e, this._currentPos);
    return new Uint8Array(i);
  }
  parseNodeId() {
    const t = this._parseUint_32();
    return console.assert(t !== Ts), t;
  }
  parseLayerId() {
    const t = this._parseUint_32();
    return console.assert(t !== Ts), t;
  }
  parseGenericTypes() {
    const t = this._parseUint_32(), e = new b_();
    for (let i = 0; i < t; i++) {
      const n = this.parseCString(), r = this._parseUint_32();
      e.set(r, n);
    }
    return e;
  }
  parseGenericTypeId() {
    return this._parseUint_32();
  }
  parseGenericId() {
    return this.parseCString();
  }
  parseModifiers() {
    return this._parseUint_32();
  }
  _parseScKey() {
    const t = this._parseUint_32();
    return console.assert(t !== og.Invalid), t;
  }
  parseDataKey() {
    return this._parseScKey();
  }
  parseInstanceKey() {
    return this._parseScKey();
  }
  parseMeshKey() {
    return this._parseScKey();
  }
  parseModelKey(t) {
    const e = this._parseScKey();
    return t !== null ? t.getEffectiveModelKey(e) : e;
  }
  parseInclusionKey(t, e) {
    const i = this._parseScKey();
    return t !== null ? t.getEffectiveInclusionKey(i, e) : i;
  }
  parseMatrix() {
    const t = this._header !== null && this._header.doublePrecisionMatrices ? () => this.parseFloat_64() : () => this.parseFloat_32(), e = Wn.getIdentity();
    for (let i = 0; i < 4; ++i)
      for (let n = 0; n < 3; ++n)
        e[4 * i + n] = t();
    return e;
  }
  _parseInt_8() {
    return this._dataView.getInt8(this._currentPos++);
  }
  _parseUint_8() {
    return this._dataView.getUint8(this._currentPos++);
  }
  _parseUint_32() {
    const t = this._dataView.getUint32(this._currentPos, !0);
    return this._currentPos += 4, t;
  }
  _parseInt_32() {
    const t = this._dataView.getInt32(this._currentPos, !0);
    return this._currentPos += 4, t;
  }
  _parseFloat_32() {
    const t = this._dataView.getFloat32(this._currentPos, !0);
    return this._currentPos += 4, t;
  }
  _parseFloat_64() {
    const t = this._dataView.getFloat64(this._currentPos, !0);
    return this._currentPos += 8, t;
  }
  parseFloat_32() {
    return this._parseFloat_32();
  }
  parseFloat_64() {
    return this._parseFloat_64();
  }
  parseAttributeType() {
    return this._parseInt_8();
  }
  parseNodeParseBits() {
    const t = new x_();
    return t.parseBits1(this), t.parseBits2(this), t;
  }
  parseViewParseBits() {
    return this._parseUint_32();
  }
  parsePmiParseBits() {
    return this._parseUint_32();
  }
  parseLayerParseBits() {
    return this._parseUint_32();
  }
  parseAttributeParseBits() {
    return this._parseUint_32();
  }
  parseRelationshipParseBits() {
    return this._parseUint_32();
  }
  parseBoolean() {
    return this._parseUint_8() !== 0;
  }
  parsePoint3_32() {
    return new _(this._parseFloat_32(), this._parseFloat_32(), this._parseFloat_32());
  }
  parsePoint3_64() {
    return new _(this._parseFloat_64(), this._parseFloat_64(), this._parseFloat_64());
  }
  parsePlane3_32() {
    return ln.createFromCoefficients(
      this._parseFloat_32(),
      this._parseFloat_32(),
      this._parseFloat_32(),
      this._parseFloat_32()
    );
  }
  parsePmiType() {
    return this._parseUint_32();
  }
  parsePmiSubType() {
    return this._parseUint_32();
  }
  parsePmiTopoRef() {
    return this._parseInt_8();
  }
  parseBodyType() {
    return this._parseUint_8();
  }
  parseFaceType() {
    return this._parseInt_8();
  }
  parseEdgeType() {
    return this._parseInt_8();
  }
  parseUserDataIndex() {
    const t = this._parseUint_32(), e = this._parseUint_32();
    return e <= 2097151 ? 4294967296 * e + t : `${e.toString(16)}${Kv(t)}`.toUpperCase();
  }
  getHeader() {
    return this._header;
  }
}
function z0(s, t) {
  const e = (n) => {
    t.push(n);
  }, i = {
    enterProductOccurrence: e,
    enterAnyBody: e,
    enterCadView: e,
    enterPmi: e,
    enterPartDefinition: e,
    enterRepresentationItem: e
  };
  return Ln.walk(i, s, Vt.None);
}
async function _a(s) {
  const t = [], e = [];
  for (const i of s) {
    const n = z0(i, e);
    t.push(n);
  }
  await Ge(t);
  for (const i of e)
    i.markLoaded();
}
class H0 {
  constructor(t, e) {
    this.value = t, this.kids = e.slice();
  }
}
const yg = [25, 1, 0];
class ca {
  constructor(t) {
    this.referencedInfo = t;
  }
}
function cf(s) {
  return s instanceof ca ? s.referencedInfo : s;
}
function U0(s, t) {
  let e = s.nodeInfo.localTransform;
  return e === null ? e = t : e = Wn.multiply(e, t), {
    ...s,
    nodeInfo: {
      ...s.nodeInfo,
      localTransform: e
    }
  };
}
class hf {
  /**
   * This is used to parse `ModelFileInfo` without adding it to the tree.
   */
  static parseXml(t, e, i, n, r) {
    console.assert(n.localName === "ModelFile");
    const o = /* @__PURE__ */ new Map(), l = /* @__PURE__ */ new Map(), h = /* @__PURE__ */ new Map(), u = (m) => {
      let x = _e.parseXml(
        t,
        e,
        i,
        m,
        r
      );
      const b = x.nodeInfo.nodeId;
      if (h.has(x.nodeInfo.nodeId)) {
        const k = new ca(x);
        o.set(b, k);
      } else
        l.has(x.nodeInfo.nodeId) || (l.set(x.nodeInfo.nodeId, null), t.additionalMatrix !== null && (x = U0(x, t.additionalMatrix.m))), o.set(b, x);
      const C = gi.parseNodeIds(m, "Children") ?? [];
      for (const k of C)
        l.set(k, x);
      const P = gi.parseNodeId(m, "InstanceRef");
      if (P !== null) {
        const k = h.get(P);
        k === void 0 ? h.set(P, [x]) : k.push(x);
      }
    };
    let d = n.firstElementChild;
    for (; d !== null; ) {
      if (d.localName !== "ProductOccurence")
        throw new si(`Unexpected element "${d.localName}".`);
      if (gi.parseNodeId(d, "Id") === null)
        throw new si('Expected "Id" attribute.');
      u(d), d = d.nextElementSibling;
    }
    const g = this._parentMapToChildMap(o, l, h);
    return {
      treeInfos: this._childMapRoseTrees(g)
    };
  }
  static _parentMapToChildMap(t, e, i) {
    const n = /* @__PURE__ */ new Map(), r = (o, l) => {
      const h = n.get(o);
      h === void 0 ? n.set(o, [l]) : h.push(l);
    };
    return e.forEach((o, l) => {
      const h = t.get(l);
      if (h instanceof ca)
        throw new si('Expected a referenced node for "InstanceRef".');
      r(o, h);
    }), i.forEach((o, l) => {
      console.assert(o.length > 0);
      const h = t.get(l);
      if (!(h instanceof ca))
        throw new si(
          `Node is both an "InstanceRef" and contained in another node's "Children" list.`
        );
      for (const u of o)
        r(u, h);
    }), n;
  }
  static _childMapRoseTrees(t) {
    const e = (r) => {
      const o = [], l = cf(r), h = t.get(l);
      if (h !== void 0) {
        console.assert(h.length > 0);
        for (const u of h) {
          const d = e(u);
          o.push(d);
        }
      }
      return new H0(r, o);
    }, i = t.get(null);
    if (i === void 0)
      return console.assert(t.size === 0), [];
    const n = [];
    for (const r of i) {
      if (r instanceof ca) {
        console.assert(!1);
        continue;
      }
      const o = e(r);
      n.push(o);
    }
    return n;
  }
  /**
   * Inserts `ModelFileInfo` into the assembly tree.
   */
  static async reify(t, e, i, n, r, o) {
    const l = [], h = [], u = [];
    for (const g of o.treeInfos) {
      if (g.value instanceof ca) {
        console.assert(!1);
        continue;
      }
      const y = this._reifyProductOccurrence(
        t,
        e,
        i,
        n,
        r,
        r,
        g,
        l
      );
      h.push(y), u.push(y.getRuntimeId());
    }
    const d = e.promiseTrigger(
      "_subtreeLoaded",
      "subtreeLoaded",
      u,
      ho.LoadModel
    );
    return l.push(d), await Ge(l), h;
  }
  static _rectifyExternalModelInfo(t, e) {
    let i = {
      ...e.referencedInfo.externalModelInfo,
      reservedNodeIdOffset: 0
    };
    if (i === null)
      throw new si('"InstanceRef" node does not contain "ExternalModel".');
    if (!sh(i))
      throw new oi();
    console.assert(i.reservedNodeIdOffset === 0);
    const n = t.newNodeIdOffset();
    return i = {
      ...i,
      reservedNodeIdOffset: n
    }, i;
  }
  static _reifyProductOccurrence(t, e, i, n, r, o, l, h) {
    const u = cf(l.value);
    if (u.childDataKeys.length !== 0)
      throw new oi();
    if (u.externalModelInfo !== null)
      throw new qr('Unexpected "ExternalModel". Should be a child of an "InstanceRef".');
    const d = _e.reifySync(
      t,
      i,
      n,
      r,
      u,
      o
    );
    o.addProductOccurrence(d), d.markLoaded();
    for (const g of l.kids)
      if (g.value instanceof ca) {
        console.assert(g.kids.length === 0);
        const y = this._rectifyExternalModelInfo(n, g.value);
        if (v_(y)) {
          const m = i.attachByExternalModelInfo(y, d, r).then(async (x) => {
            if (x === null)
              return;
            await _a([x]), d.addAttachContext(x);
            const b = x.getChildren().map((I) => I.getRuntimeId());
            await e.promiseTrigger(
              "_subtreeLoaded",
              "subtreeLoaded",
              b,
              ho.LoadModel
            );
          });
          h.push(m);
        } else
          d.addPendingExternalModel(y);
      } else
        console.assert(g.value.externalModelInfo === null), this._reifyProductOccurrence(
          t,
          e,
          i,
          n,
          r,
          d,
          g,
          h
        );
    return d;
  }
  static _parseBounding(t, e) {
    const i = cf(t.value);
    let n = Ns;
    i.measurementUnit !== null && (n = i.measurementUnit);
    let r = 1;
    n === Ns ? n = e : e !== Ns && (r = n / e);
    let o = new mt().setScaleComponent(r, r, r);
    const l = i.nodeInfo.localTransform;
    if (l !== null) {
      const d = mt.createFromArray(l);
      o = mt.multiply(d, o);
    }
    const h = yn.invalid();
    for (const d of t.kids) {
      let g = this._parseBounding(d, n);
      g = o.transformBox(g), h.addBox(g);
    }
    const u = i.externalModelInfo;
    if (u !== null) {
      if (!sh(u))
        throw new oi();
      let d = u.bounding;
      if (d !== null && !d.isDegenerate()) {
        const g = u.measurementUnit || Ns;
        if (e !== Ns && g !== Ns) {
          const y = g / n, m = new mt().setScaleComponent(
            y,
            y,
            y
          );
          o = mt.multiply(m, o);
        }
        d = o.transformBox(d), h.addBox(d);
      }
    }
    return h;
  }
  static parseBounding(t, e) {
    const i = yn.invalid();
    for (const n of t.treeInfos)
      for (const r of n.kids) {
        const o = this._parseBounding(r, e);
        i.addBox(o);
      }
    return i;
  }
  constructor() {
  }
}
const Ao = class Ao {
  constructor(t, e, i, n, r, o, l, h) {
    this.headerVersion = t, this._rootAssemblyDataKey = e, this.isDrawing = i, this.isMeasurable = n, this.originalFileName = r, this.originalFileType = o, this.doublePrecisionMatrices = l, this.assemblyDataVersion = h;
  }
  supportsAttributeBits() {
    return this.headerVersion >= 5;
  }
  rootAssemblyDataKey() {
    return console.assert(this._rootAssemblyDataKey !== zu.Invalid), this._rootAssemblyDataKey;
  }
  // double precision matrices
  static parseBinary(t) {
    if (t.length === 0)
      return null;
    const e = new rh(new va(null, t)), i = new x_();
    if (i.parseBits1(e), !i.hasBits1(ei.Header))
      return null;
    const n = e.parseAssemblyDataHeaderVersion();
    if (n > Ao._maxHeaderVersion)
      throw new Ea(`Unknown header version: ${n}`);
    let r = [];
    if (n >= 4 && (r = e.parseAssemblyDataVersion(3), !Zc(yg, r)))
      throw new Ea(`Invalid version: ${Km(r)}`);
    i.parseBits2(e);
    const o = e.parseDataKey(), l = e.parseBoolean();
    let h, u = "", d = pl.Unknown, g = !1;
    return n >= 1 ? h = e.parseBoolean() : h = !0, n >= 3 && (g = i.hasBits2(_r.DoublePrecisionMatrices), i.hasBits2(_r.OriginalName) && (u = e.parseCString()), d = e.parseIndex_32()), new Ao(
      n,
      o,
      l,
      h,
      u,
      d,
      g,
      r
    );
  }
};
Ao._maxHeaderVersion = 5, Ao.dynamic = new Ao(
  Ao._maxHeaderVersion,
  zu.Invalid,
  !1,
  // isDrawing
  !1,
  // isMeasurable
  "",
  // originalFileName
  pl.Unknown,
  !0,
  []
);
let Ys = Ao;
class va {
  constructor(t, e) {
    this.header = t, this.bytes = e;
  }
}
class Gn {
  constructor(t, e, i, n) {
    this._productOccurrences = null, this._relationship = [], this._bimNodeIdMap = /* @__PURE__ */ new Map(), this._bimInfos = [], console.assert(i !== void 0), console.assert(i === Ei.Local == (n === xs.Local)), this._attachContext = e, this._inclusionKey = i, this._modelKey = n;
    let r = e.getReservedNodeIdOffset();
    r !== null ? e.forgetReservedNodeIdOffset() : r = t.newNodeIdOffset(), this._nodeIdOffset = r, t.registerInclusionContext(this);
  }
  split(t, e) {
    return new Gn(t, e, this._inclusionKey, this._modelKey);
  }
  getIdOffset() {
    return this._nodeIdOffset;
  }
  toRuntimeId(t) {
    return console.assert(Dl(t)), t + this._nodeIdOffset;
  }
  getInclusionKey() {
    return this._inclusionKey;
  }
  getModelKey() {
    return this._modelKey;
  }
  getParent() {
    return this._attachContext;
  }
  /** Naming clarity for when you know you want it as the attach-context */
  getAttachContext() {
    return this._attachContext;
  }
  addProductOccurrence(t) {
    console.assert(t.getParent() === this), this._productOccurrences = Yn(this._productOccurrences, t);
  }
  getChildren() {
    return hi(this._productOccurrences);
  }
  removeProductOccurrence(t) {
    let e = hi(this._productOccurrences);
    const i = e.length;
    return e = e.filter((n) => n !== t), e.length === 0 ? this._productOccurrences = null : this._productOccurrences = vs(e), e.length < i;
  }
  purgeContents() {
    const t = [], e = hi(this._productOccurrences);
    for (const i of e) {
      const n = i.purgeContents();
      t.push(n);
    }
    return this._productOccurrences = null, this._relationship.length = 0, Ge(t);
  }
  hasChildren() {
    return this._productOccurrences !== null;
  }
  isLoaded() {
    if (this._productOccurrences instanceof _e)
      return this._productOccurrences.isLoaded();
    if (this._productOccurrences === null)
      return !0;
    for (const t of this._productOccurrences)
      if (!t.isLoaded())
        return !1;
    return !0;
  }
  addRelationship(t) {
    this._relationship.push(t);
  }
  getRelationships() {
    return this._relationship;
  }
  addBimInfos(t) {
    this._bimInfos.push(t);
  }
  getBimInfos() {
    return this._bimInfos;
  }
  addBimIdToMap(t, e) {
    this._bimNodeIdMap.set(t, e);
  }
  getRuntimeNodeFromBimId(t) {
    const e = this._bimNodeIdMap.get(t);
    return e !== void 0 ? e : null;
  }
}
class Pn {
  constructor(t, e, i, n, r) {
    this._reservedNodeIdOffset = null, this._inclusionContexts = null, this._originalFileName = "", this._originalFileType = Dc.Unknown, this._assemblyDataVersion = [], this._genericTypeMaps = null, console.assert(n !== Ur.Invalid), this._remapper = t, this._attachScope = e, this._attachedInvisibly = i, this._masterModelKey = n, this._parent = r;
  }
  async getRootNodeMetaData(t) {
    if (this._masterModelKey === Ur.Invalid)
      return null;
    const e = t.getAbstractScEngine(), i = this._masterModelKey, r = await e.safeGetMetaData(i, 1);
    if (r !== null) {
      const o = t.tryParseHeader(r);
      if (o === null)
        return new va(null, r);
      const l = await o;
      this._originalFileName = l.originalFileName, this._originalFileType = l.originalFileType, this._assemblyDataVersion = l.assemblyDataVersion;
      const h = await e.safeGetMetaData(i, l.rootAssemblyDataKey());
      return h !== null ? new va(l, h) : null;
    }
    return null;
  }
  getAttachScope() {
    return this._attachScope;
  }
  attachedInvisibly() {
    return this._attachedInvisibly;
  }
  getMasterModelKey() {
    return this._masterModelKey;
  }
  addInclusionContext(t) {
    console.assert(t.getParent() === this), this._inclusionContexts = Yn(this._inclusionContexts, t);
  }
  getRemapper() {
    return this._remapper;
  }
  getParent() {
    return this._parent;
  }
  getChildren() {
    const t = this._inclusionContexts;
    if (t === null)
      return [];
    if (Array.isArray(t)) {
      console.assert(t.length > 0);
      const e = t[0].getChildren();
      for (let i = 1; i < t.length; ++i) {
        const n = t[i];
        e.push(...n.getChildren());
      }
      return e;
    } else
      return t.getChildren();
  }
  getInclusionContexts() {
    return hi(this._inclusionContexts);
  }
  split(t, e, i) {
    return new Pn(
      this._remapper,
      t,
      e,
      this._masterModelKey,
      i
    );
  }
  hasChildren() {
    return this._inclusionContexts !== null;
  }
  removeProductOccurrence(t) {
    let e = null, i = hi(this._inclusionContexts);
    for (const n of i)
      if (n.removeProductOccurrence(t)) {
        e = n;
        break;
      }
    return e === null ? !1 : (i = i.filter((n) => n.hasChildren()), i.length === 0 ? this._inclusionContexts = null : this._inclusionContexts = vs(i), !0);
  }
  purgeContents() {
    const t = [], e = hi(this._inclusionContexts);
    for (const i of e) {
      const n = i.purgeContents();
      t.push(n);
    }
    return this._inclusionContexts = null, Ge(t);
  }
  isLoaded() {
    if (this._inclusionContexts instanceof Gn)
      return this._inclusionContexts.isLoaded();
    if (this._inclusionContexts === null)
      return !0;
    for (const t of this._inclusionContexts)
      if (!t.isLoaded())
        return !1;
    return !0;
  }
  setReservedNodeIdOffset(t) {
    console.assert(this._reservedNodeIdOffset === null), this._reservedNodeIdOffset = t;
  }
  getReservedNodeIdOffset() {
    return this._reservedNodeIdOffset;
  }
  forgetReservedNodeIdOffset() {
    console.assert(this._reservedNodeIdOffset !== null), this._reservedNodeIdOffset = null;
  }
  getOriginalFileName() {
    return this._originalFileName;
  }
  getOriginalFileType() {
    return this._originalFileType;
  }
  setGenericTypeMaps(t) {
    this._genericTypeMaps = t;
  }
  getGenericTypeMaps() {
    return this._genericTypeMaps;
  }
  getAssemblyDataVersion() {
    return this._assemblyDataVersion;
  }
}
function j0(s) {
  if (typeof s == "string")
    throw new oi();
  return s;
}
class Ls {
  constructor(t, e, i) {
    this._handledExternalModels = null, this._attachContexts = null, this._registeredScsModelKeys = /* @__PURE__ */ new Map(), this._layerIdMap = new b_(), this._parent = t, this._scsBufferCache = i;
  }
  /**
   * Returns whether or not an authored external model should be handled or not.
   */
  handleExternalModel(t, e, i) {
    const n = e.getInclusionKey(), r = `${af(i)} ${af(
      n
    )} ${af(t)}`;
    return this._handledExternalModels === null && (this._handledExternalModels = /* @__PURE__ */ new Set()), this._handledExternalModels.has(r) ? !1 : (this._handledExternalModels.add(r), !0);
  }
  getParent() {
    return this._parent;
  }
  addAttachContext(t) {
    this._attachContexts = Yn(this._attachContexts, t);
  }
  getChildren() {
    const t = this._attachContexts;
    if (t === null)
      return [];
    if (Array.isArray(t)) {
      console.assert(t.length > 0);
      const e = t[0].getChildren();
      for (let i = 1; i < t.length; ++i) {
        const n = t[i];
        e.push(...n.getChildren());
      }
      return e;
    } else
      return t.getChildren();
  }
  getAttachContexts() {
    return this._attachContexts === null ? [] : Array.isArray(this._attachContexts) ? this._attachContexts : [this._attachContexts];
  }
  hasChildren() {
    return this._attachContexts !== null;
  }
  removeProductOccurrence(t) {
    let e = null, i = hi(this._attachContexts);
    for (const n of i)
      if (n.removeProductOccurrence(t)) {
        e = n;
        break;
      }
    return e === null ? !1 : (i = i.filter((n) => n.hasChildren()), i.length === 0 ? this._attachContexts = null : this._attachContexts = vs(i), !0);
  }
  purgeContents() {
    const t = [], e = hi(this._attachContexts);
    for (const i of e) {
      const n = i.purgeContents();
      t.push(n);
    }
    return this._attachContexts = null, Ge(t);
  }
  isLoaded() {
    if (this._attachContexts instanceof Pn)
      return this._attachContexts.isLoaded();
    if (this._attachContexts === null)
      return !0;
    for (const t of this._attachContexts)
      if (!t.isLoaded())
        return !1;
    return !0;
  }
  /**
   * This should not be called more than once per `ExternalModelName` in a given `LoadContext`.
   */
  initializeScsModelKeysOf(t) {
    console.assert(this._registeredScsModelKeys.get(t) === void 0), this._registeredScsModelKeys.set(t, pd());
  }
  /**
   * Gets the model keys of an SCS model by its external name from a shattered XML file.
   *
   * Returns:
   *  - `null` if `initializeScsModelKeysOf` was not called for the given model.
   *  - `TrackedOpenPromise<null>` if the model has no attachment data.
   *  - `TrackedOpenPromise<ModelKey[]>` if the model has attachment data.
   */
  getScsModelKeysOf(t) {
    const e = this._registeredScsModelKeys.get(t);
    return e === void 0 ? null : e;
  }
  markAsFirstLoad() {
    console.assert(this._isFirstLoad === void 0), this._isFirstLoad = !0;
  }
  isFirstLoad() {
    return this._isFirstLoad === !0;
  }
  async toScsBuffer(t, e) {
    const i = jn.create(async () => {
      const n = await e(t);
      return j0(n);
    });
    return this._scsBufferCache === null ? i : this._scsBufferCache.load(t, i);
  }
  // This gets called on both successful and erroneous loads.
  onLoadComplete() {
    this._scsBufferCache = null;
  }
  addLayerIdToMap(t, e) {
    this._layerIdMap.set(t, e);
  }
  getAuthoredLayerId(t) {
    const e = this._layerIdMap.getRight(t);
    return e !== void 0 ? e : null;
  }
  getRuntimeLayerId(t) {
    const e = this._layerIdMap.getLeft(t);
    return e !== void 0 ? e : null;
  }
  // Maps runtime layer IDs to authored layer IDs
}
function oh(s) {
  let t = Wn.getIdentity(), e = s;
  for (; e !== null; )
    if (e instanceof ts) {
      const i = e.getLocalTransform();
      i && (t = Wn.multiply(t, i)), e instanceof ns ? e = null : e = e.getParent();
    } else if (e instanceof Gn)
      e = e.getParent();
    else if (e instanceof Pn)
      e = e.getParent();
    else if (e instanceof Ls)
      e = e.getParent();
    else
      return t;
  return t;
}
function I_(s) {
  let t = s;
  for (; ; )
    if (t instanceof ts)
      if (t instanceof Rl)
        t = t.getParent();
      else
        return t;
    else if (t instanceof Ls)
      t = t.getParent();
    else if (t instanceof Gn)
      t = t.getParent();
    else if (t instanceof Pn)
      t = t.getParent();
    else {
      if (t === null)
        return null;
      console.assert(!1), t = t.getInclusionContext();
    }
}
function Do(s) {
  return s instanceof Rl || s instanceof _e ? s.isOutOfHierarchy() : !1;
}
function W0(s) {
  return s instanceof _e || s instanceof Sn || s instanceof ss ? s.getBranchVisibility() : s.isVisible() ? de.Shown : de.Hidden;
}
function G0(s) {
  if (s instanceof _e)
    return s.isADrawingSheetNode() ? Le.DrawingSheet : s.hasBodyInstances() ? Le.PartInstance : Le.AssemblyNode;
  if (s instanceof ns)
    return Le.Part;
  if (s instanceof Bs)
    return Le.PmiBody;
  if (s instanceof co)
    return Le.ViewFrame;
  if (s instanceof Ui)
    return Le.BodyInstance;
  if (s instanceof tn)
    switch (s.getBodyType()) {
      case el.BRep:
        return Le.BrepBody;
      case el.Tessellation:
        return Le.TessBody;
      case el.Wireframe:
        return Le.WireBody;
      case el.PointCloud:
        return Le.PointsBody;
      case el.Unknown:
      default:
        return Le.Body;
    }
  else
    return s instanceof Sn ? Le.Pmi : Le.CadView;
}
function ah(s) {
  const t = s.getGenericTypeId();
  if (t !== null) {
    const i = Fi(s).getGenericTypeMaps();
    if (i !== null)
      return i.getRight(t) || null;
  }
  return null;
}
function Gi(s) {
  let t = s;
  for (; ; )
    if (t instanceof ts)
      t = t.getParent();
    else {
      if (t instanceof Gn)
        return t;
      if (t instanceof Bs)
        t = t.getParent();
      else if (t instanceof co)
        t = t.getParent();
      else
        return t.getInclusionContext();
    }
}
function Js(s) {
  let t = s;
  for (; ; )
    if (t instanceof Pn)
      t = t.getParent();
    else {
      if (t instanceof Ls)
        return t;
      t instanceof ts || t instanceof Gn ? t = t.getParent() : t = t.getInclusionContext();
    }
}
function Fi(s) {
  let t = s;
  for (; ; )
    if (t instanceof Gn)
      t = t.getParent();
    else {
      if (t instanceof Pn)
        return t;
      if (t instanceof ts)
        t = t.getParent();
      else if (t instanceof Ls) {
        const e = t.getParent();
        if (e === null)
          throw new oi();
        t = e;
      } else
        t = t.getInclusionContext();
    }
}
function Hp(s) {
  let t = null, e = s;
  for (; ; )
    if (e instanceof _e)
      t = e, e = e.getParent();
    else if (e instanceof ts)
      e = e.getParent();
    else if (e instanceof Gn) {
      if (t === null)
        throw new oi();
      return t;
    } else
      e = e.getInclusionContext();
}
function pr(s) {
  let t = s;
  for (; ; ) {
    if (t instanceof _e)
      return t;
    if (t instanceof Pn)
      t = t.getParent();
    else if (t instanceof Gn)
      t = t.getParent();
    else if (t instanceof Ls) {
      const e = t.getParent();
      if (e === null)
        return null;
      t = e;
    } else if (t instanceof Rl)
      t = t.getParent();
    else if (t instanceof Sn)
      t = t.getParent();
    else if (t instanceof ss)
      t = t.getParent();
    else
      return console.assert(!1), null;
  }
}
const $0 = "IFCCOLUMN", q0 = "IFCCOVERING", K0 = "IFCCURTAINWALL", X0 = "IFCDOOR", J0 = "IFCRAMP", Y0 = "IFCROOF", Z0 = "IFCSLAB", Q0 = "IFCSTAIR", tb = "IFCSTAIRFLIGHT", eb = "IFCTRANSPORTELEMENT", ib = "IFCWALL", nb = "IFCWALLSTANDARDCASE", sb = "IFCWINDOW";
function rb(s, t) {
  let e = s;
  for (; e !== null; ) {
    if (e.getName() === t || ah(e) === t)
      return !0;
    e = pr(e.getParent());
  }
  return !1;
}
function ob(s) {
  switch (s) {
    case $0:
    case K0:
    case Q0:
    case tb:
    case ib:
    case nb:
    case sb:
      return mn.Wall | mn.Floor;
    case q0:
    case J0:
    case Y0:
    case Z0:
      return mn.Floor;
    case X0:
    case eb:
      return mn.Door | mn.Floor;
  }
  return mn.None;
}
async function ab(s, t, e, i) {
  const n = await t.getNodeOrRepItem(e);
  if (n === null || n instanceof tn || n instanceof ns)
    return mn.None;
  let r = ah(n);
  if (r === null) {
    if (i === null)
      return mn.None;
    const l = await n.getAttributes();
    for (const h of l)
      if (h.getTitle() === i) {
        r = h.getValue();
        break;
      }
    if (r === null)
      return mn.None;
  }
  const o = s(r);
  return o !== mn.None ? o : mn.None;
}
async function lb(s) {
  const t = [], e = {
    enterAnyBody: (i) => {
      i instanceof Ui && t.push(i);
    }
  };
  return await Ln.walk(e, s, Vt.None), t;
}
async function cb(s) {
  const t = await lb(s), e = /* @__PURE__ */ new Set();
  for (const i of t) {
    const n = i.getParent();
    e.add(n);
  }
  return ao(e);
}
async function hb(s, t, e, i) {
  const n = [];
  for (const u of e) {
    const d = ab(
      s,
      t,
      u,
      i
    );
    n.push(d);
  }
  const r = await Promise.all(n), o = [], l = [], h = [];
  for (let u = 0; u < e.length; ++u) {
    const d = e[u], g = r[u];
    g !== mn.None && (g & mn.Floor && o.push(d), g & mn.Wall && l.push(d), g & mn.Door && h.push(d));
  }
  return {
    floors: o,
    walls: l,
    doors: h
  };
}
function uf(s) {
  const t = [];
  for (const e of s) {
    const i = e.getBodyInstances();
    for (const n of i) {
      const r = n.getInstanceInc();
      t.push(r[0], r[1]);
    }
  }
  return t;
}
async function ub(s, t, e, i, n) {
  const r = await cb(i), o = await hb(
    s,
    e,
    r,
    n
  ), l = uf(o.floors);
  t.registerBimInstances(l, Pc.Floor);
  const h = uf(o.walls);
  t.registerBimInstances(h, Pc.Wall);
  const u = uf(o.doors);
  t.registerBimInstances(u, Pc.Door);
}
async function db(s, t, e) {
  const i = [], n = [], r = {
    enterAnyBody: (u) => {
      if (u instanceof Ui && !u.isOutOfHierarchy()) {
        i.push(u);
        const d = u.getInstanceInc();
        n.push(d[0], d[1]);
      }
    }
  };
  await Ln.walk(r, s, Vt.None);
  const o = /* @__PURE__ */ new Map(), l = await t.getPartColor(n, e), h = l.length;
  console.assert(h === i.length);
  for (let u = 0; u < h; ++u) {
    const d = l[u];
    d !== null && o.set(i[u].getRuntimeId(), d);
  }
  return o;
}
function vl(s) {
  return [s.x, s.y, s.z];
}
function fb(s) {
  return [Math.abs(s[0]), Math.abs(s[1]), Math.abs(s[2])];
}
function gb(s, t) {
  return [s[0] * t[0], s[1] * t[1], s[2] * t[2]];
}
function pb(s, t) {
  return [s[0] + t[0], s[1] + t[1], s[2] + t[2]];
}
function mb(s, t) {
  return [s[0] - t[0], s[1] - t[1], s[2] - t[2]];
}
function _b(s, t) {
  return [s[0] + t[0], s[1] + t[1], s[2] + t[2], s[3] + t[3]];
}
function Nf(s, t) {
  return [s[0] - t[0], s[1] - t[1], s[2] - t[2], s[3] - t[3]];
}
function io(s, t) {
  return s[0] * t[0] + s[1] * t[1] + s[2] * t[2];
}
function wg(s) {
  const t = s[0], e = s[1], i = s[2];
  return t * t + e * e + i * i;
}
function Up(s) {
  return Math.sqrt(wg(s));
}
function yb(s, t) {
  return [s * t[0], s * t[1], s * t[2]];
}
function df(s) {
  return [s.x, s.y, s.z, s.w];
}
function _c(s, t) {
  const e = s.m, i = t;
  return [e[i], e[i + 4], e[i + 8], e[i + 12]];
}
function jp(s) {
  const t = s[0], e = s[1], i = s[2], n = s[3];
  return t * t + e * e + i * i + n * n;
}
function ff(s, t) {
  return [s * t[0], s * t[1], s * t[2], s * t[3]];
}
function wb(s, t, e) {
  let i = io(s, e) + e[3];
  return i *= i, i < 1e-5 && (i = 1e-5), t / i;
}
const rs = 400, ba = "_empty", vg = Ts;
function yu(s) {
  return s;
}
class Nc {
  // View with ViewKey 0
  /** @hidden */
  constructor(t, e) {
    this._pmiColor = vt.black(), this._pmiColorOverride = !1, this._viewAxes = new Wp(), this._viewAxesSet = !1, this._engine = t, this._callbackManager = e, this._callbackManager.bind({
      _firstModelLoaded: async (i) => {
      },
      _resetAssemblyTreeBegin: async () => {
        this._viewAxes = new Wp(), this._viewAxesSet = !1;
      }
    });
  }
  /** @hidden */
  _setModelStructure(t) {
    console.assert(this._modelStructure === void 0), this._modelStructure = t;
  }
  /** @hidden */
  _setDefaultView(t) {
    this._defaultView = t;
  }
  /**
   * Sets the up and front vectors for the model coordinate system.
   * Both the upVector and frontVector must be unique, cardinal axes.
   * @param frontVector
   * @param upVector
   */
  setViewAxes(t, e) {
    if (t.isAxis() && e.isAxis() && !t.equals(e))
      this._viewAxes.frontVector = t, this._viewAxes.upVector = e, this._callbackManager.trigger("viewAxes", t, e), this._viewAxesSet = !0;
    else
      throw new oe("The upVector and frontVector must be unique, cardinal axes.");
  }
  /**
   * Gets whether there has been a successful call to setViewAxes.
   */
  viewAxesHaveBeenSet() {
    return this._viewAxesSet;
  }
  /**
   * @returns the up and front vectors for the model coordinate system.
   */
  getViewAxes() {
    return this._viewAxes;
  }
  /**
   * Gets the world space bounding box for the model.
   * @returns Promise that resolves with a Box representing the world space bounding box of the model.
   */
  async getModelBounding(t, e, i = !1) {
    let n = new yn();
    try {
      n = await this._engine.getModelBounding(
        t,
        e,
        i
      );
    } catch (r) {
      console.assert(ha(r) && Gm(r) === cg.Cancelled);
    }
    return n;
  }
  /**
   * Gets the world space bounding box for the model. This does not take node visibility into account.
   * @returns Promise that resolves with a Box representing the world space bounding box of the model.
   */
  async getLooseBounding() {
    return this._engine.getLooseBounding();
  }
  /** @hidden */
  _allowNodeDeletion(t) {
    return this._modelStructure.allowNodeDeletion(t);
  }
  /** @hidden */
  _preventNodeDeletion(t) {
    return this._modelStructure.preventNodeDeletion(t);
  }
  /** @hidden */
  _preventMeshDeletion(t) {
    return console.assert(t[0] === xs.Local), this._modelStructure.preventMeshDeletion(t[1]);
  }
  /** @hidden */
  _getNodeFromInstanceInc(t, e, i, n) {
    return this._modelStructure.getNodeFromInstanceInc(
      t,
      e,
      i,
      n
    );
  }
  /**
   * Gets the world space bounding box for a list of nodes.
   * @param nodeIds IDs of the nodes for which you wish to get the bounding box.
   * @param config Allows fine control of what body types to compute the bounding against. If not provided, all body types are considered.
   * @returns Promise that resolves with the world space bounding box for the given IDs.
   */
  getNodesBounding(t, e) {
    let i = $t.All;
    return (e == null ? void 0 : e.bodyInstance) === !1 && (i &= ~$t.BodyInstance), (e == null ? void 0 : e.pmiBody) === !1 && (i &= ~$t.PmiBody), (e == null ? void 0 : e.viewFrame) === !1 && (i &= ~$t.ViewFrame), this._modelStructure.getBounding(
      t,
      i,
      (e == null ? void 0 : e.ignoreInvisible) ?? !1,
      (e == null ? void 0 : e.tightBounding) ?? !1
    );
  }
  /**
   * Gets the world space bounding box for a node including any effects (explosion, camera suppression, etc).
   * Note: This function can have performance implications when used on nodes with many children.
   * @param nodeId ID of the node for which you wish to get the bounding box.
   * @param view View to use for determining visibility.
   * @returns Promise that resolves with the world space bounding box for the given ID.
   */
  async getNodeRealBounding(t, e) {
    const i = e !== void 0 ? e.id : Me.Default, n = this._modelStructure.gatherInstanceIncsFromNodeIds(
      [t],
      $t.All,
      Vt.None
    );
    if (n.length === 0)
      throw new oe("Cannot get bounding of node without geometry.");
    return this._engine.getDrawnPartsBounding(n, i);
  }
  /**
   * Sets the visibility for a given set of nodes.
   * @param mapping The mapping of node IDs to boolean value indicating the visibility setting for that node.
   * @param initiallyHiddenStayHidden Controls whether or not initially hidden geometries stay hidden. Default behavior is driven by [[setBehaviorInitiallyHidden]].
   * @param mode an optional walk mode to use while traversing the model tree
   * @returns Promise that resolves when the operation has completed.
   */
  setNodesVisibilities(t, e = null) {
    return t = Op(t), this._modelStructure.setVisibilitiesByMap(
      t,
      e !== null ? e : void 0
    );
  }
  /**
   * Sets visibility for a given list of nodes.
   * @param nodeIds The node IDs whose visibilities will be set.
   * @param visibility If true, nodes will be shown. If false, they will be hidden.
   * @param initiallyHiddenStayHidden Controls whether or not initially hidden geometries stay hidden. Default behavior is driven by [[setBehaviorInitiallyHidden]].
   * @param mode an optional walk mode to use while traversing the model tree
   * @returns Promise that resolves when the operation has completed.
   */
  setNodesVisibility(t, e, i = null) {
    return this._modelStructure.setVisibilitiesByValue(
      t,
      e,
      i
    );
  }
  setBodyNodesVisibility(t, e) {
    const i = this._modelStructure.lookupAnyTreeNode(t);
    if (i === null)
      throw new Ds(t);
    const n = typeof e == "boolean" ? (r) => e : e;
    return this._modelStructure.setBodyNodesVisibility(
      i,
      (r) => n(r.getRuntimeId())
    );
  }
  /**
   * Resets visibility for all nodes in the model.
   * @returns Promise that resolves when the operation has completed.
   */
  resetNodesVisibility() {
    return this.isDrawing() ? this._callbackManager.promiseTrigger("_resetDrawing", null) : this._modelStructure.resetAllVisibilities();
  }
  /**
   * Returns a defaultVisibility boolean value and a visibilityException set of NodeIds.
   * defaultVisibility will be true if there are more nodes visible than hidden, and false otherwise.
   * If defaultVisibility is true, set of nodes that are hidden, if false, nodes that are visible.
   */
  async getVisibilityState(t) {
    const e = this._modelStructure.lookupAnyTreeNode(t);
    if (e === null)
      throw new Ds(t);
    return c_(e);
  }
  /**
   * Resets transform for all nodes in the model.
   * @returns Promise that resolves when the operation has completed.
   */
  resetNodesTransform() {
    return this._modelStructure.resetAllTransforms();
  }
  /**
   * Resets the state of the model to its default
   * @returns Promise that resolves when the operation has completed.
   */
  reset() {
    return this.resetModelOpacity(), this._modelStructure.reset();
  }
  /**
   * Remove all nodes, CAD views, configurations, and sheets from the model.
   *
   * If you intend to load additional models via the `loadSubtree` family
   * of methods, you should wait on the resolution of this promise before doing so.
   */
  clear() {
    return this._modelStructure.clear();
  }
  /**
   * Sets the color on the faces for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to set
   * @param color the color to set
   * @returns Promise that resolves when this operation has completed.
   */
  setNodesFaceColor(t, e) {
    return this._setNodesFaceColor(t, e), Promise.resolve();
  }
  /**
   * Sets the ambient color on the faces for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to set
   * @param color the color to set
   */
  setNodesAmbientColor(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      $t.All,
      Vt.None
    );
    i.length > 0 && this._engine.setPartAmbientColor(i, Yt.Faces, e);
  }
  /**
   * Sets the ambient mix on the faces for a given list of nodes.
   * The mix is between the material ambient light and the global ambient light,
   * with 1.0 representing full material ambient mix and 0.0 representing full global
   * ambient light.
   * @param nodeIds IDs of nodes whose color to set
   * @param value the decimal value to set, between 0 and 1
   */
  setNodesAmbientMix(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      $t.All,
      Vt.None
    );
    i.length > 0 && this._engine.setPartAmbientMix(i, Yt.Faces, e);
  }
  /**
   * Gets the ambient color on the faces for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to get
   */
  getNodesAmbientColor(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      $t.All,
      Vt.None
    );
    return e.length > 0 ? this._engine.getPartAmbientColor(e, Yt.Faces) : Promise.resolve([]);
  }
  /**
   * Gets the ambient color set on the faces of a list of leaf nodes. If no color has been set,
   * the color specified when the model was authored will be returned.
   * @param nodeIds IDs of the nodes to be queried
   */
  getNodesEffectiveAmbientColor(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      $t.All,
      Vt.None
    );
    return e.length > 0 ? this._engine.getPartEffectiveAmbientColor(e, Yt.Faces) : Promise.resolve([]);
  }
  /**
   * Unsets the ambient color on the faces for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to unset
   */
  unsetNodesAmbientColor(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      $t.All,
      Vt.None
    );
    e.length > 0 && this._engine.unsetPartAmbientColor(e, Yt.Faces);
  }
  /**
   * Sets the emissive color on the faces for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to set
   * @param color the color to set
   */
  setNodesFaceEmissiveColor(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      $t.All,
      Vt.None
    );
    i.length > 0 && this._engine.setPartEmissiveColor(i, Yt.Faces, e);
  }
  /**
   * Gets the emissive color on the faces for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to get
   */
  getNodesFaceEmissiveColor(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      $t.All,
      Vt.None
    );
    return e.length > 0 ? this._engine.getPartEmissiveColor(e, Yt.Faces) : Promise.resolve([]);
  }
  /**
   * Gets the emissive color set on the faces of a list of leaf nodes. If no color has been set,
   * the color specified when the model was authored will be returned.
   * @param nodeIds IDs of the nodes to be queried
   */
  getNodesEffectiveEmissiveColor(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      $t.All,
      Vt.None
    );
    return e.length > 0 ? this._engine.getPartEffectiveEmissiveColor(e, Yt.Faces) : Promise.resolve([]);
  }
  /**
   * Resets the emissive color on the faces for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to reset
   */
  unsetNodesFaceEmissiveColor(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      $t.All,
      Vt.None
    );
    e.length > 0 && this._engine.unsetPartEmissiveColor(e, Yt.Faces);
  }
  /**
   * Sets the specular color on the faces for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to set
   * @param color the color to set
   */
  setNodesFaceSpecularColor(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      $t.All,
      Vt.None
    );
    i.length > 0 && this._engine.setPartSpecularColor(i, Yt.Faces, e);
  }
  /**
   * Gets the specular color on the faces for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to get
   */
  getNodesFaceSpecularColor(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      $t.All,
      Vt.None
    );
    return e.length > 0 ? this._engine.getPartSpecularColor(e, Yt.Faces) : Promise.resolve([]);
  }
  /**
   * Gets the specular color set on the faces of a list of leaf nodes. If no color has been set,
   * the color specified when the model was authored will be returned.
   * @param nodeIds IDs of the nodes to be queried
   */
  getNodesEffectiveSpecularColor(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      $t.All,
      Vt.None
    );
    return e.length > 0 ? this._engine.getPartEffectiveSpecularColor(e, Yt.Faces) : Promise.resolve([]);
  }
  /**
   * Resets the specular color on the faces for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to reset
   */
  unsetNodesFaceSpecularColor(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      $t.All,
      Vt.None
    );
    e.length > 0 && this._engine.unsetPartSpecularColor(e, Yt.Faces);
  }
  /**
   * Sets the specular intensity on the faces for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to set
   * @param value the value to set
   */
  setNodesFaceSpecularIntensity(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      $t.All,
      Vt.None
    );
    i.length > 0 && this._engine.setPartSpecularIntensity(i, Yt.Faces, e);
  }
  /**
   * Resets the specular intensity on the faces for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to set
   */
  unsetNodesFaceSpecularIntensity(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      $t.All,
      Vt.None
    );
    e.length > 0 && this._engine.unsetPartSpecularIntensity(e, Yt.Faces);
  }
  _setNodesFaceColor(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      $t.All,
      Vt.None
    );
    i.length > 0 && this._engine.setPartColor(i, Yt.Faces, e);
  }
  _unsetNodesColor(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      $t.All,
      Vt.None
    );
    i.length > 0 && this._engine.unsetPartColor(i, e);
  }
  /**
   * Unsets the color on the faces for a given list of nodes.
   * @param nodeIds IDs of nodes to modify
   * @param color the color to set
   * @returns Promise that resolves when this operation has completed.
   */
  unsetNodesFaceColor(t) {
    return this._unsetNodesColor(t, Yt.Faces), Promise.resolve();
  }
  /**
   * Sets the color on the lines/edges for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to set
   * @param color the color to set
   * @returns Promise that resolves when this operation has completed.
   */
  setNodesLineColor(t, e) {
    return this._setNodesLineColor(t, e), Promise.resolve();
  }
  _setNodesLineColor(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      $t.All,
      Vt.None
    );
    i.length > 0 && this._engine.setPartColor(i, Yt.Lines, e);
  }
  /**
   * Unsets the color on the lines for a given list of nodes.
   * @param nodeIds IDs of nodes to modify
   * @param color the color to set
   * @returns Promise that resolves when this operation has completed.
   */
  unsetNodesLineColor(t) {
    return this._unsetNodesColor(t, Yt.Lines), Promise.resolve();
  }
  /**
   * Sets whether the supplied nodes should appear highlighted. When a node is highlighted,
   * the highlight color will override any color previously set on the model.
   *
   * *Tip:* An easy way to unhighlight the entire model is to call [[setNodesHighlighted]]
   * on the root node of the model:
   * ```
   * hwv.model.setNodesHighlighted([hwv.model.getAbsoluteRootNode()], false);
   * ```
   * (In this case, `hwv` is your instance of [[WebViewer]].)
   *
   * @param nodeIds array of IDs for this operation.
   * @param highlighted value indicating whether the supplied nodes should be highlighted.
   * @returns Promise that resolves when this operation has completed.
   */
  setNodesHighlighted(t, e) {
    if (t.length === 0)
      return Promise.resolve();
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      $t.All,
      Vt.LoadedNodesOnly
    );
    return i.length > 0 && this._engine.highlightParts(i, e), Promise.resolve();
  }
  /**
   * Returns whether the supplied nodes have been highlighted with [[setNodesHighlighted]].
   * @param nodeIds the list of nodes to be queried
   */
  getNodesHighlighted(t) {
    const e = this._getInstanceIncsFromLeafNodes(t);
    return e.length > 0 ? this._engine.getPartHighlighted(e) : Promise.resolve([]);
  }
  /**
   * Sets colors for a given set of nodes.
   *
   * @param params object mapping node IDs to color to set for that node
   * @param alsoApplyToWireframe change or not lines color
   * @param alsoApplyToPoints change or not points color
   * @returns Promise that resolves when this operation has completed.
   */
  setNodesColors(t, e = !1, i = !1) {
    const n = /* @__PURE__ */ new Set(), r = /* @__PURE__ */ new Map(), o = (l, h) => {
      const u = this._modelStructure.lookupAnyTreeNode(l);
      if (u !== null) {
        const d = ih(
          u,
          $t.All,
          !1,
          n,
          Vt.None
        );
        if (d.length > 0) {
          const g = (h.r << 16) + (h.g << 8) + h.b, y = r.get(g);
          y ? r.set(g, y.concat(d)) : r.set(g, d);
        }
      }
    };
    if (t instanceof Map)
      t.forEach((l, h) => {
        o(h, l);
      });
    else {
      const l = Object.keys(t);
      for (const h of l) {
        const u = parseInt(h, 10);
        o(u, t[u]);
      }
    }
    return r.forEach((l, h) => {
      const u = new vt(h >> 16, (h & 65280) >> 8, h & 255);
      this._engine.setPartColor(l, Yt.Faces, u), e && this._engine.setPartColor(l, Yt.Lines, u), i && this._engine.setPartColor(l, Yt.Points, u);
    }), Promise.resolve();
  }
  /**
   * Gets an array of PMI topology references linking a PMI node to a body element, like a face or an edge.
   * @param pmiNodeId the ID of the PMI node.
   */
  getPmiTopologyReferences(t) {
    const e = [], i = (r, o, l) => {
      const h = new Sb();
      return h.bodyId = r, h.subElementType = o, h.subElementIndex = l, h;
    }, n = this._modelStructure.getPmiTopologyReferences(t);
    if (n !== null)
      for (const r of n) {
        const o = r.body.getRuntimeId(), l = r.faceIds;
        for (const u of l)
          e.push(i(o, ch.Face, u));
        const h = r.edgeIds;
        for (const u of h)
          e.push(i(o, ch.Edge, u));
      }
    return e.length === 0 ? null : e;
  }
  /**
   * Returns names and ids of all the PMIs available in the scene
   * @returns a map associating PMI IDs to PMI names
   */
  getPmis() {
    return this._modelStructure.getPmis();
  }
  /**
   * Returns the type of a given PMI
   * @param idPMI ID of the PMI
   * @returns Type of the PMI (Dimension, Datum, GD&T...)
   */
  getPmiType(t) {
    return this._modelStructure.getPmiType(t);
  }
  /**
   * Returns the subtype of a given PMI
   * @param idPMI ID of the PMI
   * @returns Subtype of the PMI (Dimension distance, Datum target, GD&T fcf...)
   */
  getPmiSubtype(t) {
    return this._modelStructure.getPmiSubType(t);
  }
  /**
   * Saves a PMI override color
   * @param color the override color
   */
  setPmiColor(t) {
    this._pmiColor.assign(t);
  }
  /**
   * Returns the set PMI override color  (if none is set, defaults to black)
   * @returns color
   */
  getPmiColor() {
    return this._pmiColor.copy();
  }
  /**
   * Takes a boolean value and either enables the set PMI override color or resets all PMI colors to their default
   * @returns Promise that resolves when this operation has completed.
   */
  setPmiColorOverride(t, e) {
    return this._pmiColorOverride = t, t ? this._modelStructure.setPmiColor(this._pmiColor, e) : this._modelStructure.resetPmiColor(e), Promise.resolve();
  }
  /**
   * @returns a boolean value indicating the status of the PMI override color.
   */
  getPmiColorOverride() {
    return this._pmiColorOverride;
  }
  /**
   * Computes the distance between two bodies
   * @param partId1 id for the part which the first face belongs to
   * @param partId2 id for the part which the second face belongs to
   * @returns a promise that resolves with a Markup.Measure.FaceFaceDistanceItem when the operation completes
   */
  computeMinimumBodyBodyDistance(t, e) {
    const i = this._modelStructure.lookupAnyBody(t);
    if (i === null)
      throw new is(t, In.AnyBody);
    const n = this._modelStructure.lookupAnyBody(e);
    if (n === null)
      throw new is(e, In.AnyBody);
    const r = i.getInstanceInc(), o = n.getInstanceInc();
    return this._engine.computeMinimumBodyBodyDistance(r, o);
  }
  /**
   * Computes the distance between two faces
   * @param partId1 id for the part which the first face belongs to
   * @param faceId1 id for the face in the first part
   * @param partId2 id for the part which the second face belongs to
   * @param faceId2 id for the face in the second part
   * @returns a promise that resolves with a Markup.Measure.FaceFaceDistanceItem when the operation completes
   */
  computeMinimumFaceFaceDistance(t, e, i, n) {
    const r = this._modelStructure.lookupAnyBody(t);
    if (r === null)
      throw new is(t, In.AnyBody);
    const o = this._modelStructure.lookupAnyBody(i);
    if (o === null)
      throw new is(i, In.AnyBody);
    const l = r.getInstanceInc(), h = o.getInstanceInc();
    return this._engine.computeMininimumFaceFaceDistance(
      [l[0], l[1]],
      e,
      [h[0], h[1]],
      n
    );
  }
  /**
   * Computers the minimum distance between a face and a ray.
   * @param nodeId id of the node the face belongs to
   * @param faceId id of the face in the node
   * @param ray the ray to test against
   * @returns a promise that resolves with a Markup.Measure.FaceFaceDistanceItem when the operation completes
   */
  computeMinimumFaceRayDistance(t, e, i) {
    const n = this._modelStructure.lookupAnyBody(t);
    if (n === null)
      throw new is(t, In.AnyBody);
    const r = n.getInstanceInc();
    return this._engine.computeMinimumFaceRayDistance(r, e, i);
  }
  /**
   * Computers the minimum distance between a face and an infinite line.
   * @param nodeId id of the node the face belongs to
   * @param faceId id of the face in the node
   * @param ray the line (in the form of a ray) to test against
   * @returns a promise that resolves with a Markup.Measure.FaceFaceDistanceItem when the operation completes
   */
  computeMinimumFaceLineDistance(t, e, i) {
    const n = this._modelStructure.lookupAnyBody(t);
    if (n === null)
      throw new is(t, In.AnyBody);
    const r = n.getInstanceInc();
    return this._engine.computeMinimumFaceLineDistance(r, e, i);
  }
  /**
   * Sets the color for a face element. This color will take precedence over any currently set color on the node
   * @param nodeId the Id of the node containing the face
   * @param faceId the Id of the face in the node that will have its color set
   * @param color the color to set
   */
  setNodeFaceColor(t, e, i) {
    return this._setNodeFaceColor(t, e, i), Promise.resolve();
  }
  _setNodeFaceColor(t, e, i) {
    const n = this._modelStructure.gatherInstanceIncsFromNodeIds(
      [t],
      $t.All,
      Vt.None
    );
    if (n.length === 2) {
      const r = n;
      this._engine.setElementColor(r, Yt.Faces, e, 1, i);
    }
  }
  /**
   * Sets the visibility for a face element. This visibility setting will take precedence over other element visibility settings
   * @param partId the Id of the part containing the face
   * @param faceId the Id of the face in the node that will have its visibility set
   * @param visibility visibility state to be set
   */
  setNodeFaceVisibility(t, e, i) {
    this._setNodeElementVisibility(t, e, i, Yt.Faces);
  }
  /**
   * Clears the visibility for a node's face elements, resetting them to default.
   * @param partId the Id of the part to be reset
   */
  clearNodeFaceVisibility(t) {
    this._clearNodeElementVisibility(t, Yt.Faces);
  }
  _setNodeElementVisibility(t, e, i, n) {
    const r = this._modelStructure.gatherInstanceIncsFromNodeIds(
      [t],
      $t.All,
      Vt.None
    );
    if (r.length === 2) {
      const o = r;
      this._engine.setElementVisibility(o, n, e, 1, i);
    }
  }
  _clearNodeElementVisibility(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      [t],
      $t.All,
      Vt.None
    );
    if (i.length === 2) {
      const n = i;
      this._engine.clearElementVisibility(n, e);
    }
  }
  _unsetElementColor(t, e, i) {
    if (i < 0)
      return;
    const n = this._getInstanceIncFromSingleLeafNode(t);
    this._engine.unsetElementColor(n, e, i, 1);
  }
  /**
   * Unsets the color for a face element. This will return the face's color to its default state.
   * @param nodeId the Id of the node containing the face
   * @param faceId the Id of the face in the node that will have its color unset
   */
  unsetNodeFaceColor(t, e) {
    return this._unsetElementColor(t, Yt.Faces, e), Promise.resolve();
  }
  /**
   * Sets whether the face element for a given node should appear highlighted.
   * When a face element is highlighted, the highlight color will override
   * any color previously set on the element.
   * @param nodeId the id for the node containing the face element.
   * @param faceId the face Id that is the target of this operation.
   * @param highlighted value indicating whether the supplied face element should be highlighted.
   */
  setNodeFaceHighlighted(t, e, i) {
    return this._setNodeFaceHighlighted(t, e, i), Promise.resolve();
  }
  _setNodeFaceHighlighted(t, e, i) {
    const n = this._modelStructure.gatherInstanceIncsFromNodeIds(
      [t],
      $t.All,
      Vt.LoadedNodesOnly
    );
    n.length > 0 && this._engine.highlightElements(n, Yt.Faces, e, 1, i);
  }
  async _getElementHighlighted(t, e, i) {
    const n = this._getInstanceIncFromSingleLeafNode(t), [r] = await this._engine.getElementHighlighted(n, e, i);
    return r;
  }
  /**
   * Returns whether the supplied face element has been highlighted with [[setNodeFaceHighlighted]].
   * @param nodeId the ID of the node containing the face element
   * @param faceIndex the index of the face within the node
   */
  getNodeFaceHighlighted(t, e) {
    return this._getElementHighlighted(t, Yt.Faces, e);
  }
  /**
   * Gets the color set via [[setNodePointColor]] on a point element.
   * If no color has been set, `null` will be returned.
   * <br><br> See also: [[getNodeEffectivePointColor]]
   * @param nodeId the ID of the node containing the point
   * @param pointIndex the index of the point in the node
   */
  getNodePointColor(t, e) {
    return this._getNodeElementColor(t, Yt.Points, e);
  }
  /**
   * Gets the color set via [[setNodePointColor]] on a point element. If no color has been set,
   * the node's point color will be returned. If the node's point color has not been set,
   * the color specified when the model was authored will be returned.
   * @param nodeId the ID of the node containing the point
   * @param pointIndex the index of the point in the node
   * @param view the View to use for calculating view effects
   */
  getNodeEffectivePointColor(t, e, i) {
    return this._getNodeEffectiveElementColor(t, Yt.Points, e, i);
  }
  /**
   * Sets the color for a point element.
   * @param partId the Id of the node containing the point.
   * @param pointId the Id of the point in the node that will have its color set.
   * @param color the color to set.
   */
  setNodePointColor(t, e, i) {
    const n = this._modelStructure.lookupAnyBody(t);
    if (n === null)
      throw new is(t, In.AnyBody);
    const r = n.getInstanceInc();
    this._engine.setElementColor(r, Yt.Points, e, 1, i);
  }
  /**
   * Unsets the color for a point element. This will return the point's color to its default state.
   * @param partId the Id of the node containing the point
   * @param pointId the Id of the point in the node that will have its color unset
   */
  unsetNodePointColor(t, e) {
    this._unsetElementColor(t, Yt.Points, e);
  }
  /**
   * Gets the color set via [[setNodesPointColor]] on the points of a list of leaf nodes.
   * If no color has been explicitly set for a particular node, `null` will appear at the corresponding
   * position in the returned array.
   * <br><br> See also: [[getNodesEffectivePointColor]]
   * @param nodeIds IDs of the nodes to be queried
   */
  getNodesPointColor(t) {
    return this._getNodesColor(t, Yt.Points);
  }
  /**
   * Gets the color set on the points of a list of leaf nodes. If no color has been set,
   * the color specified when the model was authored will be returned.
   * @param nodeIds IDs of the nodes to be queried
   */
  getNodesEffectivePointColor(t) {
    return this._getNodesEffectiveColor(t, Yt.Points);
  }
  /**
   * Sets the color on the points for a given list of nodes.
   * @param nodeIds IDs of nodes whose color to set
   * @returns Promise that resolves when this operation has completed.
   */
  setNodesPointColor(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      $t.All,
      Vt.None
    );
    i.length > 0 && this._engine.setPartColor(i, Yt.Points, e);
  }
  /**
   * Unsets the color on the points for a given list of nodes.
   * @param nodeIds IDs of nodes to modify
   */
  unsetNodesPointColor(t) {
    this._unsetNodesColor(t, Yt.Points);
  }
  /**
   * Sets the color for a line element.
   * @param nodeId the Id of the node containing the line.
   * @param lineId the Id of the line in the node that will have its color set.
   * @param color the color to set.
   */
  setNodeLineColor(t, e, i) {
    return this._setNodeLineColor(t, e, i), Promise.resolve();
  }
  _setNodeLineColor(t, e, i) {
    const n = this._modelStructure.lookupAnyBody(t);
    if (n === null)
      throw new is(t, In.AnyBody);
    const r = n.getInstanceInc();
    this._engine.setElementColor(r, Yt.Lines, e, 1, i);
  }
  /**
   * Unsets the color for a line element. This will return the line's color to its default state.
   * @param nodeId the Id of the node containing the line
   * @param lineId the Id of the line in the node that will have its color unset
   */
  unsetNodeLineColor(t, e) {
    return this._unsetElementColor(t, Yt.Lines, e), Promise.resolve();
  }
  /**
   * Sets the visibility for a line element. This visibility setting will take precedence over other element visibility settings
   * @param partId the Id of the part containing the line
   * @param lineId the Id of the line in the node that will have its visibility set
   * @param visibility visibility state to be set
   */
  setNodeLineVisibility(t, e, i) {
    this._setNodeElementVisibility(t, e, i, Yt.Lines);
  }
  /**
   * Clears the visibility for a node's line elements, resetting them to default.
   * @param partId the Id of the part to clear visibilities from
   */
  clearNodeLineVisibility(t) {
    this._clearNodeElementVisibility(t, Yt.Lines);
  }
  /**
   * Sets whether the line element for a given node should appear highlighted. When a line element is highlighted, the highlight color will override any color previously set on the element.
   * @param nodeId the id for the node containing the line element.
   * @param lineId the line Id that is the target of this operation.
   * @param highlighted value indicating whether the supplied line element should be highlighted.
   */
  setNodeLineHighlighted(t, e, i) {
    return this._setNodeLineHighlighted(t, e, i), Promise.resolve();
  }
  _setNodeLineHighlighted(t, e, i) {
    const n = this._modelStructure.gatherInstanceIncsFromNodeIds(
      [t],
      $t.All,
      Vt.LoadedNodesOnly
    );
    n.length > 0 && this._engine.highlightElements(n, Yt.Lines, e, 1, i);
  }
  /**
   * Returns whether the supplied line element has been highlighted with [[setNodeLineHighlighted]].
   * @param nodeId the ID of the node containing the line element
   * @param lineIndex the index of the line within the node
   */
  getNodeLineHighlighted(t, e) {
    return this._getElementHighlighted(t, Yt.Lines, e);
  }
  /**
   * Sets the visibility for a point element. This visibility setting will take precedence over other element visibility settings
   * @param partId the Id of the part containing the point
   * @param pointId the Id of the point in the node that will have its visibility set
   * @param visibility visibility state to be set
   */
  setNodePointVisibility(t, e, i) {
    this._setNodeElementVisibility(t, e, i, Yt.Points);
  }
  /**
   * Clears the visibility for a node's point elements, resetting it to default.
   * @param partId the Id of the part to clear visibilities from
   */
  clearNodePointVisibility(t) {
    this._clearNodeElementVisibility(t, Yt.Points);
  }
  /**
   * Sets whether the point element for a given node should appear highlighted. When a point element is highlighted, the highlight color will override any color previously set on the element.
   * @param nodeId the id for the node containing the point element.
   * @param pointId the point Id that is the target of this operation.
   * @param highlighted value indicating whether the supplied point element should be highlighted.
   */
  setNodePointHighlighted(t, e, i) {
    return this._setNodePointHighlighted(t, e, i), Promise.resolve();
  }
  _setNodePointHighlighted(t, e, i) {
    const n = this._modelStructure.lookupAnyBody(t);
    if (n === null)
      throw new is(t, In.AnyBody);
    const r = n.getInstanceInc();
    this._engine.highlightElements(r, Yt.Points, e, 1, i);
  }
  /**
   * Returns whether the supplied point element has been highlighted with [[setNodePointHighlighted]].
   * @param nodeId the ID of the node containing the point element
   * @param pointIndex the index of the point within the node
   */
  getNodePointHighlighted(t, e) {
    return this._getElementHighlighted(t, Yt.Points, e);
  }
  /**
   * Resets color for all nodes in the model.
   * @returns Promise that resolves when this operation has completed.
   */
  resetNodesColor() {
    return this._engine.resetColors(), Promise.resolve();
  }
  /**
   * Sets opacity for a given list of nodes.
   * @param nodeIds IDs of nodes whose opacity will be set
   * @param opacity opacity value to apply to each node. The value should be between the range of 0.0 and 1.0. 0.0 indicates fully transparent, while 1.0 is fully opaque.
   */
  setNodesOpacity(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      $t.All,
      Vt.None
    );
    i.length > 0 && this._engine.setPartOpacity(i, e);
  }
  /**
   * Returns whether nodes with the given NodeIds have an opacity value that is not fully opaque.
   * @param nodeIds IDs of nodes to query.
   * @returns array of boolean values corresponding to the id array passed into the function.  A value of true indicates that the node contains transparency and is not fully opaque.
   */
  getNodesHaveTransparency(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      $t.All,
      Vt.None
    );
    return e.length > 0 ? this._engine.getPartHasTransparency(e) : Promise.resolve([]);
  }
  /**
   * Sets opacity for a given set of nodes.
   * @param params object mapping node IDs to opacity to set for that NodeId. The opacity value should be between the range of 0.0 and 1.0. 0.0 indicates fully transparent, while 1.0 is fully opaque.
   */
  setNodesOpacities(t) {
    t = Op(t);
    const e = /* @__PURE__ */ new Set();
    t.forEach((i, n) => {
      const r = this._modelStructure.lookupAnyTreeNode(n);
      if (r !== null) {
        const o = ih(
          r,
          $t.BodyInstance,
          !1,
          e,
          Vt.None
        );
        o.length > 0 && this._engine.setPartOpacity(o, i);
      }
    });
  }
  /**
   * Resets opacity for all nodes in the model.
   * @returns Promise that resolves when this operation has completed.
   */
  resetModelOpacity() {
    this._engine.resetOpacity(), this._callbackManager.trigger("_resetOpacity");
  }
  /**
   * Resets highlight for all nodes in the model.
   * @returns Promise that resolves when this operation has completed.
   */
  resetModelHighlight() {
    return this._engine.clearHighlight(), Promise.resolve();
  }
  /**
   * Resets opacity for a given list of nodes.
   * @param nodeIds IDs of nodes whose opacity will be reset to their default values
   */
  resetNodesOpacity(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      $t.All,
      Vt.None
    );
    e.length > 0 && this._engine.unsetPartOpacity(e);
  }
  _getNodesColor(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      $t.All,
      Vt.None
    );
    return i.length > 0 ? this._engine.getPartColor(i, e) : Promise.resolve([]);
  }
  _getNodesEffectiveColor(t, e) {
    const i = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      $t.All,
      Vt.None
    );
    return i.length > 0 ? this._engine.getEffectivePartColor(i, e) : Promise.resolve([]);
  }
  /**
   * Gets the color set via [[setNodesFaceColor]] on the faces of a list of leaf nodes.
   * If no color has been explicitly set for a particular node, `null` will appear at the corresponding
   * position in the returned array.
   * <br><br> See also: [[getNodesEffectiveFaceColor]]
   * @param nodeIds IDs of the nodes to be queried
   */
  getNodesFaceColor(t) {
    return this._getNodesColor(t, Yt.Faces);
  }
  /**
   * Gets the color set on the faces of a list of leaf nodes. If no color has been set,
   * the color specified when the model was authored will be returned.
   * @param nodeIds IDs of the nodes to be queried
   */
  getNodesEffectiveFaceColor(t) {
    return this._getNodesEffectiveColor(t, Yt.Faces);
  }
  /**
   * Gets the color set via [[setNodesLineColor]] on the lines of a list of leaf nodes.
   * If no color has been set for a particular node, `null` will appear at the corresponding
   * position in the returned array.
   * @param nodeIds IDs of the nodes to be queried
   */
  getNodesLineColor(t) {
    return this._getNodesColor(t, Yt.Lines);
  }
  /**
   * Gets the color set on the lines of a list of leaf nodes. If no color has been set,
   * the color specified when the model was authored will be returned.
   * @param nodeIds IDs of the nodes to be queried
   */
  getNodesEffectiveLineColor(t) {
    return this._getNodesEffectiveColor(t, Yt.Lines);
  }
  /**
   * Gets a map associating NodeIds to colors that are set on those nodes.
   * Only NodeIds of nodes that have a color set will be included.
   * @param startNodeId The start node to walk when building the color map.
   * @param elementType Returned colors are of this element type.
   */
  async getNodeColorMap(t, e) {
    const i = this._modelStructure.lookupAnyTreeNode(t);
    if (i !== null)
      return db(i, this._engine, e);
    throw new Ds(t);
  }
  /**
   * Gets the opacity set via [[setNodesOpacity]] on a list of leaf nodes.
   * If no value has been set for a particular node, `null` will appear at the corresponding
   * position in the returned array.
   * @param nodeIds IDs of the nodes to be queried
   */
  getNodesOpacity(t) {
    return Promise.resolve(this._getNodesOpacity(t));
  }
  _getNodesOpacity(t) {
    const e = this._getInstanceIncsFromLeafNodes(t);
    return e.length > 0 ? this._engine.getPartOpacity(e) : [];
  }
  /**
   * Gets the opacity set on a list of leaf nodes multiplied by the opacity
   * specified when the model was authored. If no opacity has been set,
   * the opacity specified when the model was authored will be returned directly.
   * @param nodeIds IDs of the nodes to be queried
   * @param elementType the type of element (faces, lines or points) to query
   */
  getNodesEffectiveOpacity(t, e) {
    const i = this._getInstanceIncsFromLeafNodes(t);
    return i && i.length > 0 ? this._engine.getEffectivePartOpacity(i, e) : Promise.resolve([]);
  }
  async _getNodeElementColor(t, e, i) {
    const n = this._getInstanceIncFromSingleLeafNode(t), [r] = await this._engine.getElementColor(n, e, i);
    return r;
  }
  async _getNodeEffectiveElementColor(t, e, i, n) {
    const r = n !== void 0 ? n.id : Me.Default, o = this._getInstanceIncFromSingleLeafNode(t), [l] = await this._engine.getEffectiveElementColor(
      o,
      e,
      i,
      r
    );
    return l;
  }
  /**
   * Gets the color set via [[setNodeFaceColor]] on a face element.
   * If no color has been set, `null` will be returned.
   * <br><br> See also: [[getNodeEffectiveFaceColor]]
   * @param nodeId the ID of the node containing the face
   * @param faceIndex the index of the face in the node
   */
  getNodeFaceColor(t, e) {
    return this._getNodeElementColor(t, Yt.Faces, e);
  }
  /**
   * Gets the color set via [[setNodeFaceColor]] on a face element. If no color has been set,
   * the node's face color will be returned. If the node's face color has not been set,
   * the color specified when the model was authored will be returned.
   * @param nodeId the ID of the node containing the face
   * @param faceIndex the index of the face in the node
   * @param view the View to use when calculating view effects
   */
  getNodeEffectiveFaceColor(t, e, i) {
    return this._getNodeEffectiveElementColor(t, Yt.Faces, e, i);
  }
  /**
   * Gets the color set via [[setNodeLineColor]] on a line element.
   * If no color has been set, `null` will be returned.
   * @param nodeId the ID of the node containing the line
   * @param lineIndex the index of the line in the node
   */
  getNodeLineColor(t, e) {
    return this._getNodeElementColor(t, Yt.Lines, e);
  }
  /**
   * Gets the color set via [[setNodeLineColor]] on a line element. If no color has been set,
   * the node's line color will be returned. If the node's line color has not been set,
   * the color specified when the model was authored will be returned.
   * @param nodeId the ID of the node containing the line
   * @param lineIndex the index of the line in the node
   * @param view the View to use when calculating view effects
   */
  getNodeEffectiveLineColor(t, e, i) {
    return this._getNodeEffectiveElementColor(t, Yt.Lines, e, i);
  }
  /**
   * Returns "Out Of Hierarchy" status for child node for the given Id.
   * @param id Node id to get children of
   * @returns false if node is Out Of Hierarchy, true if it is
   */
  getOutOfHierarchy(t) {
    return this._modelStructure.isOutOfHierarchy(t);
  }
  /**
   * Returns the absolute root node of the assembly tree.
   * @returns Id for the model tree root node or null if the model structure is not loaded.
   */
  getAbsoluteRootNode() {
    return this._modelStructure.getAbsoluteRootNodeId();
  }
  /**
   * Returns IDs for child nodes for the given Id.
   * @param id Node id to get children of
   * @param includeOutOfHierarchy true to include Out Of Hierarchy node, false or null to exclude them
   * @returns ID for the children of this node, or null if the ID is invalid
   */
  getNodeChildren(t, e) {
    return this._modelStructure.getChildIds(t, e || !1);
  }
  /**
   * Returns IDs of nodes who instance the same part as the supplied node.
   * This method should be called on nodes whose type is `PartInstance`.
   * @param id ID of a `PartInstance` node.
   * @returns Array containing `PartInstance` node IDs. These nodes all instance the same part as the supplied node.  If this method is called on a node which is not of type `PartInstance` then `null` will be returned.
   */
  getNodesInstancingSamePart(t) {
    return this._modelStructure.getPartReferrers(t);
  }
  /**
   * Returns the unit multiplier affecting the supplied node.
   * This number is a multiplier of millimeters (for example inches will be `25.4`).
   * The default value is `1.0`.
   * @returns The unit multiplier for the model (in mm)
   */
  getNodeUnitMultiplier(t) {
    return this._modelStructure.getUnit(t);
  }
  /**
   * Creates a CAD view. This method will trigger a "cadViewCreated" callback if the creation is successful.
   * @param id Node id to attach the created view to
   * @param viewName Name of the view
   * @param camera Camera that will be set when the view gets activated
   * @param pmiIds (optional, if undefined or null no change applied to pmis) Node IDs of the PMI to show for the view others will be hidden
   * @param nodesToShow (optional, pass null or empty array if none to send) Node IDs of the elements to force visibility on
   * @param nodesToHide (optional, pass null or empty array if none to send) Node IDs of the elements to force visibility off
   * @param nodeIdsAndLocalTransforms (optional, pass null or empty array if none to send) array of node ID and matrix pair, defining specific local transform to apply
   * @param cuttingPlane (optional, pass null if none to send) Cutting plane to set when the view gets activated. Distance of the planes must be in the same unit as the model.
   * @param meshInstanceData (optional, pass null if none to send) object that specifies the data for the mesh instance of the rectangular frame (mostly found on capture views)
   * @returns id of the view, null is returned if the function fails
   */
  createCadView(t, e, i, n, r, o, l, h, u) {
    n === void 0 && (n = null), r || (r = []), o || (o = []), l || (l = []), h === void 0 && (h = null), u === void 0 && (u = null);
    const d = this._modelStructure.createCadView(
      t,
      e,
      i,
      n,
      r,
      o,
      l,
      h,
      u
    );
    return d !== null && this._callbackManager.trigger("cadViewCreated", d, e), d;
  }
  /**
   * Gets CAD View information for this model.
   * @returns a map mapping associating CAD View ID to name
   */
  getCadViewMap() {
    return this._modelStructure.getCadViewMap();
  }
  /**
   * Activates a CAD View
   * @param id ID of the CAD View to activate.
   * @param duration camera transition time in milliseconds.
   * @param massageCamera If true, undesirable authored cameras may be modified into a camera with more reasonable values
   * @param view View to activate the CAD View in. Visibility will be applied to all views. Uses default view if not specified.
   * @returns None.
   */
  activateCadView(t, e = rs, i = !0, n = this._defaultView) {
    return this.resetModelOpacity(), this._modelStructure.activateCadView(n, t, e, i);
  }
  /**
   * Get PMI IDs for a CAD View
   * @param id ID of the CAD View
   * @returns IDs of visible PMIs for the view
   */
  getCadViewPmis(t) {
    return this._modelStructure.getCadViewPmis(t);
  }
  /**
   * Gets whether or not cad configurations are enabled
   * @returns Boolean indicating whether or not cad configurations are enabled
   */
  cadConfigurationsEnabled() {
    return this._modelStructure.cadConfigurationsEnabled();
  }
  /**
   * Gets CAD configurations
   * @returns an object mapping CAD configuration ID to config name
   */
  getCadConfigurations() {
    return this._modelStructure.getCadConfigurations();
  }
  /**
   * Gets CAD default configuration
   * @returns ID of default CAD Configuration
   */
  getDefaultCadConfiguration() {
    return this._modelStructure.getDefaultCadConfiguration();
  }
  /**
   * Gets CAD default view
   * @returns ID of default CAD Configuration
   */
  getDefaultCadView() {
    return this._modelStructure.getDefaultCadView();
  }
  /**
   * Activate the default CAD view
   * @param duration Duration of the camera animation
   * @param massageCamera If true, undesirable authored cameras may be modified into a camera with more reasonable values
   * @param view View to set the CAD View in. Visibility will be applied to all views. Uses default view if not specified.
   * @returns None.
   */
  activateDefaultCadView(t = rs, e = !0, i = this._defaultView) {
    return this._modelStructure.activateDefaultCadView(i, t, e);
  }
  /**
   * Gets Active CAD configuration
   * @returns ID of activated CAD Configuration
   */
  getActiveCadConfiguration() {
    return this._modelStructure.getActiveCadConfiguration();
  }
  /**
   * Get the configuration in which the view is defined
   * @returns ID of CAD Configuration of the view
   */
  getCadViewConfiguration(t) {
    return this._modelStructure.getCadViewConfiguration(t);
  }
  /**
   * Activates a CAD configuration
   * @param id ID of the CAD Configuration to activate
   * @param view View to set the CAD Configuration in. Visibility will be applied to all views. Uses default view if not specified.
   * @returns None.
   */
  activateCadConfiguration(t, e = this._defaultView) {
    return this._modelStructure.activateCadConfiguration(e, t, !0);
  }
  /**
   * Activates Default CAD configuration
   * @param fitNodes Fit view to visible nodes if possible (default true)
   * @param view View to set the CAD Configuration in. Visibility will be applied to all views. Uses default view if not specified.
   * @returns None.
   */
  activateDefaultCadConfiguration(t = !0, e = this._defaultView) {
    return this._modelStructure.activateDefaultCadConfiguration(e, t);
  }
  /**
   * Returns point attributes for a node of the given node and point.
   * @param nodeId Node to retrieve point properties from
   * @param pointIndex Index of point for which to retrieve point attributes
   * @returns Promise for the requested point attributes. Properties returned will be null if none associated with the point.
   */
  getPointAttributes(t, e) {
    return this._modelStructure.getPointAttributes(t, e);
  }
  /**
   * Returns edge count for a node of the given node.
   * @param nodeId Node to retrieve edge count from
   * @returns Promise providing the number of edges
   */
  getEdgeCount(t) {
    return this._modelStructure.getEdgeCount(t);
  }
  /**
   * Returns edge attributes for a node of the given node and edge.
   * @param nodeId Node to retrieve edge properties from
   * @param edgeIndex Index of edge for which to retrieve edge attributes
   * @returns Promise for the requested edge attributes. Properties returned will be null if none associated with the edge.
   */
  getEdgeAttributes(t, e) {
    return this._modelStructure.getEdgeAttributes(t, e);
  }
  /**
   * Returns edge properties for a node of the given node and edge.
   * @param nodeId Node to retrieve edge properties from
   * @param edgeid ID of edge for which to retrieve edge properties
   * @returns Promise for the requested edge properties. Properties returned will be null if none associated with the edge.
   */
  getEdgeProperty(t, e) {
    return this._modelStructure.getEdgeProperty(t, e);
  }
  /**
   * Returns face count for a node of the given node and face.
   * @param nodeId Node to retrieve face count from
   * @returns Promise providing the number of faces
   */
  getFaceCount(t) {
    return this._modelStructure.getFaceCount(t);
  }
  /**
   * Returns face attributes for a node of the given node and face.
   * @param nodeId Node to retrieve edge properties from
   * @param faceIndex Index of face for which to retrieve face attributes
   * @returns Promise for the requested face attributes. Properties returned will be null if none associated with the edge.
   */
  getFaceAttributes(t, e) {
    return this._modelStructure.getFaceAttributes(t, e);
  }
  /**
   * Returns Face properties for a node of the given node and face.
   * @param nodeId Node to retrieve face properties from
   * @param faceid ID of face for which to retrieve face properties
   * @returns Promise for the requested face properties. Properties returned will be null if none associated with the face.
   */
  getFaceProperty(t, e) {
    return this._modelStructure.getFaceProperty(t, e);
  }
  /**
   * Set edge property for a node of the given node and edge.
   * @param id Node to set edge properties to
   * @param edgeid ID of edge
   * @param prop property (CircleElement, LineElement...)
   */
  setEdgeProperty(t, e, i) {
    this._modelStructure.setEdgeProperty(t, e, i);
  }
  /**
   * Set face property for a node of the given node and face.
   * @param id Node to set edge properties to
   * @param faceid ID of face
   * @param prop property (CylinderElement, PlaneElement...)
   */
  setFaceProperty(t, e, i) {
    this._modelStructure.setFaceProperty(t, e, i);
  }
  /**
   * Fetch the mesh data for a particular node
   * @param nodeId the node's ID
   */
  async getNodeMeshData(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      [t],
      $t.All,
      Vt.None
    );
    if (e.length === 0)
      throw new oe("Node does not refer to a mesh instance");
    if (e.length > 2)
      throw new oe("Node refers to multiple mesh instances");
    const i = e, n = await this._engine.getInstancesMeshData(i);
    if (n[1] === Sc.Invalid)
      throw new oe("Node has instance, but no mesh data");
    return this._engine.getMeshData(n);
  }
  /**
   * Fetch the mesh data for any capping geometry on a particular node
   * @param nodeIds the node IDs to get capping data from.
   */
  async getNodeCappingMeshData(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      [t],
      $t.All,
      Vt.None
    );
    if (e.length === 0)
      throw new oe("Node does not refer to a mesh instance");
    if (e.length > 2)
      throw new oe("Node refers to multiple mesh instances");
    const i = e, n = await this._engine.getInstancesCappingMeshData(i);
    return n[1] === Sc.Invalid ? null : this._engine.getMeshData(n);
  }
  /**
   * Fetch the mesh data for any capping geometry on a list of nodes and their children
   * @param nodeIds the node IDs to get capping data from.
   */
  async getNodesCappingMeshData(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      $t.All,
      Vt.None
    ), i = await this._engine.getInstancesCappingMeshData(e), n = [];
    for (let r = 1; r < i.length; r += 2)
      if (i[r] !== Sc.Invalid) {
        const o = [i[r - 1], i[r]], l = await this._engine.getMeshData(o);
        n.push(l);
      }
    return n;
  }
  /**
   * Returns a copy of the Matrix for a node of the given ID
   * @param id Node to retrieve matrix from
   * @returns Copy of the Matrix of the node
   */
  getNodeMatrix(t) {
    return this._modelStructure.getMatrix(t);
  }
  /**
   * Sets Matrix for a node of the given ID
   * @param id Node to set matrix on
   * @param Matrix of the Node
   * @param setAsInitial tells if you want to change the node initial matrix or not
   */
  setNodeMatrix(t, e, i = !1) {
    return this._modelStructure.setMatrix(t, e, i);
  }
  /**
   * Used by Animation system to efficiently update the matrix of many nodes at once.
   * Currently not part of public API due to difference in signature with other bulk operations which use Map based parameter.
   * @hidden
   */
  _setNodesMatrices(t, e, i = !1) {
    return this._modelStructure.setMatrices(t, e, i);
  }
  /**
   * Reset node matrix to the one set as the initial one
   * @param id Node to set matrix on
   */
  resetNodeMatrixToInitial(t) {
    return this._modelStructure.resetToInitialMatrix(t);
  }
  /**
   * Returns net matrix for a node of the given ID
   * @param id Node to retrieve net matrix from
   * @returns Net Matrix of the Node
   */
  getNodeNetMatrix(t) {
    return mt.createFromArray(this._modelStructure.getNetMatrix(t));
  }
  /**
   * Returns the parent Id for the given node id.
   * @param id node id to get the parent of
   * @returns ID of the parent node for the supplied ID. If the ID is invalid or the root ID, null is returned.
   */
  getNodeParent(t) {
    return this._modelStructure.getParentId(t);
  }
  /**
   * Returns the type of the node with the given ID.
   * @param id The ID of the node to get the type for.
   * @returns The type of the node.
   */
  getNodeType(t) {
    return this._modelStructure.getType(t);
  }
  /**
   * Returns the properties for the given node ID.
   * @param id Node ID to get the parent of
   * @param computeFromChildren If true physical properties will be computed from child nodes.
   * @returns object properties for the supplied ID, or null if the ID was invalid
   */
  getNodeProperties(t, e = !0) {
    return this._modelStructure.getProperties(t, e);
  }
  /**
   * Purpose: Adds a property to the node
   * @Param nodeId node id to set the property on
   * @Param property name
   * @Param property value
   * @returns true if all went right, false otherwise
   */
  addPropertyToNode(t, e, i, n) {
    return this._modelStructure.addProperty(t, e, i, n);
  }
  /**
   * Purpose: Sets physical properties
   * @Param nodeId node id to set the property on, the node id has to be a body node
   * @Param gravityCenter gravity center in local coordinates
   * @Param surfaceArea surface area, in squared current unit
   * @Param volume volume, in cubed current unit
   * @returns true if all went right, false otherwise
   */
  setPhysicalProperties(t, e, i, n) {
    return this._modelStructure.setPhysicalProperties(t, e, i, n);
  }
  /**
   * Specifies nodes for the system to load. This method is useful when the viewer was created with the <code>streamOnDemand</code> option set to true.
   * @param nodeIds array of unique IDs for the system to load
   */
  requestNodes(t) {
    return this._modelStructure.requestNodes(t);
  }
  /**
   * Returns the name for a node in the assembly tree.
   * @param nodeId The node ID to get the name of.
   * @returns The name of the node with the given nodeId or null if no name is found.
   */
  getNodeName(t) {
    return this._modelStructure.getName(t) || null;
  }
  /**
   * Returns the Exchange ID of a node in the assembly tree.
   * @param nodeId The node ID to get the Exchange ID from.
   * @returns The Exchange ID of the node with the given nodeId or null if no Exchange ID is found.
   */
  getNodeExchangeId(t) {
    return this._modelStructure.getNodeExchangeId(t);
  }
  /**
   * Returns names and ids of all filters available in the scene
   * @returns a map associating Filter IDs to filter names
   */
  getFilters() {
    return this._modelStructure.getFilters();
  }
  /**
   * @returns The name of a filter for the given filter ID index or null if filter was not found
   */
  getFilterName(t) {
    return this._modelStructure.getFilterName(t);
  }
  /**
   * @param nodeId The ID of the node to query.
   * @returns Filters which retain or remove the given node.
   */
  getFiltersWithNode(t) {
    return this._modelStructure.getFiltersWithNode(t);
  }
  /**
   * @param filtersId array of filters indexes to take in account
   * @returns nodesId of nodes retained by the given filter indices and the type of filter (inclusive or not). Returns null if no filter is found.
   */
  getNodesFromFiltersId(t) {
    return this._modelStructure.getNodesFromFilterIds(t);
  }
  /**
   * Returns names and ids of all layers available in the scene
   * @returns a map associating Layer IDs to Layer names
   */
  getLayers() {
    return this._modelStructure.getLayers();
  }
  /**
   * Return names of layers. Different layers can have the same name. Some layers can be unnamed.
   * @returns Names of layers
   */
  getUniqueLayerNames() {
    return this._modelStructure.getUniqueLayerNames();
  }
  /**
   * @returns The name of a layer for the given filter ID or null if layer was not found
   */
  getLayerName(t) {
    return this._modelStructure.getLayerName(t);
  }
  /**
   * @returns Id of layers for the given filter name or null if no layers are found
   */
  getLayerIdsFromName(t) {
    return this._modelStructure.getLayerIdsFromName(t);
  }
  /**
   * Returns the layer ID of a node in the assembly tree.
   * @param nodeId The node ID to get the Exchange ID from.
   * @returns The layer ID of the node with the given nodeId or null if no layer is found.
   */
  getNodeLayerId(t) {
    return this._modelStructure.getNodeLayerId(t);
  }
  /**
   * Returns IDs of nodes in the given layer.
   * @param layerId The layer ID to get nodes from.
   * @param onlyTreeNodes if true return only nodes present in model Tree
   * @returns An array of nodes Id of nodes with the given layerId or null if no layers are found.
   */
  getNodesFromLayer(t, e) {
    return this._modelStructure.getRuntimeNodesFromLayer(t, e);
  }
  /**
   * Returns IDs of nodes in given layers.
   * @param layersId Array of layers Id to get nodes from.
   * @param onlyTreeNodes if true return only nodes present in model Tree
   * @returns An array of nodes Id of nodes with one of the given layerId or null if no layers are found.
   */
  getNodesFromLayers(t, e) {
    return this._modelStructure.getRuntimeNodesFromLayers(t, e);
  }
  /**
   * Returns IDs of nodes in the given layer.
   * @param layer name the name of layer to get nodes from.
   * @param onlyTreeNodes if true return only nodes present in model Tree
   * @returns An array of nodes Id of nodes with the given layerName or null if no layers are found.
   */
  getNodesFromLayerName(t, e) {
    return this._modelStructure.getRuntimeNodesFromLayerName(t, e);
  }
  /**
   * Returns the current visibility for a node.
   * @param nodeId ID of the node to get visibility for.
   * @returns true if the current node's visibility state is on or false if it is not.
   */
  getNodeVisibility(t) {
    return this._modelStructure.isVisible(t);
  }
  /**
   * Branch visibility indicates the visibility state for all of a node's children.
   * @param nodeId ID of the node at the root of the branch.
   * @returns Shown/Hidden if all children have the same visibility state, Mixed otherwise.
   */
  getBranchVisibility(t) {
    const e = this._modelStructure.getBranchVisibility(t);
    return e === de.Shown ? de.Shown : e === de.Hidden ? de.Hidden : (console.assert(e === de.Mixed), de.Mixed);
  }
  /**
   * Returns a data object. During the authoring phase, a user can store general data within a model. (This is how
   * properties are stored, for example.) This function allows you to retrieve the data from the client application.
   *
   * @see {@link https://docs.techsoft3d.com/communicator/latest/api_ref/data_import/libsc/classSC_1_1Store_1_1Model.html#_CPPv4N2SC5Store5Model6InsertE8uint32_tPK7uint8_t8uint32_t Model::Insert}
   *
   * @param an Array of ModelKey-DataKey pairs ([ModelKey, DataKey, ModelKey, DataKey, ModelKey, DataKey...]
   * @returns promise that resolves when this operation has completed returning an array of 8bits int arrays for each ModelKey-DataKey pairs
   */
  getDataFromIds(t) {
    return this._engine.getDataFromIds(t);
  }
  /**
   * @param meshData [[MeshData]] object containing data to insert into the scene.
   * @returns Promise that resolves with a [[MeshId]] when the mesh has been created. The [[MeshId]] can be used to create instances of the mesh using [[createMeshInstance]].
   */
  async createMesh(t, e) {
    const i = await this._engine.createMesh(t);
    return e && e.doNotDelete && this._preventMeshDeletion(i), i;
  }
  static _flatArrayToPairArray(t) {
    const e = [];
    for (let i = 0; i < t.length; i += 2)
      e.push([t[i], t[i + 1]]);
    return e;
  }
  static _pairArrayToFlatArray(t) {
    const e = [];
    for (const i of t)
      e.push(i[0], i[1]);
    return e;
  }
  /**
   * Retrieve the [[MeshId]] associated with the mesh data attached to the given nodes.
   */
  async getMeshIds(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      $t.All,
      Vt.None
    ), i = await this._engine.getInstancesMeshData(e);
    return Nc._flatArrayToPairArray(i);
  }
  /**
   * Replace a mesh's data. This will affect all instances of that mesh.
   * @param key the [[MeshId]] identifying the mesh
   * @param data the new data
   */
  replaceMesh(t, e) {
    return this._engine.replaceMesh(t, e);
  }
  /**
   * Creates an instance of a mesh that has been created using [[createMesh]] or retrieved using [[getMeshIds]].
   * @param data object that specifies the data for this mesh instance
   * @param parentNodeId the ID of the desired parent node
   * @param preventFromResetting if set to true, then the visibility and positioning won't be reset when resetxxx() functions gets called.
   * @param isOutOfHierarchy True if the node created shouldn't appear in the model structure.
   * @returns Promise that resolves with a node ID that can be used to perform operations on this instance.
   */
  createMeshInstance(t, e, i, n) {
    return e === void 0 && (e = null), i || (i = !1), n || (n = !1), this._createMeshInstance(t, e, i, n);
  }
  async _createMeshInstance(t, e, i, n) {
    const r = t.getMatrix(), o = r !== null || e !== null;
    let l = t.getCreationFlags();
    i && (l |= ee.DoNotReset), console.assert(
      !e || !n,
      "Out of hierarchy instances should not have a parent node."
    );
    const h = e === null || this.getNodeVisibility(e);
    let u = t;
    (o || !h) && (u = t.copy(), u.setCreationFlags(l | ee.Invisible));
    const d = await this._engine.createMeshInstance(u), g = this._modelStructure.createMeshInstance(
      d[0],
      d[1],
      t.getInstanceName(),
      e,
      i,
      n,
      !1
    );
    if (o || !h) {
      const x = r || new mt();
      await this.setNodeMatrix(g, x, !0), !(l & ee.Invisible) && h && this._engine.setPartVisibility(d, !0, !0);
    }
    let y = h;
    l & ee.Invisible && (y = !1);
    const m = this._modelStructure.lookupAnyTreeNode(g);
    return m !== null && m.setVisibility(y), e !== null && await this._callbackManager.promiseTrigger(
      "_subtreeLoaded",
      "subtreeLoaded",
      [g],
      ho.CreateInstance
    ), g;
  }
  /**
   * Creates a PMI Instance from a mesh that has been created using the createMesh method.
   * @param data object that specifies the data for the PMI graphic representation
   * @param pmiType see PmiType enum (Datum, Gdt, Dimension...)
   * @param pmiSubType see PmiSubType enum (DatumTarget, GdtFcf, DimensionDistance...)
   * @param refOnTopoItems see RefOnTopoItem. It defines the PMI links to a body element, like a face or an edge
   * @param parentNodeId the ID of the desired parent node
   * @returns Promise that resolves with a node ID that can be used to perform operations on this instance. You can use deleteMeshInstances() to delete the PMI
   */
  async createPmiInstance(t, e, i, n, r) {
    r === void 0 && (r = null);
    const o = [];
    for (const u of n) {
      const d = this._modelStructure.lookupBodyInstance(u.bodyId);
      if (d === null)
        throw new Ds(u.bodyId);
      const g = wl.fromBodyInstance(
        d,
        u.subElementType,
        u.subElementIndex
      );
      o.push(g);
    }
    const l = await this._engine.createMeshInstance(t), h = this._modelStructure.createPmiInstance(
      l[0],
      l[1],
      e,
      i,
      o,
      t.getInstanceName(),
      r
    );
    return r !== null && await this._callbackManager.promiseTrigger(
      "_subtreeLoaded",
      "subtreeLoaded",
      [h],
      ho.CreatePmi
    ), h;
  }
  /**
   * Creates an image that can be applied as a texture via [[setNodesTexture]].
   * See [[deleteImages]].
   * @param primaryImage The image data and associated options
   * @param thumbnailImage If specified, an uncompressed image that will be used as a
   *                       placeholder for the primary image until it is fully loaded.
   *                       Only useful when `primaryImage` is a compressed image.
   */
  createImage(t, e) {
    return this._engine.createImage(t, e);
  }
  /**
   * Deletes images created with [[createImage]].
   * @param imageIds The IDs of the images to be deleted
   */
  deleteImages(t) {
    return this._engine.destroyImages(Nc._pairArrayToFlatArray(t));
  }
  /**
   * Apply an image to a node as a texture map. See [[createImage]] and [[unsetNodesTexture]].
   * @param nodeIds The nodes on which to apply the texture
   * @param options Options specifying how the texture is applied
   */
  setNodesTexture(t, e) {
    const i = this._getInstanceIncsFromLeafNodes(t);
    return this._engine.setTexture(i, e);
  }
  /**
   * Remove one or more textures applied via [[setNodesTexture]].
   * @param nodeIds The nodes from which to remove the texture or textures
   */
  unsetNodesTexture(t) {
    const e = this._getInstanceIncsFromLeafNodes(t);
    this._engine.unsetTexture(e);
  }
  /**
   * Deletes meshes that have been created at run time.
   *
   * In order for this method to succeed, all mesh instances created for the given IDs
   * must have also been destroyed with [[deleteMeshInstances]].
   *
   * @param meshIds The IDs of meshes that should be deleted
   * @returns Promise that resolves when this operation has completed.
   */
  deleteMeshes(t) {
    return this._engine.destroyMeshes(Nc._pairArrayToFlatArray(t));
  }
  /**
   * Deletes mesh instances that have been created at run time
   * @param nodeIds array of IDs for mesh instances created at run time that should be destroyed
   * @returns Promise that resolves when this operation has completed.
   */
  deleteMeshInstances(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      $t.All,
      Vt.None
    ), i = [];
    if (e.length > 0) {
      for (const n of t)
        i.push(this._modelStructure.deleteNode(n));
      i.push(this._engine.destroyLocalInstances(e));
    }
    return Ge(i);
  }
  _obtainLoadSubtreeConfig(t) {
    if (t[0] instanceof Ma)
      return t[0].copy();
    {
      const e = new Ma();
      return e.additionalMatrix = t[0] || null, e.allowMissingExternalModels = !!t[1], e.copy();
    }
  }
  loadSubtreeFromXmlFile(t, e, i, ...n) {
    const r = this._obtainLoadSubtreeConfig(n);
    return i || (i = yu), this._modelStructure.loadSubtreeFromXmlFile(
      t,
      e,
      i,
      r
    );
  }
  loadSubtreeFromXmlBuffer(t, e, i, ...n) {
    const r = this._obtainLoadSubtreeConfig(n);
    return i || (i = yu), this._modelStructure.loadSubtreeFromXmlDoc(t, e, i, r);
  }
  loadSubtreeFromScsXmlFile(t, e, i, ...n) {
    const r = this._obtainLoadSubtreeConfig(n);
    return i || (i = yu), this._modelStructure.loadSubtreeFromScsXmlFile(
      t,
      e,
      i,
      r
    );
  }
  loadSubtreeFromScsXmlBuffer(t, e, i, ...n) {
    const r = this._obtainLoadSubtreeConfig(n);
    return i || (i = yu), this._modelStructure.loadSubtreeFromScsXmlDoc(t, e, i, r);
  }
  loadSubtreeFromModel(t, e, ...i) {
    const n = this._obtainLoadSubtreeConfig(i);
    return this._modelStructure.loadSubtreeFromStream(t, e, n);
  }
  loadSubtreeFromScsFile(t, e, ...i) {
    const n = this._obtainLoadSubtreeConfig(i);
    return this._modelStructure.loadSubtreeFromScsFile(t, e, n);
  }
  loadSubtreeFromScsBuffer(t, e, ...i) {
    const n = this._obtainLoadSubtreeConfig(i);
    return this._modelStructure.loadSubtreeFromScsBuffer(t, e, n);
  }
  /**
   * Loads measurement data from a JSON object
   * @param json JSON object containing measurement data
   */
  loadMeasurementFromJson(t) {
    return this._modelStructure.loadMeasurementFromJson(t);
  }
  /**
   * Loads measurement data from a JSON string
   * @param str JSON string containing measurement data
   */
  loadMeasurementFromString(t) {
    return this._modelStructure.loadMeasurementFromString(t);
  }
  /**
   * Loads measurement data from a ZIP file
   * @param filename Name of a file containing ZIP measurement data
   */
  loadMeasurementFromFile(t) {
    return this._modelStructure.loadMeasurementFromFile(t);
  }
  /**
   * Delete all the current scene and load the specified model instead. Also triggers a "modelSwitched" when finished.
   * @param newModelFilename Name of the model file to load after the existing scene gets deleted
   * @returns A `Promise` of the newly loaded model's root nodes IDs.
   */
  switchToModel(t) {
    return this._callbackManager.trigger("modelLoadBegin"), this._modelStructure.switchToModel(t);
  }
  /**
   * Creates a node
   * @param parentNodeId ID of the node to link the child node to. This ID should not have a type of Body or BodyInstance. If this parameter is `undefined`, the child node will be linked to the root.
   * @param name of the node to create
   * @param nodeID (optional) ID you want the node to have, if not specified the nodeID will be set automatically. Be aware that if the specified node ID is already used by another node, then it will be ignored a new one will be set automatically.
   * @param localMatrix (optional) Initial local matrix of the node (identity if none set)
   * @param visibility (optional) Initial visibility of the node (visible if nothing set)
   * @param measurmentUnit (optional) Specifies optional measurement units for this node. When set to null (the default), the node will inheret the unit setting of the parent node. If set, a scaling matrix will be computed
   *    that scales appropriately based on the unit scaling and applied to the newly created node. If a non-null localMatrix has been specified, that matrix will be combined with the computed scaling matrix.
   * @returns child node ID
   */
  createNode(t, e, i, n, r, o) {
    t === void 0 && (t = null), i === void 0 && (i = null), n === void 0 && (n = null), r == null && (r = !0);
    const l = this._modelStructure.createNode(
      t,
      e,
      i,
      n,
      r,
      o
    );
    return l !== null && this._callbackManager.promiseTrigger(
      "_subtreeLoaded",
      "subtreeLoaded",
      [l],
      ho.CreateNode
    ), l;
  }
  /**
   * Delete a node and all its children
   * @param ID of the node
   */
  async deleteNode(t) {
    const e = this._modelStructure.gatherInclusionKeysFromNodeIds([t]);
    await this._modelStructure.deleteNode(t), await this._engine.detachInclusions(e), this._callbackManager.trigger("subtreeDeleted", [t]);
  }
  /**
   * Creates an part node
   * @param nodeID (optional) ID you want the node to have, if not specified the nodeID will be set automatically. Be aware that if the specified node ID is already used by another node, then it will be ignored and new one will be set automatically.
   * @returns a node ID to access the created part node
   */
  createPart(t) {
    return t === void 0 && (t = null), this._modelStructure.createPart(t);
  }
  /**
   * Set a part on an assembly node
   * @param assemblyNodeID ID of the assembly node
   * @param partNodeID ID of the part node
   * @returns true if all went right, false otherwise
   */
  setPart(t, e) {
    return t == null || e == null ? !1 : this._modelStructure.setPart(t, e);
  }
  /**
   * Creates a representation item on a part
   * @param partNodeId ID of the part node
   * @param repItemId (optional) Id you want the node to have, if not specified the nodeId will be set automatically. Be aware that if the specified node Id is already used by another node, then it will be ignored and a new one will be set automatically.
   * @returns node ID to access the created representation item, null is returned if something went wrong
   */
  createAndAddRepresentationItem(t, e) {
    return t == null ? null : (e === void 0 && (e = null), this._modelStructure.createAndAddRepItem(t, e));
  }
  /**
   * Returns the lowest available node ID
   */
  getLowestAvailableNodeId() {
    return this._modelStructure.getLowestAvailableNodeId();
  }
  /**
   * Allows changing the behavior in the viewer
   * @param instanceModifier InstanceModifier
   * @param nodeIds Array of node ids
   * @param value boolean
   */
  setInstanceModifier(t, e, i) {
    return this._setInstanceModifier(t, e, i, $t.All), Promise.resolve();
  }
  /** @hidden */
  _setInstanceModifier(t, e, i, n) {
    const r = this._modelStructure.gatherInstanceIncsFromNodeIds(
      e,
      n,
      Vt.None
    );
    r.length > 0 && this._engine.setInstanceModifier(t, r, i);
  }
  getAssociatedModelKey(t) {
    const e = this._modelStructure.getAssociatedModelKey(t);
    return Promise.resolve(e);
  }
  hasDepthRange(t) {
    const e = this._getInstanceIncsFromLeafNodes(t);
    return this._engine.hasDepthRange(e);
  }
  /**
   * Remaps the depth values used for z-ordering of pixels to the given
   * range, which must be a subset of `[0,1]`. The depth value at the
   * near plane (normally `0`) is mapped to `min` and the value at
   * the far plane (normally `1`) is mapped to `max`.
   *
   * The smaller the range, the more z-fighting you will see among
   * objects set to that range.
   *
   * @param nodeIds the node IDs to operate on
   * @param min the depth value at the near plane
   * @param max the depth value at the far plane
   */
  setDepthRange(t, e, i) {
    return this._setDepthRange(t, e, i), Promise.resolve();
  }
  _setDepthRange(t, e, i) {
    const n = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      $t.All,
      Vt.None
    );
    this._engine.setDepthRange(n, e, i);
  }
  /**
   * Unsets the depth range set by [[setDepthRange]].
   * @param nodeIds the node IDs to operate on
   */
  unsetDepthRange(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      $t.All,
      Vt.None
    );
    this._engine.unsetDepthRange(e);
  }
  /** @hidden */
  _gatherInstanceIncsFromNodeIds(t, e = $t.All) {
    return this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      e,
      Vt.None
    );
  }
  _getInstanceIncsFromLeafNodes(t) {
    const e = [];
    for (const i of t) {
      const n = this._modelStructure.gatherInstanceIncsFromNodeIds(
        [i],
        $t.All,
        Vt.None
      );
      if (n.length === 2) {
        const r = n;
        e.push(r[0], r[1]);
      } else
        throw new oe("Non-leaf node encountered");
    }
    return e;
  }
  _getInstanceIncFromSingleLeafNode(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      [t],
      $t.All,
      Vt.None
    );
    if (e.length === 2)
      return e;
    throw new oe("Non-leaf node encountered");
  }
  /**
   * Sets the desired mesh level
   * @param nodeIds IDs of nodes in the assembly on which mesh level will be set
   * @param meshLevel 0 standard, 1 low, 2 extra low
   * @returns Promise that resolves when the operation has completed.
   */
  setMeshLevel(t, e) {
    return this._modelStructure.setMeshLevel(t, e), Promise.resolve();
  }
  /**
   * Sets the metallic and roughness factors for the supplied nodes materials.
   * Materials that are not currently set to use the Metallic Roughness shading model will be upgraded to use this mode.
   * @param nodeIds List of nodes to set material properties for
   * @param metallicFactor The metalness of the material
   * @param roughnessFactor The roughness of the material
   */
  setMetallicRoughness(t, e, i) {
    const n = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      $t.All,
      Vt.None
    );
    this._engine.setMetallicRoughness(n, e, i);
  }
  /**
   * Gets the metallic and roughness factors for the supplied nodes materials.
   * Materials that are not currently set to use the Metallic Roughness shading model will have a null entry
   * @param nodeIds List of nodes to get material properties for
   */
  getMetallicRoughness(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      $t.All,
      Vt.None
    );
    return this._engine.getMetallicRoughness(e);
  }
  /**
   * Unsets the metallic and roughness values set with [[setMetallicRoughness]]
   * These materials will no longer use the Metallic Roughness shading model.
   * @param nodeIds List of nodes to unset material properties for
   */
  unsetMetallicRoughness(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      $t.All,
      Vt.None
    );
    this._engine.unsetMetallicRoughness(e);
  }
  /**
   * If enabled then models loaded into an existing scene with a different unit value will be scaled to the unit value of the current scene.
   * @param enabled value indicating if automatic unit scaling will be active
   */
  setEnableAutomaticUnitScaling(t) {
    return this._modelStructure.setEnableAutomaticUnitScaling(t);
  }
  /**
   * By default, objects that are initially hidden stays hidden unless specifically set to be shown. This function allows this behavior to be disabled.
   * @param enabled value indicating if initially hidden objects stay hidden
   */
  setBehaviorInitiallyHidden(t) {
    return this._modelStructure.setBehaviorInitiallyHidden(t);
  }
  /**
   * Tells if the model is a CAD drawing or not
   * @returns true if the model is a CAD drawing
   */
  isDrawing() {
    return this._modelStructure.isACadDrawing();
  }
  /**
   * @returns true if the model contains measurement data.
   */
  isMeasurable() {
    return this._modelStructure.isMeasurable();
  }
  /**
   * @param bodyId ID of the body node containing the line
   * @param lineIndex Index of the line ot be checked
   * @returns true if the line has associated measurement data
   */
  isLineMeasurable(t, e) {
    return this._modelStructure.isLineMeasurable(t, e);
  }
  isFaceMeasurable(t, e) {
    return this._modelStructure.isFaceMeasurable(t, e);
  }
  /**
   * @returns the original file name of the model which contain the given node or null if the node is not found.
   */
  getModelFileNameFromNode(t) {
    return this._modelStructure.getModelFileNameFromNode(t);
  }
  /**
   * @returns the original file type of the model which contain the given node or null if the node is not found.
   */
  getModelFileTypeFromNode(t) {
    return this._modelStructure.getModelFileTypeFromNode(t);
  }
  /**
   * @returns the generic type of the given node or null if the node is not found.
   */
  getNodeGenericType(t) {
    return this._modelStructure.getNodeGenericType(t);
  }
  /**
   * @returns the generic id of the given node or null if the node is not found.
   */
  getNodeGenericId(t) {
    return this._modelStructure.getNodeGenericId(t);
  }
  /**
   * This function recursively discovers BIM nodes in the supplied subtree and registers them.
   * @param startNodeId The root of the subtree to walk for registration.
   * @param attributeToMask The callback used to obtain a node's [[BimMask]] from its attributes.
   * @returns Promise that resolves when the operation has completed.
   */
  async registerBimNodes(t, e, i = null) {
    const n = this._modelStructure.lookupAnyTreeNode(t);
    if (n !== null)
      return typeof i == "boolean" && (i = i ? "TYPE" : null), ub(
        e,
        this._engine,
        this._modelStructure,
        n,
        i
      );
  }
  /**
   * Gets all generic types and NodeIds with that type.
   * @returns Map containing generic types and NodeIds
   */
  getGenericTypeIdMap() {
    return this._modelStructure.getGenericTypeIdMap();
  }
  /**
   * This function returns all NodeIds with an IFC type.
   * @param genericType
   * @returns All NodeIds with an IFC type
   */
  getNodesByGenericType(t) {
    return this._modelStructure.getNodesByGenericType(t);
  }
  /**
   * This function gets all generic types contained in the model.
   * @returns All generic types.
   */
  getGenericTypes() {
    return this._modelStructure.getGenericTypes();
  }
  /**
   * Checks if a [[NodeId]] is a generic type.
   * @param nodeId
   * @param genericType
   */
  hasEffectiveGenericType(t, e) {
    return this._modelStructure.hasEffectiveGenericType(t, e);
  }
  /**
   * This function recursively discovers IFC nodes in the supplied subtree and registers them.
   * @param startNodeId The root of the subtree to walk for registration.
   * @returns Promise that resolves when the operation has completed.
   */
  registerIfcNodes(t, e = null) {
    return this.registerBimNodes(t, ob, e);
  }
  /**
   * Tells if the view is an annotation view or not
   * @param cadViewNodeId Node ID of the CAD view
   * @returns true if the view is an annotation view
   */
  isAnnotationView(t) {
    return this._modelStructure.isAnnotationView(t);
  }
  /**
   * Tells if the view is a combine state view or not
   * @param cadViewNodeId Node ID of the CAD view
   * @returns true if the view is a combine state view
   */
  isCombineStateView(t) {
    return this._modelStructure.isCombineStateView(t);
  }
  /**
   * Sets a vector and angle used to determine an object's visibility based on camera orientation.
   * @param space The space in which the culling vector is defined.
   * @param vector A vector that will be compared with the view vector.
   * @param toleranceDegrees The maximum angle between the culling vector and the view vector within which the object will be visible.
   */
  setNodesCullingVector(t, e, i, n) {
    return this._setNodesCullingVector(t, e, i, n), Promise.resolve();
  }
  _setNodesCullingVector(t, e, i, n) {
    const r = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      $t.All,
      Vt.None
    );
    return this._engine.setCullingVector(r, e, i, n);
  }
  /**
   * Unsets the vector and angle used to determine an object's visibility based on camera orientation.
   * @param nodeIds The nodes to unset culling vectors on.
   */
  unsetNodesCullingVectors(t) {
    return this._unsetNodesCullingVectors(t), Promise.resolve();
  }
  _unsetNodesCullingVectors(t) {
    const e = this._modelStructure.gatherInstanceIncsFromNodeIds(
      t,
      $t.All,
      Vt.None
    );
    this._engine.unsetCullingVector(e);
  }
  /**
   * Retrieves the vector and angle used to determine an object's visibility based on camera orientation.
   * If unset, `null` will appear at the corresponding array index.
   * @param nodeIds The nodes to query culling vectors from.
   * @returns A promise of culling vectors.
   */
  getNodesCullingVectors(t) {
    const e = this._getInstanceIncsFromLeafNodes(t);
    return this._engine.getCullingVector(e);
  }
  /**
   * Retrieves the node ID offset for a given node.
   * @param nodeId The node to obtain the node ID offset from.
   * @returns The node ID offset for the supplied node.
   */
  getNodeIdOffset(t) {
    return this._modelStructure.getIdOffset(t);
  }
  /**
   * Queries if a node is fully loaded or not.
   * @param nodeId The node to query.
   * @returns True if the node is fully loaded; false otherwise.
   */
  isNodeLoaded(t) {
    return this._modelStructure.isNodeLoaded(t);
  }
  /**
   * Triangulates the supplied polygon.
   * @param polygonPoints An array of point data for the polygon. Points are stored [XYZXYZXYZ...] format.
   * @param normal The normal of the polygon to triangulate.
   * @returns An array containing the point data for the generated triangles. Points are stored [XYZXYZXYZ...] format.
   *          This returned list is always divisible by 9 (3 points per triangle; 3 floats per point).
   */
  triangulatePolygon(t, e) {
    const i = vl(e);
    return this._engine.triangulatePolygon(t, i);
  }
  /**
   * Applies the given line pattern to the specified nodes. See also [[unsetNodesLinePattern]].
   * @param nodeIds The IDs of the nodes.
   * @param pattern The line pattern. See [[LinePattern]] for details.
   * @param patternLength The length of a single repetition of the line pattern.
   * @param patternLengthUnit The unit in which the length of the pattern is measured. See [[LinePatternLengthUnit]] for details.
   */
  setNodesLinePattern(t, e, i, n) {
    const r = this._gatherInstanceIncsFromNodeIds(t);
    this._engine.setLinePattern(r, e, i, n);
  }
  /**
   * Removes the line pattern applied by [[setNodesLinePattern]].
   * @param nodeIds The IDs of the nodes.
   */
  unsetNodesLinePattern(t) {
    const e = this._gatherInstanceIncsFromNodeIds(t);
    this._engine.unsetLinePattern(e);
  }
  /** @hidden */
  async _hwfAwaitAssemblyTreeReady() {
    const t = this.getAbsoluteRootNode(), e = this._modelStructure.lookupAnyTreeNode(t);
    if (e === null)
      throw new oi();
    const i = Js(e);
    await Ln.forceLazyPromises(i), await _a([i]);
  }
  /**
   * Returns all the `UserDataIndex` items associated with the input node.
   * @param nodeId The ID of the node to query.
   * @returns A list of `UserDataIndex`, possibly empty.
   * @throws `InvalidNodeIdError`
   */
  getNodeUserDataIndices(t) {
    return this._modelStructure.getUserDataIndices(t);
  }
  /**
   * Returns the user data for a given node and index.
   * @param nodeId The ID of the node to query.
   * @param index The index of the data.
   * @returns The user data.
   * @throws `InvalidNodeIdError` `InvalidIndexError`
   */
  getNodeUserData(t, e) {
    return this._modelStructure.getUserData(t, e);
  }
  /**
   * Returns a list of node IDs given a list of generic IDs. Note that the
   * returned list of node IDs may be longer than the provided list of generic
   * IDs since one ID can be used by more than one node.
   * @param genericIds Array of generic IDs to find nodes fore
   * @returns Array of node ids corresponding to the provided generic IDs
   */
  getNodeIdsByGenericIds(t) {
    const e = [];
    for (const i of t) {
      const n = this._modelStructure.getNodesByGenericId(i);
      n !== null && n.forEach((r) => {
        e.push(r);
      });
    }
    return e;
  }
  /** @hidden */
  _getModelStructure() {
    return this._modelStructure;
  }
  /**
   * Returns true if the node is within an external model.
   * @param nodeId
   */
  isWithinExternalModel(t) {
    return this._modelStructure.isWithinExternalModel(t);
  }
  /** @hidden */
  _firstAssemblyDataHeader() {
    return this._modelStructure.firstAssemblyDataHeader();
  }
  /**
   * Retrieves the bim id of the corresponding node id.
   * @param node the id of the node for which you want its bim id.
   * @returns the bim id corresponding to the node or null if none.
   */
  getBimIdFromNode(t) {
    return this._modelStructure.getBimIdFromNode(t);
  }
  /**
   * Retrieves the bim ids of the corresponding generic id.
   * @param ifcGuid the generic id for which you want its bim id.
   * @returns the bim id corresponding to the ifcGuid or null if none.
   */
  getBimIdsFromGenericId(t) {
    const e = [], i = this._modelStructure.getNodesByGenericId(t);
    return i !== null && i.forEach((n) => {
      const r = this.getBimIdFromNode(n);
      r !== null && e.push(r);
    }), e;
  }
  /**
   * Retrieves the node id of the corresponding bim id.
   * @param node any known node id of the working model.
   * @param bimID bim id for which you want its node id.
   * @returns the node id corresponding to the BimId or null if none.
   */
  getNodeIdFromBimId(t, e) {
    return this._modelStructure.getRuntimeNodeFromBimId(t, e);
  }
  /**
   * Retrieves the generic id of the corresponding bim id.
   * @param node any known node id of the working model.
   * @param bimId bim id for which you want its generic id.
   * @returns the generic id corresponding to the BimId or null if none.
   */
  getGenericIdFromBimId(t, e) {
    const i = this._modelStructure.getRuntimeNodeFromBimId(t, e);
    return i !== null ? this._modelStructure.getNodeGenericId(i) : null;
  }
  /**
   * Retrieves all type of relationships that a bim id has.
   * @param node any known node id of the working model.
   * @param bimId bim id for which you want its types of relationships.
   * @returns array of type of relationship corresponding to the BimId.
   */
  getRelationshipTypesFromBimId(t, e) {
    const i = [], n = this._modelStructure.getBimIdRelationshipTypes(t, e);
    for (const r of n)
      i.push(r.type);
    return i;
  }
  /**
   * Retrieve all related relationships that a bim id have.
   * @param node any known node id of the working model.
   * @param bimId bim id for which you want its related relationships.
   * @returns array of bim id which are the related relationship of the BimId.
   */
  getBimIdRelatedElements(t, e, i) {
    const n = this._modelStructure.getBimIdRelationshipTypes(t, e);
    for (const r of n)
      if (r.type === i)
        return r.relateds;
    return [];
  }
  /**
   * Retrieve all relating relationships that a bim id have.
   * @param node any known node id of the working model.
   * @param bimId bim id for which you want its relating relationships.
   * @returns array of bim id which are the relating relationship of the BimId.
   */
  getBimIdRelatingElements(t, e, i) {
    const n = this._modelStructure.getBimIdRelationshipTypes(t, e);
    for (const r of n)
      if (r.type === i)
        return r.relatings;
    return [];
  }
  /**
   * Retrieve all relationships that a bim id have, sorted in 2 arrays (relateds and relatings)
   * @param node any known node id of the working model.
   * @param bimId bim id for which you want its relationships.
   * @returns double array of bim id of relationship of the BimId sorted by its relateds and its relatings.
   */
  getBimIdConnectedElements(t, e, i) {
    const n = this._modelStructure.getBimIdRelationshipTypes(t, e);
    for (const r of n)
      if (r.type === i)
        return { relateds: r.relateds, relatings: r.relatings };
    return { relateds: [], relatings: [] };
  }
  /**
   * Retrieve the name of the bim element
   * @param bimId bim id for which you want the bim element name.
   * @param node any known node id of the working model.
   * @returns the name and the info regarding the connection to a node of the bim element.
   */
  getBimInfoFromBimId(t, e) {
    return this._modelStructure.getInfoOfBimId(t, e);
  }
}
var vb = /* @__PURE__ */ ((s) => s)(vb || {}), bb = /* @__PURE__ */ ((s) => s)(bb || {}), ho = /* @__PURE__ */ ((s) => (s[s.LoadModel = 0] = "LoadModel", s[s.CreateNode = 1] = "CreateNode", s[s.CreateInstance = 2] = "CreateInstance", s[s.CreatePmi = 3] = "CreatePmi", s))(ho || {}), xb = /* @__PURE__ */ ((s) => (s[s.Desktop = 0] = "Desktop", s[s.Mobile = 1] = "Mobile", s))(xb || {}), Yt = /* @__PURE__ */ ((s) => (s[s.Faces = 0] = "Faces", s[s.Lines = 1] = "Lines", s[s.Points = 2] = "Points", s))(Yt || {}), ri = /* @__PURE__ */ ((s) => (s[s.Perspective = 0] = "Perspective", s[s.Orthographic = 1] = "Orthographic", s))(ri || {}), Ct = /* @__PURE__ */ ((s) => (s[s.Top = 0] = "Top", s[s.Bottom = 1] = "Bottom", s[s.Left = 2] = "Left", s[s.Right = 3] = "Right", s[s.Front = 4] = "Front", s[s.Back = 5] = "Back", s[s.Iso = 6] = "Iso", s[s.TopRightFront = 7] = "TopRightFront", s[s.TopLeftFront = 8] = "TopLeftFront", s[s.TopLeftBack = 9] = "TopLeftBack", s[s.TopRightBack = 10] = "TopRightBack", s[s.TopBack = 11] = "TopBack", s[s.TopFront = 12] = "TopFront", s[s.TopLeft = 13] = "TopLeft", s[s.TopRight = 14] = "TopRight", s[s.BottomRightBack = 15] = "BottomRightBack", s[s.BottomLeftBack = 16] = "BottomLeftBack", s[s.BottomLeftFront = 17] = "BottomLeftFront", s[s.BottomRightFront = 18] = "BottomRightFront", s[s.BottomFront = 19] = "BottomFront", s[s.BottomBack = 20] = "BottomBack", s[s.BottomLeft = 21] = "BottomLeft", s[s.BottomRight = 22] = "BottomRight", s[s.RightBottomBack = 23] = "RightBottomBack", s[s.RightBottomFront = 24] = "RightBottomFront", s[s.RightTopFront = 25] = "RightTopFront", s[s.RightTopBack = 26] = "RightTopBack", s[s.RightTop = 27] = "RightTop", s[s.RightBottom = 28] = "RightBottom", s[s.RightFront = 29] = "RightFront", s[s.RightBack = 30] = "RightBack", s[s.LeftBottomFront = 31] = "LeftBottomFront", s[s.LeftBottomBack = 32] = "LeftBottomBack", s[s.LeftTopBack = 33] = "LeftTopBack", s[s.LeftTopFront = 34] = "LeftTopFront", s[s.LeftTop = 35] = "LeftTop", s[s.LeftBottom = 36] = "LeftBottom", s[s.LeftBack = 37] = "LeftBack", s[s.LeftFront = 38] = "LeftFront", s[s.FrontBottomRight = 39] = "FrontBottomRight", s[s.FrontTopRight = 40] = "FrontTopRight", s[s.FrontTopLeft = 41] = "FrontTopLeft", s[s.FrontBottomLeft = 42] = "FrontBottomLeft", s[s.FrontRight = 43] = "FrontRight", s[s.FrontLeft = 44] = "FrontLeft", s[s.FrontTop = 45] = "FrontTop", s[s.FrontBottom = 46] = "FrontBottom", s[s.BackTopRight = 47] = "BackTopRight", s[s.BackBottomRight = 48] = "BackBottomRight", s[s.BackBottomLeft = 49] = "BackBottomLeft", s[s.BackTopLeft = 50] = "BackTopLeft", s[s.BackLeft = 51] = "BackLeft", s[s.BackRight = 52] = "BackRight", s[s.BackBottom = 53] = "BackBottom", s[s.BackTop = 54] = "BackTop", s))(Ct || {}), Qe = /* @__PURE__ */ ((s) => (s[s.X = 0] = "X", s[s.Y = 1] = "Y", s[s.Z = 2] = "Z", s))(Qe || {}), Ee = /* @__PURE__ */ ((s) => (s[s.None = -1] = "None", s[s.Left = 0] = "Left", s[s.Middle = 1] = "Middle", s[s.Right = 2] = "Right", s))(Ee || {}), ys = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.Left = 1] = "Left", s[s.Right = 2] = "Right", s[s.Middle = 4] = "Middle", s))(ys || {}), Vr = /* @__PURE__ */ ((s) => (s[s.Axis = 0] = "Axis", s[s.Plane = 1] = "Plane", s[s.ViewPlane = 2] = "ViewPlane", s[s.Rotate = 3] = "Rotate", s))(Vr || {}), So = /* @__PURE__ */ ((s) => (s[s.Translate = 0] = "Translate", s[s.Rotate = 1] = "Rotate", s))(So || {}), ve = /* @__PURE__ */ ((s) => (s[s.Invalid = -1] = "Invalid", s[s.None = 0] = "None", s[s.Navigate = 1] = "Navigate", s[s.Orbit = 2] = "Orbit", s[s.Pan = 3] = "Pan", s[s.Zoom = 4] = "Zoom", s[s.WindowZoom = 5] = "WindowZoom", s[s.Walk = 6] = "Walk", s[s.KeyboardWalk = 7] = "KeyboardWalk", s[s.WalkMode = 8] = "WalkMode", s[s.Turntable = 9] = "Turntable", s[s.Select = 10] = "Select", s[s.AreaSelect = 11] = "AreaSelect", s[s.RayDrillSelect = 12] = "RayDrillSelect", s[s.RedlineCircle = 13] = "RedlineCircle", s[s.RedlineText = 14] = "RedlineText", s[s.RedlineRectangle = 15] = "RedlineRectangle", s[s.RedlinePolyline = 16] = "RedlinePolyline", s[s.MeasureEdgeLength = 17] = "MeasureEdgeLength", s[s.MeasureFaceFaceDistance = 18] = "MeasureFaceFaceDistance", s[s.MeasureLineLineAngle = 19] = "MeasureLineLineAngle", s[s.MeasurePointPointDistance = 20] = "MeasurePointPointDistance", s[s.MeasureBodyBodyDistance = 21] = "MeasureBodyBodyDistance", s[s.MeasureFaceFaceAngle = 22] = "MeasureFaceFaceAngle", s[s.MeasurePolylineDistance = 23] = "MeasurePolylineDistance", s[s.MeasurePolygonArea = 24] = "MeasurePolygonArea", s[s.Note = 25] = "Note", s[s.Cutting = 26] = "Cutting", s[s.Handle = 27] = "Handle", s[s.NavCube = 28] = "NavCube", s[s.AxisTriad = 29] = "AxisTriad", s[s.Floorplan = 30] = "Floorplan", s[s.SpaceMouse = 31] = "SpaceMouse", s))(ve || {}), ae = /* @__PURE__ */ ((s) => (s[s.MouseDown = 0] = "MouseDown", s[s.MouseMove = 1] = "MouseMove", s[s.MouseUp = 2] = "MouseUp", s[s.Mousewheel = 3] = "Mousewheel", s[s.TouchStart = 4] = "TouchStart", s[s.TouchMove = 5] = "TouchMove", s[s.TouchEnd = 6] = "TouchEnd", s[s.KeyDown = 7] = "KeyDown", s[s.KeyUp = 8] = "KeyUp", s[s.ViewOrientationChange = 9] = "ViewOrientationChange", s))(ae || {}), Ci = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.Shift = 2] = "Shift", s[s.Alt = 4] = "Alt", s[s.Control = 8] = "Control", s[s.Command = 16] = "Command", s))(Ci || {}), mr = /* @__PURE__ */ ((s) => (s[s.Down = 0] = "Down", s[s.Up = 1] = "Up", s[s.Move = 2] = "Move", s[s.Wheel = 3] = "Wheel", s))(mr || {}), Eu = /* @__PURE__ */ ((s) => (s[s.Start = 0] = "Start", s[s.Move = 1] = "Move", s[s.End = 2] = "End", s))(Eu || {}), Df = /* @__PURE__ */ ((s) => (s[s.Down = 0] = "Down", s[s.Up = 1] = "Up", s))(Df || {}), Re = /* @__PURE__ */ ((s) => (s[s.Forward = 0] = "Forward", s[s.Backward = 1] = "Backward", s[s.Left = 2] = "Left", s[s.Right = 3] = "Right", s[s.Up = 4] = "Up", s[s.Down = 5] = "Down", s[s.RotateRight = 6] = "RotateRight", s[s.RotateLeft = 7] = "RotateLeft", s[s.TiltUp = 8] = "TiltUp", s[s.TiltDown = 9] = "TiltDown", s))(Re || {}), ti = /* @__PURE__ */ ((s) => (s[s.Backspace = 8] = "Backspace", s[s.Shift = 16] = "Shift", s[s.Escape = 27] = "Escape", s[s.PgUp = 33] = "PgUp", s[s.PgDown = 34] = "PgDown", s[s.LeftArrow = 37] = "LeftArrow", s[s.UpArrow = 38] = "UpArrow", s[s.RightArrow = 39] = "RightArrow", s[s.DownArrow = 40] = "DownArrow", s[s.Delete = 46] = "Delete", s[s.a = 65] = "a", s[s.b = 66] = "b", s[s.c = 67] = "c", s[s.d = 68] = "d", s[s.e = 69] = "e", s[s.f = 70] = "f", s[s.g = 71] = "g", s[s.h = 72] = "h", s[s.i = 73] = "i", s[s.j = 74] = "j", s[s.k = 75] = "k", s[s.l = 76] = "l", s[s.m = 77] = "m", s[s.n = 78] = "n", s[s.o = 79] = "o", s[s.p = 80] = "p", s[s.q = 81] = "q", s[s.r = 82] = "r", s[s.s = 83] = "s", s[s.t = 84] = "t", s[s.u = 85] = "u", s[s.v = 86] = "v", s[s.w = 87] = "w", s[s.x = 88] = "x", s[s.y = 89] = "y", s[s.z = 90] = "z", s[s._0 = 48] = "_0", s[s._1 = 49] = "_1", s[s._2 = 50] = "_2", s[s._3 = 51] = "_3", s[s._4 = 52] = "_4", s[s._5 = 53] = "_5", s[s._6 = 54] = "_6", s[s._7 = 55] = "_7", s[s._8 = 56] = "_8", s[s._9 = 57] = "_9", s[s.NumPad_0 = 96] = "NumPad_0", s[s.NumPad_1 = 97] = "NumPad_1", s[s.NumPad_2 = 98] = "NumPad_2", s[s.NumPad_3 = 99] = "NumPad_3", s[s.NumPad_4 = 100] = "NumPad_4", s[s.NumPad_5 = 101] = "NumPad_5", s[s.NumPad_6 = 102] = "NumPad_6", s[s.NumPad_7 = 103] = "NumPad_7", s[s.NumPad_8 = 104] = "NumPad_8", s[s.NumPad_9 = 105] = "NumPad_9", s))(ti || {}), Se = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.Face = 1] = "Face", s[s.Line = 2] = "Line", s[s.Point = 4] = "Point", s[s.All = 7] = "All", s))(Se || {}), On = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.Face = 1] = "Face", s[s.Line = 2] = "Line", s[s.Point = 3] = "Point", s[s.Part = 4] = "Part", s))(On || {}), xn = /* @__PURE__ */ ((s) => (s[s.Set = 0] = "Set", s[s.Add = 1] = "Add", s[s.Toggle = 2] = "Toggle", s))(xn || {}), Tr = /* @__PURE__ */ ((s) => (s[s.HighlightOnly = 0] = "HighlightOnly", s[s.OutlineOnly = 1] = "OutlineOnly", s[s.HighlightAndOutline = 2] = "HighlightAndOutline", s))(Tr || {}), Ib = /* @__PURE__ */ ((s) => (s[s.Info = 0] = "Info", s[s.Warning = 1] = "Warning", s[s.Error = 2] = "Error", s))(Ib || {}), Lo = /* @__PURE__ */ ((s) => (s[s.Interactive = 1] = "Interactive", s[s.All = 2] = "All", s[s.OnDemand = 4] = "OnDemand", s[
  s.Default = 1
  /* Interactive */
] = "Default", s))(Lo || {}), lh = /* @__PURE__ */ ((s) => (s[s.Client = 0] = "Client", s[s.Server = 1] = "Server", s))(lh || {}), lr = /* @__PURE__ */ ((s) => (s[s.Wireframe = 0] = "Wireframe", s[s.Shaded = 1] = "Shaded", s[s.WireframeOnShaded = 2] = "WireframeOnShaded", s[s.HiddenLine = 3] = "HiddenLine", s[s.XRay = 4] = "XRay", s[s.Gooch = 5] = "Gooch", s[s.Toon = 6] = "Toon", s))(lr || {}), Cb = /* @__PURE__ */ ((s) => (s[s.Unsorted = 0] = "Unsorted", s[s.SingleLayer = 1] = "SingleLayer", s))(Cb || {}), bg = /* @__PURE__ */ ((s) => (s[s.SMAA = 0] = "SMAA", s[s.None = 1] = "None", s))(bg || {}), Qi = /* @__PURE__ */ ((s) => (s[s.DoNotExplode = 0] = "DoNotExplode", s[s.DoNotCut = 1] = "DoNotCut", s[s.DoNotSelect = 2] = "DoNotSelect", s[s.SuppressCameraScale = 3] = "SuppressCameraScale", s[s.OverrideSceneVisibility = 4] = "OverrideSceneVisibility", s[s.DoNotLight = 5] = "DoNotLight", s[s.DoNotOutlineHighlight = 6] = "DoNotOutlineHighlight", s[s.ExcludeBounding = 7] = "ExcludeBounding", s[s.DoNotUseVertexColors = 8] = "DoNotUseVertexColors", s[s.AlwaysDraw = 9] = "AlwaysDraw", s[s.DoNotXRay = 10] = "DoNotXRay", s[s.ScreenOriented = 11] = "ScreenOriented", s[s.ScreenSpace = 12] = "ScreenSpace", s[s.ScreenSpaceStretched = 13] = "ScreenSpaceStretched", s[s.DoNotReset = 14] = "DoNotReset", s))(Qi || {}), ee = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.SuppressCameraScale = 1] = "SuppressCameraScale", s[s.ScreenOriented = 2] = "ScreenOriented", s[s.DoNotCut = 4] = "DoNotCut", s[s.DoNotExplode = 8] = "DoNotExplode", s[s.DoNotSelect = 16] = "DoNotSelect", s[s.DoNotLight = 32] = "DoNotLight", s[s.DoNotOutlineHighlight = 64] = "DoNotOutlineHighlight", s[s.ExcludeBounding = 128] = "ExcludeBounding", s[s.DoNotUseVertexColors = 256] = "DoNotUseVertexColors", s[s.Invisible = 512] = "Invisible", s[s.DoNotXRay = 1024] = "DoNotXRay", s[s.AlwaysDraw = 2048] = "AlwaysDraw", s[s.OverrideSceneVisibility = 4096] = "OverrideSceneVisibility", s[s.ScreenSpace = 8192] = "ScreenSpace", s[s.ScreenSpaceStretched = 16384] = "ScreenSpaceStretched", s[s.DoNotReset = 32768] = "DoNotReset", s))(ee || {}), Po = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.Model = 1] = "Model", s[s.Instance = 2] = "Instance", s[s.Ejected = 4] = "Ejected", s[s.All = 7] = "All", s))(Po || {}), yc = /* @__PURE__ */ ((s) => (s[s.CameraTarget = 0] = "CameraTarget", s[s.ModelCenter = 1] = "ModelCenter", s[s.OrbitTarget = 2] = "OrbitTarget", s))(yc || {}), wc = /* @__PURE__ */ ((s) => (s[s.Mouse = 0] = "Mouse", s[s.Keyboard = 1] = "Keyboard", s))(wc || {}), Le = /* @__PURE__ */ ((s) => (s[s.AssemblyNode = 0] = "AssemblyNode", s[s.PartInstance = 1] = "PartInstance", s[s.Part = 2] = "Part", s[s.BodyInstance = 3] = "BodyInstance", s[s.PmiBody = 4] = "PmiBody", s[s.ViewFrame = 5] = "ViewFrame", s[s.Body = 6] = "Body", s[s.BrepBody = 7] = "BrepBody", s[s.TessBody = 8] = "TessBody", s[s.WireBody = 9] = "WireBody", s[s.PointsBody = 10] = "PointsBody", s[s.Pmi = 11] = "Pmi", s[s.CadView = 12] = "CadView", s[s.DrawingSheet = 13] = "DrawingSheet", s[s.Unknown = 14] = "Unknown", s))(Le || {}), C_ = /* @__PURE__ */ ((s) => (s[s.Unknown = 0] = "Unknown", s[s.Text = 1] = "Text", s[s.Dimension = 2] = "Dimension", s[s.Arrow = 3] = "Arrow", s[s.Balloon = 4] = "Balloon", s[s.CircleCenter = 5] = "CircleCenter", s[s.Coordinate = 6] = "Coordinate", s[s.Datum = 7] = "Datum", s[s.Fastener = 8] = "Fastener", s[s.Gdt = 9] = "Gdt", s[s.Locator = 10] = "Locator", s[s.MeasurementPoint = 11] = "MeasurementPoint", s[s.Roughness = 12] = "Roughness", s[s.Welding = 13] = "Welding", s[s.Table = 14] = "Table", s[s.Other = 15] = "Other", s[s.GeometricalTolerance = 16] = "GeometricalTolerance", s))(C_ || {}), S_ = /* @__PURE__ */ ((s) => (s[s.Unknown = 0] = "Unknown", s[s.DatumIdent = 1] = "DatumIdent", s[s.DatumTarget = 2] = "DatumTarget", s[s.DimensionDistance = 1] = "DimensionDistance", s[s.DimensionDistanceOffset = 2] = "DimensionDistanceOffset", s[s.DimensionDistanceCumulate = 3] = "DimensionDistanceCumulate", s[s.DimensionChamfer = 4] = "DimensionChamfer", s[s.DimensionSlope = 5] = "DimensionSlope", s[s.DimensionOrdinate = 6] = "DimensionOrdinate", s[s.DimensionRadius = 7] = "DimensionRadius", s[s.DimensionRadiusTangent = 8] = "DimensionRadiusTangent", s[s.DimensionRadiusCylinder = 9] = "DimensionRadiusCylinder", s[s.DimensionRadiusEdge = 10] = "DimensionRadiusEdge", s[s.DimensionDiameter = 11] = "DimensionDiameter", s[s.DimensionDiameterTangent = 12] = "DimensionDiameterTangent", s[s.DimensionDiameterCylinder = 13] = "DimensionDiameterCylinder", s[s.DimensionDiameterEdge = 14] = "DimensionDiameterEdge", s[s.DimensionDiameterCone = 15] = "DimensionDiameterCone", s[s.DimensionLength = 16] = "DimensionLength", s[s.DimensionLengthCurvilinear = 17] = "DimensionLengthCurvilinear", s[s.DimensionLengthCircular = 18] = "DimensionLengthCircular", s[s.DimensionAngle = 19] = "DimensionAngle", s[s.GdtFcf = 1] = "GdtFcf", s[s.WeldingLine = 1] = "WeldingLine", s[s.WeldingSpot = 2] = "WeldingSpot", s[s.OtherSymbolUser = 1] = "OtherSymbolUser", s[s.OtherSymbolUtility = 2] = "OtherSymbolUtility", s[s.OtherSymbolCustom = 3] = "OtherSymbolCustom", s[s.OtherGeometricReference = 4] = "OtherGeometricReference", s[s.OtherRegion = 5] = "OtherRegion", s))(S_ || {}), ch = /* @__PURE__ */ ((s) => (s[s.Unknown = -1] = "Unknown", s[s.Context = 1] = "Context", s[s.Item = 2] = "Item", s[s.MultipleVertex = 3] = "MultipleVertex", s[s.UniqueVertex = 4] = "UniqueVertex", s[s.WireEdge = 5] = "WireEdge", s[s.Edge = 6] = "Edge", s[s.CoEdge = 7] = "CoEdge", s[s.Loop = 8] = "Loop", s[s.Face = 9] = "Face", s[s.Shell = 10] = "Shell", s[s.Connex = 11] = "Connex", s[s.Body = 12] = "Body", s[s.SingleWireBody = 13] = "SingleWireBody", s[s.BrepData = 14] = "BrepData", s[s.WireBody = 17] = "WireBody", s))(ch || {}), Zs = /* @__PURE__ */ ((s) => (s[s.Unknown = 0] = "Unknown", s[s.Clockwise = 1] = "Clockwise", s[s.CounterClockwise = 2] = "CounterClockwise", s))(Zs || {}), qe = /* @__PURE__ */ ((s) => (s[s.UpperLeftCorner = 0] = "UpperLeftCorner", s[s.LowerLeftCorner = 1] = "LowerLeftCorner", s[s.LowerRightCorner = 2] = "LowerRightCorner", s[s.UpperRightCorner = 3] = "UpperRightCorner", s[s.TopCenter = 4] = "TopCenter", s[s.LeftCenter = 5] = "LeftCenter", s[s.RightCenter = 6] = "RightCenter", s[s.BottomCenter = 7] = "BottomCenter", s[s.Center = 8] = "Center", s))(qe || {}), Fe = /* @__PURE__ */ ((s) => (s[s.Pixels = 0] = "Pixels", s[s.ProportionOfCanvas = 1] = "ProportionOfCanvas", s[s.MinimumProportionOfCanvas = 2] = "MinimumProportionOfCanvas", s[s.ProportionOfOtherDimension = 3] = "ProportionOfOtherDimension", s))(Fe || {}), Of = /* @__PURE__ */ ((s) => (s[s.ScreenPixels = 0] = "ScreenPixels", s[s.CSSPixels = 1] = "CSSPixels", s[s.World = 2] = "World", s[s.ProportionOfScreenWidth = 3] = "ProportionOfScreenWidth", s[s.ProportionOfScreenHeight = 4] = "ProportionOfScreenHeight", s[s.ProportionOfBoundingDiagonal = 5] = "ProportionOfBoundingDiagonal", s))(Of || {}), Rf = /* @__PURE__ */ ((s) => (s[s.Square = 0] = "Square", s[s.Disk = 1] = "Disk", s[s.Sphere = 2] = "Sphere", s))(Rf || {});
class Sb {
  constructor() {
    this.bodyId = vg, this.subElementType = -1, this.subElementIndex = -1;
  }
}
var de = /* @__PURE__ */ ((s) => (s[s.Hidden = 0] = "Hidden", s[s.Shown = 1] = "Shown", s[s.Mixed = 2] = "Mixed", s))(de || {}), Pb = /* @__PURE__ */ ((s) => (s[s.Object = 0] = "Object", s[s.World = 1] = "World", s))(Pb || {}), be = /* @__PURE__ */ ((s) => (s[s.First = 8] = "First", s[
  s.Handles = 8
  /* First */
] = "Handles", s[s.AxisTriad = 9] = "AxisTriad", s[s.NavCube = 10] = "NavCube", s[s.Floorplan = 11] = "Floorplan", s[s.TestFramework = 12] = "TestFramework", s))(be || {});
class kb {
  constructor() {
    this.pos1 = _.zero(), this.pos2 = _.zero(), this.distance = 0;
  }
}
class Wp {
  constructor() {
    this.frontVector = new _(-1, 0, 0), this.upVector = new _(0, 0, 1);
  }
}
var Mb = /* @__PURE__ */ ((s) => (s[s.Object = 0] = "Object", s[s.World = 1] = "World", s[s.ProportionOfScreenWidth = 2] = "ProportionOfScreenWidth", s[s.ProportionOfScreenHeight = 3] = "ProportionOfScreenHeight", s))(Mb || {}), hh = /* @__PURE__ */ ((s) => (s[s.Selected = 0] = "Selected", s[s.Unselected = 1] = "Unselected", s))(hh || {}), Ks = /* @__PURE__ */ ((s) => (s[s.Pixels = 0] = "Pixels", s[s.ProportionOfWidth = 1] = "ProportionOfWidth", s[s.ProportionOfHeight = 2] = "ProportionOfHeight", s))(Ks || {}), zr = /* @__PURE__ */ ((s) => (s[s.Undefined = 0] = "Undefined", s[s.Int = 1] = "Int", s[s.Float = 2] = "Float", s[s.Time = 3] = "Time", s[s.String = 4] = "String", s[s.Ignored = 5] = "Ignored", s))(zr || {});
class Gp {
  constructor(t, e) {
    this.isInclusive = t, this.nodeIds = e;
  }
}
class Eb {
  constructor(t, e) {
    this.defaultVisibility = t, this.visibilityExceptions = e;
  }
}
class Ma {
  constructor() {
    this.additionalMatrix = null, this.allowMissingExternalModels = !1, this.attachInvisibly = !1, this.implicitlyLoadXmlExternalModels = !0, this.ignoreCadViews = !1, this.ignoreFilters = !1, this.ignoreLayers = !1, this.ignoreGenericTypes = !1, this.ignoreBimRelationships = !1, this._allowSubtreeLoadedCallback = !0;
  }
  copy() {
    const t = new Ma();
    return t.additionalMatrix = this.additionalMatrix, t.additionalMatrix !== null && (t.additionalMatrix = t.additionalMatrix.copy()), t.allowMissingExternalModels = this.allowMissingExternalModels, t.attachInvisibly = this.attachInvisibly, t.implicitlyLoadXmlExternalModels = this.implicitlyLoadXmlExternalModels, t.ignoreCadViews = this.ignoreCadViews, t.ignoreFilters = this.ignoreFilters, t.ignoreLayers = this.ignoreLayers, t.ignoreGenericTypes = this.ignoreGenericTypes, t.ignoreBimRelationships = this.ignoreBimRelationships, t._allowSubtreeLoadedCallback = this._allowSubtreeLoadedCallback, t;
  }
}
var Dc = /* @__PURE__ */ ((s) => (s[s.Unknown = 0] = "Unknown", s[s.Catia = 2] = "Catia", s[s.CatiaV5 = 3] = "CatiaV5", s[s.Cadds = 4] = "Cadds", s[s.Unigraphics = 5] = "Unigraphics", s[s.Parasolid = 6] = "Parasolid", s[s.Euclid = 7] = "Euclid", s[s.Iges = 9] = "Iges", s[s.Unisurf = 10] = "Unisurf", s[s.Vda = 11] = "Vda", s[s.Stl = 12] = "Stl", s[s.Wrl = 13] = "Wrl", s[s.Dxf = 14] = "Dxf", s[s.Acis = 15] = "Acis", s[s.ProE = 16] = "ProE", s[s.Step = 18] = "Step", s[s.Ideas = 19] = "Ideas", s[s.Jt = 20] = "Jt", s[s.Slw = 22] = "Slw", s[s.Cgr = 23] = "Cgr", s[s.Prc = 24] = "Prc", s[s.Xvl = 25] = "Xvl", s[s.Hpgl = 26] = "Hpgl", s[s.TopSolid = 27] = "TopSolid", s[s.OneSpaceDesigner = 28] = "OneSpaceDesigner", s[s._3dxml = 29] = "_3dxml", s[s.Inventor = 30] = "Inventor", s[s.PostScript = 31] = "PostScript", s[s.Pdp = 32] = "Pdp", s[s.U3d = 33] = "U3d", s[s.Ifc = 34] = "Ifc", s[s.Dwg = 35] = "Dwg", s[s.Dwf = 36] = "Dwf", s[s.Se = 37] = "Se", s[s.Obj = 38] = "Obj", s[s.Kmz = 39] = "Kmz", s[s.Dae = 40] = "Dae", s[s._3ds = 41] = "_3ds", s[s.Rhino = 43] = "Rhino", s[s.Xml = 44] = "Xml", s[s._3mf = 45] = "_3mf", s[s.Scs = 46] = "Scs", s[s._3dHtml = 47] = "_3dHtml", s[s.Hsf = 48] = "Hsf", s[s.Gltf = 49] = "Gltf", s[s.Revit = 50] = "Revit", s[s.Fbx = 51] = "Fbx", s))(Dc || {}), Lf = /* @__PURE__ */ ((s) => (s[s.World = 0] = "World", s[s.ProportionOfBoundingHeight = 1] = "ProportionOfBoundingHeight", s))(Lf || {}), Ab = /* @__PURE__ */ ((s) => (s[s.Default = 0] = "Default", s[s.PerNode = 1] = "PerNode", s))(Ab || {}), hl = /* @__PURE__ */ ((s) => (s[s.NorthUp = 0] = "NorthUp", s[s.AvatarUp = 1] = "AvatarUp", s))(hl || {}), P_ = /* @__PURE__ */ ((s) => (s[s.ContainedInSpatialStructure = 0] = "ContainedInSpatialStructure", s[s.Aggregates = 1] = "Aggregates", s[s.VoidsElement = 2] = "VoidsElement", s[s.FillsElement = 3] = "FillsElement", s[s.SpaceBoundary = 4] = "SpaceBoundary", s[s.ConnectsPathElements = 5] = "ConnectsPathElements", s[s.Undefined = 6] = "Undefined", s))(P_ || {}), k_ = /* @__PURE__ */ ((s) => (s[s.FixedFramerate = 0] = "FixedFramerate", s[s.OcclusionCulling = 1] = "OcclusionCulling", s))(k_ || {}), _s = /* @__PURE__ */ ((s) => (s[s.Rgba32 = 0] = "Rgba32", s[s.Rgb24 = 1] = "Rgb24", s[s.Gray8 = 2] = "Gray8", s[s.GrayAlpha16 = 3] = "GrayAlpha16", s[s.Jpeg = 4] = "Jpeg", s[s.Png = 5] = "Png", s))(_s || {}), Ff = /* @__PURE__ */ ((s) => (s[s.Clamp = 0] = "Clamp", s[s.Repeat = 1] = "Repeat", s[s.Trim = 2] = "Trim", s))(Ff || {}), Tb = /* @__PURE__ */ ((s) => (s[s.UV = 0] = "UV", s))(Tb || {}), Nb = /* @__PURE__ */ ((s) => (s[s.Decal = 1] = "Decal", s))(Nb || {}), Oc = /* @__PURE__ */ ((s) => (s[s.Model = 1] = "Model", s[s.Svg = 2] = "Svg", s[s.Html = 4] = "Html", s[s.All = 7] = "All", s))(Oc || {});
class oe extends Error {
  /**
   * Creates a new CommunicatorError
   */
  constructor(t) {
    super(t), Object.setPrototypeOf(this, oe.prototype);
  }
}
class xg extends oe {
  /**
   * Creates a new InvalidIndexError
   */
  constructor(t) {
    super(`Invalid index (${t}).`), Object.setPrototypeOf(this, xg.prototype);
  }
}
class Oo extends oe {
  /**
   * Creates a new PickOutsideCanvasError
   */
  constructor() {
    super("Cannot pick from outside the canvas area."), Object.setPrototypeOf(this, Oo.prototype);
  }
}
class no extends oe {
  /**
   * Creates a new SelectionInvalidatedError
   */
  constructor() {
    super("Selection invalidated."), Object.setPrototypeOf(this, no.prototype);
  }
}
class oi extends oe {
  /**
   * Creates a new InternalLogicError
   */
  constructor() {
    super("Internal logic error."), Object.setPrototypeOf(this, oi.prototype);
  }
}
class Ds extends oe {
  /**
   * Creates a new InvalidNodeIdError
   */
  constructor(t) {
    super(`Invalid node (${t}).`), Object.setPrototypeOf(this, Ds.prototype), this.nodeId = t;
  }
}
class is extends oe {
  /**
   * Creates a new InvalidNodeTypeError
   */
  constructor(t, e, ...i) {
    i.push(e);
    const n = [];
    for (const l of i)
      switch (l) {
        case In.ProductOccurrence:
          n.push(Le.DrawingSheet, Le.PartInstance, Le.AssemblyNode);
          break;
        case In.AnyBody:
          n.push(Le.BodyInstance), n.push(Le.PmiBody), n.push(Le.ViewFrame);
          break;
        case In.BodyInstance:
          n.push(Le.BodyInstance);
          break;
        case In.CadView:
          n.push(Le.CadView);
          break;
        default:
          $r();
      }
    n.sort();
    const r = [];
    for (const l of n)
      r.push(Le[l]);
    const o = r.length === 1 ? `type (${r[0]})` : `types ${r}`;
    super(`Expected node (${t}) to be of ${o}.`), Object.setPrototypeOf(this, is.prototype), this.nodeId = t, this.expectedTypes = n;
  }
}
class qr extends oe {
  /**
   * Creates a new LoadError
   */
  constructor(t) {
    super(t), Object.setPrototypeOf(this, qr.prototype);
  }
}
class _d extends qr {
  /**
   * Creates a new LoadCancelledError
   */
  constructor() {
    super("Load cancelled."), Object.setPrototypeOf(this, _d.prototype);
  }
}
class yd extends qr {
  /**
   * Creates a new MissingModelError
   */
  constructor(t) {
    super(`Missing model: '${t}'.`), Object.setPrototypeOf(this, yd.prototype);
  }
}
class Rs extends oe {
  /**
   * Creates a new ParseError
   */
  constructor(t) {
    super(t), Object.setPrototypeOf(this, Rs.prototype);
  }
}
class Ea extends Rs {
  /**
   * Creates a new AssemblyDataParseError
   */
  constructor(t) {
    super(t), Object.setPrototypeOf(this, Ea.prototype);
  }
}
class si extends Rs {
  /**
   * Creates a new XmlParseError
   */
  constructor(t) {
    super(t), Object.setPrototypeOf(this, si.prototype);
  }
}
function Db(s) {
  return Ob(s);
}
function Ob(s) {
  const t = new M_();
  for (const i of s)
    i._gatherForExport(t);
  const e = {};
  if (!t.buffers.isEmpty()) {
    e.buffers = [];
    for (const i of t.buffers.toArray())
      e.buffers.push(i._export());
  }
  if (!t.samplers.isEmpty()) {
    e.samplers = [];
    for (const i of t.samplers.toArray())
      e.samplers.push(i._export(t));
  }
  if (!t.colorMaps.isEmpty()) {
    e.colorMaps = [];
    for (const i of t.colorMaps.toArray())
      e.colorMaps.push(Lb(i));
  }
  if (s.length !== 0) {
    e.animations = [];
    for (const i of s)
      e.animations.push(i._export(t));
  }
  return {
    ...e
  };
}
function Rb(s) {
  const t = s, e = new E_();
  if (t.buffers !== void 0)
    for (const n of t.buffers)
      e.buffers.push(_h._import(n));
  if (t.samplers !== void 0)
    for (const n of t.samplers)
      e.samplers.push(Xc._import(e, n));
  if (t.colorMaps !== void 0)
    for (const n of t.colorMaps)
      e.colorMaps.push(Fb(n));
  const i = [];
  if (t.animations !== void 0)
    for (const n of t.animations)
      i.push(dd._import(e, n));
  return i;
}
function Lb(s) {
  const t = [];
  for (const e of s)
    t.push([e.position, e.color.r, e.color.g, e.color.b]);
  return t;
}
function Fb(s) {
  const t = [];
  for (const e of s)
    t.push({
      position: e[0],
      color: new vt(e[1], e[2], e[3])
    });
  return t;
}
class M_ {
  constructor() {
    this.buffers = new Au(), this.samplers = new Au(), this.colorMaps = new Au();
  }
}
class E_ {
  constructor() {
    this.buffers = [], this.samplers = [], this.colorMaps = [];
  }
}
class Au {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  add(t) {
    this.map.has(t) || this.map.set(t, this.map.size);
  }
  getIndex(t) {
    const e = this.map.get(t);
    if (e === void 0)
      throw new oi();
    return e;
  }
  /**
   * Returns an array containing each element of the set placed at its
   * assigned index.
   */
  toArray() {
    const t = [];
    return this.map.forEach((e, i) => {
      t[e] = i;
    }), t;
  }
  isEmpty() {
    return this.map.size === 0;
  }
}
var A_ = /* @__PURE__ */ ((s) => (s[s.Stopped = 0] = "Stopped", s[s.Playing = 1] = "Playing", s[s.Paused = 2] = "Paused", s[s.Complete = 3] = "Complete", s))(A_ || {});
const jg = class jg {
  /** @hidden Do not use.  Create via Animation.Manager API instead. */
  constructor(t, e) {
    this._viewer = t, this.animation = e, this._nodeValues = /* @__PURE__ */ new Map(), this._disabledChannels = /* @__PURE__ */ new Set(), this._currentTime = 0, this._lastUpdate = 0, this.speed = 1, this._animationTime = 0, this._state = 0, this.loop = 0, this._loopCount = 0, this.onComplete = null, this.nodeIdOffset = 0, this.reload();
  }
  /** Sets the enabled state for a channel in this players animation.
   * All channels are enabled by default when a player is created.
   * A channel that has been disabled will not have its value interpolated by the system until it is re-enabled
   * @param channel a channel from the underlying animation
   * @param enabled boolean value indicating whether the channel should be enabled.
   */
  setChannelEnabled(t, e) {
    e ? this._disabledChannels.delete(t) : this._disabledChannels.add(t);
  }
  /**
   * Updates internal state of animation player.
   *
   * Call this method after any part of the underlying animation has been updated.
   * */
  reload() {
    this._nodeValues.clear(), this._animationTime = 0;
    for (const t of this.animation.nodeChannels) {
      const e = t.sampler.buffer.times.length;
      if (e !== 0) {
        if (!this._nodeValues.has(t.nodeId)) {
          const i = new Em(t.nodeId);
          i.pivotPoint = this.animation.pivotPoints.get(t.nodeId), this._nodeValues.set(t.nodeId, i);
        }
        this._animationTime = Math.max(this._animationTime, t.sampler.buffer.times[e - 1]);
      }
    }
    for (const t of this.animation.cameraChannels) {
      const e = t.sampler.buffer.times.length;
      e !== 0 && (this._animationTime = Math.max(this._animationTime, t.sampler.buffer.times[e - 1]));
    }
  }
  /**
   * Called automatically by the Animation.Manager when it is updating all animations.
   * @returns True if values were modified.
   * @hidden
   */
  _tick(t, e) {
    if (this._state !== 1)
      return !1;
    const i = (t - this._lastUpdate) / 1e3;
    return this._tickTime(i, e), this._lastUpdate = t, !0;
  }
  /**
   * Updates the animation using the supplied delta time specified in seconds.
   * @returns True if values were modified.
   * @hidden
   */
  _tickTime(t, e) {
    if (this._state !== 1)
      return !1;
    this._currentTime += t * this.speed;
    const i = this._currentTime < 0, n = this._currentTime > this._animationTime;
    return i || n ? this.loop < 0 || this.loop > this._loopCount ? (this._loopCount += 1, this._currentTime = i ? this._animationTime : 0, this.evaluate(this._currentTime, e)) : (this._currentTime = this._animationTime, this.evaluate(this._currentTime, e), this._state = 3, this._loopCount = 0, this.onComplete && this.onComplete()) : this.evaluate(this._currentTime, e), !0;
  }
  /** Starts playing the animation. */
  play() {
    this._state !== 1 && (this._state === 3 && (this._currentTime = 0), this._lastUpdate = performance.now(), this._state = 1);
  }
  /** Pauses animation playback. */
  pause() {
    this._state === 1 && (this._state = 2);
  }
  /** Stops animation playback and resets the current time to 0. */
  stop() {
    this._state = 0, this.setTime(0);
  }
  /**
   * Sets the current animation time.
   * @param time time in milliseconds
   */
  setTime(t) {
    const e = new Fu();
    this._currentTime = Math.min(t, this._animationTime), this.evaluate(this._currentTime, e), e.apply(this._viewer);
  }
  /**
   * Calculate the values for each channel of the associated [[Animation]]
   * at the given time.
   *
   * @param time The time at which to evaluate the animation.
   * @param out Storage for the evaluated values. If supplied, this object
   * will be returned instead of a new [[BatchedValues]] object. This
   * allows values gathered from multiple players to be combined into one
   * batch.
   */
  evaluate(t, e) {
    e === void 0 && (e = new Fu());
    for (const i of this.animation.nodeChannels) {
      const n = this._nodeValues.get(i.nodeId);
      n !== void 0 && !this._disabledChannels.has(i) && i._getValue(t, n);
    }
    this._nodeValues.forEach((i) => {
      if (e === void 0)
        throw new oi();
      const n = i.nodeId + this.nodeIdOffset;
      (i.flags & Nn.Transform) === Nn.Transform && (i.updateMatrix(), e.node.matrixNodeIds.push(n), e.node.matrices.push(i.matrix)), (i.flags & Nn.Opacity) === Nn.Opacity && e.node.opacities.set(n, i.opacity), (i.flags & Nn.Visibility) === Nn.Visibility && (i.visibility !== 0 ? e.node.visibilityOn.push(n) : e.node.visibilityOff.push(n)), (i.flags & Nn.Color) === Nn.Color && e.node.colors.set(
        n,
        new vt(i.color.x, i.color.y, i.color.z)
      ), i.flags = Nn.None;
    });
    for (const i of this.animation.cameraChannels)
      i.sampler.buffer.times.length > 0 && !this._disabledChannels.has(i) && i._getValue(t, e.camera);
    return e;
  }
  /** Gets the current animation state. */
  getState() {
    return this._state;
  }
  /** Gets the current time in seconds that the animation has been playing. */
  getCurrentTime() {
    return this._currentTime;
  }
  /** Gets the current time in seconds of the entire animation. */
  getAnimationTime() {
    return this._animationTime;
  }
};
jg.LoopIndefinitely = -1;
let Qu = jg;
class T_ {
  /** @hidden Created during WebViewer Initialization. */
  constructor(t) {
    this._viewer = t, this._players = [], this._intervalHandle = null, this._batch = new Fu(), this._viewer.setCallbacks({
      assemblyTreeReady: () => {
        this.setTickInterval(50);
      }
    });
  }
  /** Creates a new animation player for the supplied animation. */
  createPlayer(t) {
    const e = new Qu(this._viewer, t);
    return this._players.push(e), e;
  }
  /** Removes the player at the provided index from control of the manager. Returns `true` if a player was removed */
  removePlayerByIndex(t) {
    return t >= this._players.length ? !1 : (this._players.splice(t, 1), !0);
  }
  /** Removes the provided player from control of the manager. Returns `true` is a player was removed */
  removePlayer(t) {
    for (let e = 0; e < this._players.length; e++)
      if (this._players[e] === t)
        return this._players.splice(e, 1), !0;
    return !1;
  }
  /** Removes all players from control of the manager. */
  clear() {
    this._players = [];
  }
  _tick() {
    if (this._players.length === 0)
      return;
    this._batch.clear();
    let t = !1;
    const e = performance.now();
    for (const i of this._players)
      i._tick(e, this._batch) && (t = !0);
    t && (this._viewer.pauseRendering(), this._batch.apply(this._viewer), this._viewer.resumeRendering());
  }
  /** @hidden  Called by the web viewer only*/
  _shutdown() {
    this._intervalHandle !== null && clearInterval(this._intervalHandle);
  }
  /**
   * Sets the interval at which animations are updated.
   * @param milliseconds number of milliseconds between update intervals
   */
  setTickInterval(t) {
    this._intervalHandle && clearInterval(this._intervalHandle), this._intervalHandle = setInterval(() => {
      this._tick();
    }, t);
  }
}
function ac(s, t, e, i) {
  const n = e === fr.Width || e === fr.Height ? Os.Scalar : Os.Vec3, r = new _h(n), o = new Xc(r, i);
  return s.createCameraChannel(t, e, o);
}
function Bb(s, t, e) {
  const i = [];
  return i.push(
    ac(
      s,
      `${t}-Position`,
      fr.Position,
      e
    )
  ), i.push(
    ac(
      s,
      `${t}-Target`,
      fr.Target,
      e
    )
  ), i.push(
    ac(s, `${t}-Up`, fr.Up, e)
  ), i.push(
    ac(s, `${t}-Width`, fr.Width, e)
  ), i.push(
    ac(
      s,
      `${t}-Height`,
      fr.Height,
      e
    )
  ), i;
}
function Vb(s, t, e) {
  const i = t.getPosition();
  e.cameraChannels[0].sampler.buffer.insertVec3Keyframe(
    s,
    i.x,
    i.y,
    i.z
  );
  const n = t.getTarget();
  e.cameraChannels[1].sampler.buffer.insertVec3Keyframe(s, n.x, n.y, n.z);
  const r = t.getUp();
  e.cameraChannels[2].sampler.buffer.insertVec3Keyframe(s, r.x, r.y, r.z), e.cameraChannels[3].sampler.buffer.insertScalarKeyframe(s, t.getWidth()), e.cameraChannels[4].sampler.buffer.insertScalarKeyframe(s, t.getHeight());
}
const JC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Animation: dd,
  BatchedCameraValues: Am,
  BatchedNodeValues: Tm,
  BatchedValues: Fu,
  CameraChannel: Kc,
  CameraProperty: fr,
  ExportContext: M_,
  ImportContext: E_,
  IndexedSet: Au,
  InterpolationType: Vu,
  KeyType: Os,
  KeyframeBuffer: _h,
  Manager: T_,
  NodeChannel: qc,
  NodeProperty: Bu,
  NodeValues: Em,
  NodeValuesFlags: Nn,
  Player: Qu,
  PlayerState: A_,
  Sampler: Xc,
  createCameraChannels: Bb,
  exportAnimations: Db,
  importAnimations: Rb,
  keyframeCamera: Vb
}, Symbol.toStringTag, { value: "Module" }));
var Xs = /* @__PURE__ */ ((s) => (s[s.Unknown = 0] = "Unknown", s[s.v1_0 = 1] = "v1_0", s[s.v2_0 = 2] = "v2_0", s[s.v2_1 = 3] = "v2_1", s))(Xs || {}), Xn = /* @__PURE__ */ ((s) => (s[s.Unknown = 0] = "Unknown", s[s.TopicFolder = 1] = "TopicFolder", s[s.Version = 2] = "Version", s[s.Markup = 3] = "Markup", s[s.Snapshot = 4] = "Snapshot", s[s.Viewpoint = 5] = "Viewpoint", s[s.Schema = 6] = "Schema", s[s.Project = 7] = "Project", s))(Xn || {});
const Nr = "HOOPS Communicator";
function vc(s) {
  return s ? "true" : "false";
}
function Tu(s, t) {
  const e = s.createElement("Component");
  return t.ifcGuid !== void 0 && e.setAttribute("IfcGuid", t.ifcGuid), t.originatingSystem !== void 0 && e.setAttribute("OriginatingSystem", t.originatingSystem), t.authoringToolId !== void 0 && e.setAttribute("AuthoringToolId", t.authoringToolId.toString()), e;
}
function wu(s) {
  return s.length === 1 ? `0${s}` : s;
}
function N_(s, t) {
  const e = t ? wu(Math.round(t).toString(16)) : "", i = wu(Math.round(s.r).toString(16)), n = wu(Math.round(s.g).toString(16)), r = wu(Math.round(s.b).toString(16));
  return `${e}${i}${n}${r}`;
}
function cr(s, t, e) {
  const i = s.createElement("X"), n = s.createElement("Y"), r = s.createElement("Z");
  i.innerHTML = e.x.toString(), n.innerHTML = e.y.toString(), r.innerHTML = e.z.toString(), t.appendChild(i), t.appendChild(n), t.appendChild(r);
}
function Dr(s, t, e) {
  e != null && s.setAttribute(t, e);
}
function Rr(s, t, e, i) {
  const n = s.createElement(e);
  n.innerHTML = i, t.appendChild(n);
}
function on(s, t, e, i) {
  i != null && Rr(s, t, e, i);
}
function bc(s) {
  return s == null ? null : s.toISOString();
}
function Bf(s) {
  return s == null ? null : s.toString();
}
function Nu(s) {
  return s == null ? null : s ? "true" : "false";
}
function vu(s) {
  throw new Error('Could not dynamically require "' + s + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var D_ = { exports: {} };
/*!

JSZip v3.10.1 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/main/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/main/LICENSE
*/
(function(s, t) {
  (function(e) {
    s.exports = e();
  })(function() {
    return function e(i, n, r) {
      function o(u, d) {
        if (!n[u]) {
          if (!i[u]) {
            var g = typeof vu == "function" && vu;
            if (!d && g)
              return g(u, !0);
            if (l)
              return l(u, !0);
            var y = new Error("Cannot find module '" + u + "'");
            throw y.code = "MODULE_NOT_FOUND", y;
          }
          var m = n[u] = { exports: {} };
          i[u][0].call(m.exports, function(x) {
            var b = i[u][1][x];
            return o(b || x);
          }, m, m.exports, e, i, n, r);
        }
        return n[u].exports;
      }
      for (var l = typeof vu == "function" && vu, h = 0; h < r.length; h++)
        o(r[h]);
      return o;
    }({ 1: [function(e, i, n) {
      var r = e("./utils"), o = e("./support"), l = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      n.encode = function(h) {
        for (var u, d, g, y, m, x, b, I = [], C = 0, P = h.length, k = P, O = r.getTypeOf(h) !== "string"; C < h.length; )
          k = P - C, g = O ? (u = h[C++], d = C < P ? h[C++] : 0, C < P ? h[C++] : 0) : (u = h.charCodeAt(C++), d = C < P ? h.charCodeAt(C++) : 0, C < P ? h.charCodeAt(C++) : 0), y = u >> 2, m = (3 & u) << 4 | d >> 4, x = 1 < k ? (15 & d) << 2 | g >> 6 : 64, b = 2 < k ? 63 & g : 64, I.push(l.charAt(y) + l.charAt(m) + l.charAt(x) + l.charAt(b));
        return I.join("");
      }, n.decode = function(h) {
        var u, d, g, y, m, x, b = 0, I = 0, C = "data:";
        if (h.substr(0, C.length) === C)
          throw new Error("Invalid base64 input, it looks like a data url.");
        var P, k = 3 * (h = h.replace(/[^A-Za-z0-9+/=]/g, "")).length / 4;
        if (h.charAt(h.length - 1) === l.charAt(64) && k--, h.charAt(h.length - 2) === l.charAt(64) && k--, k % 1 != 0)
          throw new Error("Invalid base64 input, bad content length.");
        for (P = o.uint8array ? new Uint8Array(0 | k) : new Array(0 | k); b < h.length; )
          u = l.indexOf(h.charAt(b++)) << 2 | (y = l.indexOf(h.charAt(b++))) >> 4, d = (15 & y) << 4 | (m = l.indexOf(h.charAt(b++))) >> 2, g = (3 & m) << 6 | (x = l.indexOf(h.charAt(b++))), P[I++] = u, m !== 64 && (P[I++] = d), x !== 64 && (P[I++] = g);
        return P;
      };
    }, { "./support": 30, "./utils": 32 }], 2: [function(e, i, n) {
      var r = e("./external"), o = e("./stream/DataWorker"), l = e("./stream/Crc32Probe"), h = e("./stream/DataLengthProbe");
      function u(d, g, y, m, x) {
        this.compressedSize = d, this.uncompressedSize = g, this.crc32 = y, this.compression = m, this.compressedContent = x;
      }
      u.prototype = { getContentWorker: function() {
        var d = new o(r.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new h("data_length")), g = this;
        return d.on("end", function() {
          if (this.streamInfo.data_length !== g.uncompressedSize)
            throw new Error("Bug : uncompressed data size mismatch");
        }), d;
      }, getCompressedWorker: function() {
        return new o(r.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      } }, u.createWorkerFrom = function(d, g, y) {
        return d.pipe(new l()).pipe(new h("uncompressedSize")).pipe(g.compressWorker(y)).pipe(new h("compressedSize")).withStreamInfo("compression", g);
      }, i.exports = u;
    }, { "./external": 6, "./stream/Crc32Probe": 25, "./stream/DataLengthProbe": 26, "./stream/DataWorker": 27 }], 3: [function(e, i, n) {
      var r = e("./stream/GenericWorker");
      n.STORE = { magic: "\0\0", compressWorker: function() {
        return new r("STORE compression");
      }, uncompressWorker: function() {
        return new r("STORE decompression");
      } }, n.DEFLATE = e("./flate");
    }, { "./flate": 7, "./stream/GenericWorker": 28 }], 4: [function(e, i, n) {
      var r = e("./utils"), o = function() {
        for (var l, h = [], u = 0; u < 256; u++) {
          l = u;
          for (var d = 0; d < 8; d++)
            l = 1 & l ? 3988292384 ^ l >>> 1 : l >>> 1;
          h[u] = l;
        }
        return h;
      }();
      i.exports = function(l, h) {
        return l !== void 0 && l.length ? r.getTypeOf(l) !== "string" ? function(u, d, g, y) {
          var m = o, x = y + g;
          u ^= -1;
          for (var b = y; b < x; b++)
            u = u >>> 8 ^ m[255 & (u ^ d[b])];
          return -1 ^ u;
        }(0 | h, l, l.length, 0) : function(u, d, g, y) {
          var m = o, x = y + g;
          u ^= -1;
          for (var b = y; b < x; b++)
            u = u >>> 8 ^ m[255 & (u ^ d.charCodeAt(b))];
          return -1 ^ u;
        }(0 | h, l, l.length, 0) : 0;
      };
    }, { "./utils": 32 }], 5: [function(e, i, n) {
      n.base64 = !1, n.binary = !1, n.dir = !1, n.createFolders = !0, n.date = null, n.compression = null, n.compressionOptions = null, n.comment = null, n.unixPermissions = null, n.dosPermissions = null;
    }, {}], 6: [function(e, i, n) {
      var r = null;
      r = typeof Promise < "u" ? Promise : e("lie"), i.exports = { Promise: r };
    }, { lie: 37 }], 7: [function(e, i, n) {
      var r = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Uint32Array < "u", o = e("pako"), l = e("./utils"), h = e("./stream/GenericWorker"), u = r ? "uint8array" : "array";
      function d(g, y) {
        h.call(this, "FlateWorker/" + g), this._pako = null, this._pakoAction = g, this._pakoOptions = y, this.meta = {};
      }
      n.magic = "\b\0", l.inherits(d, h), d.prototype.processChunk = function(g) {
        this.meta = g.meta, this._pako === null && this._createPako(), this._pako.push(l.transformTo(u, g.data), !1);
      }, d.prototype.flush = function() {
        h.prototype.flush.call(this), this._pako === null && this._createPako(), this._pako.push([], !0);
      }, d.prototype.cleanUp = function() {
        h.prototype.cleanUp.call(this), this._pako = null;
      }, d.prototype._createPako = function() {
        this._pako = new o[this._pakoAction]({ raw: !0, level: this._pakoOptions.level || -1 });
        var g = this;
        this._pako.onData = function(y) {
          g.push({ data: y, meta: g.meta });
        };
      }, n.compressWorker = function(g) {
        return new d("Deflate", g);
      }, n.uncompressWorker = function() {
        return new d("Inflate", {});
      };
    }, { "./stream/GenericWorker": 28, "./utils": 32, pako: 38 }], 8: [function(e, i, n) {
      function r(m, x) {
        var b, I = "";
        for (b = 0; b < x; b++)
          I += String.fromCharCode(255 & m), m >>>= 8;
        return I;
      }
      function o(m, x, b, I, C, P) {
        var k, O, B = m.file, j = m.compression, V = P !== u.utf8encode, Y = l.transformTo("string", P(B.name)), q = l.transformTo("string", u.utf8encode(B.name)), st = B.comment, dt = l.transformTo("string", P(st)), U = l.transformTo("string", u.utf8encode(st)), J = q.length !== B.name.length, A = U.length !== st.length, R = "", wt = "", z = "", St = B.dir, X = B.date, At = { crc32: 0, compressedSize: 0, uncompressedSize: 0 };
        x && !b || (At.crc32 = m.crc32, At.compressedSize = m.compressedSize, At.uncompressedSize = m.uncompressedSize);
        var at = 0;
        x && (at |= 8), V || !J && !A || (at |= 2048);
        var ot = 0, Ut = 0;
        St && (ot |= 16), C === "UNIX" ? (Ut = 798, ot |= function(Lt, Je) {
          var Bi = Lt;
          return Lt || (Bi = Je ? 16893 : 33204), (65535 & Bi) << 16;
        }(B.unixPermissions, St)) : (Ut = 20, ot |= function(Lt) {
          return 63 & (Lt || 0);
        }(B.dosPermissions)), k = X.getUTCHours(), k <<= 6, k |= X.getUTCMinutes(), k <<= 5, k |= X.getUTCSeconds() / 2, O = X.getUTCFullYear() - 1980, O <<= 4, O |= X.getUTCMonth() + 1, O <<= 5, O |= X.getUTCDate(), J && (wt = r(1, 1) + r(d(Y), 4) + q, R += "up" + r(wt.length, 2) + wt), A && (z = r(1, 1) + r(d(dt), 4) + U, R += "uc" + r(z.length, 2) + z);
        var Pt = "";
        return Pt += `
\0`, Pt += r(at, 2), Pt += j.magic, Pt += r(k, 2), Pt += r(O, 2), Pt += r(At.crc32, 4), Pt += r(At.compressedSize, 4), Pt += r(At.uncompressedSize, 4), Pt += r(Y.length, 2), Pt += r(R.length, 2), { fileRecord: g.LOCAL_FILE_HEADER + Pt + Y + R, dirRecord: g.CENTRAL_FILE_HEADER + r(Ut, 2) + Pt + r(dt.length, 2) + "\0\0\0\0" + r(ot, 4) + r(I, 4) + Y + R + dt };
      }
      var l = e("../utils"), h = e("../stream/GenericWorker"), u = e("../utf8"), d = e("../crc32"), g = e("../signature");
      function y(m, x, b, I) {
        h.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = x, this.zipPlatform = b, this.encodeFileName = I, this.streamFiles = m, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = [];
      }
      l.inherits(y, h), y.prototype.push = function(m) {
        var x = m.meta.percent || 0, b = this.entriesCount, I = this._sources.length;
        this.accumulate ? this.contentBuffer.push(m) : (this.bytesWritten += m.data.length, h.prototype.push.call(this, { data: m.data, meta: { currentFile: this.currentFile, percent: b ? (x + 100 * (b - I - 1)) / b : 100 } }));
      }, y.prototype.openedSource = function(m) {
        this.currentSourceOffset = this.bytesWritten, this.currentFile = m.file.name;
        var x = this.streamFiles && !m.file.dir;
        if (x) {
          var b = o(m, x, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
          this.push({ data: b.fileRecord, meta: { percent: 0 } });
        } else
          this.accumulate = !0;
      }, y.prototype.closedSource = function(m) {
        this.accumulate = !1;
        var x = this.streamFiles && !m.file.dir, b = o(m, x, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        if (this.dirRecords.push(b.dirRecord), x)
          this.push({ data: function(I) {
            return g.DATA_DESCRIPTOR + r(I.crc32, 4) + r(I.compressedSize, 4) + r(I.uncompressedSize, 4);
          }(m), meta: { percent: 100 } });
        else
          for (this.push({ data: b.fileRecord, meta: { percent: 0 } }); this.contentBuffer.length; )
            this.push(this.contentBuffer.shift());
        this.currentFile = null;
      }, y.prototype.flush = function() {
        for (var m = this.bytesWritten, x = 0; x < this.dirRecords.length; x++)
          this.push({ data: this.dirRecords[x], meta: { percent: 100 } });
        var b = this.bytesWritten - m, I = function(C, P, k, O, B) {
          var j = l.transformTo("string", B(O));
          return g.CENTRAL_DIRECTORY_END + "\0\0\0\0" + r(C, 2) + r(C, 2) + r(P, 4) + r(k, 4) + r(j.length, 2) + j;
        }(this.dirRecords.length, b, m, this.zipComment, this.encodeFileName);
        this.push({ data: I, meta: { percent: 100 } });
      }, y.prototype.prepareNextSource = function() {
        this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume();
      }, y.prototype.registerPrevious = function(m) {
        this._sources.push(m);
        var x = this;
        return m.on("data", function(b) {
          x.processChunk(b);
        }), m.on("end", function() {
          x.closedSource(x.previous.streamInfo), x._sources.length ? x.prepareNextSource() : x.end();
        }), m.on("error", function(b) {
          x.error(b);
        }), this;
      }, y.prototype.resume = function() {
        return !!h.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0));
      }, y.prototype.error = function(m) {
        var x = this._sources;
        if (!h.prototype.error.call(this, m))
          return !1;
        for (var b = 0; b < x.length; b++)
          try {
            x[b].error(m);
          } catch {
          }
        return !0;
      }, y.prototype.lock = function() {
        h.prototype.lock.call(this);
        for (var m = this._sources, x = 0; x < m.length; x++)
          m[x].lock();
      }, i.exports = y;
    }, { "../crc32": 4, "../signature": 23, "../stream/GenericWorker": 28, "../utf8": 31, "../utils": 32 }], 9: [function(e, i, n) {
      var r = e("../compressions"), o = e("./ZipFileWorker");
      n.generateWorker = function(l, h, u) {
        var d = new o(h.streamFiles, u, h.platform, h.encodeFileName), g = 0;
        try {
          l.forEach(function(y, m) {
            g++;
            var x = function(P, k) {
              var O = P || k, B = r[O];
              if (!B)
                throw new Error(O + " is not a valid compression method !");
              return B;
            }(m.options.compression, h.compression), b = m.options.compressionOptions || h.compressionOptions || {}, I = m.dir, C = m.date;
            m._compressWorker(x, b).withStreamInfo("file", { name: y, dir: I, date: C, comment: m.comment || "", unixPermissions: m.unixPermissions, dosPermissions: m.dosPermissions }).pipe(d);
          }), d.entriesCount = g;
        } catch (y) {
          d.error(y);
        }
        return d;
      };
    }, { "../compressions": 3, "./ZipFileWorker": 8 }], 10: [function(e, i, n) {
      function r() {
        if (!(this instanceof r))
          return new r();
        if (arguments.length)
          throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
        this.files = /* @__PURE__ */ Object.create(null), this.comment = null, this.root = "", this.clone = function() {
          var o = new r();
          for (var l in this)
            typeof this[l] != "function" && (o[l] = this[l]);
          return o;
        };
      }
      (r.prototype = e("./object")).loadAsync = e("./load"), r.support = e("./support"), r.defaults = e("./defaults"), r.version = "3.10.1", r.loadAsync = function(o, l) {
        return new r().loadAsync(o, l);
      }, r.external = e("./external"), i.exports = r;
    }, { "./defaults": 5, "./external": 6, "./load": 11, "./object": 15, "./support": 30 }], 11: [function(e, i, n) {
      var r = e("./utils"), o = e("./external"), l = e("./utf8"), h = e("./zipEntries"), u = e("./stream/Crc32Probe"), d = e("./nodejsUtils");
      function g(y) {
        return new o.Promise(function(m, x) {
          var b = y.decompressed.getContentWorker().pipe(new u());
          b.on("error", function(I) {
            x(I);
          }).on("end", function() {
            b.streamInfo.crc32 !== y.decompressed.crc32 ? x(new Error("Corrupted zip : CRC32 mismatch")) : m();
          }).resume();
        });
      }
      i.exports = function(y, m) {
        var x = this;
        return m = r.extend(m || {}, { base64: !1, checkCRC32: !1, optimizedBinaryString: !1, createFolders: !1, decodeFileName: l.utf8decode }), d.isNode && d.isStream(y) ? o.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : r.prepareContent("the loaded zip file", y, !0, m.optimizedBinaryString, m.base64).then(function(b) {
          var I = new h(m);
          return I.load(b), I;
        }).then(function(b) {
          var I = [o.Promise.resolve(b)], C = b.files;
          if (m.checkCRC32)
            for (var P = 0; P < C.length; P++)
              I.push(g(C[P]));
          return o.Promise.all(I);
        }).then(function(b) {
          for (var I = b.shift(), C = I.files, P = 0; P < C.length; P++) {
            var k = C[P], O = k.fileNameStr, B = r.resolve(k.fileNameStr);
            x.file(B, k.decompressed, { binary: !0, optimizedBinaryString: !0, date: k.date, dir: k.dir, comment: k.fileCommentStr.length ? k.fileCommentStr : null, unixPermissions: k.unixPermissions, dosPermissions: k.dosPermissions, createFolders: m.createFolders }), k.dir || (x.file(B).unsafeOriginalName = O);
          }
          return I.zipComment.length && (x.comment = I.zipComment), x;
        });
      };
    }, { "./external": 6, "./nodejsUtils": 14, "./stream/Crc32Probe": 25, "./utf8": 31, "./utils": 32, "./zipEntries": 33 }], 12: [function(e, i, n) {
      var r = e("../utils"), o = e("../stream/GenericWorker");
      function l(h, u) {
        o.call(this, "Nodejs stream input adapter for " + h), this._upstreamEnded = !1, this._bindStream(u);
      }
      r.inherits(l, o), l.prototype._bindStream = function(h) {
        var u = this;
        (this._stream = h).pause(), h.on("data", function(d) {
          u.push({ data: d, meta: { percent: 0 } });
        }).on("error", function(d) {
          u.isPaused ? this.generatedError = d : u.error(d);
        }).on("end", function() {
          u.isPaused ? u._upstreamEnded = !0 : u.end();
        });
      }, l.prototype.pause = function() {
        return !!o.prototype.pause.call(this) && (this._stream.pause(), !0);
      }, l.prototype.resume = function() {
        return !!o.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0);
      }, i.exports = l;
    }, { "../stream/GenericWorker": 28, "../utils": 32 }], 13: [function(e, i, n) {
      var r = e("readable-stream").Readable;
      function o(l, h, u) {
        r.call(this, h), this._helper = l;
        var d = this;
        l.on("data", function(g, y) {
          d.push(g) || d._helper.pause(), u && u(y);
        }).on("error", function(g) {
          d.emit("error", g);
        }).on("end", function() {
          d.push(null);
        });
      }
      e("../utils").inherits(o, r), o.prototype._read = function() {
        this._helper.resume();
      }, i.exports = o;
    }, { "../utils": 32, "readable-stream": 16 }], 14: [function(e, i, n) {
      i.exports = { isNode: typeof Buffer < "u", newBufferFrom: function(r, o) {
        if (Buffer.from && Buffer.from !== Uint8Array.from)
          return Buffer.from(r, o);
        if (typeof r == "number")
          throw new Error('The "data" argument must not be a number');
        return new Buffer(r, o);
      }, allocBuffer: function(r) {
        if (Buffer.alloc)
          return Buffer.alloc(r);
        var o = new Buffer(r);
        return o.fill(0), o;
      }, isBuffer: function(r) {
        return Buffer.isBuffer(r);
      }, isStream: function(r) {
        return r && typeof r.on == "function" && typeof r.pause == "function" && typeof r.resume == "function";
      } };
    }, {}], 15: [function(e, i, n) {
      function r(B, j, V) {
        var Y, q = l.getTypeOf(j), st = l.extend(V || {}, d);
        st.date = st.date || /* @__PURE__ */ new Date(), st.compression !== null && (st.compression = st.compression.toUpperCase()), typeof st.unixPermissions == "string" && (st.unixPermissions = parseInt(st.unixPermissions, 8)), st.unixPermissions && 16384 & st.unixPermissions && (st.dir = !0), st.dosPermissions && 16 & st.dosPermissions && (st.dir = !0), st.dir && (B = C(B)), st.createFolders && (Y = I(B)) && P.call(this, Y, !0);
        var dt = q === "string" && st.binary === !1 && st.base64 === !1;
        V && V.binary !== void 0 || (st.binary = !dt), (j instanceof g && j.uncompressedSize === 0 || st.dir || !j || j.length === 0) && (st.base64 = !1, st.binary = !0, j = "", st.compression = "STORE", q = "string");
        var U = null;
        U = j instanceof g || j instanceof h ? j : x.isNode && x.isStream(j) ? new b(B, j) : l.prepareContent(B, j, st.binary, st.optimizedBinaryString, st.base64);
        var J = new y(B, U, st);
        this.files[B] = J;
      }
      var o = e("./utf8"), l = e("./utils"), h = e("./stream/GenericWorker"), u = e("./stream/StreamHelper"), d = e("./defaults"), g = e("./compressedObject"), y = e("./zipObject"), m = e("./generate"), x = e("./nodejsUtils"), b = e("./nodejs/NodejsStreamInputAdapter"), I = function(B) {
        B.slice(-1) === "/" && (B = B.substring(0, B.length - 1));
        var j = B.lastIndexOf("/");
        return 0 < j ? B.substring(0, j) : "";
      }, C = function(B) {
        return B.slice(-1) !== "/" && (B += "/"), B;
      }, P = function(B, j) {
        return j = j !== void 0 ? j : d.createFolders, B = C(B), this.files[B] || r.call(this, B, null, { dir: !0, createFolders: j }), this.files[B];
      };
      function k(B) {
        return Object.prototype.toString.call(B) === "[object RegExp]";
      }
      var O = { load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, forEach: function(B) {
        var j, V, Y;
        for (j in this.files)
          Y = this.files[j], (V = j.slice(this.root.length, j.length)) && j.slice(0, this.root.length) === this.root && B(V, Y);
      }, filter: function(B) {
        var j = [];
        return this.forEach(function(V, Y) {
          B(V, Y) && j.push(Y);
        }), j;
      }, file: function(B, j, V) {
        if (arguments.length !== 1)
          return B = this.root + B, r.call(this, B, j, V), this;
        if (k(B)) {
          var Y = B;
          return this.filter(function(st, dt) {
            return !dt.dir && Y.test(st);
          });
        }
        var q = this.files[this.root + B];
        return q && !q.dir ? q : null;
      }, folder: function(B) {
        if (!B)
          return this;
        if (k(B))
          return this.filter(function(q, st) {
            return st.dir && B.test(q);
          });
        var j = this.root + B, V = P.call(this, j), Y = this.clone();
        return Y.root = V.name, Y;
      }, remove: function(B) {
        B = this.root + B;
        var j = this.files[B];
        if (j || (B.slice(-1) !== "/" && (B += "/"), j = this.files[B]), j && !j.dir)
          delete this.files[B];
        else
          for (var V = this.filter(function(q, st) {
            return st.name.slice(0, B.length) === B;
          }), Y = 0; Y < V.length; Y++)
            delete this.files[V[Y].name];
        return this;
      }, generate: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, generateInternalStream: function(B) {
        var j, V = {};
        try {
          if ((V = l.extend(B || {}, { streamFiles: !1, compression: "STORE", compressionOptions: null, type: "", platform: "DOS", comment: null, mimeType: "application/zip", encodeFileName: o.utf8encode })).type = V.type.toLowerCase(), V.compression = V.compression.toUpperCase(), V.type === "binarystring" && (V.type = "string"), !V.type)
            throw new Error("No output type specified.");
          l.checkSupport(V.type), V.platform !== "darwin" && V.platform !== "freebsd" && V.platform !== "linux" && V.platform !== "sunos" || (V.platform = "UNIX"), V.platform === "win32" && (V.platform = "DOS");
          var Y = V.comment || this.comment || "";
          j = m.generateWorker(this, V, Y);
        } catch (q) {
          (j = new h("error")).error(q);
        }
        return new u(j, V.type || "string", V.mimeType);
      }, generateAsync: function(B, j) {
        return this.generateInternalStream(B).accumulate(j);
      }, generateNodeStream: function(B, j) {
        return (B = B || {}).type || (B.type = "nodebuffer"), this.generateInternalStream(B).toNodejsStream(j);
      } };
      i.exports = O;
    }, { "./compressedObject": 2, "./defaults": 5, "./generate": 9, "./nodejs/NodejsStreamInputAdapter": 12, "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31, "./utils": 32, "./zipObject": 35 }], 16: [function(e, i, n) {
      i.exports = e("stream");
    }, { stream: void 0 }], 17: [function(e, i, n) {
      var r = e("./DataReader");
      function o(l) {
        r.call(this, l);
        for (var h = 0; h < this.data.length; h++)
          l[h] = 255 & l[h];
      }
      e("../utils").inherits(o, r), o.prototype.byteAt = function(l) {
        return this.data[this.zero + l];
      }, o.prototype.lastIndexOfSignature = function(l) {
        for (var h = l.charCodeAt(0), u = l.charCodeAt(1), d = l.charCodeAt(2), g = l.charCodeAt(3), y = this.length - 4; 0 <= y; --y)
          if (this.data[y] === h && this.data[y + 1] === u && this.data[y + 2] === d && this.data[y + 3] === g)
            return y - this.zero;
        return -1;
      }, o.prototype.readAndCheckSignature = function(l) {
        var h = l.charCodeAt(0), u = l.charCodeAt(1), d = l.charCodeAt(2), g = l.charCodeAt(3), y = this.readData(4);
        return h === y[0] && u === y[1] && d === y[2] && g === y[3];
      }, o.prototype.readData = function(l) {
        if (this.checkOffset(l), l === 0)
          return [];
        var h = this.data.slice(this.zero + this.index, this.zero + this.index + l);
        return this.index += l, h;
      }, i.exports = o;
    }, { "../utils": 32, "./DataReader": 18 }], 18: [function(e, i, n) {
      var r = e("../utils");
      function o(l) {
        this.data = l, this.length = l.length, this.index = 0, this.zero = 0;
      }
      o.prototype = { checkOffset: function(l) {
        this.checkIndex(this.index + l);
      }, checkIndex: function(l) {
        if (this.length < this.zero + l || l < 0)
          throw new Error("End of data reached (data length = " + this.length + ", asked index = " + l + "). Corrupted zip ?");
      }, setIndex: function(l) {
        this.checkIndex(l), this.index = l;
      }, skip: function(l) {
        this.setIndex(this.index + l);
      }, byteAt: function() {
      }, readInt: function(l) {
        var h, u = 0;
        for (this.checkOffset(l), h = this.index + l - 1; h >= this.index; h--)
          u = (u << 8) + this.byteAt(h);
        return this.index += l, u;
      }, readString: function(l) {
        return r.transformTo("string", this.readData(l));
      }, readData: function() {
      }, lastIndexOfSignature: function() {
      }, readAndCheckSignature: function() {
      }, readDate: function() {
        var l = this.readInt(4);
        return new Date(Date.UTC(1980 + (l >> 25 & 127), (l >> 21 & 15) - 1, l >> 16 & 31, l >> 11 & 31, l >> 5 & 63, (31 & l) << 1));
      } }, i.exports = o;
    }, { "../utils": 32 }], 19: [function(e, i, n) {
      var r = e("./Uint8ArrayReader");
      function o(l) {
        r.call(this, l);
      }
      e("../utils").inherits(o, r), o.prototype.readData = function(l) {
        this.checkOffset(l);
        var h = this.data.slice(this.zero + this.index, this.zero + this.index + l);
        return this.index += l, h;
      }, i.exports = o;
    }, { "../utils": 32, "./Uint8ArrayReader": 21 }], 20: [function(e, i, n) {
      var r = e("./DataReader");
      function o(l) {
        r.call(this, l);
      }
      e("../utils").inherits(o, r), o.prototype.byteAt = function(l) {
        return this.data.charCodeAt(this.zero + l);
      }, o.prototype.lastIndexOfSignature = function(l) {
        return this.data.lastIndexOf(l) - this.zero;
      }, o.prototype.readAndCheckSignature = function(l) {
        return l === this.readData(4);
      }, o.prototype.readData = function(l) {
        this.checkOffset(l);
        var h = this.data.slice(this.zero + this.index, this.zero + this.index + l);
        return this.index += l, h;
      }, i.exports = o;
    }, { "../utils": 32, "./DataReader": 18 }], 21: [function(e, i, n) {
      var r = e("./ArrayReader");
      function o(l) {
        r.call(this, l);
      }
      e("../utils").inherits(o, r), o.prototype.readData = function(l) {
        if (this.checkOffset(l), l === 0)
          return new Uint8Array(0);
        var h = this.data.subarray(this.zero + this.index, this.zero + this.index + l);
        return this.index += l, h;
      }, i.exports = o;
    }, { "../utils": 32, "./ArrayReader": 17 }], 22: [function(e, i, n) {
      var r = e("../utils"), o = e("../support"), l = e("./ArrayReader"), h = e("./StringReader"), u = e("./NodeBufferReader"), d = e("./Uint8ArrayReader");
      i.exports = function(g) {
        var y = r.getTypeOf(g);
        return r.checkSupport(y), y !== "string" || o.uint8array ? y === "nodebuffer" ? new u(g) : o.uint8array ? new d(r.transformTo("uint8array", g)) : new l(r.transformTo("array", g)) : new h(g);
      };
    }, { "../support": 30, "../utils": 32, "./ArrayReader": 17, "./NodeBufferReader": 19, "./StringReader": 20, "./Uint8ArrayReader": 21 }], 23: [function(e, i, n) {
      n.LOCAL_FILE_HEADER = "PK", n.CENTRAL_FILE_HEADER = "PK", n.CENTRAL_DIRECTORY_END = "PK", n.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07", n.ZIP64_CENTRAL_DIRECTORY_END = "PK", n.DATA_DESCRIPTOR = "PK\x07\b";
    }, {}], 24: [function(e, i, n) {
      var r = e("./GenericWorker"), o = e("../utils");
      function l(h) {
        r.call(this, "ConvertWorker to " + h), this.destType = h;
      }
      o.inherits(l, r), l.prototype.processChunk = function(h) {
        this.push({ data: o.transformTo(this.destType, h.data), meta: h.meta });
      }, i.exports = l;
    }, { "../utils": 32, "./GenericWorker": 28 }], 25: [function(e, i, n) {
      var r = e("./GenericWorker"), o = e("../crc32");
      function l() {
        r.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0);
      }
      e("../utils").inherits(l, r), l.prototype.processChunk = function(h) {
        this.streamInfo.crc32 = o(h.data, this.streamInfo.crc32 || 0), this.push(h);
      }, i.exports = l;
    }, { "../crc32": 4, "../utils": 32, "./GenericWorker": 28 }], 26: [function(e, i, n) {
      var r = e("../utils"), o = e("./GenericWorker");
      function l(h) {
        o.call(this, "DataLengthProbe for " + h), this.propName = h, this.withStreamInfo(h, 0);
      }
      r.inherits(l, o), l.prototype.processChunk = function(h) {
        if (h) {
          var u = this.streamInfo[this.propName] || 0;
          this.streamInfo[this.propName] = u + h.data.length;
        }
        o.prototype.processChunk.call(this, h);
      }, i.exports = l;
    }, { "../utils": 32, "./GenericWorker": 28 }], 27: [function(e, i, n) {
      var r = e("../utils"), o = e("./GenericWorker");
      function l(h) {
        o.call(this, "DataWorker");
        var u = this;
        this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, h.then(function(d) {
          u.dataIsReady = !0, u.data = d, u.max = d && d.length || 0, u.type = r.getTypeOf(d), u.isPaused || u._tickAndRepeat();
        }, function(d) {
          u.error(d);
        });
      }
      r.inherits(l, o), l.prototype.cleanUp = function() {
        o.prototype.cleanUp.call(this), this.data = null;
      }, l.prototype.resume = function() {
        return !!o.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, r.delay(this._tickAndRepeat, [], this)), !0);
      }, l.prototype._tickAndRepeat = function() {
        this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (r.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0));
      }, l.prototype._tick = function() {
        if (this.isPaused || this.isFinished)
          return !1;
        var h = null, u = Math.min(this.max, this.index + 16384);
        if (this.index >= this.max)
          return this.end();
        switch (this.type) {
          case "string":
            h = this.data.substring(this.index, u);
            break;
          case "uint8array":
            h = this.data.subarray(this.index, u);
            break;
          case "array":
          case "nodebuffer":
            h = this.data.slice(this.index, u);
        }
        return this.index = u, this.push({ data: h, meta: { percent: this.max ? this.index / this.max * 100 : 0 } });
      }, i.exports = l;
    }, { "../utils": 32, "./GenericWorker": 28 }], 28: [function(e, i, n) {
      function r(o) {
        this.name = o || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = { data: [], end: [], error: [] }, this.previous = null;
      }
      r.prototype = { push: function(o) {
        this.emit("data", o);
      }, end: function() {
        if (this.isFinished)
          return !1;
        this.flush();
        try {
          this.emit("end"), this.cleanUp(), this.isFinished = !0;
        } catch (o) {
          this.emit("error", o);
        }
        return !0;
      }, error: function(o) {
        return !this.isFinished && (this.isPaused ? this.generatedError = o : (this.isFinished = !0, this.emit("error", o), this.previous && this.previous.error(o), this.cleanUp()), !0);
      }, on: function(o, l) {
        return this._listeners[o].push(l), this;
      }, cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = [];
      }, emit: function(o, l) {
        if (this._listeners[o])
          for (var h = 0; h < this._listeners[o].length; h++)
            this._listeners[o][h].call(this, l);
      }, pipe: function(o) {
        return o.registerPrevious(this);
      }, registerPrevious: function(o) {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.streamInfo = o.streamInfo, this.mergeStreamInfo(), this.previous = o;
        var l = this;
        return o.on("data", function(h) {
          l.processChunk(h);
        }), o.on("end", function() {
          l.end();
        }), o.on("error", function(h) {
          l.error(h);
        }), this;
      }, pause: function() {
        return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0);
      }, resume: function() {
        if (!this.isPaused || this.isFinished)
          return !1;
        var o = this.isPaused = !1;
        return this.generatedError && (this.error(this.generatedError), o = !0), this.previous && this.previous.resume(), !o;
      }, flush: function() {
      }, processChunk: function(o) {
        this.push(o);
      }, withStreamInfo: function(o, l) {
        return this.extraStreamInfo[o] = l, this.mergeStreamInfo(), this;
      }, mergeStreamInfo: function() {
        for (var o in this.extraStreamInfo)
          Object.prototype.hasOwnProperty.call(this.extraStreamInfo, o) && (this.streamInfo[o] = this.extraStreamInfo[o]);
      }, lock: function() {
        if (this.isLocked)
          throw new Error("The stream '" + this + "' has already been used.");
        this.isLocked = !0, this.previous && this.previous.lock();
      }, toString: function() {
        var o = "Worker " + this.name;
        return this.previous ? this.previous + " -> " + o : o;
      } }, i.exports = r;
    }, {}], 29: [function(e, i, n) {
      var r = e("../utils"), o = e("./ConvertWorker"), l = e("./GenericWorker"), h = e("../base64"), u = e("../support"), d = e("../external"), g = null;
      if (u.nodestream)
        try {
          g = e("../nodejs/NodejsStreamOutputAdapter");
        } catch {
        }
      function y(x, b) {
        return new d.Promise(function(I, C) {
          var P = [], k = x._internalType, O = x._outputType, B = x._mimeType;
          x.on("data", function(j, V) {
            P.push(j), b && b(V);
          }).on("error", function(j) {
            P = [], C(j);
          }).on("end", function() {
            try {
              var j = function(V, Y, q) {
                switch (V) {
                  case "blob":
                    return r.newBlob(r.transformTo("arraybuffer", Y), q);
                  case "base64":
                    return h.encode(Y);
                  default:
                    return r.transformTo(V, Y);
                }
              }(O, function(V, Y) {
                var q, st = 0, dt = null, U = 0;
                for (q = 0; q < Y.length; q++)
                  U += Y[q].length;
                switch (V) {
                  case "string":
                    return Y.join("");
                  case "array":
                    return Array.prototype.concat.apply([], Y);
                  case "uint8array":
                    for (dt = new Uint8Array(U), q = 0; q < Y.length; q++)
                      dt.set(Y[q], st), st += Y[q].length;
                    return dt;
                  case "nodebuffer":
                    return Buffer.concat(Y);
                  default:
                    throw new Error("concat : unsupported type '" + V + "'");
                }
              }(k, P), B);
              I(j);
            } catch (V) {
              C(V);
            }
            P = [];
          }).resume();
        });
      }
      function m(x, b, I) {
        var C = b;
        switch (b) {
          case "blob":
          case "arraybuffer":
            C = "uint8array";
            break;
          case "base64":
            C = "string";
        }
        try {
          this._internalType = C, this._outputType = b, this._mimeType = I, r.checkSupport(C), this._worker = x.pipe(new o(C)), x.lock();
        } catch (P) {
          this._worker = new l("error"), this._worker.error(P);
        }
      }
      m.prototype = { accumulate: function(x) {
        return y(this, x);
      }, on: function(x, b) {
        var I = this;
        return x === "data" ? this._worker.on(x, function(C) {
          b.call(I, C.data, C.meta);
        }) : this._worker.on(x, function() {
          r.delay(b, arguments, I);
        }), this;
      }, resume: function() {
        return r.delay(this._worker.resume, [], this._worker), this;
      }, pause: function() {
        return this._worker.pause(), this;
      }, toNodejsStream: function(x) {
        if (r.checkSupport("nodestream"), this._outputType !== "nodebuffer")
          throw new Error(this._outputType + " is not supported by this method");
        return new g(this, { objectMode: this._outputType !== "nodebuffer" }, x);
      } }, i.exports = m;
    }, { "../base64": 1, "../external": 6, "../nodejs/NodejsStreamOutputAdapter": 13, "../support": 30, "../utils": 32, "./ConvertWorker": 24, "./GenericWorker": 28 }], 30: [function(e, i, n) {
      if (n.base64 = !0, n.array = !0, n.string = !0, n.arraybuffer = typeof ArrayBuffer < "u" && typeof Uint8Array < "u", n.nodebuffer = typeof Buffer < "u", n.uint8array = typeof Uint8Array < "u", typeof ArrayBuffer > "u")
        n.blob = !1;
      else {
        var r = new ArrayBuffer(0);
        try {
          n.blob = new Blob([r], { type: "application/zip" }).size === 0;
        } catch {
          try {
            var o = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            o.append(r), n.blob = o.getBlob("application/zip").size === 0;
          } catch {
            n.blob = !1;
          }
        }
      }
      try {
        n.nodestream = !!e("readable-stream").Readable;
      } catch {
        n.nodestream = !1;
      }
    }, { "readable-stream": 16 }], 31: [function(e, i, n) {
      for (var r = e("./utils"), o = e("./support"), l = e("./nodejsUtils"), h = e("./stream/GenericWorker"), u = new Array(256), d = 0; d < 256; d++)
        u[d] = 252 <= d ? 6 : 248 <= d ? 5 : 240 <= d ? 4 : 224 <= d ? 3 : 192 <= d ? 2 : 1;
      u[254] = u[254] = 1;
      function g() {
        h.call(this, "utf-8 decode"), this.leftOver = null;
      }
      function y() {
        h.call(this, "utf-8 encode");
      }
      n.utf8encode = function(m) {
        return o.nodebuffer ? l.newBufferFrom(m, "utf-8") : function(x) {
          var b, I, C, P, k, O = x.length, B = 0;
          for (P = 0; P < O; P++)
            (64512 & (I = x.charCodeAt(P))) == 55296 && P + 1 < O && (64512 & (C = x.charCodeAt(P + 1))) == 56320 && (I = 65536 + (I - 55296 << 10) + (C - 56320), P++), B += I < 128 ? 1 : I < 2048 ? 2 : I < 65536 ? 3 : 4;
          for (b = o.uint8array ? new Uint8Array(B) : new Array(B), P = k = 0; k < B; P++)
            (64512 & (I = x.charCodeAt(P))) == 55296 && P + 1 < O && (64512 & (C = x.charCodeAt(P + 1))) == 56320 && (I = 65536 + (I - 55296 << 10) + (C - 56320), P++), I < 128 ? b[k++] = I : (I < 2048 ? b[k++] = 192 | I >>> 6 : (I < 65536 ? b[k++] = 224 | I >>> 12 : (b[k++] = 240 | I >>> 18, b[k++] = 128 | I >>> 12 & 63), b[k++] = 128 | I >>> 6 & 63), b[k++] = 128 | 63 & I);
          return b;
        }(m);
      }, n.utf8decode = function(m) {
        return o.nodebuffer ? r.transformTo("nodebuffer", m).toString("utf-8") : function(x) {
          var b, I, C, P, k = x.length, O = new Array(2 * k);
          for (b = I = 0; b < k; )
            if ((C = x[b++]) < 128)
              O[I++] = C;
            else if (4 < (P = u[C]))
              O[I++] = 65533, b += P - 1;
            else {
              for (C &= P === 2 ? 31 : P === 3 ? 15 : 7; 1 < P && b < k; )
                C = C << 6 | 63 & x[b++], P--;
              1 < P ? O[I++] = 65533 : C < 65536 ? O[I++] = C : (C -= 65536, O[I++] = 55296 | C >> 10 & 1023, O[I++] = 56320 | 1023 & C);
            }
          return O.length !== I && (O.subarray ? O = O.subarray(0, I) : O.length = I), r.applyFromCharCode(O);
        }(m = r.transformTo(o.uint8array ? "uint8array" : "array", m));
      }, r.inherits(g, h), g.prototype.processChunk = function(m) {
        var x = r.transformTo(o.uint8array ? "uint8array" : "array", m.data);
        if (this.leftOver && this.leftOver.length) {
          if (o.uint8array) {
            var b = x;
            (x = new Uint8Array(b.length + this.leftOver.length)).set(this.leftOver, 0), x.set(b, this.leftOver.length);
          } else
            x = this.leftOver.concat(x);
          this.leftOver = null;
        }
        var I = function(P, k) {
          var O;
          for ((k = k || P.length) > P.length && (k = P.length), O = k - 1; 0 <= O && (192 & P[O]) == 128; )
            O--;
          return O < 0 || O === 0 ? k : O + u[P[O]] > k ? O : k;
        }(x), C = x;
        I !== x.length && (o.uint8array ? (C = x.subarray(0, I), this.leftOver = x.subarray(I, x.length)) : (C = x.slice(0, I), this.leftOver = x.slice(I, x.length))), this.push({ data: n.utf8decode(C), meta: m.meta });
      }, g.prototype.flush = function() {
        this.leftOver && this.leftOver.length && (this.push({ data: n.utf8decode(this.leftOver), meta: {} }), this.leftOver = null);
      }, n.Utf8DecodeWorker = g, r.inherits(y, h), y.prototype.processChunk = function(m) {
        this.push({ data: n.utf8encode(m.data), meta: m.meta });
      }, n.Utf8EncodeWorker = y;
    }, { "./nodejsUtils": 14, "./stream/GenericWorker": 28, "./support": 30, "./utils": 32 }], 32: [function(e, i, n) {
      var r = e("./support"), o = e("./base64"), l = e("./nodejsUtils"), h = e("./external");
      function u(b) {
        return b;
      }
      function d(b, I) {
        for (var C = 0; C < b.length; ++C)
          I[C] = 255 & b.charCodeAt(C);
        return I;
      }
      e("setimmediate"), n.newBlob = function(b, I) {
        n.checkSupport("blob");
        try {
          return new Blob([b], { type: I });
        } catch {
          try {
            var C = new (self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder)();
            return C.append(b), C.getBlob(I);
          } catch {
            throw new Error("Bug : can't construct the Blob.");
          }
        }
      };
      var g = { stringifyByChunk: function(b, I, C) {
        var P = [], k = 0, O = b.length;
        if (O <= C)
          return String.fromCharCode.apply(null, b);
        for (; k < O; )
          I === "array" || I === "nodebuffer" ? P.push(String.fromCharCode.apply(null, b.slice(k, Math.min(k + C, O)))) : P.push(String.fromCharCode.apply(null, b.subarray(k, Math.min(k + C, O)))), k += C;
        return P.join("");
      }, stringifyByChar: function(b) {
        for (var I = "", C = 0; C < b.length; C++)
          I += String.fromCharCode(b[C]);
        return I;
      }, applyCanBeUsed: { uint8array: function() {
        try {
          return r.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
        } catch {
          return !1;
        }
      }(), nodebuffer: function() {
        try {
          return r.nodebuffer && String.fromCharCode.apply(null, l.allocBuffer(1)).length === 1;
        } catch {
          return !1;
        }
      }() } };
      function y(b) {
        var I = 65536, C = n.getTypeOf(b), P = !0;
        if (C === "uint8array" ? P = g.applyCanBeUsed.uint8array : C === "nodebuffer" && (P = g.applyCanBeUsed.nodebuffer), P)
          for (; 1 < I; )
            try {
              return g.stringifyByChunk(b, C, I);
            } catch {
              I = Math.floor(I / 2);
            }
        return g.stringifyByChar(b);
      }
      function m(b, I) {
        for (var C = 0; C < b.length; C++)
          I[C] = b[C];
        return I;
      }
      n.applyFromCharCode = y;
      var x = {};
      x.string = { string: u, array: function(b) {
        return d(b, new Array(b.length));
      }, arraybuffer: function(b) {
        return x.string.uint8array(b).buffer;
      }, uint8array: function(b) {
        return d(b, new Uint8Array(b.length));
      }, nodebuffer: function(b) {
        return d(b, l.allocBuffer(b.length));
      } }, x.array = { string: y, array: u, arraybuffer: function(b) {
        return new Uint8Array(b).buffer;
      }, uint8array: function(b) {
        return new Uint8Array(b);
      }, nodebuffer: function(b) {
        return l.newBufferFrom(b);
      } }, x.arraybuffer = { string: function(b) {
        return y(new Uint8Array(b));
      }, array: function(b) {
        return m(new Uint8Array(b), new Array(b.byteLength));
      }, arraybuffer: u, uint8array: function(b) {
        return new Uint8Array(b);
      }, nodebuffer: function(b) {
        return l.newBufferFrom(new Uint8Array(b));
      } }, x.uint8array = { string: y, array: function(b) {
        return m(b, new Array(b.length));
      }, arraybuffer: function(b) {
        return b.buffer;
      }, uint8array: u, nodebuffer: function(b) {
        return l.newBufferFrom(b);
      } }, x.nodebuffer = { string: y, array: function(b) {
        return m(b, new Array(b.length));
      }, arraybuffer: function(b) {
        return x.nodebuffer.uint8array(b).buffer;
      }, uint8array: function(b) {
        return m(b, new Uint8Array(b.length));
      }, nodebuffer: u }, n.transformTo = function(b, I) {
        if (I = I || "", !b)
          return I;
        n.checkSupport(b);
        var C = n.getTypeOf(I);
        return x[C][b](I);
      }, n.resolve = function(b) {
        for (var I = b.split("/"), C = [], P = 0; P < I.length; P++) {
          var k = I[P];
          k === "." || k === "" && P !== 0 && P !== I.length - 1 || (k === ".." ? C.pop() : C.push(k));
        }
        return C.join("/");
      }, n.getTypeOf = function(b) {
        return typeof b == "string" ? "string" : Object.prototype.toString.call(b) === "[object Array]" ? "array" : r.nodebuffer && l.isBuffer(b) ? "nodebuffer" : r.uint8array && b instanceof Uint8Array ? "uint8array" : r.arraybuffer && b instanceof ArrayBuffer ? "arraybuffer" : void 0;
      }, n.checkSupport = function(b) {
        if (!r[b.toLowerCase()])
          throw new Error(b + " is not supported by this platform");
      }, n.MAX_VALUE_16BITS = 65535, n.MAX_VALUE_32BITS = -1, n.pretty = function(b) {
        var I, C, P = "";
        for (C = 0; C < (b || "").length; C++)
          P += "\\x" + ((I = b.charCodeAt(C)) < 16 ? "0" : "") + I.toString(16).toUpperCase();
        return P;
      }, n.delay = function(b, I, C) {
        setImmediate(function() {
          b.apply(C || null, I || []);
        });
      }, n.inherits = function(b, I) {
        function C() {
        }
        C.prototype = I.prototype, b.prototype = new C();
      }, n.extend = function() {
        var b, I, C = {};
        for (b = 0; b < arguments.length; b++)
          for (I in arguments[b])
            Object.prototype.hasOwnProperty.call(arguments[b], I) && C[I] === void 0 && (C[I] = arguments[b][I]);
        return C;
      }, n.prepareContent = function(b, I, C, P, k) {
        return h.Promise.resolve(I).then(function(O) {
          return r.blob && (O instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(O)) !== -1) && typeof FileReader < "u" ? new h.Promise(function(B, j) {
            var V = new FileReader();
            V.onload = function(Y) {
              B(Y.target.result);
            }, V.onerror = function(Y) {
              j(Y.target.error);
            }, V.readAsArrayBuffer(O);
          }) : O;
        }).then(function(O) {
          var B = n.getTypeOf(O);
          return B ? (B === "arraybuffer" ? O = n.transformTo("uint8array", O) : B === "string" && (k ? O = o.decode(O) : C && P !== !0 && (O = function(j) {
            return d(j, r.uint8array ? new Uint8Array(j.length) : new Array(j.length));
          }(O))), O) : h.Promise.reject(new Error("Can't read the data of '" + b + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"));
        });
      };
    }, { "./base64": 1, "./external": 6, "./nodejsUtils": 14, "./support": 30, setimmediate: 54 }], 33: [function(e, i, n) {
      var r = e("./reader/readerFor"), o = e("./utils"), l = e("./signature"), h = e("./zipEntry"), u = e("./support");
      function d(g) {
        this.files = [], this.loadOptions = g;
      }
      d.prototype = { checkSignature: function(g) {
        if (!this.reader.readAndCheckSignature(g)) {
          this.reader.index -= 4;
          var y = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + o.pretty(y) + ", expected " + o.pretty(g) + ")");
        }
      }, isSignature: function(g, y) {
        var m = this.reader.index;
        this.reader.setIndex(g);
        var x = this.reader.readString(4) === y;
        return this.reader.setIndex(m), x;
      }, readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
        var g = this.reader.readData(this.zipCommentLength), y = u.uint8array ? "uint8array" : "array", m = o.transformTo(y, g);
        this.zipComment = this.loadOptions.decodeFileName(m);
      }, readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
        for (var g, y, m, x = this.zip64EndOfCentralSize - 44; 0 < x; )
          g = this.reader.readInt(2), y = this.reader.readInt(4), m = this.reader.readData(y), this.zip64ExtensibleData[g] = { id: g, length: y, value: m };
      }, readBlockZip64EndOfCentralLocator: function() {
        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), 1 < this.disksCount)
          throw new Error("Multi-volumes zip are not supported");
      }, readLocalFiles: function() {
        var g, y;
        for (g = 0; g < this.files.length; g++)
          y = this.files[g], this.reader.setIndex(y.localHeaderOffset), this.checkSignature(l.LOCAL_FILE_HEADER), y.readLocalPart(this.reader), y.handleUTF8(), y.processAttributes();
      }, readCentralDir: function() {
        var g;
        for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(l.CENTRAL_FILE_HEADER); )
          (g = new h({ zip64: this.zip64 }, this.loadOptions)).readCentralPart(this.reader), this.files.push(g);
        if (this.centralDirRecords !== this.files.length && this.centralDirRecords !== 0 && this.files.length === 0)
          throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
      }, readEndOfCentral: function() {
        var g = this.reader.lastIndexOfSignature(l.CENTRAL_DIRECTORY_END);
        if (g < 0)
          throw this.isSignature(0, l.LOCAL_FILE_HEADER) ? new Error("Corrupted zip: can't find end of central directory") : new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
        this.reader.setIndex(g);
        var y = g;
        if (this.checkSignature(l.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === o.MAX_VALUE_16BITS || this.diskWithCentralDirStart === o.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === o.MAX_VALUE_16BITS || this.centralDirRecords === o.MAX_VALUE_16BITS || this.centralDirSize === o.MAX_VALUE_32BITS || this.centralDirOffset === o.MAX_VALUE_32BITS) {
          if (this.zip64 = !0, (g = this.reader.lastIndexOfSignature(l.ZIP64_CENTRAL_DIRECTORY_LOCATOR)) < 0)
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          if (this.reader.setIndex(g), this.checkSignature(l.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, l.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(l.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0))
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(l.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral();
        }
        var m = this.centralDirOffset + this.centralDirSize;
        this.zip64 && (m += 20, m += 12 + this.zip64EndOfCentralSize);
        var x = y - m;
        if (0 < x)
          this.isSignature(y, l.CENTRAL_FILE_HEADER) || (this.reader.zero = x);
        else if (x < 0)
          throw new Error("Corrupted zip: missing " + Math.abs(x) + " bytes.");
      }, prepareReader: function(g) {
        this.reader = r(g);
      }, load: function(g) {
        this.prepareReader(g), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles();
      } }, i.exports = d;
    }, { "./reader/readerFor": 22, "./signature": 23, "./support": 30, "./utils": 32, "./zipEntry": 34 }], 34: [function(e, i, n) {
      var r = e("./reader/readerFor"), o = e("./utils"), l = e("./compressedObject"), h = e("./crc32"), u = e("./utf8"), d = e("./compressions"), g = e("./support");
      function y(m, x) {
        this.options = m, this.loadOptions = x;
      }
      y.prototype = { isEncrypted: function() {
        return (1 & this.bitFlag) == 1;
      }, useUTF8: function() {
        return (2048 & this.bitFlag) == 2048;
      }, readLocalPart: function(m) {
        var x, b;
        if (m.skip(22), this.fileNameLength = m.readInt(2), b = m.readInt(2), this.fileName = m.readData(this.fileNameLength), m.skip(b), this.compressedSize === -1 || this.uncompressedSize === -1)
          throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        if ((x = function(I) {
          for (var C in d)
            if (Object.prototype.hasOwnProperty.call(d, C) && d[C].magic === I)
              return d[C];
          return null;
        }(this.compressionMethod)) === null)
          throw new Error("Corrupted zip : compression " + o.pretty(this.compressionMethod) + " unknown (inner file : " + o.transformTo("string", this.fileName) + ")");
        this.decompressed = new l(this.compressedSize, this.uncompressedSize, this.crc32, x, m.readData(this.compressedSize));
      }, readCentralPart: function(m) {
        this.versionMadeBy = m.readInt(2), m.skip(2), this.bitFlag = m.readInt(2), this.compressionMethod = m.readString(2), this.date = m.readDate(), this.crc32 = m.readInt(4), this.compressedSize = m.readInt(4), this.uncompressedSize = m.readInt(4);
        var x = m.readInt(2);
        if (this.extraFieldsLength = m.readInt(2), this.fileCommentLength = m.readInt(2), this.diskNumberStart = m.readInt(2), this.internalFileAttributes = m.readInt(2), this.externalFileAttributes = m.readInt(4), this.localHeaderOffset = m.readInt(4), this.isEncrypted())
          throw new Error("Encrypted zip are not supported");
        m.skip(x), this.readExtraFields(m), this.parseZIP64ExtraField(m), this.fileComment = m.readData(this.fileCommentLength);
      }, processAttributes: function() {
        this.unixPermissions = null, this.dosPermissions = null;
        var m = this.versionMadeBy >> 8;
        this.dir = !!(16 & this.externalFileAttributes), m == 0 && (this.dosPermissions = 63 & this.externalFileAttributes), m == 3 && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || this.fileNameStr.slice(-1) !== "/" || (this.dir = !0);
      }, parseZIP64ExtraField: function() {
        if (this.extraFields[1]) {
          var m = r(this.extraFields[1].value);
          this.uncompressedSize === o.MAX_VALUE_32BITS && (this.uncompressedSize = m.readInt(8)), this.compressedSize === o.MAX_VALUE_32BITS && (this.compressedSize = m.readInt(8)), this.localHeaderOffset === o.MAX_VALUE_32BITS && (this.localHeaderOffset = m.readInt(8)), this.diskNumberStart === o.MAX_VALUE_32BITS && (this.diskNumberStart = m.readInt(4));
        }
      }, readExtraFields: function(m) {
        var x, b, I, C = m.index + this.extraFieldsLength;
        for (this.extraFields || (this.extraFields = {}); m.index + 4 < C; )
          x = m.readInt(2), b = m.readInt(2), I = m.readData(b), this.extraFields[x] = { id: x, length: b, value: I };
        m.setIndex(C);
      }, handleUTF8: function() {
        var m = g.uint8array ? "uint8array" : "array";
        if (this.useUTF8())
          this.fileNameStr = u.utf8decode(this.fileName), this.fileCommentStr = u.utf8decode(this.fileComment);
        else {
          var x = this.findExtraFieldUnicodePath();
          if (x !== null)
            this.fileNameStr = x;
          else {
            var b = o.transformTo(m, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(b);
          }
          var I = this.findExtraFieldUnicodeComment();
          if (I !== null)
            this.fileCommentStr = I;
          else {
            var C = o.transformTo(m, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(C);
          }
        }
      }, findExtraFieldUnicodePath: function() {
        var m = this.extraFields[28789];
        if (m) {
          var x = r(m.value);
          return x.readInt(1) !== 1 || h(this.fileName) !== x.readInt(4) ? null : u.utf8decode(x.readData(m.length - 5));
        }
        return null;
      }, findExtraFieldUnicodeComment: function() {
        var m = this.extraFields[25461];
        if (m) {
          var x = r(m.value);
          return x.readInt(1) !== 1 || h(this.fileComment) !== x.readInt(4) ? null : u.utf8decode(x.readData(m.length - 5));
        }
        return null;
      } }, i.exports = y;
    }, { "./compressedObject": 2, "./compressions": 3, "./crc32": 4, "./reader/readerFor": 22, "./support": 30, "./utf8": 31, "./utils": 32 }], 35: [function(e, i, n) {
      function r(x, b, I) {
        this.name = x, this.dir = I.dir, this.date = I.date, this.comment = I.comment, this.unixPermissions = I.unixPermissions, this.dosPermissions = I.dosPermissions, this._data = b, this._dataBinary = I.binary, this.options = { compression: I.compression, compressionOptions: I.compressionOptions };
      }
      var o = e("./stream/StreamHelper"), l = e("./stream/DataWorker"), h = e("./utf8"), u = e("./compressedObject"), d = e("./stream/GenericWorker");
      r.prototype = { internalStream: function(x) {
        var b = null, I = "string";
        try {
          if (!x)
            throw new Error("No output type specified.");
          var C = (I = x.toLowerCase()) === "string" || I === "text";
          I !== "binarystring" && I !== "text" || (I = "string"), b = this._decompressWorker();
          var P = !this._dataBinary;
          P && !C && (b = b.pipe(new h.Utf8EncodeWorker())), !P && C && (b = b.pipe(new h.Utf8DecodeWorker()));
        } catch (k) {
          (b = new d("error")).error(k);
        }
        return new o(b, I, "");
      }, async: function(x, b) {
        return this.internalStream(x).accumulate(b);
      }, nodeStream: function(x, b) {
        return this.internalStream(x || "nodebuffer").toNodejsStream(b);
      }, _compressWorker: function(x, b) {
        if (this._data instanceof u && this._data.compression.magic === x.magic)
          return this._data.getCompressedWorker();
        var I = this._decompressWorker();
        return this._dataBinary || (I = I.pipe(new h.Utf8EncodeWorker())), u.createWorkerFrom(I, x, b);
      }, _decompressWorker: function() {
        return this._data instanceof u ? this._data.getContentWorker() : this._data instanceof d ? this._data : new l(this._data);
      } };
      for (var g = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], y = function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      }, m = 0; m < g.length; m++)
        r.prototype[g[m]] = y;
      i.exports = r;
    }, { "./compressedObject": 2, "./stream/DataWorker": 27, "./stream/GenericWorker": 28, "./stream/StreamHelper": 29, "./utf8": 31 }], 36: [function(e, i, n) {
      (function(r) {
        var o, l, h = r.MutationObserver || r.WebKitMutationObserver;
        if (h) {
          var u = 0, d = new h(x), g = r.document.createTextNode("");
          d.observe(g, { characterData: !0 }), o = function() {
            g.data = u = ++u % 2;
          };
        } else if (r.setImmediate || r.MessageChannel === void 0)
          o = "document" in r && "onreadystatechange" in r.document.createElement("script") ? function() {
            var b = r.document.createElement("script");
            b.onreadystatechange = function() {
              x(), b.onreadystatechange = null, b.parentNode.removeChild(b), b = null;
            }, r.document.documentElement.appendChild(b);
          } : function() {
            setTimeout(x, 0);
          };
        else {
          var y = new r.MessageChannel();
          y.port1.onmessage = x, o = function() {
            y.port2.postMessage(0);
          };
        }
        var m = [];
        function x() {
          var b, I;
          l = !0;
          for (var C = m.length; C; ) {
            for (I = m, m = [], b = -1; ++b < C; )
              I[b]();
            C = m.length;
          }
          l = !1;
        }
        i.exports = function(b) {
          m.push(b) !== 1 || l || o();
        };
      }).call(this, typeof ga < "u" ? ga : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 37: [function(e, i, n) {
      var r = e("immediate");
      function o() {
      }
      var l = {}, h = ["REJECTED"], u = ["FULFILLED"], d = ["PENDING"];
      function g(C) {
        if (typeof C != "function")
          throw new TypeError("resolver must be a function");
        this.state = d, this.queue = [], this.outcome = void 0, C !== o && b(this, C);
      }
      function y(C, P, k) {
        this.promise = C, typeof P == "function" && (this.onFulfilled = P, this.callFulfilled = this.otherCallFulfilled), typeof k == "function" && (this.onRejected = k, this.callRejected = this.otherCallRejected);
      }
      function m(C, P, k) {
        r(function() {
          var O;
          try {
            O = P(k);
          } catch (B) {
            return l.reject(C, B);
          }
          O === C ? l.reject(C, new TypeError("Cannot resolve promise with itself")) : l.resolve(C, O);
        });
      }
      function x(C) {
        var P = C && C.then;
        if (C && (typeof C == "object" || typeof C == "function") && typeof P == "function")
          return function() {
            P.apply(C, arguments);
          };
      }
      function b(C, P) {
        var k = !1;
        function O(V) {
          k || (k = !0, l.reject(C, V));
        }
        function B(V) {
          k || (k = !0, l.resolve(C, V));
        }
        var j = I(function() {
          P(B, O);
        });
        j.status === "error" && O(j.value);
      }
      function I(C, P) {
        var k = {};
        try {
          k.value = C(P), k.status = "success";
        } catch (O) {
          k.status = "error", k.value = O;
        }
        return k;
      }
      (i.exports = g).prototype.finally = function(C) {
        if (typeof C != "function")
          return this;
        var P = this.constructor;
        return this.then(function(k) {
          return P.resolve(C()).then(function() {
            return k;
          });
        }, function(k) {
          return P.resolve(C()).then(function() {
            throw k;
          });
        });
      }, g.prototype.catch = function(C) {
        return this.then(null, C);
      }, g.prototype.then = function(C, P) {
        if (typeof C != "function" && this.state === u || typeof P != "function" && this.state === h)
          return this;
        var k = new this.constructor(o);
        return this.state !== d ? m(k, this.state === u ? C : P, this.outcome) : this.queue.push(new y(k, C, P)), k;
      }, y.prototype.callFulfilled = function(C) {
        l.resolve(this.promise, C);
      }, y.prototype.otherCallFulfilled = function(C) {
        m(this.promise, this.onFulfilled, C);
      }, y.prototype.callRejected = function(C) {
        l.reject(this.promise, C);
      }, y.prototype.otherCallRejected = function(C) {
        m(this.promise, this.onRejected, C);
      }, l.resolve = function(C, P) {
        var k = I(x, P);
        if (k.status === "error")
          return l.reject(C, k.value);
        var O = k.value;
        if (O)
          b(C, O);
        else {
          C.state = u, C.outcome = P;
          for (var B = -1, j = C.queue.length; ++B < j; )
            C.queue[B].callFulfilled(P);
        }
        return C;
      }, l.reject = function(C, P) {
        C.state = h, C.outcome = P;
        for (var k = -1, O = C.queue.length; ++k < O; )
          C.queue[k].callRejected(P);
        return C;
      }, g.resolve = function(C) {
        return C instanceof this ? C : l.resolve(new this(o), C);
      }, g.reject = function(C) {
        var P = new this(o);
        return l.reject(P, C);
      }, g.all = function(C) {
        var P = this;
        if (Object.prototype.toString.call(C) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var k = C.length, O = !1;
        if (!k)
          return this.resolve([]);
        for (var B = new Array(k), j = 0, V = -1, Y = new this(o); ++V < k; )
          q(C[V], V);
        return Y;
        function q(st, dt) {
          P.resolve(st).then(function(U) {
            B[dt] = U, ++j !== k || O || (O = !0, l.resolve(Y, B));
          }, function(U) {
            O || (O = !0, l.reject(Y, U));
          });
        }
      }, g.race = function(C) {
        var P = this;
        if (Object.prototype.toString.call(C) !== "[object Array]")
          return this.reject(new TypeError("must be an array"));
        var k = C.length, O = !1;
        if (!k)
          return this.resolve([]);
        for (var B = -1, j = new this(o); ++B < k; )
          V = C[B], P.resolve(V).then(function(Y) {
            O || (O = !0, l.resolve(j, Y));
          }, function(Y) {
            O || (O = !0, l.reject(j, Y));
          });
        var V;
        return j;
      };
    }, { immediate: 36 }], 38: [function(e, i, n) {
      var r = {};
      (0, e("./lib/utils/common").assign)(r, e("./lib/deflate"), e("./lib/inflate"), e("./lib/zlib/constants")), i.exports = r;
    }, { "./lib/deflate": 39, "./lib/inflate": 40, "./lib/utils/common": 41, "./lib/zlib/constants": 44 }], 39: [function(e, i, n) {
      var r = e("./zlib/deflate"), o = e("./utils/common"), l = e("./utils/strings"), h = e("./zlib/messages"), u = e("./zlib/zstream"), d = Object.prototype.toString, g = 0, y = -1, m = 0, x = 8;
      function b(C) {
        if (!(this instanceof b))
          return new b(C);
        this.options = o.assign({ level: y, method: x, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: m, to: "" }, C || {});
        var P = this.options;
        P.raw && 0 < P.windowBits ? P.windowBits = -P.windowBits : P.gzip && 0 < P.windowBits && P.windowBits < 16 && (P.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new u(), this.strm.avail_out = 0;
        var k = r.deflateInit2(this.strm, P.level, P.method, P.windowBits, P.memLevel, P.strategy);
        if (k !== g)
          throw new Error(h[k]);
        if (P.header && r.deflateSetHeader(this.strm, P.header), P.dictionary) {
          var O;
          if (O = typeof P.dictionary == "string" ? l.string2buf(P.dictionary) : d.call(P.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(P.dictionary) : P.dictionary, (k = r.deflateSetDictionary(this.strm, O)) !== g)
            throw new Error(h[k]);
          this._dict_set = !0;
        }
      }
      function I(C, P) {
        var k = new b(P);
        if (k.push(C, !0), k.err)
          throw k.msg || h[k.err];
        return k.result;
      }
      b.prototype.push = function(C, P) {
        var k, O, B = this.strm, j = this.options.chunkSize;
        if (this.ended)
          return !1;
        O = P === ~~P ? P : P === !0 ? 4 : 0, typeof C == "string" ? B.input = l.string2buf(C) : d.call(C) === "[object ArrayBuffer]" ? B.input = new Uint8Array(C) : B.input = C, B.next_in = 0, B.avail_in = B.input.length;
        do {
          if (B.avail_out === 0 && (B.output = new o.Buf8(j), B.next_out = 0, B.avail_out = j), (k = r.deflate(B, O)) !== 1 && k !== g)
            return this.onEnd(k), !(this.ended = !0);
          B.avail_out !== 0 && (B.avail_in !== 0 || O !== 4 && O !== 2) || (this.options.to === "string" ? this.onData(l.buf2binstring(o.shrinkBuf(B.output, B.next_out))) : this.onData(o.shrinkBuf(B.output, B.next_out)));
        } while ((0 < B.avail_in || B.avail_out === 0) && k !== 1);
        return O === 4 ? (k = r.deflateEnd(this.strm), this.onEnd(k), this.ended = !0, k === g) : O !== 2 || (this.onEnd(g), !(B.avail_out = 0));
      }, b.prototype.onData = function(C) {
        this.chunks.push(C);
      }, b.prototype.onEnd = function(C) {
        C === g && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = C, this.msg = this.strm.msg;
      }, n.Deflate = b, n.deflate = I, n.deflateRaw = function(C, P) {
        return (P = P || {}).raw = !0, I(C, P);
      }, n.gzip = function(C, P) {
        return (P = P || {}).gzip = !0, I(C, P);
      };
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/deflate": 46, "./zlib/messages": 51, "./zlib/zstream": 53 }], 40: [function(e, i, n) {
      var r = e("./zlib/inflate"), o = e("./utils/common"), l = e("./utils/strings"), h = e("./zlib/constants"), u = e("./zlib/messages"), d = e("./zlib/zstream"), g = e("./zlib/gzheader"), y = Object.prototype.toString;
      function m(b) {
        if (!(this instanceof m))
          return new m(b);
        this.options = o.assign({ chunkSize: 16384, windowBits: 0, to: "" }, b || {});
        var I = this.options;
        I.raw && 0 <= I.windowBits && I.windowBits < 16 && (I.windowBits = -I.windowBits, I.windowBits === 0 && (I.windowBits = -15)), !(0 <= I.windowBits && I.windowBits < 16) || b && b.windowBits || (I.windowBits += 32), 15 < I.windowBits && I.windowBits < 48 && !(15 & I.windowBits) && (I.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new d(), this.strm.avail_out = 0;
        var C = r.inflateInit2(this.strm, I.windowBits);
        if (C !== h.Z_OK)
          throw new Error(u[C]);
        this.header = new g(), r.inflateGetHeader(this.strm, this.header);
      }
      function x(b, I) {
        var C = new m(I);
        if (C.push(b, !0), C.err)
          throw C.msg || u[C.err];
        return C.result;
      }
      m.prototype.push = function(b, I) {
        var C, P, k, O, B, j, V = this.strm, Y = this.options.chunkSize, q = this.options.dictionary, st = !1;
        if (this.ended)
          return !1;
        P = I === ~~I ? I : I === !0 ? h.Z_FINISH : h.Z_NO_FLUSH, typeof b == "string" ? V.input = l.binstring2buf(b) : y.call(b) === "[object ArrayBuffer]" ? V.input = new Uint8Array(b) : V.input = b, V.next_in = 0, V.avail_in = V.input.length;
        do {
          if (V.avail_out === 0 && (V.output = new o.Buf8(Y), V.next_out = 0, V.avail_out = Y), (C = r.inflate(V, h.Z_NO_FLUSH)) === h.Z_NEED_DICT && q && (j = typeof q == "string" ? l.string2buf(q) : y.call(q) === "[object ArrayBuffer]" ? new Uint8Array(q) : q, C = r.inflateSetDictionary(this.strm, j)), C === h.Z_BUF_ERROR && st === !0 && (C = h.Z_OK, st = !1), C !== h.Z_STREAM_END && C !== h.Z_OK)
            return this.onEnd(C), !(this.ended = !0);
          V.next_out && (V.avail_out !== 0 && C !== h.Z_STREAM_END && (V.avail_in !== 0 || P !== h.Z_FINISH && P !== h.Z_SYNC_FLUSH) || (this.options.to === "string" ? (k = l.utf8border(V.output, V.next_out), O = V.next_out - k, B = l.buf2string(V.output, k), V.next_out = O, V.avail_out = Y - O, O && o.arraySet(V.output, V.output, k, O, 0), this.onData(B)) : this.onData(o.shrinkBuf(V.output, V.next_out)))), V.avail_in === 0 && V.avail_out === 0 && (st = !0);
        } while ((0 < V.avail_in || V.avail_out === 0) && C !== h.Z_STREAM_END);
        return C === h.Z_STREAM_END && (P = h.Z_FINISH), P === h.Z_FINISH ? (C = r.inflateEnd(this.strm), this.onEnd(C), this.ended = !0, C === h.Z_OK) : P !== h.Z_SYNC_FLUSH || (this.onEnd(h.Z_OK), !(V.avail_out = 0));
      }, m.prototype.onData = function(b) {
        this.chunks.push(b);
      }, m.prototype.onEnd = function(b) {
        b === h.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = o.flattenChunks(this.chunks)), this.chunks = [], this.err = b, this.msg = this.strm.msg;
      }, n.Inflate = m, n.inflate = x, n.inflateRaw = function(b, I) {
        return (I = I || {}).raw = !0, x(b, I);
      }, n.ungzip = x;
    }, { "./utils/common": 41, "./utils/strings": 42, "./zlib/constants": 44, "./zlib/gzheader": 47, "./zlib/inflate": 49, "./zlib/messages": 51, "./zlib/zstream": 53 }], 41: [function(e, i, n) {
      var r = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
      n.assign = function(h) {
        for (var u = Array.prototype.slice.call(arguments, 1); u.length; ) {
          var d = u.shift();
          if (d) {
            if (typeof d != "object")
              throw new TypeError(d + "must be non-object");
            for (var g in d)
              d.hasOwnProperty(g) && (h[g] = d[g]);
          }
        }
        return h;
      }, n.shrinkBuf = function(h, u) {
        return h.length === u ? h : h.subarray ? h.subarray(0, u) : (h.length = u, h);
      };
      var o = { arraySet: function(h, u, d, g, y) {
        if (u.subarray && h.subarray)
          h.set(u.subarray(d, d + g), y);
        else
          for (var m = 0; m < g; m++)
            h[y + m] = u[d + m];
      }, flattenChunks: function(h) {
        var u, d, g, y, m, x;
        for (u = g = 0, d = h.length; u < d; u++)
          g += h[u].length;
        for (x = new Uint8Array(g), u = y = 0, d = h.length; u < d; u++)
          m = h[u], x.set(m, y), y += m.length;
        return x;
      } }, l = { arraySet: function(h, u, d, g, y) {
        for (var m = 0; m < g; m++)
          h[y + m] = u[d + m];
      }, flattenChunks: function(h) {
        return [].concat.apply([], h);
      } };
      n.setTyped = function(h) {
        h ? (n.Buf8 = Uint8Array, n.Buf16 = Uint16Array, n.Buf32 = Int32Array, n.assign(n, o)) : (n.Buf8 = Array, n.Buf16 = Array, n.Buf32 = Array, n.assign(n, l));
      }, n.setTyped(r);
    }, {}], 42: [function(e, i, n) {
      var r = e("./common"), o = !0, l = !0;
      try {
        String.fromCharCode.apply(null, [0]);
      } catch {
        o = !1;
      }
      try {
        String.fromCharCode.apply(null, new Uint8Array(1));
      } catch {
        l = !1;
      }
      for (var h = new r.Buf8(256), u = 0; u < 256; u++)
        h[u] = 252 <= u ? 6 : 248 <= u ? 5 : 240 <= u ? 4 : 224 <= u ? 3 : 192 <= u ? 2 : 1;
      function d(g, y) {
        if (y < 65537 && (g.subarray && l || !g.subarray && o))
          return String.fromCharCode.apply(null, r.shrinkBuf(g, y));
        for (var m = "", x = 0; x < y; x++)
          m += String.fromCharCode(g[x]);
        return m;
      }
      h[254] = h[254] = 1, n.string2buf = function(g) {
        var y, m, x, b, I, C = g.length, P = 0;
        for (b = 0; b < C; b++)
          (64512 & (m = g.charCodeAt(b))) == 55296 && b + 1 < C && (64512 & (x = g.charCodeAt(b + 1))) == 56320 && (m = 65536 + (m - 55296 << 10) + (x - 56320), b++), P += m < 128 ? 1 : m < 2048 ? 2 : m < 65536 ? 3 : 4;
        for (y = new r.Buf8(P), b = I = 0; I < P; b++)
          (64512 & (m = g.charCodeAt(b))) == 55296 && b + 1 < C && (64512 & (x = g.charCodeAt(b + 1))) == 56320 && (m = 65536 + (m - 55296 << 10) + (x - 56320), b++), m < 128 ? y[I++] = m : (m < 2048 ? y[I++] = 192 | m >>> 6 : (m < 65536 ? y[I++] = 224 | m >>> 12 : (y[I++] = 240 | m >>> 18, y[I++] = 128 | m >>> 12 & 63), y[I++] = 128 | m >>> 6 & 63), y[I++] = 128 | 63 & m);
        return y;
      }, n.buf2binstring = function(g) {
        return d(g, g.length);
      }, n.binstring2buf = function(g) {
        for (var y = new r.Buf8(g.length), m = 0, x = y.length; m < x; m++)
          y[m] = g.charCodeAt(m);
        return y;
      }, n.buf2string = function(g, y) {
        var m, x, b, I, C = y || g.length, P = new Array(2 * C);
        for (m = x = 0; m < C; )
          if ((b = g[m++]) < 128)
            P[x++] = b;
          else if (4 < (I = h[b]))
            P[x++] = 65533, m += I - 1;
          else {
            for (b &= I === 2 ? 31 : I === 3 ? 15 : 7; 1 < I && m < C; )
              b = b << 6 | 63 & g[m++], I--;
            1 < I ? P[x++] = 65533 : b < 65536 ? P[x++] = b : (b -= 65536, P[x++] = 55296 | b >> 10 & 1023, P[x++] = 56320 | 1023 & b);
          }
        return d(P, x);
      }, n.utf8border = function(g, y) {
        var m;
        for ((y = y || g.length) > g.length && (y = g.length), m = y - 1; 0 <= m && (192 & g[m]) == 128; )
          m--;
        return m < 0 || m === 0 ? y : m + h[g[m]] > y ? m : y;
      };
    }, { "./common": 41 }], 43: [function(e, i, n) {
      i.exports = function(r, o, l, h) {
        for (var u = 65535 & r | 0, d = r >>> 16 & 65535 | 0, g = 0; l !== 0; ) {
          for (l -= g = 2e3 < l ? 2e3 : l; d = d + (u = u + o[h++] | 0) | 0, --g; )
            ;
          u %= 65521, d %= 65521;
        }
        return u | d << 16 | 0;
      };
    }, {}], 44: [function(e, i, n) {
      i.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 45: [function(e, i, n) {
      var r = function() {
        for (var o, l = [], h = 0; h < 256; h++) {
          o = h;
          for (var u = 0; u < 8; u++)
            o = 1 & o ? 3988292384 ^ o >>> 1 : o >>> 1;
          l[h] = o;
        }
        return l;
      }();
      i.exports = function(o, l, h, u) {
        var d = r, g = u + h;
        o ^= -1;
        for (var y = u; y < g; y++)
          o = o >>> 8 ^ d[255 & (o ^ l[y])];
        return -1 ^ o;
      };
    }, {}], 46: [function(e, i, n) {
      var r, o = e("../utils/common"), l = e("./trees"), h = e("./adler32"), u = e("./crc32"), d = e("./messages"), g = 0, y = 4, m = 0, x = -2, b = -1, I = 4, C = 2, P = 8, k = 9, O = 286, B = 30, j = 19, V = 2 * O + 1, Y = 15, q = 3, st = 258, dt = st + q + 1, U = 42, J = 113, A = 1, R = 2, wt = 3, z = 4;
      function St(T, _t) {
        return T.msg = d[_t], _t;
      }
      function X(T) {
        return (T << 1) - (4 < T ? 9 : 0);
      }
      function At(T) {
        for (var _t = T.length; 0 <= --_t; )
          T[_t] = 0;
      }
      function at(T) {
        var _t = T.state, ft = _t.pending;
        ft > T.avail_out && (ft = T.avail_out), ft !== 0 && (o.arraySet(T.output, _t.pending_buf, _t.pending_out, ft, T.next_out), T.next_out += ft, _t.pending_out += ft, T.total_out += ft, T.avail_out -= ft, _t.pending -= ft, _t.pending === 0 && (_t.pending_out = 0));
      }
      function ot(T, _t) {
        l._tr_flush_block(T, 0 <= T.block_start ? T.block_start : -1, T.strstart - T.block_start, _t), T.block_start = T.strstart, at(T.strm);
      }
      function Ut(T, _t) {
        T.pending_buf[T.pending++] = _t;
      }
      function Pt(T, _t) {
        T.pending_buf[T.pending++] = _t >>> 8 & 255, T.pending_buf[T.pending++] = 255 & _t;
      }
      function Lt(T, _t) {
        var ft, $, W = T.max_chain_length, nt = T.strstart, bt = T.prev_length, It = T.nice_match, rt = T.strstart > T.w_size - dt ? T.strstart - (T.w_size - dt) : 0, xt = T.window, Rt = T.w_mask, Dt = T.prev, Ht = T.strstart + st, Ue = xt[nt + bt - 1], pe = xt[nt + bt];
        T.prev_length >= T.good_match && (W >>= 2), It > T.lookahead && (It = T.lookahead);
        do
          if (xt[(ft = _t) + bt] === pe && xt[ft + bt - 1] === Ue && xt[ft] === xt[nt] && xt[++ft] === xt[nt + 1]) {
            nt += 2, ft++;
            do
              ;
            while (xt[++nt] === xt[++ft] && xt[++nt] === xt[++ft] && xt[++nt] === xt[++ft] && xt[++nt] === xt[++ft] && xt[++nt] === xt[++ft] && xt[++nt] === xt[++ft] && xt[++nt] === xt[++ft] && xt[++nt] === xt[++ft] && nt < Ht);
            if ($ = st - (Ht - nt), nt = Ht - st, bt < $) {
              if (T.match_start = _t, It <= (bt = $))
                break;
              Ue = xt[nt + bt - 1], pe = xt[nt + bt];
            }
          }
        while ((_t = Dt[_t & Rt]) > rt && --W != 0);
        return bt <= T.lookahead ? bt : T.lookahead;
      }
      function Je(T) {
        var _t, ft, $, W, nt, bt, It, rt, xt, Rt, Dt = T.w_size;
        do {
          if (W = T.window_size - T.lookahead - T.strstart, T.strstart >= Dt + (Dt - dt)) {
            for (o.arraySet(T.window, T.window, Dt, Dt, 0), T.match_start -= Dt, T.strstart -= Dt, T.block_start -= Dt, _t = ft = T.hash_size; $ = T.head[--_t], T.head[_t] = Dt <= $ ? $ - Dt : 0, --ft; )
              ;
            for (_t = ft = Dt; $ = T.prev[--_t], T.prev[_t] = Dt <= $ ? $ - Dt : 0, --ft; )
              ;
            W += Dt;
          }
          if (T.strm.avail_in === 0)
            break;
          if (bt = T.strm, It = T.window, rt = T.strstart + T.lookahead, xt = W, Rt = void 0, Rt = bt.avail_in, xt < Rt && (Rt = xt), ft = Rt === 0 ? 0 : (bt.avail_in -= Rt, o.arraySet(It, bt.input, bt.next_in, Rt, rt), bt.state.wrap === 1 ? bt.adler = h(bt.adler, It, Rt, rt) : bt.state.wrap === 2 && (bt.adler = u(bt.adler, It, Rt, rt)), bt.next_in += Rt, bt.total_in += Rt, Rt), T.lookahead += ft, T.lookahead + T.insert >= q)
            for (nt = T.strstart - T.insert, T.ins_h = T.window[nt], T.ins_h = (T.ins_h << T.hash_shift ^ T.window[nt + 1]) & T.hash_mask; T.insert && (T.ins_h = (T.ins_h << T.hash_shift ^ T.window[nt + q - 1]) & T.hash_mask, T.prev[nt & T.w_mask] = T.head[T.ins_h], T.head[T.ins_h] = nt, nt++, T.insert--, !(T.lookahead + T.insert < q)); )
              ;
        } while (T.lookahead < dt && T.strm.avail_in !== 0);
      }
      function Bi(T, _t) {
        for (var ft, $; ; ) {
          if (T.lookahead < dt) {
            if (Je(T), T.lookahead < dt && _t === g)
              return A;
            if (T.lookahead === 0)
              break;
          }
          if (ft = 0, T.lookahead >= q && (T.ins_h = (T.ins_h << T.hash_shift ^ T.window[T.strstart + q - 1]) & T.hash_mask, ft = T.prev[T.strstart & T.w_mask] = T.head[T.ins_h], T.head[T.ins_h] = T.strstart), ft !== 0 && T.strstart - ft <= T.w_size - dt && (T.match_length = Lt(T, ft)), T.match_length >= q)
            if ($ = l._tr_tally(T, T.strstart - T.match_start, T.match_length - q), T.lookahead -= T.match_length, T.match_length <= T.max_lazy_match && T.lookahead >= q) {
              for (T.match_length--; T.strstart++, T.ins_h = (T.ins_h << T.hash_shift ^ T.window[T.strstart + q - 1]) & T.hash_mask, ft = T.prev[T.strstart & T.w_mask] = T.head[T.ins_h], T.head[T.ins_h] = T.strstart, --T.match_length != 0; )
                ;
              T.strstart++;
            } else
              T.strstart += T.match_length, T.match_length = 0, T.ins_h = T.window[T.strstart], T.ins_h = (T.ins_h << T.hash_shift ^ T.window[T.strstart + 1]) & T.hash_mask;
          else
            $ = l._tr_tally(T, 0, T.window[T.strstart]), T.lookahead--, T.strstart++;
          if ($ && (ot(T, !1), T.strm.avail_out === 0))
            return A;
        }
        return T.insert = T.strstart < q - 1 ? T.strstart : q - 1, _t === y ? (ot(T, !0), T.strm.avail_out === 0 ? wt : z) : T.last_lit && (ot(T, !1), T.strm.avail_out === 0) ? A : R;
      }
      function re(T, _t) {
        for (var ft, $, W; ; ) {
          if (T.lookahead < dt) {
            if (Je(T), T.lookahead < dt && _t === g)
              return A;
            if (T.lookahead === 0)
              break;
          }
          if (ft = 0, T.lookahead >= q && (T.ins_h = (T.ins_h << T.hash_shift ^ T.window[T.strstart + q - 1]) & T.hash_mask, ft = T.prev[T.strstart & T.w_mask] = T.head[T.ins_h], T.head[T.ins_h] = T.strstart), T.prev_length = T.match_length, T.prev_match = T.match_start, T.match_length = q - 1, ft !== 0 && T.prev_length < T.max_lazy_match && T.strstart - ft <= T.w_size - dt && (T.match_length = Lt(T, ft), T.match_length <= 5 && (T.strategy === 1 || T.match_length === q && 4096 < T.strstart - T.match_start) && (T.match_length = q - 1)), T.prev_length >= q && T.match_length <= T.prev_length) {
            for (W = T.strstart + T.lookahead - q, $ = l._tr_tally(T, T.strstart - 1 - T.prev_match, T.prev_length - q), T.lookahead -= T.prev_length - 1, T.prev_length -= 2; ++T.strstart <= W && (T.ins_h = (T.ins_h << T.hash_shift ^ T.window[T.strstart + q - 1]) & T.hash_mask, ft = T.prev[T.strstart & T.w_mask] = T.head[T.ins_h], T.head[T.ins_h] = T.strstart), --T.prev_length != 0; )
              ;
            if (T.match_available = 0, T.match_length = q - 1, T.strstart++, $ && (ot(T, !1), T.strm.avail_out === 0))
              return A;
          } else if (T.match_available) {
            if (($ = l._tr_tally(T, 0, T.window[T.strstart - 1])) && ot(T, !1), T.strstart++, T.lookahead--, T.strm.avail_out === 0)
              return A;
          } else
            T.match_available = 1, T.strstart++, T.lookahead--;
        }
        return T.match_available && ($ = l._tr_tally(T, 0, T.window[T.strstart - 1]), T.match_available = 0), T.insert = T.strstart < q - 1 ? T.strstart : q - 1, _t === y ? (ot(T, !0), T.strm.avail_out === 0 ? wt : z) : T.last_lit && (ot(T, !1), T.strm.avail_out === 0) ? A : R;
      }
      function xe(T, _t, ft, $, W) {
        this.good_length = T, this.max_lazy = _t, this.nice_length = ft, this.max_chain = $, this.func = W;
      }
      function He() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = P, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new o.Buf16(2 * V), this.dyn_dtree = new o.Buf16(2 * (2 * B + 1)), this.bl_tree = new o.Buf16(2 * (2 * j + 1)), At(this.dyn_ltree), At(this.dyn_dtree), At(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new o.Buf16(Y + 1), this.heap = new o.Buf16(2 * O + 1), At(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new o.Buf16(2 * O + 1), At(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function Be(T) {
        var _t;
        return T && T.state ? (T.total_in = T.total_out = 0, T.data_type = C, (_t = T.state).pending = 0, _t.pending_out = 0, _t.wrap < 0 && (_t.wrap = -_t.wrap), _t.status = _t.wrap ? U : J, T.adler = _t.wrap === 2 ? 0 : 1, _t.last_flush = g, l._tr_init(_t), m) : St(T, x);
      }
      function Ne(T) {
        var _t = Be(T);
        return _t === m && function(ft) {
          ft.window_size = 2 * ft.w_size, At(ft.head), ft.max_lazy_match = r[ft.level].max_lazy, ft.good_match = r[ft.level].good_length, ft.nice_match = r[ft.level].nice_length, ft.max_chain_length = r[ft.level].max_chain, ft.strstart = 0, ft.block_start = 0, ft.lookahead = 0, ft.insert = 0, ft.match_length = ft.prev_length = q - 1, ft.match_available = 0, ft.ins_h = 0;
        }(T.state), _t;
      }
      function cn(T, _t, ft, $, W, nt) {
        if (!T)
          return x;
        var bt = 1;
        if (_t === b && (_t = 6), $ < 0 ? (bt = 0, $ = -$) : 15 < $ && (bt = 2, $ -= 16), W < 1 || k < W || ft !== P || $ < 8 || 15 < $ || _t < 0 || 9 < _t || nt < 0 || I < nt)
          return St(T, x);
        $ === 8 && ($ = 9);
        var It = new He();
        return (T.state = It).strm = T, It.wrap = bt, It.gzhead = null, It.w_bits = $, It.w_size = 1 << It.w_bits, It.w_mask = It.w_size - 1, It.hash_bits = W + 7, It.hash_size = 1 << It.hash_bits, It.hash_mask = It.hash_size - 1, It.hash_shift = ~~((It.hash_bits + q - 1) / q), It.window = new o.Buf8(2 * It.w_size), It.head = new o.Buf16(It.hash_size), It.prev = new o.Buf16(It.w_size), It.lit_bufsize = 1 << W + 6, It.pending_buf_size = 4 * It.lit_bufsize, It.pending_buf = new o.Buf8(It.pending_buf_size), It.d_buf = 1 * It.lit_bufsize, It.l_buf = 3 * It.lit_bufsize, It.level = _t, It.strategy = nt, It.method = ft, Ne(T);
      }
      r = [new xe(0, 0, 0, 0, function(T, _t) {
        var ft = 65535;
        for (ft > T.pending_buf_size - 5 && (ft = T.pending_buf_size - 5); ; ) {
          if (T.lookahead <= 1) {
            if (Je(T), T.lookahead === 0 && _t === g)
              return A;
            if (T.lookahead === 0)
              break;
          }
          T.strstart += T.lookahead, T.lookahead = 0;
          var $ = T.block_start + ft;
          if ((T.strstart === 0 || T.strstart >= $) && (T.lookahead = T.strstart - $, T.strstart = $, ot(T, !1), T.strm.avail_out === 0) || T.strstart - T.block_start >= T.w_size - dt && (ot(T, !1), T.strm.avail_out === 0))
            return A;
        }
        return T.insert = 0, _t === y ? (ot(T, !0), T.strm.avail_out === 0 ? wt : z) : (T.strstart > T.block_start && (ot(T, !1), T.strm.avail_out), A);
      }), new xe(4, 4, 8, 4, Bi), new xe(4, 5, 16, 8, Bi), new xe(4, 6, 32, 32, Bi), new xe(4, 4, 16, 16, re), new xe(8, 16, 32, 32, re), new xe(8, 16, 128, 128, re), new xe(8, 32, 128, 256, re), new xe(32, 128, 258, 1024, re), new xe(32, 258, 258, 4096, re)], n.deflateInit = function(T, _t) {
        return cn(T, _t, P, 15, 8, 0);
      }, n.deflateInit2 = cn, n.deflateReset = Ne, n.deflateResetKeep = Be, n.deflateSetHeader = function(T, _t) {
        return T && T.state ? T.state.wrap !== 2 ? x : (T.state.gzhead = _t, m) : x;
      }, n.deflate = function(T, _t) {
        var ft, $, W, nt;
        if (!T || !T.state || 5 < _t || _t < 0)
          return T ? St(T, x) : x;
        if ($ = T.state, !T.output || !T.input && T.avail_in !== 0 || $.status === 666 && _t !== y)
          return St(T, T.avail_out === 0 ? -5 : x);
        if ($.strm = T, ft = $.last_flush, $.last_flush = _t, $.status === U)
          if ($.wrap === 2)
            T.adler = 0, Ut($, 31), Ut($, 139), Ut($, 8), $.gzhead ? (Ut($, ($.gzhead.text ? 1 : 0) + ($.gzhead.hcrc ? 2 : 0) + ($.gzhead.extra ? 4 : 0) + ($.gzhead.name ? 8 : 0) + ($.gzhead.comment ? 16 : 0)), Ut($, 255 & $.gzhead.time), Ut($, $.gzhead.time >> 8 & 255), Ut($, $.gzhead.time >> 16 & 255), Ut($, $.gzhead.time >> 24 & 255), Ut($, $.level === 9 ? 2 : 2 <= $.strategy || $.level < 2 ? 4 : 0), Ut($, 255 & $.gzhead.os), $.gzhead.extra && $.gzhead.extra.length && (Ut($, 255 & $.gzhead.extra.length), Ut($, $.gzhead.extra.length >> 8 & 255)), $.gzhead.hcrc && (T.adler = u(T.adler, $.pending_buf, $.pending, 0)), $.gzindex = 0, $.status = 69) : (Ut($, 0), Ut($, 0), Ut($, 0), Ut($, 0), Ut($, 0), Ut($, $.level === 9 ? 2 : 2 <= $.strategy || $.level < 2 ? 4 : 0), Ut($, 3), $.status = J);
          else {
            var bt = P + ($.w_bits - 8 << 4) << 8;
            bt |= (2 <= $.strategy || $.level < 2 ? 0 : $.level < 6 ? 1 : $.level === 6 ? 2 : 3) << 6, $.strstart !== 0 && (bt |= 32), bt += 31 - bt % 31, $.status = J, Pt($, bt), $.strstart !== 0 && (Pt($, T.adler >>> 16), Pt($, 65535 & T.adler)), T.adler = 1;
          }
        if ($.status === 69)
          if ($.gzhead.extra) {
            for (W = $.pending; $.gzindex < (65535 & $.gzhead.extra.length) && ($.pending !== $.pending_buf_size || ($.gzhead.hcrc && $.pending > W && (T.adler = u(T.adler, $.pending_buf, $.pending - W, W)), at(T), W = $.pending, $.pending !== $.pending_buf_size)); )
              Ut($, 255 & $.gzhead.extra[$.gzindex]), $.gzindex++;
            $.gzhead.hcrc && $.pending > W && (T.adler = u(T.adler, $.pending_buf, $.pending - W, W)), $.gzindex === $.gzhead.extra.length && ($.gzindex = 0, $.status = 73);
          } else
            $.status = 73;
        if ($.status === 73)
          if ($.gzhead.name) {
            W = $.pending;
            do {
              if ($.pending === $.pending_buf_size && ($.gzhead.hcrc && $.pending > W && (T.adler = u(T.adler, $.pending_buf, $.pending - W, W)), at(T), W = $.pending, $.pending === $.pending_buf_size)) {
                nt = 1;
                break;
              }
              nt = $.gzindex < $.gzhead.name.length ? 255 & $.gzhead.name.charCodeAt($.gzindex++) : 0, Ut($, nt);
            } while (nt !== 0);
            $.gzhead.hcrc && $.pending > W && (T.adler = u(T.adler, $.pending_buf, $.pending - W, W)), nt === 0 && ($.gzindex = 0, $.status = 91);
          } else
            $.status = 91;
        if ($.status === 91)
          if ($.gzhead.comment) {
            W = $.pending;
            do {
              if ($.pending === $.pending_buf_size && ($.gzhead.hcrc && $.pending > W && (T.adler = u(T.adler, $.pending_buf, $.pending - W, W)), at(T), W = $.pending, $.pending === $.pending_buf_size)) {
                nt = 1;
                break;
              }
              nt = $.gzindex < $.gzhead.comment.length ? 255 & $.gzhead.comment.charCodeAt($.gzindex++) : 0, Ut($, nt);
            } while (nt !== 0);
            $.gzhead.hcrc && $.pending > W && (T.adler = u(T.adler, $.pending_buf, $.pending - W, W)), nt === 0 && ($.status = 103);
          } else
            $.status = 103;
        if ($.status === 103 && ($.gzhead.hcrc ? ($.pending + 2 > $.pending_buf_size && at(T), $.pending + 2 <= $.pending_buf_size && (Ut($, 255 & T.adler), Ut($, T.adler >> 8 & 255), T.adler = 0, $.status = J)) : $.status = J), $.pending !== 0) {
          if (at(T), T.avail_out === 0)
            return $.last_flush = -1, m;
        } else if (T.avail_in === 0 && X(_t) <= X(ft) && _t !== y)
          return St(T, -5);
        if ($.status === 666 && T.avail_in !== 0)
          return St(T, -5);
        if (T.avail_in !== 0 || $.lookahead !== 0 || _t !== g && $.status !== 666) {
          var It = $.strategy === 2 ? function(rt, xt) {
            for (var Rt; ; ) {
              if (rt.lookahead === 0 && (Je(rt), rt.lookahead === 0)) {
                if (xt === g)
                  return A;
                break;
              }
              if (rt.match_length = 0, Rt = l._tr_tally(rt, 0, rt.window[rt.strstart]), rt.lookahead--, rt.strstart++, Rt && (ot(rt, !1), rt.strm.avail_out === 0))
                return A;
            }
            return rt.insert = 0, xt === y ? (ot(rt, !0), rt.strm.avail_out === 0 ? wt : z) : rt.last_lit && (ot(rt, !1), rt.strm.avail_out === 0) ? A : R;
          }($, _t) : $.strategy === 3 ? function(rt, xt) {
            for (var Rt, Dt, Ht, Ue, pe = rt.window; ; ) {
              if (rt.lookahead <= st) {
                if (Je(rt), rt.lookahead <= st && xt === g)
                  return A;
                if (rt.lookahead === 0)
                  break;
              }
              if (rt.match_length = 0, rt.lookahead >= q && 0 < rt.strstart && (Dt = pe[Ht = rt.strstart - 1]) === pe[++Ht] && Dt === pe[++Ht] && Dt === pe[++Ht]) {
                Ue = rt.strstart + st;
                do
                  ;
                while (Dt === pe[++Ht] && Dt === pe[++Ht] && Dt === pe[++Ht] && Dt === pe[++Ht] && Dt === pe[++Ht] && Dt === pe[++Ht] && Dt === pe[++Ht] && Dt === pe[++Ht] && Ht < Ue);
                rt.match_length = st - (Ue - Ht), rt.match_length > rt.lookahead && (rt.match_length = rt.lookahead);
              }
              if (rt.match_length >= q ? (Rt = l._tr_tally(rt, 1, rt.match_length - q), rt.lookahead -= rt.match_length, rt.strstart += rt.match_length, rt.match_length = 0) : (Rt = l._tr_tally(rt, 0, rt.window[rt.strstart]), rt.lookahead--, rt.strstart++), Rt && (ot(rt, !1), rt.strm.avail_out === 0))
                return A;
            }
            return rt.insert = 0, xt === y ? (ot(rt, !0), rt.strm.avail_out === 0 ? wt : z) : rt.last_lit && (ot(rt, !1), rt.strm.avail_out === 0) ? A : R;
          }($, _t) : r[$.level].func($, _t);
          if (It !== wt && It !== z || ($.status = 666), It === A || It === wt)
            return T.avail_out === 0 && ($.last_flush = -1), m;
          if (It === R && (_t === 1 ? l._tr_align($) : _t !== 5 && (l._tr_stored_block($, 0, 0, !1), _t === 3 && (At($.head), $.lookahead === 0 && ($.strstart = 0, $.block_start = 0, $.insert = 0))), at(T), T.avail_out === 0))
            return $.last_flush = -1, m;
        }
        return _t !== y ? m : $.wrap <= 0 ? 1 : ($.wrap === 2 ? (Ut($, 255 & T.adler), Ut($, T.adler >> 8 & 255), Ut($, T.adler >> 16 & 255), Ut($, T.adler >> 24 & 255), Ut($, 255 & T.total_in), Ut($, T.total_in >> 8 & 255), Ut($, T.total_in >> 16 & 255), Ut($, T.total_in >> 24 & 255)) : (Pt($, T.adler >>> 16), Pt($, 65535 & T.adler)), at(T), 0 < $.wrap && ($.wrap = -$.wrap), $.pending !== 0 ? m : 1);
      }, n.deflateEnd = function(T) {
        var _t;
        return T && T.state ? (_t = T.state.status) !== U && _t !== 69 && _t !== 73 && _t !== 91 && _t !== 103 && _t !== J && _t !== 666 ? St(T, x) : (T.state = null, _t === J ? St(T, -3) : m) : x;
      }, n.deflateSetDictionary = function(T, _t) {
        var ft, $, W, nt, bt, It, rt, xt, Rt = _t.length;
        if (!T || !T.state || (nt = (ft = T.state).wrap) === 2 || nt === 1 && ft.status !== U || ft.lookahead)
          return x;
        for (nt === 1 && (T.adler = h(T.adler, _t, Rt, 0)), ft.wrap = 0, Rt >= ft.w_size && (nt === 0 && (At(ft.head), ft.strstart = 0, ft.block_start = 0, ft.insert = 0), xt = new o.Buf8(ft.w_size), o.arraySet(xt, _t, Rt - ft.w_size, ft.w_size, 0), _t = xt, Rt = ft.w_size), bt = T.avail_in, It = T.next_in, rt = T.input, T.avail_in = Rt, T.next_in = 0, T.input = _t, Je(ft); ft.lookahead >= q; ) {
          for ($ = ft.strstart, W = ft.lookahead - (q - 1); ft.ins_h = (ft.ins_h << ft.hash_shift ^ ft.window[$ + q - 1]) & ft.hash_mask, ft.prev[$ & ft.w_mask] = ft.head[ft.ins_h], ft.head[ft.ins_h] = $, $++, --W; )
            ;
          ft.strstart = $, ft.lookahead = q - 1, Je(ft);
        }
        return ft.strstart += ft.lookahead, ft.block_start = ft.strstart, ft.insert = ft.lookahead, ft.lookahead = 0, ft.match_length = ft.prev_length = q - 1, ft.match_available = 0, T.next_in = It, T.input = rt, T.avail_in = bt, ft.wrap = nt, m;
      }, n.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./messages": 51, "./trees": 52 }], 47: [function(e, i, n) {
      i.exports = function() {
        this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
      };
    }, {}], 48: [function(e, i, n) {
      i.exports = function(r, o) {
        var l, h, u, d, g, y, m, x, b, I, C, P, k, O, B, j, V, Y, q, st, dt, U, J, A, R;
        l = r.state, h = r.next_in, A = r.input, u = h + (r.avail_in - 5), d = r.next_out, R = r.output, g = d - (o - r.avail_out), y = d + (r.avail_out - 257), m = l.dmax, x = l.wsize, b = l.whave, I = l.wnext, C = l.window, P = l.hold, k = l.bits, O = l.lencode, B = l.distcode, j = (1 << l.lenbits) - 1, V = (1 << l.distbits) - 1;
        t:
          do {
            k < 15 && (P += A[h++] << k, k += 8, P += A[h++] << k, k += 8), Y = O[P & j];
            e:
              for (; ; ) {
                if (P >>>= q = Y >>> 24, k -= q, (q = Y >>> 16 & 255) === 0)
                  R[d++] = 65535 & Y;
                else {
                  if (!(16 & q)) {
                    if (!(64 & q)) {
                      Y = O[(65535 & Y) + (P & (1 << q) - 1)];
                      continue e;
                    }
                    if (32 & q) {
                      l.mode = 12;
                      break t;
                    }
                    r.msg = "invalid literal/length code", l.mode = 30;
                    break t;
                  }
                  st = 65535 & Y, (q &= 15) && (k < q && (P += A[h++] << k, k += 8), st += P & (1 << q) - 1, P >>>= q, k -= q), k < 15 && (P += A[h++] << k, k += 8, P += A[h++] << k, k += 8), Y = B[P & V];
                  i:
                    for (; ; ) {
                      if (P >>>= q = Y >>> 24, k -= q, !(16 & (q = Y >>> 16 & 255))) {
                        if (!(64 & q)) {
                          Y = B[(65535 & Y) + (P & (1 << q) - 1)];
                          continue i;
                        }
                        r.msg = "invalid distance code", l.mode = 30;
                        break t;
                      }
                      if (dt = 65535 & Y, k < (q &= 15) && (P += A[h++] << k, (k += 8) < q && (P += A[h++] << k, k += 8)), m < (dt += P & (1 << q) - 1)) {
                        r.msg = "invalid distance too far back", l.mode = 30;
                        break t;
                      }
                      if (P >>>= q, k -= q, (q = d - g) < dt) {
                        if (b < (q = dt - q) && l.sane) {
                          r.msg = "invalid distance too far back", l.mode = 30;
                          break t;
                        }
                        if (J = C, (U = 0) === I) {
                          if (U += x - q, q < st) {
                            for (st -= q; R[d++] = C[U++], --q; )
                              ;
                            U = d - dt, J = R;
                          }
                        } else if (I < q) {
                          if (U += x + I - q, (q -= I) < st) {
                            for (st -= q; R[d++] = C[U++], --q; )
                              ;
                            if (U = 0, I < st) {
                              for (st -= q = I; R[d++] = C[U++], --q; )
                                ;
                              U = d - dt, J = R;
                            }
                          }
                        } else if (U += I - q, q < st) {
                          for (st -= q; R[d++] = C[U++], --q; )
                            ;
                          U = d - dt, J = R;
                        }
                        for (; 2 < st; )
                          R[d++] = J[U++], R[d++] = J[U++], R[d++] = J[U++], st -= 3;
                        st && (R[d++] = J[U++], 1 < st && (R[d++] = J[U++]));
                      } else {
                        for (U = d - dt; R[d++] = R[U++], R[d++] = R[U++], R[d++] = R[U++], 2 < (st -= 3); )
                          ;
                        st && (R[d++] = R[U++], 1 < st && (R[d++] = R[U++]));
                      }
                      break;
                    }
                }
                break;
              }
          } while (h < u && d < y);
        h -= st = k >> 3, P &= (1 << (k -= st << 3)) - 1, r.next_in = h, r.next_out = d, r.avail_in = h < u ? u - h + 5 : 5 - (h - u), r.avail_out = d < y ? y - d + 257 : 257 - (d - y), l.hold = P, l.bits = k;
      };
    }, {}], 49: [function(e, i, n) {
      var r = e("../utils/common"), o = e("./adler32"), l = e("./crc32"), h = e("./inffast"), u = e("./inftrees"), d = 1, g = 2, y = 0, m = -2, x = 1, b = 852, I = 592;
      function C(U) {
        return (U >>> 24 & 255) + (U >>> 8 & 65280) + ((65280 & U) << 8) + ((255 & U) << 24);
      }
      function P() {
        this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new r.Buf16(320), this.work = new r.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function k(U) {
        var J;
        return U && U.state ? (J = U.state, U.total_in = U.total_out = J.total = 0, U.msg = "", J.wrap && (U.adler = 1 & J.wrap), J.mode = x, J.last = 0, J.havedict = 0, J.dmax = 32768, J.head = null, J.hold = 0, J.bits = 0, J.lencode = J.lendyn = new r.Buf32(b), J.distcode = J.distdyn = new r.Buf32(I), J.sane = 1, J.back = -1, y) : m;
      }
      function O(U) {
        var J;
        return U && U.state ? ((J = U.state).wsize = 0, J.whave = 0, J.wnext = 0, k(U)) : m;
      }
      function B(U, J) {
        var A, R;
        return U && U.state ? (R = U.state, J < 0 ? (A = 0, J = -J) : (A = 1 + (J >> 4), J < 48 && (J &= 15)), J && (J < 8 || 15 < J) ? m : (R.window !== null && R.wbits !== J && (R.window = null), R.wrap = A, R.wbits = J, O(U))) : m;
      }
      function j(U, J) {
        var A, R;
        return U ? (R = new P(), (U.state = R).window = null, (A = B(U, J)) !== y && (U.state = null), A) : m;
      }
      var V, Y, q = !0;
      function st(U) {
        if (q) {
          var J;
          for (V = new r.Buf32(512), Y = new r.Buf32(32), J = 0; J < 144; )
            U.lens[J++] = 8;
          for (; J < 256; )
            U.lens[J++] = 9;
          for (; J < 280; )
            U.lens[J++] = 7;
          for (; J < 288; )
            U.lens[J++] = 8;
          for (u(d, U.lens, 0, 288, V, 0, U.work, { bits: 9 }), J = 0; J < 32; )
            U.lens[J++] = 5;
          u(g, U.lens, 0, 32, Y, 0, U.work, { bits: 5 }), q = !1;
        }
        U.lencode = V, U.lenbits = 9, U.distcode = Y, U.distbits = 5;
      }
      function dt(U, J, A, R) {
        var wt, z = U.state;
        return z.window === null && (z.wsize = 1 << z.wbits, z.wnext = 0, z.whave = 0, z.window = new r.Buf8(z.wsize)), R >= z.wsize ? (r.arraySet(z.window, J, A - z.wsize, z.wsize, 0), z.wnext = 0, z.whave = z.wsize) : (R < (wt = z.wsize - z.wnext) && (wt = R), r.arraySet(z.window, J, A - R, wt, z.wnext), (R -= wt) ? (r.arraySet(z.window, J, A - R, R, 0), z.wnext = R, z.whave = z.wsize) : (z.wnext += wt, z.wnext === z.wsize && (z.wnext = 0), z.whave < z.wsize && (z.whave += wt))), 0;
      }
      n.inflateReset = O, n.inflateReset2 = B, n.inflateResetKeep = k, n.inflateInit = function(U) {
        return j(U, 15);
      }, n.inflateInit2 = j, n.inflate = function(U, J) {
        var A, R, wt, z, St, X, At, at, ot, Ut, Pt, Lt, Je, Bi, re, xe, He, Be, Ne, cn, T, _t, ft, $, W = 0, nt = new r.Buf8(4), bt = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!U || !U.state || !U.output || !U.input && U.avail_in !== 0)
          return m;
        (A = U.state).mode === 12 && (A.mode = 13), St = U.next_out, wt = U.output, At = U.avail_out, z = U.next_in, R = U.input, X = U.avail_in, at = A.hold, ot = A.bits, Ut = X, Pt = At, _t = y;
        t:
          for (; ; )
            switch (A.mode) {
              case x:
                if (A.wrap === 0) {
                  A.mode = 13;
                  break;
                }
                for (; ot < 16; ) {
                  if (X === 0)
                    break t;
                  X--, at += R[z++] << ot, ot += 8;
                }
                if (2 & A.wrap && at === 35615) {
                  nt[A.check = 0] = 255 & at, nt[1] = at >>> 8 & 255, A.check = l(A.check, nt, 2, 0), ot = at = 0, A.mode = 2;
                  break;
                }
                if (A.flags = 0, A.head && (A.head.done = !1), !(1 & A.wrap) || (((255 & at) << 8) + (at >> 8)) % 31) {
                  U.msg = "incorrect header check", A.mode = 30;
                  break;
                }
                if ((15 & at) != 8) {
                  U.msg = "unknown compression method", A.mode = 30;
                  break;
                }
                if (ot -= 4, T = 8 + (15 & (at >>>= 4)), A.wbits === 0)
                  A.wbits = T;
                else if (T > A.wbits) {
                  U.msg = "invalid window size", A.mode = 30;
                  break;
                }
                A.dmax = 1 << T, U.adler = A.check = 1, A.mode = 512 & at ? 10 : 12, ot = at = 0;
                break;
              case 2:
                for (; ot < 16; ) {
                  if (X === 0)
                    break t;
                  X--, at += R[z++] << ot, ot += 8;
                }
                if (A.flags = at, (255 & A.flags) != 8) {
                  U.msg = "unknown compression method", A.mode = 30;
                  break;
                }
                if (57344 & A.flags) {
                  U.msg = "unknown header flags set", A.mode = 30;
                  break;
                }
                A.head && (A.head.text = at >> 8 & 1), 512 & A.flags && (nt[0] = 255 & at, nt[1] = at >>> 8 & 255, A.check = l(A.check, nt, 2, 0)), ot = at = 0, A.mode = 3;
              case 3:
                for (; ot < 32; ) {
                  if (X === 0)
                    break t;
                  X--, at += R[z++] << ot, ot += 8;
                }
                A.head && (A.head.time = at), 512 & A.flags && (nt[0] = 255 & at, nt[1] = at >>> 8 & 255, nt[2] = at >>> 16 & 255, nt[3] = at >>> 24 & 255, A.check = l(A.check, nt, 4, 0)), ot = at = 0, A.mode = 4;
              case 4:
                for (; ot < 16; ) {
                  if (X === 0)
                    break t;
                  X--, at += R[z++] << ot, ot += 8;
                }
                A.head && (A.head.xflags = 255 & at, A.head.os = at >> 8), 512 & A.flags && (nt[0] = 255 & at, nt[1] = at >>> 8 & 255, A.check = l(A.check, nt, 2, 0)), ot = at = 0, A.mode = 5;
              case 5:
                if (1024 & A.flags) {
                  for (; ot < 16; ) {
                    if (X === 0)
                      break t;
                    X--, at += R[z++] << ot, ot += 8;
                  }
                  A.length = at, A.head && (A.head.extra_len = at), 512 & A.flags && (nt[0] = 255 & at, nt[1] = at >>> 8 & 255, A.check = l(A.check, nt, 2, 0)), ot = at = 0;
                } else
                  A.head && (A.head.extra = null);
                A.mode = 6;
              case 6:
                if (1024 & A.flags && (X < (Lt = A.length) && (Lt = X), Lt && (A.head && (T = A.head.extra_len - A.length, A.head.extra || (A.head.extra = new Array(A.head.extra_len)), r.arraySet(A.head.extra, R, z, Lt, T)), 512 & A.flags && (A.check = l(A.check, R, Lt, z)), X -= Lt, z += Lt, A.length -= Lt), A.length))
                  break t;
                A.length = 0, A.mode = 7;
              case 7:
                if (2048 & A.flags) {
                  if (X === 0)
                    break t;
                  for (Lt = 0; T = R[z + Lt++], A.head && T && A.length < 65536 && (A.head.name += String.fromCharCode(T)), T && Lt < X; )
                    ;
                  if (512 & A.flags && (A.check = l(A.check, R, Lt, z)), X -= Lt, z += Lt, T)
                    break t;
                } else
                  A.head && (A.head.name = null);
                A.length = 0, A.mode = 8;
              case 8:
                if (4096 & A.flags) {
                  if (X === 0)
                    break t;
                  for (Lt = 0; T = R[z + Lt++], A.head && T && A.length < 65536 && (A.head.comment += String.fromCharCode(T)), T && Lt < X; )
                    ;
                  if (512 & A.flags && (A.check = l(A.check, R, Lt, z)), X -= Lt, z += Lt, T)
                    break t;
                } else
                  A.head && (A.head.comment = null);
                A.mode = 9;
              case 9:
                if (512 & A.flags) {
                  for (; ot < 16; ) {
                    if (X === 0)
                      break t;
                    X--, at += R[z++] << ot, ot += 8;
                  }
                  if (at !== (65535 & A.check)) {
                    U.msg = "header crc mismatch", A.mode = 30;
                    break;
                  }
                  ot = at = 0;
                }
                A.head && (A.head.hcrc = A.flags >> 9 & 1, A.head.done = !0), U.adler = A.check = 0, A.mode = 12;
                break;
              case 10:
                for (; ot < 32; ) {
                  if (X === 0)
                    break t;
                  X--, at += R[z++] << ot, ot += 8;
                }
                U.adler = A.check = C(at), ot = at = 0, A.mode = 11;
              case 11:
                if (A.havedict === 0)
                  return U.next_out = St, U.avail_out = At, U.next_in = z, U.avail_in = X, A.hold = at, A.bits = ot, 2;
                U.adler = A.check = 1, A.mode = 12;
              case 12:
                if (J === 5 || J === 6)
                  break t;
              case 13:
                if (A.last) {
                  at >>>= 7 & ot, ot -= 7 & ot, A.mode = 27;
                  break;
                }
                for (; ot < 3; ) {
                  if (X === 0)
                    break t;
                  X--, at += R[z++] << ot, ot += 8;
                }
                switch (A.last = 1 & at, ot -= 1, 3 & (at >>>= 1)) {
                  case 0:
                    A.mode = 14;
                    break;
                  case 1:
                    if (st(A), A.mode = 20, J !== 6)
                      break;
                    at >>>= 2, ot -= 2;
                    break t;
                  case 2:
                    A.mode = 17;
                    break;
                  case 3:
                    U.msg = "invalid block type", A.mode = 30;
                }
                at >>>= 2, ot -= 2;
                break;
              case 14:
                for (at >>>= 7 & ot, ot -= 7 & ot; ot < 32; ) {
                  if (X === 0)
                    break t;
                  X--, at += R[z++] << ot, ot += 8;
                }
                if ((65535 & at) != (at >>> 16 ^ 65535)) {
                  U.msg = "invalid stored block lengths", A.mode = 30;
                  break;
                }
                if (A.length = 65535 & at, ot = at = 0, A.mode = 15, J === 6)
                  break t;
              case 15:
                A.mode = 16;
              case 16:
                if (Lt = A.length) {
                  if (X < Lt && (Lt = X), At < Lt && (Lt = At), Lt === 0)
                    break t;
                  r.arraySet(wt, R, z, Lt, St), X -= Lt, z += Lt, At -= Lt, St += Lt, A.length -= Lt;
                  break;
                }
                A.mode = 12;
                break;
              case 17:
                for (; ot < 14; ) {
                  if (X === 0)
                    break t;
                  X--, at += R[z++] << ot, ot += 8;
                }
                if (A.nlen = 257 + (31 & at), at >>>= 5, ot -= 5, A.ndist = 1 + (31 & at), at >>>= 5, ot -= 5, A.ncode = 4 + (15 & at), at >>>= 4, ot -= 4, 286 < A.nlen || 30 < A.ndist) {
                  U.msg = "too many length or distance symbols", A.mode = 30;
                  break;
                }
                A.have = 0, A.mode = 18;
              case 18:
                for (; A.have < A.ncode; ) {
                  for (; ot < 3; ) {
                    if (X === 0)
                      break t;
                    X--, at += R[z++] << ot, ot += 8;
                  }
                  A.lens[bt[A.have++]] = 7 & at, at >>>= 3, ot -= 3;
                }
                for (; A.have < 19; )
                  A.lens[bt[A.have++]] = 0;
                if (A.lencode = A.lendyn, A.lenbits = 7, ft = { bits: A.lenbits }, _t = u(0, A.lens, 0, 19, A.lencode, 0, A.work, ft), A.lenbits = ft.bits, _t) {
                  U.msg = "invalid code lengths set", A.mode = 30;
                  break;
                }
                A.have = 0, A.mode = 19;
              case 19:
                for (; A.have < A.nlen + A.ndist; ) {
                  for (; xe = (W = A.lencode[at & (1 << A.lenbits) - 1]) >>> 16 & 255, He = 65535 & W, !((re = W >>> 24) <= ot); ) {
                    if (X === 0)
                      break t;
                    X--, at += R[z++] << ot, ot += 8;
                  }
                  if (He < 16)
                    at >>>= re, ot -= re, A.lens[A.have++] = He;
                  else {
                    if (He === 16) {
                      for ($ = re + 2; ot < $; ) {
                        if (X === 0)
                          break t;
                        X--, at += R[z++] << ot, ot += 8;
                      }
                      if (at >>>= re, ot -= re, A.have === 0) {
                        U.msg = "invalid bit length repeat", A.mode = 30;
                        break;
                      }
                      T = A.lens[A.have - 1], Lt = 3 + (3 & at), at >>>= 2, ot -= 2;
                    } else if (He === 17) {
                      for ($ = re + 3; ot < $; ) {
                        if (X === 0)
                          break t;
                        X--, at += R[z++] << ot, ot += 8;
                      }
                      ot -= re, T = 0, Lt = 3 + (7 & (at >>>= re)), at >>>= 3, ot -= 3;
                    } else {
                      for ($ = re + 7; ot < $; ) {
                        if (X === 0)
                          break t;
                        X--, at += R[z++] << ot, ot += 8;
                      }
                      ot -= re, T = 0, Lt = 11 + (127 & (at >>>= re)), at >>>= 7, ot -= 7;
                    }
                    if (A.have + Lt > A.nlen + A.ndist) {
                      U.msg = "invalid bit length repeat", A.mode = 30;
                      break;
                    }
                    for (; Lt--; )
                      A.lens[A.have++] = T;
                  }
                }
                if (A.mode === 30)
                  break;
                if (A.lens[256] === 0) {
                  U.msg = "invalid code -- missing end-of-block", A.mode = 30;
                  break;
                }
                if (A.lenbits = 9, ft = { bits: A.lenbits }, _t = u(d, A.lens, 0, A.nlen, A.lencode, 0, A.work, ft), A.lenbits = ft.bits, _t) {
                  U.msg = "invalid literal/lengths set", A.mode = 30;
                  break;
                }
                if (A.distbits = 6, A.distcode = A.distdyn, ft = { bits: A.distbits }, _t = u(g, A.lens, A.nlen, A.ndist, A.distcode, 0, A.work, ft), A.distbits = ft.bits, _t) {
                  U.msg = "invalid distances set", A.mode = 30;
                  break;
                }
                if (A.mode = 20, J === 6)
                  break t;
              case 20:
                A.mode = 21;
              case 21:
                if (6 <= X && 258 <= At) {
                  U.next_out = St, U.avail_out = At, U.next_in = z, U.avail_in = X, A.hold = at, A.bits = ot, h(U, Pt), St = U.next_out, wt = U.output, At = U.avail_out, z = U.next_in, R = U.input, X = U.avail_in, at = A.hold, ot = A.bits, A.mode === 12 && (A.back = -1);
                  break;
                }
                for (A.back = 0; xe = (W = A.lencode[at & (1 << A.lenbits) - 1]) >>> 16 & 255, He = 65535 & W, !((re = W >>> 24) <= ot); ) {
                  if (X === 0)
                    break t;
                  X--, at += R[z++] << ot, ot += 8;
                }
                if (xe && !(240 & xe)) {
                  for (Be = re, Ne = xe, cn = He; xe = (W = A.lencode[cn + ((at & (1 << Be + Ne) - 1) >> Be)]) >>> 16 & 255, He = 65535 & W, !(Be + (re = W >>> 24) <= ot); ) {
                    if (X === 0)
                      break t;
                    X--, at += R[z++] << ot, ot += 8;
                  }
                  at >>>= Be, ot -= Be, A.back += Be;
                }
                if (at >>>= re, ot -= re, A.back += re, A.length = He, xe === 0) {
                  A.mode = 26;
                  break;
                }
                if (32 & xe) {
                  A.back = -1, A.mode = 12;
                  break;
                }
                if (64 & xe) {
                  U.msg = "invalid literal/length code", A.mode = 30;
                  break;
                }
                A.extra = 15 & xe, A.mode = 22;
              case 22:
                if (A.extra) {
                  for ($ = A.extra; ot < $; ) {
                    if (X === 0)
                      break t;
                    X--, at += R[z++] << ot, ot += 8;
                  }
                  A.length += at & (1 << A.extra) - 1, at >>>= A.extra, ot -= A.extra, A.back += A.extra;
                }
                A.was = A.length, A.mode = 23;
              case 23:
                for (; xe = (W = A.distcode[at & (1 << A.distbits) - 1]) >>> 16 & 255, He = 65535 & W, !((re = W >>> 24) <= ot); ) {
                  if (X === 0)
                    break t;
                  X--, at += R[z++] << ot, ot += 8;
                }
                if (!(240 & xe)) {
                  for (Be = re, Ne = xe, cn = He; xe = (W = A.distcode[cn + ((at & (1 << Be + Ne) - 1) >> Be)]) >>> 16 & 255, He = 65535 & W, !(Be + (re = W >>> 24) <= ot); ) {
                    if (X === 0)
                      break t;
                    X--, at += R[z++] << ot, ot += 8;
                  }
                  at >>>= Be, ot -= Be, A.back += Be;
                }
                if (at >>>= re, ot -= re, A.back += re, 64 & xe) {
                  U.msg = "invalid distance code", A.mode = 30;
                  break;
                }
                A.offset = He, A.extra = 15 & xe, A.mode = 24;
              case 24:
                if (A.extra) {
                  for ($ = A.extra; ot < $; ) {
                    if (X === 0)
                      break t;
                    X--, at += R[z++] << ot, ot += 8;
                  }
                  A.offset += at & (1 << A.extra) - 1, at >>>= A.extra, ot -= A.extra, A.back += A.extra;
                }
                if (A.offset > A.dmax) {
                  U.msg = "invalid distance too far back", A.mode = 30;
                  break;
                }
                A.mode = 25;
              case 25:
                if (At === 0)
                  break t;
                if (Lt = Pt - At, A.offset > Lt) {
                  if ((Lt = A.offset - Lt) > A.whave && A.sane) {
                    U.msg = "invalid distance too far back", A.mode = 30;
                    break;
                  }
                  Je = Lt > A.wnext ? (Lt -= A.wnext, A.wsize - Lt) : A.wnext - Lt, Lt > A.length && (Lt = A.length), Bi = A.window;
                } else
                  Bi = wt, Je = St - A.offset, Lt = A.length;
                for (At < Lt && (Lt = At), At -= Lt, A.length -= Lt; wt[St++] = Bi[Je++], --Lt; )
                  ;
                A.length === 0 && (A.mode = 21);
                break;
              case 26:
                if (At === 0)
                  break t;
                wt[St++] = A.length, At--, A.mode = 21;
                break;
              case 27:
                if (A.wrap) {
                  for (; ot < 32; ) {
                    if (X === 0)
                      break t;
                    X--, at |= R[z++] << ot, ot += 8;
                  }
                  if (Pt -= At, U.total_out += Pt, A.total += Pt, Pt && (U.adler = A.check = A.flags ? l(A.check, wt, Pt, St - Pt) : o(A.check, wt, Pt, St - Pt)), Pt = At, (A.flags ? at : C(at)) !== A.check) {
                    U.msg = "incorrect data check", A.mode = 30;
                    break;
                  }
                  ot = at = 0;
                }
                A.mode = 28;
              case 28:
                if (A.wrap && A.flags) {
                  for (; ot < 32; ) {
                    if (X === 0)
                      break t;
                    X--, at += R[z++] << ot, ot += 8;
                  }
                  if (at !== (4294967295 & A.total)) {
                    U.msg = "incorrect length check", A.mode = 30;
                    break;
                  }
                  ot = at = 0;
                }
                A.mode = 29;
              case 29:
                _t = 1;
                break t;
              case 30:
                _t = -3;
                break t;
              case 31:
                return -4;
              case 32:
              default:
                return m;
            }
        return U.next_out = St, U.avail_out = At, U.next_in = z, U.avail_in = X, A.hold = at, A.bits = ot, (A.wsize || Pt !== U.avail_out && A.mode < 30 && (A.mode < 27 || J !== 4)) && dt(U, U.output, U.next_out, Pt - U.avail_out) ? (A.mode = 31, -4) : (Ut -= U.avail_in, Pt -= U.avail_out, U.total_in += Ut, U.total_out += Pt, A.total += Pt, A.wrap && Pt && (U.adler = A.check = A.flags ? l(A.check, wt, Pt, U.next_out - Pt) : o(A.check, wt, Pt, U.next_out - Pt)), U.data_type = A.bits + (A.last ? 64 : 0) + (A.mode === 12 ? 128 : 0) + (A.mode === 20 || A.mode === 15 ? 256 : 0), (Ut == 0 && Pt === 0 || J === 4) && _t === y && (_t = -5), _t);
      }, n.inflateEnd = function(U) {
        if (!U || !U.state)
          return m;
        var J = U.state;
        return J.window && (J.window = null), U.state = null, y;
      }, n.inflateGetHeader = function(U, J) {
        var A;
        return U && U.state && 2 & (A = U.state).wrap ? ((A.head = J).done = !1, y) : m;
      }, n.inflateSetDictionary = function(U, J) {
        var A, R = J.length;
        return U && U.state ? (A = U.state).wrap !== 0 && A.mode !== 11 ? m : A.mode === 11 && o(1, J, R, 0) !== A.check ? -3 : dt(U, J, R, R) ? (A.mode = 31, -4) : (A.havedict = 1, y) : m;
      }, n.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 41, "./adler32": 43, "./crc32": 45, "./inffast": 48, "./inftrees": 50 }], 50: [function(e, i, n) {
      var r = e("../utils/common"), o = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], l = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], h = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], u = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      i.exports = function(d, g, y, m, x, b, I, C) {
        var P, k, O, B, j, V, Y, q, st, dt = C.bits, U = 0, J = 0, A = 0, R = 0, wt = 0, z = 0, St = 0, X = 0, At = 0, at = 0, ot = null, Ut = 0, Pt = new r.Buf16(16), Lt = new r.Buf16(16), Je = null, Bi = 0;
        for (U = 0; U <= 15; U++)
          Pt[U] = 0;
        for (J = 0; J < m; J++)
          Pt[g[y + J]]++;
        for (wt = dt, R = 15; 1 <= R && Pt[R] === 0; R--)
          ;
        if (R < wt && (wt = R), R === 0)
          return x[b++] = 20971520, x[b++] = 20971520, C.bits = 1, 0;
        for (A = 1; A < R && Pt[A] === 0; A++)
          ;
        for (wt < A && (wt = A), U = X = 1; U <= 15; U++)
          if (X <<= 1, (X -= Pt[U]) < 0)
            return -1;
        if (0 < X && (d === 0 || R !== 1))
          return -1;
        for (Lt[1] = 0, U = 1; U < 15; U++)
          Lt[U + 1] = Lt[U] + Pt[U];
        for (J = 0; J < m; J++)
          g[y + J] !== 0 && (I[Lt[g[y + J]]++] = J);
        if (V = d === 0 ? (ot = Je = I, 19) : d === 1 ? (ot = o, Ut -= 257, Je = l, Bi -= 257, 256) : (ot = h, Je = u, -1), U = A, j = b, St = J = at = 0, O = -1, B = (At = 1 << (z = wt)) - 1, d === 1 && 852 < At || d === 2 && 592 < At)
          return 1;
        for (; ; ) {
          for (Y = U - St, st = I[J] < V ? (q = 0, I[J]) : I[J] > V ? (q = Je[Bi + I[J]], ot[Ut + I[J]]) : (q = 96, 0), P = 1 << U - St, A = k = 1 << z; x[j + (at >> St) + (k -= P)] = Y << 24 | q << 16 | st | 0, k !== 0; )
            ;
          for (P = 1 << U - 1; at & P; )
            P >>= 1;
          if (P !== 0 ? (at &= P - 1, at += P) : at = 0, J++, --Pt[U] == 0) {
            if (U === R)
              break;
            U = g[y + I[J]];
          }
          if (wt < U && (at & B) !== O) {
            for (St === 0 && (St = wt), j += A, X = 1 << (z = U - St); z + St < R && !((X -= Pt[z + St]) <= 0); )
              z++, X <<= 1;
            if (At += 1 << z, d === 1 && 852 < At || d === 2 && 592 < At)
              return 1;
            x[O = at & B] = wt << 24 | z << 16 | j - b | 0;
          }
        }
        return at !== 0 && (x[j + at] = U - St << 24 | 64 << 16 | 0), C.bits = wt, 0;
      };
    }, { "../utils/common": 41 }], 51: [function(e, i, n) {
      i.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 52: [function(e, i, n) {
      var r = e("../utils/common"), o = 0, l = 1;
      function h(W) {
        for (var nt = W.length; 0 <= --nt; )
          W[nt] = 0;
      }
      var u = 0, d = 29, g = 256, y = g + 1 + d, m = 30, x = 19, b = 2 * y + 1, I = 15, C = 16, P = 7, k = 256, O = 16, B = 17, j = 18, V = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], Y = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], q = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], st = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], dt = new Array(2 * (y + 2));
      h(dt);
      var U = new Array(2 * m);
      h(U);
      var J = new Array(512);
      h(J);
      var A = new Array(256);
      h(A);
      var R = new Array(d);
      h(R);
      var wt, z, St, X = new Array(m);
      function At(W, nt, bt, It, rt) {
        this.static_tree = W, this.extra_bits = nt, this.extra_base = bt, this.elems = It, this.max_length = rt, this.has_stree = W && W.length;
      }
      function at(W, nt) {
        this.dyn_tree = W, this.max_code = 0, this.stat_desc = nt;
      }
      function ot(W) {
        return W < 256 ? J[W] : J[256 + (W >>> 7)];
      }
      function Ut(W, nt) {
        W.pending_buf[W.pending++] = 255 & nt, W.pending_buf[W.pending++] = nt >>> 8 & 255;
      }
      function Pt(W, nt, bt) {
        W.bi_valid > C - bt ? (W.bi_buf |= nt << W.bi_valid & 65535, Ut(W, W.bi_buf), W.bi_buf = nt >> C - W.bi_valid, W.bi_valid += bt - C) : (W.bi_buf |= nt << W.bi_valid & 65535, W.bi_valid += bt);
      }
      function Lt(W, nt, bt) {
        Pt(W, bt[2 * nt], bt[2 * nt + 1]);
      }
      function Je(W, nt) {
        for (var bt = 0; bt |= 1 & W, W >>>= 1, bt <<= 1, 0 < --nt; )
          ;
        return bt >>> 1;
      }
      function Bi(W, nt, bt) {
        var It, rt, xt = new Array(I + 1), Rt = 0;
        for (It = 1; It <= I; It++)
          xt[It] = Rt = Rt + bt[It - 1] << 1;
        for (rt = 0; rt <= nt; rt++) {
          var Dt = W[2 * rt + 1];
          Dt !== 0 && (W[2 * rt] = Je(xt[Dt]++, Dt));
        }
      }
      function re(W) {
        var nt;
        for (nt = 0; nt < y; nt++)
          W.dyn_ltree[2 * nt] = 0;
        for (nt = 0; nt < m; nt++)
          W.dyn_dtree[2 * nt] = 0;
        for (nt = 0; nt < x; nt++)
          W.bl_tree[2 * nt] = 0;
        W.dyn_ltree[2 * k] = 1, W.opt_len = W.static_len = 0, W.last_lit = W.matches = 0;
      }
      function xe(W) {
        8 < W.bi_valid ? Ut(W, W.bi_buf) : 0 < W.bi_valid && (W.pending_buf[W.pending++] = W.bi_buf), W.bi_buf = 0, W.bi_valid = 0;
      }
      function He(W, nt, bt, It) {
        var rt = 2 * nt, xt = 2 * bt;
        return W[rt] < W[xt] || W[rt] === W[xt] && It[nt] <= It[bt];
      }
      function Be(W, nt, bt) {
        for (var It = W.heap[bt], rt = bt << 1; rt <= W.heap_len && (rt < W.heap_len && He(nt, W.heap[rt + 1], W.heap[rt], W.depth) && rt++, !He(nt, It, W.heap[rt], W.depth)); )
          W.heap[bt] = W.heap[rt], bt = rt, rt <<= 1;
        W.heap[bt] = It;
      }
      function Ne(W, nt, bt) {
        var It, rt, xt, Rt, Dt = 0;
        if (W.last_lit !== 0)
          for (; It = W.pending_buf[W.d_buf + 2 * Dt] << 8 | W.pending_buf[W.d_buf + 2 * Dt + 1], rt = W.pending_buf[W.l_buf + Dt], Dt++, It === 0 ? Lt(W, rt, nt) : (Lt(W, (xt = A[rt]) + g + 1, nt), (Rt = V[xt]) !== 0 && Pt(W, rt -= R[xt], Rt), Lt(W, xt = ot(--It), bt), (Rt = Y[xt]) !== 0 && Pt(W, It -= X[xt], Rt)), Dt < W.last_lit; )
            ;
        Lt(W, k, nt);
      }
      function cn(W, nt) {
        var bt, It, rt, xt = nt.dyn_tree, Rt = nt.stat_desc.static_tree, Dt = nt.stat_desc.has_stree, Ht = nt.stat_desc.elems, Ue = -1;
        for (W.heap_len = 0, W.heap_max = b, bt = 0; bt < Ht; bt++)
          xt[2 * bt] !== 0 ? (W.heap[++W.heap_len] = Ue = bt, W.depth[bt] = 0) : xt[2 * bt + 1] = 0;
        for (; W.heap_len < 2; )
          xt[2 * (rt = W.heap[++W.heap_len] = Ue < 2 ? ++Ue : 0)] = 1, W.depth[rt] = 0, W.opt_len--, Dt && (W.static_len -= Rt[2 * rt + 1]);
        for (nt.max_code = Ue, bt = W.heap_len >> 1; 1 <= bt; bt--)
          Be(W, xt, bt);
        for (rt = Ht; bt = W.heap[1], W.heap[1] = W.heap[W.heap_len--], Be(W, xt, 1), It = W.heap[1], W.heap[--W.heap_max] = bt, W.heap[--W.heap_max] = It, xt[2 * rt] = xt[2 * bt] + xt[2 * It], W.depth[rt] = (W.depth[bt] >= W.depth[It] ? W.depth[bt] : W.depth[It]) + 1, xt[2 * bt + 1] = xt[2 * It + 1] = rt, W.heap[1] = rt++, Be(W, xt, 1), 2 <= W.heap_len; )
          ;
        W.heap[--W.heap_max] = W.heap[1], function(pe, sn) {
          var kn, $i, es, ai, Vs, zs, Fn = sn.dyn_tree, Qt = sn.max_code, Bn = sn.stat_desc.static_tree, Vn = sn.stat_desc.has_stree, ls = sn.stat_desc.extra_bits, qi = sn.stat_desc.extra_base, Ti = sn.stat_desc.max_length, $n = 0;
          for (ai = 0; ai <= I; ai++)
            pe.bl_count[ai] = 0;
          for (Fn[2 * pe.heap[pe.heap_max] + 1] = 0, kn = pe.heap_max + 1; kn < b; kn++)
            Ti < (ai = Fn[2 * Fn[2 * ($i = pe.heap[kn]) + 1] + 1] + 1) && (ai = Ti, $n++), Fn[2 * $i + 1] = ai, Qt < $i || (pe.bl_count[ai]++, Vs = 0, qi <= $i && (Vs = ls[$i - qi]), zs = Fn[2 * $i], pe.opt_len += zs * (ai + Vs), Vn && (pe.static_len += zs * (Bn[2 * $i + 1] + Vs)));
          if ($n !== 0) {
            do {
              for (ai = Ti - 1; pe.bl_count[ai] === 0; )
                ai--;
              pe.bl_count[ai]--, pe.bl_count[ai + 1] += 2, pe.bl_count[Ti]--, $n -= 2;
            } while (0 < $n);
            for (ai = Ti; ai !== 0; ai--)
              for ($i = pe.bl_count[ai]; $i !== 0; )
                Qt < (es = pe.heap[--kn]) || (Fn[2 * es + 1] !== ai && (pe.opt_len += (ai - Fn[2 * es + 1]) * Fn[2 * es], Fn[2 * es + 1] = ai), $i--);
          }
        }(W, nt), Bi(xt, Ue, W.bl_count);
      }
      function T(W, nt, bt) {
        var It, rt, xt = -1, Rt = nt[1], Dt = 0, Ht = 7, Ue = 4;
        for (Rt === 0 && (Ht = 138, Ue = 3), nt[2 * (bt + 1) + 1] = 65535, It = 0; It <= bt; It++)
          rt = Rt, Rt = nt[2 * (It + 1) + 1], ++Dt < Ht && rt === Rt || (Dt < Ue ? W.bl_tree[2 * rt] += Dt : rt !== 0 ? (rt !== xt && W.bl_tree[2 * rt]++, W.bl_tree[2 * O]++) : Dt <= 10 ? W.bl_tree[2 * B]++ : W.bl_tree[2 * j]++, xt = rt, Ue = (Dt = 0) === Rt ? (Ht = 138, 3) : rt === Rt ? (Ht = 6, 3) : (Ht = 7, 4));
      }
      function _t(W, nt, bt) {
        var It, rt, xt = -1, Rt = nt[1], Dt = 0, Ht = 7, Ue = 4;
        for (Rt === 0 && (Ht = 138, Ue = 3), It = 0; It <= bt; It++)
          if (rt = Rt, Rt = nt[2 * (It + 1) + 1], !(++Dt < Ht && rt === Rt)) {
            if (Dt < Ue)
              for (; Lt(W, rt, W.bl_tree), --Dt != 0; )
                ;
            else
              rt !== 0 ? (rt !== xt && (Lt(W, rt, W.bl_tree), Dt--), Lt(W, O, W.bl_tree), Pt(W, Dt - 3, 2)) : Dt <= 10 ? (Lt(W, B, W.bl_tree), Pt(W, Dt - 3, 3)) : (Lt(W, j, W.bl_tree), Pt(W, Dt - 11, 7));
            xt = rt, Ue = (Dt = 0) === Rt ? (Ht = 138, 3) : rt === Rt ? (Ht = 6, 3) : (Ht = 7, 4);
          }
      }
      h(X);
      var ft = !1;
      function $(W, nt, bt, It) {
        Pt(W, (u << 1) + (It ? 1 : 0), 3), function(rt, xt, Rt, Dt) {
          xe(rt), Ut(rt, Rt), Ut(rt, ~Rt), r.arraySet(rt.pending_buf, rt.window, xt, Rt, rt.pending), rt.pending += Rt;
        }(W, nt, bt);
      }
      n._tr_init = function(W) {
        ft || (function() {
          var nt, bt, It, rt, xt, Rt = new Array(I + 1);
          for (rt = It = 0; rt < d - 1; rt++)
            for (R[rt] = It, nt = 0; nt < 1 << V[rt]; nt++)
              A[It++] = rt;
          for (A[It - 1] = rt, rt = xt = 0; rt < 16; rt++)
            for (X[rt] = xt, nt = 0; nt < 1 << Y[rt]; nt++)
              J[xt++] = rt;
          for (xt >>= 7; rt < m; rt++)
            for (X[rt] = xt << 7, nt = 0; nt < 1 << Y[rt] - 7; nt++)
              J[256 + xt++] = rt;
          for (bt = 0; bt <= I; bt++)
            Rt[bt] = 0;
          for (nt = 0; nt <= 143; )
            dt[2 * nt + 1] = 8, nt++, Rt[8]++;
          for (; nt <= 255; )
            dt[2 * nt + 1] = 9, nt++, Rt[9]++;
          for (; nt <= 279; )
            dt[2 * nt + 1] = 7, nt++, Rt[7]++;
          for (; nt <= 287; )
            dt[2 * nt + 1] = 8, nt++, Rt[8]++;
          for (Bi(dt, y + 1, Rt), nt = 0; nt < m; nt++)
            U[2 * nt + 1] = 5, U[2 * nt] = Je(nt, 5);
          wt = new At(dt, V, g + 1, y, I), z = new At(U, Y, 0, m, I), St = new At(new Array(0), q, 0, x, P);
        }(), ft = !0), W.l_desc = new at(W.dyn_ltree, wt), W.d_desc = new at(W.dyn_dtree, z), W.bl_desc = new at(W.bl_tree, St), W.bi_buf = 0, W.bi_valid = 0, re(W);
      }, n._tr_stored_block = $, n._tr_flush_block = function(W, nt, bt, It) {
        var rt, xt, Rt = 0;
        0 < W.level ? (W.strm.data_type === 2 && (W.strm.data_type = function(Dt) {
          var Ht, Ue = 4093624447;
          for (Ht = 0; Ht <= 31; Ht++, Ue >>>= 1)
            if (1 & Ue && Dt.dyn_ltree[2 * Ht] !== 0)
              return o;
          if (Dt.dyn_ltree[18] !== 0 || Dt.dyn_ltree[20] !== 0 || Dt.dyn_ltree[26] !== 0)
            return l;
          for (Ht = 32; Ht < g; Ht++)
            if (Dt.dyn_ltree[2 * Ht] !== 0)
              return l;
          return o;
        }(W)), cn(W, W.l_desc), cn(W, W.d_desc), Rt = function(Dt) {
          var Ht;
          for (T(Dt, Dt.dyn_ltree, Dt.l_desc.max_code), T(Dt, Dt.dyn_dtree, Dt.d_desc.max_code), cn(Dt, Dt.bl_desc), Ht = x - 1; 3 <= Ht && Dt.bl_tree[2 * st[Ht] + 1] === 0; Ht--)
            ;
          return Dt.opt_len += 3 * (Ht + 1) + 5 + 5 + 4, Ht;
        }(W), rt = W.opt_len + 3 + 7 >>> 3, (xt = W.static_len + 3 + 7 >>> 3) <= rt && (rt = xt)) : rt = xt = bt + 5, bt + 4 <= rt && nt !== -1 ? $(W, nt, bt, It) : W.strategy === 4 || xt === rt ? (Pt(W, 2 + (It ? 1 : 0), 3), Ne(W, dt, U)) : (Pt(W, 4 + (It ? 1 : 0), 3), function(Dt, Ht, Ue, pe) {
          var sn;
          for (Pt(Dt, Ht - 257, 5), Pt(Dt, Ue - 1, 5), Pt(Dt, pe - 4, 4), sn = 0; sn < pe; sn++)
            Pt(Dt, Dt.bl_tree[2 * st[sn] + 1], 3);
          _t(Dt, Dt.dyn_ltree, Ht - 1), _t(Dt, Dt.dyn_dtree, Ue - 1);
        }(W, W.l_desc.max_code + 1, W.d_desc.max_code + 1, Rt + 1), Ne(W, W.dyn_ltree, W.dyn_dtree)), re(W), It && xe(W);
      }, n._tr_tally = function(W, nt, bt) {
        return W.pending_buf[W.d_buf + 2 * W.last_lit] = nt >>> 8 & 255, W.pending_buf[W.d_buf + 2 * W.last_lit + 1] = 255 & nt, W.pending_buf[W.l_buf + W.last_lit] = 255 & bt, W.last_lit++, nt === 0 ? W.dyn_ltree[2 * bt]++ : (W.matches++, nt--, W.dyn_ltree[2 * (A[bt] + g + 1)]++, W.dyn_dtree[2 * ot(nt)]++), W.last_lit === W.lit_bufsize - 1;
      }, n._tr_align = function(W) {
        Pt(W, 2, 3), Lt(W, k, dt), function(nt) {
          nt.bi_valid === 16 ? (Ut(nt, nt.bi_buf), nt.bi_buf = 0, nt.bi_valid = 0) : 8 <= nt.bi_valid && (nt.pending_buf[nt.pending++] = 255 & nt.bi_buf, nt.bi_buf >>= 8, nt.bi_valid -= 8);
        }(W);
      };
    }, { "../utils/common": 41 }], 53: [function(e, i, n) {
      i.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, {}], 54: [function(e, i, n) {
      (function(r) {
        (function(o, l) {
          if (!o.setImmediate) {
            var h, u, d, g, y = 1, m = {}, x = !1, b = o.document, I = Object.getPrototypeOf && Object.getPrototypeOf(o);
            I = I && I.setTimeout ? I : o, h = {}.toString.call(o.process) === "[object process]" ? function(O) {
              process.nextTick(function() {
                P(O);
              });
            } : function() {
              if (o.postMessage && !o.importScripts) {
                var O = !0, B = o.onmessage;
                return o.onmessage = function() {
                  O = !1;
                }, o.postMessage("", "*"), o.onmessage = B, O;
              }
            }() ? (g = "setImmediate$" + Math.random() + "$", o.addEventListener ? o.addEventListener("message", k, !1) : o.attachEvent("onmessage", k), function(O) {
              o.postMessage(g + O, "*");
            }) : o.MessageChannel ? ((d = new MessageChannel()).port1.onmessage = function(O) {
              P(O.data);
            }, function(O) {
              d.port2.postMessage(O);
            }) : b && "onreadystatechange" in b.createElement("script") ? (u = b.documentElement, function(O) {
              var B = b.createElement("script");
              B.onreadystatechange = function() {
                P(O), B.onreadystatechange = null, u.removeChild(B), B = null;
              }, u.appendChild(B);
            }) : function(O) {
              setTimeout(P, 0, O);
            }, I.setImmediate = function(O) {
              typeof O != "function" && (O = new Function("" + O));
              for (var B = new Array(arguments.length - 1), j = 0; j < B.length; j++)
                B[j] = arguments[j + 1];
              var V = { callback: O, args: B };
              return m[y] = V, h(y), y++;
            }, I.clearImmediate = C;
          }
          function C(O) {
            delete m[O];
          }
          function P(O) {
            if (x)
              setTimeout(P, 0, O);
            else {
              var B = m[O];
              if (B) {
                x = !0;
                try {
                  (function(j) {
                    var V = j.callback, Y = j.args;
                    switch (Y.length) {
                      case 0:
                        V();
                        break;
                      case 1:
                        V(Y[0]);
                        break;
                      case 2:
                        V(Y[0], Y[1]);
                        break;
                      case 3:
                        V(Y[0], Y[1], Y[2]);
                        break;
                      default:
                        V.apply(l, Y);
                    }
                  })(B);
                } finally {
                  C(O), x = !1;
                }
              }
            }
          }
          function k(O) {
            O.source === o && typeof O.data == "string" && O.data.indexOf(g) === 0 && P(+O.data.slice(g.length));
          }
        })(typeof self > "u" ? r === void 0 ? this : r : self);
      }).call(this, typeof ga < "u" ? ga : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}] }, {}, [10])(10);
  });
})(D_);
var Ig = D_.exports;
const O_ = /* @__PURE__ */ fd(Ig), zb = new O_();
class Du {
  constructor(t, e) {
    this._version = Xs.Unknown, this._topicsMap = /* @__PURE__ */ new Map(), this._bcfFileName = t, this._id = e;
  }
  /**
   * Exports BCF data to a file. Prompts the user to save it on their device.
   * @param filename Filename BCF data will be exported as
   */
  async exportBCF(t) {
    await this.toBcfZipBlob().then((e) => {
      const i = document.createElement("a"), n = URL.createObjectURL(e);
      i.href = n, i.download = `${t}.bcf`, document.body.appendChild(i), i.click(), setTimeout(() => {
        document.body.removeChild(i), URL.revokeObjectURL(n);
      }, 0);
    });
  }
  /**
   * Creates a BCFZIP blob. The resulting blob is importable using `BcfManager.addBCFFromBuffer`.
   */
  toBcfZipBlob() {
    const t = new XMLSerializer(), i = zb.file("bcf.version", '<?xml version="1.0" encoding="UTF-8"?><Version VersionId="2.1" xsi:noNamespaceSchemaLocation="version.xsd" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><DetailedVersion>2.1</DetailedVersion></Version>');
    return this._topicsMap.forEach((n, r) => {
      const o = i.folder(r);
      if (o === null) {
        console.error("Failed to create folder for BCF topic");
        return;
      }
      const l = t.serializeToString(n.getMarkup().export());
      o.file("markup.bcf", l), n.getViewpointMap().forEach((d, g) => {
        const y = t.serializeToString(d.export());
        o.file(g, y);
      }), n.getSnapshotMap().forEach((d, g) => {
        o.file(g, d.getData());
      });
    }), i.generateAsync({ type: "blob" });
  }
  /**
   * Adds a BCF topic.
   * @param topicId
   * @param topic
   */
  addTopic(t, e) {
    this._topicsMap.set(t, e);
  }
  /**
   * @returns A map associating BCF topic ids to BCF topic data.
   */
  getTopics() {
    return this._topicsMap;
  }
  /**
   * Gets a BCF topic.
   * @param topicId
   */
  getTopic(t) {
    return this._topicsMap.get(t) || null;
  }
  /**
   * Gets the BCF version.
   */
  getVersion() {
    return this._version;
  }
  /**
   * Sets the BCF version.
   * @param version
   */
  setVersion(t) {
    this._version = t;
  }
  /**
   * Gets the BCF filename.
   */
  getFilename() {
    return this._bcfFileName;
  }
  /**
   * Identifier used to keep track of loaded BCF data.
   */
  getId() {
    return this._id;
  }
}
function Ss() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(s) {
    const t = new Uint32Array(1);
    bv().getRandomValues(t);
    const e = t[0] / 4294967295 * 16 | 0;
    return (s === "x" ? e : e & 3 | 8).toString(16);
  });
}
class R_ {
  constructor(t, e, i, n, r, o) {
    this._ifcProject = t, this._ifcSpatialStructureElement = e, this._isExternal = i, this._filename = n, this._date = r, this._reference = o;
  }
  /**
   * [[GenericId]] Reference to the project to which this topic is related in the IFC file
   */
  getIfcProject() {
    return this._ifcProject || null;
  }
  /**
   * [[GenericId]] Reference to the spatial structure element, e.g. IfcBuildingStorey, to which this topic is related.
   */
  getIfcSpacialStructureElement() {
    return this._ifcSpatialStructureElement || null;
  }
  /**
   * Is the IFC file external or within the bcfzip
   */
  getIsExternal() {
    return this._isExternal || null;
  }
  /**
   * The BIM file related to this topic.
   */
  getBimFilename() {
    return this._filename || null;
  }
  /**
   * Date of the BIM file.
   */
  getBimDate() {
    return this._date || null;
  }
  /**
   * URI to IfcFile.
   * IsExternal=false "..\example.ifc" (within bcfzip)
   * IsExternal=true "https://.../example.ifc"
   */
  getReference() {
    return this._reference || null;
  }
}
class L_ {
  constructor(t, e, i, n) {
    this._viewpointFilename = void 0, this._snapshotFilename = void 0, this._index = void 0, this._guid = t, this._viewpointFilename = e, this._snapshotFilename = i, n !== void 0 && (this._index = parseInt(n, 10));
  }
  getGuid() {
    return this._guid;
  }
  getViewpointFilename() {
    return this._viewpointFilename || null;
  }
  getSnapshotFilename() {
    return this._snapshotFilename || null;
  }
  getIndex() {
    return this._index || null;
  }
}
class Vf {
  constructor(t, e, i, n, r, o, l) {
    this._guid = t, this._date = e, this._author = i, this._text = n, this._viewpointGuid = r, this._modifiedDate = o, this._modifiedAuthor = l;
  }
  getId() {
    return this._guid;
  }
  getDate() {
    return this._date;
  }
  setDate(t) {
    this._date = t;
  }
  getAuthor() {
    return this._author;
  }
  setAuthor(t) {
    this._author = t;
  }
  getText() {
    return this._text;
  }
  setText(t) {
    this._text = t;
  }
  getViewpointGuid() {
    return this._viewpointGuid || null;
  }
  setViewpointGuid(t) {
    this._viewpointGuid = t !== null ? t : void 0;
  }
  getModifiedDate() {
    return this._modifiedDate || null;
  }
  setModifiedDate(t) {
    this._modifiedDate = t !== null ? t : void 0;
  }
  getModifiedAuthor() {
    return this._modifiedAuthor || null;
  }
  setModifiedAuthor(t) {
    this._modifiedAuthor = t !== null ? t : void 0;
  }
}
class F_ {
  constructor(t, e, i) {
    this._markupHeaderFiles = [], this._topic = {
      guid: "",
      title: "",
      creationDate: /* @__PURE__ */ new Date(),
      creationAuthor: ""
    }, this._comments = /* @__PURE__ */ new Map(), this._viewpoints = /* @__PURE__ */ new Map(), this._filename = t, this._bcfTopic = i, this._parseDocument(e);
  }
  _parseDocument(t) {
    if (t === null)
      return;
    let i = t.documentElement.firstElementChild;
    for (; i !== null; ) {
      const n = i.localName;
      if (n === null)
        break;
      switch (n) {
        case "Header":
          this._parseHeader(i);
          break;
        case "Topic":
          this._parseTopic(i);
          break;
        case "Comment":
          this._parseComment(i);
          break;
        case "Viewpoints":
          this._parseViewpoint(i);
          break;
      }
      i = i.nextElementSibling;
    }
  }
  _exportHeader(t) {
    const e = t.createElement("Header");
    return Dr(e, "ProjectGuid", this._projectGuid), this._markupHeaderFiles.forEach((i) => {
      const n = t.createElement("File");
      Dr(n, "IfcProject", i.getIfcProject()), Dr(
        n,
        "IfcSpatialStructureElement",
        i.getIfcSpacialStructureElement()
      ), Dr(
        n,
        "isExternal",
        Nu(i.getIsExternal())
      ), on(t, n, "Filename", i.getBimFilename()), on(t, n, "Date", bc(i.getBimDate())), on(t, n, "Reference", i.getReference()), e.appendChild(n);
    }), e;
  }
  _exportTopicData(t) {
    const e = t.createElement("Topic");
    if (e.setAttribute("Guid", this._topic.guid), Dr(e, "TopicType", this._topic.topicType), Dr(e, "TopicStatus", this._topic.topicStatus), Rr(t, e, "Title", this._topic.title), Rr(t, e, "CreationDate", this._topic.creationDate.toISOString()), Rr(t, e, "CreationAuthor", this._topic.creationAuthor), on(t, e, "ReferenceLink", this._topic.referenceLink), on(t, e, "Priority", this._topic.priority), on(t, e, "Index", Bf(this._topic.index)), on(
      t,
      e,
      "ModifiedDate",
      bc(this._topic.modifiedDate)
    ), on(t, e, "ModifiedAuthor", this._topic.modifiedAuthor), on(t, e, "DueDate", bc(this._topic.dueDate)), on(t, e, "AssignedTo", this._topic.assignedTo), on(t, e, "Description", this._topic.description), on(t, e, "Stage", this._topic.stage), this._topic.labels) {
      const i = t.createElement("Labels");
      this._topic.labels.forEach((n) => {
        Rr(t, i, "Label", n);
      }), e.appendChild(i);
    }
    return e;
  }
  _exportBimSnippet(t, e) {
    const i = t.createElement("BimSnippet");
    return i.setAttribute("SnippetType", e.snippetType), Dr(
      i,
      "isExternal",
      Nu(e.isExternal)
    ), Rr(t, i, "Reference", e.reference), on(t, i, "ReferenceSchema", e.referenceSchema), i;
  }
  _exportDocumentReference(t, e) {
    const i = t.createElement("DocumentReference");
    return Dr(i, "Guid", e.guid), Dr(
      i,
      "isExternal",
      Nu(e.isExternal)
    ), on(
      t,
      i,
      "ReferencedDocument",
      e.referencedDocument
    ), on(t, i, "Description", e.description), i;
  }
  _exportRelatedTopic(t, e) {
    const i = t.createElement("RelatedTopic");
    return i.setAttribute("Guid", e.guid), i;
  }
  _exportTopic(t) {
    const e = this._exportTopicData(t);
    return this._topic.bimSnippets && this._topic.bimSnippets.forEach((i) => {
      e.appendChild(this._exportBimSnippet(t, i));
    }), this._topic.documentReferences && this._topic.documentReferences.forEach((i) => {
      e.appendChild(this._exportDocumentReference(t, i));
    }), this._topic.relatedTopics && this._topic.relatedTopics.forEach((i) => {
      e.appendChild(this._exportRelatedTopic(t, i));
    }), e;
  }
  _exportComment(t, e) {
    const i = t.createElement("Comment");
    i.setAttribute("Guid", e.getId()), Rr(t, i, "Date", e.getDate().toISOString()), Rr(t, i, "Author", e.getAuthor()), Rr(t, i, "Comment", e.getText()), on(
      t,
      i,
      "ModifiedDate",
      bc(e.getModifiedDate())
    ), on(t, i, "ModifiedAuthor", e.getModifiedAuthor());
    const n = e.getViewpointGuid();
    if (n) {
      const r = t.createElement("Viewpoint");
      r.setAttribute("Guid", n), i.appendChild(r);
    }
    return i;
  }
  _exportViewpoint(t, e) {
    const i = t.createElement("Viewpoints");
    return i.setAttribute("Guid", e.getGuid()), on(t, i, "Viewpoint", e.getViewpointFilename()), on(t, i, "Snapshot", e.getSnapshotFilename()), on(
      t,
      i,
      "Index",
      Bf(e.getIndex())
    ), i;
  }
  /**
   * @returns XML document containing the markup data.
   */
  export() {
    const t = document.implementation.createDocument("", "", null), e = t.createElement("Markup");
    return e.appendChild(this._exportHeader(t)), e.appendChild(this._exportTopic(t)), this._comments.forEach((i) => {
      e.appendChild(this._exportComment(t, i));
    }), this._viewpoints.forEach((i) => {
      e.appendChild(this._exportViewpoint(t, i));
    }), t.appendChild(e), t;
  }
  /**
   * @returns the project GUID.
   */
  getProjectGuid() {
    return this._projectGuid || null;
  }
  /**
   * @returns a list of [[BCFMarkupHeaderFile]] containing data related to IFC files.
   */
  getMarkupHeaderFiles() {
    return this._markupHeaderFiles;
  }
  /**
   * Gets the Markup filename.
   */
  getFilename() {
    return this._filename;
  }
  /**
   * Gets the topic id.
   */
  getTopicId() {
    return this._topic.guid;
  }
  /**
   * Sets the topic id.
   * @param guid
   */
  setTopicId(t) {
    this._topic.guid = t;
  }
  /**
   * Gets the topic type.
   */
  getTopicType() {
    return this._topic.topicType || null;
  }
  /**
   * Sets the topic type.
   * @param topicType
   */
  setTopicType(t) {
    this._topic.topicType = t !== null ? t : void 0;
  }
  /**
   * Gets the topic status.
   */
  getTopicStatus() {
    return this._topic.topicStatus || null;
  }
  /**
   * Sets the topic status.
   * @param topicStatus
   */
  setTopicStatus(t) {
    this._topic.topicStatus = t !== null ? t : void 0;
  }
  /**
   * Gets the title of the markup topic.
   */
  getTopicTitle() {
    return this._topic.title;
  }
  /**
   * Sets the title of the markup topic.
   * @param title
   */
  setTopicTitle(t) {
    this._topic.title = t;
  }
  /**
   * Gets the creation date of the markup topic.
   */
  getTopicCreationDate() {
    return this._topic.creationDate;
  }
  /**
   * Sets the creation date of the markup topic;
   * @param date
   */
  setTopicCreationDate(t) {
    this._topic.creationDate = t;
  }
  /**
   * Gets the name of the user that created the markup topic.
   */
  getTopicCreationAuthor() {
    return this._topic.creationAuthor;
  }
  /**
   * Sets the name of the user that created the markup topic.
   * @param author
   */
  setTopicCreationAuthor(t) {
    this._topic.creationAuthor = t;
  }
  /**
   * List of references to the topic, for example, a work request management system or an URI to a model.
   */
  getTopicReferenceLink() {
    return this._topic.referenceLink || null;
  }
  /**
   * Sets the ReferenceLink.
   * @param referenceLink
   */
  setTopicReferenceLink(t) {
    this._topic.referenceLink = t === null ? void 0 : t;
  }
  /**
   * Gets the topic priority.
   */
  getTopicPriority() {
    return this._topic.priority || null;
  }
  /**
   * Sets the topic priority.
   * @param priority
   */
  setTopicPriority(t) {
    this._topic.priority = t === null ? void 0 : t;
  }
  /**
   * Number to maintain the order of the topics.
   */
  getTopicIndex() {
    return this._topic.index || null;
  }
  /**
   * Sets the topic index.
   * @param index
   */
  setTopicIndex(t) {
    this._topic.index = t === null ? void 0 : t;
  }
  /**
   * Tags for grouping Topics.
   */
  getTopicLabels() {
    return this._topic.labels === void 0 ? [] : this._topic.labels.slice();
  }
  /**
   * Sets the topic labels.
   * @param labels
   */
  setTopicLabels(t) {
    this._topic.labels = t.slice();
  }
  /**
   * Date when the topic was last modified. Exists only when Topic has been modified after creation.
   */
  getTopicModifiedDate() {
    return this._topic.modifiedDate || null;
  }
  /**
   * Sets the topic modified date.
   * @param date
   */
  setTopicModifiedDate(t) {
    this._topic.modifiedDate = t === null ? void 0 : t;
  }
  /**
   * User who modified the topic. Exists only when Topic has been modified after creation.
   */
  getTopicModifiedAuthor() {
    return this._topic.modifiedAuthor || null;
  }
  /**
   * Sets the author that last modified the topic.
   * @param modifiedAuthor
   */
  setTopicModifiedAuthor(t) {
    this._topic.modifiedAuthor = t === null ? void 0 : t;
  }
  /**
   * Date when the issue needs to be resolved by.
   */
  getTopicDueDate() {
    return this._topic.dueDate || null;
  }
  /**
   * Sets the topic due date.
   * @param date
   */
  setTopicDueDate(t) {
    this._topic.dueDate = t === null ? void 0 : t;
  }
  /**
   * The user to whom this topic is assigned to. Recommended to be in email format. The list of possible values are defined in the extension schema.
   */
  getTopicAssignedTo() {
    return this._topic.assignedTo || null;
  }
  /**
   * Sets the user that the topic is assigned to.
   */
  setTopicAssignedTo(t) {
    this._topic.assignedTo = t === null ? void 0 : t;
  }
  /**
   * Description of the topic.
   */
  getTopicDescription() {
    return this._topic.description || null;
  }
  /**
   * Sets the topic description;
   * @param description
   */
  setTopicDescription(t) {
    this._topic.description = t === null ? void 0 : t;
  }
  /**
   * Stage this topic is part of.
   */
  getTopicStage() {
    return this._topic.stage || null;
  }
  /**
   * Sets the topic stage;
   * @param stage
   */
  setTopicState(t) {
    this._topic.stage = t === null ? void 0 : t;
  }
  /**
   * Gets a map of GUIDs and corresponding comments.
   */
  getComments() {
    return this._comments;
  }
  /**
   * Adds a comment to the topic.
   * @param date
   * @param author
   * @param text
   * @param viewpointGuid
   * @param modifiedDate
   * @param modifiedAuthor
   */
  addComment(t, e, i, n, r, o) {
    const l = Ss(), h = new Vf(
      l,
      t,
      e,
      i,
      n,
      r,
      o
    );
    return this._comments.set(l, h), h;
  }
  /**
   * Updates a topic comment.
   * @param comment
   */
  updateComment(t) {
    const e = t.getId();
    this._comments.set(e, t);
  }
  /**
   * Deletes a comment from the topic..
   * @param guid
   */
  deleteComment(t) {
    this._comments.delete(t);
  }
  /**
   * Gets a map of GUIDs and corresponding viewpoints.
   */
  getViewpoints() {
    return this._viewpoints;
  }
  _addFile(t) {
    const e = this._getElementAttributes(t), i = this._getChildData(t), n = i.get("Date"), r = {
      date: n === void 0 ? void 0 : new Date(n),
      filename: i.get("Filename"),
      reference: i.get("Reference"),
      ifcProject: e.get("IfcProject"),
      ifcSpatialStructureElement: e.get("IfcSpatialStructureElement"),
      isExternal: e.get("isExternal") === "true"
    };
    this._markupHeaderFiles.push(
      new R_(
        r.ifcProject,
        r.ifcSpatialStructureElement,
        r.isExternal,
        r.filename,
        r.date,
        r.reference
      )
    );
  }
  _parseHeader(t) {
    const i = this._getElementAttributes(t).get("ProjectGuid");
    i !== void 0 && (this._projectGuid = i);
    let n = t.firstElementChild;
    n !== null && (this._addFile(n), n = n.nextElementSibling);
  }
  _parseTopic(t) {
    const e = this._getElementAttributes(t), i = e.get("Guid");
    if (i === void 0)
      return;
    this._topic.guid = i, this._topic.topicType = e.get("TopicType") || e.get("Status"), this._topic.topicStatus = e.get("TopicStatus") || e.get("VerbalStatus");
    let n = t.firstElementChild;
    if (n !== null)
      for (; n !== null; ) {
        const r = n.localName;
        if (r === null)
          break;
        const o = this._getChildData(n), l = this._getElementAttributes(n);
        switch (r) {
          case "BimSnippet":
            {
              this._topic.bimSnippets === void 0 && (this._topic.bimSnippets = []);
              const h = o.get("Reference"), u = l.get("SnippetType");
              if (h !== void 0 && u !== void 0) {
                const d = {
                  snippetType: u,
                  reference: h
                };
                l.get("isExternal") && (d.isExternal = l.get("isExternal") === "true"), o.get("ReferenceSchema") && (d.referenceSchema = o.get("ReferenceSchema")), this._topic.bimSnippets.push(d);
              }
            }
            break;
          case "DocumentReference":
            {
              this._topic.documentReferences === void 0 && (this._topic.documentReferences = []);
              const h = {};
              o.get("Guid") && (h.guid = o.get("Guid")), o.get("isExternal") && (h.isExternal = o.get("isExternal") === "true"), o.get("Description") && (h.description = o.get("Description")), o.get("ReferencedDocument") && (h.referencedDocument = o.get("ReferencedDocument")), this._topic.documentReferences.push(h);
            }
            break;
          case "RelatedTopic":
            {
              this._topic.relatedTopics === void 0 && (this._topic.relatedTopics = []);
              const h = o.get("Guid");
              if (h !== void 0) {
                const u = {
                  guid: h
                };
                this._topic.relatedTopics.push(u);
              }
            }
            break;
          case "ReferenceLink":
            n.textContent && (this._topic.referenceLink = n.textContent);
            break;
          case "Title":
            n.textContent && (this._topic.title = n.textContent);
            break;
          case "Priority":
            n.textContent && (this._topic.priority = n.textContent);
            break;
          case "Index":
            n.textContent && (this._topic.index = parseInt(n.textContent, 10));
            break;
          case "Labels":
            {
              let h = n.firstChild;
              if (!h)
                break;
              for (this._topic.labels === void 0 && (this._topic.labels = []); h; )
                h.textContent && this._topic.labels.push(h.textContent), h = h.nextSibling;
            }
            break;
          case "CreationDate":
            n.textContent && (this._topic.creationDate = new Date(n.textContent));
            break;
          case "CreationAuthor":
            n.textContent && (this._topic.creationAuthor = n.textContent);
            break;
          case "ModifiedDate":
            n.textContent && (this._topic.modifiedDate = new Date(n.textContent));
            break;
          case "ModifiedAuthor":
            n.textContent && (this._topic.modifiedAuthor = n.textContent);
            break;
          case "DueDate":
            n.textContent && (this._topic.dueDate = new Date(n.textContent));
            break;
          case "AssignedTo":
            n.textContent && (this._topic.assignedTo = n.textContent);
            break;
          case "Description":
            n.textContent && (this._topic.description = n.textContent);
            break;
          case "Stage":
            n.textContent && (this._topic.stage = n.textContent);
            break;
        }
        n = n.nextElementSibling;
      }
  }
  _parseComment(t) {
    let e = "", i = /* @__PURE__ */ new Date(), n = "", r = "", o, l, h;
    const d = this._getElementAttributes(t).get("Guid");
    if (d)
      e = d;
    else
      return;
    let g = t.firstElementChild;
    if (g !== null)
      for (; g !== null; ) {
        const m = g.localName;
        if (m === null)
          break;
        switch (m) {
          case "Date":
            g.textContent && (i = new Date(g.textContent));
            break;
          case "Author":
            g.textContent && (n = g.textContent);
            break;
          case "Comment":
            g.textContent && (r = g.textContent);
            break;
          case "Viewpoint":
            o = this._getElementAttributes(g).get("Guid");
            break;
          case "ModifiedDate":
            g.textContent && (l = new Date(g.textContent));
            break;
          case "ModifiedAuthor":
            g.textContent && (h = g.textContent);
            break;
        }
        g = g.nextElementSibling;
      }
    const y = new Vf(
      e,
      i,
      n,
      r,
      o,
      l,
      h
    );
    this._comments.set(e, y);
  }
  _parseViewpoint(t) {
    const i = this._getElementAttributes(t).get("Guid");
    if (i !== void 0) {
      const n = this._getChildData(t), r = n.get("Viewpoint"), o = n.get("Snapshot"), l = n.get("Index");
      this.addViewpoint(i, r, o, l);
    }
  }
  addViewpoint(t, e, i, n) {
    this._viewpoints.set(
      t,
      new L_(t, e, i, n)
    );
  }
  _getChildData(t) {
    const e = /* @__PURE__ */ new Map();
    let i = t.firstElementChild;
    for (; i !== null; ) {
      const n = i.localName;
      let r = null;
      i.firstElementChild === null && (r = i.textContent), n !== null && r !== null && e.set(n, r), i = i.nextElementSibling;
    }
    return e;
  }
  _getElementAttributes(t) {
    const e = t.attributes, i = /* @__PURE__ */ new Map();
    for (let n = 0; n < e.length; ++n) {
      const r = e[n], o = r.name, l = r.value;
      i.set(o, l);
    }
    return i;
  }
}
class xa {
  constructor(t, e) {
    this._filename = t, this._data = e;
  }
  /**
   * Creates a BCF Snapshot from an HTMLImageElement.
   * @param filename
   * @param image
   */
  static createFromImage(t, e) {
    const i = xa.snapshotDataFromImage(e);
    return new xa(t, i);
  }
  /**
   * Gets the filename.
   */
  getFilename() {
    return this._filename;
  }
  /**
   * Gets png data.
   */
  getData() {
    return this._data;
  }
  /**
   * Gets a url for images corresponding to viewpoints.
   */
  getUrl() {
    const t = new Blob([this._data], { type: "image/png" });
    return URL.createObjectURL(t, { oneTimeOnly: !0 });
  }
  /**
   * Gets image data as a Uint8Array from an HTMLImageElement.
   * @param img
   */
  static snapshotDataFromImage(t) {
    const e = t.src;
    return xa._convertDataURIToBinary(e);
  }
  static _convertDataURIToBinary(t) {
    const e = ";base64,", i = t.indexOf(e) + e.length, n = window.atob(t.substring(i)), r = new Uint8Array(n.length);
    for (let o = 0; o < n.length; o++) {
      const l = n[o].charCodeAt(0);
      r[o] = l;
    }
    return r;
  }
}
class go {
  constructor() {
    this._behindView = !1;
  }
  /**
   * Called when the MarkupItem is removed from a view from the system.
   * Any cleanup that needs to be done should be performed in this method.
   * @param view the view to remove from, null if removed from everywhere.
   */
  remove(t) {
  }
  // XXX: This should probably have a `Promise<void>` return type. See `NoteText.prototype.remove` for an example.
  /**
   * Called when the markup item should be redrawn on a specific view. This most typically happens when the scene is rendered.
   * @param renderer renderer engine to draw.
   * @param view the view to draw on.
   */
  draw(t, e) {
  }
  /**
   * Called when a hit test is performed on this markup item.
   * @param point position in window where the hit test is being performed.
   * @returns boolean value indicating whether this item was picked
   */
  hit(t, e) {
    return !1;
  }
  /**
   * Called when a hit test is performed on this markup item.
   * @param point position in window where the hit test is being performed.
   * @param pickTolerance amount of tolerance allowed for a hit in pixels.
   * @returns boolean value indicating whether this item was picked
   */
  hitWithTolerance(t, e, i) {
    return !1;
  }
  /**
   * Called when this markup item is selected by the system from a given view.
   * @param view the view where the selection occured
   */
  onSelect(t) {
  }
  /**
   * Called when this markup item is deselected by the system
   */
  onDeselect() {
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return {};
  }
  /**
   * Gets the fully qualified class name for this markup item. E.g. "Communicator.Markup.Redline.RedlineCircle"
   * @returns fully qualified class name
   */
  getClassName() {
    return "Communicator.Markup.MarkupItem";
  }
}
class Ll extends go {
  constructor(t) {
    super(), this._viewer = t;
  }
  onDragStart(t, e) {
    return !1;
  }
  onDragMove(t, e) {
    return !1;
  }
  onDragEnd(t, e) {
    return !1;
  }
  remove(t) {
    this._viewer.trigger("redlineDeleted", this);
  }
}
class Cg {
  constructor() {
    this._strokeWidth = 1, this._strokeColor = vt.black();
  }
  /** @hidden */
  _assign(t) {
    this._strokeWidth = t._strokeWidth, this._strokeColor.assign(t._strokeColor);
  }
  /**
   * Sets the stroke color for this shape
   * @param color the stroke color
   */
  setStrokeColor(t) {
    this._strokeColor.assign(t);
  }
  /**
   * Gets the stroke color for this shape
   * @returns the stroke color
   */
  getStrokeColor() {
    return this._strokeColor.copy();
  }
  /**
   * Sets the stroke width for this shape in pixels
   * @param strokeWidth the stroke width in pixels
   */
  setStrokeWidth(t) {
    this._strokeWidth = t;
  }
  /**
   * Gets the stroke width for this shape in pixels
   * @returns the stroke width in pixels
   */
  getStrokeWidth() {
    return this._strokeWidth;
  }
}
class Fa extends Cg {
  constructor() {
    super(...arguments), this._fillColor = vt.black(), this._fillOpacity = 1;
  }
  /** @hidden */
  _assign(t) {
    super._assign(t), this._fillColor.assign(t._fillColor), this._fillOpacity = t._fillOpacity;
  }
  /**
   * Gets the fill opacity for this shape
   * @returns the fill opacity
   */
  getFillOpacity() {
    return this._fillOpacity;
  }
  /**
   * Sets the fill opacity for this shape
   * @param fillOpacity the fill opacity
   */
  setFillOpacity(t) {
    this._fillOpacity = t;
  }
  /**
   * Sets the fill color for this shape
   * @param color the fill color
   */
  setFillColor(t) {
    this._fillColor.assign(t);
  }
  /**
   * Gets the fill color for this shape
   * @returns the fill color
   */
  getFillColor() {
    return this._fillColor.copy();
  }
}
var _n = /* @__PURE__ */ ((s) => (s[s.None = 0] = "None", s[s.Arrowhead = 1] = "Arrowhead", s[s.Circle = 2] = "Circle", s))(_n || {});
const $p = 9;
class Dh extends Cg {
  constructor() {
    super(...arguments), this._startEndcapType = 0, this._startEndcapColor = vt.black(), this._startEndcapSize = $p, this._endEndcapType = 0, this._endEndcapColor = vt.black(), this._endEndcapSize = $p, this._endcapsInverted = !1;
  }
  /** @hidden */
  _assign(t) {
    super._assign(t), this._startEndcapType = t._startEndcapType, this._startEndcapColor.assign(t._startEndcapColor), this._startEndcapSize = t._startEndcapSize, this._endEndcapType = t._endEndcapType, this._endEndcapColor.assign(t._endEndcapColor), this._endEndcapSize = t._endEndcapSize, this._endcapsInverted = t._endcapsInverted;
  }
  /**
   * Gets the start endcap type for this shape. The default Value is none.
   * @returns the start endcap type
   */
  getStartEndcapType() {
    return this._startEndcapType;
  }
  /**
   * Sets the start endcap type for this shape
   * @param endcapType the new endcap type
   */
  setStartEndcapType(t) {
    this._startEndcapType = t;
  }
  /**
   * Gets the color of the start endcap. Default value is black.
   * @returns color for the start endcap.
   */
  getStartEndcapColor() {
    return this._startEndcapColor.copy();
  }
  /**
   * Sets the color for the start endcap.
   * @param color the start endcap color value.
   */
  setStartEndcapColor(t) {
    this._startEndcapColor.assign(t);
  }
  /**
   * Gets the size of the start endcap in pixels. Default value is 9.
   * @returns size of the start endcap.
   */
  getStartEndcapSize() {
    return this._startEndcapSize;
  }
  /**
   * Sets the size of the start endcap in pixels.
   * @param size the start endcap.
   */
  setStartEndcapSize(t) {
    this._startEndcapSize = t;
  }
  /**
   * Gets the end endcap type for this shape. The default value is none.
   * @returns the end endcap type
   */
  getEndEndcapType() {
    return this._endEndcapType;
  }
  /**
   * Sets the end endcap type for this shape
   * @param endcapType the new endcap type
   */
  setEndEndcapType(t) {
    this._endEndcapType = t;
  }
  /**
   * Convenience for setting the start and eend endcap type for this shape
   * @param endcapType the new endcap type
   */
  setEndcapType(t) {
    this._startEndcapType = t, this._endEndcapType = t;
  }
  /**
   * Gets the size of the end endcap in pixels. Default value is 9.
   * @returns size of the end endcap.
   */
  getEndEndcapSize() {
    return this._endEndcapSize;
  }
  /**
   * Sets the size of the end endcap in pixels.
   * @param size the end endcap.
   */
  setEndEndcapSize(t) {
    this._endEndcapSize = t;
  }
  /**
   * Gets the color of the end endcap. Default value is black.
   * @returns color for the end endcap.
   */
  getEndEndcapColor() {
    return this._endEndcapColor.copy();
  }
  /**
   * Sets the color for the end endcap.
   * @param color the end endcap color value.
   */
  setEndEndcapColor(t) {
    this._endEndcapColor.assign(t);
  }
  /**
   * Gets whether endcaps are inverted for this shape. The default value is false.
   * @returns value indicating whether endcaps are inverted
   */
  getEndcapsInverted() {
    return this._endcapsInverted;
  }
  /**
   * Sets whether endcapsare inverted for this shape.
   * @param inverted value indicated whether endcaps should be inverted
   */
  setEndcapsInverted(t) {
    this._endcapsInverted = t;
  }
}
class Gr extends Fa {
  constructor() {
    super(...arguments), this._center = K.zero(), this._radius = 1;
  }
  /**
   * Sets the values for the circle
   * @param center the center point of the circle.
   * @radius the circle radius.
   */
  set(t, e) {
    this._center.assign(t), this.setRadius(e);
  }
  /**
   * Gets the center of the circle
   * @returns the circle center
   */
  getCenter() {
    return this._center.copy();
  }
  /**
   * Sets the center of the circle
   * @param the circle center
   */
  setCenter(t) {
    this._center.assign(t);
  }
  /**
   * Gets the radius of the circle
   * @returns the circle radius
   */
  getRadius() {
    return this._radius;
  }
  /**
   * Sets the radius of the circle
   * @param radius the circle radius
   */
  setRadius(t) {
    this._radius = t;
  }
}
class B_ {
  constructor(t, e) {
    this.center = t.copy(), this.radius = e;
  }
}
class Sg extends Fa {
  constructor() {
    super(...arguments), this._circles = [];
  }
  /**
   * Removes all circles from this collection
   */
  clear() {
    this._circles = [];
  }
  /**
   * Adds a circle to the collection
   * @param center circle center
   * @param radius the circle radius
   */
  addCircle(t, e) {
    this._circles.push(new B_(t, e));
  }
  /**
   * Updates a circle in the collection
   * @param index the index of the circle to update
   * @param center circle center
   * @param radius the circle radius
   */
  setCircle(t, e, i) {
    const n = this._circles[t];
    n.center.assign(e), n.radius = i;
  }
  /**
   * Gets the circles in the collection
   */
  getCircles() {
    return this._circles;
  }
}
const ua = class ua extends Ll {
  constructor(t) {
    super(t), this._uniqueId = Ss(), this._centerPt = _.zero(), this._radiusPt = _.zero(), this._circleShape = new Gr(), this._previousDragPlanePosition = _.zero(), this._circleShape.setFillOpacity(0), this._circleShape.setStrokeColor(vt.red()), this._circleShape.setStrokeWidth(2);
  }
  setCenter(t) {
    this._centerPt.assign(t);
  }
  getCenter() {
    return this._centerPt.copy();
  }
  setRadiusPoint(t) {
    this._radiusPt.assign(t);
  }
  getRadiusPoint() {
    return this._radiusPt.copy();
  }
  getUniqueId() {
    return this._uniqueId;
  }
  _update(t) {
    const e = K.fromPoint3(t.projectPoint(this._centerPt)), i = K.fromPoint3(t.projectPoint(this._radiusPt)), n = K.distance(e, i);
    this._circleShape.set(e, n);
  }
  draw(t, e) {
    this._update(e), t.drawCircle(this._circleShape);
  }
  hit(t, e) {
    return this.hitWithTolerance(t, e, 0);
  }
  hitWithTolerance(t, e, i) {
    this._update(e);
    const n = this._circleShape.getStrokeWidth() + i, r = K.distance(this._circleShape.getCenter(), t) - this._circleShape.getRadius();
    return Math.abs(r) <= n;
  }
  onSelect() {
    this._circleShape.setStrokeWidth(4);
  }
  onDeselect() {
    this._circleShape.setStrokeWidth(2);
  }
  isValid() {
    return this._circleShape.getRadius() > ua._validRadiusTolerance;
  }
  // dragging methods
  onDragStart(t, e) {
    const i = e.getCamera().getCameraPlaneIntersectionPoint(t, e);
    return i !== null && this._previousDragPlanePosition.assign(i), !1;
  }
  onDragMove(t, e) {
    const i = e.getCamera().getCameraPlaneIntersectionPoint(t, e);
    if (i !== null) {
      const n = _.subtract(i, this._previousDragPlanePosition);
      this._centerPt.add(n), this._radiusPt.add(n), this._previousDragPlanePosition.assign(i);
    }
    return !0;
  }
  // Serialization methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      uniqueId: this._uniqueId,
      centerPoint: this._centerPt.toJson(),
      radiusPoint: this._radiusPt.toJson(),
      className: this.getClassName()
    };
  }
  /**
   * Creates a new [[RedlineCircle]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t, e) {
    const i = t, n = new ua(e);
    return n._uniqueId = i.uniqueId, n.setCenter(_.fromJson(i.centerPoint)), n.setRadiusPoint(_.fromJson(i.radiusPoint)), n;
  }
  getClassName() {
    return ua.className;
  }
};
ua.className = "Communicator.Markup.Redline.RedlineCircle", ua._validRadiusTolerance = 1;
let Aa = ua;
as(Aa.className, Aa.fromJson);
class Ba extends Dh {
  constructor() {
    super(...arguments), this._points = [];
  }
  /**
   * Removes all points from this polyline
   */
  clearPoints() {
    this._points = [];
  }
  /**
   * Gets the points in this polyline
   * @returns the points in this polyline
   */
  getPoints() {
    return this._points;
  }
  /**
   * Adds a point to the polyline
   * @param point the point to add to the line
   */
  pushPoint(t) {
    this._points.push(t.copy());
  }
}
class Hb extends Dh {
  constructor() {
    super(...arguments), this._polylines = [];
  }
  /**
   * Removes all polylines from the collection
   */
  clear() {
    this._polylines = [];
  }
  /**
   * Creates a new array of points that represent a polyline. Add Point2 objects to the array to construct the polyline
   * @returns new array which represents a polyline.
   */
  createPolyline() {
    const t = [];
    return this._polylines.push(t), t;
  }
  /**
   * @returns the polylines in this collection
   */
  getPolylines() {
    return this._polylines;
  }
}
const Rc = class Rc extends Ll {
  constructor(t) {
    super(t), this._uniqueId = Ss(), this._points = [], this._polylineShape = new Ba(), this._previousDragPlanePosition = _.zero(), this._polylineShape.setStrokeWidth(2), this._polylineShape.setStrokeColor(vt.red());
  }
  addPoint(t) {
    this._points.push(t.copy());
  }
  getPoints() {
    const t = [];
    return this._points.forEach((e) => {
      t.push(e.copy());
    }), t;
  }
  _update(t) {
    this._polylineShape.clearPoints();
    for (const e of this._points) {
      const i = K.fromPoint3(t.projectPoint(e));
      this._polylineShape.pushPoint(i);
    }
  }
  draw(t, e) {
    this._update(e), this.isValid() && t.drawPolyline(this._polylineShape);
  }
  hit(t, e) {
    return this.hitWithTolerance(t, e, 0);
  }
  hitWithTolerance(t, e, i) {
    this._update(e);
    const n = this._polylineShape.getStrokeWidth() + i, r = this._polylineShape.getPoints();
    if (r.length > 1) {
      for (let o = 1; o < r.length; o++)
        if (uc(t, r[o - 1], r[o], n))
          return !0;
    }
    return !1;
  }
  onSelect() {
    this._polylineShape.setStrokeWidth(4);
  }
  onDeselect() {
    this._polylineShape.setStrokeWidth(2);
  }
  getClassName() {
    return Rc.className;
  }
  isValid() {
    return this._points.length > 1;
  }
  // dragging methods
  onDragStart(t, e) {
    const i = e.getCamera().getCameraPlaneIntersectionPoint(t, e);
    return i !== null && this._previousDragPlanePosition.assign(i), !1;
  }
  onDragMove(t, e) {
    const i = e.getCamera().getCameraPlaneIntersectionPoint(t, e);
    if (i !== null) {
      const n = _.subtract(i, this._previousDragPlanePosition);
      for (const r of this._points)
        r.add(n);
      this._polylineShape.clearPoints(), this._previousDragPlanePosition.assign(i);
    }
    return !0;
  }
  // Serialization methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    const t = [];
    for (const e of this._points)
      t.push(e.toJson());
    return {
      uniqueId: this._uniqueId,
      points: t
    };
  }
  /**
   * Creates a new [[RedlinePolyline]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t, e) {
    const i = t, n = new Rc(e);
    n._uniqueId = i.uniqueId;
    for (const r of i.points)
      n.addPoint(_.fromJson(r));
    return n;
  }
};
Rc.className = "Communicator.Markup.Redline.RedlinePolyline";
let Ta = Rc;
as(Ta.className, Ta.fromJson);
class wd extends Fa {
  constructor() {
    super(...arguments), this._borderRadius = 0;
  }
  /** @hidden */
  _assign(t) {
    super._assign(t), this._borderRadius = t._borderRadius;
  }
  /**
   * Gets the border radius for this shape
   * @returns the border radius
   */
  getBorderRadius() {
    return this._borderRadius;
  }
  /**
   * Sets the border radius for this shape
   * @param borderRadius the border radius in pixels
   */
  setBorderRadius(t) {
    this._borderRadius = t;
  }
}
class vd extends wd {
  /**
   * Creates a new rectangle markup item
   * @param position the screen space position of the top left of the rectangle.
   * @param size the point object representing the width and height of the rectangle in pixels.
   */
  constructor(t, e) {
    super(), this._position = K.zero(), this._size = K.zero(), t && this._position.assign(t), e && this._size.assign(e);
  }
  /** @hidden */
  _assign(t) {
    super._assign(t), this._position.assign(t._position), this._size.assign(t._size);
  }
  /**
   * Sets the rectanlge position
   * @param position the top left corner of the rectangle
   */
  setPosition(t) {
    this._position.assign(t);
  }
  /**
   * Gets rectangle position
   * @returns the rectangle position
   */
  getPosition() {
    return this._position.copy();
  }
  /**
   * Sets the rectanlge size
   * @param size indicating the rectangle width and height
   */
  setSize(t) {
    this._size.assign(t);
  }
  /**
   * Gets rectangle size
   * @returns the rectangle size
   */
  getSize() {
    return this._size.copy();
  }
}
class V_ {
  constructor(t, e) {
    this.position = t.copy(), this.size = e.copy();
  }
}
class Ub extends wd {
  constructor() {
    super(...arguments), this._rectangles = [];
  }
  /**
   * Removes all rectangles from this collection
   */
  clear() {
    this._rectangles = [];
  }
  /**
   * Adds a rectangle to the collection
   * @param position the top left corner of the rectangle
   * @param size indicating the rectangle width and height
   */
  addRectangle(t, e) {
    this._rectangles.push(new V_(t, e));
  }
  /**
   * Gets the rectangles in the collection
   */
  getRectangles() {
    return this._rectangles;
  }
}
const To = class To extends Ll {
  constructor(t) {
    super(t), this._uniqueId = Ss(), this._point1 = _.zero(), this._point2 = _.zero(), this._rectangleShape = new vd(), this._previousDragPlanePosition = _.zero(), this._rectangleShape.setFillOpacity(0), this._rectangleShape.setStrokeColor(vt.red()), this._rectangleShape.setStrokeWidth(2);
  }
  setPoint1(t) {
    this._point1.assign(t);
  }
  getPoint1() {
    return this._point1.copy();
  }
  setPoint2(t) {
    this._point2.assign(t);
  }
  getPoint2() {
    return this._point2.copy();
  }
  getUniqueId() {
    return this._uniqueId;
  }
  _update(t) {
    const e = t.projectPoint(this._point1), i = t.projectPoint(this._point2), n = new K(
      Math.min(e.x, i.x),
      Math.min(e.y, i.y)
    ), r = new K(
      Math.max(e.x, i.x),
      Math.max(e.y, i.y)
    ), o = K.subtract(r, n);
    this._rectangleShape.setPosition(n), this._rectangleShape.setSize(o);
  }
  draw(t, e) {
    this._update(e), t.drawRectangle(this._rectangleShape);
  }
  hit(t, e) {
    return this.hitWithTolerance(t, e, 0);
  }
  hitWithTolerance(t, e, i) {
    this._update(e);
    const n = this._rectangleShape.getStrokeWidth() + i, r = this._rectangleShape.getPosition(), o = this._rectangleShape.getSize(), l = r, h = new K(r.x + o.x, l.y), u = new K(r.x, r.y + o.y), d = new K(r.x + o.x, r.y + o.y);
    return uc(t, l, h, n) || uc(t, h, d, n) || uc(t, d, u, n) ? !0 : !!uc(t, u, l, n);
  }
  onSelect() {
    this._rectangleShape.setStrokeWidth(4);
  }
  onDeselect() {
    this._rectangleShape.setStrokeWidth(2);
  }
  isValid() {
    const t = this._rectangleShape.getSize();
    return t.x > To._validSizeTolerance.x && t.y > To._validSizeTolerance.y;
  }
  // dragging methods
  onDragStart(t, e) {
    const i = e.getCamera().getCameraPlaneIntersectionPoint(t, e);
    return i !== null && this._previousDragPlanePosition.assign(i), !1;
  }
  onDragMove(t, e) {
    const i = e.getCamera().getCameraPlaneIntersectionPoint(t, e);
    if (i !== null) {
      const n = _.subtract(i, this._previousDragPlanePosition);
      this._point1.add(n), this._point2.add(n), this._previousDragPlanePosition.assign(i);
    }
    return !0;
  }
  // serialization methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      uniqueId: this._uniqueId,
      className: this.getClassName(),
      point1: this._point1.toJson(),
      point2: this._point2.toJson()
    };
  }
  /**
   * Creates a new [[RedlineRectangle]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t, e) {
    const i = t, n = new To(e);
    return n._uniqueId = i.uniqueId, n.setPoint1(_.fromJson(i.point1)), n.setPoint2(_.fromJson(i.point2)), n;
  }
  getClassName() {
    return To.className;
  }
};
To.className = "Communicator.Markup.Redline.RedlineRectangle", To._validSizeTolerance = new K(5, 5);
let Na = To;
as(Na.className, Na.fromJson);
const fl = class fl {
  constructor(t, e) {
    this._sizeChanged = !1, this._sizeUpdateCallback = t, this._textUpdateCallback = e, this._createTextBox();
  }
  _createTextBox() {
    this._currentSize = fl._defaultSize.copy(), this._textArea = document.createElement("textarea"), this._textArea.style.position = "absolute", this._textArea.style.width = `${fl._defaultSize.x}px`, this._textArea.style.height = `${fl._defaultSize.y}px`, this._textArea.style.zIndex = "1", this._textArea.style.pointerEvents = "none", this._textArea.style.resize = "none", this._textArea.style.letterSpacing = "1px", this.setBorderWidth(2), this._textArea.onmousemove = (e) => {
      e.stopPropagation();
      const i = new K(
        parseInt(this._textArea.style.width, 10),
        parseInt(this._textArea.style.height, 10)
      );
      this.setSize(i);
    }, this._textArea.onmouseup = (e) => {
      e.stopPropagation(), this._sizeChanged && (this._sizeChanged = !1, this._sizeUpdateCallback(this._currentSize));
    };
    const t = () => {
      this._textUpdateCallback(this._textArea.value);
    };
    this._textArea.oninput = t;
  }
  setPosition(t) {
    this._textArea.style.left = `${t.x}px`, this._textArea.style.top = `${t.y}px`;
  }
  setBorderWidth(t) {
    this._textArea.style.outline = `${t}px solid red`;
  }
  setText(t) {
    this._textArea.textContent = t;
  }
  setSize(t) {
    this._currentSize.equals(t) || (this._sizeChanged = !0, this._currentSize.assign(t), this._textArea.style.width = `${t.x}px`, this._textArea.style.height = `${t.y}px`);
  }
  focus() {
    this._textArea.focus(), this._textArea.style.pointerEvents = "auto", this._textArea.style.resize = "both";
  }
  blur() {
    this._textArea.blur(), this._textArea.style.pointerEvents = "none", this._textArea.style.resize = "none";
  }
  getTextArea() {
    return this._textArea;
  }
};
fl._defaultSize = new K(100, 100);
let td = fl;
const da = class da extends Ll {
  constructor(t, e = da.defaultText) {
    super(t), this._uniqueId = Ss(), this._position = _.zero(), this._size = new K(100, 100), this._redlineTextElements = /* @__PURE__ */ new Map(), this._previousDragPlanePosition = _.zero(), this._callbacks = null, this._text = e;
  }
  setPosition(t) {
    this._position.assign(t);
  }
  getPosition() {
    return this._position.copy();
  }
  setSize(t) {
    this._size.assign(t), this._redlineTextElements.forEach((e) => {
      e.element.setSize(t);
    }), this._viewer.trigger("redlineUpdated", this);
  }
  getSize() {
    return this._size.copy();
  }
  setText(t) {
    this._text = t, this._redlineTextElements.forEach((e) => {
      e.element.setText(t);
    }), this._viewer.trigger("redlineUpdated", this);
  }
  getText() {
    return this._text;
  }
  registerCallback() {
    this._callbacks === null && (this._callbacks = {
      selectionArray: () => {
        this.onDeselect();
      }
    }, this._viewer.setCallbacks(this._callbacks));
  }
  unregisterCallback() {
    this._callbacks !== null && (this._viewer.unsetCallbacks(this._callbacks), this._callbacks = null);
  }
  createTextElement() {
    const t = (n) => {
      this.setSize(n);
    }, e = (n) => {
      this.setText(n);
    }, i = new td(t, e);
    return i.setText(this._text), this.registerCallback(), i;
  }
  draw(t, e) {
    const i = K.fromPoint3(e.projectPoint(this._position));
    let n = this._redlineTextElements.get(e);
    if (!n) {
      const r = this.createTextElement(), o = this._viewer.markupManager.addMarkupElement(r.getTextArea(), e);
      n = { id: o, element: r }, this._redlineTextElements.set(e, { id: o, element: r });
    }
    n.element.setPosition(i);
  }
  hit(t, e) {
    return this.hitWithTolerance(t, e, 0);
  }
  hitWithTolerance(t, e, i) {
    const n = this._redlineTextElements.get(e);
    if (!n)
      return !1;
    const r = n.element.getTextArea(), o = new K(
      parseFloat(r.style.left || "0"),
      parseFloat(r.style.top || "0")
    ), l = new K(
      parseFloat(r.style.width || "0"),
      parseFloat(r.style.height || "0")
    );
    return Mm(t, o, l, i);
  }
  getClassName() {
    return da.className;
  }
  onSelect(t) {
    const e = this._redlineTextElements.get(t);
    e && (e.element.setBorderWidth(4), e.element.focus());
  }
  onDeselect() {
    this._redlineTextElements.forEach((t) => {
      t.element.setBorderWidth(2), t.element.blur();
    });
  }
  isValid() {
    return this._text.length > 0;
  }
  remove(t) {
    const e = [];
    t ? e.push(t) : e.push(...this._redlineTextElements.keys());
    for (let i of e) {
      const n = this._redlineTextElements.get(i);
      n && (this._viewer.markupManager.removeMarkupElement(n.id, i), this._redlineTextElements.delete(i), this._redlineTextElements.size === 0 && this.unregisterCallback());
    }
    super.remove(t);
  }
  // drag methods and drop methods
  onDragStart(t, e) {
    const i = e.getCamera().getCameraPlaneIntersectionPoint(t, e);
    return i !== null && this._previousDragPlanePosition.assign(i), !1;
  }
  onDragMove(t, e) {
    const i = e.getCamera().getCameraPlaneIntersectionPoint(t, e);
    if (i !== null) {
      const n = _.subtract(i, this._previousDragPlanePosition), r = this.getPosition();
      r.add(n), this.setPosition(r), this._previousDragPlanePosition.assign(i);
    }
    return !0;
  }
  // Serialization methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      uniqueId: this._uniqueId,
      className: this.getClassName(),
      position: this._position.toJson(),
      size: this._size.toJson(),
      text: this._text
    };
  }
  /**
   * Creates a new [[RedlineText]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t, e) {
    const i = t, n = new da(e, i.text);
    return n._uniqueId = i.uniqueId, n.setPosition(_.fromJson(i.position)), n.setSize(K.fromJson(i.size)), n;
  }
};
da.className = "Communicator.Markup.Redline.RedlineText", da.defaultText = "Type Here...";
let Wo = da;
as(Wo.className, Wo.fromJson);
const jb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  RedlineCircle: Aa,
  RedlinePolyline: Ta,
  RedlineRectangle: Na,
  RedlineText: Wo,
  RedlineTextElement: td
}, Symbol.toStringTag, { value: "Module" })), Lc = class Lc extends go {
  constructor(t, e = null, i = null, n = null, r = null) {
    super(), this._uniqueId = Ss(), this._lineMeshId = null, this._lineMeshInstanceId = null, this._lineColor = vt.red(), this._lineOpacity = 1, this._linePattern = null, this._linePatternLength = null, this._linePatternLengthUnit = null, this._viewer = t, this._firstPoint = e, this._secondPoint = i, this._firstNodeId = n, this._secondNodeId = r;
  }
  /**
   * Sets the line color.
   * @param color
   */
  setLineColor(t) {
    this._lineColor = t;
  }
  /**
   * Gets the line color.
   */
  getLineColor() {
    return this._lineColor;
  }
  /**
   * Sets the line opacity.
   * @param opacity
   */
  setLineOpacity(t) {
    this._lineOpacity = t;
  }
  /**
   * Gets the line opacity.
   */
  getLineOpacity() {
    return this._lineOpacity;
  }
  /**
   * Sets the line pattern.
   * @param pattern The line pattern.
   * @param patternLength The length of a single repetition of the line pattern.
   * @param patternLengthUnit The unit in which the pattern length is measured.
   */
  setLinePattern(t, e, i) {
    this._linePattern = t, this._linePatternLength = e, this._linePatternLengthUnit = i;
  }
  /**
   * Gets the line pattern.
   */
  getLinePattern() {
    return this._linePattern !== void 0 ? this._linePattern : null;
  }
  /**
   * Gets the length of a single repetition of the line pattern.
   */
  getLinePatternLength() {
    return this._linePatternLength !== void 0 ? this._linePatternLength : null;
  }
  /**
   * Gets the unit in which the line pattern length is measured.
   */
  getLinePatternLengthUnit() {
    return this._linePatternLengthUnit !== void 0 ? this._linePatternLengthUnit : null;
  }
  /**
   * Sets the first point on the line.
   * @param firstPoint
   */
  setFirstPoint(t) {
    this._firstPoint = t;
  }
  /**
   * Gets the first point on the line.
   * @returns the first point, or null if none is set.
   */
  getFirstPoint() {
    return this._firstPoint;
  }
  /**
   * Sets the second point on the line.
   * @param secondPoint
   */
  setSecondPoint(t) {
    this._secondPoint = t;
  }
  /**
   * Gets the second point on the line.
   * @returns the second point, or null if none is set.
   */
  getSecondPoint() {
    return this._secondPoint;
  }
  /**
   * Sets the NodeId of the part associated with the first line point
   * @param nodeId
   */
  setFirstNodeId(t) {
    this._firstNodeId = t;
  }
  /**
   * Gets the NodeId of the part associated with the first line point
   */
  getFirstNodeId() {
    return this._firstNodeId;
  }
  /**
   * Sets the NodeId of the part associated with the second line point
   * @param nodeId
   */
  setSecondNodeId(t) {
    this._secondNodeId = t;
  }
  /**
   * Gets the NodeId of the part associated with the second line point
   */
  getSecondNodeId() {
    return this._secondNodeId;
  }
  /**
   * Gets the node id associated with the line markup.
   */
  getNodeId() {
    return this._lineMeshInstanceId;
  }
  /**
   * Removes the line geometry from the scene.
   */
  async removeLine() {
    const t = this._viewer.model;
    this._lineMeshInstanceId !== null && (await t.deleteMeshInstances([this._lineMeshInstanceId]), this._lineMeshInstanceId = null, this._lineMeshId !== null && (await t.deleteMeshes([this._lineMeshId]), this._lineMeshId = null));
  }
  /**
   * Draws updated line geometry in the scene.
   */
  async updateLine() {
    if (await this.removeLine(), this._firstPoint !== null && this._secondPoint !== null) {
      const t = new Cs();
      t.addPolyline([
        this._firstPoint.x,
        this._firstPoint.y,
        this._firstPoint.z,
        this._secondPoint.x,
        this._secondPoint.y,
        this._secondPoint.z
      ]);
      const e = this._viewer.model, i = await e.createMesh(t);
      this._lineMeshId = i;
      const n = new Qs(i);
      n.setLineColor(this._lineColor), n.setLineOpacity(this._lineOpacity), n.setCreationFlags(ee.ExcludeBounding);
      const r = await e.createMeshInstance(n);
      this._linePattern !== null && e.setNodesLinePattern(
        [r],
        this._linePattern,
        this._linePatternLength,
        this._linePatternLengthUnit
      ), this._lineMeshInstanceId = r;
    }
  }
  /**
   * Returns a unique markup id for this line.
   */
  getId() {
    return this._uniqueId;
  }
  /**
   * Sets a markup id for this line.
   * @param id
   */
  setId(t) {
    this._uniqueId = t;
  }
  /**
   * Returns the class name for this markup item.
   */
  getClassName() {
    return Lc.className;
  }
  _toJson() {
    return {
      className: this.getClassName(),
      uniqueId: this._uniqueId,
      firstPoint: this.getFirstPoint(),
      secondPoint: this.getSecondPoint(),
      firstNodeId: this.getFirstNodeId(),
      secondNodeId: this.getSecondNodeId(),
      lineColor: this.getLineColor(),
      lineOpacity: this.getLineOpacity(),
      linePattern: this.getLinePattern(),
      linePatternLength: this.getLinePatternLength(),
      linePatternLengthUnit: this.getLinePatternLengthUnit()
    };
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  /**
   * Creates a new [[LineMarkup]] from an object given by [[toJson]].
   * @param An object given by [[toJson]].
   * @returns The prepared object.
   */
  static async fromJson(t, e) {
    const i = t, n = new Lc(
      e,
      _.fromJson(i.firstPoint),
      _.fromJson(i.secondPoint),
      i.firstNodeId,
      i.secondNodeId
    );
    return n.setId(i.uniqueId), n.setLineColor(vt.fromJson(i.lineColor)), n.setLineOpacity(i.lineOpacity), i.linePattern != null && i.linePatternLength != null && i.linePatternLengthUnit != null && n.setLinePattern(i.linePattern, i.linePatternLength, i.linePatternLengthUnit), n;
  }
};
Lc.className = "Communicator.Markup.Line.LineMarkup";
let Da = Lc;
as(Da.className, Da.fromJson);
const Wb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  LineMarkup: Da
}, Symbol.toStringTag, { value: "Module" }));
class bl {
  constructor(t, e, i, n, r, o) {
    this._version = Xs.Unknown, this._components = {}, this._lines = [], this._clippingPlanes = [], this._viewer = o, this._filename = t, this._version = i, this._modelBounding = n, this._unitScale = 1e3 / r, this._parseDocument(e);
  }
  static async createViewpoint(t, e, i = null) {
    const n = (j) => {
      const V = [];
      return j.forEach((Y) => {
        let q = null;
        for (; Y !== null && q === null; )
          q = r.getNodeGenericId(Y), Y = r.getNodeParent(Y);
        V.push(q);
      }), console.assert(j.length === V.length), V;
    }, r = t.model, o = r.getAbsoluteRootNode(), l = await r.getVisibilityState(o), h = await r.getNodeColorMap(o, an.Faces), u = await r.getModelBounding(!0, !1), d = r.getNodeUnitMultiplier(o), g = new bl(
      e,
      null,
      Xs.v2_1,
      u,
      d,
      t
    ), y = l.defaultVisibility;
    g.setDefaultVisibility(y);
    const m = l.visibilityExceptions, x = [];
    m.forEach((j) => {
      x.push(j);
    });
    const b = [], I = n(x);
    for (let j = 0; j < I.length; j++) {
      const V = I[j];
      let Y;
      V !== null ? Y = r.getNodeIdsByGenericIds([V]) : Y = [x[j]];
      for (const q of Y) {
        const st = await r.getVisibilityState(q), dt = { genericId: V, nodeId: q };
        y ? st.visibilityExceptions.size === 0 && b.push(dt) : (st.visibilityExceptions.size !== 0 || st.defaultVisibility) && b.push(dt);
      }
    }
    g.setVisibilityExceptionNodes(b);
    const P = t.selectionManager.getResults().map((j) => j.getNodeId()), k = n(P), O = [];
    for (let j = 0; j < P.length; j++) {
      const V = {
        genericId: k[j],
        nodeId: P[j]
      };
      O.push(V);
    }
    g.setSelectionNodes(O);
    const B = /* @__PURE__ */ new Map();
    if (h.size > 0 && h.forEach((j, V) => {
      const Y = r.getNodeParent(V);
      if (Y === null)
        return;
      const q = r.getNodeGenericId(Y);
      let st = B.get(j);
      st === void 0 && (st = /* @__PURE__ */ new Set(), B.set(j, st)), st.add({ genericId: q, nodeId: V });
    }), g.setColorNodes(B), g.setCamera(t.view.getCamera()), i !== null) {
      const j = bl._markupRedlineToBcf(i.getMarkup(), t.view);
      g.setLines(j);
    }
    return g;
  }
  static _markupRedlineToBcf(t, e) {
    const r = (d) => {
      const g = e.projectPoint(d);
      return e.unprojectPoint(K.fromPoint3(g), 0);
    }, o = (d, g, y) => {
      const m = Math.PI * 2 / y, x = [];
      for (let b = 0; b <= y; b++) {
        const I = b * m;
        x.push(
          new K(d.x + Math.cos(I) * g, d.y + Math.sin(I) * g)
        );
      }
      return x;
    }, l = (d) => {
      for (let g = 0; g < d.length - 1; ++g) {
        const y = d[g], m = d[g + 1];
        if (y !== null && m !== null) {
          const x = [y.copy().scale(1e-3), m.copy().scale(1e-3)];
          u.push(x);
        }
      }
    }, h = (d) => {
      for (let g = 0; g < d.length; ++g) {
        const y = d[g], m = d[(g + 1) % d.length];
        if (y !== null && m !== null) {
          const x = [y.copy().scale(1e-3), m.copy().scale(1e-3)];
          u.push(x);
        }
      }
    }, u = [];
    return t.forEach((d) => {
      if (d instanceof Ta) {
        const y = d.getPoints().map(r);
        l(y);
      } else if (d instanceof Aa) {
        const g = d.getCenter(), y = d.getRadiusPoint(), m = K.fromPoint3(e.projectPoint(g)), x = K.fromPoint3(e.projectPoint(y)), b = K.subtract(x, m).length(), C = o(m, b, 40).map((P) => e.unprojectPoint(P, 0));
        h(C);
      } else if (d instanceof Na) {
        const g = d.getPoint1(), y = d.getPoint2(), m = K.fromPoint3(e.projectPoint(g)), x = K.fromPoint3(e.projectPoint(y)), b = [];
        b.push(e.unprojectPoint(m, 0)), b.push(
          e.unprojectPoint(new K(m.x, x.y), 0)
        ), b.push(e.unprojectPoint(x, 0)), b.push(
          e.unprojectPoint(new K(x.x, m.y), 0)
        ), h(b);
      }
    }), u;
  }
  _parseDocument(t) {
    if (t === null)
      return;
    const e = t.documentElement, i = e.attributes.getNamedItem("Guid");
    i !== null && (this._viewpointGuid = i.value);
    let n = e.firstElementChild;
    for (; n !== null; ) {
      const r = n.localName;
      if (r === null)
        break;
      switch (r) {
        case "Components":
          this._version >= Xs.v2_1 ? this._parseComponents(n) : this._parseComponentsV2_0(n);
          break;
        case "OrthogonalCamera":
          this._parseOrthogonalCamera(n);
          break;
        case "PerspectiveCamera":
          this._parsePerspectiveCamera(n);
          break;
        case "Lines":
          this._parseLines(n);
          break;
        case "ClippingPlanes":
          this._parseClippingPlanes(n);
          break;
      }
      n = n.nextElementSibling;
    }
  }
  _exportComponents(t) {
    const e = t.createElement("Components"), i = t.createElement("ViewSetupHints"), n = this._components.viewSetupHints;
    n && (e.setAttribute("SpacesVisible", vc(n.spacesVisible)), e.setAttribute(
      "SpaceBoundariesVisible",
      vc(n.spaceBoundariesVisible)
    ), e.setAttribute("OpeningsVisible", vc(n.openingsVisible))), e.appendChild(i);
    const r = t.createElement("Selection"), o = this._components.selection;
    o && o.forEach((y) => {
      r.appendChild(Tu(t, y));
    }), e.appendChild(r);
    const l = t.createElement("Visibility"), h = this._components.defaultVisibility, u = this._components.visibilityExceptions;
    if (h !== void 0 && u !== void 0) {
      l.setAttribute("DefaultVisibility", vc(h));
      const y = t.createElement("Exceptions");
      u.forEach((m) => {
        y.appendChild(Tu(t, m));
      }), l.appendChild(y);
    }
    e.appendChild(l);
    const d = t.createElement("Coloring"), g = this._components.coloring;
    return g && g.forEach((y) => {
      const m = t.createElement("Color");
      m.setAttribute("Color", N_(y.color, y.alpha)), y.components.forEach((x) => {
        m.appendChild(Tu(t, x));
      }), d.appendChild(m);
    }), e.appendChild(d), e;
  }
  _exportOrthogonalCamera(t, e) {
    const i = t.createElement("OrthogonalCamera"), n = t.createElement("CameraViewPoint"), r = t.createElement("CameraDirection"), o = t.createElement("CameraUpVector");
    cr(t, n, e.cameraViewPoint), cr(t, r, e.cameraDirection), cr(t, o, e.cameraUpVector);
    const l = t.createElement("ViewToWorldScale");
    return l.innerHTML = e.viewToWorldScale.toString(), i.appendChild(n), i.appendChild(r), i.appendChild(o), i.appendChild(l), i;
  }
  _exportPerspectiveCamera(t, e) {
    const i = t.createElement("PerspectiveCamera"), n = t.createElement("CameraViewPoint"), r = t.createElement("CameraDirection"), o = t.createElement("CameraUpVector");
    cr(t, n, e.cameraViewPoint), cr(t, r, e.cameraDirection), cr(t, o, e.cameraUpVector);
    const l = t.createElement("FieldOfView");
    return l.innerHTML = e.fieldOfView.toString(), i.appendChild(n), i.appendChild(r), i.appendChild(o), i.appendChild(l), i;
  }
  _exportLines(t) {
    const e = t.createElement("Lines");
    return this._lines.forEach((i) => {
      const n = t.createElement("Line"), r = t.createElement("StartPoint"), o = t.createElement("EndPoint");
      cr(t, r, i.startPoint), cr(t, o, i.endPoint), n.appendChild(r), n.appendChild(o), e.appendChild(n);
    }), e;
  }
  _exportClippingPlanes(t) {
    const e = t.createElement("ClippingPlanes");
    return this._clippingPlanes.forEach((i) => {
      const n = t.createElement("ClippingPlane"), r = t.createElement("Location"), o = t.createElement("Direction");
      cr(t, r, i.location), cr(t, o, i.direction), n.appendChild(r), n.appendChild(o), e.appendChild(n);
    }), e;
  }
  /**
   * @returns XML document containing the viewpoint data.
   */
  export() {
    const t = document.implementation.createDocument("", "", null), e = t.createElement("VisualizationInfo");
    return e.appendChild(this._exportComponents(t)), this._viewpointGuid !== void 0 && e.setAttribute("Guid", this._viewpointGuid), this._orthogonalCamera ? e.appendChild(this._exportOrthogonalCamera(t, this._orthogonalCamera)) : this._perspectiveCamera && e.appendChild(this._exportPerspectiveCamera(t, this._perspectiveCamera)), this._lines.length > 0 && e.appendChild(this._exportLines(t)), this._clippingPlanes.length > 0 && e.appendChild(this._exportClippingPlanes(t)), t.appendChild(e), t;
  }
  /**
   * Activates viewpoint.
   * Sets the camera, visibility, cutting planes, colors, and markup.
   */
  async activate() {
    await this._activateCamera(), await this._activateComponentsVisibility(), await this._activateMarkup(), await this._activateCuttingPlanes(), this._activateSelected(), await this._activateColors();
  }
  async _activateCamera() {
    const t = this.getCamera();
    t !== null && await this._viewer.view._setCameraPromise(t, 800);
  }
  async _activateComponentsVisibility() {
    const t = this._viewer.model, e = this._getDefaultVisibility(), i = this.getVisibilityExceptionNodes();
    i.length ? (await t.setNodesVisibility([-2], e), await t.setNodesVisibility(i, !e)) : await t.reset();
  }
  async _activateMarkup() {
    const t = this._viewer.lineManager;
    await t.removeAllLines();
    const e = [];
    for (let i = 0; i < this._lines.length; ++i) {
      const n = this._lines[i], r = new Da(
        this._viewer,
        n.startPoint.copy().scale(1e3),
        n.endPoint.copy().scale(1e3)
      );
      e.push(t.addLine(r));
    }
    await Promise.all(e);
  }
  async _activateCuttingPlanes() {
    const e = await this._viewer.model.getModelBounding(!0, !1), i = this._viewer.cuttingManager;
    await i.clearAllCuttingSections();
    for (let n = 0; n < this._clippingPlanes.length; ++n) {
      const r = i.getCuttingSection(n);
      await r.clear();
      const o = this._clippingPlanes[n], l = o.location.copy().scale(1e3), h = o.direction.normalize(), u = ln.createFromPointAndNormal(l, h), d = i.createReferenceGeometryFromFaceNormal(
        h,
        l,
        e
      );
      await r.addPlane(u, d);
    }
    await i.activateCuttingSections();
  }
  _activateSelected() {
    const t = this._getNodeIdsFromComponents(this._components.selection);
    this._viewer.selectionManager.clear(), t.forEach((e) => {
      this._viewer.selectionManager.selectNode(e, xn.Add);
    });
  }
  async _activateColors() {
    const t = this._viewer.model, e = t.getAbsoluteRootNode();
    if (t.unsetNodesFaceColor([e]), t.unsetNodesLineColor([e]), this._components.coloring !== void 0) {
      const i = /* @__PURE__ */ new Map();
      for (let n = 0; n < this._components.coloring.length; ++n) {
        const r = this._components.coloring[n];
        this._getNodeIdsFromComponents(r.components).forEach((l) => {
          i.set(l, r.color);
        });
      }
      await this._viewer.model.setNodesColors(i);
    }
  }
  /**
   * Gets the viewpoint filename.
   */
  getFilename() {
    return this._filename;
  }
  /**
   * Gets the GUID associated with the viewpoint.
   */
  getViewpointGuid() {
    return this._viewpointGuid || null;
  }
  _fromBCFPerspectiveCamera(t, e) {
    const i = new Cn();
    i.setProjection(ri.Perspective);
    const n = t.cameraViewPoint.copy().scale(this._unitScale), r = t.cameraDirection.copy().normalize().scale(e), o = _.add(n, r), l = t.cameraUpVector.copy().normalize();
    i.setPosition(n), i.setTarget(o), i.setUp(l);
    const h = Fo(t.fieldOfView), u = Math.tan(h / 2), g = 2 * _.subtract(i.getTarget(), i.getPosition()).length() * u;
    return i.setWidth(g), i.setHeight(g), i;
  }
  _fromBCFOrthogonalCamera(t, e) {
    const i = new Cn();
    i.setProjection(ri.Orthographic);
    const n = t.cameraViewPoint.copy().scale(this._unitScale), r = t.cameraDirection.copy().normalize().scale(e), o = _.add(n, r), l = t.cameraUpVector.copy().normalize();
    i.setPosition(n), i.setTarget(o), i.setUp(l);
    const h = t.viewToWorldScale * this._unitScale * 2;
    return i.setWidth(h), i.setHeight(h), i;
  }
  /**
   * Gets the viewpoint camera, or null if none is set.
   */
  getCamera() {
    const t = this._modelBounding.extents().length();
    return this._perspectiveCamera ? this._fromBCFPerspectiveCamera(this._perspectiveCamera, t / 40) : this._orthogonalCamera ? this._fromBCFOrthogonalCamera(this._orthogonalCamera, t) : null;
  }
  /**
   * Sets the viewpoint camera.
   * @param camera
   */
  setCamera(t) {
    t.getProjection() === ri.Perspective ? (this._perspectiveCamera = this._toBCFPerspectiveCamera(t), this._orthogonalCamera = void 0) : (this._orthogonalCamera = this._toBCFOrthogonalCamera(t), this._perspectiveCamera = void 0);
  }
  _toBCFOrthogonalCamera(t) {
    const e = t.getPosition(), i = t.getTarget(), n = _.subtract(i, e).normalize(), r = t.getUp().normalize(), o = e.copy().scale(1 / this._unitScale), h = t.getWidth() / (this._unitScale * 2);
    return {
      cameraDirection: n,
      cameraUpVector: r,
      cameraViewPoint: o,
      viewToWorldScale: h
    };
  }
  _toBCFPerspectiveCamera(t) {
    const e = t.getPosition(), i = t.getTarget(), n = _.subtract(i, e).normalize(), r = t.getUp().normalize(), o = e.copy().scale(1 / this._unitScale), l = t.getWidth(), h = _.subtract(t.getTarget(), t.getPosition()).length(), u = l / (2 * h), d = Math.atan(u) * 2, g = rg(d);
    return {
      cameraDirection: n,
      cameraUpVector: r,
      cameraViewPoint: o,
      fieldOfView: g
    };
  }
  /**
   * Sets the default visibility.
   * If true, visibility exceptions are hidden.
   * If false, visibility exceptions are shown.
   * @param defaultVisibility
   */
  setDefaultVisibility(t) {
    this._components.defaultVisibility = t;
  }
  _getDefaultVisibility() {
    return this._components.defaultVisibility !== void 0 ? this._components.defaultVisibility : !0;
  }
  /**
   * Sets the visibility exceptions. These nodes will be shown or hidden based on the default visibility setting.
   * @param visibilityExceptions Array of GenericIds corresponding to components.
   */
  setVisibilityExceptions(t) {
    const e = t.map(
      (i) => {
        const n = this._viewer.model.getNodeIdsByGenericIds([i]), r = n.length !== 0 ? n[0] : void 0;
        return {
          ifcGuid: i,
          authoringToolId: r,
          originatingSystem: Nr
        };
      }
    );
    this._components.visibilityExceptions = e;
  }
  /**
   * Sets the visibility exceptions. These nodes will be shown or hidden based on the default visibility setting.
   * @param visibilityExceptions Array of BcfNodes corresponding to components.
   */
  setVisibilityExceptionNodes(t) {
    const e = t.map(
      (i) => ({
        ifcGuid: i.genericId !== null ? i.genericId : void 0,
        authoringToolId: i.nodeId,
        originatingSystem: Nr
      })
    );
    this._components.visibilityExceptions = e;
  }
  /**
   * Gets the visibility exception generic ids.
   * @returns Array of GenericIds corresponding to components.
   */
  getVisibilityExceptions() {
    return this._getGenericIdsFromComponents(this._components.visibilityExceptions);
  }
  /**
   * Gets the visibility exception node ids.
   * @returns Array of NodeIds corresponding to components.
   */
  getVisibilityExceptionNodes() {
    return this._getNodeIdsFromComponents(this._components.visibilityExceptions);
  }
  /**
   * Sets the colors.
   * @param colorGenericIdMap Map correlating color to GenericIds.
   */
  setColors(t) {
    const e = [];
    t.forEach((i, n) => {
      const r = [];
      i.forEach((l) => {
        const h = this._viewer.model.getNodeIdsByGenericIds([l]), u = h.length !== 0 ? h[0] : void 0;
        r.push({
          ifcGuid: l,
          authoringToolId: u,
          originatingSystem: Nr
        });
      });
      const o = {
        color: n,
        components: r
      };
      e.push(o);
    }), this._components.coloring = e;
  }
  /**
   * Sets the colors.
   * @param colorNodeMap Map correlating color to BfcNodes.
   */
  setColorNodes(t) {
    const e = [];
    t.forEach((i, n) => {
      const r = [];
      i.forEach((l) => {
        const h = l.genericId !== null ? l.genericId : void 0;
        r.push({
          ifcGuid: h,
          authoringToolId: l.nodeId,
          originatingSystem: Nr
        });
      });
      const o = {
        color: n,
        components: r
      };
      e.push(o);
    }), this._components.coloring = e;
  }
  /**
   * @returns Map correlating color to components.
   */
  getColors() {
    const t = /* @__PURE__ */ new Map(), e = this._components.coloring;
    return e !== void 0 && e.forEach((i) => {
      const n = i.color.copy(), r = /* @__PURE__ */ new Set();
      i.components.map((o) => {
        o.ifcGuid !== void 0 && r.add(o.ifcGuid);
      }), t.set(n, r);
    }), t;
  }
  /**
   * @returns Map correlating color to nodes.
   */
  getColorsToNodes() {
    const t = /* @__PURE__ */ new Map(), e = this._components.coloring;
    return e !== void 0 && e.forEach((i) => {
      const n = i.color.copy(), r = /* @__PURE__ */ new Set();
      i.components.map((o) => {
        o.authoringToolId !== void 0 && o.originatingSystem === Nr && r.add(o.authoringToolId);
      }), t.set(n, r);
    }), t;
  }
  /**
   * Sets the markup lines.
   * @param lines array of start point and end point line pairs.
   */
  setLines(t) {
    this._lines = [], t.forEach((e) => {
      const i = {
        startPoint: e[0].copy(),
        endPoint: e[1].copy()
      };
      this._lines.push(i);
    });
  }
  /**
   * Gets markup lines.
   * @returns Array containing start point and end point line pairs.
   */
  getLines() {
    const t = [];
    return this._lines.forEach((e) => {
      t.push([e.startPoint.copy(), e.endPoint.copy()]);
    }), t;
  }
  /**
   * Sets the clipping planes.
   * @param planes array containing position and direction pairs.
   */
  setClippingPlanes(t) {
    this._clippingPlanes = [], t.forEach((e) => {
      const i = {
        location: e[0].copy(),
        direction: e[1].copy()
      };
      this._clippingPlanes.push(i);
    });
  }
  /**
   * Gets the clipping planes.
   * @returns Array containing position and direction pairs.
   */
  getClippingPlanes() {
    const t = [];
    return this._clippingPlanes.forEach((e) => {
      t.push([e.location.copy(), e.direction.copy()]);
    }), t;
  }
  /**
   * Sets a list of items to be added to the selection set.
   */
  setSelection(t) {
    const e = t.map((i) => {
      const n = this._viewer.model.getNodeIdsByGenericIds([i]), r = n.length !== 0 ? n[0] : void 0;
      return {
        ifcGuid: i,
        authoringToolId: r,
        originatingSystem: Nr
      };
    });
    this._components.selection = e;
  }
  /**
   * Sets a list of items to be added to the selection set.
   */
  setSelectionNodes(t) {
    const e = t.map((i) => ({
      ifcGuid: i.genericId !== null ? i.genericId : void 0,
      authoringToolId: i.nodeId,
      originatingSystem: Nr
    }));
    this._components.selection = e;
  }
  /**
   * Gets a list of generic IDs that are in the selection set.
   */
  getSelection() {
    const t = [], e = this._components.selection;
    return e !== void 0 && e.forEach((i) => {
      i.ifcGuid && t.push(i.ifcGuid);
    }), t;
  }
  /**
   * Gets a list of node IDs that are in the selection set.
   */
  getSelectionNodes() {
    const t = [], e = this._components.selection;
    return e !== void 0 && e.forEach((i) => {
      i.authoringToolId !== void 0 && i.originatingSystem === Nr && t.push(i.authoringToolId);
    }), t;
  }
  _getGenericIdsFromComponents(t) {
    if (!t)
      return [];
    const e = [];
    for (let i = 0; i < t.length; ++i) {
      const n = t[i];
      n.ifcGuid !== void 0 && e.push(n.ifcGuid);
    }
    return e;
  }
  _getNodeIdsFromComponents(t) {
    if (!t)
      return [];
    const e = /* @__PURE__ */ new Set(), i = [];
    for (let r = 0; r < t.length; ++r) {
      const o = t[r];
      o.authoringToolId !== void 0 && o.originatingSystem === Nr ? e.add(o.authoringToolId) : o.ifcGuid !== void 0 && i.push(o.ifcGuid);
    }
    const n = this._viewer.model.getNodeIdsByGenericIds(i);
    for (const r of n)
      e.add(r);
    return Array.from(e);
  }
  _parseComponentsV2_0(t) {
    console.assert(this._version <= Xs.v2_0);
    const e = [], i = [], n = [];
    let r = !0, o = t.firstElementChild;
    for (; o !== null; ) {
      const l = o.localName;
      if (l === null)
        break;
      switch (l) {
        case "Component":
          {
            const h = o.attributes, u = h.getNamedItem("IfcGuid"), d = h.getNamedItem("Selected"), g = h.getNamedItem("Visible"), y = h.getNamedItem("Color");
            if (u !== null && u.value) {
              const x = {
                ifcGuid: u.value
              };
              if (d !== null && d.value === "true" && e.push(x), r = !1, g !== null && g.value === "false" || i.push(x), y !== null && y.value) {
                const b = y.value;
                n.push(this._colorFromArgb(b, [x]));
              }
            }
          }
          break;
      }
      o = o.nextElementSibling;
    }
    this._components = {
      defaultVisibility: r,
      selection: e,
      visibilityExceptions: i,
      coloring: n
    };
  }
  _parseComponents(t) {
    console.assert(this._version >= Xs.v2_1);
    let e = t.firstElementChild;
    const i = {
      spacesVisible: !1,
      spaceBoundariesVisible: !1,
      openingsVisible: !1
    };
    let n = [], r = !0, o = [], l = [];
    for (; e !== null; ) {
      const h = e.localName;
      if (h === null)
        break;
      const u = e.attributes;
      switch (h) {
        case "ViewSetupHints":
          {
            const d = u.getNamedItem("SpacesVisible"), g = u.getNamedItem("SpaceBoundariesVisible"), y = u.getNamedItem("OpeningsVisible");
            d !== null && (i.spacesVisible = d.value === "true"), g !== null && (i.spaceBoundariesVisible = g.value === "true"), y !== null && (i.openingsVisible = y.value === "true");
          }
          break;
        case "Selection":
          n = this._getComponents(e);
          break;
        case "Visibility":
          {
            const d = u.getNamedItem("DefaultVisibility");
            d && (r = d.value === "true");
            const g = e.firstElementChild;
            g !== null && (o = this._getComponents(g));
          }
          break;
        case "Coloring":
          l = this._getColoring(e);
          break;
      }
      e = e.nextElementSibling;
    }
    this._components = {
      viewSetupHints: i,
      selection: n,
      defaultVisibility: r,
      visibilityExceptions: o,
      coloring: l
    };
  }
  _getCameraData(t) {
    const e = [];
    let i = t.firstElementChild;
    for (; i !== null; )
      switch (i.nodeName) {
        case "FieldOfView":
        case "ViewToWorldScale":
          {
            const n = i.textContent;
            n !== null && e.push(parseFloat(n)), i = null;
          }
          break;
        default:
          e.push(this._getPoint(i)), i = i.nextElementSibling;
      }
    return e;
  }
  _parseOrthogonalCamera(t) {
    const e = this._getCameraData(t);
    e.length === 4 && (this._orthogonalCamera = {
      cameraViewPoint: e[0],
      cameraDirection: e[1],
      cameraUpVector: e[2],
      viewToWorldScale: e[3]
    });
  }
  _parsePerspectiveCamera(t) {
    const e = this._getCameraData(t);
    e.length === 4 && (this._perspectiveCamera = {
      cameraViewPoint: e[0],
      cameraDirection: e[1],
      cameraUpVector: e[2],
      fieldOfView: e[3]
    });
  }
  _parseLines(t) {
    let e = t.firstElementChild;
    for (; e !== null; )
      this._lines.push(this._getLine(e)), e = e.nextElementSibling;
  }
  _parseClippingPlanes(t) {
    let e = t.firstElementChild;
    for (; e !== null; )
      this._clippingPlanes.push(this._getClippingPlane(e)), e = e.nextElementSibling;
  }
  _getClippingPlane(t) {
    let e = t.firstElementChild, i = _.zero(), n = _.zero();
    return e !== null && (i = this._getPoint(e), e = e.nextElementSibling, e !== null && (n = this._getPoint(e))), {
      location: i,
      direction: n
    };
  }
  _getLine(t) {
    let e = t.firstElementChild, i = _.zero(), n = _.zero();
    return e !== null && (i = this._getPoint(e), e = e.nextElementSibling, e !== null && (n = this._getPoint(e))), {
      startPoint: i,
      endPoint: n
    };
  }
  _getPoint(t) {
    const e = [];
    let i = t.firstElementChild;
    for (; i !== null; ) {
      const n = i.firstChild;
      n !== null && e.push(parseFloat(n.wholeText)), i = i.nextElementSibling;
    }
    return console.assert(e.length === 3), new _(e[0], e[1], e[2]);
  }
  _colorFromArgb(t, e) {
    const i = {
      color: vt.black(),
      components: e
    }, n = [];
    for (let r = 0; r < t.length; r += 2) {
      const o = t.substr(r, 2);
      n.push(parseInt(o, 16));
    }
    return n.length === 3 ? i.color.set(n[0], n[1], n[2]) : n.length === 4 && (i.alpha = n[0], i.color.set(n[1], n[2], n[3])), i;
  }
  _getColoring(t) {
    const e = [];
    let i = t.firstElementChild;
    for (; i !== null; ) {
      const r = i.attributes.getNamedItem("Color"), o = this._getComponents(i);
      r && o.length && e.push(this._colorFromArgb(r.value, o)), i = i.nextElementSibling;
    }
    return e;
  }
  _getComponents(t) {
    const e = [];
    let i = t.firstElementChild;
    for (; i !== null; ) {
      const n = i.attributes, r = n.getNamedItem("IfcGuid"), o = n.getNamedItem("OriginatingSystem"), l = n.getNamedItem("AuthoringToolId");
      if (r !== null) {
        const h = {
          ifcGuid: r.value
        };
        o !== null && (h.originatingSystem = o.value), l !== null && (h.authoringToolId = parseInt(l.value, 10)), e.push(h);
      }
      i = i.nextElementSibling;
    }
    return e;
  }
}
class bd {
  constructor(t, e, i, n) {
    this._viewpointMap = /* @__PURE__ */ new Map(), this._snapshotMap = /* @__PURE__ */ new Map(), this._viewer = n, this._topicId = i, this._bcfDataId = t, this._bcfFilename = e;
  }
  /**
   * Takes a MarkupView and creates a BCF Topic from it.
   * @param bcfDataId
   * @param bcfFilename
   * @param viewer
   * @param markupView
   * @param topicTitle
   */
  static async createTopic(t, e, i, n, r = null) {
    const o = Ss(), l = new bd(e, i, o, t), u = l.addMarkup("markup.bcf", null);
    u.setTopicTitle(n), u.setTopicId(o);
    const d = "viewpoint.bcfv", g = await bl.createViewpoint(t, d, r);
    l.setViewpoint(d, g);
    const y = "snapshot.png", m = (r !== null ? r.getSnapshotImage() : null) || await t.takeSnapshot(), x = xa.createFromImage(y, m);
    return l.setSnapshot(y, x), l;
  }
  /**
   * Gets the topic id corresponding to the BCF topic folder.
   */
  getTopicId() {
    return this._topicId;
  }
  /**
   * Adds a BCF markup.
   * @param markup BCF markup data.
   */
  addMarkup(t, e) {
    return this._markup = new F_(t, e, this), this._markup;
  }
  /**
   * @returns BCF markup data.
   */
  getMarkup() {
    return this._markup;
  }
  /**
   * Creates and adds BCF viewpoint.
   * @param fileName viewpoint filename.
   * @param viewpoint BCF viewpoint data.
   */
  addViewpoint(t, e, i, n, r) {
    const o = new bl(
      t,
      e,
      i,
      n,
      r,
      this._viewer
    );
    return this.setViewpoint(t, o), o;
  }
  /**
   * Adds a BCF Viewpoint. If there is a already a viewpoint with the same filename, it will be replaced.
   * @param filename
   * @param viewpoint
   */
  setViewpoint(t, e) {
    this._viewpointMap.set(t, e);
  }
  /**
   * @returns A map associating viewpoint filenames with viewpoint data.
   */
  getViewpointMap() {
    return this._viewpointMap;
  }
  /**
   * Gets viewpoint data.
   * @param filename viewpoint filename.
   */
  getViewpoint(t) {
    return this._viewpointMap.get(t) || null;
  }
  /**
   * Creates and adds a Snapshot.
   * @param fileName Snapshot filename.
   * @param png Image data.
   */
  addSnapshot(t, e) {
    const i = new xa(t, e);
    this.setSnapshot(t, i);
  }
  /**
   * Adds a BCF Snapshot. If there is already a snapshot with the smae filename, it will be replaced.
   * @param filename
   * @param snapshot
   */
  setSnapshot(t, e) {
    this._snapshotMap.set(t, e);
  }
  /**
   * @returns A map associating snapshot filenames with snapshot data.
   */
  getSnapshotMap() {
    return this._snapshotMap;
  }
  /**
   * Gets snapshot data.
   * @param filename snapshot or corresponding viewpoint filename
   */
  getSnapshot(t) {
    return this._snapshotMap.get(this._massageSnapshotFilename(t)) || null;
  }
  _massageSnapshotFilename(t) {
    if (t === "viewpoint.bcfv")
      return "snapshot.png";
    const e = t.split(".");
    return e[1] === "bcfv" ? `${e[0]}.png` : t;
  }
}
const YC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  BCFComment: Vf,
  BCFData: Du,
  BCFFileType: Xn,
  BCFMarkup: F_,
  BCFMarkupHeaderFile: R_,
  BCFMarkupViewpoint: L_,
  BCFSnapshot: xa,
  BCFTopic: bd,
  BCFVersion: Xs,
  BCFViewpoint: bl,
  addElem: Rr,
  appendPoint3: cr,
  argbStringFromColor: N_,
  boolToString: vc,
  conditionalAddElem: on,
  conditionalBoolToString: Nu,
  conditionalDateToString: bc,
  conditionalNumberToString: Bf,
  conditionalSetAttribute: Dr,
  defaultOriginatingSystem: Nr,
  exportComponent: Tu
}, Symbol.toStringTag, { value: "Module" }));
var ed = /* @__PURE__ */ ((s) => (s[s.avatarOffset = 1500] = "avatarOffset", s[s.maxClimbHeight = 600] = "maxClimbHeight", s[s.negligibleClimbHeight = 20] = "negligibleClimbHeight", s[s.maxFallDistance = 5e3] = "maxFallDistance", s))(ed || {}), id = /* @__PURE__ */ ((s) => (s[s.avatarOffset = 150] = "avatarOffset", s))(id || {}), nd = /* @__PURE__ */ ((s) => (s[s.transparencyRange = 4e3] = "transparencyRange", s))(nd || {});
const ZC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  DefaultDoorConfig: nd,
  DefaultFloorConfig: ed,
  DefaultWallConfig: id
}, Symbol.toStringTag, { value: "Module" }));
var Go = /* @__PURE__ */ ((s) => (s[s.Never = 0] = "Never", s[s.Bim = 1] = "Bim", s[s.BimWalk = 2] = "BimWalk", s))(Go || {}), bn = /* @__PURE__ */ ((s) => (s.Inactive = "inactive", s.Activating = "activating", s.Active = "active", s))(bn || {});
function zf(s) {
  if (s.length === 0)
    return new mt();
  if (s.length === 1)
    return s[0];
  let t = mt.multiply(s[1], s[0]);
  for (let e = 2; e < s.length; ++e)
    t = mt.multiply(s[e], t);
  return t;
}
function il(s, t, e) {
  return Math.max(t, Math.min(e, s));
}
function z_(s, t) {
  return s.x >= t.min.x && s.x <= t.max.x && s.y >= t.min.y && s.y <= t.max.y && s.z >= t.min.z && s.z <= t.max.z;
}
function Hf(s, t) {
  return s.z >= t.min.z && s.z <= t.max.z;
}
class H_ {
  constructor(t, e, i, n, r) {
    this.floorplanNode = null, this.floorNode = t, this.bounds = e, this.slabNodes = i, this.spaceNodes = n, this.floorplanMeshCreationNodes = r;
  }
}
class Oh {
  constructor() {
    this.overlayAnchor = qe.LowerRightCorner, this.overlaySize = new K(0.25, 1), this.overlayWidthUnit = Fe.ProportionOfCanvas, this.overlayHeightUnit = Fe.ProportionOfOtherDimension, this.overlayOffset = new K(0, 0), this.overlayOffsetXUnit = Fe.Pixels, this.overlayOffsetYUnit = Fe.Pixels, this.backgroundColor = vt.white(), this.backgroundOpacity = 0.25, this.borderColor = vt.black(), this.borderOpacity = 1, this.avatarColor = vt.createFromFloat(1, 0, 1), this.avatarOutlineColor = vt.black(), this.avatarOpacity = 1, this.avatarScale = 1, this.fixedAvatarScale = !0, this.overlayFeetPerPixel = 0.1, this.zoomLevel = 1, this.autoActivate = Go.BimWalk, this.floorplanOrientation = hl.NorthUp, this.customAvatar = null, this.trackCameraEnabled = !1;
  }
  /**
   * Per-floor information.
   * @returns Copy of this configuration object.
   */
  copy() {
    const t = new Oh();
    return t.overlayAnchor = this.overlayAnchor, t.overlaySize = this.overlaySize.copy(), t.overlayWidthUnit = this.overlayWidthUnit, t.overlayHeightUnit = this.overlayHeightUnit, t.overlayOffset = this.overlayOffset.copy(), t.overlayOffsetXUnit = this.overlayOffsetXUnit, t.overlayOffsetYUnit = this.overlayOffsetYUnit, t.backgroundColor = this.backgroundColor.copy(), t.backgroundOpacity = this.backgroundOpacity, t.borderColor = this.borderColor.copy(), t.borderOpacity = this.borderOpacity, t.avatarColor = this.avatarColor.copy(), t.avatarOutlineColor = this.avatarOutlineColor.copy(), t.avatarOpacity = this.avatarOpacity, t.avatarScale = this.avatarScale, t.fixedAvatarScale = this.fixedAvatarScale, t.customAvatar = this.customAvatar, t.overlayFeetPerPixel = this.overlayFeetPerPixel, t.zoomLevel = this.zoomLevel, t.trackCameraEnabled = this.trackCameraEnabled, t.autoActivate = this.autoActivate, t.floorplanOrientation = this.floorplanOrientation, t;
  }
}
class Si {
  constructor(t = Se.Face) {
    this.respectVisibility = !0, this.forceEffectiveVisibilityMask = Se.None, this.forceEffectiveSceneVisibilityMask = Se.None, this.respectDepthRange = !0, this.oneEntityPerTypePerInstance = !0, this.restrictLinesAndPointsToSelectedFaceInstances = !0, this.enableProximityFaces = !1, this.ignoreCappingGeometry = !1, this.ignoreOverlays = !1, this.restrictToOverlays = !1, this.selectionMask = t;
  }
  /** Returns a copy of this [[PickConfig]]. */
  copy() {
    const t = new Si();
    return vv(this, t), t;
  }
  get allowFaces() {
    return (this.selectionMask & Se.Face) !== 0;
  }
  set allowFaces(t) {
    this.selectionMask = pa(this.selectionMask, Se.Face, t);
  }
  get allowLines() {
    return (this.selectionMask & Se.Line) !== 0;
  }
  set allowLines(t) {
    this.selectionMask = pa(this.selectionMask, Se.Line, t);
  }
  get allowPoints() {
    return (this.selectionMask & Se.Point) !== 0;
  }
  set allowPoints(t) {
    this.selectionMask = pa(this.selectionMask, Se.Point, t);
  }
}
class xd {
  constructor(t = Se.All) {
    this.mustBeFullyContained = !1, this.respectVisibility = !0, this.forceEffectiveVisibilityMask = Se.None, this.forceEffectiveSceneVisibilityMask = Se.None, this.allowFaces = !0, this.allowLines = !0, this.allowPoints = !0, this.ignoreCuttingSections = !0, this.onlyStreamedInstances = !1, this.ignoreUnrequestedInstances = !1, this.allowFaces = (t & Se.Face) !== 0, this.allowLines = (t & Se.Line) !== 0, this.allowPoints = (t & Se.Point) !== 0;
  }
}
class $o {
  constructor(t, e, i, n) {
    this.x = t, this.xUnit = e, this.y = i, this.yUnit = n;
  }
}
class U_ {
  constructor(t, e, i) {
    this._anchor = t, this._position = e, this._size = i;
  }
  getAnchor() {
    return this._anchor;
  }
  getPosition() {
    return this._position;
  }
  getSize() {
    return this._size;
  }
}
class j_ {
  /** @hidden */
  constructor(t, e, i, n) {
    this._view = t, this._model = e, this._callbackManager = i, this._engine = n, this._viewports = [];
    for (let r = 0; r <= this.maxIndex(); r++)
      this._viewports.push(null);
  }
  /**
   * Gets the maximum index value that can be used for indexing overlays.
   * @returns the maximum index value.
   */
  maxIndex() {
    return be.First - 1;
  }
  /**
   * Creates an overlay or updates an existing one.
   * @param index the index of the overlay. This value may be any number between 1 and maxIndex(). If No overlay exists for this index one will be created.
   * @param anchor the anchor point for the viewport.
   * @param x the x value of the viewport location.
   * @param xUnit the unit type of the x parameter.
   * @param y the y value of the viewport location.
   * @param yUnit the unit type of the y parameter.
   * @param width the width of the viewport.
   * @param widthUnit the unit type of the width parameter.
   * @param height the height of the viewport.
   * @param heightUnit the unit type of the height parameter.
   */
  setViewport(t, e, i, n, r, o, l, h, u, d) {
    if (t === 0)
      throw new oe("Index 0 is reserved and may not be used to specify an overlay.");
    if (t < 0)
      throw new oe(`Invalid index ${t} specified when setting viewport.`);
    if (n === Fe.ProportionOfOtherDimension && o === Fe.ProportionOfOtherDimension)
      throw new oe("Both x and y may not be set proportional to each other");
    if (h === Fe.ProportionOfOtherDimension && d === Fe.ProportionOfOtherDimension)
      throw new oe(
        "Both width and height may not be set proportional to each other"
      );
    this._validateUnit(i, n, "x"), this._validateUnit(r, o, "y"), this._validateUnit(l, h, "width"), this._validateUnit(u, d, "height");
    const g = new $o(i, n, r, o), y = new $o(l, h, u, d), m = new U_(e, g, y);
    return this._viewports[t] = m, this._engine.setOverlayViewport(
      t,
      e,
      i,
      n,
      r,
      o,
      l,
      h,
      u,
      d,
      this._view.id
    ), this._callbackManager.trigger("overlayViewportSet", t, this._view), Promise.resolve();
  }
  /**
   * @hidden
   * Gets the position of a viewport as it was defined with OverlayUnits
   * @param index Index to get position of
   * @returns OverlayUnitPoint expressing overlay's position
   */
  _getViewportPosition(t) {
    const e = this._viewports[t];
    return e === null ? null : e.getPosition();
  }
  /**
   * Gets position in pixels of the viewport with the supplied index, or `null` if none has been set.
   * Note: This does not take the anchor point into account
   * @param index The index of the overlay to get the position of.
   */
  getViewportPixelPosition(t) {
    const e = this._viewports[t];
    if (e === null)
      return null;
    const i = e.getPosition();
    return this._toPixelPoint(i);
  }
  /**
   * Gets the calculated position of the upper-left corner of the viewport with the supplied index, or `null`
   * if none has been set.
   * @param index The index of the overlay to get the offset of
   */
  getViewportPixelOffsetInCanvas(t) {
    const e = this.getViewportPixelPosition(t);
    if (e === null)
      return null;
    const i = this.getViewportPixelSize(t);
    if (i === null)
      return null;
    const n = this.getViewportAnchor(t);
    if (n === null)
      return null;
    const r = this._getOverlayOffset(n, i), o = K.add(r, e);
    switch (n) {
      case qe.UpperRightCorner:
      case qe.RightCenter:
      case qe.LowerRightCorner:
        o.x = r.x - e.x;
        break;
    }
    switch (n) {
      case qe.LeftCenter:
      case qe.Center:
      case qe.RightCenter:
      case qe.LowerLeftCorner:
      case qe.BottomCenter:
      case qe.LowerRightCorner:
        o.y = r.y - e.y;
    }
    return o;
  }
  /**
   * @hidden
   * Gets the size of a viewport as it was defined with OverlayUnits
   * @param index Index to get size of
   * @returns OverlayUnitPoint expressing overlay's size
   */
  _getViewportSize(t) {
    const e = this._viewports[t];
    return e === null ? null : e.getSize();
  }
  /**
   * Gets size in pixels of the viewport with the supplied index, or `null` if none has been set.
   * @param index The index of the overlay to get the size of.
   */
  getViewportPixelSize(t) {
    const e = this._viewports[t];
    if (e === null)
      return null;
    const i = e.getSize();
    return this._toPixelPoint(i);
  }
  /**
   * Get the anchor point of the viewport with the supplied index, or `null` if none has been set.
   * @param index The index of the overlay to get the anchor of.
   */
  getViewportAnchor(t) {
    const e = this._viewports[t];
    return e === null ? null : e.getAnchor();
  }
  /**
   * Sets the visibility state for the given viewport.
   * @param index the overlay index.
   * @param visibility boolean value indicating whether the overlay should be rendered.
   */
  setVisibility(t, e) {
    return this._engine.setOverlayVisibility(t, e, this._view.id), Promise.resolve();
  }
  /**
   * Removes an overlay from the system. All nodes that have been assigned to this overlay will be returned to the default view.
   * @param index the index of the overlay to destroy.
   */
  destroy(t) {
    return this._engine.destroyOverlay(t, this._view.id), this._viewports[t] = null, Promise.resolve();
  }
  /**
   * Adds nodes into the overlay at the given index. They will no longer be rendered in the main window or any other overlay.
   * This method should not be called before the model structure ready callback has been triggered.
   * @param index the overlay index to add nodes into.
   * @param nodes the nodes to add into the overlay.
   */
  addNodes(t, e) {
    const i = this._model._gatherInstanceIncsFromNodeIds(e);
    return i.length > 0 && this._engine.addNodesToOverlay(i, this._view.id, t), Promise.resolve();
  }
  /**
   * Sets the camera for the given index.
   * @param index
   * @param camera
   */
  setCamera(t, e) {
    return this._engine.setOverlayCamera(t, e, this._view.id), Promise.resolve();
  }
  /** @hidden */
  _getOverlayOffset(t, e) {
    const i = this._view.getCanvasSize(), n = K.zero();
    return t === qe.LowerRightCorner || t === qe.UpperRightCorner || t === qe.RightCenter ? n.x = i.x - e.x : (t === qe.Center || t === qe.TopCenter || t === qe.BottomCenter) && (n.x = 0.5 * (i.x - e.x)), t === qe.LowerLeftCorner || t === qe.LowerRightCorner || t === qe.BottomCenter ? n.y = i.y - e.y : (t === qe.Center || t === qe.LeftCenter || t === qe.RightCenter) && (n.y = 0.5 * (i.y - e.y)), n;
  }
  /**
   * @hidden
   * Converts an OverlayUnitPoint to a pixel defined Point2 using the viewer's current dimensions
   * @param unitPoint Point defined with [[OverlayUnit]]s to convert
   * @returns point expressed in pixels based on viewer's current size
   */
  _toPixelPoint(t) {
    const e = this._view.getCanvasSize(), i = K.zero();
    let n = !1;
    switch (t.xUnit) {
      case Fe.Pixels:
        i.x = t.x;
        break;
      case Fe.ProportionOfCanvas:
        i.x = e.x * t.x;
        break;
      case Fe.MinimumProportionOfCanvas:
        i.x = t.x * Math.min(e.x, e.y);
        break;
      case Fe.ProportionOfOtherDimension:
        n = !0;
        break;
    }
    switch (t.yUnit) {
      case Fe.Pixels:
        i.y = t.y;
        break;
      case Fe.ProportionOfCanvas:
        i.y = e.y * t.y;
        break;
      case Fe.MinimumProportionOfCanvas:
        i.y = t.y * Math.min(e.x, e.y);
        break;
      case Fe.ProportionOfOtherDimension:
        i.y = i.x * t.y;
        break;
    }
    return n && (i.x = t.x * i.y), i;
  }
  _validateUnit(t, e, i) {
    if (e !== Fe.Pixels && (t < 0 || t > 1))
      throw new Rs(
        `value for ${i} should be between 0.0 and 1.0 when specifying non pixel value`
      );
  }
}
const QC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  OverlayManager: j_,
  OverlayUnitPoint: $o,
  OverlayViewport: U_
}, Symbol.toStringTag, { value: "Module" })), Tn = class Tn {
  /** @hidden */
  constructor(t, e, i, n, r) {
    this._active = bn.Inactive, this._isSceneReady = !1, this._isModelLoaded = !1, this._isOverlayVisible = !1, this._isCallbacksSet = !1, this._onCameraUpdateFunc = this._doCameraUpdate.bind(this), this._onFrameDrawnFunc = this._onFrameDrawn.bind(this), this._floorplanNode = null, this._currentFloorInfo = null, this._config = new Oh(), this._floorLock = !1, this._tightBoundings = !1, this._genericStoreyType = "IFCBUILDINGSTOREY", this._floorInfos = /* @__PURE__ */ new Map(), this._floorInfosArray = new Array(), this._avatarNode = null, this._avatarDirty = !0, this._borderNode = null, this._borderDirty = !0, this._backgroundNode = null, this._backgroundDirty = !0, this._canvasSize = new K(1, 1), this._sync = new jo(1, !0), this._setFloorplanSync = new P0(!1), this._viewer = t, this._model = e, this._engine = n, this._overlayManager = i, this._config = r.copy(), this._viewer.setCallbacks({
      sceneReady: () => {
        console.assert(
          this._active !== bn.Active,
          "Got sceneReady while Floorplan is Active"
        ), this._isSceneReady = !0, this._active === bn.Activating && this._sync.push(() => this._doUpdateActivation());
      },
      modelSwitchStart: () => {
        this._isModelLoaded = !1, this._sync.push(async () => this._deactivate());
      },
      firstModelLoaded: () => {
        this._isModelLoaded = !0, this._onModelLoaded();
      },
      subtreeLoaded: () => {
        this._isModelLoaded = !0, this._onModelLoaded();
      }
    });
  }
  /** Sets a custom avatar. See [[FloorplanConfig.customAvatar]] for detailed information. */
  async setCustomAvatar(t) {
    if (this._config.customAvatar !== t)
      return await this._doSetCustomAvatar(t), this._avatarDirty = !0, this._onConfigurationChanged();
  }
  /** Sets the size of the floorplan overlay window. See [[FloorplanConfig.overlaySize]] for detailed information. */
  async setOverlaySize(t, e, i) {
    return this._config.overlaySize = t.copy(), this._config.overlayWidthUnit = e, this._config.overlayHeightUnit = i, this._onConfigurationChanged();
  }
  /** Sets the anchor position of the floorplan overlay window. See [[FloorplanConfig.overlayAnchor]] for detailed information. */
  async setOverlayAnchor(t) {
    return this._config.overlayAnchor = t, this._onConfigurationChanged();
  }
  /** Sets the offset position of the floorplan overlay window. See [[FloorplanConfig.overlayOffset]] for detailed information. */
  async setOverlayOffset(t) {
    return this._config.overlayOffset = t.copy(), this._onConfigurationChanged();
  }
  /** Sets the overlay scaling. See [[FloorplanConfig.overlayFeetPerPixel]] for detailed information. */
  async setOverlayFeetPerPixel(t) {
    return this._config.overlayFeetPerPixel = t, this._onConfigurationChanged();
  }
  /** Sets the overlay zoom level. See [[FloorplanConfig.zoomLevel]] for detailed information. */
  async setZoomLevel(t) {
    return this._config.zoomLevel = t, this._onConfigurationChanged();
  }
  /** Sets the overlay background color. See [[FloorplanConfig.backgroundColor]] for detailed information. */
  async setBackgroundColor(t) {
    return this._config.backgroundColor = t, this._backgroundDirty = !0, this._onConfigurationChanged();
  }
  /** Sets the overlay background opacity. See [[FloorplanConfig.backgroundOpacity]] for detailed information. */
  async setBackgroundOpacity(t) {
    return this._config.backgroundOpacity = t, this._backgroundDirty = !0, this._onConfigurationChanged();
  }
  /** Sets the overlay border color. See [[FloorplanConfig.borderColor]] for detailed information. */
  async setBorderColor(t) {
    return this._config.borderColor = t, this._borderDirty = !0, this._onConfigurationChanged();
  }
  /** Sets the overlay border opacity. See [[FloorplanConfig.borderOpacity]] for detailed information. */
  async setBorderOpacity(t) {
    return this._config.borderOpacity = t, this._borderDirty = !0, this._onConfigurationChanged();
  }
  /** Sets the avatar primary color. See [[FloorplanConfig.avatarColor]] for detailed information. */
  async setAvatarColor(t) {
    return this._config.avatarColor = t, this._avatarDirty = !0, this._onConfigurationChanged();
  }
  /** Sets the avatar outline color. See [[FloorplanConfig.avatarOutlineColor]] for detailed information. */
  async setAvatarOutlineColor(t) {
    return this._config.avatarOutlineColor = t, this._avatarDirty = !0, this._onConfigurationChanged();
  }
  /** Sets the avatar opacity. See [[FloorplanConfig.avatarOpacity]] for detailed information. */
  async setAvatarOpacity(t) {
    return this._config.avatarOpacity = t, this._avatarDirty = !0, this._onConfigurationChanged();
  }
  /** Sets the avatar scale. See [[FloorplanConfig.avatarScale]] for detailed information. */
  async setAvatarScale(t) {
    return this._config.avatarScale = t, this._avatarDirty = !0, this._onConfigurationChanged();
  }
  /** Sets the avatar size to fixed scale. See [[FloorplanConfig.fixedAvatarScale]] for detailed information. */
  async setFixedAvatarScale(t) {
    if (this._config.fixedAvatarScale !== t)
      return await this._deleteAvatarNode(), this._config.fixedAvatarScale = t, this._avatarDirty = !0, this._onConfigurationChanged();
  }
  /** Sets the floorplan tracking mode. See [[FloorplanConfig.trackCameraEnabled]] for detailed information. */
  async setTrackCameraEnabled(t) {
    return this._config.trackCameraEnabled = t, this._onConfigurationChanged();
  }
  /** Sets the floorplan display orientation. See [[FloorplanConfig.floorplanOrientation]] for detailed information. */
  async setFloorplanOrientation(t) {
    return this._config.floorplanOrientation = t, this._onConfigurationChanged();
  }
  /** Sets the auto-activate capability for any models loaded after this call. See [[FloorplanConfig.autoActivate]] for detailed information. */
  async setAutoActivate(t) {
    return this._config.autoActivate = t, this._onConfigurationChanged();
  }
  /** Locks floorplan to current floor such that changing floors will not change the displayed floorplan. */
  async setFloorLock(t) {
    if (this._floorLock = t, this.isActive() && !t) {
      const e = this._viewer.view.getCamera().getPosition();
      await this._setFloorplanFromPosition(e);
    }
  }
  /** Returns `true` if displayed floor has been locked with [[setFloorLock]]. */
  getFloorLock() {
    return this._floorLock;
  }
  /**
   * Makes floorplans use tight boundings during creation which can result in a better fit for the overlay.
   * This involves recreating any already existing floorplans.
   * This can be significantly more time consuming than using loose boundings if your floors are complex.
   * Defaults to `false`.
   */
  async setUseTightBoundings(t) {
    t !== this._tightBoundings && (await this._deleteAllFloorplans(), this._tightBoundings = t, this.isActive() && await this._onProcessIfc());
  }
  /**
   * Updates the floorplan to use the given configuration. This function allows
   * the user to set all configuration values with a single operation. There are
   * also `set<config-value>()` functions for easily setting individual configuration
   * values.
   *
   * Note that when using this function, all settings in the given configuration are
   * used and thus overwrite any individual settings changed with a prior
   * `set<config-value>()` call.
   *
   * All values from the passed configuration will be copied as part of this operation.
   */
  async setConfiguration(t) {
    const e = this._config.customAvatar;
    return this._config = t.copy(), e !== this._config.customAvatar && await this._doSetCustomAvatar(this._config.customAvatar), this._borderDirty = !0, this._backgroundDirty = !0, this._avatarDirty = !0, this._onConfigurationChanged();
  }
  /** Returns a copy of the current floorplan configuration. */
  getConfiguration() {
    return this._config.copy();
  }
  /** Gets the [[NodeId]] of the current storey. */
  getCurrentFloorNodeId() {
    return this._currentFloorInfo !== null ? this._currentFloorInfo.floorNode : null;
  }
  /** Gets the [[NodeId]] of the floorplan avatar. */
  getAvatarNodeId() {
    return this._avatarNode;
  }
  /** Returns `true` if the given point is inside the floorplan overlay and `false` otherwise. */
  insideOverlay(t) {
    const e = this._getOverlaySizeInPixels(), i = this._getOverlayOffsetInPixels();
    return t.x >= i.x && t.y >= i.y && t.x <= i.x + e.x && t.y <= i.y + e.y;
  }
  /**
   *  Activate the floorplan overlay.
   */
  async activate() {
    await this._sync.push(() => this._activate());
  }
  /**
   *  Deactivate the floorplan overlay. Once explicitly deactivated via this call, auto-activation
   *  will be suppressed for any new model that is loaded. Auto-activation can be reenabled by
   *  calling [[setAutoActivate]].
   */
  async deactivate() {
    await this._sync.push(() => this._deactivate());
  }
  /**
   * The avatar node needs to be deleted any time we are making changes to the mesh,
   * such as switching to a custom avatar or fixed avatar scale.
   */
  async _deleteAvatarNode() {
    if (this._avatarNode !== null) {
      try {
        this._model._getModelStructure().allowNodeDeletion(this._avatarNode), await this._model.deleteNode(this._avatarNode);
      } catch (t) {
        console.log(`Problem deleting existing avatar: ${t.message}`);
      }
      this._avatarNode = null;
    }
  }
  /** Perform the steps needed to set a custom avatar. */
  async _doSetCustomAvatar(t) {
    await this._deleteAvatarNode(), this._config.customAvatar = t;
  }
  /** Call after something in the configuration has changed. Will update all visuals accordingly */
  async _onConfigurationChanged() {
    return this._config.zoomLevel = il(this._config.zoomLevel, 0.1, 10), this._config.avatarScale = il(this._config.avatarScale, 0.1, 10), this._config.backgroundOpacity = il(this._config.backgroundOpacity, 0, 1), this._config.borderOpacity = il(this._config.borderOpacity, 0, 1), this._config.avatarOpacity = il(this._config.avatarOpacity, 0, 1), this._isModelLoaded && this._active === bn.Inactive && this._config.autoActivate === Go.Bim ? this._onModelLoaded() : (this._isOverlayVisible && (this._isOverlayVisible = !1, await this._setupOverlay()), this._doCameraUpdate());
  }
  /** Sets the best floorplan for the given world position */
  async _setFloorplanFromPosition(t) {
    return this._setFloorplanSync.push(() => this._doSetFloorplanFromPosition(t));
  }
  /** Sets what floor the floorplan displays based on position */
  async _doSetFloorplanFromPosition(t) {
    let e = null;
    const i = [];
    for (const r of this._floorInfosArray)
      z_(t, r.bounds) && i.push(r);
    if (e = await (async (r) => {
      const o = await this._performDownwardSelection(t);
      for (const l of o) {
        const h = l.getNodeId(), u = this._model.getNodeParent(h);
        if (u === null)
          continue;
        const d = this._viewer.model.getNodeGenericType(u);
        if (d !== null) {
          if (Tn._ifcSpaceTypes.has(d)) {
            const g = await this._viewer.model.getNodesBounding([u]);
            if (!Hf(t, g))
              continue;
            for (const m of r)
              if (m.spaceNodes.indexOf(u) !== -1)
                return m;
          } else if (Tn._ifcFloorTypes.has(d)) {
            for (const g of r)
              if (g.slabNodes.indexOf(u) !== -1)
                return g;
          }
        }
      }
      return null;
    })(i), e === null) {
      for (const r of this._floorInfosArray)
        if (Hf(t, r.bounds)) {
          e = r;
          break;
        }
    }
    if (e !== null && (this._currentFloorInfo = e, this._floorplanNode === null || this._floorplanNode !== e.floorplanNode))
      return this._setFloorplanFromFloorNode(e.floorNode);
  }
  /** This function performs a downward selection and sorts the results by the top of their boundings */
  async _performDownwardSelection(t) {
    const e = new Si();
    e.respectVisibility = !1, e.oneEntityPerTypePerInstance = !0;
    const i = new wr(t, new _(0, 0, -1)), n = await this._viewer.view.pickAllFromRay(i, e), r = /* @__PURE__ */ new Map();
    for (const l of n) {
      const h = l.getNodeId(), u = await this._model.getNodesBounding([h]);
      r.set(h, u.max.z);
    }
    const o = (l, h) => {
      const u = r.get(l.getNodeId()), d = r.get(h.getNodeId());
      return u === void 0 || d === void 0 ? -1 : d - u;
    };
    return n.sort(o);
  }
  /**
   *  Will set the active state appropriately and kick off activation processing
   */
  async _activate() {
    this._active === bn.Inactive && (this._active = bn.Activating, await this._doUpdateActivation());
  }
  /**
   *  Deactivation will remove camera callbacks, hide the overlay, delete floornodes, and any other necessary cleanup
   */
  async _deactivate() {
    this._active !== bn.Inactive && (this._active = bn.Inactive, this._isCallbacksSet && (this._isCallbacksSet = !1, this._viewer.unsetCallbacks({
      camera: this._onCameraUpdateFunc,
      frameDrawn: this._onFrameDrawnFunc,
      transitionEnd: this._onCameraUpdateFunc
    })), this._isOverlayVisible = !1, await this._overlayManager.setVisibility(be.Floorplan, this._isOverlayVisible), this._borderNode && (await this._model.deleteNode(this._borderNode), this._borderNode = null), this._backgroundNode && (await this._model.deleteNode(this._backgroundNode), this._backgroundNode = null), await this._deleteAllFloorplans());
  }
  /**  This will be called anytime a model has loaded... first model, second model, etc. */
  async _onModelLoaded() {
    await this._sync.push(() => this._doOnModelLoaded());
  }
  /**
   * When a model is loaded, the active state will be examined and possibly modified here based on the incoming model.
   */
  async _doOnModelLoaded() {
    console.assert(this._isModelLoaded, "Model not loaded as expected");
    const t = this._model.getNodesByGenericType(this._genericStoreyType), e = t && t.size > 0;
    if (!e) {
      await this._deactivate();
      return;
    }
    this._active === bn.Inactive ? e && this._config.autoActivate === Go.Bim && (this._active = bn.Activating) : this._active === bn.Active && (this._active = bn.Activating), this._active === bn.Activating && await this._doUpdateActivation();
  }
  /**
   *  This will activate the floorplan visuals if conditions allow.
   */
  async _doUpdateActivation() {
    this._active !== bn.Activating || !this._isSceneReady || !this._isModelLoaded || (this._active = bn.Active, this._isOverlayVisible || await this._setupOverlay(), await this._onProcessIfc(), this._isCallbacksSet || (this._isCallbacksSet = !0, this._viewer.setCallbacks({
      camera: this._onCameraUpdateFunc,
      frameDrawn: this._onFrameDrawnFunc,
      transitionEnd: this._onCameraUpdateFunc
    })));
  }
  /**
   *  Deletes all floorplan infos including generated nodes
   */
  async _deleteAllFloorplans() {
    const t = this._floorInfosArray.slice();
    this._floorInfos.clear(), this._floorInfosArray.length = 0, this._floorplanNode = null, this._currentFloorInfo = null;
    for (const e of t)
      e.floorplanNode && await this._model.deleteNode(e.floorplanNode);
  }
  /** Hides the currently active floorplan */
  async _hideActiveFloorplan() {
    this._floorplanNode !== null && (await this._hideOverlayNode(this._floorplanNode), this._floorplanNode = null, this._currentFloorInfo = null);
  }
  /**
   *  Call when IFC information is available from the model tree. Note that this call can happen multiple
   *  times within a session, thus it must be tolerant of existing data vs new data.
   */
  async _onProcessIfc() {
    console.assert(this._active === bn.Active), await this._gatherFloorInfos(), await this._doCameraUpdate();
  }
  /**
   */
  _hasFloorInfo(t) {
    return this._floorInfos.has(t);
  }
  /**
   */
  _getFloorInfo(t) {
    const e = this._floorInfos.get(t);
    return e === void 0 ? null : e;
  }
  /**
   * Creates floorplan related information from a floor node
   */
  async _createFloorInfo(t) {
    const e = new Array();
    this._gatherDescendentIfcNodes(t, Tn._ifcFloorTypes, e);
    const i = new Array();
    this._gatherDescendentIfcNodes(t, Tn._ifcSpaceTypes, i);
    const n = new Array();
    if (this._gatherDescendentIfcNodes(
      t,
      Tn._ifcFloorplanCreationTypes,
      n
    ), n.length === 0)
      return null;
    const r = await this._model.getNodesBounding(n, {
      bodyInstance: !0,
      pmiBody: !1,
      viewFrame: !1,
      tightBounding: this._tightBoundings
    }), o = new H_(
      t,
      r,
      e,
      i,
      n
    );
    return this._floorInfos.set(t, o), this._floorInfosArray.push(o), o;
  }
  /**
   *  Find the root floor nodes within the model.
   */
  async _gatherFloorInfos() {
    const t = this._model.getNodesByGenericType(Tn._genericStoreyType);
    if (t === null || t.size === 0) {
      await this._deactivate();
      return;
    }
    for (const e of ao(t))
      this._hasFloorInfo(e) || await this._createFloorInfo(e);
    this._floorInfos.size === 0 && await this._deactivate();
  }
  /**
   * Gathers all descendent nodes that have IFC types matching the given IFC types
   */
  _gatherDescendentIfcNodes(t, e, i) {
    const n = this._model.getNodeChildren(t);
    for (const r of n) {
      const o = this._model.getNodeGenericType(r);
      o !== null && e.has(o) && i.push(r), this._gatherDescendentIfcNodes(r, e, i);
    }
  }
  /**
   * Creates a floorplan mesh from a FloorInfo object and returns the NodeId of the resulting mesh.
   * Note: This does not attach the created floorplan mesh to the FloorInfo param. That must be done after.
   */
  async _createFloorplanFromFloorInfo(t) {
    const e = this._model._gatherInstanceIncsFromNodeIds(
      t.floorplanMeshCreationNodes
    ), i = await this._engine.createFloorplanMesh(e), n = i[0], r = i[1];
    return this._model._getModelStructure().createMeshInstance(n, r, "floorplan", null, !0, !0, !1);
  }
  /** We need to handle a canvas size updates, so use the frame-drawn callback */
  async _onFrameDrawn() {
    const t = this._viewer.view.getCanvasSize();
    t.equals(this._canvasSize) || (this._canvasSize = t.copy(), this._isOverlayVisible && (this._isOverlayVisible = !1, await this._setupOverlay()));
  }
  /** Updates the overlay camera based on current state */
  async _doCameraUpdate() {
    if (this.isActive()) {
      this._floorLock || await this._setFloorplanFromPosition(this._viewer.view.getCamera().getPosition());
      try {
        this._viewer.pauseRendering(), await this._updateOverlay();
      } finally {
        this._viewer.resumeRendering();
      }
    }
  }
  /**
   * Returns `true` if the [[FloorplanManager]] is fully active.
   */
  isActive() {
    return this._active === bn.Active;
  }
  /** Call anytime something in the floorplan overlay might need to change. */
  async _updateOverlay() {
    if (!this.isActive())
      return;
    const t = this._viewer.view.getCamera(), e = t.getPosition();
    let i = _.subtract(t.getTarget(), e);
    i.z = 0, i.normalize(), (isNaN(i.x) || i.length() === 0) && (i = new _(0, 1, 0)), await this._updateOverlayCamera(e, i), await this._updateOverlayNodes(e, i);
  }
  /**
   * Call anytime something in the floorplan overlay might need to change.
   */
  async _updateOverlayNodes(t, e) {
    const i = this._model, n = this._config, r = this._model.getNodeUnitMultiplier(this._model.getAbsoluteRootNode()) * 304.8, o = this._getOverlaySizeInPixels(), l = o.x / o.y, h = r * n.overlayFeetPerPixel / n.zoomLevel, u = h / l;
    let d = h * o.x, g = d / l;
    if (!n.trackCameraEnabled) {
      const B = this._getFixedCameraSize(l);
      B !== null && (d = B.x, g = B.y);
    }
    const y = new mt().setTranslationComponent(
      t.x,
      t.y,
      Tn._avatarZ
    ), m = r * n.avatarScale, x = new mt().setScaleComponent(m, m, m), b = new mt();
    b.m[0] = e.y, b.m[1] = -e.x, b.m[2] = 0, b.m[4] = e.x, b.m[5] = e.y, b.m[6] = 0, b.m[8] = 0, b.m[9] = 0, b.m[10] = 1, await this._viewer.model.setNodeMatrix(
      this._avatarNode,
      zf([y, b, x])
    ), this._avatarDirty && (n.customAvatar === null && (i.setNodesFaceColor([this._avatarNode], n.avatarColor), i.setNodesLineColor([this._avatarNode], n.avatarOutlineColor), i.setNodesOpacity([this._avatarNode], n.avatarOpacity)), this._avatarDirty = !1), this._borderDirty && (i.setNodesLineColor([this._borderNode], n.borderColor), i.setNodesOpacity([this._borderNode], n.borderOpacity), this._borderDirty = !1), this._backgroundDirty && (i.setNodesFaceColor([this._backgroundNode], n.backgroundColor), i.setNodesOpacity([this._backgroundNode], n.backgroundOpacity), this._backgroundDirty = !1);
    const I = d - h, C = g - u, P = new mt().setScaleComponent(I, C, 1), k = new mt();
    if (!this._config.trackCameraEnabled && this._currentFloorInfo !== null) {
      const B = this._currentFloorInfo.bounds.center();
      k.setTranslationComponent(B.x, B.y, 0);
    } else
      k.setTranslationComponent(t.x, t.y, 0);
    const O = this._config.floorplanOrientation === hl.AvatarUp ? zf([k, b, P]) : mt.multiply(P, k);
    await this._viewer.model.setNodeMatrix(this._borderNode, O), await this._viewer.model.setNodeMatrix(this._backgroundNode, O);
  }
  /**
   * Moves the camera such that the avatar will appear at the provided point on the overlay.
   * This is only available when the floorplan is not tracking the camera.
   * @param point Point in canvas within overlay
   */
  snapAvatarToPoint(t) {
    if (this._currentFloorInfo === null || !this.insideOverlay(t))
      return;
    if (this._config.trackCameraEnabled) {
      console.log(
        "FP: snapAvatarToPoint: currently only supported when trackCameraEnabled is false"
      );
      return;
    }
    const e = this._getOverlaySizeInPixels(), i = this._getOverlayOffsetInPixels(), n = new K(t.x - i.x, t.y - i.y), r = this._currentFloorInfo.bounds, o = r.extents(), l = o.x / o.y, h = e.x / e.y, u = this._viewer.view.getCamera(), d = u.getPosition(), g = u.getTarget();
    let y = new mt();
    if (this._config.floorplanOrientation !== hl.NorthUp) {
      const P = _.subtract(g, d), k = new _(P.x, P.y, 0).normalize(), O = new _(0, 1, 0), B = new _(-1, 0, 0), j = yr(B, k) > 90 ? new _(0, 0, -1) : new _(0, 0, 1), V = yr(O, k);
      y = mt.createFromOffAxisRotation(j, V);
    }
    let m, x;
    h > l ? (m = o.y / e.y, x = new K(
      r.center().x - o.y / 2 * h,
      r.center().y + o.y / 2
    )) : (m = o.x / e.x, x = new K(
      r.center().x - o.x / 2,
      r.center().y + o.x / 2 / h
    ));
    let b = new _(
      n.x * m + x.x,
      x.y - n.y * m,
      d.z
    );
    b = y.transform(b);
    const I = _.subtract(g, d), C = _.add(b, I);
    u.setPosition(b), u.setTarget(C), u.setProjection(ri.Perspective), this._viewer.view.setCamera(u);
  }
  /** Figure out the pixel size of the overlay window */
  _getOverlaySizeInPixels() {
    const t = new $o(
      this._config.overlaySize.x,
      this._config.overlayWidthUnit,
      this._config.overlaySize.y,
      this._config.overlayHeightUnit
    );
    return this._viewer.overlayManager._toPixelPoint(t);
  }
  /** Get overlay offset in pixels */
  _getOverlayOffsetInPixels() {
    const t = this._overlayManager.getViewportPixelOffsetInCanvas(
      be.Floorplan
    );
    return t === null ? K.zero() : t;
  }
  _getFixedCameraSize(t) {
    if (this._currentFloorInfo !== null) {
      const e = this._currentFloorInfo.bounds.extents();
      return e.x / e.y > t ? new K(e.x, e.x / t) : new K(e.y * t, e.y);
    }
    return null;
  }
  /** Updates the camera settings for the overlay. Only update if the floorplan has changed?  */
  async _updateOverlayCamera(t, e) {
    const i = this._config, n = this._getOverlaySizeInPixels(), r = n.x / n.y;
    let h = this._model.getNodeUnitMultiplier(this._model.getAbsoluteRootNode()) * 304.8 * i.overlayFeetPerPixel / i.zoomLevel * n.x, u = h / r;
    if (!i.trackCameraEnabled) {
      const g = this._getFixedCameraSize(r);
      g !== null && (h = g.x, u = g.y);
    }
    const d = new Cn();
    if (d.setWidth(h), d.setHeight(u), !this._config.trackCameraEnabled && this._currentFloorInfo !== null) {
      const g = this._currentFloorInfo.bounds.center();
      d.setTarget(new _(g.x, g.y, 0)), d.setPosition(new _(g.x, g.y, 10));
    } else
      d.setTarget(new _(t.x, t.y, 0)), d.setPosition(new _(t.x, t.y, 10));
    i.floorplanOrientation === hl.AvatarUp ? d.setUp(e) : i.floorplanOrientation === hl.NorthUp && d.setUp(new _(0, 1, 0)), await this._overlayManager.setCamera(be.Floorplan, d);
  }
  /**
   * Sets the current floorplan based on the floorNode.
   *
   * @param floorNode A IFC Story node.
   */
  async _setFloorplanFromFloorNode(t) {
    await this._hideActiveFloorplan();
    const e = this._hasFloorInfo(t) ? this._getFloorInfo(t) : await this._createFloorInfo(t);
    if (e !== null) {
      if (e.floorplanNode === null) {
        const i = await this._createFloorplanFromFloorInfo(e), n = new mt();
        await this._model.setNodeMatrix(i, n, !0), await this._overlayManager.addNodes(be.Floorplan, [i]), e.floorplanNode = i, this._floorplanNode = i, this._currentFloorInfo = e, await this._showOverlayNode(i);
      } else
        this._floorplanNode = e.floorplanNode, this._currentFloorInfo = e, await this._showOverlayNode(e.floorplanNode);
      await this._updateOverlay();
    }
  }
  /**
   *  Creates the floorplan overlay
   */
  async _setupOverlay() {
    const t = this._config;
    console.assert(this.isActive());
    const e = this._overlayManager;
    this._isOverlayVisible = !0, await e.setViewport(
      be.Floorplan,
      t.overlayAnchor,
      t.overlayOffset.x,
      t.overlayOffsetXUnit,
      t.overlayOffset.y,
      t.overlayOffsetYUnit,
      t.overlaySize.x,
      t.overlayWidthUnit,
      t.overlaySize.y,
      t.overlayHeightUnit
    ), await e.setVisibility(be.Floorplan, this._isOverlayVisible), this._avatarNode || (this._avatarNode = this._config.customAvatar = this._config.customAvatar ?? await this._createAvatar(), this._model._getModelStructure().preventNodeDeletion(this._avatarNode), await this._overlayManager.addNodes(be.Floorplan, [this._avatarNode])), this._borderNode || (this._borderNode = await this._create2dBox(!0, !1, Tn._borderZ), await this._overlayManager.addNodes(be.Floorplan, [this._borderNode]), this._borderDirty = !0), this._backgroundNode || (this._backgroundNode = await this._create2dBox(!1, !0, Tn._backgroundZ), await this._overlayManager.addNodes(be.Floorplan, [this._backgroundNode]), this._backgroundDirty = !0), await this._updateOverlay();
  }
  /** Nodes within the the overlay displays aren't honoring their visibility settings. This is a workaround
   *  until that problem is fixed. Since the floorplan is a top-down view, we can just move "hidden" nodes
   *  far enough out of the camera view so they aren't rendered.
   */
  async _hideOverlayNode(t) {
    const e = new mt();
    e.setTranslationComponent(1e30, 0, 0), await this._model.setNodeMatrix(t, e, !0);
  }
  /** See _hideOverlayNode for workaround description */
  async _showOverlayNode(t) {
    await this._model.setNodeMatrix(t, new mt(), !0);
  }
  /** Creates a simple node to show the camera-position as an avatar on the overlay */
  async _createAvatar() {
    const t = this._config.fixedAvatarScale ? 1e4 : 1, e = 1.2 / t, i = 1.5 / t, n = -1.1 / t, r = [
      0,
      i,
      0,
      -e,
      -i,
      0,
      0,
      n,
      0,
      0,
      i,
      0,
      0,
      n,
      0,
      e,
      -i,
      0
    ], o = [
      -e,
      -i,
      0,
      0,
      i,
      0,
      e,
      -i,
      0,
      0,
      n,
      0,
      -e,
      -i,
      0
    ], l = new Cs();
    l.setBackfacesEnabled(!1), l.addFaces(r, void 0, void 0, void 0), l.addPolyline(o, void 0);
    const h = await this._viewer.model.createMesh(l), u = new Qs(h), d = (this._config.fixedAvatarScale ? ee.SuppressCameraScale : ee.None) | ee.ExcludeBounding;
    return u.setCreationFlags(d), await this._viewer.model.createMeshInstance(
      u,
      null,
      !0,
      !0
    );
  }
  /** Create a 2d line based box. Used for the overlay border & background */
  async _create2dBox(t, e, i) {
    const h = new Cs();
    if (t) {
      const y = [
        -0.5,
        -0.5,
        i,
        -0.5,
        0.5,
        i,
        0.5,
        0.5,
        i,
        0.5,
        -0.5,
        i,
        -0.5,
        -0.5,
        i
      ];
      h.addPolyline(y, void 0);
    }
    if (e) {
      const y = [
        0.5,
        -0.5,
        i,
        0.5,
        0.5,
        i,
        -0.5,
        0.5,
        i,
        -0.5,
        0.5,
        i,
        -0.5,
        -0.5,
        i,
        0.5,
        -0.5,
        i
      ], m = [
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1,
        0,
        0,
        1
      ];
      h.addFaces(y, m), h.setBackfacesEnabled(!1);
    }
    const u = await this._viewer.model.createMesh(h), d = new Qs(u);
    return d.setCreationFlags(
      ee.ExcludeBounding | ee.DoNotReset
    ), await this._viewer.model.createMeshInstance(d, null, !0, !0);
  }
};
Tn._genericStoreyType = "IFCBUILDINGSTOREY", Tn._ifcFloorTypes = /* @__PURE__ */ new Set(["IFCSLAB"]), Tn._ifcSpaceTypes = /* @__PURE__ */ new Set(["IFCSPACE"]), Tn._ifcFloorplanCreationTypes = /* @__PURE__ */ new Set([
  "IFCWALL",
  "IFCWALLSTANDARDCASE",
  "IFCCURTAINWALL",
  "IFCSLAB",
  "IFCCOLUMN"
]), Tn._backgroundZ = -1, Tn._avatarZ = 1, Tn._borderZ = 2;
let sd = Tn;
const t1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ActiveState: bn,
  FloorInfo: H_,
  FloorplanAutoActivation: Go,
  FloorplanConfig: Oh,
  FloorplanManager: sd,
  clamp: il,
  isPointInBox: z_,
  isPointInBoxOnlyZ: Hf,
  multiplyMatrices: zf
}, Symbol.toStringTag, { value: "Module" }));
class Id {
  /**
   * @param viewKey key for the View the event is occurring in
   */
  constructor(t = Me.Default) {
    this._date = /* @__PURE__ */ new Date(), this._handled = !1, this._viewKey = t;
  }
  /**
   * Get the ViewKey this event is associated with.
   */
  get viewKey() {
    return this._viewKey;
  }
  /**
   * Gets the handled state of the event
   * @returns whether the event has been handled
   */
  getHandled() {
    return this._handled;
  }
  /**
   * Sets the handled state of the event. When an event has been handled it will not propagate any further
   * @param handled Indicates whether this event has been handled.
   */
  setHandled(t) {
    this._handled = t;
  }
  /**
   * Gets the Date this event occurred
   * @returns the event Date
   */
  getDate() {
    return this._date;
  }
}
class Uf extends Id {
  /** @hidden */
  constructor(t, e, i, n) {
    super(n), this._keyCode = t, this._eventType = i;
  }
  /**
   * gets the key code
   * @returns the key code of the event
   */
  getKeyCode() {
    return this._keyCode;
  }
  /**
   * gets the event type
   * @returns the type of key event
   */
  getEventType() {
    return this._eventType;
  }
}
class Pg extends Id {
  /** @hidden */
  constructor(t, e, i, n, r) {
    super(r), this._position = new K(t, e), this._modifiers = i, this._inputType = n;
  }
  /**
   * gets the window position of the mouse pointer for this event
   * @returns the mouse position for this event
   */
  getPosition() {
    return this._position.copy();
  }
  /**
   * gets the state of the shift key
   * @returns whether the shift key was down when this event was generated
   */
  shiftDown() {
    return (this._modifiers & Ci.Shift) === Ci.Shift;
  }
  /**
   * gets the state of the alt key
   * @returns whether the alt key was down when this event was generated
   */
  altDown() {
    return (this._modifiers & Ci.Alt) === Ci.Alt;
  }
  /**
   * gets the state of the control key
   * @returns whether the control key was down when this event was generated
   */
  controlDown() {
    return (this._modifiers & Ci.Control) === Ci.Control;
  }
  /**
   * gets the state of the command key
   * @returns whether the command key was down when this event was generated
   */
  commandDown() {
    return (this._modifiers & Ci.Command) === Ci.Command;
  }
  /**
   * gets the event type
   * @returns the type of mouse event
   */
  getEventType() {
    return this._inputType;
  }
  /**
   * gets the event modifiers
   * @returns bitwise combination of KeyModifiers
   */
  getModifiers() {
    return this._modifiers;
  }
}
class Wr extends Pg {
  /**
   * Mouse Event class
   * @param positionX X window position of the mouse
   * @param positionY Y window position of the mouse
   * @param button mouse button associated with this event
   * @param buttons mouse buttons currently pressed with this event
   * @param modifiers bitwise collection of values from KeyModifiers enum
   * @param inputType the type of the event
   */
  constructor(t, e, i, n, r, o, l) {
    super(t, e, r, o, l), this._button = i, this._buttons = n;
  }
  /**
   * gets the mouse button associated with this event
   * @returns the mouse button for this event
   */
  getButton() {
    return this._button;
  }
  /**
   * gets the mouse buttons currently pressed with this event
   * @returns the mouse buttons currently pressed for this event
   */
  getButtons() {
    return this._buttons;
  }
}
class W_ extends Pg {
  /**
   * Mousewheel Event class
   * @param positionX X window position of the mouse
   * @param positionY Y window position of the mouse
   * @param wheelDelta the direction the mouse wheel moved
   * @param buttons mouse buttons currently pressed with this event
   * @param modifiers bitwise collection of values from KeyModifiers enum
   * @param inputType the type of the event
   * @hidden
   */
  constructor(t, e, i, n, r, o, l) {
    super(t, e, r, o, l), this._wheelDelta = i, this._buttons = n;
  }
  /**
   * Gets the wheel delta for this event. A positive value indicates that the wheel was scrolled Up, while a negative value indicated the wheel was scrolled down.
   * @returns Wheel dela value
   */
  getWheelDelta() {
    return this._wheelDelta;
  }
  /**
   * gets the mouse buttons currently pressed with this event
   * @returns the mouse buttons currently pressed for this event
   */
  getButtons() {
    return this._buttons;
  }
}
var so = /* @__PURE__ */ ((s) => (s[s.Dec = 0] = "Dec", s[s.Inc = 1] = "Inc", s))(so || {});
function jf(s, t) {
  if (t.getNodeType(s) === Le.BodyInstance) {
    let e = s;
    for (; e !== null; ) {
      if (t.getNodeGenericId(e) !== null)
        return e;
      e = t.getNodeParent(e);
    }
  }
  return s;
}
class rd {
  constructor(t, e, i) {
    this.faceItem = t, this.lineItem = e, this.pointItem = i;
  }
  /**
   * Returns the most relevant selection item for the provided selection mask.
   * The priority used by this method is points -> lines -> faces.
   * For example, if your selection mask was Faces | Lines and this item contained and all fields were populated, this method would return its lineItem.
   * @param mask a selection mask used to indicate the relevancy of the item to retrieve.
   * @returns the most relevant selection item if one exists.  If no relevant item is found, null is returned.
   */
  fetchMostRelevant(t) {
    return this.pointItem !== null && t & Se.Point ? this.pointItem : this.lineItem !== null && t & Se.Line ? this.lineItem : this.faceItem !== null && t & Se.Face ? this.faceItem : null;
  }
}
class Rh {
  /** @hidden */
  constructor(t, e, i, n, r, o, l) {
    this._position = t.copy(), this._normal = e.copy(), this._elementIndex = i, this._elementBits = r, this._bounding = o.copy(), this._overlayIndex = n, this._isProximityFace = l;
  }
  /**
   * Returns whether or not this face entity was selected by proximity or was instead selected dead-on.
   * @returns True if this face entity was selected by proximity and false otherwise.
   */
  isProximityFace() {
    return this._isProximityFace;
  }
  /**
   * Returns whether or not this face entity is capping geometry or not.
   * @returns True if this face entity is capping geometry and false otherwise.
   */
  isCappingGeometry() {
    return this._elementIndex === -1;
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      position: this._position.toJson(),
      normal: this._normal.toJson(),
      cadFaceIndex: this._elementIndex,
      cadFaceBits: this._elementBits,
      bounding: this._bounding.toJson(),
      overlayIndex: this._overlayIndex,
      isProximityFace: this._isProximityFace
    };
  }
  /**
   * Creates a new [[FaceEntity]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t) {
    const e = t, i = _.fromJson(e.position), n = _.fromJson(e.normal), r = yn.fromJson(e.bounding), o = e.overlayIndex, l = e.isProximityFace === !0;
    return new Rh(
      i,
      n,
      e.cadFaceIndex,
      o,
      e.cadFaceBits,
      r,
      l
    );
  }
  /**
   * Gets the world space position of the selection point.
   * @returns World space position of the selection point if it can be determined.
   */
  getPosition() {
    return this._position.copy();
  }
  /**
   * Gets the face normal for the selection Point.
   * @returns Face normal for the selection position if it can be determined.
   */
  getNormal() {
    return this._normal.copy();
  }
  /**
   * Gets the cad face index for the selection Point.
   * @returns The index for the cad face.
   */
  getCadFaceIndex() {
    return this._elementIndex;
  }
  /**
   * Gets the cad face bits for the selection Point.
   * @returns The bits set on the cad face.
   */
  getCadFaceBits() {
    return this._elementBits;
  }
  /**
   * Gets the bounding box for the face entity
   * @returns Bounding box for the face entity
   */
  getBounding() {
    return this._bounding.copy();
  }
  /**
   * @returns The index of the overlay the entity belongs to.
   */
  overlayIndex() {
    return this._overlayIndex;
  }
}
class xc {
  constructor(t) {
    this._handle = t;
  }
}
class Lh {
  /** @hidden */
  constructor(t, e, i, n, r, o, l) {
    if (this._lineSegmentVertices = [], this._elementIndex = t, this._elementBits = l, this._position = e.copy(), this._bounding = r.copy(), this._overlayIndex = o, i) {
      if (n >= 0) {
        const h = 3 * n;
        this._bestLineSegmentVertexIndex = new _(
          i[h],
          i[h + 1],
          i[h + 2]
        );
      }
      this._lineSegmentVertices.push(
        new _(i[0], i[1], i[2])
      );
      for (let h = 3; h < i.length; h += 6)
        this._lineSegmentVertices.push(
          new _(i[h], i[h + 1], i[h + 2])
        );
    }
  }
  isCappingGeometry() {
    return this._elementIndex < 0;
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    const t = [];
    for (const e of this._lineSegmentVertices)
      t.push(e.toJson());
    return {
      lineId: this._elementIndex,
      lineBits: this._elementBits,
      position: this._position.toJson(),
      linePoints: t,
      bounding: this._bounding.copy(),
      overlayIndex: this._overlayIndex
    };
  }
  /**
   * Creates a new [[LineEntity]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t) {
    const e = t, i = _.fromJson(e.position), n = yn.fromJson(e.bounding), r = e.overlayIndex, o = new Lh(e.lineId, i, null, -1, n, r, 0);
    for (const l of e.linePoints) {
      const h = _.fromJson(l);
      o._lineSegmentVertices.push(h);
    }
    return o;
  }
  /**
   * Gets the line identifier
   * @returns the identifier of the line that was selected
   */
  getLineId() {
    return this._elementIndex;
  }
  /**
   * Gets the closest point on the selected line
   * @returns the closest point on the line
   */
  getPosition() {
    return this._position.copy();
  }
  getPoints() {
    return this._lineSegmentVertices;
  }
  /**
   * Returns the vertex of the line that is closest to the selection
   * point.
   *
   * Clipped vertices are skipped. If the vertex is occluded, then
   * `null` is returned.
   */
  getBestVertex() {
    return this._bestLineSegmentVertexIndex ? this._bestLineSegmentVertexIndex.copy() : null;
  }
  /**
   * Gets the kine bits for the selection Point.
   * @returns The bits set on the line/edge.
   */
  getLineBits() {
    return this._elementBits;
  }
  /**
   * Gets the bounding box for the line entity
   * @returns Bounding box for the line entity
   */
  getBounding() {
    return this._bounding.copy();
  }
  /**
   * @returns The index of the overlay the entity belongs to.
   */
  overlayIndex() {
    return this._overlayIndex;
  }
}
class G_ {
  constructor() {
    this.none = 0, this.face = 0, this.line = 0, this.point = 0, this.part = 0;
  }
  update(t, e) {
    switch (t.getSelectionType()) {
      case On.None:
        e === so.Dec ? --this.none : ++this.none;
        break;
      case On.Face:
        e === so.Dec ? --this.face : ++this.face;
        break;
      case On.Line:
        e === so.Dec ? --this.line : ++this.line;
        break;
      case On.Point:
        e === so.Dec ? --this.point : ++this.point;
        break;
      case On.Part:
        e === so.Dec ? --this.part : ++this.part;
        break;
    }
  }
  sum() {
    return this.none + this.face + this.line + this.point + this.part;
  }
}
class Fh {
  /** @hidden */
  constructor(t, e, i, n) {
    this._position = t.copy(), this._elementIndex = e, this._overlayIndex = i, this._elementBits = n;
  }
  /**
   * Creates a new [[PointEntity]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t) {
    const e = t, i = _.fromJson(e.position), n = e.overlayIndex;
    return new Fh(i, e.pointId, e.pointBits, n);
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      pointId: this._elementIndex,
      pointBits: this._elementBits,
      position: this._position.toJson(),
      overlayIndex: this._overlayIndex
    };
  }
  /**
   * Gets the world space position of the selection point.
   * @returns World space position of the selection point if it can be determined.
   */
  getPosition() {
    return this._position.copy();
  }
  /**
   * Gets the cad bits for the selection Point.
   * @returns The bits set on the point.
   */
  getPointBits() {
    return this._elementBits;
  }
  /**
   * Gets the point identifier
   * @returns the identifier of the point that was selected
   */
  getPointId() {
    return this._elementIndex;
  }
  /**
   * @returns The index of the overlay the entity belongs to.
   */
  overlayIndex() {
    return this._overlayIndex;
  }
}
class _i {
  /** @hidden */
  constructor(t = null, e = null, i = null, n = null, r = null) {
    this._nodeId = t, this._inclusionKey = e, this._faceEntity = i, this._lineEntity = n, this._pointEntity = r;
  }
  static create(t, e, i, n, r) {
    return new _i(t, e, i, n, r);
  }
  getSelectionType() {
    return this._nodeId === null ? On.None : this._faceEntity !== null ? On.Face : this._lineEntity !== null ? On.Line : this._pointEntity !== null ? On.Point : On.Part;
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      nodeId: this._nodeId,
      includeId: this._inclusionKey,
      faceEntity: this._faceEntity ? this._faceEntity.toJson() : null,
      lineEntity: this._lineEntity ? this._lineEntity.toJson() : null,
      pointEntity: this._pointEntity ? this._pointEntity.toJson() : null
    };
  }
  /** @hidden */
  static _fromJson(t) {
    const e = t;
    return new _i(
      e.nodeId,
      e.includeId,
      e.faceEntity ? Rh.fromJson(e.faceEntity) : null,
      e.lineEntity ? Lh.fromJson(e.lineEntity) : null,
      e.pointEntity ? Fh.fromJson(e.pointEntity) : null
    );
  }
  /**
   * Gets the face entity for this selection.
   * @returns the face entity if one was selected, otherwise null
   */
  getFaceEntity() {
    return this._faceEntity;
  }
  /**
   * Gets the line entity for this selection.
   * @returns the line entity if one was selected, otherwise null
   */
  getLineEntity() {
    return this._lineEntity;
  }
  /**
   * Gets the point entity for this selection.
   * @returns the point entity if one was selected, otherwise null
   */
  getPointEntity() {
    return this._pointEntity;
  }
  /**
   * Gets the part id for this selection.
   * @returns the part id associated with this selection item
   */
  getNodeId() {
    return this._nodeId ?? vg;
  }
  /**
   * Gets the include id for this selection.
   * @returns the inclusion key associated with this selection item
   */
  getInclusionKey() {
    return this._inclusionKey;
  }
  /**
   * Convenience method for getting the world space position of the selection point.
   * [[SelectionItem]]s with a type of [[SelectionType.Part]] will not have a position and null will be returned.
   * @returns World space position of the selection point if it can be determined.
   */
  getPosition() {
    return this._faceEntity !== null ? this._faceEntity.getPosition() : this._lineEntity !== null ? this._lineEntity.getPosition() : this._pointEntity !== null ? this._pointEntity.getPosition() : null;
  }
  /**
   * Gets the overlay index for this selection.
   * @returns the overlay index associated with this selection item
   */
  overlayIndex() {
    return this._faceEntity ? this._faceEntity.overlayIndex() : this._lineEntity ? this._lineEntity.overlayIndex() : this._pointEntity ? this._pointEntity.overlayIndex() : null;
  }
  /** @hidden */
  _setNodeId(t) {
    this._nodeId = t;
  }
  /**
   * Determines if two selection items are equal.
   * @param selectionItem The selection item to test against.
   * @returns whether or not the two items are equal.
   */
  equals(t) {
    return this._nodeId !== t._nodeId || this.getSelectionType() !== t.getSelectionType() ? !1 : this._faceEntity && t._faceEntity ? this._faceEntity.getCadFaceIndex() === t._faceEntity.getCadFaceIndex() : this._lineEntity && t._lineEntity ? this._lineEntity.getLineId() === t._lineEntity.getLineId() : this._pointEntity && t._pointEntity ? this._pointEntity.getPointId() === t._pointEntity.getPointId() : !0;
  }
  /** @hidden */
  _hash(t) {
    let e = this._nodeId !== null ? this._nodeId.toString(36) : "";
    return t || (e += `;${this.getSelectionType()};`, this._faceEntity && (e += this._faceEntity.getCadFaceIndex().toString(36)), e += ";", this._lineEntity && (e += this._lineEntity.getLineId().toString(36)), e += ";", this._pointEntity && (e += this._pointEntity.getPointId().toString(36))), e;
  }
  /**
   * @returns true if the object has the fields required for an [[EntitySelectionItem]].
   * This function can be used as a TypeScript [type guard](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards).
   */
  isEntitySelection() {
    return this._faceEntity !== null || this._lineEntity !== null || this._pointEntity !== null;
  }
  /**
   * @returns true if the object has the fields required for a [[NodeSelectionItem]].
   * This function can be used as a TypeScript [type guard](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards).
   */
  isNodeSelection() {
    return this._nodeId !== null;
  }
  /**
   * @returns true if the object has the fields required for a [[NodeEntitySelectionItem]].
   * This function can be used as a TypeScript [type guard](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards).
   */
  isNodeEntitySelection() {
    return this._nodeId !== null && this.isEntitySelection();
  }
  /**
   * @returns true if the object has the fields required for a [[FaceSelectionItem]].
   * This function can be used as a TypeScript [type guard](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards).
   */
  isFaceSelection() {
    return this._nodeId !== null && this._faceEntity !== null;
  }
  /**
   * @returns true if the object has the fields required for a [[LineSelectionItem]].
   * This function can be used as a TypeScript [type guard](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards).
   */
  isLineSelection() {
    return this._nodeId !== null && this._lineEntity !== null;
  }
  /**
   * @returns true if the object has the fields required for a [[PointSelectionItem]].
   * This function can be used as a TypeScript [type guard](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards).
   */
  isPointSelection() {
    return this._nodeId !== null && this._pointEntity !== null;
  }
}
class $_ {
  constructor(t) {
    this.futureItemHash = null, this.pastItemHash = t;
  }
}
class Cd {
  /** @hidden */
  constructor(t, e, i, n, r) {
    this._selectedItemsPruned = /* @__PURE__ */ new Map(), this._selectedItemsFull = /* @__PURE__ */ new Map(), this._selectedNodeCounts = /* @__PURE__ */ new Map(), this._temporalLinks = /* @__PURE__ */ new Map(), this._oldestItemHash = null, this._newestItemHash = null, this._selectedLayers = /* @__PURE__ */ new Set(), this._selectedTypes = /* @__PURE__ */ new Set(), this._nodeSelectionColor = new vt(255, 255, 0), this._nodeSelectionOutlineColor = new vt(255, 255, 0), this._elementSelectionColor = vt.red(), this._elementSelectionOutlineColor = vt.red(), this._nodeHighlightMode = Tr.HighlightAndOutline, this._nodeElementHighlightMode = Tr.HighlightAndOutline, this._highlightNodeSelection = !0, this._highlightFaceElementSelection = !0, this._highlightLineElementSelection = !0, this._highlightPointElementSelection = !0, this._selectParentIfSelected = !0, this._pruneSelectionDescendants = !0, this._ignoreEntityWhenTogglingChildSelection = !0, this._singleEntityToggleMode = !1, this._suppressImplicitRemovalCallback = !1, this._selectionFilter = null, this._incrementalBlacklistedInstanceNodes = /* @__PURE__ */ new Set(), this._viewer = t, this._engine = i, this._model = n, this._modelStructure = r, this._callbackManager = e, this._callbackManager.bind({
      _subtreeLoaded: (o) => {
        for (const l of o)
          this._onSubtreeLoaded(l);
        return Promise.resolve();
      },
      _drawContextCreated: (o) => {
        this._updateHighlightingMode();
      }
    });
  }
  /** * @hidden */
  _init() {
    this._updateHighlightingMode();
    for (const t of this._viewer.views)
      this._engine.setHighlightColorizeCompression(t.id, 0.7);
    this._callbackManager.bind({
      _drawContextCreated: (t) => {
        this._engine.setHighlightColorizeCompression(t, 0.7);
      }
    });
  }
  /**
   * This allows manipulating the selected NodeId.
   * To reset the filter, set it to null.
   * @param selectionFilter function that manipulates the selected NodeId.
   */
  setSelectionFilter(t) {
    this._selectionFilter = t;
  }
  /**
   * @returns [[SelectionFilter]] function or null if none is set.
   */
  getSelectionFilter() {
    return this._selectionFilter;
  }
  /**
   * Enables / disables descendant pruning and clears the current selection set.  When enabled, a parent and child will not be present in the same selection set.  This behavior is enabled by default.
   */
  setPruneSelectionDescendants(t) {
    this._pruneSelectionDescendants = t, this.clear();
  }
  /**
   * Gets whether descendant pruning is enabled.
   * See also: [[setPruneSelectionDescendants]]
   */
  getPruneSelectionDescendants() {
    return this._pruneSelectionDescendants;
  }
  /**
   * Enables / disables automatic parent selection.  When enabled, if a selected part is selected again, its parent will be selected.  This behavior is enabled by default.
   */
  setSelectParentIfSelected(t) {
    this._selectParentIfSelected = t;
  }
  /**
   * Gets whether automatic parent selection is enabled.
   * See also: [[setSelectParentIfSelected]]
   */
  getSelectParentIfSelected() {
    return this._selectParentIfSelected;
  }
  /**
   * Enables / disables ignore entity when toggling child selection mode.
   *
   * When enabled, a [[NodeSelectionItem]] that has a selected ancestor may only be toggled if it does not contain an entity selection.
   * A selection item without an entity selection is usually generated from selecting a node via a model tree control.
   * A selection item containing an entity selection is usually generated as a result of a viewport picking operation.
   *
   * This behavior is enabled by default.
   * See Also: [[toggle]]
   */
  setIgnoreEntityWhenTogglingChildSelection(t) {
    this._ignoreEntityWhenTogglingChildSelection = t;
  }
  /**
   * Gets whether ignore entity when toggling child selection mode is enabled.
   * See also: [[setIgnoreEntityWhenTogglingChildSelection]]
   */
  getIgnoreEntityWhenTogglingChildSelection() {
    return this._ignoreEntityWhenTogglingChildSelection;
  }
  /**
   * Enables / disables single entity toggle mode.
   *
   * When enabled, limits the selection set to containing only one entity selection for each node id.
   * Toggling with an entity selection that has the same node id as a [[NodeSelectionItem]]
   * already in the selection set will remove that item from the selection set.
   *
   * This behavior is disabled by default.
   * See Also: [[toggle]]
   */
  setSingleEntityToggleModeEnabled(t) {
    this._singleEntityToggleMode = t, this.clear();
  }
  /**
   * Gets whether single entity toggle mode is enabled.
   * See also: [[setSingleEntityToggleModeEnabled]]
   */
  getSingleEntityToggleModeEnabled() {
    return this._singleEntityToggleMode;
  }
  /**
   * Sets whether to generate selectionArray callbacks with implicitly removed nodes.
   *
   * For example, consider the case where you have a parent node that has a multiple child nodes.
   * Normally, if the parent begins selected and then a child is removed from the selection set
   * there will be two selectionArray callbacks generated. The first will for the removal of the
   * parent node. The second wil be for the addition of all of it's children except the one that was
   * initially removed.
   *
   * When this behavior is enabled only a single selectionArray callback will be generated for the
   * child node that was removed.
   *
   * This behavior is disabled by default.
   */
  setSuppressImplicitRemovalCallback(t) {
    this._suppressImplicitRemovalCallback = t;
  }
  /**
   * Gets whether implicit removal callbacks are being suppressed
   * See also: [[setSuppressImplicitRemovalCallback]]
   */
  getSuppressImplicitRemovalCallback() {
    return this._suppressImplicitRemovalCallback;
  }
  /**
   * Performs a selection operation from the given position on the canvas. The best candidate entity is selected.
   * This method triggers a selection event.
   * @param point The canvas position to select from.
   * @param config The configuration object used for this picking operation.
   * @param selectionMode The mode to use for this selection.
   * @param view The view to use when projecting the point into the scene.
   * @returns Promise that resolves when this operation has completed.
   */
  async selectFromPoint(t, e, i = xn.Set, n = this._viewer.view) {
    const r = await n.pickFromPoint(t, e);
    this._onSelectionItem(r, i);
  }
  /**
   * Performs a selection operation from the given position on the canvas. All candidate entities are selected.
   * This method triggers a selection event.
   * @param point The canvas position to select from.
   * @param config The configuration object used for this picking operation.
   * @param selectionMode The mode to use for this selection.
   * @param view The view to use when projecting the point into the scene.
   * @returns Promise that resolves when this operation has completed.
   */
  async selectAllFromPoint(t, e, i = xn.Set, n = this._viewer.view) {
    const r = await n.pickAllFromPoint(t, e);
    this._onSelectionItems(r, i);
  }
  /**
   * Performs a selection operation from the given world-space ray. The best candidate entity is selected.
   * This method triggers a selection event.
   * @param ray The world-space ray to perform the selection with.
   * @param config The configuration object used for this picking operation.
   * @param selectionMode The mode to use for this selection.
   * @param view The view to use when projecting the point into the scene.
   * @returns Promise that resolves when this operation has completed.
   */
  async selectFromRay(t, e, i = xn.Set, n = this._viewer.view) {
    const r = await n.pickFromRay(t, e);
    this._onSelectionItem(r, i);
  }
  /**
   * Performs a selection operation from the given world-space ray. All candidate entities are selected.
   * This method triggers a selection event.
   * @param ray The world-space ray to perform the selection with.
   * @param config The configuration object used for this picking operation.
   * @param selectionMode The mode to use for this selection.
   * @param view The view to use when projecting the point into the scene.
   * @returns Promise that resolves when this operation has completed.
   */
  async selectAllFromRay(t, e, i = xn.Set, n = this._viewer.view) {
    const r = await n.pickAllFromRay(t, e);
    this._onSelectionItems(r, i);
  }
  _onSelectionItem(t, e) {
    t.isNodeEntitySelection() ? this._processSelection(t, e) : this._triggerNullSelection();
  }
  _onSelectionItems(t, e) {
    if (e === xn.Set && this.clear(!1), t.length === 0) {
      this._triggerNullSelection();
      return;
    }
    switch (e) {
      case xn.Add:
      case xn.Set:
        this.add(t);
        break;
      case xn.Toggle:
        for (const i of t)
          this.toggle(i);
        break;
      default:
        $r();
    }
  }
  /**
   * Creates a new and active selection context for the provided selection window.
   * @param areaCssMin The minimum coordinate in css pixel space for the selection window.
   * @param areaCssMax The maximum coordinate in css pixel space for the selection window.
   * @param config The configuration object used for this selection operation.
   * @param view The view to use when projecting the point into the scene.
   * @returns The handle for the selection context.
   */
  beginScreenSelectByArea(t, e, i, n = this._viewer.view) {
    return n.beginScreenSelectByArea(t, e, i);
  }
  /**
   * Creates a new and active selection context for the provided selection ray.
   * The ray is created at the supplied ray origin and is cast into the scene.
   * Faces are selected if they lie along the ray.
   * Lines and points are selected if they lie within the ray's box radius.
   *
   * Note: Somewhat confusingly ray drill selection is actually a selection by volume.
   * The provided ray origin and radius are used to create a frustum to preform the selection.
   * This has some consequences. For example, the `SelectionResult`s returned by advancing a
   * ray drill selection will not have selection positions, since they were not selected at
   * a single point.
   * @param rayCssOrigin The coordinate in css pixel space for the selection ray's origin.
   * @param rayCssBoxRadius The radius around the ray in css pixel space used for line and point selection proximity.
   * @param config The configuration object used for this selection operation.
   * @param view The view to use when projecting the point into the scene.
   * @returns The handle for the selection context.
   */
  beginRayDrillSelection(t, e, i, n = this._viewer.view) {
    return n.beginRayDrillSelection(t, e, i);
  }
  /**
   * Creates a new and active selection context for the provided selection volume.
   * The selection volume is a convex polyhedron defined by the bounded intersection of its half-spaces.
   * @param volumePlanes The planes used to define volume. A point p is inside the volume if and only if (plane.determineSide(p) == true) for all supplied planes.
   * @param heuristicOrigin A point used to compute distances against for ordering returned results. This is typically (but not necessarily) the center of the volume.
   * @param config The configuration object used for this selection operation.
   * @returns The handle for the selection context.
   */
  beginConvexPolyhedronSelection(t, e, i) {
    return this._viewer.view.beginConvexPolyhedronSelection(t, e, i);
  }
  /**
   * Creates a new and active selection context for the provided selection sphere.
   * @param sphereCenter The center of the selection sphere.
   * @param sphereRadius The radius of the selection sphere.
   * @param config The configuration object used for this selection operation.
   * @returns The handle for the selection context.
   */
  beginSphereSelection(t, e, i) {
    return this._viewer.view.beginSphereSelection(t, e, i);
  }
  /**
   * Deactivates and destroys the provided selection context.
   * @param handle The selection context to destroy.
   */
  endIncrementalSelection(t) {
    return this._callbackManager.trigger("incrementalSelectionEnd"), this._viewer.view.endIncrementalSelection(t), Promise.resolve();
  }
  /**
   * Adds the next batch of instances selected by the supplied selection
   * context to the selection set.
   *
   * @param handle The handle to an active area selection context.
   * @param predicate An optional function that returns `true` if a given
   * [[NodeSelectionItem]] should be added to the selection set. If
   * `false` is returned, the item will not be added.
   *
   * @returns `true` if there are possibly more items to select and
   * `false` if not.
   */
  async advanceIncrementalSelection(t, e = null) {
    let i = await this._viewer.view.advanceIncrementalSelection(t);
    if (i === null)
      return !1;
    if (e !== null) {
      const n = await Promise.all(i.map(e));
      i = i.filter((r, o) => n[o]);
    }
    return this.add(i), !0;
  }
  isSelected(t) {
    return this.contains(t) ? !0 : t.isNodeSelection() ? this._findAncestor(t) !== null : !1;
  }
  /**
   * Checks whether a node, or its parents, appear in the selection set or not.
   * Note: for the purposes of this function element selections on a node
   * are considered the same as node selection.
   * @param nodeId Node to check for
   * @returns `true` if the node or its parents appear in the selection set. `false` otherwise
   */
  isNodeSelected(t) {
    for (const i of this.getResults())
      if (i.getNodeId() === t)
        return !0;
    const e = _i.create(t);
    return this._findAncestor(e) !== null;
  }
  contains(t) {
    return this._selectedItemsPruned.has(t._hash(this._singleEntityToggleMode));
  }
  /**
   * Checks if the parent of a selection item is in the selection set.
   * @param selectionItem
   * @returns parent selection item, or null if not found
   */
  containsParent(t) {
    return this._findAncestor(t);
  }
  _findAncestor(t) {
    if (this._selectedItemsPruned.size > 0)
      for (; ; ) {
        const e = this._model.getNodeParent(t.getNodeId());
        if (e === null)
          return null;
        t = _i.create(e);
        const i = t._hash(this._singleEntityToggleMode);
        if (this._selectedItemsPruned.has(i))
          return t;
      }
    return null;
  }
  /**
   * Adds all items in a layer to the selection set.
   * @param layerName
   * @param selectionMode
   */
  selectLayer(t, e) {
    e === xn.Set && this.clear();
    const i = [], n = this._model.getLayerIdsFromName(t);
    if (n !== null)
      for (const o of n) {
        const l = this._model.getNodesFromLayer(o, !0);
        if (l !== null)
          for (const h of l)
            i.push(_i.create(h));
      }
    const r = this._selectedLayers.has(t);
    e === xn.Toggle && r ? this.remove(i) : (this.add(i), this._selectedLayers.add(t));
  }
  /**
   * Gets all selected layers.
   */
  getSelectedLayers() {
    const t = [];
    return this._selectedLayers.forEach((e) => {
      t.push(e);
    }), t;
  }
  /**
   * Adds all items with an IFC type to the selection set.
   * @param genericType
   */
  selectType(t, e) {
    e === xn.Set && this.clear();
    const i = [], n = this._model.getNodesByGenericType(t);
    n !== null && n.forEach((o) => {
      i.push(_i.create(o));
    });
    const r = this._selectedTypes.has(t);
    if (e === xn.Toggle && r)
      for (const o of i)
        this.remove(o);
    else
      this.add(i), this._selectedTypes.add(t);
  }
  /**
   * Gets all selected IFC types.
   */
  getSelectedTypes() {
    const t = [];
    return this._selectedTypes.forEach((e) => {
      t.push(e);
    }), t;
  }
  /**
   * Selects a node with the given Id.
   * @param nodeId nodeId of the node to select. Pass null to clear the selection.
   * @returns the selection type of this operation.
   */
  selectNode(t, e = xn.Set) {
    if (t !== null && this._modelStructure.isIdValid(t)) {
      const i = _i.create(t);
      return this._processSelection(i, e), i.getSelectionType();
    } else
      return this._processSelection(null, e), On.None;
  }
  _triggerNullSelection() {
    this._callbackManager.trigger("selectionArray", [], !1);
  }
  _isInAxisOverlay(t) {
    const i = t.getFaceEntity();
    if (i)
      return i.overlayIndex() === 1;
    const n = t.getLineEntity();
    if (n)
      return n.overlayIndex() === 1;
    const r = t.getPointEntity();
    return r ? r.overlayIndex() === 1 : !1;
  }
  _getNodeCounts(t) {
    const e = t.getNodeId();
    let i = this._selectedNodeCounts.get(e);
    return i || (i = new G_(), this._selectedNodeCounts.set(e, i)), i;
  }
  _addToFull(t, e) {
    for (; this._selectedItemsFull.set(e, t); ) {
      const i = this._model.getNodeParent(t.getNodeId());
      if (i === null)
        return;
      t = _i.create(i), e = t._hash(this._singleEntityToggleMode);
    }
  }
  _addItems(t, e) {
    const i = t.length;
    if (i === 0)
      return;
    this._callbackManager.trigger("incrementalSelectionBatchBegin");
    const n = [];
    for (let r = 0; r < i; ++r) {
      const o = this._filterItem(t[r]);
      if (o !== null && this._addImpl(o, o._hash(this._singleEntityToggleMode))) {
        const l = new Fr(o);
        n.push(l);
      }
    }
    n.length === 0 ? this._triggerNullSelection() : e || this._callbackManager.trigger("selectionArray", n, !1), this._callbackManager.trigger("incrementalSelectionBatchEnd");
  }
  _addItem(t, e) {
    const i = this._filterItem(t);
    if (i !== null && this._addImpl(i, i._hash(this._singleEntityToggleMode))) {
      const n = new Fr(i);
      e || this._callbackManager.trigger("selectionArray", [n], !1);
    } else
      this._triggerNullSelection();
  }
  /**
   * Manually adds an item or array of items to the selection set.
   * Triggers a selection event.
   * @param itemOrItems A selectionItem or selectionItem array that will be added to the current selection set.
   * @param suppressCallback Optional boolean param to suppress the selectionArray callbacks calls to this generate.
   */
  add(t, e = !1) {
    if (t === null) {
      this._triggerNullSelection();
      return;
    }
    Array.isArray(t) ? this._addItems(t, e) : this._addItem(t, e);
  }
  _filterItem(t) {
    if (this._selectionFilter === null)
      return t;
    const e = t.getNodeId(), i = this._selectionFilter(e, this._model);
    return i === e ? t : i === null ? null : _i.create(i);
  }
  _addImpl(t, e) {
    if (t.getSelectionType() === On.None)
      return !1;
    if (this._isInAxisOverlay(t))
      return !0;
    if (this._selectedItemsPruned.has(e))
      return !1;
    if (this._pruneSelectionDescendants) {
      if (this._findAncestor(t) !== null)
        return !1;
      this._removeDescendants(t);
    }
    this._selectedItemsPruned.set(e, t), this._addToFull(t, e), this._getNodeCounts(t).update(t, so.Inc);
    const i = this._newestItemHash;
    if (this._newestItemHash = e, this._oldestItemHash || (this._oldestItemHash = e), i !== null) {
      const r = this._temporalLinks.get(i);
      r && (r.futureItemHash = e);
    }
    const n = new $_(i);
    if (this._temporalLinks.set(e, n), this._updateItemHighlight(t, !0, !0), this._modelStructure.getType(t.getNodeId()) === Le.Pmi) {
      const r = this._modelStructure.getPmiTopologyReferences(t.getNodeId());
      if (r !== null)
        for (const o of r) {
          const l = o.body.getRuntimeId(), h = o.faceIds;
          for (const d of h)
            this._model.setNodeFaceHighlighted(l, d, !0);
          const u = o.edgeIds;
          for (const d of u)
            this._model.setNodeLineHighlighted(l, d, !0);
        }
    }
    return !0;
  }
  _removeUpdateLayers(t) {
    if (this._selectedLayers.size > 0) {
      const e = t.getNodeId();
      if (e !== null) {
        const i = this._model.getNodeLayerId(e);
        if (i !== null) {
          const n = this._model.getLayerName(i);
          n !== null && this._selectedLayers.delete(n);
        }
      }
    }
  }
  _removeUpdateTypes(t) {
    if (this._selectedTypes.size > 0) {
      const e = t.getNodeId();
      if (e !== null) {
        const i = this._model.getNodeGenericType(e);
        i !== null && this._selectedTypes.delete(i);
      }
    }
  }
  _removeFromFull(t, e) {
    if (this._removeUpdateLayers(t), this._removeUpdateTypes(t), this._selectedItemsFull.delete(e)) {
      const i = this._model.getNodeChildren(t.getNodeId());
      for (const n of i) {
        const r = _i.create(n);
        this._removeFromFull(r, r._hash(this._singleEntityToggleMode));
      }
    }
  }
  _removeItems(t, e) {
    const i = [];
    t.forEach((n) => {
      this._removeImpl(n, n._hash(this._singleEntityToggleMode)) && i.push(new Fr(n));
    }), e || this._callbackManager.trigger("selectionArray", i, !0);
  }
  _removeItem(t, e) {
    if (this._removeImpl(t, t._hash(this._singleEntityToggleMode))) {
      const i = new Fr(t);
      e || this._callbackManager.trigger("selectionArray", [i], !0);
    }
  }
  /**
   * Manually removes an item or an array of items from the selection set.
   * Triggers a selection event.
   * @param itemOrItems A selectionItem or an array of selection items that will be removed from the current selection set.
   * @param suppressCallback Optional boolean param to suppress the selectionArray callbacks calls to this generate.
   */
  remove(t, e = !1) {
    Array.isArray(t) ? this._removeItems(t, e) : this._removeItem(t, e);
  }
  /** hidden */
  _removeImpl(t, e) {
    if (this._singleEntityToggleMode) {
      const l = this._selectedItemsPruned.get(e);
      l && (t = l);
    }
    if (!this._selectedItemsPruned.delete(e))
      return !1;
    this._removeFromFull(t, e);
    const i = this._getNodeCounts(t);
    i.update(t, so.Dec);
    const n = this._temporalLinks.get(e);
    if (n !== void 0) {
      if (this._temporalLinks.delete(e), n.pastItemHash !== null) {
        const l = this._temporalLinks.get(n.pastItemHash);
        l && (l.futureItemHash = n.futureItemHash);
      }
      if (n.futureItemHash !== null) {
        const l = this._temporalLinks.get(n.futureItemHash);
        l && (l.pastItemHash = n.pastItemHash);
      }
      this._oldestItemHash === e && (this._oldestItemHash = n.futureItemHash), this._newestItemHash === e && (this._newestItemHash = n.pastItemHash);
    }
    let r = !0;
    const o = !1;
    if (i.sum() === 0) {
      r = !1;
      const l = t.getNodeId();
      this._selectedNodeCounts.delete(l);
    }
    return this._updateItemHighlight(t, r, o), !0;
  }
  static _selectionItemIsFromModelBrowser(t) {
    return t.getFaceEntity() === null && t.getLineEntity() === null && t.getPointEntity() === null;
  }
  /**
   * Manually adds or removes an item from the selection set.
   * Triggers a selection event.
   * @param selectionItem A selectionItem that will be added or removed from the selection set.
   */
  toggle(t) {
    const e = this._filterItem(t);
    if (e === null)
      return;
    const i = this._findAncestor(e), n = e._hash(this._singleEntityToggleMode);
    if (i !== null) {
      if (Cd._selectionItemIsFromModelBrowser(t) ? this._removeImplicit(t, i, this._suppressImplicitRemovalCallback) : this._ignoreEntityWhenTogglingChildSelection || this._removeImplicit(
        _i.create(e.getNodeId()),
        i,
        this._suppressImplicitRemovalCallback
      ), this._suppressImplicitRemovalCallback) {
        const r = new Fr(e);
        this._callbackManager.trigger("selectionArray", [r], !0);
      }
    } else if (this._selectedItemsPruned.has(n)) {
      if (this._removeImpl(e, n)) {
        const r = new Fr(t);
        this._callbackManager.trigger("selectionArray", [r], !0);
      }
    } else if (e !== null && this._addImpl(e, n)) {
      const r = new Fr(e);
      this._callbackManager.trigger("selectionArray", [r], !1);
    }
  }
  /**
   * Manually removes all currently selected items (if any) from the selection set and adds the supplied item.
   * Triggers a selection event.
   * @param selectionItem A selectionItem that will become the new selection item.
   */
  set(t) {
    this.clear(!1), this.add(t);
  }
  /**
   * Gets all current selection items.
   * @returns array of all selection items.
   */
  getResults() {
    const t = [];
    return this.each((e) => {
      t.push(e);
    }), t;
  }
  /**
   * Gets a selection at the specified index. The first selected item will be at index 0.
   * @param index index of selection item to get
   * @returns the selection result at the given index.
   */
  getResult(t) {
    const e = this.size();
    if (t < 0 || t >= e)
      return null;
    const i = e - t - 1;
    return t <= i ? this._getItemFromOldest(t) : this._getItemFromNewest(i);
  }
  _getItemFromOldest(t) {
    let e = this._oldestItemHash;
    for (; e; ) {
      if (t-- === 0)
        return this._selectedItemsPruned.get(e) || null;
      e = this._temporalLinks.get(e).futureItemHash;
    }
    return null;
  }
  _getItemFromNewest(t) {
    let e = this._newestItemHash;
    for (; e; ) {
      if (t-- === 0)
        return this._selectedItemsPruned.get(e) || null;
      e = this._temporalLinks.get(e).pastItemHash;
    }
    return null;
  }
  /**
   * Gets the least recent selection item.
   * @returns the least recently selected item (if any).
   */
  getFirst() {
    return this._oldestItemHash !== null && this._selectedItemsPruned.get(this._oldestItemHash) || null;
  }
  /**
   * Gets the most recent selection item.
   * @returns the most recently selected item (if any).
   */
  getLast() {
    return this._newestItemHash !== null && this._selectedItemsPruned.get(this._newestItemHash) || null;
  }
  /**
   * Gets the number of selection items.
   * @returns the number of selected items.
   */
  size() {
    return this._selectedItemsPruned.size;
  }
  /**
   * Iterates over all selection items.
   * The function passed in will be called once for every selection item and will receive the item as its parameter.
   * @param func a function to be called for every selection item.
   */
  each(t) {
    let e = this._oldestItemHash;
    for (; e; ) {
      const i = this._selectedItemsPruned.get(e);
      t(i), e = this._temporalLinks.get(e).futureItemHash;
    }
  }
  /**
   * Removes all items from the selection set.
   * @param triggerCallback triggers a null selection callback when true.
   */
  clear(t = !0) {
    this._selectedLayers.clear(), this._selectedTypes.clear(), this._clearHighlight(), this._selectedItemsPruned.clear(), this._selectedItemsFull.clear(), this._selectedNodeCounts.clear(), this._temporalLinks.clear(), this._oldestItemHash = null, this._newestItemHash = null, t && this._triggerNullSelection();
  }
  /**
   * Sets the color to be used when selecting nodes.
   * This method should not be called before the sceneReady callback has been triggered.
   * @param color the color to apply to the selected node.
   */
  setNodeSelectionColor(t) {
    return this._setNodeSelectionColor(t), Promise.resolve();
  }
  _setNodeSelectionColor(t) {
    this._nodeSelectionColor.assign(t), this._updateHighlightingMode();
  }
  /**
   * Gets the color to be used when selecting nodes.
   * @returns the color that is applied to a selected node.
   */
  getNodeSelectionColor() {
    return this._nodeSelectionColor.copy();
  }
  /**
   * Sets color for the node selection outline.
   * This method should not be called before the sceneReady callback has been triggered.
   * @param color the color to apply to the node selection outline.
   */
  setNodeSelectionOutlineColor(t) {
    return this._setNodeSelectionOutlineColor(t), Promise.resolve();
  }
  _setNodeSelectionOutlineColor(t) {
    this._nodeSelectionOutlineColor.assign(t), this._updateHighlightingMode();
  }
  /**
   * Gets the color to be used for outlining the node selection.
   * @returns the color for node selection outline.
   */
  getNodeSelectionOutlineColor() {
    return this._nodeSelectionOutlineColor.copy();
  }
  /**
   * Sets the color to use for node element selection.
   * This method should not be called before the sceneReady callback has been triggered.
   * @param color the color to apply to selected node elements.
   */
  setNodeElementSelectionColor(t) {
    return this._setNodeElementSelectionColor(t), Promise.resolve();
  }
  _setNodeElementSelectionColor(t) {
    this._elementSelectionColor.assign(t), this._updateHighlightingMode();
  }
  /**
   * Gets the color to use for face and line selection.
   * @returns the color used for face and line selection.
   */
  getNodeElementSelectionColor() {
    return this._elementSelectionColor.copy();
  }
  /**
   * Gets the color to use for outlining node element selection.
   * This method should not be called before the sceneReady callback has been triggered.
   * @param color the color used for outlining face and line selection.
   */
  setNodeElementSelectionOutlineColor(t) {
    return this._setNodeElementSelectionOutlineColor(t), Promise.resolve();
  }
  _setNodeElementSelectionOutlineColor(t) {
    this._elementSelectionOutlineColor.assign(t), this._updateHighlightingMode();
  }
  /**
   * Gets the color to use for outlining face and line selection.
   * @returns color the color used for outlining face and line selection.
   */
  getNodeElementSelectionOutlineColor() {
    return this._elementSelectionOutlineColor.copy();
  }
  /**
   * Gets whether face elements will be highlighted on selection.
   * @returns boolean the current value for face element selection highlighting.
   */
  getHighlightFaceElementSelection() {
    return this._highlightFaceElementSelection;
  }
  /**
   * Sets whether face elements should be highlighted when a selection occurs.
   * By default the system will automatically highlight face elements associated with a selection item.
   * @param highlightFaceElementSelection value indicating whether selected face elements should be highlighted.
   */
  setHighlightFaceElementSelection(t) {
    return this._highlightFaceElementSelection = t, this._updateHighlight(), Promise.resolve();
  }
  /**
   * Sets the highlighting mode for selected nodes. The default behavior is to highlight the node and render an overlay outline.
   * This method should not be called before the sceneReady callback has been triggered.
   * @param highlightMode the highlighting mode that will be applied to selected nodes.
   */
  setNodeSelectionHighlightMode(t) {
    return this._setNodeSelectionHighlightMode(t), Promise.resolve();
  }
  _setNodeSelectionHighlightMode(t) {
    this._nodeHighlightMode = t, this._updateHighlightingMode();
  }
  /**
   * Gets the highlighting mode for selected nodes.
   * @returns the current
   */
  getNodeSelectionHighlightMode() {
    return this._nodeHighlightMode;
  }
  /**
   * Sets the highlighting mode for selected node elements.
   * The default behavior is to highlight the node element and render an overlay outline.
   * This method should not be called before the sceneReady callback has been triggered.
   * @param highlightMode the highlighting mode that will be applied to selected nodes.
   */
  setNodeElementSelectionHighlightMode(t) {
    return this._setNodeElementSelectionHighlightMode(t), Promise.resolve();
  }
  _setNodeElementSelectionHighlightMode(t) {
    this._nodeElementHighlightMode = t, this._updateHighlightingMode();
  }
  getNodeElementSelectionHighlightMode() {
    return this._nodeElementHighlightMode;
  }
  /**
   * Sets whether nodes should be highlighted when a selection occurs.
   * By default, the system will automatically highlight the node associated with a selection item.
   * @param highlightNodeSelection value indicating whether selected nodes should be highlighted.
   */
  setHighlightNodeSelection(t) {
    return this._highlightNodeSelection = t, this._updateHighlight(), Promise.resolve();
  }
  /**
   * Gets whether nodes will be highlighted on selection.
   * @returns the current value for node selection highlighting.
   */
  getHighlightNodeSelection() {
    return this._highlightNodeSelection;
  }
  /**
   * Gets whether line elements will be highlighted on selection.
   * @returns boolean the current value for line element selection highlighting.
   */
  getHighlightLineElementSelection() {
    return this._highlightLineElementSelection;
  }
  /**
   * Gets whether point elements will be highlighted on selection.
   * @returns boolean the current value for point element selection highlighting.
   */
  getHighlightPointElementSelection() {
    return this._highlightPointElementSelection;
  }
  /**
   * Sets whether line elements should be highlighted when a selection occurs.
   * By default the system will automatically highlight line elements associated with a selection item.
   * @param highlightLineElementSelection value indicating whether selected line elements should be highlighted.
   */
  setHighlightLineElementSelection(t) {
    return this._highlightLineElementSelection = t, this._updateHighlight(), Promise.resolve();
  }
  /**
   * Sets whether point elements should be highlighted when a selection occurs.
   * By default the system will automatically highlight point elements associated with a selection item.
   * @param highlightPointElementSelection value indicating whether selected point elements should be highlighted.
   */
  setHighlightPointElementSelection(t) {
    return this._highlightPointElementSelection = t, this._updateHighlight(), Promise.resolve();
  }
  /**
   * Sets the pick tolerance in pixels for line and point picking.
   * If a line or point is within this pixel tolerance of the click point,
   * it will be prioritized over the face at the click position.
   *
   * The default value is 20.
   * @param Pick Tolerance value in pixels
   */
  setPickTolerance(t) {
    this._engine.setPickTolerance(t);
  }
  /**
   * Gets the pick tolerance in pixels for line and point picking.
   *
   * The default value is 20.
   * @returns number Pick tolerance value in pixels
   */
  getPickTolerance() {
    return this._engine.getPickTolerance();
  }
  /**
   * Exports selection objects so that they may be loaded back into the the system at a later time using loadSelectionData.
   * @returns exported selection data.
   */
  exportSelectionData() {
    const t = [], e = this.getResults();
    for (const i of e)
      t.push(i.toJson());
    return t;
  }
  /**
   * Loads serialized selection items exported using [[exportSelectionData]] back into the [[SelectionManager]].
   * The current selection will be cleared. A selection event will be triggered for each loaded item.
   * This method should not be called before the [[CallbackMap.modelStructureReady]] callback has been triggered.
   * @param data data to be imported in the form of a JavaScript object or JSON string
   */
  loadSelectionData(t) {
    if (this.clear(!1), typeof t == "string" && (t = JSON.parse(t), !Array.isArray(t)))
      throw new Rs("Expected JSON depicting an Array.");
    const e = [];
    for (const i of t) {
      const n = _i._fromJson(i);
      n.isNodeSelection() && e.push(n);
    }
    this.add(e);
  }
  _pathToParent(t, e) {
    const i = [];
    for (; !t.equals(e); ) {
      i.push(t);
      const n = this._model.getNodeParent(t.getNodeId());
      if (n === null)
        break;
      t = _i.create(n);
    }
    return i;
  }
  _removeImplicit(t, e, i) {
    const n = this._pathToParent(t, e), r = (u) => {
      for (const d of n)
        if (u.equals(d))
          return !0;
      return !1;
    };
    let o = e;
    const l = [t], h = [];
    for (; n.length > 0; ) {
      l.push(o);
      const u = this._model.getNodeChildren(o.getNodeId());
      for (const d of u) {
        const g = _i.create(d);
        r(g) || h.push(g);
      }
      o = n.pop();
    }
    console.assert(t === o), this.remove(l, i), this.add(h, i);
  }
  _removeDescendants(t) {
    const e = this._model.getNodeChildren(t.getNodeId());
    for (const i of e) {
      const n = _i.create(i);
      this._removeDescendantsRecursive(n);
    }
  }
  _removeDescendantsRecursive(t) {
    const e = t._hash(this._singleEntityToggleMode);
    if (this._selectedItemsFull.delete(e)) {
      this._removeImpl(t, e);
      const i = this._model.getNodeChildren(t.getNodeId());
      for (const n of i) {
        const r = _i.create(n);
        this._removeDescendantsRecursive(r);
      }
    }
  }
  _processSelection(t, e) {
    switch (e) {
      case xn.Add:
        this.add(t);
        break;
      case xn.Set:
        this.set(t);
        break;
      case xn.Toggle:
        t !== null && this.toggle(t);
        break;
    }
  }
  _clearHighlight() {
    this._selectedItemsPruned.size > 0 && this._engine.clearHighlight();
  }
  _updateHighlight() {
    this._clearHighlight(), this._selectedItemsPruned.forEach((t) => {
      t && this._updateItemHighlight(t, !0, !0);
    }), this._highlightNodeSelection && this._model.setNodesHighlighted([], !0);
  }
  _updateItemHighlight(t, e, i) {
    const n = t.getNodeId();
    if (this._highlightNodeSelection && this._model.setNodesHighlighted([n], e), this._model.getNodeType(n) !== Le.Pmi) {
      const r = t.getFaceEntity();
      this._highlightFaceElementSelection && r !== null && !r.isCappingGeometry() && this._model.setNodeFaceHighlighted(n, r.getCadFaceIndex(), i);
      const o = t.getLineEntity();
      this._highlightLineElementSelection && o !== null && !o.isCappingGeometry() && this._model.setNodeLineHighlighted(n, o.getLineId(), i);
      const l = t.getPointEntity();
      this._highlightPointElementSelection && l !== null && this._model.setNodePointHighlighted(n, l.getPointId(), i);
    }
  }
  _updateHighlightingMode() {
    for (const t of this._viewer.views) {
      switch (this._nodeHighlightMode) {
        case Tr.HighlightOnly:
          this._engine.setNodeHighlightColor(t.id, this._nodeSelectionColor, null);
          break;
        case Tr.OutlineOnly:
          this._engine.setNodeHighlightColor(t.id, null, this._nodeSelectionOutlineColor);
          break;
        case Tr.HighlightAndOutline:
          this._engine.setNodeHighlightColor(
            t.id,
            this._nodeSelectionColor,
            this._nodeSelectionOutlineColor
          );
          break;
      }
      switch (this._nodeElementHighlightMode) {
        case Tr.HighlightOnly:
          this._engine.setElementHighlightColor(t.id, this._elementSelectionColor, null);
          break;
        case Tr.OutlineOnly: {
          this._nodeHighlightMode === Tr.OutlineOnly ? this._engine.setElementHighlightColor(
            t.id,
            null,
            this._elementSelectionOutlineColor
          ) : this._engine.setElementHighlightColor(
            t.id,
            this._nodeSelectionColor,
            this._elementSelectionOutlineColor
          );
          break;
        }
        case Tr.HighlightAndOutline:
          this._engine.setElementHighlightColor(
            t.id,
            this._elementSelectionColor,
            this._elementSelectionOutlineColor
          );
          break;
      }
    }
  }
  _onSubtreeLoaded(t) {
    const e = _i.create(t);
    if (this.isSelected(e))
      return this._updateItemHighlight(e, !0, !0);
  }
}
const e1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CompositeSelectionItem: rd,
  FaceEntity: Rh,
  IncrementalSelectionId: xc,
  LineEntity: Lh,
  NodeCounts: G_,
  Op: so,
  PointEntity: Fh,
  SelectionItem: _i,
  SelectionManager: Cd,
  TemporalLink: $_,
  ifcSelectionFilter: jf
}, Symbol.toStringTag, { value: "Module" }));
class Fr {
  /**
   * Creates a new NodeSelectionEvent
   * @hidden
   */
  constructor(t) {
    this._selection = t;
  }
  /**
   * Gets the result of the selection operator.
   * @returns the result of the selection
   */
  getType() {
    return this._selection ? this._selection.getSelectionType() : On.None;
  }
  /**
   * Gets the selection object.
   * @returns Selection object containing detailed information about the selection
   */
  getSelection() {
    return this._selection;
  }
  /**
   * Creates a no-selection event.
   * @returns Selection event with result set to none.
   * @hidden
   */
  static _createNull() {
    return new Fr(_i.create());
  }
}
class Ou extends Id {
  /**
   * Touch Event class
   * @param id unique identifier for this touch
   * @param positionX X window position of the touch
   * @param positionY Y window position of the touch
   * @hidden
   */
  constructor(t, e, i, n, r, o) {
    super(o), this._id = t, this._position = new K(e, i), this._buttons = n, this._inputType = r;
  }
  /**
   * gets the id this event
   * @returns the unique identifier for this touch
   */
  getId() {
    return this._id;
  }
  /**
   * gets the window position of the mouse pointer for this event
   * @returns the mouse position for this event
   */
  getPosition() {
    return this._position;
  }
  /**
   * gets the event type
   * @returns the type of touch event
   */
  getEventType() {
    return this._inputType;
  }
  /**
   * gets the mouse buttons currently pressed with this event
   * @returns the mouse buttons currently pressed for this event
   */
  getButtons() {
    return this._buttons;
  }
}
function Gb(s) {
  switch (s) {
    case ae.MouseDown:
      return !0;
    case ae.MouseMove:
      return !0;
    case ae.MouseUp:
      return !0;
    case ae.Mousewheel:
      return !0;
    case ae.TouchStart:
      return !1;
    case ae.TouchMove:
      return !1;
    case ae.TouchEnd:
      return !1;
    case ae.KeyDown:
      return !1;
    case ae.KeyUp:
      return !1;
    case ae.ViewOrientationChange:
      return !1;
    default:
      return !1;
  }
}
const i1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  InputEvent: Id,
  KeyInputEvent: Uf,
  MouseInputEvent: Wr,
  MouseInputEventBase: Pg,
  MouseWheelInputEvent: W_,
  NodeSelectionEvent: Fr,
  TouchInputEvent: Ou,
  isMouseEventType: Gb
}, Symbol.toStringTag, { value: "Module" }));
class q_ {
  constructor(t, e) {
    this._markupItems = /* @__PURE__ */ new Map(), this._activeViews = /* @__PURE__ */ new Map(), this._selectedMarkup = null, this._pendingUpdateHandleTimer = new Xo(), this._viewToUpdate = /* @__PURE__ */ new Set(), this._pickTolerance = 0, this._callbackManager = t, this._markupRenderer = e;
  }
  shutdown() {
    this._activeViews.forEach((t, e) => {
      this.setActiveView(e, t);
    }), this._markupItems.forEach((t, e) => {
      t.forEach((i) => {
        i.remove(e);
      });
    }), this._markupItems.clear();
  }
  _updateLater(t, e) {
    this._viewToUpdate.add(t), this._pendingUpdateHandleTimer.isIdle(Dn.BeforeAction) && this._pendingUpdateHandleTimer.set(0, () => {
      this.update();
    }), e !== null && this._pendingUpdateHandleTimer.waitForIdle(Dn.AfterAction).then(() => {
      e.resolve();
    });
  }
  updateLater(t) {
    this._updateLater(t, null);
  }
  _updateAllViews() {
    this._activeViews.forEach((t, e) => {
      this._viewToUpdate.add(e);
    }), this._markupItems.forEach((t, e) => {
      this._viewToUpdate.add(e);
    }), this.update();
  }
  update() {
    this._pendingUpdateHandleTimer.clear(), this._viewToUpdate.forEach((t) => {
      this.renderMarkup(t), this.renderActiveViewMarkup(t);
    }), this._viewToUpdate.clear();
  }
  registerMarkupItem(t, e) {
    let i = this._markupItems.get(e);
    i || (i = /* @__PURE__ */ new Map(), this._markupItems.set(e, i));
    const n = Ss();
    return i.set(n, t), n;
  }
  unregisterMarkupItem(t, e) {
    let i = this._markupItems.get(e);
    if (!i)
      throw new Error("Unable to remove markup from unknown view");
    const n = i.get(t);
    n && (n.remove && n.remove(e), i.delete(t));
  }
  getActiveView(t) {
    const e = this._activeViews.get(t);
    return e !== void 0 ? e : null;
  }
  getViews(t) {
    const e = [];
    return this._activeViews.forEach((i, n) => {
      t === i && e.push(n);
    }), e;
  }
  async setActiveView(t, e) {
    this._selectedMarkup && (this._selectedMarkup.onDeselect(), this._selectedMarkup = null, this._updateAllViews());
    const i = this.getActiveView(t);
    e ? this._activeViews.set(t, e) : this._activeViews.delete(t);
    const n = wi();
    if (this._updateLater(t, n), i !== null && i !== e) {
      const r = i.getMarkup();
      for (const o of r)
        o.remove(t);
      await n, this._callbackManager.trigger("viewDeactivated", i);
    } else
      await this._pendingUpdateHandleTimer.waitForIdle(Dn.AfterAction);
  }
  markupViewDeleted(t) {
    const e = this.getViews(t);
    for (let i of e)
      this.setActiveView(i, null);
  }
  viewDeleted(t) {
    this._activeViews.delete(t);
    const e = this._markupItems.get(t);
    e && (e.forEach((i) => {
      i.remove(t);
    }), this._markupItems.delete(t));
  }
  renderMarkup(t) {
    this._markupRenderer._setCanvas(t.domElements.getMarkupSvgElement()), this._markupRenderer._clear();
    const e = this._markupItems.get(t);
    e && (e.forEach((i) => {
      i.draw(this._markupRenderer, t);
    }), this._markupRenderer._finalize());
  }
  renderActiveViewMarkup(t) {
    this._markupRenderer._setCanvas(t.domElements.getRedlineSvgElement()), this._markupRenderer._clear();
    const e = this.getActiveView(t);
    if (!e)
      return;
    const i = e.getMarkup();
    for (const n of i)
      n.draw(this._markupRenderer, t);
    this._markupRenderer._finalize();
  }
  getPickTolerance() {
    return this._pickTolerance;
  }
  setPickTolerance(t) {
    this._pickTolerance = t;
  }
  pick(t, e) {
    const i = this.getActiveView(e);
    if (i) {
      const o = i.getMarkup();
      for (const l of o)
        if (l.hitWithTolerance(t, e, this._pickTolerance) || l.hit(t, e))
          return l;
    }
    const n = this._markupItems.get(e);
    if (!n)
      return null;
    let r = null;
    return n.forEach((o) => {
      r === null && (o.hitWithTolerance(t, e, this._pickTolerance) || o.hit(t, e)) && (r = o);
    }), r;
  }
  select(t, e) {
    this._selectedMarkup && t !== this._selectedMarkup && this._selectedMarkup.onDeselect(), this._selectedMarkup = t, this._selectedMarkup && this._selectedMarkup.onSelect(e), this._updateAllViews();
  }
  getSelected() {
    return this._selectedMarkup;
  }
}
class K_ {
  constructor(t, e) {
    this.markupView = t, this.itemResults = e;
  }
}
class uh {
  /** @hidden */
  constructor(t, e, i, n, r, o = null) {
    this._lineVisibility = !0, this._faceVisibility = !0, this._markupItems = /* @__PURE__ */ new Set(), this._sheetId = null, this._colorMap = /* @__PURE__ */ new Map(), this._snapshotImage = null, this._defaultVisibility = !0, this._visibilityExceptions = /* @__PURE__ */ new Set(), this._uniqueId = t, this._camera = i, this._name = e, this._explodeMagnitude = n, this._cuttingPlaneData = r, this._sheetId = o;
  }
  /**
   * Gets the camera of this view
   * @returns the camera of this view
   */
  getCamera() {
    return this._camera;
  }
  /**
   * Gets the sheet id for this view
   * @returns the id of the sheet for this view. If no view was active at the time of creation this function will return null.
   */
  getSheetId() {
    return this._sheetId;
  }
  /**
   * Gets the unique identifier of this view
   * @returns unique identifier of this view
   */
  getUniqueId() {
    return this._uniqueId;
  }
  /**
   * Gets the name of this view
   * @returns name of this view
   */
  getName() {
    return this._name;
  }
  /**
   * Sets the name for this view
   * @param name name to set
   */
  setName(t) {
    this._name = t;
  }
  /**
   * Gets line visibility setting for this view
   * @returns line visibility setting for this view
   */
  getLineVisibility() {
    return this._lineVisibility;
  }
  /**
   * Sets line visibility for this view
   * @param lineVisibility line visibility setting for this view
   */
  setLineVisibility(t) {
    this._lineVisibility = t;
  }
  /**
   * Gets face visibility setting for this view
   * @returns face visibility setting for this view
   */
  getFaceVisibility() {
    return this._faceVisibility;
  }
  /**
   * Sets face visibility for this view
   * @param faceVisibility face visibility setting for this view
   */
  setFaceVisibility(t) {
    this._faceVisibility = t;
  }
  /**
   * Adds a markup item to this view
   * @param markupItem the markup to be added to this view.
   */
  addMarkupItem(t) {
    this._markupItems.add(t);
  }
  /**
   * Gets an array of markup items associated with this view
   * @returns {boolean} face visibility setting for this view
   */
  getMarkup() {
    return ao(this._markupItems);
  }
  /**
   * Removes a markup item from the view
   * @param markupItem the markup to be removed from this view.
   * @returns result of the removal operation
   */
  removeMarkup(t) {
    return t.remove(null), this._markupItems.delete(t);
  }
  /**
   * @returns a JSON object with the cutting plane data associated with this view
   */
  getCuttingPlaneData() {
    return this._cuttingPlaneData;
  }
  /**
   * Takes a JSON cutting plane data object and associates it with this view
   * @param cuttingPlaneData
   */
  setCuttingPlaneData(t) {
    this._cuttingPlaneData = t;
  }
  /**
   * @returns the explode value associated with this view
   */
  getExplodeMagnitude() {
    return this._explodeMagnitude;
  }
  /**
   * Takes an explode magnitude and associates it with this view
   */
  setExplodeMagnitude(t) {
    this._explodeMagnitude = t;
  }
  /**
   * @returns A color map associating NodeIds to Colors.
   */
  getColorMap() {
    return this._colorMap;
  }
  /**
   * Takes a color map associating NodeIds to Colors and associates it with this view.
   * @param colorMap
   */
  setColorMap(t) {
    this._colorMap = t;
  }
  getDefaultVisibility() {
    return this._defaultVisibility;
  }
  setDefaultVisibility(t) {
    this._defaultVisibility = t;
  }
  getVisibilityExceptions() {
    return this._visibilityExceptions;
  }
  setVisibilityExceptions(t) {
    this._visibilityExceptions = t;
  }
  getSnapshotImage() {
    return this._snapshotImage;
  }
  setSnapshotImage(t) {
    this._snapshotImage = t;
  }
  _handleLoadMarkupItem(t) {
    return t instanceof go ? (this.addMarkupItem(t), !0) : !1;
  }
  /** @hidden */
  static async _fromJson(t, e) {
    const i = t, n = Cn.fromJson(i.camera);
    let r;
    if (i.hasOwnProperty("sheetId") && i.sheetId) {
      const y = parseInt(t.sheetId, 10);
      isNaN(y) || (r = y);
    }
    const o = new uh(
      i.uniqueId,
      i.name,
      n,
      i.explodeMagnitude,
      i.cuttingData,
      r
    );
    if (o.setLineVisibility(i.lineVisibility), o.setFaceVisibility(i.faceVisibility), i.defaultVisibility !== void 0 && i.visibilityExceptions !== void 0) {
      o.setDefaultVisibility(i.defaultVisibility);
      const y = /* @__PURE__ */ new Set();
      i.visibilityExceptions.forEach((m) => {
        y.add(m);
      }), o.setVisibilityExceptions(y);
    }
    const l = /* @__PURE__ */ new Map(), h = i.colors;
    if (Array.isArray(h))
      for (const y of h) {
        const m = y[0], x = vt.fromJson(y[1]);
        l.set(m, x);
      }
    o.setColorMap(l);
    const u = [];
    console.assert(Array.isArray(i.markup));
    for (const y of i.markup) {
      const m = hg(y.className);
      if (m) {
        const x = m(y, e);
        x instanceof Promise ? u.push(
          x.then((b) => o._handleLoadMarkupItem(b))
        ) : u.push(Promise.resolve(o._handleLoadMarkupItem(x)));
      }
    }
    const d = i.imageSrc;
    if (d !== void 0 && d.length > 0) {
      const y = new Image();
      y.src = d, o.setSnapshotImage(y);
    }
    const g = await Promise.all(u);
    return new K_(o, g);
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    const t = {
      uniqueId: this._uniqueId,
      name: this._name,
      camera: this._camera.toJson(),
      cuttingData: this._cuttingPlaneData,
      explodeMagnitude: this._explodeMagnitude,
      lineVisibility: this._lineVisibility,
      faceVisibility: this._faceVisibility,
      markup: [],
      sheetId: this._sheetId,
      defaultVisibility: this._defaultVisibility,
      visibilityExceptions: [],
      colors: [],
      imageSrc: ""
    };
    return this._markupItems.forEach((e) => {
      const i = e.toJson();
      i.className = e.getClassName(), t.markup.push(i);
    }), this._visibilityExceptions.forEach((e) => {
      t.visibilityExceptions.push(e);
    }), this._colorMap.forEach((e, i) => {
      t.colors.push([i, e.toJson()]);
    }), this._snapshotImage !== null && (t.imageSrc = this._snapshotImage.src), t;
  }
}
const $b = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  RedlineItem: Ll
}, Symbol.toStringTag, { value: "Module" }));
class Qn extends Dh {
  /**
   * Creates a new Line Shape
   * @param p1 Optional first point on the line. If omitted, default value of (0,0) is used.
   * @param p2 Optional second point on the line. If omitted, default value of (0,0) is used.
   * @returns new Line object.
   */
  constructor(t, e) {
    super(), t ? this._p1 = t.copy() : this._p1 = K.zero(), e ? this._p2 = e.copy() : this._p2 = K.zero();
  }
  /**
   * Sets the points that define the line segment
   * @param p1 first point of the line segment
   * @param p2 second point of the line segment
   */
  set(t, e) {
    this._p1.assign(t), this._p2.assign(e);
  }
  /**
   * Gets the first point of the line segment
   * @returns the first point of the line segment
   */
  getP1() {
    return this._p1.copy();
  }
  /**
   * Sets the first point of the line segment
   * @param p1 first point of the line segment
   */
  setP1(t) {
    this._p1.assign(t);
  }
  /**
   * Gets the second point of the line segment
   * @returns the second point of the line segment
   */
  getP2() {
    return this._p2;
  }
  /**
   * sets the first point of the line segment
   * @param p2 second point of the line segment
   */
  setP2(t) {
    this._p2.assign(t);
  }
}
class X_ {
  constructor(t, e) {
    this.p1 = t.copy(), this.p2 = e.copy();
  }
}
class qb extends Dh {
  constructor() {
    super(...arguments), this._lines = [];
  }
  /**
   * Adds a line segment to the collection
   * @param p1 first point of the line segment
   * @param p2 second point of the line segment
   */
  addLine(t, e) {
    this._lines.push(new X_(t, e));
  }
  /**
   * Gets the lines in the collection
   */
  getLines() {
    return this._lines;
  }
  /**
   * Removes all line segments from this collection
   */
  clear() {
    this._lines = [];
  }
}
class J_ extends Fa {
  constructor() {
    super(...arguments), this._points = [];
  }
  /**
   * Removes all points from this polygon
   */
  clearPoints() {
    this._points = [];
  }
  /**
   * Gets the points in this polyline
   * @returns the points in this polygon
   */
  getPoints() {
    return this._points;
  }
  /**
   * Adds a point to the polygon
   * @param point the point to add to the polygon
   */
  pushPoint(t) {
    this._points.push(t.copy());
  }
}
class Kb extends Fa {
  constructor() {
    super(...arguments), this._polygons = [];
  }
  /**
   * Removes all polygons from the collection
   */
  clear() {
    this._polygons = [];
  }
  /**
   * Creates a new array of points that represent a polygon. Add Point2 objects to the array to construct the polygon
   * @returns new array which represents a polygon.
   */
  createPolygon() {
    const t = [];
    return this._polygons.push(t), t;
  }
  /**
   * @returns the polylines in this collection
   */
  getPolygons() {
    return this._polygons;
  }
}
class Sd extends Fa {
  /** @hidden */
  constructor() {
    super(), this._fontFamily = null, this._fontSize = 12, this.setStrokeWidth(0);
  }
  /** @hidden */
  _assign(t) {
    super._assign(t), this._fontFamily = t._fontFamily, this._fontSize = t._fontSize;
  }
  /**
   * Gets the font family for this text
   * @returns the font family
   */
  getFontFamily() {
    return this._fontFamily;
  }
  /**
   * Sets the font family this shape
   * @param fontFamily font family to use for this text
   */
  setFontFamily(t) {
    this._fontFamily = t;
  }
  /**
   * Sets the font size for this text
   * @param fontSize size to use for this text
   */
  setFontSize(t) {
    this._fontSize = t;
  }
  /**
   * Gets the font size for this text
   * @returns the font size
   */
  getFontSize() {
    return this._fontSize;
  }
}
class Xb extends Sd {
  /**
   * Creates a new markup text item.
   * @param text the text associated with this item.
   * @param position the screen space point of the top left of the text string.
   */
  constructor(t, e) {
    super(), this._position = K.zero(), this._text = "", e && (this._position = e.copy()), t && this.setText(t);
  }
  /** @hidden */
  _assign(t) {
    super._assign(t), this._text = t._text, this._position.assign(t._position);
  }
  /**
   * Sets the text position
   * @returns the top left position to render text from
   */
  setPosition(t) {
    this._position.assign(t);
  }
  /**
   * Gets the text position
   * @returns the text position
   */
  getPosition() {
    return this._position;
  }
  /**
   * Sets the text content
   * @param text the text to render
   */
  setText(t) {
    this._text = t;
  }
  /**
   * Gets the text content
   * @returns the text content
   */
  getText() {
    return this._text;
  }
}
class kg {
  constructor(t, e) {
    this.text = t, this.position = e.copy();
  }
}
class Y_ extends Sd {
  constructor() {
    super(...arguments), this._textStrings = [];
  }
  /**
   * Removes all text strings from this collection
   */
  clear() {
    this._textStrings = [];
  }
  /**
   * Adds a string to the collection
   * @param text the text to render
   * @param position the top left position of the text
   */
  addString(t, e) {
    this._textStrings.push(new kg(t, e));
  }
  /**
   * Gets the strings in the collection
   */
  getStrings() {
    return this._textStrings;
  }
}
class Mg {
  /** @hidden */
  constructor() {
    this._padding = 5, this._text = new Sd(), this._box = new wd(), this._box.setFillOpacity(0), this._box.setFillColor(vt.white());
  }
  /** @hidden */
  _assign(t) {
    this._text._assign(t._text), this._box._assign(t._box), this._padding = t._padding;
  }
  /**
   * Gets the Text portion of the TextBox. Use the methods on this object to modify the appearance of the text string
   * @returns the text markup object
   */
  getTextPortion() {
    return this._text;
  }
  /**
   * Gets the Box portion of the TextBox. Use the methods on this object to modify the appearance of the rectangle around the text string
   * @returns the rectangle markup object.
   */
  getBoxPortion() {
    return this._box;
  }
  /**
   * Gets the Pixel distance between the text and outer rectangle
   * @returns the padding value.
   */
  getPadding() {
    return this._padding;
  }
  /**
   * Sets the Pixel distance between the text and outer rectangle
   * @param padding the padding value.
   */
  setPadding(t) {
    this._padding = t;
  }
}
class Fl extends Mg {
  /**
   * Creates a new TextBox Markup Shape.
   * @param position the screen space point of the top left of the box. Default value is (0,0).
   * @param text the text string for the box. Default value is empty string.
   */
  constructor(t, e) {
    super(), this._position = K.zero(), this._textStr = "", t && this._position.assign(t), e && (this._textStr = e);
  }
  /** @hidden */
  _assign(t) {
    super._assign(t), this._position.assign(t._position);
  }
  /**
   * Gets the position in screen space of the top-left corner of the TextBox rectangle
   * @returns the TextBox position
   */
  getPosition() {
    return this._position.copy();
  }
  /**
   * Sets the position in screen space of the top-left corner of the TextBox rectangle
   * @param position the TextBox position
   */
  setPosition(t) {
    this._position.assign(t);
  }
  /**
   * Gets the text string for this box
   * @returns the text string
   */
  getTextString() {
    return this._textStr;
  }
  /**
   * Sets the text string for this box
   * @param text the text string
   */
  setTextString(t) {
    this._textStr = t;
  }
}
class Jb extends Mg {
  constructor() {
    super(...arguments), this._textStrings = [];
  }
  /**
   * Removes all text strings from this collection
   */
  clear() {
    this._textStrings = [];
  }
  /**
   * Adds a string to the collection
   * @param text the text to render
   * @param position the top left position of the text
   */
  addString(t, e) {
    this._textStrings.push(new kg(t, e));
  }
  /**
   * Gets the strings in the collection
   */
  getStrings() {
    return this._textStrings;
  }
}
const Yb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Circle: Gr,
  CircleCollection: Sg,
  EndcapShape: Dh,
  EndcapType: _n,
  FilledShape: Fa,
  Line: Qn,
  LineCollection: qb,
  Polygon: J_,
  PolygonCollection: Kb,
  Polyline: Ba,
  PolylineCollection: Hb,
  Rectangle: vd,
  RectangleBase: wd,
  RectangleCollection: Ub,
  StrokedShape: Cg,
  Text: Xb,
  TextBox: Fl,
  TextBoxBase: Mg,
  TextBoxCollection: Jb,
  TextCollection: Y_,
  TextMarkupBase: Sd,
  _MarkupCircleData: B_,
  _MarkupLineData: X_,
  _MarkupRectangleData: V_,
  _MarkupTextData: kg
}, Symbol.toStringTag, { value: "Module" })), bs = "http://www.w3.org/2000/svg";
function xl(s) {
  return `rgb(${s.r}, ${s.g}, ${s.b})`;
}
function Wf(s) {
  let t = "";
  for (let e = 0; e < s.length; e++)
    e && (t += " "), t += `${s[e].x},${s[e].y}`;
  return t;
}
function Gf(s, t) {
  const e = s * 1.1, i = new K(e, 0), n = new K(e, s), r = new K(0, s / 2), o = document.createElementNS(bs, "marker");
  o.id = Ss(), o.markerWidth.baseVal.value = e, o.markerHeight.baseVal.value = s, o.setOrientToAuto(), o.refY.baseVal.value = s / 2;
  const l = `M${i.x},${i.y} L${n.x},${n.y} L${r.x},${r.y} Z`, h = document.createElementNS(bs, "path");
  return h.setAttribute("d", l), h.setAttributeNS(null, "fill", xl(t)), o.appendChild(h), o;
}
function $f(s, t) {
  const e = s * 1.1, i = K.zero(), n = new K(0, s), r = new K(e, s / 2), o = document.createElementNS(bs, "marker");
  o.id = Ss(), o.markerWidth.baseVal.value = e, o.markerHeight.baseVal.value = s, o.setOrientToAuto(), o.refY.baseVal.value = s / 2, o.refX.baseVal.value = s;
  const l = `M${i.x},${i.y} L${n.x},${n.y} L${r.x},${r.y} Z`, h = document.createElementNS(bs, "path");
  return h.setAttribute("d", l), h.setAttributeNS(null, "fill", xl(t)), o.appendChild(h), o;
}
function qf(s, t, e, i) {
  const n = e / 2, r = xl(i), o = document.createElementNS(bs, "circle");
  return o.setAttributeNS(null, "cx", s.x.toString()), o.setAttributeNS(null, "cy", s.y.toString()), o.setAttributeNS(null, "r", n.toString()), o.setAttributeNS(null, "fill", r), t > 0 && (o.setAttributeNS(null, "stroke-width", t.toString()), o.setAttributeNS(null, "stroke", r)), o;
}
class Z_ {
  constructor() {
    this._svgCanvas = null, this._svgDefsElement = null, this._svgElements = [], this._svgTextElements = [];
  }
  _setCanvas(t) {
    this._svgCanvas = t, this._svgDefsElement = document.createElementNS(bs, "defs"), this._svgCanvas.appendChild(this._svgDefsElement);
  }
  _clear() {
    if (this._svgCanvas === null || this._svgDefsElement === null)
      throw new oe("canvas not set");
    for (; this._svgCanvas.firstChild; )
      this._svgCanvas.removeChild(this._svgCanvas.firstChild);
    for (this._svgElements = [], this._svgTextElements = []; this._svgDefsElement.firstChild; )
      this._svgDefsElement.removeChild(this._svgDefsElement.firstChild);
    this._svgCanvas.appendChild(this._svgDefsElement);
  }
  _finalize() {
    if (this._svgCanvas === null)
      throw new oe("canvas not set");
    for (const t of this._svgElements)
      this._svgCanvas.appendChild(t);
    for (const t of this._svgTextElements)
      this._svgCanvas.appendChild(t);
  }
  drawCircle(t) {
    return this._addCircleNode(t.getCenter(), t.getRadius(), t);
  }
  drawCircles(t) {
    const e = t.getCircles(), i = [];
    for (const n of e) {
      const r = this._addCircleNode(n.center, n.radius, t);
      i.push(r);
    }
    return i;
  }
  drawLine(t) {
    return this._addLineElement(t.getP1(), t.getP2(), t);
  }
  drawLines(t) {
    const e = t.getLines(), i = [];
    for (const n of e) {
      const r = this._addLineElement(n.p1, n.p2, t);
      i.push(r);
    }
    return i;
  }
  drawText(t) {
    return this._addTextElement(t.getText(), t.getPosition(), t);
  }
  drawTexts(t) {
    const e = t.getStrings(), i = [];
    for (const n of e) {
      const r = this._addTextElement(n.text, n.position, t);
      i.push(r);
    }
    return i;
  }
  measureText(t, e) {
    if (this._svgCanvas === null)
      throw new oe("canvas not set");
    const i = this._createTextElement(t, K.zero(), e);
    this._svgCanvas.appendChild(i);
    const n = i.getBoundingClientRect(), r = new K(n.width, n.height);
    return this._svgCanvas.removeChild(i), r;
  }
  measureTextBox(t) {
    const e = this.measureText(t.getTextString(), t.getTextPortion());
    return e.x += 2 * t.getBoxPortion().getStrokeWidth(), e.y += 2 * t.getBoxPortion().getStrokeWidth(), e.x += 2 * t.getPadding(), e.y += 2 * t.getPadding(), e;
  }
  drawPolyline(t) {
    return this._addPolylineElement(t.getPoints(), t);
  }
  drawPolylines(t) {
    const e = t.getPolylines(), i = [];
    for (const n of e) {
      const r = this._addPolylineElement(n, t);
      i.push(r);
    }
    return i;
  }
  drawPolygon(t) {
    return this._addPolygonElement(t.getPoints(), t);
  }
  drawPolygons(t) {
    const e = t.getPolygons(), i = [];
    for (const n of e) {
      const r = this._addPolygonElement(n, t);
      i.push(r);
    }
    return i;
  }
  drawRectangle(t) {
    return this._addRectangleElement(t.getPosition(), t.getSize(), t);
  }
  drawRectangles(t) {
    const e = t.getRectangles(), i = [];
    for (const n of e) {
      const r = this._addRectangleElement(n.position, n.size, t);
      i.push(r);
    }
    return i;
  }
  drawTextBox(t) {
    return this._addTextBoxElement(t.getTextString(), t.getPosition(), t);
  }
  drawTextBoxes(t) {
    const e = t.getStrings(), i = [];
    for (const n of e) {
      const r = this._addTextBoxElement(n.text, n.position, t);
      i.push(r);
    }
    return i;
  }
  _addTextBoxElement(t, e, i) {
    const n = this.measureText(t, i.getTextPortion());
    n.x += 2 * i.getPadding(), n.y += 2 * i.getPadding();
    const r = [], o = this._addRectangleElement(
      e,
      n,
      i.getBoxPortion(),
      !0
    );
    r.push(o);
    const l = e.copy();
    l.x += i.getPadding(), l.y += i.getPadding() / 2 + i.getBoxPortion().getStrokeWidth();
    const h = this._addTextElement(t, l, i.getTextPortion());
    return r.push(h), r;
  }
  _renderEndcaps(t, e, i, n) {
    if (this._svgDefsElement === null)
      throw new oe("canvas not set");
    if (i.getStartEndcapType() === _n.Arrowhead) {
      let r;
      i.getEndcapsInverted() ? (r = $f(
        i.getStartEndcapSize(),
        i.getStartEndcapColor()
      ), r.refX.baseVal.value = i.getStartEndcapSize()) : r = Gf(
        i.getStartEndcapSize(),
        i.getStartEndcapColor()
      ), n.style.markerStart = `url(#${r.id})`, this._svgDefsElement.appendChild(r);
    } else if (i.getStartEndcapType() === _n.Circle) {
      const r = qf(
        t,
        i.getStrokeWidth(),
        i.getStartEndcapSize(),
        i.getStartEndcapColor()
      );
      this._addSVGElement(r);
    }
    if (i.getEndEndcapType() === _n.Arrowhead) {
      let r;
      i.getEndcapsInverted() ? r = Gf(i.getEndEndcapSize(), i.getEndEndcapColor()) : r = $f(i.getEndEndcapSize(), i.getEndEndcapColor()), n.style.markerEnd = `url(#${r.id})`, this._svgDefsElement.appendChild(r);
    } else if (i.getEndEndcapType() === _n.Circle) {
      const r = qf(
        e,
        i.getStrokeWidth(),
        i.getEndEndcapSize(),
        i.getEndEndcapColor()
      );
      this._addSVGElement(r);
    }
  }
  _createTextElement(t, e, i) {
    const n = document.createElementNS(bs, "text"), r = t.split(`
`);
    for (const l of r) {
      const h = document.createElementNS(bs, "tspan");
      h.textContent = l, h.setAttributeNS(null, "x", `${e.x}`), h.setAttributeNS(null, "dy", "1.2em"), n.appendChild(h);
    }
    const o = i.getFontFamily();
    return o && n.setAttributeNS(null, "font-family", o), n.setAttributeNS(null, "font-size", i.getFontSize().toString()), n.setAttributeNS(null, "x", `${e.x}`), n.setAttributeNS(null, "y", `${e.y}`), this._setGenericFillAttributes(n, i), this._setGenericStrokeAttributes(n, i), n;
  }
  _addTextElement(t, e, i) {
    const n = this._createTextElement(t, e, i);
    return this._addSVGTextItemElement(n), n;
  }
  _addRectangleElement(t, e, i, n = !1) {
    const r = document.createElementNS(bs, "rect");
    r.setAttributeNS(null, "x", t.x.toString()), r.setAttributeNS(null, "y", t.y.toString()), r.setAttributeNS(null, "width", e.x.toString()), r.setAttributeNS(null, "height", e.y.toString());
    const o = i.getBorderRadius();
    return o > 0 && (r.setAttributeNS(null, "rx", o.toString()), r.setAttributeNS(null, "ry", o.toString())), this._setGenericFillAttributes(r, i), this._setGenericStrokeAttributes(r, i), n ? this._addSVGTextItemElement(r) : this._addSVGElement(r), r;
  }
  _addLineElement(t, e, i) {
    const n = document.createElementNS(bs, "line");
    return n.setAttributeNS(null, "x1", t.x.toString()), n.setAttributeNS(null, "y1", t.y.toString()), n.setAttributeNS(null, "x2", e.x.toString()), n.setAttributeNS(null, "y2", e.y.toString()), this._setGenericStrokeAttributes(n, i), this._addSVGElement(n), this._renderEndcaps(t, e, i, n), n;
  }
  _addPolygonElement(t, e) {
    const i = Wf(t), n = document.createElementNS(bs, "polygon");
    return n.setAttributeNS(null, "points", i), this._setGenericStrokeAttributes(n, e), this._setGenericFillAttributes(n, e), this._addSVGElement(n), n;
  }
  _addPolylineElement(t, e) {
    const i = Wf(t), n = document.createElementNS(bs, "polyline");
    return n.setAttributeNS(null, "points", i), n.setAttributeNS(null, "fill", "none"), this._renderEndcaps(t[0], t[t.length - 1], e, n), this._setGenericStrokeAttributes(n, e), this._addSVGElement(n), n;
  }
  _addCircleNode(t, e, i) {
    const n = document.createElementNS(bs, "circle");
    return n.setAttributeNS(null, "cx", t.x.toString()), n.setAttributeNS(null, "cy", t.y.toString()), n.setAttributeNS(null, "r", e.toString()), this._setGenericFillAttributes(n, i), this._setGenericStrokeAttributes(n, i), this._addSVGElement(n), n;
  }
  _setGenericFillAttributes(t, e) {
    t.setAttributeNS(null, "fill", xl(e.getFillColor())), t.setAttributeNS(null, "fill-opacity", e.getFillOpacity().toString());
  }
  _setGenericStrokeAttributes(t, e) {
    t.setAttributeNS(null, "stroke", xl(e.getStrokeColor())), t.setAttributeNS(null, "stroke-width", e.getStrokeWidth().toString());
  }
  _addSVGTextItemElement(t) {
    this._svgTextElements.push(t);
  }
  _addSVGElement(t) {
    this._svgElements.push(t);
  }
}
const Zb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  SVGMarkupRenderer: Z_,
  createCircleMarker: qf,
  createEndArrowMarker: $f,
  createStartArrowMarker: Gf,
  svgColorRgbString: xl,
  svgNamespace: bs,
  svgPointString: Wf
}, Symbol.toStringTag, { value: "Module" })), n1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Line: Wb,
  MarkupItem: go,
  MarkupItemManager: q_,
  MarkupView: uh,
  Redline: $b,
  Shapes: Yb,
  Svg: Zb,
  _MarkupViewConstruction: K_
}, Symbol.toStringTag, { value: "Module" })), Q_ = 45, ty = -45, ey = 150, iy = 30;
function ny(s) {
  nl(s, Re.Forward, Re.Backward), nl(s, Re.Left, Re.Right), nl(s, Re.Up, Re.Down), nl(s, Re.RotateLeft, Re.RotateRight), nl(s, Re.TiltUp, Re.TiltDown);
}
function nl(s, t, e) {
  s.has(t) && s.has(e) && (s.delete(t), s.delete(e));
}
function Kf(s, t, e) {
  return Math.max(Math.min(s, e), t);
}
function sy(s) {
  const t = s.getViewAxes().upVector;
  return console.assert(t.isAxis()), _.scale(t, -1);
}
function Eg(s, t) {
  const e = new Si(Se.Face);
  return e.bimMask = s, e.ignoreOverlays = !0, t !== null && (e.maxWorldDistance = t), e;
}
async function Xf(s, t, e, i) {
  const n = new wr(t, e), r = Eg(mn.Floor, i), o = await s.pickFromRay(n, r);
  return o.isFaceSelection() ? o.getPosition() : null;
}
async function ry(s, t, e, i) {
  const n = new wr(t, e.copy().normalize()), r = Eg(mn.Wall, i), o = await s.pickFromRay(n, r);
  return o.isFaceSelection() ? o : null;
}
class Qb {
  constructor() {
    this._action = new fo(!0), this._latestPromise = null, this._timestamp = 0;
  }
  isIdle() {
    return this._latestPromise === null && this._action.isIdle();
  }
  /**
   * Returned promise can reject if future calls are made. This is by design.
   */
  set(t) {
    const e = ++this._timestamp;
    this._latestPromise !== null && this._latestPromise.reject(void 0);
    const i = wi();
    return this._latestPromise = i, this._action.clear(), this._action.waitForIdle().then(() => {
      e === this._timestamp && this._action.set(() => {
        if (e !== this._timestamp)
          return;
        i === this._latestPromise && (this._latestPromise = null), typeof t == "function" && (t = Is.create(t));
        let n;
        try {
          n = t.get();
        } catch (r) {
          return this._advance(i, !0, r);
        }
        return n === void 0 ? this._advance(i, !1, null) : n.then(
          () => this._advance(i, !1, null),
          (r) => this._advance(i, !0, r)
        );
      });
    }), i;
  }
  _advance(t, e, i) {
    t === this._latestPromise && (this._latestPromise = null), e ? t.reject(i) : t.resolve();
  }
}
class Jf {
  constructor(t, e) {
    this._button = t, this._modifier = e;
  }
  getButton() {
    return this._button;
  }
  getModifier() {
    return this._modifier;
  }
}
class Ai {
  /** @hidden */
  constructor(t, e) {
    this._ptFirst = K.zero(), this._ptPrevious = K.zero(), this._ptCurrent = K.zero(), this._dragging = !1, this._dragCount = 0, this._primaryTouchId = null, this._mapping = [], this._buttonModifierActive = !1, this._doubleClickInterval = 200, this._firstMouseDownTime = null, this._isDoubleClick = !1, this._viewer = t, this._view = e;
  }
  /** @hidden */
  onDoubleClick(t) {
  }
  /** @hidden */
  onMouseDown(t) {
    if (this._firstMouseDownTime ? Date.now() - this._firstMouseDownTime < this._doubleClickInterval ? (this._isDoubleClick = !0, this._firstMouseDownTime = null) : this._firstMouseDownTime = Date.now() : (this._firstMouseDownTime = Date.now(), this._isDoubleClick = !1), this._isDoubleClick)
      this.onDoubleClick(t);
    else {
      if (this._buttonModifierActive = this.checkMapping(t), this._buttonModifierActive) {
        const e = t.getPosition();
        this._ptFirst.assign(e), this._ptPrevious.assign(e), this._ptCurrent.assign(e);
      }
      this._dragging = !0;
    }
  }
  /** @hidden */
  onMouseMove(t) {
    this.isActive() && (this._ptPrevious.assign(this._ptCurrent), this._ptCurrent.assign(t.getPosition()), this._dragging && (this._ptCurrent.equals(this._ptPrevious) || (++this._dragCount, this._dragCount === 1 && this._viewer.trigger("beginInteraction"))));
  }
  /** @hidden */
  onMouseUp(t) {
    this._buttonModifierActive && this.stopInteraction(), this._dragging = !1, this._dragCount = 0;
  }
  /** @hidden */
  stopInteraction() {
    this._viewer.trigger("endInteraction"), this._dragging = !1, this._dragCount = 0, this._buttonModifierActive = !1;
  }
  /** @hidden */
  isDragging() {
    return this._dragging;
  }
  /** @hidden */
  isActive() {
    return (this._buttonModifierActive || this._primaryTouchId !== null) && !this._isDoubleClick && !this._viewer.getContextMenuStatus();
  }
  /** @hidden */
  onTouchStart(t) {
    if (this._primaryTouchId === null) {
      this._primaryTouchId = t.getId();
      const e = t.getPosition(), i = new Wr(
        e.x,
        e.y,
        Ee.None,
        t.getButtons(),
        Ci.None,
        mr.Down,
        t.viewKey
      );
      this.onMouseDown(i);
    }
    t.setHandled(this.setHandled());
  }
  /** @hidden */
  async onTouchMove(t) {
    if (this._primaryTouchId === t.getId()) {
      const e = t.getPosition(), i = new Wr(
        e.x,
        e.y,
        Ee.None,
        t.getButtons(),
        Ci.None,
        mr.Move,
        t.viewKey
      );
      await this.onMouseMove(i);
    }
    return t.setHandled(this.setHandled()), Promise.resolve();
  }
  /** @hidden */
  onTouchEnd(t) {
    if (this._primaryTouchId === t.getId()) {
      const e = t.getPosition(), i = new Wr(
        e.x,
        e.y,
        Ee.None,
        t.getButtons(),
        Ci.None,
        mr.Up,
        t.viewKey
      );
      this.onMouseUp(i), this._primaryTouchId = null;
    }
    t.setHandled(this.setHandled());
  }
  /**
   * Adds a button and key modifier mapping for the operator. If no mapping is provided, all combinations are considered valid.
   * All mappings require a mouse button, but a key modifier is optional.
   * @param button
   * @param modifier
   */
  addMapping(t, e = Ci.None) {
    this._mapping.push(new Jf(t, e));
  }
  /**
   * Clears any button and key modifier mappings for the operator.
   */
  clearMapping() {
    this._mapping = [];
  }
  /**
   * Sets the button and key modifier mapping for the operator.
   * @param button
   * @param modifier
   */
  setMapping(t, e = Ci.None) {
    this._mapping = [], this._mapping.push(new Jf(t, e));
  }
  /** @hidden */
  checkMapping(t) {
    if (this._mapping.length === 0)
      return !0;
    for (const e of this._mapping)
      if (e.getButton() === t.getButton() && e.getModifier() === t.getModifiers())
        return !0;
    return !1;
  }
  /** @hidden */
  setHandled() {
    return !1;
  }
  /** @hidden */
  onDeactivate() {
    const t = this.stopInteraction();
    return this._primaryTouchId = null, t;
  }
}
class Bh {
  constructor(t, e) {
    this._mode = t, this._impl = new sx(e);
  }
  /**
   * Creates a new `IncrementalSelection` object that can be used to perform incremental selections.
   *
   * @param mode Controls whether or not selections are performed using the [[View]] or the [[SelectionManager]].
   * @param viewer The `WebViewer` of the scene.
   * @param createSelectionPredicate This callback is used to create a selection predicate. Return null to not filter selection results.
   * @returns The created `IncrementalSelection` object.
   */
  static create(t, e) {
    return new Bh(t, e);
  }
  performSelection(t, e, i) {
    const n = this._impl.viewer;
    let r;
    return this._mode === "View" ? (r = n.view, i === void 0 && (i = [])) : (this._mode, r = n.selectionManager), e === void 0 && (e = null), this._impl.performSelection(r, t, e, i);
  }
  /**
   * Returns whether or not this object has an active selection in progress.
   * @returns `true` if active and `false` if idle.
   */
  isIdle() {
    return this._impl.isIdle();
  }
  /**
   * Used to wait for this object to become idle.
   * @returns A promise that resolves when this becomes idle.
   */
  waitForIdle() {
    return this._impl.waitForIdle();
  }
  /**
   * Stops the selection.
   * @returns A `Promise` that resolves when completed.
   */
  stopSelection() {
    return this._impl.stopSelection();
  }
  /**
   * Stops and clears the selection.
   * @returns A `Promise` that resolves when completed.
   */
  clearSelection() {
    return this._impl.clearSelection();
  }
}
function tx(s) {
  return "areaCssMin" in s;
}
function ex(s) {
  return "rayCssBoxRadius" in s;
}
function ix(s) {
  return "volumePlanes" in s;
}
function nx(s) {
  return "sphereRadius" in s;
}
class sx {
  constructor(t) {
    this._killHandles = [], this._activeSelectionCount = 0, this._inactivityPromise = null, this.viewer = t;
  }
  isIdle() {
    return this._activeSelectionCount === 0;
  }
  async waitForIdle() {
    return this._activeSelectionCount === 0 ? (console.assert(this._inactivityPromise === null), Promise.resolve()) : (this._inactivityPromise === null && (this._inactivityPromise = wi()), this._inactivityPromise);
  }
  async stopSelection() {
    console.assert(this._killHandles.length === this._activeSelectionCount);
    const t = [];
    for (const e of this._killHandles)
      t.push(e());
    return Ge(t);
  }
  async clearSelection() {
    const t = this.viewer.selectionManager;
    t.clear(), await this.stopSelection(), t.clear();
  }
  async _advanceBySelectionManager(t, e) {
    return this.viewer.selectionManager.advanceIncrementalSelection(t, e);
  }
  async _advanceByView(t, e, i) {
    let r = await this.viewer.view.advanceIncrementalSelection(t);
    if (r === null)
      return !1;
    if (e) {
      const o = await Promise.all(r.map(e));
      r = r.filter((l, h) => o[h]);
    }
    for (const o of r)
      i.push(o);
    return !0;
  }
  _wrapBeginSelection(t, e) {
    return tx(e) ? t.beginScreenSelectByArea(
      e.areaCssMin,
      e.areaCssMax,
      e.pickConfig
    ) : ex(e) ? t.beginRayDrillSelection(
      e.rayCssOrigin,
      e.rayCssBoxRadius,
      e.pickConfig
    ) : ix(e) ? t.beginConvexPolyhedronSelection(
      e.volumePlanes,
      e.heuristicOrigin,
      e.pickConfig
    ) : nx(e) ? t.beginSphereSelection(
      e.sphereCenter,
      e.sphereRadius,
      e.pickConfig
    ) : $r();
  }
  async performSelection(t, e, i, n) {
    return n === void 0 ? this._performSelection(t, e, i, null) : (await this._performSelection(t, e, i, n), n);
  }
  async _performSelection(t, e, i, n) {
    const r = this._wrapBeginSelection(t, e);
    if (r === null)
      return;
    ++this._activeSelectionCount;
    const o = this.viewer.selectionManager, l = n === null;
    let h = !1;
    const u = Is.create(async () => {
      h = !0;
      try {
        const g = await r;
        l ? await o.endIncrementalSelection(g) : await this.viewer.view.endIncrementalSelection(g);
      } finally {
        const g = this._killHandles.indexOf(d);
        console.assert(g >= 0), this._killHandles.splice(g, 1), --this._activeSelectionCount, this._activeSelectionCount === 0 && this._inactivityPromise !== null && (this._inactivityPromise.resolve(), this._inactivityPromise = null);
      }
    }), d = () => u.get();
    this._killHandles.push(d);
    try {
      const g = await r;
      let y = !0;
      for (; y && !h; )
        l ? y = await this._advanceBySelectionManager(g, i) : y = await this._advanceByView(g, i, n), y && !h && await md(1);
    } finally {
      await d();
    }
  }
}
class oy {
  constructor(t) {
    this._nearbyDoors = /* @__PURE__ */ new Set(), this._viewer = t;
  }
  _performSphereSelection(t, e, i) {
    const n = Bh.create("View", this._viewer), r = new xd(Se.Face);
    return r.bimMask = i, r.onlyStreamedInstances = !0, r.ignoreUnrequestedInstances = !0, n.performSelection({
      pickConfig: r,
      sphereCenter: t,
      sphereRadius: e
    });
  }
  async updateNearbyDoors(t, e, i) {
    const n = await this._performSphereSelection(
      t,
      e,
      mn.Door
    ), r = /* @__PURE__ */ new Set();
    for (const g of n) {
      const y = g.getNodeId();
      r.add(y);
    }
    const o = Sf(r, this._nearbyDoors), l = Sf(this._nearbyDoors, r), h = ao(o), u = ao(l), d = this._viewer.model;
    d.setNodesOpacity(h, i), d.resetNodesOpacity(u), this._nearbyDoors = r;
  }
  forgetNearbyDoors() {
    const t = ao(this._nearbyDoors);
    this._nearbyDoors.clear(), this._viewer.model.resetNodesOpacity(t);
  }
}
class Ag extends Ai {
  /** @hidden */
  constructor(t, e) {
    super(t, e), this._elevationSpeed = 0, this._rotationSpeed = 0, this._viewAngle = 90, this._zoomDistance = 0, this._walkDistance = 0, this._tilt = 0, this._majorAxis = Qe.X, this._maxExtents = 0, this._walkActive = !1, this._activeWalk = new fo(!0), this._bimModeEnabled = !1, this._synchronizedToggleBimMode = new Qb(), this._initialInteractiveDrawLimitIncreaseStatus = !0, this._logical = {
      floor: {
        ...ed
      },
      wall: {
        ...id
      },
      door: {
        ...nd
      }
    }, this._effective = {
      floor: {
        ...ed
      },
      wall: {
        ...id
      },
      door: {
        ...nd
      }
    }, this._doorCache = new oy(t), this._downAxis = new _(0, -1, 0), t.setCallbacks({
      subtreeLoaded: (i, n) => {
        n === ho.LoadModel && this._updateSceneFloor();
      }
    });
  }
  _updateSceneFloor() {
    this._downAxis = sy(this._viewer.model);
  }
  isBimModeEnabled() {
    return this._bimModeEnabled;
  }
  async _enableBimMode() {
    this._bimModeEnabled = !0, this._effective.floor = this._scaleAgainstModelUnit(this._logical.floor), this._effective.wall = this._scaleAgainstModelUnit(this._logical.wall), this._effective.door = this._scaleAgainstModelUnit(this._logical.door), this._updateSceneFloor(), await this._applyGravity(), await this._updateNearbyDoors();
  }
  _disableBimMode() {
    this._bimModeEnabled = !1, this._doorCache.forgetNearbyDoors();
  }
  /**
   * Enables BIM mode, which includes collision detection
   */
  enableBimMode() {
    return this._synchronizedToggleBimMode.set(async () => {
      await this._enableBimMode();
    });
  }
  /**
   * Disables BIM mode, which includes collision detection
   */
  disableBimMode() {
    return this._synchronizedToggleBimMode.set(() => {
      this._disableBimMode();
    });
  }
  /**
   * Toggles BIM mode, deactivating it if it's activated and activating it if it's deactivated
   */
  toggleBimMode() {
    return this._synchronizedToggleBimMode.set(() => this._bimModeEnabled ? this._disableBimMode() : this._enableBimMode());
  }
  /** @hidden */
  async onActivate() {
    this._view.setProjectionMode(ri.Perspective);
    const t = this._view;
    if (this._initialInteractiveDrawLimitIncreaseStatus = await t.getInteractiveDrawLimitIncreaseEnabled(), t.setInteractiveDrawLimitIncreaseEnabled(!1), this._calculateInitialPosition(), this._maxExtents === 0 && await this.resetDefaultWalkSpeeds(), this._bimModeEnabled && await this._updateNearbyDoors(), this._view.floorplanManager.getConfiguration().autoActivate === Go.BimWalk) {
      const i = this._viewer.model.getNodesByGenericType("IFCBUILDINGSTOREY");
      i && i.size > 0 && await this._view.floorplanManager.activate();
    }
  }
  /** @hidden */
  async onDeactivate() {
    if (this._view.setInteractiveDrawLimitIncreaseEnabled(
      this._initialInteractiveDrawLimitIncreaseStatus
    ), this._doorCache.forgetNearbyDoors(), this._view.floorplanManager.getConfiguration().autoActivate === Go.BimWalk) {
      const e = this._viewer.model.getNodesByGenericType("IFCBUILDINGSTOREY");
      e && e.size > 0 && await this._view.floorplanManager.deactivate();
    }
    super.onDeactivate();
  }
  /**
   * Sets the walk, rotate, and mouse look speeds to the default values.
   */
  async resetDefaultWalkSpeeds() {
    this._rotationSpeed = 40, this._viewAngle = 90;
    const e = (await this._viewer.model.getLooseBounding()).extents();
    this._maxExtents = Math.max(e.x, e.y, e.z), this._walkDistance = this._maxExtents / 15, this._elevationSpeed = this._maxExtents / 10, this._zoomDistance = this._maxExtents / 30;
  }
  /**
   * Gets the floor distance config used by BIM mode.
   * See also: [[enableBimMode]].
   */
  getBimFloorConfig() {
    return { ...this._logical.floor };
  }
  /**
   * Sets the floor distance config used by BIM mode.
   * See also: [[enableBimMode]].
   */
  setBimFloorConfig(t) {
    this._logical.floor = { ...t }, this._effective.floor = this._scaleAgainstModelUnit(this._logical.floor);
  }
  /**
   * Gets the wall distance config used by BIM mode.
   * See also: [[enableBimMode]].
   */
  getBimWallConfig() {
    return { ...this._logical.wall };
  }
  /**
   * Sets the wall distance config used by BIM mode.
   * See also: [[enableBimMode]].
   */
  setBimWallConfig(t) {
    this._logical.wall = { ...t }, this._effective.wall = this._scaleAgainstModelUnit(this._logical.wall);
  }
  /**
   * Gets the door distance config used by BIM mode.
   * See also: [[enableBimMode]].
   */
  getBimDoorConfig() {
    return { ...this._logical.door };
  }
  /**
   * Sets the door distance config used by BIM mode.
   */
  setBimDoorConfig(t) {
    this._logical.door = { ...t }, this._effective.door = this._scaleAgainstModelUnit(this._logical.door);
  }
  _scaleAgainstModelUnit(t) {
    const e = this._viewer.model, i = 1 / e.getNodeUnitMultiplier(e.getAbsoluteRootNode());
    t = { ...t };
    const n = Object.keys(t);
    for (const r of n)
      typeof t[r] == "number" && (t[r] *= i);
    return t;
  }
  /** @hidden */
  onMouseDown(t) {
    super.onMouseDown(t);
  }
  /** @hidden */
  onMouseMove(t) {
    super.onMouseMove(t);
  }
  /** @hidden */
  onMouseUp(t) {
    super.onMouseUp(t);
  }
  /** @hidden */
  async _applyGravity() {
    const t = this._view, e = t.getCamera();
    let i = e.getPosition(), n = await Xf(
      t,
      i,
      this._downAxis,
      this._effective.floor.maxFallDistance
    );
    if (n === null && (i = _.subtract(
      i,
      _.scale(this._downAxis, this._effective.floor.avatarOffset)
    ), n = await Xf(
      t,
      i,
      this._downAxis,
      this._effective.floor.maxFallDistance
    ), n === null))
      return;
    const r = new _(0, 0, this._effective.floor.avatarOffset), o = _.add(n, r), l = _.subtract(o, i), h = l.length();
    h > this._effective.floor.negligibleClimbHeight && yr(l, this._downAxis) > 90 && h > this._effective.floor.maxClimbHeight || this._applyWalkDelta(e, l);
  }
  /** @hidden */
  _updateNearbyDoors() {
    const e = this._view.getCamera().getPosition();
    return this._doorCache.updateNearbyDoors(
      e,
      this._effective.door.transparencyRange,
      0.5
    );
  }
  _updateCamera(t) {
    this._resetPosition(t), this._updateCameraTilt(t), this._updateCameraViewAngle(t), this._view.setCamera(t);
  }
  /** @hidden */
  _applyWalkDelta(t, e) {
    t.dolly(_.scale(e, -1)), this._updateCamera(t);
  }
  /** @hidden */
  async _applyWalkDeltaWithCollisionCheck(t, e, i) {
    const n = t.getPosition(), o = mt.createFromOffAxisRotation(i, 90).transform(e), h = mt.createFromOffAxisRotation(i, -90).transform(e), u = this._testWallCollision(
      n,
      o,
      this._effective.wall.avatarOffset
    ), d = this._testWallCollision(
      n,
      h,
      this._effective.wall.avatarOffset
    ), g = this._testWallCollision(
      n,
      e,
      e.length() + this._effective.wall.avatarOffset
    ), [y, m] = await Promise.all([
      u,
      d
    ]);
    if (y !== null || m !== null) {
      const b = (I) => {
        if (I !== null) {
          const C = I.getFaceEntity().getNormal();
          return yr(C, e) > 90;
        }
        return !1;
      };
      if (b(y) || b(m))
        return;
    }
    const x = await g;
    if (x !== null) {
      const b = e.length(), I = _.scale(e, 1 / b), P = _.subtract(x.getPosition(), n).length() - this._effective.wall.avatarOffset, k = Math.min(b, P);
      e = _.scale(I, k);
    }
    this._applyWalkDelta(t, e);
  }
  _testWallCollision(t, e, i) {
    return ry(this._view, t, e, i);
  }
  _walkBackward(t, e) {
    const n = this._view.getCamera();
    this._resetPosition(n);
    const r = n.getTarget(), o = n.getPosition(), l = n.getUp(), u = _.subtract(o, r).normalize().copy().scale(t);
    return e ? this._applyWalkDeltaWithCollisionCheck(n, u, l) : this._applyWalkDelta(n, u);
  }
  _walkForward(t, e) {
    return this._walkBackward(-t, e);
  }
  _walkLeft(t, e) {
    const n = this._view.getCamera();
    this._resetPosition(n);
    const r = n.getTarget(), o = n.getPosition(), l = n.getUp(), h = _.subtract(r, o).normalize(), d = _.cross(l, h).normalize().copy().scale(t);
    return e ? this._applyWalkDeltaWithCollisionCheck(n, d, l) : this._applyWalkDelta(n, d);
  }
  _walkRight(t, e) {
    return this._walkLeft(-t, e);
  }
  walkBackward(t) {
    return this._walkBackward(t, !1);
  }
  walkForward(t) {
    return this._walkForward(t, !1);
  }
  walkLeft(t) {
    return this._walkLeft(t, !1);
  }
  walkRight(t) {
    return this._walkRight(t, !1);
  }
  walkBackwardWithCollision(t) {
    return this._walkBackward(t, !0);
  }
  walkForwardWithCollision(t) {
    return this._walkForward(t, !0);
  }
  walkLeftWithCollision(t) {
    return this._walkLeft(t, !0);
  }
  walkRightWithCollision(t) {
    return this._walkRight(t, !0);
  }
  walkDown(t) {
    const i = this._view.getCamera();
    this._resetPosition(i);
    const n = i.getUp().normalize().scale(t);
    this._applyWalkDelta(i, n);
  }
  walkUp(t) {
    this.walkDown(-t);
  }
  rotateRight(t) {
    const i = this._view.getCamera();
    this._resetPosition(i);
    const n = i.getTarget(), r = i.getPosition(), l = _.subtract(r, n).length(), h = _.subtract(n, r).normalize(), u = Fo(t), d = Math.tan(u), y = _.subtract(i.getTarget(), i.getPosition()).length() * d, m = _.cross(h, i.getUp()).scale(y);
    let x = n.copy().add(m);
    const b = _.subtract(x, r).normalize().scale(l);
    x = _.add(r, b), i.setTarget(x), this._updateCamera(i);
  }
  rotateLeft(t) {
    this.rotateRight(-t);
  }
  tiltDown(t) {
    this.setTilt(this._tilt + t);
    const i = this._view.getCamera();
    this._resetPosition(i), this._updateCamera(i);
  }
  tiltUp(t) {
    this.tiltDown(-t);
  }
  /** @hidden */
  _calculateInitialPosition() {
    const e = this._view.getCamera();
    this._calculateMajorAxis(e), this.setTilt(this._calculateInitialTilt(e)), this._resetPosition(e), this._updateCamera(e);
  }
  _updateCameraViewAngle(t) {
    const e = Fo(this._viewAngle), i = Math.tan(e / 2), r = _.subtract(t.getTarget(), t.getPosition()).length() * i;
    t.setWidth(r), t.setHeight(r);
  }
  _updateCameraTilt(t) {
    const e = t.getPosition(), i = t.getTarget(), n = t.getUp().normalize(), r = _.subtract(i, e).normalize(), o = _.cross(n, r).normalize(), l = _.distance(i, e);
    mt.createFromOffAxisRotation(o, this._tilt).transform(r, r), t.setTarget(_.add(e, r.scale(l)));
  }
  _calculateInitialTilt(t) {
    const e = t.getTarget(), i = t.getPosition(), n = _.subtract(e, i), r = n.length();
    this._majorAxis === Qe.X ? n.x = 0 : this._majorAxis === Qe.Y ? n.y = 0 : this._majorAxis === Qe.Z && (n.z = 0);
    const o = n.length();
    return Math.acos(o / r) * (180 / Math.PI);
  }
  /** @hidden */
  _resetPosition(t) {
    this._calculateMajorAxis(t);
    const e = t.getPosition(), i = t.getTarget(), n = _.subtract(i, e);
    let r = n.length();
    switch (this.getWalkSpeed() > 0 && (r = this.getWalkSpeed()), this._majorAxis) {
      case Qe.X:
        n.set(0, n.y, n.z), t.setUp(new _(1, 0, 0));
        break;
      case Qe.Y:
        n.set(n.x, 0, n.z), t.setUp(new _(0, 1, 0));
        break;
      case Qe.Z:
        n.set(n.x, n.y, 0), t.setUp(new _(0, 0, 1));
        break;
    }
    n.normalize().scale(r), t.setTarget(_.add(e, n));
  }
  /** @hidden */
  _calculateMajorAxis(t) {
    const e = t.getUp(), i = Math.abs(e.x), n = Math.abs(e.y), r = Math.abs(e.z);
    r >= i && r >= n ? this._majorAxis = Qe.Z : n >= i && n >= r ? this._majorAxis = Qe.Y : this._majorAxis = Qe.X;
  }
  /**
   * Sets the speed to walk when using the mouse scroll wheel.
   * @param zoomSpeed distance for walking with the mouse scroll wheel.
   */
  setZoomSpeed(t) {
    this._zoomDistance = t;
  }
  /**
   * Gets the speed used when walking with the mouse scroll wheel.
   */
  getZoomSpeed() {
    return this._zoomDistance;
  }
  /**
   * Sets the tilt value. Values must be between -45 and 45 degrees.
   * @param tilt
   */
  setTilt(t) {
    this._tilt = Kf(t, ty, Q_);
    const e = this._view.getCamera();
    this._updateCamera(e);
  }
  /**
   * Gets the tilt value.
   */
  getTilt() {
    return this._tilt;
  }
  /**
   * Sets the view angle. Values must be between 30 and 150 degrees.
   * @param viewAngle
   */
  setViewAngle(t) {
    const e = Kf(t, iy, ey);
    this._viewAngle !== e && (this._viewAngle = e, this._updateCamera(this._view.getCamera()));
  }
  /**
   * Gets the view angle.
   */
  getViewAngle() {
    return this._viewAngle;
  }
  /**
   * Sets the walkSpeed for walking forward, backwards, left, and right.
   * @param walkSpeed The camera will move by walkSpeed per second.
   */
  setWalkSpeed(t) {
    this._walkDistance = t;
  }
  /**
   * Gets the walkSpeed for walking forward, backwards, left, and right.
   */
  getWalkSpeed() {
    return this._walkDistance;
  }
  /**
   * Sets the elevation speed for moving the camera up and down.
   * @param elevationSpeed The camera will move by elevationSpeed per second.
   */
  setElevationSpeed(t) {
    this._elevationSpeed = t;
  }
  /**
   * Gets the elevation speed for moving the camera up and down.
   */
  getElevationSpeed() {
    return this._elevationSpeed;
  }
  /**
   * Sets the rotation speed for tilt and rotate.
   * @param rotationSpeed The camera will rotate by rotationSpeed degrees per second.
   */
  setRotationSpeed(t) {
    this._rotationSpeed = t;
  }
  /**
   * Gets the rotation speed for tilt and rotate.
   */
  getRotationSpeed() {
    return this._rotationSpeed;
  }
  /** @hidden */
  setWalkActive(t) {
    this._walkActive = t;
  }
  /**
   * Returns true if walking is currently active
   */
  getWalkActive() {
    return this._walkActive;
  }
  /**
   * Returns true if BIM mode is currently active
   */
  getBimModeEnabled() {
    return this._bimModeEnabled;
  }
  /**
   * Get major axis
   */
  getMajorAxis() {
    return this._majorAxis;
  }
  /** @hidden */
  getActiveWalk() {
    return this._activeWalk;
  }
}
class od extends Ag {
  /** @hidden */
  constructor(t, e) {
    super(t, e), this._keyWalkMapping = /* @__PURE__ */ new Map(), this._keyUpMap = /* @__PURE__ */ new Map(), this._keyDownMap = /* @__PURE__ */ new Map(), this._mouseLookSpeed = 0, this._mouseLookEnabled = !0, this._previousWalkTime = 0, this._tickTimerId = null, t.setCallbacks({
      camera: (i) => {
        i.getProjection() !== ri.Perspective && this._keyDownMap.clear();
      }
    }), this.addKeyMapping(ti.a, Re.Left), this.addKeyMapping(ti.d, Re.Right), this.addKeyMapping(ti.w, Re.Forward), this.addKeyMapping(ti.s, Re.Backward), this.addKeyMapping(ti.q, Re.RotateLeft), this.addKeyMapping(ti.e, Re.RotateRight), this.addKeyMapping(ti.r, Re.TiltUp), this.addKeyMapping(ti.f, Re.TiltDown), this.addKeyMapping(ti.x, Re.Up), this.addKeyMapping(ti.c, Re.Down), this.addKeyMapping(ti.LeftArrow, Re.Left), this.addKeyMapping(ti.RightArrow, Re.Right), this.addKeyMapping(ti.UpArrow, Re.Forward), this.addKeyMapping(ti.DownArrow, Re.Backward);
  }
  /**
   * Adds a key mapping for a walk direction.
   * @param key
   * @param walkDirection
   */
  addKeyMapping(t, e) {
    this._keyWalkMapping.set(t, e);
  }
  /**
   * Gets the walk direction key mapping.
   */
  getKeyMapping() {
    return gd(this._keyWalkMapping);
  }
  /**
   * Clears all key mappings.
   */
  clearKeyMappings() {
    this._keyWalkMapping.clear();
  }
  /** @hidden */
  onMouseDown(t) {
    super.onMouseDown(t), this._viewer.focusInput(!0);
  }
  /** @hidden */
  onMouseMove(t) {
    if (super.onMouseMove(t), this._dragging && this._mouseLookEnabled) {
      this._view.setProjectionMode(ri.Perspective);
      const e = window.screen.width, i = window.screen.height;
      t.setHandled(!0);
      const n = K.subtract(this._ptPrevious, this._ptCurrent);
      this.rotateLeft(n.x / e * this._mouseLookSpeed), this.tiltUp(n.y / i * this._mouseLookSpeed);
    }
  }
  /** @hidden */
  onMouseUp(t) {
    this._dragCount > 5 && t.setHandled(!0), super.onMouseUp(t);
  }
  /** @hidden */
  onMousewheel(t) {
    this._view.setProjectionMode(ri.Perspective);
    const e = this._view.getCamera(), i = t.getPosition(), n = t.getWheelDelta();
    this._view.pickFromPoint(i, new Si(Se.Face)).then((r) => {
      const o = r.getPosition();
      if (r !== null && o !== null) {
        const h = _.subtract(
          e.getPosition(),
          o
        ).normalize().scale(this.getZoomSpeed() * n);
        this._applyWalkDelta(e, h);
      } else
        this.walkBackward(n * this.getWalkSpeed());
    });
  }
  /** @hidden */
  onKeyDown(t) {
    this._view.setProjectionMode(ri.Perspective);
    const e = t.getKeyCode();
    e === ti.v && this.toggleBimMode(), this._keyCodeActive(e) || (this._keyDownMap.set(e, t.getDate().getTime()), this._onKeyChange(e));
  }
  /** @hidden */
  onKeyUp(t) {
    const e = t.getKeyCode();
    this._keyUpMap.set(e, t.getDate().getTime()), this._onKeyChange(e);
  }
  _keyCodeActive(t) {
    const e = this._keyDownMap.get(t);
    if (e !== void 0) {
      const i = this._keyUpMap.get(t);
      if (i === void 0 || e > i)
        return !0;
    }
    return !1;
  }
  _onKeyChange(t) {
    this._keyCodeActive(t) && this._keyWalkMapping.has(t) && (this.getWalkActive() || (this._previousWalkTime = Date.now()), this._onTick());
  }
  /**
   * Sets the speed for mouse look.
   * @param mouseLookSpeed
   */
  setMouseLookSpeed(t) {
    this._mouseLookSpeed = t;
  }
  /**
   * Gets the mouse look speed.
   */
  getMouseLookSpeed() {
    return this._mouseLookSpeed;
  }
  /**
   * Sets whether the mouse look is enabled. If enabled, mouse move events will not continue down the operator stack.
   * @param mouseLookEnabled
   */
  setMouseLookEnabled(t) {
    this._mouseLookEnabled = t;
  }
  /**
   * Gets whether the mouse look is enabled. If enabled, mouse move events will not continue down the operator stack.
   */
  getMouseLookEnabled() {
    return this._mouseLookEnabled;
  }
  async resetDefaultWalkSpeeds() {
    return super.resetDefaultWalkSpeeds().then(() => {
      this._mouseLookSpeed = 300;
    });
  }
  _execWalkDirection(t, e, i) {
    const n = this.getWalkSpeed() * e;
    switch (t) {
      case Re.Forward:
        return i ? this.walkForwardWithCollision(n) : this.walkForward(n);
      case Re.Backward:
        return i ? this.walkBackwardWithCollision(n) : this.walkBackward(n);
      case Re.Left:
        return i ? this.walkLeftWithCollision(n) : this.walkLeft(n);
      case Re.Right:
        return i ? this.walkRightWithCollision(n) : this.walkRight(n);
      case Re.Up:
        return this.walkUp(this.getElevationSpeed() * e);
      case Re.Down:
        return this.walkDown(this.getElevationSpeed() * e);
      case Re.RotateLeft:
        return this.rotateLeft(this.getRotationSpeed() * e);
      case Re.RotateRight:
        return this.rotateRight(this.getRotationSpeed() * e);
      case Re.TiltUp:
        return this.tiltUp(this.getRotationSpeed() * e);
      case Re.TiltDown:
        return this.tiltDown(this.getRotationSpeed() * e);
      default:
        $r();
    }
  }
  _queueWalkDirections(t) {
    const e = /* @__PURE__ */ new Set();
    this._keyWalkMapping.forEach((n, r) => {
      this._keyCodeActive(r) && e.add(n);
    }), ny(e);
    const i = ao(e);
    if (i.sort(), i.length > 0) {
      this.setWalkActive(!0);
      const n = this.getBimModeEnabled();
      this.getActiveWalk().set(async () => {
        const r = new Ac(1, !0);
        if (t > 0)
          for (const o of i)
            r.push(() => this._execWalkDirection(o, t, n));
        if (n && (!e.has(Re.Up) && !e.has(Re.Down) && r.push(async () => {
          await this._applyGravity();
        }), r.push(async () => {
          await this._updateNearbyDoors();
        })), !r.isIdle())
          return r.waitForIdle();
      });
    }
  }
  /** @hidden */
  _onTick() {
    const t = Date.now(), e = (t - this._previousWalkTime) / 1e3;
    this._previousWalkTime = t;
    const i = !this.getActiveWalk().isIdle();
    this.setWalkActive(i), this._queueWalkDirections(e), this._tickTimerId !== null && (cancelAnimationFrame(this._tickTimerId), this._tickTimerId = null), this.getWalkActive() && (this._tickTimerId = requestAnimationFrame(() => {
      this._onTick();
    }));
  }
}
class ay {
  /**
   * Caches a stream of points generated in time by storing them in a wrapped array, from oldest to newest. When the wrap occurs, the oldest, earliest entries are overwritten
   * @param {number} maxPoints the maximum point stream size
   */
  constructor(t = 10) {
    this._count = 0, this._points = new Array(t), this._times = new Array(t);
  }
  /**
   * Clears the array of points
   */
  clear() {
    this._count = 0;
  }
  /**
   * Adds a point to the array of points, possibly overwriting the oldest one
   */
  add(t, e = Date.now()) {
    const i = this._count % this._points.length;
    this._points[i] === void 0 ? this._points[i] = t.copy() : this._points[i].assign(t), this._times[i] = e, this._count++;
  }
  /**
   * Gets the average offset from the first point specified between (now - offset) and now
   */
  getAverageOffsetWithinMilliseconds(t, e = Date.now()) {
    let i = -1;
    const n = K.zero(), r = Math.min(this._points.length, this._count);
    if (r > 0) {
      let o = 0;
      for (let l = 0; l < r; l++) {
        const h = (this._count - 1 - l) % this._points.length;
        if (e - this._times[h] > t)
          break;
        i = h, n.add(this._points[h]), o++;
      }
      o > 1 ? (n.subtract(this._points[i]), o--, n.scale(1 / o)) : (i = -1, n.set(0, 0));
    }
    return i >= 0 ? K.subtract(n, this._points[i]) : n;
  }
}
class Tg extends Ai {
  /** @hidden */
  constructor(t, e, i) {
    super(t, e), this._cameraRotationMomentumEnabled = !1, this._isDown = !1, this._mouseDragged = !1, this._averagedMousePoints = new ay(), this._averageTimeIntervalMilliseconds = 150, this._previousMouseMovePoint = K.zero(), this._mouseMovePoint = K.zero(), this._mouseMoveOffset = K.zero(), this._previousMouseMoveTime = null, this._mouseMoveTime = null, this._mouseMoveElapsedTimeSeconds = 0, this._rotationDegreesPerSecond = [0, 0], this._animationLastTickTime = 0, this._animationElapsedTimeSeconds = 0, this._animationIntervalResult = null, this._preferredAnimationIntervalMilliseconds = 16, this._momentum = 0, this._momentumLossPerSecond = 0, this._degreesPerPixel = 0.5, this._maxRotationMagnitudeScale = 8, this._initialSelectionPosition = null, this._cameraRotateFunction = i;
  }
  getCameraRotationMomentumEnabled() {
    return this._cameraRotationMomentumEnabled;
  }
  setCameraRotationMomentumEnabled(t) {
    t !== this._cameraRotationMomentumEnabled && (this._cameraRotationMomentumEnabled = t, t || this.stopAnimation());
  }
  isCurrentlyAnimating() {
    return this._cameraRotationMomentumEnabled && this.getMomentum() > 0;
  }
  /** @hidden */
  onDeactivate() {
    return super.onDeactivate();
  }
  /** @hidden */
  onViewOrientationChange() {
    this.stopAnimation();
  }
  supportsAnimation() {
    return !0;
  }
  /** @hidden */
  onMouseDown(t) {
    super.onMouseDown(t), this.isActive() && (this._initialSelectionPosition = t.getPosition(), this._isDown = !0, this.stopAnimation(), this._mouseDragged = !1, this._previousMouseMoveTime = Date.now(), this._mouseMoveTime = this._previousMouseMoveTime, this._mouseMovePoint.assign(this._initialSelectionPosition), this._previousMouseMovePoint.assign(this._mouseMovePoint), this._averagedMousePoints.clear(), this._averagedMousePoints.add(this._mouseMovePoint, this._mouseMoveTime));
  }
  /** @hidden */
  onMouseMove(t) {
    if (super.onMouseMove(t), this.isActive()) {
      if (!this._isDown)
        return;
      this._mouseDragged = !0, this._previousMouseMovePoint.assign(this._mouseMovePoint), this._mouseMovePoint.assign(t.getPosition()), this._mouseMoveOffset = K.subtract(this._mouseMovePoint, this._previousMouseMovePoint), this._previousMouseMoveTime = this._mouseMoveTime, this._mouseMoveTime = Date.now(), this._mouseMoveElapsedTimeSeconds = this._previousMouseMoveTime === null ? 0 : (this._mouseMoveTime - this._previousMouseMoveTime) / 1e3, this._averagedMousePoints.add(this._mouseMovePoint, this._mouseMoveTime);
      const e = this._getMouseMoveOffsetForRotation();
      this._rotateCamera(e);
    }
  }
  /** @hidden */
  onMouseUp(t) {
    if (this.isActive() && (this._isDown = !1, this._mouseDragged && this.getCameraRotationMomentumEnabled())) {
      this._mouseMoveOffset = this._averagedMousePoints.getAverageOffsetWithinMilliseconds(
        this._averageTimeIntervalMilliseconds
      );
      const e = this._getMouseMoveOffsetForRotation();
      if (e[0] !== 0 || e[1] !== 0) {
        for (let i = 0; i < 2; i++) {
          const n = Math.abs(e[i]) * this._maxRotationMagnitudeScale;
          this._rotationDegreesPerSecond[i] = e[i] / this._mouseMoveElapsedTimeSeconds, this._rotationDegreesPerSecond[i] < -n ? this._rotationDegreesPerSecond[i] = -n : this._rotationDegreesPerSecond[i] > n && (this._rotationDegreesPerSecond[i] = n);
        }
        this._momentum = 1, this._startAnimation();
      } else
        this._momentum = 0;
    }
    super.onMouseUp(t);
  }
  _rotateCamera(t) {
    this._cameraRotateFunction(t);
  }
  stopAnimation() {
    this._animationIntervalResult !== null && (clearInterval(this._animationIntervalResult), this._animationIntervalResult = null);
  }
  getMomentum() {
    return this._momentum;
  }
  /**
   * Sets proportion of momentum lost per second if camera rotation momentum is enabled. At 0
   * no momentum is lost and the camera will orbit indefinitely. Above 1 the camera will stop
   * orbiting within a second of release. Only values greater than or equal to 0 are accepted.
   * @param amountLost Proportion of momentum lost per second
   */
  setMomentumLossPerSecond(t) {
    t >= 0 && (this._momentumLossPerSecond = t);
  }
  getMomentumLossPerSecond() {
    return this._momentumLossPerSecond;
  }
  isAnimating() {
    return this._animationIntervalResult !== null;
  }
  _startAnimation() {
    this._animationIntervalResult === null && (this._animationLastTickTime = Date.now(), this._animationIntervalResult = window.setInterval(() => {
      this._onTick();
    }, this._preferredAnimationIntervalMilliseconds));
  }
  _getMouseMoveOffsetForRotation() {
    return [
      -this._mouseMoveOffset.x * this._degreesPerPixel,
      this._mouseMoveOffset.y * this._degreesPerPixel
    ];
  }
  _onTick() {
    const t = Date.now();
    this._animationElapsedTimeSeconds = (t - this._animationLastTickTime) / 1e3, this._animationLastTickTime = t;
    const e = [
      this._animationElapsedTimeSeconds * this._rotationDegreesPerSecond[0],
      this._animationElapsedTimeSeconds * this._rotationDegreesPerSecond[1]
    ];
    if (this._rotateCamera(e), this._momentumLossPerSecond > 0)
      if (this._momentum = Math.max(
        0,
        this._momentum - this._animationElapsedTimeSeconds * this._momentumLossPerSecond
      ), this._momentum > 0)
        for (let i = 0; i < this._rotationDegreesPerSecond.length; i++)
          this._rotationDegreesPerSecond[i] *= this._momentum;
      else {
        for (let i = 0; i < this._rotationDegreesPerSecond.length; i++)
          this._rotationDegreesPerSecond[i] = 0;
        this._rotateCamera(this._rotationDegreesPerSecond), this.stopAnimation();
      }
  }
}
class ly extends go {
  constructor(t, e, i, n) {
    super(), this._circle = new Gr(), this._viewer = t, this._view = e, this._position = i, this._circle.setRadius(n);
  }
  draw() {
    if (this._circle) {
      const t = this._view.projectPoint(this._position);
      this._circle.setCenter(K.fromPoint3(t)), this._viewer.markupManager.getRenderer().drawCircle(this._circle);
    }
  }
}
class Ng extends Tg {
  /** @hidden */
  constructor(t, e) {
    super(t, e, (i) => {
      if (!this._viewer.sheetManager.isDrawingSheetActive())
        if (this._pickPosition !== null) {
          if (this._circleMarkupHandler === null) {
            const n = new ly(
              this._viewer,
              this._view,
              this._pickPosition,
              this._circleRadius
            );
            this._circleMarkupHandler = this._viewer.markupManager.registerMarkup(
              n,
              this._view
            );
          }
          this._orbitByTurnTiltWithTarget(i, this._pickPosition);
        } else {
          const n = this._view.getCamera();
          switch (this._orbitFallbackMode) {
            default:
            case yc.CameraTarget:
              this._orbitByTurnTiltWithTarget(i, n.getTarget());
              break;
            case yc.ModelCenter:
              this._modelCenter && this._orbitByTurnTiltWithTarget(i, this._modelCenter);
              break;
            case yc.OrbitTarget:
              this._orbitByTurnTiltWithTarget(i, this._orbitTarget);
              break;
          }
        }
    }), this._orbitTarget = _.zero(), this._orbitFallbackMode = yc.ModelCenter, this._modelCenter = _.zero(), this._circleMarkupHandler = null, this._circleRadius = 3, this._updateCameraCenterAction = new fo(!1), this._updateCameraCenterTimer = new Xo(), this._primaryButton = Ee.Middle, this._pickPosition = null, this._bimOrbitEnabled = !1, this._viewer.setCallbacks({
      sceneReady: () => {
        this._updateModelCenter();
      },
      modelSwitched: () => {
        this._updateModelCenter();
      },
      visibilityChanged: () => {
        this._updateModelCenter();
      },
      _updateTransform: (i) => {
        i || this._updateModelCenter();
      },
      _geometryCreated: () => {
        this._updateModelCenter();
      },
      hwfParseComplete: () => {
        this._updateModelCenter();
      }
    }), this._viewer.getSceneReady() && this._updateModelCenter(0);
  }
  _updateModelCenter(t = 50) {
    this._updateCameraCenterTimer.clear(), this._updateCameraCenterAction.set(async () => {
      const e = await this._viewer.model.getModelBounding(!0, !1);
      if (e.isDegenerate() && t > 0) {
        this._updateCameraCenterTimer.set(500, () => {
          this._updateModelCenter(t - 1);
        });
        return;
      }
      this._modelCenter = e.center();
    });
  }
  /** @hidden */
  async onMouseDown(t) {
    if (super.onMouseDown(t), this.isActive() && t.getButton() === this._primaryButton) {
      const e = await this._view.pickFromPoint(
        t.getPosition(),
        new Si(Se.Face)
      );
      e !== null && e.overlayIndex() === 0 ? (this._pickPosition = e.getPosition(), t.setHandled(!0)) : this._pickPosition = null;
    }
  }
  /** @hidden */
  onMouseUp(t) {
    super.onMouseUp(t), t.getButton() === this._primaryButton && (this._pickPosition = null), this._removeMarkup();
  }
  /** @hidden */
  onDeactivate() {
    const t = super.onDeactivate();
    return this._updateCameraCenterTimer.clear(), t;
  }
  /**
   * BIM orbit is intended to make orbiting building models easier.
   * It slows the rotation speed, clamps vertical rotation to 180 degrees, and restricts horizontal rotation to rotate around the vertical axis.
   * @param bimOrbitEnabled
   */
  setBimOrbitEnabled(t) {
    this._bimOrbitEnabled = t;
  }
  /**
   * Returns true if BIM orbit is enabled.
   */
  getBimOrbitEnabled() {
    return this._bimOrbitEnabled;
  }
  /** @hidden */
  _removeMarkup() {
    this._circleMarkupHandler !== null && (this._viewer.markupManager.unregisterMarkup(this._circleMarkupHandler, this._view), this._circleMarkupHandler = null);
  }
  _getClampedRotationMatrix(t, e, i, n) {
    const r = mt.createFromOffAxisRotation(t, e), o = _.zero();
    return r.transform(i, o), rg(Math.asin(_.dot(n, o))) <= 0 ? new mt() : r;
  }
  async _orbitByTurnTiltWithTarget(t, e) {
    const i = this._view, n = i.getCamera();
    let r = n.getPosition().subtract(e), o = n.getTarget().subtract(e), l = n.getUp().normalize();
    const h = _.subtract(o, r).normalize(), u = _.cross(l, h).normalize(), d = t[0], g = t[1];
    let y = new mt(), m = new mt();
    if (this._bimOrbitEnabled) {
      const I = this._viewer.model.getViewAxes().upVector.copy();
      y = this._getClampedRotationMatrix(u, g, l, I), m = mt.createFromOffAxisRotation(I, d / 4);
      const C = m.transform(y.transform(r)), P = m.transform(y.transform(o)), k = m.transform(y.transform(_.add(r, l)));
      k.subtract(C), r = C, o = P, l = k;
    } else {
      y = mt.createFromOffAxisRotation(u, g), m = mt.createFromOffAxisRotation(l, d);
      const b = mt.multiply(m, y), I = b.transform(r), C = b.transform(o), P = b.transform(_.add(r, l));
      P.subtract(I), r = I, o = C, l = P;
    }
    r.add(e), o.add(e), n.setPosition(r), n.setTarget(o), n.setUp(l), i.setCamera(n), (await this._viewer.model.getModelBounding(!1, !1)).isDegenerate() && this._viewer.view.unsetDefaultCamera();
  }
  /**
   * Sets the fallback mode. This is used to specify whether to orbit
   * around a set target, the model center, or camera target.
   */
  setOrbitFallbackMode(t) {
    this._orbitFallbackMode = t;
  }
  /**
   * Gets the orbit fallback mode.
   * @returns orbit fallback mode
   */
  getOrbitFallbackMode() {
    return this._orbitFallbackMode;
  }
  /**
   * Sets the orbit target for the orbit fallback mode OrbitTarget.
   * @param orbitTarget
   */
  setOrbitTarget(t) {
    this._orbitTarget = t;
  }
  /**
   * Gets the orbit target point.
   * @returns orbit target
   */
  getOrbitTarget() {
    return this._orbitTarget;
  }
  /**
   * Sets the primary mouse button. When this button is pressed, we will orbit around the selected point on the model.
   * If there is no selected point, the orbit fallback mode will be used for orbit.
   * @param button
   */
  setPrimaryButton(t) {
    this._primaryButton = t;
  }
  /**
   * @returns the primary orbit button
   */
  getPrimaryButton() {
    return this._primaryButton;
  }
}
class cy extends Ai {
  /** @hidden */
  constructor(t, e, i, n, r) {
    super(t, e), this._activeOperator = null, this._activeTouchCount = 0, this._touchMoveCount = 0, this._returnToOrbit = !1, this._bimNavigationEnabled = !1, this._orbitOperator = i, this._panOperator = n, this._zoomOperator = r;
  }
  /**
   * When BIM navigation is enabled, the following controls for orbit, pan, and zoom are set:
   * Left mouse button: orbit
   * Middle mouse wheel: zoom
   * Middle mouse button: pan
   * Right mouse button: zoom
   * @param bimNavigation
   */
  setBimNavigationEnabled(t) {
    this._bimNavigationEnabled = t;
    const e = this._orbitOperator, i = this._zoomOperator, n = this._panOperator;
    e.clearMapping(), i.clearMapping(), n.clearMapping(), e.setMapping(Ee.Left), e.setBimOrbitEnabled(t), i.setDollyZoomEnabled(t), t ? (e.setPrimaryButton(Ee.Left), i.setMapping(Ee.Right), n.setMapping(Ee.Middle), this._setBimCamera()) : (e.addMapping(Ee.Middle), e.setPrimaryButton(Ee.Middle), i.addMapping(Ee.Left, Ci.Shift), n.addMapping(Ee.Right), n.addMapping(Ee.Left, Ci.Control));
  }
  _setBimCamera() {
    const t = this._view.getCamera(), e = _.subtract(t.getPosition(), t.getTarget()).normalize(), n = this._viewer.model.getViewAxes().upVector.copy(), r = _.cross(e, n), o = _.cross(r, e);
    t.setUp(o), t.setProjection(ri.Perspective), this._view.setCamera(t);
  }
  /**
   * Returns true if BIM navigation is enabled.
   */
  getBimNavigationEnabled() {
    return this._bimNavigationEnabled;
  }
  /** @hidden */
  onViewOrientationChange() {
    this._activeTouchCount = 0, this._returnToOrbit = !1;
  }
  /** @hidden */
  onMouseDown(t) {
    super.onMouseDown(t), this._setActiveOperatorForMouseInput(t), this._activeOperator && (this._bimNavigationEnabled && this._setBimCamera(), this._activeOperator.onMouseDown(t));
  }
  /** @hidden */
  onMouseMove(t) {
    super.onMouseMove(t), this._activeOperator && this._dragging && this._dragCount > 3 && this._activeOperator.onMouseMove(t);
  }
  /** @hidden */
  onMouseUp(t) {
    this._activeOperator && this._activeOperator.onMouseUp(t), this._activeOperator instanceof Ng || this._orbitOperator._removeMarkup(), super.onMouseUp(t);
  }
  /** @hidden */
  async onMousewheel(t) {
    await this._zoomOperator.onMousewheel(t);
  }
  /** @hidden */
  onTouchStart(t) {
    ++this._activeTouchCount, this._orbitOperator.onTouchStart(t), this._zoomOperator.onTouchStart(t), this._viewer.sheetManager.isDrawingSheetActive() && (this._panOperator.onTouchStart(t), this._orbitOperator.onDeactivate()), this._activeTouchCount === 1 && (this._primaryTouchId = t.getId()), this._activeTouchCount === 2 && (this._orbitOperator.onDeactivate(), this._panOperator.onTouchStart(t), this._zoomOperator.onTouchStart(t));
  }
  /** @hidden */
  async onTouchMove(t) {
    ++this._touchMoveCount, this._touchMoveCount > 5 && (this._returnToOrbit ? (this._orbitOperator.onTouchStart(t), this._returnToOrbit = !1) : this._activeTouchCount === 1 ? (await this._orbitOperator.onTouchMove(t), await this._zoomOperator.onTouchMove(t), await this._panOperator.onTouchMove(t)) : this._activeTouchCount === 2 && (await this._zoomOperator.onTouchMove(t), await this._panOperator.onTouchMove(t)));
  }
  /** @hidden */
  onTouchEnd(t) {
    this._activeTouchCount === 2 && (this._returnToOrbit = !0), this._zoomOperator.onTouchEnd(t), this._panOperator.onTouchEnd(t), this._orbitOperator.onTouchEnd(t), this._activeTouchCount > 0 && --this._activeTouchCount, this._activeTouchCount === 0 && (this._touchMoveCount = 0);
  }
  /** @hidden */
  stopInteraction() {
    const t = [];
    let e;
    return e = super.stopInteraction(), e !== void 0 && t.push(e), this._activeTouchCount = 0, this._touchMoveCount = 0, e = this._zoomOperator.onDeactivate(), e !== void 0 && t.push(e), e = this._panOperator.onDeactivate(), e !== void 0 && t.push(e), e = this._orbitOperator.onDeactivate(), e !== void 0 && t.push(e), Ge(t);
  }
  _setActiveOperatorForMouseInput(t) {
    const e = this._orbitOperator, i = this._panOperator, n = this._zoomOperator;
    this._activeOperator = null, this._viewer.sheetManager.isDrawingSheetActive() ? this._activeOperator = i : e.checkMapping(t) ? this._activeOperator = e : n.checkMapping(t) ? this._activeOperator = n : i.checkMapping(t) && (this._activeOperator = i);
  }
  /** @hidden */
  onDeactivate() {
    super.onDeactivate(), this._orbitOperator.onDeactivate(), this._panOperator.onDeactivate(), this._zoomOperator.onDeactivate();
  }
}
class hy extends Ai {
  /** @hidden */
  constructor(t, e) {
    super(t, e), this._cameraPtPrevious = _.zero();
  }
  /** @hidden */
  onMouseDown(t) {
    if (super.onMouseDown(t), this.isActive() || this._viewer.sheetManager.isDrawingSheetActive()) {
      const e = this._view, n = e.getCamera().getCameraPlaneIntersectionPoint(t.getPosition(), e);
      n && this._cameraPtPrevious.assign(n);
    }
  }
  /** @hidden */
  onMouseMove(t) {
    if (super.onMouseMove(t), this.isActive() || this._viewer.sheetManager.isDrawingSheetActive()) {
      const e = this._view, i = e.getCamera(), n = i.getCameraPlaneIntersectionPoint(t.getPosition(), e);
      if (n) {
        const r = _.subtract(n, this._cameraPtPrevious);
        i.dolly(r), e.setCamera(i);
      }
    }
  }
}
class uy extends Tg {
  /** @hidden */
  constructor(t, e) {
    super(t, e, (i) => {
      this._rotateAroundAxis(this._rotationAxis, i[0]);
    }), this._rotationAxis = new _(0, 0, 1), this._tiltAmount = 12;
  }
  async _rotateAroundAxis(t, e) {
    const i = this._view, n = i.getCamera(), r = n.getPosition(), o = n.getUp().normalize(), l = n.getTarget(), h = mt.createFromOffAxisRotation(t, e), u = new mt().setTranslationComponent(-l.x, -l.y, -l.z), d = mt.multiply(u, h), g = new mt().setTranslationComponent(l.x, l.y, l.z);
    mt.multiply(d, g).transform(r, r), h.transform(o, o), o.normalize(), n.setPosition(r), n.setUp(o), i.setCamera(n), (await this._viewer.model.getModelBounding(!1, !1)).isDegenerate() && this._viewer.view.unsetDefaultCamera();
  }
  /** @hidden */
  onMousewheel(t) {
    const e = t.getWheelDelta(), i = this._view.getCamera(), n = i.getUp().normalize(), r = _.subtract(i.getTarget(), i.getPosition()).normalize(), o = _.cross(n, r).normalize();
    e > 0 ? this._rotateAroundAxis(o, this._tiltAmount) : this._rotateAroundAxis(o, -this._tiltAmount);
  }
  _axisToPoint3(t) {
    let e = null;
    switch (t) {
      case Qe.X:
        e = new _(1, 0, 0);
        break;
      case Qe.Y:
        e = new _(0, 1, 0);
        break;
      case Qe.Z:
        e = new _(0, 0, 1);
        break;
    }
    return e;
  }
  /**
   * Sets the rotation axis.
   * @param axis [[Axis]] or [[Point3]] used to set the rotation axis.
   */
  setRotationAxis(t) {
    let e = null;
    return t instanceof _ ? e = t : e = this._axisToPoint3(t), e !== null ? (this._rotationAxis.assign(e), !0) : !1;
  }
}
class dy {
  /** @hidden */
  constructor(t, e, i) {
    this._keyboardWalkOperator = i, this._walkOperator = e, this._activeOperator = e, this._walkMode = wc.Mouse, this._active = !1;
  }
  /**
   * Sets the walk mode to Mouse or Keyboard.
   * @param walkMode
   */
  async setWalkMode(t) {
    this._walkMode !== t && (this._walkMode = t, t === wc.Keyboard ? (this._activeOperator = this._keyboardWalkOperator, this._active && (await this._walkOperator.onDeactivate(), await this._keyboardWalkOperator.onActivate())) : (this._activeOperator = this._walkOperator, this._active && (await this._keyboardWalkOperator.onDeactivate(), await this._walkOperator.onActivate())));
  }
  /**
   * Gets the walk mode.
   * @returns Keyboard or Mouse
   */
  getWalkMode() {
    return this._activeOperator instanceof od ? wc.Keyboard : wc.Mouse;
  }
  /** @hidden */
  onMouseDown(t) {
    this._activeOperator.onMouseDown(t);
  }
  /** @hidden */
  onMouseMove(t) {
    this._activeOperator.onMouseMove(t);
  }
  /** @hidden */
  onMouseUp(t) {
    this._activeOperator.onMouseUp(t);
  }
  /** @hidden */
  onMousewheel(t) {
    this._activeOperator.onMousewheel(t);
  }
  /** @hidden */
  onTouchStart(t) {
    this._activeOperator.onTouchStart(t);
  }
  /** @hidden */
  async onTouchMove(t) {
    await this._activeOperator.onTouchMove(t);
  }
  /** @hidden */
  onTouchEnd(t) {
    this._activeOperator.onTouchEnd(t);
  }
  /** @hidden */
  onKeyDown(t) {
    this._activeOperator.onKeyDown(t);
  }
  /** @hidden */
  onKeyUp(t) {
    this._activeOperator instanceof od && this._activeOperator.onKeyUp(t);
  }
  /** @hidden */
  onDeactivate() {
    return this._activeOperator.onDeactivate();
  }
  /** @hidden */
  onActivate() {
    return this._active = !0, this._activeOperator.onActivate();
  }
  /** @hidden */
  onViewOrientationChange() {
    this._active = !1;
  }
  /** @hidden */
  stopInteraction() {
    return this._activeOperator.stopInteraction();
  }
  /**
   * Sets BIM mode enables/disabled on both mouse and keyboard walk
   */
  async setBimModeEnabled(t) {
    const e = [];
    return t ? (e.push(this._keyboardWalkOperator.enableBimMode()), e.push(this._walkOperator.enableBimMode())) : (e.push(this._keyboardWalkOperator.disableBimMode()), e.push(this._walkOperator.disableBimMode())), Promise.all(e).then(() => {
    });
  }
  /**
   * Resets speeds to defaults on both mouse and keyboard walk
   */
  async resetDefaultWalkSpeeds() {
    return Promise.all([
      this._walkOperator.resetDefaultWalkSpeeds(),
      this._keyboardWalkOperator.resetDefaultWalkSpeeds()
    ]).then(() => {
    });
  }
  /**
   * Sets BIM floor config on both mouse and keyboard walk
   */
  setBimFloorConfig(t) {
    this._walkOperator.setBimFloorConfig(t), this._keyboardWalkOperator.setBimFloorConfig(t);
  }
  /**
   * Sets BIM wall config on both mouse and keyboard walk
   */
  setBimWallConfig(t) {
    this._walkOperator.setBimWallConfig(t), this._keyboardWalkOperator.setBimWallConfig(t);
  }
  /**
   * Sets BIM door config on both mouse and keyboard walk
   */
  setBimDoorConfig(t) {
    this._walkOperator.setBimDoorConfig(t), this._keyboardWalkOperator.setBimDoorConfig(t);
  }
  /**
   * Sets zoom speed on both mouse and keyboard walk
   */
  setZoomSpeed(t) {
    this._walkOperator.setZoomSpeed(t), this._keyboardWalkOperator.setZoomSpeed(t);
  }
  /**
   * Sets walk speed for both mouse and keyboard walk
   */
  setWalkSpeed(t) {
    this._walkOperator.setWalkSpeed(t), this._keyboardWalkOperator.setWalkSpeed(t);
  }
  /**
   * Sets elevation speed for both mouse and keyboard walk
   */
  setElevationSpeed(t) {
    this._walkOperator.setElevationSpeed(t), this._keyboardWalkOperator.setElevationSpeed(t);
  }
  /**
   * Sets rotation speed for both mouse and keyboard walk
   */
  setRotationSpeed(t) {
    this._walkOperator.setRotationSpeed(t), this._keyboardWalkOperator.setRotationSpeed(t);
  }
  /**
   * Sets view angle (FOV) for both mouse and keyboard walk operators
   */
  setViewAngle(t) {
    this._walkOperator.setViewAngle(t), this._keyboardWalkOperator.setViewAngle(t);
  }
}
class fy extends Ag {
  /** @hidden */
  constructor(t, e) {
    super(t, e), this._timerId = null, this._walkButton = Ee.None, this._previousTimestamp = 0, this._activeTouchCount = 0, this._maxDistance = 200;
  }
  /** @hidden */
  async onActivate() {
    await super.onActivate(), this._viewer.trigger("walkOperatorActivated");
  }
  /** @hidden */
  onKeyDown(t) {
    const e = t.getKeyCode(), i = this.getWalkSpeed();
    e === ti.PgUp && this.setWalkSpeed(i * 1.2), e === ti.PgDown && this.setWalkSpeed(i * 0.8), e === ti.v && this.toggleBimMode();
  }
  /** @hidden */
  async onDeactivate() {
    const t = this._resetCameraTarget();
    return this.stopWalking(), await super.onDeactivate(), this._viewer.trigger("walkOperatorDeactivated"), t;
  }
  // This can resolve issues that arise if the user activates a CAD view while walking that may change the projection mode.
  _checkProjection() {
    const t = this._view;
    t.getProjectionMode() !== ri.Perspective && (t.setProjectionMode(ri.Perspective), this._calculateInitialPosition());
  }
  /** @hidden */
  onMouseDown(t) {
    super.onMouseDown(t), this._checkProjection(), this.isActive() && (this.stopWalking(), this.setWalkActive(!0), this._walkButton = t.getButton());
  }
  /** @hidden */
  onMouseMove(t) {
    super.onMouseMove(t), this.getWalkActive() && this._timerId === null && this.isActive() && (this._previousTimestamp = Date.now(), this._onTick());
  }
  /** @hidden */
  onMouseUp(t) {
    this.isActive() && this.stopWalking(), super.onMouseUp(t);
  }
  /** @hidden */
  onTouchStart(t) {
    super.onTouchStart(t), ++this._activeTouchCount, this._activeTouchCount === 1 ? this._walkButton = Ee.Left : this._activeTouchCount === 2 ? this._walkButton = Ee.Right : this._activeTouchCount === 3 && (this._walkButton = Ee.None);
  }
  /** @hidden */
  async onTouchMove(t) {
    if (this._activeTouchCount === 3 && this._primaryTouchId === t.getId()) {
      this._ptCurrent.assign(t.getPosition());
      const e = K.subtract(this._ptCurrent, this._ptPrevious);
      this._adjustTilt(e.y / 100 * 1.5);
    } else
      this._activeTouchCount < 3 && await super.onTouchMove(t);
    return Promise.resolve();
  }
  /** @hidden */
  onTouchEnd(t) {
    super.onTouchEnd(t), this._activeTouchCount > 0 && --this._activeTouchCount;
  }
  /** @hidden */
  onMousewheel(t) {
    this._checkProjection(), t.getWheelDelta() > 0 ? this._adjustTilt(3) : this._adjustTilt(-3);
  }
  /** @hidden */
  stopWalking() {
    this._timerId !== null && (cancelAnimationFrame(this._timerId), this._timerId = null), this.setWalkActive(!1);
  }
  /** @hidden */
  async _testWalk(t, e, i, n = Me.Default) {
    const r = new Wr(
      0,
      0,
      i,
      ys.None,
      Ci.None,
      mr.Down,
      n
    ), o = new Wr(
      0,
      t,
      i,
      ys.None,
      Ci.None,
      mr.Move,
      n
    ), l = new Wr(
      0,
      t,
      i,
      ys.None,
      Ci.None,
      mr.Up,
      n
    );
    this.onMouseDown(r), this.onMouseMove(o), await md(e), this.onMouseUp(l);
  }
  /** @hidden */
  _onTick() {
    const t = Date.now(), e = (t - this._previousTimestamp) / 1e3;
    this._previousTimestamp = t;
    const i = this._view, n = K.subtract(this._ptCurrent, this._ptFirst), r = new K(
      Math.abs(n.x) / this._maxDistance,
      Math.abs(n.y) / this._maxDistance
    ), o = this.getRotationSpeed() * e * r.x, l = this.getWalkSpeed() * e * r.y, h = this.getElevationSpeed() * e * r.x, u = this.getElevationSpeed() * e * r.y;
    if (this._walkButton === Ee.Left) {
      if (n.x !== 0 && (n.x > 0 ? this.rotateRight(o) : n.x < 0 && this.rotateLeft(o)), n.y !== 0) {
        const d = i.getCamera();
        this._resetPosition(d);
        const g = d.getTarget(), y = d.getPosition(), m = _.subtract(g, y).normalize(), x = d.getUp();
        let b = _.scale(m, l);
        n.y > 0 && (b = b.negate()), this.setWalkActive(!0);
        const I = this.getBimModeEnabled();
        this.getActiveWalk().set(async () => {
          if (I)
            await this._applyWalkDeltaWithCollisionCheck(d, b, x), await this._applyGravity(), await this._updateNearbyDoors();
          else
            return this._applyWalkDelta(d, b);
        });
      }
    } else
      (this._walkButton === Ee.Right || this._walkButton === Ee.Middle) && (Math.abs(n.y) > 0 && (n.y > 0 ? this.walkUp(u) : this.walkDown(u)), Math.abs(n.x) > 0 && (n.x > 0 ? this.walkRight(h) : this.walkLeft(h)));
    this._timerId = requestAnimationFrame(() => {
      this._onTick();
    });
  }
  _adjustTilt(t) {
    const e = this._view;
    this.setTilt(this.getTilt() + t);
    const i = e.getCamera();
    this._resetPosition(i);
    const n = i.getTarget(), r = i.getPosition(), o = _.distance(n, r), l = i.getUp().normalize(), h = _.subtract(n, r).normalize(), u = _.cross(l, h).normalize();
    mt.createFromOffAxisRotation(u, this.getTilt()).transform(h, h), h.normalize().scale(o), i.setTarget(_.add(r, h)), e.setCamera(i);
  }
  async _resetCameraTarget() {
    const t = this._view, e = t.getCanvasSize(), i = new K(Math.round(e.x / 2), Math.round(e.y / 2)), n = new Si(), r = await t.pickFromPoint(i, n);
    if (r.isEntitySelection()) {
      const o = t.getCamera();
      o.setTarget(r.getPosition()), t.updateCamera(o);
    }
  }
}
class Rn extends go {
  /** @hidden */
  constructor(t) {
    super(), this._stage = 0, this._finalized = !1, this._uniqueId = "", this._positions = [], this._name = "", this._measurementValue = 0, this._unitMultiplier = 1, this._textShape = new Fl(), this._visibility = !0, this._positions = [], this._lineShapes = [], this._viewer = t;
  }
  /**
   * Gets the name of this measurement.
   * @returns the measurement name
   */
  getName() {
    return this._name;
  }
  /**
   * Sets the name of this measurement
   * @param name the name to set
   */
  setName(t) {
    this._name = t;
  }
  /** @hidden */
  _getStage() {
    return this._stage;
  }
  /** @hidden */
  _nextStage() {
    this._stage++;
  }
  /** @hidden */
  _setId(t) {
    this._uniqueId = t;
  }
  /** @hidden */
  _getId() {
    return this._uniqueId;
  }
  /** @hidden */
  adjust(t) {
  }
  /** @hidden */
  _isFinalized() {
    return this._finalized;
  }
  /** @hidden */
  update() {
  }
  /** @hidden */
  draw() {
    this.update();
  }
  setVisibility(t) {
    this._visibility = t, this.draw(), t ? this._viewer.trigger("measurementShown", this) : this._viewer.trigger("measurementHidden", this);
  }
  getVisibility() {
    return this._visibility;
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return {};
  }
  /**
   * Returns the unit agnostic value for this measurement.
   * In the case where this value represents distance, use [[getUnitMultiplier]] to determine the measurement units.
   * In other cases, this value will be the angle measurement in degrees.
   * @returns the measurement value
   */
  getMeasurementValue() {
    return this._measurementValue;
  }
  /**
   * Returns the unit multiplier incorporated into the measurement value.
   * This number is a multiplier of millimeters (for example inches will be `25.4`).
   * The default value is `1.0`.
   */
  getUnitMultiplier() {
    return this._unitMultiplier;
  }
  /**
   * Sets the measurement text that is rendered with this measurement.
   * @param measurementText the text to render with this measurement
   */
  setMeasurementText(t) {
    this._textShape.setTextString(t);
  }
  /**
   * Gets the text for this measurement. By default this will contain the measurement value and units for the model in the cases where the measurement is a distance.
   * In other cases it will contain the angle in degrees.
   */
  getMeasurementText() {
    return this._textShape.getTextString();
  }
  /**
   * Returns whether the measurement markup is valid. Override in subclasses when needed.
   */
  isMarkupValid() {
    return !0;
  }
  /** @hidden */
  _setMeasurementValue(t) {
    this._measurementValue = t / this._unitMultiplier, this.setMeasurementText($c(this._measurementValue, this._unitMultiplier)), this._viewer.trigger("measurementValueSet", this);
  }
  /** @hidden */
  static _serializePointArray(t) {
    const e = [];
    for (const i of t)
      e.push(i.toJson());
    return e;
  }
  /** @hidden */
  static _constructPointArray(t) {
    const e = [];
    for (const i of t) {
      const n = _.fromJson(i);
      e.push(n);
    }
    return e;
  }
}
class Dg extends Rn {
  constructor(t, e) {
    super(t), this._rectangle = new vd(), this._markupHandle = null, this._dim = new K(0, 0), this.initialPosition = new K(0, 0), this.currentPosition = new K(0, 0), this.min = new K(0, 0), this.max = new K(0, 0), this._name = "_RectangleMarkup", this._rectangle.setFillOpacity(0), this._rectangle.setStrokeColor(vt.red()), this._constantStrokeColor = e;
  }
  draw() {
    this._viewer.markupManager.getRenderer().drawRectangle(this._rectangle);
  }
  updateCurrentPosition(t) {
    if (this.currentPosition.assign(t), this._constantStrokeColor || this._rectangle.setStrokeColor(
      this.initialPosition.x < this.currentPosition.x ? vt.red() : vt.blue()
    ), this.min.assign(this.initialPosition), this.max.assign(this.currentPosition), this.max.x < this.min.x) {
      const e = this.max.x;
      this.max.x = this.min.x, this.min.x = e;
    }
    if (this.max.y < this.min.y) {
      const e = this.max.y;
      this.max.y = this.min.y, this.min.y = e;
    }
    this._dim.assign(this.max), this._dim.subtract(this.min), this._updateRectangleVertices();
  }
  _updateRectangleVertices() {
    this._rectangle.setPosition(this.min), this._rectangle.setSize(this._dim);
  }
  activate(t) {
    this.initialPosition.assign(t), this.currentPosition.assign(t), this.min.assign(t), this.max.assign(t), this._dim.set(0, 0), this._rectangle.setStrokeWidth(1), this._updateRectangleVertices();
    const e = this._viewer.markupManager;
    this._markupHandle = e.registerMarkup(this, this._viewer.view);
  }
  deactivate() {
    this.initialPosition.set(0, 0), this.currentPosition.set(0, 0), this.min.set(0, 0), this.max.set(0, 0), this._dim.set(0, 0), this._rectangle.setStrokeWidth(0), this._updateRectangleVertices();
    const t = this._viewer.markupManager;
    this._markupHandle !== null && (t.unregisterMarkup(this._markupHandle, this._viewer.view), this._markupHandle = null), t.refreshMarkup(this._viewer.view);
  }
  isActive() {
    return this._markupHandle !== null;
  }
}
class gy extends Ai {
  /** @hidden */
  constructor(t, e) {
    super(t, e), this._rectangleMarkup = new Dg(t, !0), this._computeTarget = !1, this._preserveViewAngle = !0;
  }
  /**
   * When enabled, the camera target will be computed using selection while zooming.
   * This can provide a better zoom behavior in perspective projection mode,
   * but comes at the cost of performing a selection on the model during each zoom operation,
   * which may not be ideal for performance on large models.
   *
   * This setting is disabled by default.
   */
  setComputeTarget(t) {
    this._computeTarget = t;
  }
  /**
   * Returns whether a new camera target will be computed using selection.
   * See [[setComputeTarget]]
   */
  getComputeTarget() {
    return this._computeTarget;
  }
  /**
   * Sets whether to maintain a constant view angle while zooming. If
   * enabled, when zooming causes the camera's field of view to shrink or
   * grow, the camera's position will also be moved toward or away from
   * the target, respectively.
   *
   * This may prevent confusing camera behavior when perspective
   * projection is used or might be used. When using only orthographic
   * projection, it is better to disable this.
   *
   * If window zoom is being using in conjunction with mouse wheel zoom
   * this setting should be the same in both.
   *
   * This setting is enabled by default.
   */
  setPreserveViewAngle(t) {
    this._preserveViewAngle = t;
  }
  /**
   * Gets whether to maintain a constant view angle while zooming. See
   * [[setPreserveViewAngle]].
   */
  getPreserveViewAngle() {
    return this._preserveViewAngle;
  }
  adjustPositionToPlane(t, e) {
    const n = this._view.getCamera().getViewMatrix(this._viewer), r = n.transform(e), o = n.transform(t);
    r.z = o.z;
    const l = mt.inverse(n);
    return l === null ? null : l.transform(r);
  }
  computeNewField(t, e, i) {
    const n = K.add(t, K.scale(K.subtract(e, t), 0.5)), r = new K(e.x, n.y), o = new K(n.x, e.y), l = new K(t.x, n.y), h = new K(n.x, t.y), u = this._view.getCamera(), d = u.getCameraPlaneIntersectionPoint(r, this._view), g = u.getCameraPlaneIntersectionPoint(o, this._view), y = u.getCameraPlaneIntersectionPoint(l, this._view), m = u.getCameraPlaneIntersectionPoint(h, this._view);
    if (d === null || g === null || y === null || m === null)
      return null;
    const x = this.adjustPositionToPlane(i, d), b = this.adjustPositionToPlane(i, g), I = this.adjustPositionToPlane(i, y), C = this.adjustPositionToPlane(i, m);
    if (x === null || b === null || I === null || C === null)
      return null;
    const P = _.subtract(x, I), k = _.subtract(b, C);
    return [P.length(), k.length()];
  }
  async computeReasonableTarget(t, e) {
    const i = K.add(t, K.scale(K.subtract(e, t), 0.5)), n = await this._view.pickFromPoint(i, new Si());
    if (n.getNodeId() !== null)
      return n.getPosition();
    {
      let r = 0;
      const o = _.zero(), l = await this._view.beginScreenSelectByArea(
        t,
        e,
        new xd()
      );
      for (; ; ) {
        const d = await this._view.advanceIncrementalSelection(l);
        if (d === null)
          break;
        for (const g of d) {
          const y = g.getPosition();
          y !== null && (o.add(y), r++);
        }
      }
      let u = this._view.getCamera().getCameraPlaneIntersectionPoint(i, this._view);
      if (u === null)
        return null;
      if (r !== 0) {
        const d = _.scale(o, 1 / r);
        u = this.adjustPositionToPlane(d, u);
      }
      return u;
    }
  }
  async getCameraTarget(t, e) {
    if (this._computeTarget)
      return this.computeReasonableTarget(t, e);
    const i = this._view.getCamera(), n = K.add(t, K.scale(K.subtract(e, t), 0.5));
    return i.getCameraPlaneIntersectionPoint(n, this._view);
  }
  async doZoom(t, e) {
    const i = this._view.getCamera(), n = i.copy(), r = i.getTarget(), o = await this.getCameraTarget(t, e);
    if (o === null)
      return;
    const l = this.computeNewField(t, e, o);
    if (l === null)
      return;
    const [h, u] = l, d = this._view.getCanvasSize(), g = new K(0, 0), y = _.distance(
      i.getCameraPlaneIntersectionPoint(d, this._view),
      i.getCameraPlaneIntersectionPoint(g, this._view)
    );
    n.setWidth(h), n.setHeight(u), n.setTarget(o), this._viewer.pauseRendering(() => {
      this._view.setCamera(n);
      const m = _.subtract(r, i.getPosition());
      let x;
      if (this._preserveViewAngle) {
        const b = _.distance(
          n.getCameraPlaneIntersectionPoint(d, this._view),
          n.getCameraPlaneIntersectionPoint(g, this._view)
        ), I = m.length() / y;
        x = _.add(
          o,
          _.scale(m.negate().normalize(), I * b)
        );
      } else
        x = _.subtract(o, m);
      n.setPosition(x), this._view.setCamera(n);
    });
  }
  /** @hidden */
  onMouseDown(t) {
    super.onMouseDown(t), this.isActive() && (t.setHandled(!0), this._rectangleMarkup.isActive() && this._rectangleMarkup.deactivate(), this._rectangleMarkup.activate(t.getPosition()));
  }
  /** @hidden */
  onMouseMove(t) {
    super.onMouseMove(t), this.isActive() && this._rectangleMarkup.isActive() && (t.setHandled(!0), this._rectangleMarkup.updateCurrentPosition(t.getPosition()), this._viewer.markupManager.refreshMarkup(this._view));
  }
  /** @hidden */
  async onMouseUp(t) {
    if (this.isActive() && this._rectangleMarkup.isActive()) {
      const e = this._rectangleMarkup;
      if (e.updateCurrentPosition(t.getPosition()), K.subtract(e.max, e.min).length() <= 3) {
        e.deactivate();
        return;
      }
      t.setHandled(!0), await this.doZoom(e.min, e.max);
    }
    this._rectangleMarkup.isActive() && this._rectangleMarkup.deactivate(), super.onMouseUp(t);
  }
}
class py extends Ai {
  /** @hidden */
  constructor(t, e) {
    super(t, e), this._mouseMoveZoomDelta = 3, this._mouseWheelZoomDelta = 0.25, this._pinchZoomModifier = 2.5, this._zoomToMousePosition = !0, this._dollyZoomEnabled = !1, this._adjustCameraTarget = !1, this._preserveViewAngle = !0, this._mouseMoveZoomFactor = 1, this._mouseWheelZoomFactor = -1, this._secondaryTouchId = null, this._lastTouch1 = K.zero(), this._lastTouch2 = K.zero(), this._prevLen = 0;
  }
  /**
   * When true, scrolling up will zoom towards the model.
   * @param inverted
   */
  setMouseWheelZoomInverted(t) {
    t ? this._mouseWheelZoomFactor = -1 : this._mouseWheelZoomFactor = 1;
  }
  getMouseWheelZoomInverted() {
    return this._mouseWheelZoomFactor === -1;
  }
  /**
   * When true, moving the mouse up will zoom towards the model.
   * @param inverted
   */
  setMouseMoveZoomInverted(t) {
    t ? this._mouseMoveZoomFactor = -1 : this._mouseMoveZoomFactor = 1;
  }
  getMouseMoveZoomInverted() {
    return this._mouseMoveZoomFactor === -1;
  }
  /**
   * Sets the delta to zoom when moving the mouse
   * @param delta
   */
  setMouseMoveZoomDelta(t) {
    this._mouseMoveZoomDelta = t;
  }
  /**
   * Gets the mouse move zoom delta
   * @returns number
   */
  getMouseMoveZoomDelta() {
    return this._mouseMoveZoomDelta;
  }
  /**
   * Sets the delta to zoom when scrolling
   * @param delta
   */
  setMouseWheelZoomDelta(t) {
    this._mouseWheelZoomDelta = t;
  }
  /**
   * Gets the scrollwheel zoom delta
   * @returns number
   */
  getMouseWheelZoomDelta() {
    return this._mouseWheelZoomDelta;
  }
  /**
   * When set, the zoom will be towards the mouse position. When not set, the zoom will be from the center of the screen.
   * @param zoom
   */
  setZoomToMousePosition(t) {
    this._zoomToMousePosition = t;
  }
  /**
   * @returns boolean When true, the zoom will be towards the mouse position. When false, the zoom will be towards the center of the screen.
   */
  getZoomToMousePosition() {
    return this._zoomToMousePosition;
  }
  /**
   * When dolly zoom is enabled, the camera position will move towards the camera target when zooming.
   * @moveCameraPositon
   */
  setDollyZoomEnabled(t) {
    this._dollyZoomEnabled = t;
  }
  /**
   * Returns true if dolly zoom is enabled.
   */
  getDollyZoomEnabled() {
    return this._dollyZoomEnabled;
  }
  /**
   * When enabled, the camera target will be updated to the selection position while zooming.
   * This can provide a better zoom behavior in perspective projection mode,
   * but comes at the cost of performing a selection on the model during each mouse scroll,
   * which may not be ideal for performance on large models.
   *
   * This setting is disabled by default.
   */
  setMouseWheelAdjustCameraTarget(t) {
    this._adjustCameraTarget = t;
  }
  /**
   * Returns whether the camera target will be updated to the selection
   * position while zooming. See [[setMouseWheelAdjustCameraTarget]].
   */
  getMouseWheelAdjustCameraTarget() {
    return this._adjustCameraTarget;
  }
  /**
   * Sets whether to maintain a constant view angle while zooming. If
   * enabled, when zooming causes the camera's field of view to shrink or
   * grow, the camera's position will also be moved toward or away from
   * the target, respectively.
   *
   * This may prevent confusing camera behavior when perspective
   * projection is used or might be used. When using only orthographic
   * projection, it is better to disable this.
   *
   * If mouse wheel zoom is being using in conjunction with window zoom
   * this setting should be the same in both.
   *
   * This setting is enabled by default.
   */
  setPreserveViewAngle(t) {
    this._preserveViewAngle = t;
  }
  /**
   * Gets whether to maintain a constant view angle while zooming. See
   * [[setPreserveViewAngle]].
   */
  getPreserveViewAngle() {
    return this._preserveViewAngle;
  }
  /** @hidden */
  async onMouseMove(t) {
    if (super.onMouseMove(t), this.isDragging() && this.isActive()) {
      const e = this._view, i = e.pointToWindowPosition(this._ptCurrent), n = e.pointToWindowPosition(this._ptPrevious), r = i.y - n.y, o = i.x - n.x, l = this._mouseMoveZoomDelta * this._mouseMoveZoomFactor * (r - o);
      this._dollyZoomEnabled ? await this._dollyZoom(l, void 0, void 0, !0) : await this._doZoom(l);
    }
  }
  /** @hidden */
  async onMousewheel(t) {
    const e = this._mouseWheelZoomDelta * this._mouseWheelZoomFactor * t.getWheelDelta();
    this._dollyZoomEnabled ? await this._dollyZoom(-e, void 0, t.getPosition()) : await this._doZoom(e, void 0, t.getPosition());
  }
  /** @hidden */
  onTouchStart(t) {
    const e = this._view;
    this._primaryTouchId === null ? (this._primaryTouchId = t.getId(), this._lastTouch1.assign(e.pointToWindowPosition(t.getPosition()))) : this._secondaryTouchId === null && (this._secondaryTouchId = t.getId(), this._lastTouch2.assign(e.pointToWindowPosition(t.getPosition()))), this._primaryTouchId !== null && this._secondaryTouchId !== null && (this._prevLen = K.subtract(this._lastTouch2, this._lastTouch1).length(), this._dragging = !0);
  }
  /** @hidden */
  onTouchMove(t) {
    const e = this._view, i = t.getId(), n = t.getPosition();
    if (i === this._primaryTouchId ? this._lastTouch1.assign(e.pointToWindowPosition(n)) : i === this._secondaryTouchId && this._lastTouch2.assign(e.pointToWindowPosition(n)), this._dragging && (i === this._primaryTouchId || i === this._secondaryTouchId)) {
      const r = K.subtract(this._lastTouch2, this._lastTouch1).length(), l = 1 / (1 - (this._prevLen - r) * this._pinchZoomModifier);
      this._zoomHelper(l, this._view.getCamera()), this._prevLen = r;
    }
    return Promise.resolve();
  }
  /** @hidden */
  onTouchEnd(t) {
    const e = t.getId();
    this._primaryTouchId === e ? this._primaryTouchId = null : this._secondaryTouchId === e && (this._secondaryTouchId = null), this._dragging = !1;
  }
  /** @hidden */
  onDeactivate() {
    this._primaryTouchId = null, this._secondaryTouchId = null;
  }
  _updateCameraViewAngle(t) {
    const e = Fo(90), i = Math.tan(e / 2), r = _.subtract(t.getTarget(), t.getPosition()).length() * i;
    return t.setWidth(r), t.setHeight(r), t;
  }
  async _dollyZoom(t, e = this._view.getCamera(), i, n = !1) {
    const r = this._view;
    e.setProjection(ri.Perspective);
    const o = e.getPosition(), l = e.getTarget();
    if (i) {
      const d = (await this._viewer.model.getModelBounding(!1, !1, !1)).extents().length() / 100, y = (await this._view.pickFromPoint(i, new Si())).getPosition();
      if (y !== null) {
        const x = _.subtract(l, o), b = _.subtract(y, o), I = _.add(o, x.scale(_.dot(x, b) / _.dot(x, x)));
        e.setTarget(I);
      }
      let m = _.subtract(e.getTarget(), o);
      t > 0 && m.length() < d && e.setTarget(
        _.add(
          l,
          m.copy().normalize().scale(d * 2)
        )
      ), m = _.subtract(e.getTarget(), o), e.setPosition(_.add(o, m.copy().scale(t / 10)));
    } else {
      const h = _.subtract(l, o).scale(t / 10);
      e.setPosition(_.add(o, h)), n && e.setTarget(_.add(l, h));
    }
    e = this._updateCameraViewAngle(e), this._viewer.pauseRendering(() => {
      if (i) {
        const h = e.getCameraPlaneIntersectionPoint(i, this._view);
        r.setCamera(e);
        const u = e.getCameraPlaneIntersectionPoint(
          i,
          this._view
        );
        h !== null && u !== null && e.dolly(_.subtract(u, h));
      }
      r.setCamera(e);
    });
  }
  async _doZoom(t, e = this._view.getCamera(), i) {
    const n = this._view, r = Math.max(1 / (1 - t), 1e-3);
    if (i && this._zoomToMousePosition) {
      if (this._adjustCameraTarget) {
        const o = await this._view.pickFromPoint(i, new Si());
        if (o !== void 0 && o.isEntitySelection()) {
          const l = e.getPosition().subtract(e.getTarget()), h = _.subtract(e.getTarget(), e.getPosition()), u = _.subtract(o.getPosition(), e.getPosition()), d = e.getPosition().add(h.scale(_.dot(h, u) / _.dot(h, h)));
          e.setTarget(d), e.setPosition(_.add(d, l));
        }
      }
      this._viewer.pauseRendering(() => {
        const o = e.getCameraPlaneIntersectionPoint(i, this._view);
        this._zoomHelper(r, e);
        const l = e.getCameraPlaneIntersectionPoint(
          i,
          this._view
        );
        o !== null && l !== null && e.dolly(_.subtract(l, o)), n.setCamera(e);
      });
    } else
      this._zoomHelper(r, e);
  }
  _zoomHelper(t, e) {
    const i = this._view;
    if (e.setWidth(e.getWidth() * t), e.setHeight(e.getHeight() * t), this._preserveViewAngle && !this._viewer.sheetManager.isDrawingSheetActive()) {
      const n = e.getPosition(), r = e.getTarget(), o = _.subtract(r, n).scale(t), l = _.subtract(r, o);
      e.setPosition(l);
    }
    i.setCamera(e);
  }
}
const rx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CameraKeyboardWalkOperator: od,
  CameraNavigationOperator: cy,
  CameraOrbitBaseOperator: Tg,
  CameraOrbitOperator: Ng,
  CameraPanOperator: hy,
  CameraTurntableOperator: uy,
  CameraWalkBaseOperator: Ag,
  CameraWalkModeOperator: dy,
  CameraWalkOperator: fy,
  CameraWindowZoomOperator: gy,
  CameraZoomOperator: py,
  DoorCache: oy,
  MAX_ANGLE: ey,
  MAX_TILT: Q_,
  MIN_ANGLE: iy,
  MIN_TILT: ty,
  OrbitMarkup: ly,
  TimedPoints: ay,
  applyGravity: Xf,
  buildCollisionRayConfig: Eg,
  clamp: Kf,
  getDownAxis: sy,
  normalizeDirections: ny,
  removeOpposing: nl,
  testWallCollision: ry
}, Symbol.toStringTag, { value: "Module" }));
var As = /* @__PURE__ */ ((s) => (s[s.NoPointsSelected = 0] = "NoPointsSelected", s[s.OnePointSelected = 1] = "OnePointSelected", s[s.TwoPointsSelected = 2] = "TwoPointsSelected", s))(As || {}), ul = /* @__PURE__ */ ((s) => (s[s.First = 0] = "First", s[s.Last = 1] = "Last", s[s.Midpoint = 2] = "Midpoint", s))(ul || {}), dl = /* @__PURE__ */ ((s) => (s[s.First = 0] = "First", s[s.Last = 1] = "Last", s[s.Midpoint = 2] = "Midpoint", s))(dl || {});
function Ru(s, t) {
  const e = new Hr(t.x, t.y, t.z, 1), i = new Hr(0, 0, 0, 0);
  s.getFullCameraMatrix().transform4(e, i);
  const n = 1 / i.w, r = new K(i.x * n, i.y * n), { x: o, y: l } = s.getCanvasSize();
  return r.x = 0.5 * o * (r.x + 1), r.y = 0.5 * l * (r.y + 1), r.x = Math.max(0, Math.min(r.x, o)), r.y = l - Math.max(0, Math.min(r.y, l)), r;
}
const Fc = class Fc extends Rn {
  constructor(t) {
    super(t), this._firstNode = null, this._firstPointShape = new Gr(), this._secondPointShape = new Gr(), this._arrowsInvert = !1, this._measurePoint1 = null, this._measurePoint2 = null, this._leaderPoint1 = null, this._leaderPoint2 = null, this._textPoint = null, this._name = "MeasureBodyBodyDistance", this._lineShapes = [];
    for (let e = 0; e < 6; e++)
      this._lineShapes.push(new Qn()), this._lineShapes[e].setStrokeColor(this._viewer.measureManager.getMeasurementColor()), this._lineShapes[e].setEndEndcapColor(this._viewer.measureManager.getMeasurementColor()), this._lineShapes[e].setStartEndcapColor(this._viewer.measureManager.getMeasurementColor());
    this._viewer = t, this.initCircle(this._firstPointShape), this.initCircle(this._secondPointShape), this._textShape = new Fl(), this._textShape.getBoxPortion().setFillOpacity(1), this._textShape.getBoxPortion().setFillColor(new vt(255, 255, 255));
  }
  initCircle(t) {
    t.setRadius(2.5), t.setFillColor(this._viewer.measureManager.getMeasurementColor());
  }
  setUnitMultiplier(t) {
    this._unitMultiplier = t;
  }
  setFirstNode(t) {
    this._stage = 1, this._firstNode = t;
  }
  getFirstNode() {
    return this._firstNode;
  }
  async setSecondNode(t) {
    if (this._firstNode === null)
      return;
    this._stage = 2;
    const e = await this._viewer.model.computeMinimumBodyBodyDistance(
      this._firstNode,
      t
    );
    this._measurePoint1 = e.pos1.copy(), this._measurePoint2 = e.pos2.copy(), this._textPoint = e.pos2.copy(), this._setMeasurementValue(e.distance);
  }
  _getStage() {
    return this._stage;
  }
  finalize() {
    this._stage++;
  }
  // adjusts the position of the measurement just before it's finalized
  adjust(t) {
    if (super.adjust(t), this._stage < 2)
      return;
    const e = this._viewer.view.raycastFromPoint(t);
    if (e === null || this._measurePoint1 === null || this._measurePoint2 === null || this._textPoint == null)
      return;
    let i = new _(1, 0, 0);
    this._measurePoint2.equals(this._measurePoint1) || (i = _.subtract(this._measurePoint2, this._measurePoint1));
    const r = this._viewer.view.getCamera().getUp(), o = _.cross(e.direction, r).normalize(), l = new _(
      (this._measurePoint1.x + this._measurePoint2.x) / 2,
      (this._measurePoint1.y + this._measurePoint2.y) / 2,
      (this._measurePoint1.z + this._measurePoint2.z) / 2
    ), h = new _(l.x + r.x, l.y + r.y, l.z + r.z), u = new _(
      l.x + o.x,
      l.y + o.y,
      l.z + o.z
    ), d = new _(
      e.origin.x + e.direction.x * 1e6,
      e.origin.y + e.direction.y * 1e6,
      e.origin.z + e.direction.z * 1e6
    );
    let g = new _(0, 0, 0);
    zo(
      e.origin,
      d,
      l,
      h,
      u,
      g
    ), this._textPoint.assign(g);
    let y = new _(0, 0, 0);
    Math.abs(i.x) <= Math.abs(i.y) && Math.abs(i.x) <= Math.abs(i.z) ? y = new _(1, 0, 0) : Math.abs(i.y) <= Math.abs(i.x) && Math.abs(i.y) <= Math.abs(i.z) ? y = new _(0, 1, 0) : y = new _(0, 0, 1);
    const m = _.cross(y, i), x = _.cross(m, i);
    m.set(
      this._measurePoint1.x + m.x,
      this._measurePoint1.y + m.y,
      this._measurePoint1.z + m.z
    ), x.set(
      this._measurePoint1.x + x.x,
      this._measurePoint1.y + x.y,
      this._measurePoint1.z + x.z
    );
    const b = new _(
      g.x + i.x * 1e4,
      g.y + i.y * 1e4,
      g.z + i.z * 1e4
    ), I = new _(
      g.x - i.x * 1e4,
      g.y - i.y * 1e4,
      g.z - i.z * 1e4
    ), C = zo(
      b,
      I,
      this._measurePoint1,
      m,
      x,
      g
    ), P = !isNaN(g.x) && !isNaN(g.y) && !isNaN(g.z);
    (!C || !P) && (g = this._measurePoint2.copy());
    const k = _.subtract(g, this._measurePoint1);
    this._leaderPoint1 = new _(
      this._measurePoint1.x + k.x,
      this._measurePoint1.y + k.y,
      this._measurePoint1.z + k.z
    ), this._leaderPoint2 = new _(
      this._measurePoint2.x + k.x,
      this._measurePoint2.y + k.y,
      this._measurePoint2.z + k.z
    ), this._updateArrowsInverted(), this._viewer.markupManager.refreshMarkup(this._viewer.view);
  }
  _updateArrowsInverted() {
    if (this._leaderPoint1 === null || this._leaderPoint2 === null || this._textPoint === null)
      return;
    const t = new _(
      (this._leaderPoint1.x + this._leaderPoint2.x) / 2,
      (this._leaderPoint1.y + this._leaderPoint2.y) / 2,
      (this._leaderPoint1.z + this._leaderPoint2.z) / 2
    ), e = _.subtract(this._leaderPoint2, this._leaderPoint1);
    _.subtract(this._textPoint, t).length() * 2 > e.length() ? this._arrowsInvert = !0 : this._arrowsInvert = !1;
  }
  // Called as part of drawing the markup. Sets line positions and determines if the markup is in view
  update() {
    if (super.update(), this._stage <= 1)
      return;
    const t = this._viewer.view;
    this._behindView = !1;
    const e = (h) => {
      if (h === null)
        return K.zero();
      const u = t.projectPoint(h);
      return u.z <= 0 && (this._behindView = !0), K.fromPoint3(u);
    }, i = e(this._measurePoint1), n = e(this._measurePoint2), r = e(this._textPoint), o = e(this._leaderPoint1), l = e(this._leaderPoint2);
    this._firstPointShape.setCenter(i), this._textShape && this._textShape.setPosition(r), this._secondPointShape.setCenter(n), this._lineShapes[0].set(i, n), this._lineShapes[1].set(o, l), this._lineShapes[2].set(i, o), this._lineShapes[3].set(n, l), this._lineShapes[4].set(o, r), this._lineShapes[5].set(o, l), this._lineShapes[5].setEndcapType(_n.Arrowhead), this._lineShapes[5].setStartEndcapType(_n.Arrowhead), this._lineShapes[5].setEndcapsInverted(this._arrowsInvert);
  }
  draw() {
    if (!this._visibility || this._viewer.explodeManager.getMagnitude() !== 0 || (this.update(), this._behindView))
      return;
    const t = this._viewer.markupManager.getRenderer();
    if (this._stage === 2 || this._stage === 3) {
      t.drawCircle(this._firstPointShape), t.drawCircle(this._secondPointShape);
      for (const e of this._lineShapes)
        t.drawLine(e);
      t.drawTextBox(this._textShape);
    }
  }
  // serialization methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      name: this._name,
      measurePoint1: this._measurePoint1,
      measurePoint2: this._measurePoint2,
      leaderPoint1: this._leaderPoint1,
      leaderPoint2: this._leaderPoint2,
      textPoint: this._textPoint,
      text: this._textShape.getTextString(),
      measurementValue: this._measurementValue,
      unitMultiplier: this._unitMultiplier,
      className: this.getClassName()
    };
  }
  /**
   * Creates a new [[MeasureBodyBodyDistanceMarkup]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t, e) {
    const i = t, n = new Fc(e);
    return n._name = i.name, n._measurePoint1 = _.fromJson(i.measurePoint1), n._measurePoint2 = _.fromJson(i.measurePoint2), n._textPoint = _.fromJson(i.textPoint), n._textShape.setTextString(i.text), n._leaderPoint1 = _.fromJson(i.leaderPoint1), n._leaderPoint2 = _.fromJson(i.leaderPoint2), n._measurementValue = i.measurementValue, n._unitMultiplier = i.unitMultiplier || 1, n._updateArrowsInverted(), n._stage = 2, n;
  }
  getClassName() {
    return Fc.className;
  }
};
Fc.className = "Communicator.Markup.Measure.MeasureBodyBodyDistanceMarkup";
let Il = Fc;
as(
  Il.className,
  Il.fromJson
);
class my extends Ai {
  constructor(t, e, i) {
    super(t, e), this._moveSelectionAction = new fo(!0), this._currentMoveHighlight = null, this._currentSelectHighlight = null, this._markup = null, this._measureManager = i;
  }
  _unsetCurrentMoveHighlight() {
    this._currentMoveHighlight !== null && (this._viewer.model.setNodesHighlighted([this._currentMoveHighlight.getNodeId()], !1), this._currentMoveHighlight = null);
  }
  _unsetCurrentSelectionHighlight() {
    this._currentSelectHighlight !== null && (this._viewer.model.setNodesHighlighted([this._currentSelectHighlight.getNodeId()], !1), this._currentSelectHighlight = null);
  }
  async _performMoveSelection(t) {
    const e = this._view, i = this._viewer.model, n = await e.pickFromPoint(t, new Si());
    if (n.overlayIndex() !== 0 || !n.isNodeSelection()) {
      this._unsetCurrentMoveHighlight();
      return;
    }
    const r = n.getNodeId();
    if (!(r === null || i.getNodeType(r) !== Le.BodyInstance)) {
      if (this._markup) {
        const o = this._markup.getFirstNode();
        if (o !== null && r === o)
          return;
      }
      this._currentMoveHighlight !== null ? n.equals(this._currentMoveHighlight) ? n.getSelectionType() === On.None && this._unsetCurrentMoveHighlight() : (this._unsetCurrentMoveHighlight(), this._currentMoveHighlight = n, i.setNodesHighlighted([r], !0)) : (this._currentMoveHighlight = n, i.setNodesHighlighted([r], !0));
    }
  }
  async _performUpSelection(t) {
    const e = this._view, i = this._viewer.model, n = await e.pickFromPoint(t, new Si());
    if (n.overlayIndex())
      return;
    if (this._markup && this._markup._getStage() === 1 && this._viewer.trigger("measurementBegin"), this._markup && this._markup._getStage() > 1) {
      const o = this._markup;
      this._markup = null, o.finalize(), this._measureManager.finalizeMeasurement(o);
      return;
    }
    const r = n.getNodeId();
    r !== null && i.getNodeType(r) === Le.BodyInstance && (!this._markup || this._markup._getStage() <= 1) && (this._unsetCurrentMoveHighlight(), this._markup ? (this._unsetCurrentSelectionHighlight(), await this._markup.setSecondNode(r), this._markup.adjust(t)) : (this._markup = new Il(this._viewer), this._markup.setUnitMultiplier(i.getNodeUnitMultiplier(r)), this._markup.setFirstNode(r), n.isNodeSelection() && (this._unsetCurrentSelectionHighlight(), this._currentSelectHighlight = n, this._viewer.model.setNodesHighlighted([r], !0)), this._measureManager.addMeasurement(this._markup)));
  }
  /** @hidden */
  onMouseMove(t) {
    super.onMouseMove(t);
    const e = t.getPosition();
    (!this._markup || this._markup._getStage() <= 1) && this._moveSelectionAction.set(() => this._performMoveSelection(e)), this._viewer.markupManager.refreshMarkup(this._viewer.view), this._markup !== null && this._markup._getStage() > 0 && this._markup.adjust(e);
  }
  async _onMouseUpImpl(t) {
    if (!this.isActive())
      return;
    const e = this._primaryTouchId !== null && this._markup !== null && this._markup._getStage() > 1;
    if (!(this._dragCount < 3 || e))
      return;
    const i = t.getPosition();
    await this._performUpSelection(i);
  }
  /** @hidden */
  async onMouseUp(t) {
    await this._onMouseUpImpl(t), super.onMouseUp(t);
  }
  /** @hidden */
  setDraggingEnabled(t) {
    this._dragging = t;
  }
  /** @hidden */
  onKeyUp(t) {
  }
  /** @hidden */
  onKeyDown(t) {
    t.getKeyCode() === ti.Escape && (this._markup !== null ? (this._measureManager.removeMeasurement(this._markup), this._markup = null) : this._measureManager.removeLastMeasurement());
  }
  /** @hidden */
  setHandled() {
    return this._markup !== null && this._markup._getStage() > 1;
  }
  /** @hidden */
  onDeactivate() {
    super.onDeactivate(), this._unsetCurrentMoveHighlight(), this._markup !== null && (this._measureManager.removeMeasurement(this._markup), this._markup = null);
  }
}
const hd = class hd extends Rn {
  /** @hidden */
  constructor(t) {
    super(t), this._lineEdgeShape = new Ba(), this._linePositions = [], this._name = "MeasureLength", this._positions = [], this._lineShapes = [], this._lineEdgeShape.setStrokeWidth(4), this._lineEdgeShape.setStrokeColor(t.measureManager.getMeasurementEdgeColor());
  }
  setLineGeometry(t) {
    this._linePositions = t, this._stage = 1;
  }
  setMeasurementEdgeColor(t) {
    this._lineEdgeShape.setStrokeColor(t);
  }
  reset() {
    this._stage = 0;
  }
  adjust(t) {
    super.adjust(t);
  }
  draw() {
  }
  getLineEdgeShape() {
    return this._lineEdgeShape;
  }
  //serialization methods
  getClassName() {
    return hd.className;
  }
};
hd.className = "Communicator.Markup.Measure.MeasureLengthMarkup";
let dh = hd;
const Bc = class Bc extends dh {
  constructor(t, e, i, n) {
    super(t), this._circlePoints = [], this._radius = 0, this._surfaceCenter = _.zero(), this._circlePlane = new ln(), this._arrowsInvert = !1, this._name = "MeasureCircleEdgeLength", this._lineProperties = e, this._matrix = i.copy(), this._unitMultiplier = n, this._textShape.getBoxPortion().setFillOpacity(1), this._textShape.getBoxPortion().setFillColor(new vt(255, 255, 255));
    const o = t.measureManager.getMeasurementColor();
    for (let l = 0; l < 5; l++)
      this._lineShapes.push(new Qn()), this._lineShapes[l].setStrokeColor(o), this._lineShapes[l].setEndEndcapColor(o), this._lineShapes[l].setStartEndcapColor(o);
  }
  createCircleData() {
    av(
      this._circlePoints,
      this._lineProperties.origin,
      this._lineProperties.radius,
      32,
      this._lineProperties.normal
    ), this._matrix.transformArray(this._circlePoints, this._circlePoints), this._positions[0] = this._circlePoints[0].copy(), this._positions[1] = this._circlePoints[16].copy();
    const t = new _(this._lineProperties.radius, 0, 0), e = new _(0, 0, 0);
    this._matrix.transform(t, t), this._matrix.transform(e, e);
    let i = _.subtract(e, t);
    this._radius = i.length(), i = _.subtract(this._positions[1], this._positions[0]), this._positions[4] = this._positions[1].copy(), this._surfaceCenter = this._matrix.transform(this._lineProperties.origin);
    const n = new _(
      this._circlePoints[0].x,
      this._circlePoints[0].y,
      this._circlePoints[0].z
    ), r = new _(
      this._circlePoints[1].x,
      this._circlePoints[1].y,
      this._circlePoints[1].z
    );
    this._circlePlane = ln.createFromPoints(n, r, this._surfaceCenter);
  }
  setLineGeometry(t) {
    if (super.setLineGeometry(t), this._positions[0] = this._linePositions[0], this._positions[0].equals(this._positions[this._positions.length - 1])) {
      const e = Math.floor(this._positions.length / 2);
      this._positions[1] = this._positions[e];
    } else
      this._positions[1] = this._linePositions[this._linePositions.length - 1];
    this._positions[1] = this._linePositions[this._linePositions.length - 1], this._positions[2] = this._linePositions[1].copy(), this.createCircleData(), this._setMeasurementValue(this._radius);
  }
  adjust(t) {
    super.adjust(t);
    const e = this._viewer.view.raycastFromPoint(t);
    if (e === null)
      return;
    const i = this._surfaceCenter, n = this._circlePlane;
    let r = n.rayIntersection(e);
    if (r === null) {
      const u = _.add(i, e.direction.copy().scale(-2 * this._radius)), g = ln.createFromPointAndNormal(u, e.direction).rayIntersection(e);
      console.assert(g !== null);
      const y = new wr(g, n.normal);
      r = n.rayIntersection(y), r === null && (r = n.rayIntersection(y.negate()));
    }
    r === null && (console.assert(!1), r = i.copy());
    const o = _.subtract(r, i).normalize().scale(this._radius), l = _.add(i, o), h = _.subtract(i, o);
    this._positions[0] = l, this._positions[1] = h, this._positions[2] = l.copy(), this._positions[3] = h.copy(), this._positions[4] = r.copy(), this._positions[5] = this._surfaceCenter.copy(), this._updateArrowsInverted(), this._viewer.markupManager.refreshMarkup(this._viewer.view);
  }
  _updateArrowsInverted() {
    const t = new _(
      (this._positions[4].x + this._positions[5].x) / 2,
      (this._positions[4].y + this._positions[5].y) / 2,
      (this._positions[4].z + this._positions[5].z) / 2
    ), e = _.subtract(this._positions[5], this._positions[4]), i = _.subtract(this._positions[2], t);
    this._arrowsInvert = i.length() * 2 > e.length();
  }
  update() {
    super.update();
    const t = this._viewer.view;
    if (this._stage > 0) {
      this._lineEdgeShape.clearPoints();
      for (const e of this._linePositions) {
        const i = K.fromPoint3(t.projectPoint(e));
        this._lineEdgeShape.pushPoint(i);
      }
    }
    if (this._stage > 1) {
      const e = new Array(6);
      for (let i = 0; i < this._positions.length; i++)
        e[i] = K.fromPoint3(t.projectPoint(this._positions[i]));
      this._textShape && this._textShape.setPosition(e[4]), this._lineShapes[0].set(e[5], e[2]), this._lineShapes[1].set(e[5], e[4]), this._lineShapes[0].setEndcapType(_n.Arrowhead), this._lineShapes[0].setStartEndcapType(_n.None), this._lineShapes[0].setEndcapsInverted(this._arrowsInvert);
    }
  }
  draw() {
    if (this._visibility && this._viewer.explodeManager.getMagnitude() === 0) {
      this.update();
      const e = this._viewer.markupManager.getRenderer();
      switch (this._stage) {
        case 1:
          e.drawPolyline(this._lineEdgeShape);
          break;
        case 2:
        case 3:
          for (let i = 0; i < 2; i++)
            e.drawLine(this._lineShapes[i]);
          e.drawTextBox(this._textShape), e.drawPolyline(this._lineEdgeShape);
          break;
      }
    }
  }
  // serialization methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    const t = Rn._serializePointArray(this._linePositions), e = Rn._serializePointArray(this._positions);
    return {
      matrix: this._matrix.toJson(),
      lineOrigin: this._lineProperties.origin,
      lineRadius: this._lineProperties.radius,
      lineNormal: this._lineProperties.normal,
      linePositions: t,
      positions: e,
      text: this._textShape.getTextString(),
      measurementValue: this._measurementValue,
      unitMultiplier: this._unitMultiplier,
      className: this.getClassName()
    };
  }
  /**
   * Creates a new [[MeasureCircleEdgeLengthMarkup]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t, e) {
    const i = t, n = mt.fromJson(i.matrix), r = i.lineRadius, o = _.fromJson(i.lineOrigin), l = _.fromJson(i.lineNormal), h = new Ol(r, o, l), u = i.unitMultiplier || 1, d = new Bc(
      e,
      h,
      n,
      u
    ), g = Rn._constructPointArray(i.linePositions), y = Rn._constructPointArray(i.positions);
    return d.setLineGeometry(g), d._positions = y, d._textShape.setTextString(i.text), d._stage = 3, d._measurementValue = i.measurementValue, d;
  }
  getClassName() {
    return Bc.className;
  }
};
Bc.className = "Communicator.Markup.Measure.MeasureCircleEdgeLengthMarkupMeasureMarkup";
let Cl = Bc;
as(
  Cl.className,
  Cl.fromJson
);
const Vc = class Vc extends dh {
  /** @hidden */
  constructor(t, e, i, n) {
    super(t), this._lineProperties = null, this._worldSpaceLength = 0, this._arrowsInvert = !1, this._name = "MeasureStraightEdgeLength", this._lineProperties = e, this._matrix = i.copy(), this._matrix.setTranslationComponent(0, 0, 0), this._unitMultiplier = n;
    const o = this._viewer.measureManager.getMeasurementColor();
    for (let h = 0; h < 5; h++) {
      const u = new Qn();
      u.setStrokeColor(o), u.setEndEndcapColor(o), u.setStartEndcapColor(o), this._lineShapes.push(u);
    }
    const l = this._textShape.getBoxPortion();
    l.setFillOpacity(1), l.setFillColor(new vt(255, 255, 255));
  }
  /** @hidden */
  setLineGeometry(t) {
    super.setLineGeometry(t), this._positions[0] = this._linePositions[0], this._positions[2] = this._linePositions[0].copy(), this._positions[1] = this._linePositions[this._linePositions.length - 1];
    let e;
    if (this._lineProperties !== null && this._lineProperties.length !== -1) {
      const i = new _(this._lineProperties.length, 0, 0);
      this._matrix.transform(i, i), this._worldSpaceLength = i.length(), e = this._worldSpaceLength;
    } else
      e = _.subtract(this._positions[1], this._positions[0]).length();
    this._setMeasurementValue(e);
  }
  /** @hidden */
  adjust(t) {
    super.adjust(t);
    const e = this._viewer.view, i = e.raycastFromPoint(t);
    if (i === null)
      return;
    const n = this._positions[0], r = this._positions[1];
    let o = new _(1, 0, 0);
    r.equals(n) || (o = _.subtract(r, n));
    const h = e.getCamera().getUp(), u = _.cross(i.direction, h).normalize(), d = _.add(n, r).scale(0.5), g = _.add(d, h), y = _.add(d, u), m = _.add(_.scale(i.direction, 1e6), i.origin), x = new _(0, 0, 0);
    zo(i.origin, m, d, g, y, x), this._positions[2].assign(x);
    let b = new _(0, 0, 0);
    Math.abs(o.x) <= Math.abs(o.y) && Math.abs(o.x) <= Math.abs(o.z) ? b = new _(1, 0, 0) : Math.abs(o.y) <= Math.abs(o.x) && Math.abs(o.y) <= Math.abs(o.z) ? b = new _(0, 1, 0) : b = new _(0, 0, 1);
    const I = _.cross(b, o), C = _.cross(I, o);
    I.add(n), C.add(n);
    const P = _.add(_.scale(o, 1e4), x), k = _.add(_.scale(o, -1e4), x);
    zo(P, k, n, I, C, x);
    const O = _.subtract(x, n);
    this._positions[3] = _.add(n, O), this._positions[4] = _.add(r, O), this._updateArrowsInverted(), this._viewer.markupManager.refreshMarkup(this._viewer.view);
  }
  _updateArrowsInverted() {
    const t = _.add(this._positions[3], this._positions[4]).scale(0.5), e = _.subtract(this._positions[4], this._positions[3]), i = _.subtract(this._positions[2], t);
    this._arrowsInvert = 2 * i.squaredLength() > e.squaredLength();
  }
  /** @hidden */
  update() {
    super.update();
    const t = this._viewer.view;
    if (this._behindView = !1, this._stage > 0) {
      this._lineEdgeShape.clearPoints();
      const e = Array(this._linePositions.length);
      for (let i = 0; i < this._linePositions.length; i++)
        e[i] = t.projectPoint(this._linePositions[i]), e[i].z <= 0 && (this._behindView = !0), this._lineEdgeShape.pushPoint(K.fromPoint3(e[i]));
    }
    if (this._stage > 1) {
      const e = new Array(6), i = Array(6);
      for (let n = 0; n < this._positions.length; n++)
        i[n] = t.projectPoint(this._positions[n]), i[n].z <= 0 && (this._behindView = !0), e[n] = K.fromPoint3(i[n]);
      this._textShape && this._textShape.setPosition(e[2]), this._lineShapes[0].set(e[3], e[4]), this._lineShapes[1].set(e[0], e[3]), this._lineShapes[2].set(e[1], e[4]), this._lineShapes[3].set(e[3], e[2]), this._lineShapes[4].set(e[3], e[4]), this._lineShapes[4].setEndcapType(_n.Arrowhead), this._lineShapes[4].setStartEndcapType(_n.Arrowhead), this._lineShapes[4].setEndcapsInverted(this._arrowsInvert);
    }
  }
  /** @hidden */
  draw() {
    if (this._visibility && this._viewer.explodeManager.getMagnitude() === 0 && (this.update(), !this._behindView)) {
      const t = this._viewer.markupManager.getRenderer();
      switch (this._stage) {
        case 1:
          t.drawPolyline(this._lineEdgeShape);
          break;
        case 2:
        case 3:
          for (const e of this._lineShapes)
            t.drawLine(e);
          t.drawTextBox(this._textShape), t.drawPolyline(this._lineEdgeShape);
          break;
      }
    }
  }
  // serialization methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      name: this._name,
      measurePoint1: this._positions[0].copy(),
      measurePoint2: this._positions[1].copy(),
      leaderPoint1: this._positions[3].copy(),
      leaderPoint2: this._positions[4].copy(),
      textPoint: this._positions[2].copy(),
      text: this._textShape.getTextString(),
      measurementValue: this._measurementValue,
      unitMultiplier: this._unitMultiplier,
      className: this.getClassName(),
      matrix: this._matrix.toJson()
    };
  }
  /**
   * Creates a new [[MeasureStraightEdgeLengthMarkup]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t, e) {
    const i = t, n = mt.fromJson(i.matrix), r = i.unitMultiplier || 1, o = new Vc(e, null, n, r);
    return o._name = i.name, o._positions[0] = _.fromJson(i.measurePoint1), o._positions[1] = _.fromJson(i.measurePoint2), o._positions[2] = _.fromJson(i.textPoint), o._textShape.setTextString(i.text), o._positions[3] = _.fromJson(i.leaderPoint1), o._positions[4] = _.fromJson(i.leaderPoint2), o._measurementValue = i.measurementValue, o._updateArrowsInverted(), o._stage = 2, o;
  }
  getClassName() {
    return Vc.className;
  }
};
Vc.className = "Communicator.Markup.Measure.MeasureStraightEdgeLengthMarkup";
let fh = Vc;
class _y extends Ai {
  /** @hidden */
  constructor(t, e, i) {
    super(t, e), this._pickConfig = new Si(Se.Line), this._moveSelectionAction = new fo(!0), this._lengthMarkup = null, this._edgeMarkup = null, this._measureManager = i, this._pickConfig.restrictLinesAndPointsToSelectedFaceInstances = !1;
  }
  /** @hidden */
  onActivate() {
    this._edgeMarkup === null && (this._edgeMarkup = new fh(this._viewer, null, new mt(), 1));
  }
  _unregisterEdgeMarkup() {
    if (this._edgeMarkup === null)
      return;
    const t = this._edgeMarkup._getId();
    t !== "" && (this._viewer.markupManager.unregisterMarkup(t, this._viewer.view), this._edgeMarkup._setId(""));
  }
  _registerEdgeMarkup() {
    this._edgeMarkup !== null && (this._unregisterEdgeMarkup(), this._edgeMarkup._setId(
      this._viewer.markupManager.registerMarkup(this._edgeMarkup, this._viewer.view)
    ));
  }
  _resetEdgeMarkup() {
    this._edgeMarkup !== null && (this._unregisterEdgeMarkup(), this._edgeMarkup.reset());
  }
  async _performMoveSelection(t, e) {
    const n = await this._view.pickFromPoint(t, this._pickConfig), r = n.getNodeId(), o = n.getLineEntity();
    r && o && !o.isCappingGeometry() && n.overlayIndex() === 0 && await this._viewer.model.isLineMeasurable(r, o.getLineId()) ? (e.setLineGeometry(o.getPoints()), this._registerEdgeMarkup()) : this._resetEdgeMarkup();
  }
  async _performUpSelection(t) {
    const e = this._view, i = this._viewer.model, n = await e.pickFromPoint(t, this._pickConfig);
    if (n.overlayIndex())
      return;
    if (this._lengthMarkup && this._lengthMarkup._getStage() === 2) {
      const d = this._lengthMarkup;
      this._lengthMarkup = null, d._nextStage(), this._measureManager.finalizeMeasurement(d);
      return;
    }
    if (this._lengthMarkup || !n.isLineSelection())
      return;
    const r = n.getNodeId();
    if (!r)
      return;
    const o = n.getLineEntity();
    if (!await this._viewer.model.isLineMeasurable(r, o.getLineId()))
      return;
    const h = i.getNodeUnitMultiplier(r), u = await i.getEdgeProperty(r, o.getLineId());
    if (this._viewer.trigger("measurementBegin"), !!u) {
      if (u instanceof yh || u instanceof Ho) {
        const d = i.getNodeNetMatrix(r);
        this._lengthMarkup = new fh(
          this._viewer,
          u,
          d,
          h
        ), this._measureManager.addMeasurement(this._lengthMarkup), this._lengthMarkup.setLineGeometry(o.getPoints()), this._lengthMarkup._nextStage(), this._lengthMarkup.adjust(t);
      } else if (u instanceof Ol) {
        const d = i.getNodeNetMatrix(r);
        this._lengthMarkup = new Cl(
          this._viewer,
          u,
          d,
          h
        ), this._measureManager.addMeasurement(this._lengthMarkup), this._lengthMarkup.setLineGeometry(o.getPoints()), this._lengthMarkup._nextStage(), this._lengthMarkup.adjust(t);
      }
      this._lengthMarkup._getStage() === 2 && this._viewer.trigger("measurementValueSet", this._lengthMarkup);
    }
  }
  /** @hidden */
  onMouseMove(t) {
    super.onMouseMove(t);
    const e = this._edgeMarkup;
    if (e === null)
      return;
    e.setMeasurementEdgeColor(this._viewer.measureManager.getMeasurementEdgeColor());
    const i = t.getPosition();
    this.isDragging() && this._primaryTouchId === null ? this._resetEdgeMarkup() : (this._lengthMarkup === null && this._moveSelectionAction.set(() => this._performMoveSelection(i, e)), this._viewer.markupManager.refreshMarkup(this._viewer.view), this._lengthMarkup !== null && this._lengthMarkup._getStage() > 0 && this._lengthMarkup.adjust(i));
  }
  async _onMouseUpImpl(t) {
    if (!this.isActive())
      return;
    const e = this._primaryTouchId !== null && this._lengthMarkup !== null;
    if (!(this._dragCount < 3 || e))
      return;
    const i = t.getPosition();
    await this._performUpSelection(i);
  }
  /** @hidden */
  onMouseUp(t) {
    this._onMouseUpImpl(t), super.onMouseUp(t);
  }
  /** @hidden */
  setDraggingEnabled(t) {
    this._dragging = t;
  }
  /** @hidden */
  onKeyUp(t) {
  }
  /** @hidden */
  onKeyDown(t) {
    t.getKeyCode() === ti.Escape && (this._lengthMarkup !== null ? (this._measureManager.removeMeasurement(this._lengthMarkup), this._lengthMarkup = null) : this._measureManager.removeLastMeasurement(), this._edgeMarkup !== null && this._resetEdgeMarkup());
  }
  /** @hidden */
  setHandled() {
    return this._lengthMarkup !== null;
  }
  /** @hidden */
  onDeactivate() {
    this._lengthMarkup !== null && (this._measureManager.removeMeasurement(this._lengthMarkup), this._lengthMarkup = null), this._edgeMarkup !== null && this._resetEdgeMarkup();
  }
}
const qp = 30, zc = class zc extends Rn {
  constructor(t) {
    super(t), this._faceSelection = [], this._arcArray = [], this._lineGeometryShape = new Ba(), this.planeIntersectionLine = [], this._pointOnLine = _.zero(), this._clickpointOriginal2 = _.zero(), this._clickpointOriginal1 = _.zero(), this._plane1 = new ln(), this._plane2 = new ln(), this._secondPoint = _.zero(), this._firstPoint = _.zero(), this._textPos = _.zero(), this._intermediatePoint = _.zero(), this._textAnchorPoint = _.zero(), this._angle = 0, this._useAuthoredNormals = !0, this._name = "MeasureFaceFaceAngle";
    const i = this._viewer.measureManager.getMeasurementColor();
    this._lineGeometryShape.setStrokeWidth(2), this._lineGeometryShape.setStrokeColor(i), this._lineGeometryShape.setEndEndcapColor(i), this._lineGeometryShape.setStartEndcapColor(i), this._textShape = new Fl(), this._textShape.getBoxPortion().setFillOpacity(1), this._textShape.getBoxPortion().setFillColor(new vt(255, 255, 255));
    for (let n = 0; n < 5; n++)
      this._lineShapes.push(new Qn()), this._lineShapes[n].setStrokeColor(i), this._lineShapes[n].setEndEndcapColor(i), this._lineShapes[n].setStartEndcapColor(i);
  }
  async _getNormalAndPositionFromSelection(t, e, i) {
    const n = t.getNodeId(), r = t.getFaceEntity().getCadFaceIndex();
    i.assign(t.getPosition().copy()), e.assign(t.getFaceEntity().getNormal());
    const o = await this._viewer.model.getFaceProperty(n, r);
    if (this._useAuthoredNormals && o !== null && o instanceof Wi) {
      const h = this._viewer.model.getNodeNetMatrix(n).normalMatrix();
      h !== null && h.transform(o.normal, e);
    }
  }
  getFirstSelection() {
    return this._faceSelection[0];
  }
  async setFirstFace(t) {
    const e = t.getNodeId(), i = t.getFaceEntity().getCadFaceIndex();
    this._viewer.model.setNodeFaceColor(e, i, new vt(255, 0, 0)), this._faceSelection.push(t);
    const n = _.zero(), r = _.zero();
    await this._getNormalAndPositionFromSelection(t, n, r), this._firstPoint = r.copy(), this._plane1.setFromPointAndNormal(this._firstPoint, n), this._clickpointOriginal1 = t.getPosition().copy(), this._stage++;
  }
  async setSecondFace(t) {
    const e = t.getNodeId(), i = t.getFaceEntity().getCadFaceIndex();
    this._faceSelection[1] = t, this._viewer.model.setNodeFaceColor(e, i, new vt(255, 0, 0));
    const n = _.zero(), r = _.zero();
    if (await this._getNormalAndPositionFromSelection(t, r, n), this._secondPoint = n.copy(), this._plane2.setFromPointAndNormal(this._secondPoint, r), this.planeIntersectionLine[0] = new _(0, 0, 0), this.planeIntersectionLine[1] = new _(0, 0, 0), rv(
      this._plane1,
      this._firstPoint,
      this._plane2,
      this._secondPoint,
      this.planeIntersectionLine[0],
      this.planeIntersectionLine[1]
    ) !== 2)
      return !1;
    const l = _.subtract(this.planeIntersectionLine[1], this.planeIntersectionLine[0]);
    l.normalize(), this.planeIntersectionLine[0].set(
      this.planeIntersectionLine[0].x - l.x * 100,
      this.planeIntersectionLine[0].y - l.y * 100,
      this.planeIntersectionLine[0].z - l.z * 100
    ), this.planeIntersectionLine[1].set(
      this.planeIntersectionLine[1].x + l.x * 100,
      this.planeIntersectionLine[1].y + l.y * 100,
      this.planeIntersectionLine[1].z + l.z * 100
    ), eo(
      this._secondPoint,
      this.planeIntersectionLine[0],
      this.planeIntersectionLine[1],
      this._pointOnLine
    );
    const h = new _(0, 0, 0), u = new _(0, 0, 0);
    h.set(
      this._firstPoint.x + l.x,
      this._firstPoint.y + l.y,
      this._firstPoint.z + l.z
    ), eo(this._pointOnLine, this._firstPoint, h, u), this._firstPoint = u.copy(), this._clickpointOriginal2 = t.getPosition().copy();
    const d = new mt(), g = _.subtract(this._secondPoint, this._pointOnLine), y = g.length(), m = _.subtract(this._firstPoint, this._pointOnLine);
    if (m.normalize(), this._intermediatePoint.set(
      this._pointOnLine.x + m.x * y,
      this._pointOnLine.y + m.y * y,
      this._pointOnLine.z + m.z * y
    ), this._angle = yr(g, m), this._angle === 0)
      return !1;
    this._measurementValue = this._angle, this._textShape.setTextString(`${this._measurementValue.toFixed(2)}°`), this._viewer.trigger("measurementValueSet", this), this._textPos = this._pointOnLine.copy();
    let x = !1, b = new _(0, 0, 0);
    const I = new _(0, 0, 0);
    hc(l, 1, d), d.transform(g, I), b.set(I.x + this._pointOnLine.x, I.y + this._pointOnLine.y, I.z + this._pointOnLine.z), b = _.subtract(b, this._firstPoint);
    const C = b.length();
    return hc(l, -1, d), d.transform(g, I), b.set(I.x + this._pointOnLine.x, I.y + this._pointOnLine.y, I.z + this._pointOnLine.z), _.subtract(b, this._firstPoint), b.length() < C && (x = !0), this._arcArray = xf(
      l,
      x ? -this._angle : this._angle,
      this._pointOnLine,
      g,
      qp
    ), this._stage++, !0;
  }
  adjust(t) {
    if (super.adjust(t), this._stage <= 1)
      return;
    const e = this._viewer.view.raycastFromPoint(t);
    if (e === null)
      return;
    const i = new _(
      e.origin.x + e.direction.x * 1e6,
      e.origin.y + e.direction.y * 1e6,
      e.origin.z + e.direction.z * 1e6
    ), n = new _(0, 0, 0);
    zo(
      e.origin,
      i,
      this._pointOnLine,
      this._firstPoint,
      this._secondPoint,
      n
    ), this._textPos = n.copy();
    let r = new _(0, 0, 0);
    r = _.subtract(n, this._pointOnLine);
    const o = r.length();
    r = _.subtract(this._secondPoint, this._pointOnLine), r.normalize(), this._secondPoint.set(
      this._pointOnLine.x + r.x * o,
      this._pointOnLine.y + r.y * o,
      this._pointOnLine.z + r.z * o
    );
    const l = _.subtract(this.planeIntersectionLine[1], this.planeIntersectionLine[0]);
    l.normalize();
    const h = new mt(), u = _.subtract(this._secondPoint, this._pointOnLine), d = u.length(), g = _.subtract(this._firstPoint, this._pointOnLine);
    g.normalize(), this._intermediatePoint.set(
      this._pointOnLine.x + g.x * d,
      this._pointOnLine.y + g.y * d,
      this._pointOnLine.z + g.z * d
    );
    let y = !1, m = new _(0, 0, 0);
    const x = new _(0, 0, 0);
    hc(l, 1, h), h.transform(u, x), m.set(x.x + this._pointOnLine.x, x.y + this._pointOnLine.y, x.z + this._pointOnLine.z), m = _.subtract(m, this._firstPoint);
    const b = m.length();
    hc(l, -1, h), h.transform(u, x), m.set(x.x + this._pointOnLine.x, x.y + this._pointOnLine.y, x.z + this._pointOnLine.z), m = _.subtract(m, this._firstPoint), m.length() < b && (y = !0), this._arcArray = xf(
      l,
      y ? -this._angle : this._angle,
      this._pointOnLine,
      u,
      qp
    );
    let C;
    const P = this._viewer.view.projectPoint(this._textPos);
    for (const k of this._arcArray) {
      const O = this._viewer.view.projectPoint(k), j = new _(
        P.x - O.x,
        P.y - O.y,
        P.z - O.z
      ).length();
      (C === void 0 || C > j) && (C = j);
    }
    if (C === void 0 || C <= 20)
      this._textAnchorPoint = this._textPos;
    else {
      const k = this._viewer.view.projectPoint(this._intermediatePoint), O = this._viewer.view.projectPoint(this._secondPoint), B = new _(
        k.x - P.x,
        k.y - P.y,
        k.z - P.z
      ), j = new _(
        O.x - P.x,
        O.y - P.y,
        O.z - P.z
      ), V = B.length(), Y = j.length();
      V < Y ? this._textAnchorPoint = this._intermediatePoint : this._textAnchorPoint = this._secondPoint;
    }
  }
  _nextStage() {
    this._stage++, this._stage > 2 && (this._finalized = !0, this.cleanup());
  }
  cleanup() {
    const t = (e) => {
      const i = this._faceSelection[e];
      this._viewer.model.unsetNodeFaceColor(
        i.getNodeId(),
        i.getFaceEntity().getCadFaceIndex()
      );
    };
    this._stage >= 2 && t(1), this._stage >= 1 && t(0);
  }
  update() {
    super.update();
    const t = this._viewer.view;
    if (this._stage > 1) {
      this._lineGeometryShape.clearPoints();
      for (const n of this._arcArray)
        this._lineGeometryShape.pushPoint(K.fromPoint3(t.projectPoint(n)));
      this._lineGeometryShape.setEndcapType(_n.Arrowhead), this._lineGeometryShape.setStartEndcapType(_n.Arrowhead), this._lineGeometryShape.setEndEndcapSize(5), this._lineGeometryShape.setStartEndcapSize(5);
      const e = new Array(10);
      e[0] = t.projectPoint(this._textPos), e[1] = t.projectPoint(this._firstPoint), e[2] = t.projectPoint(this._clickpointOriginal1), e[3] = t.projectPoint(this._secondPoint), e[4] = t.projectPoint(this._clickpointOriginal2), e[5] = t.projectPoint(this._intermediatePoint), e[6] = t.projectPoint(this._textAnchorPoint), this._behindView = !1;
      const i = new Array(10);
      for (let n = 0; n <= 6; n++)
        e[n].z <= 0 && (this._behindView = !0), i[n] = K.fromPoint3(e[n]);
      this._textShape && this._textShape.setPosition(i[0]), this._lineShapes[0].set(i[1], i[2]), this._lineShapes[1].set(i[1], i[5]), this._lineShapes[2].set(i[3], i[4]), this._lineShapes[3].set(i[6], i[0]);
    }
  }
  draw() {
    const t = this._viewer.explodeManager.getMagnitude() !== 0;
    if (!(!this._visibility || t) && (this.update(), !this._behindView && this._stage >= 2 && this._stage <= 4)) {
      const e = this._viewer.markupManager.getRenderer();
      for (let i = 0; i < 4; i++)
        e.drawLine(this._lineShapes[i]);
      e.drawTextBox(this._textShape), e.drawPolyline(this._lineGeometryShape);
    }
  }
  /**
   * Sets whether created markup will use authored normals or use selection results to calculate angles
   * @param use
   */
  setUseAuthoredNormals(t) {
    this._useAuthoredNormals = t;
  }
  /**
   * Gets whether created markup will use authored normals or use selection results to calculate angles
   */
  getUseAuthoredNormals() {
    return this._useAuthoredNormals;
  }
  // selection methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    const t = [];
    for (const e of this._arcArray) {
      const i = e.toJson();
      t.push(i);
    }
    return {
      text: this._textShape.getTextString(),
      textPos: this._textPos.toJson(),
      arcArray: t,
      firstPoint: this._firstPoint.toJson(),
      clickpointOriginal1: this._clickpointOriginal1.toJson(),
      secondPoint: this._secondPoint.toJson(),
      clickpointOriginal2: this._clickpointOriginal2.toJson(),
      intermediatePoint: this._intermediatePoint.toJson(),
      textAnchorPoint: this._textAnchorPoint.toJson(),
      measurementValue: this._measurementValue,
      className: this.getClassName()
    };
  }
  /**
   * Creates a new [[MeasureFaceFaceAngleMarkup]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t, e) {
    const i = t, n = new zc(e);
    for (const r of i.arcArray) {
      const o = _.fromJson(r);
      n._arcArray.push(o);
    }
    return n._textShape.setTextString(i.text), n._textPos.assign(_.fromJson(i.textPos)), n._firstPoint.assign(_.fromJson(i.firstPoint)), n._clickpointOriginal1 = _.fromJson(i.clickpointOriginal1), n._secondPoint.assign(_.fromJson(i.secondPoint)), n._clickpointOriginal2 = _.fromJson(i.clickpointOriginal2), n._intermediatePoint.assign(_.fromJson(i.intermediatePoint)), n._textAnchorPoint.assign(_.fromJson(i.textAnchorPoint)), n._measurementValue = i.measurementValue, n._stage = 3, n;
  }
  // serialization methods
  getClassName() {
    return zc.className;
  }
};
zc.className = "Communicator.Markup.Measure.MeasureFaceFaceAngleMarkup";
let Sl = zc;
as(Sl.className, Sl.fromJson);
async function gf(s, t) {
  if (t.getSelectionType() !== On.None) {
    const e = t.getNodeId(), i = t.getFaceEntity();
    return await s.isFaceMeasurable(e, i.getCadFaceIndex()) ? (i.getCadFaceBits() & n_.SelectionBitsFacePlanar) !== 0 : !1;
  }
  return !1;
}
class yy extends Ai {
  constructor(t, e, i) {
    super(t, e), this._moveSelectionAction = new fo(!0), this._currentHighlight = null, this._markup = null, this._useAuthoredNormals = !0, this._measureManager = i;
  }
  _unsetCurrentHighlight() {
    this._currentHighlight !== null && (this._viewer.model.unsetNodeFaceColor(
      this._currentHighlight.getNodeId(),
      this._currentHighlight.getFaceEntity().getCadFaceIndex()
    ), this._currentHighlight = null);
  }
  async _performMoveSelection(t) {
    const e = this._view, i = this._viewer.model, n = await e.pickFromPoint(t, new Si());
    if (n.overlayIndex() !== 0 || !n.isFaceSelection())
      return;
    const r = n.getNodeId(), o = n.getFaceEntity();
    if (i.getNodeType(n.getNodeId()) === Le.BodyInstance) {
      if (this._markup) {
        const l = this._markup.getFirstSelection();
        if (r === l.getNodeId()) {
          const h = l.getFaceEntity().getCadFaceIndex(), u = o.getCadFaceIndex();
          if (h === u)
            return;
        }
      }
      this._currentHighlight !== null ? n.equals(this._currentHighlight) ? n.getSelectionType() === On.None && this._unsetCurrentHighlight() : (this._unsetCurrentHighlight(), await gf(i, n) && (this._currentHighlight = n, i.setNodeFaceColor(r, o.getCadFaceIndex(), vt.yellow()))) : this._currentHighlight === null && await gf(i, n) && (this._currentHighlight = n, i.setNodeFaceColor(r, o.getCadFaceIndex(), vt.yellow()));
    }
  }
  async _performUpSelection(t) {
    const e = this._view, i = this._viewer.model, n = await e.pickFromPoint(t, new Si());
    if (n.overlayIndex())
      return;
    if (this._markup && this._markup._getStage() > 1) {
      if (this._viewer.trigger("measurementBegin"), this._markup._nextStage(), this._markup._isFinalized()) {
        const l = this._markup;
        this._markup = null, this._measureManager.finalizeMeasurement(l);
      }
      return;
    }
    if (!n.isFaceSelection() || !(i.getNodeType(n.getNodeId()) === Le.BodyInstance && (!this._markup || this._markup._getStage() <= 1)) || !await gf(i, n))
      return;
    const r = n.getFaceEntity();
    await i.getFaceProperty(
      n.getNodeId(),
      r.getCadFaceIndex()
    ) instanceof Wi && (this._unsetCurrentHighlight(), this._markup === null ? (this._markup = new Sl(this._viewer), this._markup.setUseAuthoredNormals(this._useAuthoredNormals), await this._markup.setFirstFace(n), this._measureManager.addMeasurement(this._markup)) : await this._markup.setSecondFace(n) && this._markup.adjust(t));
  }
  /** @hidden */
  onMouseMove(t) {
    super.onMouseMove(t);
    const e = t.getPosition();
    (!this._markup || this._markup._getStage() <= 1) && this._performMoveSelection(e), this._viewer.markupManager.refreshMarkup(this._viewer.view), this._markup !== null && this._markup._getStage() > 0 && this._markup.adjust(e);
  }
  _onMouseUpImpl(t) {
    if (!this.isActive())
      return;
    const e = this._primaryTouchId !== null && this._markup !== null && this._markup._getStage() > 1;
    if (!(this._dragCount < 3 || e))
      return;
    const i = t.getPosition();
    this._moveSelectionAction.set(() => this._performUpSelection(i));
  }
  /** @hidden */
  onMouseUp(t) {
    this._onMouseUpImpl(t), super.onMouseUp(t);
  }
  /** @hidden */
  setDraggingEnabled(t) {
    this._dragging = t;
  }
  /** @hidden */
  onKeyUp(t) {
  }
  /** @hidden */
  onKeyDown(t) {
    t.getKeyCode() === ti.Escape && (this._markup !== null ? (this._markup.cleanup(), this._measureManager.removeMeasurement(this._markup), this._markup = null) : this._measureManager.removeLastMeasurement());
  }
  /** @hidden */
  setHandled() {
    return this._markup !== null && this._markup._getStage() > 1;
  }
  /** @hidden */
  onDeactivate() {
    this._unsetCurrentHighlight(), this._markup !== null && (this._measureManager.removeMeasurement(this._markup), this._markup.cleanup(), this._markup = null);
  }
  /**
   * Sets whether created markup will use authored normals or use selection results to calculate angles
   * @param use
   */
  setUseAuthoredNormals(t) {
    this._useAuthoredNormals = t;
  }
  /**
   * Gets whether created markup will use authored normals or use selection results to calculate angles
   */
  getUseAuthoredNormals() {
    return this._useAuthoredNormals;
  }
}
const fa = class fa extends Rn {
  constructor(t) {
    super(t), this._faceSelection = [], this._line1PreviewShape1 = new Qn(), this._line1PreviewShape2 = new Qn(), this._line2PreviewShape1 = new Qn(), this._line2PreviewShape2 = new Qn(), this._matrix1 = new mt(), this._matrix2 = new mt(), this._lineGeometryShape = new Ba(), this._parallelFaces = !1, this._triangulatedDistance = !0, this._pointsOnSameRay = !1, this._arrowsInvert = !1, this._faceData = [], this._distance = 0, this._surfaceCenter = [_.zero(), _.zero()], this._surfaceAxis1 = [_.zero(), _.zero()], this._surfaceAxis2 = [_.zero(), _.zero()], this._cylinderAxisInfinite1 = [_.zero(), _.zero()], this._cylinderAxisInfinite2 = [_.zero(), _.zero()], this._secondPointInitial = _.zero(), this._firstPointHelper = _.zero(), this._secondPointHelper = _.zero(), this._secondPoint = _.zero(), this._firstPoint = _.zero(), this._textPos = _.zero(), this._name = "MeasureFaceFaceDistance", this._lineGeometryShape.setStrokeWidth(2), this._lineGeometryShape.setStrokeColor(this._viewer.measureManager.getMeasurementColor()), this._textShape = new Fl(), this._textShape.getBoxPortion().setFillOpacity(1), this._textShape.getBoxPortion().setFillColor(new vt(255, 255, 255));
    const i = this._viewer.measureManager.getMeasurementColor();
    for (let n = 0; n < 5; n++)
      this._lineShapes.push(new Qn()), this._lineShapes[n].setStrokeColor(i), this._lineShapes[n].setEndEndcapColor(i), this._lineShapes[n].setStartEndcapColor(i);
  }
  setUnitMultiplier(t) {
    this._unitMultiplier = t;
  }
  setFirstFace(t, e, i, n) {
    const r = t.getNodeId(), o = t.getFaceEntity(), l = t.getPosition();
    if (this._matrix1 = i.copy(), this._viewer.model.setNodeFaceColor(r, o.getCadFaceIndex(), new vt(255, 0, 0)), this._faceSelection[0] = t, this._firstPoint = l.copy(), this._faceData[0] = e, this._faceData[0] instanceof Wi) {
      const h = this._faceData[0], u = new _(
        h.origin.x + h.normal.x,
        h.origin.y + h.normal.y,
        h.origin.z + h.normal.z
      );
      this._matrix1.transform(u, this._surfaceAxis1[0]), this._matrix1.transform(h.origin, this._surfaceCenter[0]);
    } else
      this._faceData[0] instanceof Li && this.createCylinderData(this._faceData[0], i, n);
    this._stage++;
  }
  getFirstSelection() {
    return this._faceSelection[0] || null;
  }
  getFirstFaceData() {
    return this._faceData[0] || null;
  }
  cleanup() {
    const t = this._viewer.model;
    this._stage >= 2 && t.unsetNodeFaceColor(
      this._faceSelection[1].getNodeId(),
      this._faceSelection[1].getFaceEntity().getCadFaceIndex()
    ), this._stage >= 1 && t.unsetNodeFaceColor(
      this._faceSelection[0].getNodeId(),
      this._faceSelection[0].getFaceEntity().getCadFaceIndex()
    );
  }
  createCylinderData(t, e, i) {
    const r = _.subtract(i.max, i.min).length() / 4, o = new _(
      t.origin.x + t.normal.x * 1e4,
      t.origin.y + t.normal.y * 1e4,
      t.origin.z + t.normal.z * 1e4
    ), l = new _(
      t.origin.x - t.normal.x * 1e4,
      t.origin.y - t.normal.y * 1e4,
      t.origin.z - t.normal.z * 1e4
    ), h = new _(0, 0, 0);
    eo(t.origin, o, l, h), this._surfaceCenter[this._stage] = new _(0, 0, 0), e.transform(h, this._surfaceCenter[this._stage]);
    const u = new _(
      h.x + t.normal.x,
      h.y + t.normal.y,
      h.z + t.normal.z
    );
    this._surfaceAxis1[this._stage] = new _(0, 0, 0), e.transform(u, this._surfaceAxis1[this._stage]), u.set(
      h.x - t.normal.x,
      h.y - t.normal.y,
      h.z - t.normal.z
    ), this._surfaceAxis2[this._stage] = new _(0, 0, 0), e.transform(u, this._surfaceAxis2[this._stage]);
    let d = new _(0, 0, 0);
    d = this._surfaceAxis1[this._stage].copy(), d = _.subtract(d, this._surfaceCenter[this._stage]), d.normalize(), this._surfaceAxis1[this._stage].set(
      this._surfaceCenter[this._stage].x + d.x * r,
      this._surfaceCenter[this._stage].y + d.y * r,
      this._surfaceCenter[this._stage].z + d.z * r
    ), this._surfaceAxis2[this._stage].set(
      this._surfaceCenter[this._stage].x - d.x * r,
      this._surfaceCenter[this._stage].y - d.y * r,
      this._surfaceCenter[this._stage].z - d.z * r
    ), this._cylinderAxisInfinite1[this._stage] = new _(
      this._surfaceCenter[this._stage].x + d.x * r * 1e3,
      this._surfaceCenter[this._stage].y + d.y * r * 1e3,
      this._surfaceCenter[this._stage].z + d.z * r * 1e3
    ), this._cylinderAxisInfinite2[this._stage] = new _(
      this._surfaceCenter[this._stage].x - d.x * r * 1e3,
      this._surfaceCenter[this._stage].y - d.y * r * 1e3,
      this._surfaceCenter[this._stage].z - d.z * r * 1e3
    );
  }
  async setSecondFace(t, e, i, n, r) {
    const o = this._faceSelection[0], l = this._faceData[0];
    if (o === void 0 || l === void 0)
      throw new oe("setSecondFace() called before setFirstFace()");
    if (i instanceof Wi) {
      const u = l, d = new _(
        u.origin.x + u.normal.x,
        u.origin.y + u.normal.y,
        u.origin.z + u.normal.z
      );
      this._matrix1.transform(d, this._surfaceAxis1[0]), this._matrix1.transform(u.origin, this._surfaceCenter[0]);
    } else if (i instanceof Li)
      this.createCylinderData(i, n, r);
    else
      return;
    const h = await this._viewer.model.computeMinimumFaceFaceDistance(
      o.getNodeId(),
      o.getFaceEntity().getCadFaceIndex(),
      e.getNodeId(),
      e.getFaceEntity().getCadFaceIndex()
    );
    if (h.distance !== 0) {
      if (this._matrix2 = n.copy(), this._secondPoint = e.getPosition().copy(), this._secondPointInitial = new _(
        this._firstPoint.x,
        this._firstPoint.y,
        this._firstPoint.z
      ), l instanceof Wi && i instanceof Wi) {
        const u = i, d = new _(
          u.origin.x + u.normal.x,
          u.origin.y + u.normal.y,
          u.origin.z + u.normal.z
        );
        this._matrix2.transform(d, this._surfaceAxis1[1]), this._matrix2.transform(u.origin, this._surfaceCenter[1]);
        const g = new _(
          this._surfaceAxis1[0].x - this._surfaceCenter[0].x,
          this._surfaceAxis1[0].y - this._surfaceCenter[0].y,
          this._surfaceAxis1[0].z - this._surfaceCenter[0].z
        ), y = new _(
          this._surfaceAxis1[1].x - this._surfaceCenter[1].x,
          this._surfaceAxis1[1].y - this._surfaceCenter[1].y,
          this._surfaceAxis1[1].z - this._surfaceCenter[1].z
        );
        g.normalize(), y.normalize();
        const m = new _(-g.x, -g.y, -g.z);
        if (g.equalsWithTolerance(y, 1e-5) || m.equalsWithTolerance(y, 1e-5)) {
          this._secondPointHelper = new _(
            this._secondPoint.x,
            this._secondPoint.y,
            this._secondPoint.z
          ), this._firstPointHelper = new _(
            this._firstPoint.x,
            this._firstPoint.y,
            this._firstPoint.z
          );
          const x = new ln();
          x.setFromPointAndNormal(this._surfaceCenter[0], g);
          const b = new ln();
          b.setFromPointAndNormal(this._surfaceCenter[1], y);
          const I = new _(
            this._firstPoint.x + g.x,
            this._firstPoint.y + g.y,
            this._firstPoint.z + g.z
          );
          if (Sm(o.getPosition(), I, b, this._secondPoint), m.equalsWithTolerance(y, 1e-5)) {
            const V = new _(-g.x, -g.y, -g.z);
            x.setFromPointAndNormal(this._surfaceCenter[0], V);
          }
          const C = Math.abs(b.d - x.d) / x.normal.length();
          this._distance = C, this._setMeasurementValue(this._distance), this._parallelFaces = !0, this._triangulatedDistance = !1;
          const P = new _(0, 1, 0), k = _.subtract(this._secondPoint, this._firstPoint);
          let O = new _(0, 0, 0);
          O = _.subtract(this._secondPointHelper, this._firstPoint);
          const B = yr(P, k), j = yr(P, O);
          this._textPos.assign(this._secondPoint), B - j < 0.1 && B - j > -0.1 && (this._pointsOnSameRay = !0);
        } else
          this._firstPoint.assign(h.pos1), this._secondPoint.assign(h.pos2), this._textPos.assign(h.pos2), this._distance = h.distance, this._setMeasurementValue(this._distance);
      } else if (l instanceof Li && i instanceof Li) {
        const u = new _(
          this._surfaceAxis1[0].x - this._surfaceCenter[0].x,
          this._surfaceAxis1[0].y - this._surfaceCenter[0].y,
          this._surfaceAxis1[0].z - this._surfaceCenter[0].z
        ), d = new _(
          this._surfaceAxis1[1].x - this._surfaceCenter[1].x,
          this._surfaceAxis1[1].y - this._surfaceCenter[1].y,
          this._surfaceAxis1[1].z - this._surfaceCenter[1].z
        );
        u.normalize(), d.normalize();
        const g = new _(-u.x, -u.y, -u.z);
        if (u.equalsWithTolerance(d, 1e-5) || g.equalsWithTolerance(d, 1e-5)) {
          const y = new _(0, 0, 0);
          eo(
            this._firstPoint,
            this._cylinderAxisInfinite1[0],
            this._cylinderAxisInfinite2[0],
            y
          ), this._firstPoint = y.copy();
          let m = new _(this._firstPoint.x, this._firstPoint.y, this._firstPoint.z);
          m = _.subtract(m, this._surfaceCenter[0]), m.set(0, 0, 0), eo(
            this._firstPoint,
            this._cylinderAxisInfinite1[1],
            this._cylinderAxisInfinite2[1],
            y
          ), this._secondPoint = y.copy();
          const x = _.subtract(this._secondPoint, this._firstPoint).length();
          if (x < 1e-7)
            return;
          this._triangulatedDistance = !1, this._textPos.assign(this._secondPoint), this._setMeasurementValue(x);
        } else {
          if (this._distance = lv(
            this._cylinderAxisInfinite1[0],
            this._cylinderAxisInfinite2[0],
            this._cylinderAxisInfinite1[1],
            this._cylinderAxisInfinite2[1],
            this._firstPoint,
            this._secondPoint
          ), this._distance < 1e-7)
            return;
          this._textPos.assign(this._firstPoint), this._setMeasurementValue(this._distance);
        }
      } else if (l instanceof Li && i instanceof Wi) {
        const u = new _(
          this._surfaceAxis1[0].x - this._surfaceCenter[0].x,
          this._surfaceAxis1[0].y - this._surfaceCenter[0].y,
          this._surfaceAxis1[0].z - this._surfaceCenter[0].z
        ).normalize(), d = await this._viewer.model.computeMinimumFaceLineDistance(
          e.getNodeId(),
          e.getFaceEntity().getCadFaceIndex(),
          new wr(this._surfaceCenter[0], u)
        );
        if (this._distance = d.distance, this._distance < 1e-7)
          return;
        this._firstPoint.assign(d.pos1), this._secondPoint.assign(d.pos2), this._textPos.assign(d.pos2), this._secondPointHelper = new _(
          this._secondPoint.x,
          this._secondPoint.y,
          this._secondPoint.z
        ), this._firstPointHelper = new _(
          this._firstPoint.x,
          this._firstPoint.y,
          this._firstPoint.z
        ), this._viewer.model.setNodeFaceColor(
          e.getNodeId(),
          e.getFaceEntity().getCadFaceIndex(),
          new vt(255, 0, 0)
        ), this._faceData[1] = i, this._faceSelection[1] = e, this._stage++, this.adjust(t), this._setMeasurementValue(this._distance);
      } else if (l instanceof Wi && i instanceof Li) {
        const u = new _(
          this._surfaceAxis1[1].x - this._surfaceCenter[1].x,
          this._surfaceAxis1[1].y - this._surfaceCenter[1].y,
          this._surfaceAxis1[1].z - this._surfaceCenter[1].z
        ).normalize(), d = await this._viewer.model.computeMinimumFaceLineDistance(
          o.getNodeId(),
          o.getFaceEntity().getCadFaceIndex(),
          new wr(this._surfaceCenter[1], u)
        );
        if (this._distance = d.distance, this._distance < 1e-7)
          return;
        this._firstPoint.assign(d.pos1), this._secondPoint.assign(d.pos2), this._textPos.assign(d.pos2), this._secondPointHelper = new _(
          this._secondPoint.x,
          this._secondPoint.y,
          this._secondPoint.z
        ), this._firstPointHelper = new _(
          this._firstPoint.x,
          this._firstPoint.y,
          this._firstPoint.z
        ), this._viewer.model.setNodeFaceColor(
          e.getNodeId(),
          e.getFaceEntity().getCadFaceIndex(),
          new vt(255, 0, 0)
        ), this._faceData[1] = i, this._faceSelection[1] = e, this._stage++, this.adjust(t), this._setMeasurementValue(this._distance);
      } else {
        if (this._firstPoint.assign(h.pos1), this._secondPoint.assign(h.pos2), this._textPos.assign(h.pos2), this._distance = h.distance, this._distance < 1e-7)
          return;
        this._setMeasurementValue(this._distance);
      }
      this._viewer.model.setNodeFaceColor(
        e.getNodeId(),
        e.getFaceEntity().getCadFaceIndex(),
        new vt(255, 0, 0)
      ), this._faceData[1] = i, this._faceSelection[1] = e, this._stage++, this.adjust(t);
    }
  }
  adjust(t) {
    if (super.adjust(t), this._stage <= 1)
      return;
    const e = this._viewer.view.raycastFromPoint(t);
    if (e === null)
      return;
    const i = new _(
      e.origin.x + e.direction.x * 1e6,
      e.origin.y + e.direction.y * 1e6,
      e.origin.z + e.direction.z * 1e6
    ), n = Cm(e.direction);
    let r = new _(0, 0, 0);
    r = _.cross(e.direction, n), r.normalize();
    let o = new _(
      (this._firstPoint.x + this._secondPoint.x) / 2,
      (this._firstPoint.y + this._secondPoint.y) / 2,
      (this._firstPoint.z + this._secondPoint.z) / 2
    );
    o = this._textPos.copy(), n.set(o.x + n.x, o.y + n.y, o.z + n.z), r.set(o.x + r.x, o.y + r.y, o.z + r.z);
    const l = new _(0, 0, 0);
    if (zo(e.origin, i, o, n, r, l), this._stage === 2)
      eo(l, this._firstPoint, this._secondPoint, this._textPos);
    else if (this._parallelFaces || this._triangulatedDistance) {
      const h = new _(0, 0, 0), u = this._faceData[0] instanceof Li || this._faceData[1] instanceof Li, d = this._faceData[0] instanceof Wi || this._faceData[1] instanceof Wi;
      if (!this._pointsOnSameRay) {
        u && d ? eo(l, this._secondPoint, this._secondPointInitial, h) : eo(l, this._secondPoint, this._secondPointHelper, h);
        let g = new _(0, 0, 0);
        g = _.subtract(h, this._secondPoint), this._secondPoint = h.copy(), this._firstPoint.set(
          this._firstPoint.x + g.x,
          this._firstPoint.y + g.y,
          this._firstPoint.z + g.z
        ), this._textPos.set(
          this._textPos.x + g.x,
          this._textPos.y + g.y,
          this._textPos.z + g.z
        );
      }
    } else {
      const h = new _(0, 0, 0);
      eo(
        l,
        this._cylinderAxisInfinite1[1],
        this._cylinderAxisInfinite2[1],
        h
      );
      const u = _.subtract(h, this._secondPoint);
      this._secondPoint = h.copy(), this._firstPoint.set(
        this._firstPoint.x + u.x,
        this._firstPoint.y + u.y,
        this._firstPoint.z + u.z
      ), this._textPos.set(
        this._textPos.x + u.x,
        this._textPos.y + u.y,
        this._textPos.z + u.z
      );
    }
    this._updateArrowsInverted(), this._viewer.markupManager.refreshMarkup(this._viewer.view);
  }
  _updateArrowsInverted() {
    const t = new _(
      (this._firstPoint.x + this._secondPoint.x) / 2,
      (this._firstPoint.y + this._secondPoint.y) / 2,
      (this._firstPoint.z + this._secondPoint.z) / 2
    ), e = _.subtract(this._secondPoint, this._firstPoint);
    _.subtract(this._textPos, t).length() * 2 > e.length() ? this._arrowsInvert = !0 : this._arrowsInvert = !1;
  }
  _nextStage() {
    this._stage++, (this._stage > 3 || this._stage > 2 && this._triangulatedDistance) && (this._finalized = !0, this.cleanup());
  }
  /** @hidden */
  update() {
    super.update();
    const t = this._viewer.view;
    if (this._behindView = !1, this._stage === 0)
      return;
    const e = new Array(10), i = [];
    for (let n = 0; n < 10; n++)
      i.push(new _(0, 0, 0));
    this._faceData[0] instanceof Li && (i[0] = t.projectPoint(this._surfaceCenter[0]), i[1] = t.projectPoint(this._surfaceAxis1[0]), i[2] = t.projectPoint(this._surfaceAxis2[0]), e[0] = K.fromPoint3(i[0]), e[1] = K.fromPoint3(i[1]), e[2] = K.fromPoint3(i[2]), this._line1PreviewShape1.set(e[0], e[1]), this._line1PreviewShape2.set(e[0], e[2])), this._stage > 1 && this._faceData[1] instanceof Li && (i[0] = t.projectPoint(this._surfaceCenter[1]), i[1] = t.projectPoint(this._surfaceAxis1[1]), i[2] = t.projectPoint(this._surfaceAxis2[1]), e[0] = K.fromPoint3(i[0]), e[1] = K.fromPoint3(i[1]), e[2] = K.fromPoint3(i[2]), this._line2PreviewShape1.set(e[0], e[1]), this._line2PreviewShape2.set(e[0], e[2])), this._stage > 1 && (i[0] = t.projectPoint(this._textPos), i[1] = t.projectPoint(this._firstPoint), i[2] = t.projectPoint(this._secondPoint), e[0] = K.fromPoint3(i[0]), e[1] = K.fromPoint3(i[1]), e[2] = K.fromPoint3(i[2]), this._textShape && this._textShape.setPosition(e[0]), this._lineShapes[0].setEndcapType(_n.Arrowhead), this._lineShapes[0].setStartEndcapType(_n.Arrowhead), this._lineShapes[0].setEndcapsInverted(this._arrowsInvert), this._lineShapes[0].set(e[1], e[2]), i[3] = t.projectPoint(this._firstPointHelper), i[4] = t.projectPoint(this._secondPointHelper), e[3] = K.fromPoint3(i[3]), e[4] = K.fromPoint3(i[4]), this._lineShapes[1].set(e[2], e[4]), this._lineShapes[2].set(e[1], e[3]), this._lineShapes[3].set(e[1], e[0]));
    for (let n = 0; n < 6; n++)
      i[n].z < 0 && (this._behindView = !0);
  }
  draw() {
    if (this._visibility && this._viewer.explodeManager.getMagnitude() === 0 && (this.update(), !this._behindView)) {
      const t = this._faceData[0] instanceof Li || this._faceData[1] instanceof Li, e = this._faceData[0] instanceof Wi || this._faceData[1] instanceof Wi, i = this._viewer.markupManager.getRenderer();
      switch (this._stage) {
        case 1:
          this._faceData[0] instanceof Li && (i.drawLine(this._line1PreviewShape1), i.drawLine(this._line1PreviewShape2));
          break;
        case 2:
        case 3:
        case 4:
          this._faceData[0] instanceof Li && (i.drawLine(this._line1PreviewShape1), i.drawLine(this._line1PreviewShape2)), this._faceData[1] instanceof Li && (i.drawLine(this._line2PreviewShape1), i.drawLine(this._line2PreviewShape2)), t && e ? (i.drawLine(this._lineShapes[0]), i.drawLine(this._lineShapes[1]), i.drawLine(this._lineShapes[2]), i.drawLine(this._lineShapes[3]), i.drawTextBox(this._textShape)) : (i.drawLine(this._lineShapes[0]), this._parallelFaces && (i.drawLine(this._lineShapes[1]), i.drawLine(this._lineShapes[2])), i.drawLine(this._lineShapes[3]), i.drawTextBox(this._textShape));
          break;
      }
    }
  }
  //serialization methods
  static _serializeFaceProp(t) {
    return t instanceof Li ? {
      type: "CylinderElement",
      origin: t.origin.toJson(),
      normal: t.normal.toJson(),
      radius: t.radius
    } : t instanceof Wi ? {
      type: "PlaneElement",
      origin: t.origin.toJson(),
      normal: t.normal.toJson()
    } : null;
  }
  static _constructFaceProp(t) {
    if (t.type === "CylinderElement") {
      const e = _.fromJson(t.origin), i = _.fromJson(t.normal), n = t.radius;
      return new Li(n, e, i);
    } else if (t.type === "PlaneElement") {
      const e = _.fromJson(t.origin), i = _.fromJson(t.normal);
      return new Wi(e, i);
    } else
      return null;
  }
  // serialization methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    const t = [];
    for (const r of this._faceData)
      t.push(fa._serializeFaceProp(r));
    const e = [];
    for (const r of this._surfaceCenter)
      e.push(r.toJson());
    const i = [];
    for (const r of this._surfaceAxis1)
      i.push(r.toJson());
    const n = [];
    for (const r of this._surfaceAxis2)
      n.push(r.toJson());
    return {
      text: this._textShape.getTextString(),
      textPos: this._textPos.toJson(),
      firstPoint: this._firstPoint.toJson(),
      secondPoint: this._secondPoint.toJson(),
      firstPointHelper: this._firstPointHelper.toJson(),
      secondPointHelper: this._secondPointHelper.toJson(),
      secondPointInitial: this._secondPointInitial.toJson(),
      measurementValue: this._measurementValue,
      unitMultiplier: this._unitMultiplier,
      parallelFaces: this._parallelFaces,
      faceData: t,
      surfaceCenter: e,
      surfaceAxis1: i,
      surfaceAxis2: n,
      name: this.getName(),
      className: this.getClassName()
    };
  }
  /**
   * Creates a new [[MeasureFaceFaceDistanceMarkup]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t, e) {
    const i = t, n = new fa(e);
    n.setName(i.name), n._textShape.setTextString(i.text), n._textPos.assign(_.fromJson(i.textPos)), n._firstPoint.assign(_.fromJson(i.firstPoint)), n._firstPointHelper.assign(_.fromJson(i.firstPointHelper)), n._secondPoint.assign(_.fromJson(i.secondPoint)), n._secondPointHelper.assign(_.fromJson(i.secondPointHelper)), i.secondPointInitial !== void 0 && n._secondPointInitial.assign(_.fromJson(i.secondPointInitial)), console.assert(Array.isArray(i.faceData));
    for (const r of i.faceData) {
      const o = fa._constructFaceProp(r);
      console.assert(o !== null), n._faceData.push(o);
    }
    return n._surfaceCenter[0].assign(i.surfaceCenter[0]), n._surfaceCenter[1].assign(i.surfaceCenter[1]), n._surfaceAxis1[0].assign(i.surfaceAxis1[0]), n._surfaceAxis1[1].assign(i.surfaceAxis1[1]), n._surfaceAxis2[0].assign(i.surfaceAxis2[0]), n._surfaceAxis2[1].assign(i.surfaceAxis2[1]), n._stage = 4, n._parallelFaces = i.parallelFaces, n._measurementValue = i.measurementValue, n._unitMultiplier = i.unitMultiplier || 1, n;
  }
  getClassName() {
    return fa.className;
  }
};
fa.className = "Communicator.Markup.Measure.MeasureFaceFaceDistanceMarkup";
let Pl = fa;
as(
  Pl.className,
  Pl.fromJson
);
class wy extends Ai {
  constructor(t, e, i) {
    super(t, e), this._moveSelectionAction = new fo(!0), this._currentHighlight = null, this._markup = null, this._measureManager = i;
  }
  _unsetCurrentHighlight() {
    this._currentHighlight !== null && (this._viewer.model.unsetNodeFaceColor(
      this._currentHighlight.getNodeId(),
      this._currentHighlight.getFaceEntity().getCadFaceIndex()
    ), this._currentHighlight = null);
  }
  async _performMoveSelection(t) {
    const e = this._view, i = this._viewer.model, n = await e.pickFromPoint(t, new Si());
    if (n.overlayIndex() !== 0 || !n.isFaceSelection())
      return;
    const r = n.getNodeId(), o = n.getFaceEntity();
    if (i.getNodeType(r) === Le.BodyInstance) {
      if (this._markup) {
        const l = this._markup.getFirstSelection();
        if (l !== null && r === l.getNodeId() && o.getCadFaceIndex() === l.getFaceEntity().getCadFaceIndex())
          return;
      }
      this._currentHighlight !== null ? n.equals(this._currentHighlight) ? n.getSelectionType() === On.None && this._unsetCurrentHighlight() : (this._unsetCurrentHighlight(), await i.isFaceMeasurable(r, o.getCadFaceIndex()) && (this._currentHighlight = n, i.setNodeFaceColor(r, o.getCadFaceIndex(), vt.yellow()))) : await i.isFaceMeasurable(r, o.getCadFaceIndex()) && (this._currentHighlight = n, i.setNodeFaceColor(r, o.getCadFaceIndex(), vt.yellow()));
    }
  }
  async _performUpSelection(t) {
    const e = this._view, i = this._viewer.model, n = await e.pickFromPoint(t, new Si());
    if (n.overlayIndex())
      return;
    if (this._markup && this._markup._getStage() > 1) {
      if (this._viewer.trigger("measurementBegin"), this._markup._nextStage(), this._markup._isFinalized()) {
        const d = this._markup;
        this._markup = null, this._measureManager.finalizeMeasurement(d);
      }
      return;
    }
    if (!n.isFaceSelection())
      return;
    const r = n.getNodeId(), o = n.getFaceEntity();
    if (!await i.isFaceMeasurable(r, o.getCadFaceIndex()) || !(i.getNodeType(r) === Le.BodyInstance && (!this._markup || this._markup._getStage() <= 1)))
      return;
    const h = await i.getFaceProperty(r, o.getCadFaceIndex());
    if (!h)
      return;
    const u = i.getNodeNetMatrix(r);
    if (this._unsetCurrentHighlight(), h instanceof Wi || h instanceof Li) {
      const d = await i.getNodesBounding([r]);
      this._markup ? await this._markup.setSecondFace(t, n, h, u, d) : (this._markup = new Pl(this._viewer), this._markup.setUnitMultiplier(i.getNodeUnitMultiplier(r)), this._markup.setFirstFace(n, h, u, d), this._measureManager.addMeasurement(this._markup));
    }
  }
  /** @hidden */
  onMouseMove(t) {
    super.onMouseMove(t);
    const e = t.getPosition();
    (!this._markup || this._markup._getStage() <= 1) && this._moveSelectionAction.set(() => this._performMoveSelection(e)), this._viewer.markupManager.refreshMarkup(this._viewer.view), this._markup !== null && this._markup._getStage() > 0 && this._markup.adjust(e);
  }
  async _onMouseUpImpl(t) {
    if (!this.isActive())
      return;
    const e = this._primaryTouchId !== null && this._markup !== null && this._markup._getStage() > 1;
    if (!(this._dragCount < 3 || e))
      return;
    const i = t.getPosition();
    await this._performUpSelection(i);
  }
  /** @hidden */
  onMouseUp(t) {
    this._onMouseUpImpl(t), super.onMouseUp(t);
  }
  /** @hidden */
  setDraggingEnabled(t) {
    this._dragging = t;
  }
  /** @hidden */
  onKeyUp(t) {
  }
  /** @hidden */
  onKeyDown(t) {
    t.getKeyCode() === ti.Escape && (this._markup !== null ? (this._markup.cleanup(), this._measureManager.removeMeasurement(this._markup), this._markup = null) : this._measureManager.removeLastMeasurement());
  }
  /** @hidden */
  setHandled() {
    return this._markup !== null && this._markup._getStage() > 1;
  }
  /** @hidden */
  onDeactivate() {
    super.onDeactivate(), this._unsetCurrentHighlight(), this._markup !== null && (this._measureManager.removeMeasurement(this._markup), this._markup.cleanup(), this._markup = null);
  }
}
const Hc = class Hc extends Rn {
  constructor(t) {
    super(t), this._anchorLinePoint = null, this._firstLinePoint = null, this._secondLinePoint = null, this._selectionPosition = null, this._lineGeometryShape = new Ba(), this._viewer = t, this._name = "MeasureLineLineAngle", this._lineGeometryShape.setStrokeWidth(2), this._lineGeometryShape.setStrokeColor(this._viewer.measureManager.getMeasurementColor()), this._lineGeometryShape.setEndcapType(_n.Arrowhead), this._lineGeometryShape.setStartEndcapType(_n.Arrowhead), this._lineGeometryShape.setEndEndcapSize(5), this._lineGeometryShape.setStartEndcapSize(5), this._lineGeometryShape.setEndEndcapColor(this._viewer.measureManager.getMeasurementColor()), this._lineGeometryShape.setStartEndcapColor(this._viewer.measureManager.getMeasurementColor()), this._textShape.getBoxPortion().setFillOpacity(1), this._textShape.getBoxPortion().setFillColor(vt.white());
  }
  addPoint(t) {
    if (this._finalized)
      return !1;
    if (this._anchorLinePoint === null)
      this._anchorLinePoint = t.copy(), this._stage = 1;
    else if (this._firstLinePoint === null) {
      if (t.equals(this._anchorLinePoint))
        return !1;
      this._firstLinePoint = t.copy(), this._stage = 2;
    } else {
      if (t.equals(this._anchorLinePoint) || t.equals(this._firstLinePoint))
        return !1;
      const e = _.subtract(this._firstLinePoint, this._anchorLinePoint), i = _.subtract(t, this._anchorLinePoint), n = yr(e, i);
      if (n === 0 || n === 180)
        return !1;
      this._secondLinePoint = t.copy(), this.setMeasurementText(`${n.toFixed(2)}°`), this._measurementValue = n, this._finalized = !0, this._stage = 3;
    }
    return this.draw(), !0;
  }
  setSelectionPosition(t) {
    this._selectionPosition = t;
  }
  getLineGeometryShape() {
    return this._lineGeometryShape;
  }
  _drawPreviewLine(t, e) {
    const i = this._viewer.markupManager.getRenderer(), n = this._viewer.view, r = K.fromPoint3(n.projectPoint(t)), o = K.fromPoint3(n.projectPoint(e)), l = new Qn(r, o);
    i.drawLine(l);
  }
  _drawAngleMarkup(t, e, i) {
    const n = this._viewer.markupManager.getRenderer(), r = this._viewer.view, o = _.subtract(e, t), l = _.subtract(i, t), h = _.cross(o, l).normalize(), u = yr(o, l);
    if (u !== 0 && u !== 180 && !isNaN(u)) {
      const C = xf(h, -u, t, l, 30);
      this._lineGeometryShape.clearPoints();
      for (const P of C)
        this._lineGeometryShape.pushPoint(K.fromPoint3(r.projectPoint(P)));
      n.drawPolyline(this._lineGeometryShape);
    }
    const d = l.length(), g = _.add(
      t,
      o.copy().normalize().scale(d)
    ), y = K.fromPoint3(r.projectPoint(t)), m = K.fromPoint3(r.projectPoint(g)), x = K.fromPoint3(r.projectPoint(i)), b = new Qn(y, m);
    n.drawLine(b);
    const I = new Qn(y, x);
    n.drawLine(I), this._textShape.setPosition(m), this._finalized ? this._textShape.setTextString(this.getMeasurementText()) : isNaN(u) ? this._textShape.setTextString("0°") : this._textShape.setTextString(`${u.toFixed(2)}°`), n.drawTextBox(this._textShape);
  }
  draw() {
    if (!(!this._visibility || this._anchorLinePoint === null || this._viewer.view.projectPoint(this._anchorLinePoint).z <= 0)) {
      if (this._stage === 1) {
        if (this._selectionPosition === null)
          return;
        this._drawPreviewLine(this._anchorLinePoint, this._selectionPosition);
      } else if (this._stage === 2) {
        if (this._firstLinePoint === null || this._selectionPosition === null)
          return;
        this._drawAngleMarkup(this._anchorLinePoint, this._firstLinePoint, this._selectionPosition);
      } else if (this._stage === 3) {
        if (this._firstLinePoint == null || this._secondLinePoint == null)
          return;
        this._drawAngleMarkup(this._anchorLinePoint, this._firstLinePoint, this._secondLinePoint);
      }
    }
  }
  // serialization methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      name: this._name,
      anchorPoint: this._anchorLinePoint.copy(),
      firstPoint: this._firstLinePoint.copy(),
      secondPoint: this._secondLinePoint.copy(),
      measurementValue: this._measurementValue,
      measurementText: this.getMeasurementText(),
      className: this.getClassName()
    };
  }
  /**
   * Creates a new [[MeasurePointPointDistanceMarkup]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t, e) {
    const i = t, n = new Hc(e);
    return n._name = i.name, n._anchorLinePoint = _.fromJson(i.anchorPoint), n._firstLinePoint = _.fromJson(i.firstPoint), n._secondLinePoint = _.fromJson(i.secondPoint), n._measurementValue = i.measurementValue, n.setMeasurementText(i.measurementText), n._finalized = !0, n._stage = 3, n;
  }
  getClassName() {
    return Hc.className;
  }
};
Hc.className = "Communicator.Markup.Measure.MeasureLineLineAngleMarkup";
let kl = Hc;
as(kl.className, kl.fromJson);
class Og extends Rn {
  constructor(t, e) {
    super(t), this._cursorSprite = new Gr(), this._removed = !1, this._view = e, this._name = "CursorMarkup";
    const i = t.measureManager.getMeasurementColor();
    this._cursorSprite.setFillColor(i), this._cursorSprite.setStrokeColor(i), this._cursorSprite.setRadius(0), this._markupId = t.markupManager.registerMarkup(this, e);
  }
  draw() {
    this._viewer.markupManager.getRenderer().drawCircle(this._cursorSprite);
  }
  enable(t) {
    this._cursorSprite.setRadius(t ? 2.5 : 0);
  }
  isEnabled() {
    return this._cursorSprite.getRadius() > 0;
  }
  setPosition(t) {
    this._cursorSprite.setCenter(t);
  }
  destroy() {
    this._removed || this._viewer.markupManager.unregisterMarkup(this._markupId, this._view);
  }
  remove(t) {
    this._removed = !0;
  }
}
class vy {
  constructor(t, e, i) {
    this.worldPosition = t, this.screenPosition = e, this.selectionItem = i;
  }
}
class Vh {
  constructor(t, e) {
    this._cursorMarkup = null, this._updateCursorSpriteAction = new fo(!0), this._viewer = t, this._view = e, this.snappingConfig = {
      enabled: !0,
      preferVertices: !0
    };
  }
  async getSelectionCursorPoints(t, e, i) {
    const n = new Si(e ? Se.All : Se.Face);
    e && (n.enableProximityFaces = !0, n.restrictLinesAndPointsToSelectedFaceInstances = !1);
    const r = await this._view.pickFromPoint(t, n);
    if (r.overlayIndex() !== 0)
      return null;
    let o = r.getPosition(), l = t;
    if (this.snappingConfig.enabled) {
      const h = r.getLineEntity(), u = r.getPointEntity(), d = r.getFaceEntity();
      if (h || u || d) {
        let g = null;
        h !== null ? g = this._getLineSnapPoint(h, e, i) : u !== null ? g = u.getPosition() : d !== null && d.isProximityFace() && (g = d.getPosition()), g !== null && (o = g, l = Ru(this._view, o));
      }
    }
    return new vy(o, l, r);
  }
  updateCursorSprite(t, e, i) {
    this._updateCursorSpriteAction.set(() => this._updateCursorSpriteImpl(t, e, i));
  }
  async _updateCursorSpriteImpl(t, e, i) {
    if (this._cursorMarkup !== null)
      if (e) {
        const n = await this.getSelectionCursorPoints(
          t,
          e,
          i
        );
        n !== null ? (this._cursorMarkup.setPosition(n.screenPosition), this.activateCursorSprite(!0)) : this.activateCursorSprite(!1);
      } else
        this._cursorMarkup.setPosition(t);
  }
  draw() {
    this._cursorMarkup !== null && this._cursorMarkup.draw();
  }
  activateCursorSprite(t) {
    this._cursorMarkup !== null && this._cursorMarkup.enable(t);
  }
  /**
   * Finds the best point to use for the given lineEntity given the snapping behavior and settings.
   */
  _getLineSnapPoint(t, e, i) {
    const n = this.snappingConfig.preferVertices ? t.getBestVertex() : null;
    if (n !== null)
      return n;
    const r = t.getPosition();
    if (!e || i == null)
      return r;
    const o = t.getPoints(), l = 1e-10, h = (() => {
      for (let C = 0; C < o.length - 1; C++)
        if (hv(o[C], o[C + 1], r, l))
          return C;
      return 0;
    })(), u = o[h], d = o[h + 1];
    if (u === void 0 || d === void 0)
      return r;
    const g = cv(u, d, i), y = Ru(this._view, g), m = Ru(this._view, r), x = K.subtract(
      y,
      m
    ).squaredLength(), b = this._viewer.selectionManager.getPickTolerance(), I = b * b;
    return x <= I ? g : r;
  }
  _clearCursorMarkup() {
    this._cursorMarkup !== null && (this._cursorMarkup.destroy(), this._cursorMarkup = null);
  }
  onOperatorActivate() {
    this._clearCursorMarkup(), this._cursorMarkup = new Og(this._viewer, this._view), this._viewer.sheetManager.isDrawingSheetActive() && this._viewer.sheetManager.setBackgroundSelectionEnabled(!0);
  }
  onOperatorDeactivate() {
    this._clearCursorMarkup(), this._viewer.sheetManager.isDrawingSheetActive() && this._viewer.sheetManager.setBackgroundSelectionEnabled(!1);
  }
}
class by extends Ai {
  constructor(t, e, i) {
    super(t, e), this._markupItem = null, this._cameraInteractionActive = !1, this._measureManager = i, this._cursor = new Vh(t, e), this._viewer.setCallbacks({
      beginInteraction: () => {
        this._onBeginInteraction();
      },
      endInteraction: () => {
        this._onEndInteraction();
      }
    });
  }
  _onBeginInteraction() {
    this._cameraInteractionActive = !0, this._cursor.activateCursorSprite(!1);
  }
  _onEndInteraction() {
    this._cameraInteractionActive = !1;
  }
  /**
   * Determine if the given mouse event should cause snapping.
   * This is influenced by the snap configuration enabled value.
   */
  _useSnapping(t) {
    return this._cursor.snappingConfig.enabled && !t.altDown();
  }
  async _addPoint(t, e) {
    const i = await this._cursor.getSelectionCursorPoints(t, e, null);
    if (!(i === null || i.worldPosition === null) && (this._markupItem === null && (this._markupItem = new kl(this._viewer), this._measureManager.addMeasurement(this._markupItem), this._viewer.trigger("measurementBegin")), this._markupItem.addPoint(i.worldPosition), this._markupItem._isFinalized())) {
      const n = this._markupItem;
      this._markupItem = null, this._measureManager.finalizeMeasurement(n);
    }
  }
  async _updateMarkupSelectionPosition(t, e) {
    if (this._markupItem === null)
      return;
    const i = await this._cursor.getSelectionCursorPoints(t, e, null);
    i !== null && this._markupItem.setSelectionPosition(i.worldPosition);
  }
  async onMouseMove(t) {
    if (super.onMouseMove(t), this._cameraInteractionActive)
      return;
    const e = t.getPosition(), i = this._useSnapping(t);
    this._cursor.updateCursorSprite(e, i, null), await this._updateMarkupSelectionPosition(e, i), this._viewer.markupManager.refreshMarkup(this._viewer.view);
  }
  async onMouseUp(t) {
    if (!this.isActive())
      return;
    const e = t.getPosition();
    this._ptFirst.equals(e) && await this._addPoint(e, this._useSnapping(t)), super.onMouseUp(t);
  }
  onKeyDown(t) {
    t.getKeyCode() === ti.Escape && this._clearMeasurement();
  }
  _clearMeasurement() {
    this._markupItem !== null ? (this._measureManager.removeMeasurement(this._markupItem), this._markupItem = null) : this._measureManager.removeLastMeasurement();
  }
  setHandled() {
    return this._markupItem !== null && this._markupItem._getStage() > 1;
  }
  onActivate() {
    this._cursor.onOperatorActivate();
  }
  onDeactivate() {
    this._cursor.onOperatorDeactivate(), this._markupItem !== null && (this._measureManager.removeMeasurement(this._markupItem), this._markupItem = null);
  }
}
const Uc = class Uc extends Rn {
  constructor(t) {
    super(t), this._firstPointShape = new Gr(), this._secondPointShape = new Gr(), this._arrowsInvert = !1, this._name = "MeasurePointPointDistance", this._lineShapes = [];
    for (let e = 0; e < 6; e++)
      this._lineShapes.push(new Qn()), this._lineShapes[e].setStrokeColor(this._viewer.measureManager.getMeasurementColor()), this._lineShapes[e].setEndEndcapColor(this._viewer.measureManager.getMeasurementColor()), this._lineShapes[e].setStartEndcapColor(this._viewer.measureManager.getMeasurementColor());
    this._viewer = t, this.initCircle(this._firstPointShape), this.initCircle(this._secondPointShape), this._textShape = new Fl(), this._textShape.getBoxPortion().setFillOpacity(1), this._textShape.getBoxPortion().setFillColor(new vt(255, 255, 255));
  }
  initCircle(t) {
    t.setRadius(2.5), t.setFillColor(this._viewer.measureManager.getMeasurementColor());
  }
  setUnitMultiplier(t) {
    this._unitMultiplier = t;
  }
  setFirstPointPosition(t) {
    this._stage = 1, this._positions[0] = t.copy();
  }
  setSecondPointPosition(t) {
    this._stage = 2, this._positions[1] = t.copy(), this._positions[2] = t.copy(), this._setMeasurementValue(_.subtract(this._positions[1], this._positions[0]).length());
  }
  _getStage() {
    return this._stage;
  }
  finalize() {
    this._stage++;
  }
  getFirstPointPosition() {
    return this._positions[0];
  }
  getSecondPointPosition() {
    return this._positions[1];
  }
  adjust(t) {
    super.adjust(t);
    const e = this._viewer.view.raycastFromPoint(t);
    if (e === null)
      return;
    const i = this._positions[0], n = this._positions[1];
    let r = new _(1, 0, 0);
    n.equals(i) || (r = _.subtract(n, i));
    const l = this._viewer.view.getCamera().getUp(), h = _.cross(e.direction, l).normalize(), u = new _(
      (i.x + n.x) / 2,
      (i.y + n.y) / 2,
      (i.z + n.z) / 2
    ), d = new _(u.x + l.x, u.y + l.y, u.z + l.z), g = new _(
      u.x + h.x,
      u.y + h.y,
      u.z + h.z
    ), y = new _(
      e.origin.x + e.direction.x * 1e6,
      e.origin.y + e.direction.y * 1e6,
      e.origin.z + e.direction.z * 1e6
    );
    let m = new _(0, 0, 0);
    zo(
      e.origin,
      y,
      u,
      d,
      g,
      m
    ), this._positions[2].assign(m);
    let x = new _(0, 0, 0);
    Math.abs(r.x) <= Math.abs(r.y) && Math.abs(r.x) <= Math.abs(r.z) ? x = new _(1, 0, 0) : Math.abs(r.y) <= Math.abs(r.x) && Math.abs(r.y) <= Math.abs(r.z) ? x = new _(0, 1, 0) : x = new _(0, 0, 1);
    const b = _.cross(x, r), I = _.cross(b, r);
    b.set(
      i.x + b.x,
      i.y + b.y,
      i.z + b.z
    ), I.set(
      i.x + I.x,
      i.y + I.y,
      i.z + I.z
    );
    const C = new _(
      m.x + r.x * 1e4,
      m.y + r.y * 1e4,
      m.z + r.z * 1e4
    ), P = new _(
      m.x - r.x * 1e4,
      m.y - r.y * 1e4,
      m.z - r.z * 1e4
    ), k = zo(
      C,
      P,
      i,
      b,
      I,
      m
    ), O = !isNaN(m.x) && !isNaN(m.y) && !isNaN(m.z);
    (!k || !O) && (m = n.copy());
    const B = _.subtract(m, i);
    this._positions[3] = new _(
      i.x + B.x,
      i.y + B.y,
      i.z + B.z
    ), this._positions[4] = new _(
      n.x + B.x,
      n.y + B.y,
      n.z + B.z
    ), this._updateArrowsInverted(), this._viewer.markupManager.refreshMarkup(this._viewer.view);
  }
  _updateArrowsInverted() {
    const t = new _(
      (this._positions[3].x + this._positions[4].x) / 2,
      (this._positions[3].y + this._positions[4].y) / 2,
      (this._positions[3].z + this._positions[4].z) / 2
    ), e = _.subtract(this._positions[4], this._positions[3]);
    _.subtract(this._positions[2], t).length() * 2 > e.length() ? this._arrowsInvert = !0 : this._arrowsInvert = !1;
  }
  update() {
    super.update();
    const t = this._viewer.view, e = new Array(6);
    if (this._stage > 0) {
      this._behindView = !1;
      for (let i = 0; i < this._positions.length; i++)
        t.projectPoint(this._positions[i]).z <= 0 && (this._behindView = !0), e[i] = K.fromPoint3(t.projectPoint(this._positions[i]));
      this._firstPointShape.setCenter(e[0]);
    }
    this._stage > 1 && (this._textShape && this._textShape.setPosition(e[2]), this._secondPointShape.setCenter(e[1]), this._lineShapes[0].set(e[0], e[1]), this._lineShapes[1].set(e[3], e[4]), this._lineShapes[2].set(e[0], e[3]), this._lineShapes[3].set(e[1], e[4]), this._lineShapes[4].set(e[3], e[2]), this._lineShapes[5].set(e[3], e[4]), this._lineShapes[5].setEndcapType(_n.Arrowhead), this._lineShapes[5].setStartEndcapType(_n.Arrowhead), this._lineShapes[5].setEndcapsInverted(this._arrowsInvert));
  }
  draw() {
    if (this._visibility && this._viewer.explodeManager.getMagnitude() === 0 && (this.update(), !this._behindView)) {
      const t = this._viewer.markupManager.getRenderer();
      switch (this._stage) {
        case 1:
          t.drawCircle(this._firstPointShape);
          break;
        case 2:
        case 3:
          t.drawCircle(this._firstPointShape), t.drawCircle(this._secondPointShape);
          for (const e of this._lineShapes)
            t.drawLine(e);
          t.drawTextBox(this._textShape);
          break;
      }
    }
  }
  // serialization methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      name: this._name,
      measurePoint1: this._positions[0].copy(),
      measurePoint2: this._positions[1].copy(),
      leaderPoint1: this._positions[3].copy(),
      leaderPoint2: this._positions[4].copy(),
      textPoint: this._positions[2].copy(),
      text: this._textShape.getTextString(),
      measurementValue: this._measurementValue,
      unitMultiplier: this._unitMultiplier,
      className: this.getClassName()
    };
  }
  /**
   * Creates a new [[MeasurePointPointDistanceMarkup]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t, e) {
    const i = t, n = new Uc(e);
    return n._name = i.name, n._positions[0] = _.fromJson(i.measurePoint1), n._positions[1] = _.fromJson(i.measurePoint2), n._positions[2] = _.fromJson(i.textPoint), n._textShape.setTextString(i.text), n._positions[3] = _.fromJson(i.leaderPoint1), n._positions[4] = _.fromJson(i.leaderPoint2), n._measurementValue = i.measurementValue, n._unitMultiplier = i.unitMultiplier || 1, n._updateArrowsInverted(), n._stage = 2, n;
  }
  getClassName() {
    return Uc.className;
  }
  /**
   * Returns whether the measurement markup is valid.
   */
  isMarkupValid() {
    return this._positions.length >= 5;
  }
};
Uc.className = "Communicator.Markup.Measure.MeasurePointPointDistanceMarkup";
let Ml = Uc;
as(
  Ml.className,
  Ml.fromJson
);
class xy extends Ai {
  /** @hidden */
  constructor(t, e, i) {
    super(t, e), this._measureMarkup = null, this._cameraInteractionActive = !1, this._viewer = t, this._measureManager = i, this._cursor = new Vh(t, e), this._viewer.setCallbacks({
      beginInteraction: () => {
        this._onBeginInteraction();
      },
      endInteraction: () => {
        this._onEndInteraction();
      }
    });
  }
  _onBeginInteraction() {
    this._cameraInteractionActive = !0, this._cursor.activateCursorSprite(!1);
  }
  _onEndInteraction() {
    this._cameraInteractionActive = !1;
  }
  _getStage() {
    return this._measureMarkup === null ? As.NoPointsSelected : this._measureMarkup._getStage();
  }
  _draw() {
    let t = !1;
    this._getStage() < As.TwoPointsSelected && (this._cursor.draw(), t = !0), this._measureMarkup !== null && (this._measureMarkup.draw(), t = !0), t && this._viewer.markupManager.refreshMarkup(this._viewer.view);
  }
  async _finalizeMeasurement(t, e) {
    const i = this._measureMarkup;
    if (i === null) {
      console.assert(!1);
      return;
    }
    const n = new Si(e ? Se.All : Se.Face);
    (await this._view.pickFromPoint(t, n)).overlayIndex() || (i.finalize(), this._measureMarkup = null, this._measureManager.finalizeMeasurement(i));
  }
  // Gets the first picked position or null if one is not selected.  This is used as a hint when updating the cursor for snapping.
  _getFirstPickPosition() {
    let t = null;
    return this._measureMarkup !== null && this._getStage() >= As.OnePointSelected && (t = this._measureMarkup.getFirstPointPosition()), t;
  }
  async _updateMeasurementPoints(t, e) {
    const i = this._getStage();
    console.assert(i < As.TwoPointsSelected), this._viewer.trigger("measurementBegin");
    const n = this._getFirstPickPosition(), r = await this._cursor.getSelectionCursorPoints(
      t,
      e,
      n
    );
    if (r === null || r.worldPosition === null) {
      this._cursor.activateCursorSprite(!1);
      return;
    }
    this._cursor.activateCursorSprite(!0), this._measureMarkup === null && (this._measureMarkup = new Ml(this._viewer), this._measureManager.addMeasurement(this._measureMarkup));
    const o = r.worldPosition.copy();
    if (this._viewer.sheetManager.isDrawingSheetActive() && (o.z = 0), i === As.NoPointsSelected)
      this._measureMarkup.setFirstPointPosition(o), this._measureMarkup.setUnitMultiplier(
        r.selectionItem.isNodeSelection() ? this._viewer.model.getNodeUnitMultiplier(r.selectionItem.getNodeId()) : 1
      );
    else if (i === As.OnePointSelected) {
      const l = this._getFirstPickPosition();
      r.worldPosition.equalsWithTolerance(l, 1e-7) || (this._measureMarkup.setSecondPointPosition(o), this._measureMarkup.adjust(r.screenPosition));
    }
  }
  /**
   * Determine if the given mouse event should cause snapping. This is influenced by
   * the snap configuration enabled value.
   */
  _useSnapping(t) {
    return this._cursor.snappingConfig.enabled && !t.altDown();
  }
  /** @hidden */
  onMouseMove(t) {
    super.onMouseMove(t);
    const e = this._getStage();
    if (e < As.TwoPointsSelected) {
      if (!this._cameraInteractionActive) {
        const i = t.getPosition(), n = this._getFirstPickPosition();
        this._cursor.updateCursorSprite(
          i,
          this._useSnapping(t),
          n
        );
      }
    } else
      e === As.TwoPointsSelected && (this._measureMarkup.adjust(t.getPosition()), t.setHandled(!0));
    this._draw();
  }
  /** @hidden */
  async onMouseUp(t) {
    if (this.isActive()) {
      const e = this._getStage(), i = this._primaryTouchId !== null && this._measureMarkup !== null && e > As.OnePointSelected;
      if (this._dragCount < 3 || i) {
        const n = this._useSnapping(t), r = t.getPosition();
        e <= As.OnePointSelected ? await this._updateMeasurementPoints(r, n) : await this._finalizeMeasurement(r, n);
      }
    }
    super.onMouseUp(t);
  }
  /** @hidden */
  onKeyUp(t) {
  }
  _clearMeasurement() {
    this._measureMarkup !== null ? (this._measureManager.removeMeasurement(this._measureMarkup), this._measureMarkup = null) : this._measureManager.removeLastMeasurement();
  }
  /** @hidden */
  onKeyDown(t) {
    t.getKeyCode() === ti.Escape && this._clearMeasurement();
  }
  /** @hidden */
  setHandled() {
    return this._getStage() > As.OnePointSelected;
  }
  /** @hidden */
  onActivate() {
    this._cursor.onOperatorActivate();
  }
  /** @hidden */
  onDeactivate() {
    this._cursor.onOperatorDeactivate(), this._measureMarkup !== null && (this._measureManager.removeMeasurement(this._measureMarkup), this._measureMarkup = null);
  }
}
const jc = class jc extends Rn {
  constructor(t) {
    super(t), this._initialPoint = new Gr(), this._leaderLine = new Qn(), this._endpoints = new Sg(), this._textboxCorners = [
      K.zero(),
      K.zero(),
      K.zero(),
      K.zero()
    ], this._polygon = new J_(), this._plane = null, this.textPosition = _.zero(), this.leaderPosition = _.zero(), this.pointRadius = 2.5, this._viewer = t;
    const e = this._viewer.measureManager.getMeasurementColor();
    this._initialPoint.setFillColor(e), this._initialPoint.setStrokeColor(e), this._leaderLine.setStrokeColor(e), this._endpoints.setFillColor(e), this._endpoints.setStrokeColor(e), this._endpoints.setFillOpacity(1), this._textShape.getBoxPortion().setFillOpacity(1), this._textShape.getBoxPortion().setFillColor(vt.white()), this._polygon.setFillColor(e), this._polygon.setFillOpacity(0.4);
  }
  _calculateArea() {
    const t = this._positions.length;
    if (t < 3)
      return 0;
    const e = new Float32Array(t * 3);
    for (let u = 0; u < t; u++) {
      const d = this._positions[u];
      e[3 * u] = d.x, e[3 * u + 1] = d.y, e[3 * u + 2] = d.z;
    }
    const i = _.subtract(this._positions[1], this._positions[0]), n = _.subtract(this._positions[2], this._positions[0]), r = _.cross(i, n), o = this._viewer.model.triangulatePolygon(e, r);
    let l = 0;
    const h = o.length / 3 / 3;
    for (let u = 0; u < h; u++) {
      const d = u * 3 * 3, g = [];
      for (let I = 0; I < 3; I++) {
        const C = o[d + I * 3], P = o[d + I * 3 + 1], k = o[d + I * 3 + 2];
        g[I] = new _(C, P, k);
      }
      const y = _.subtract(g[1], g[0]).length(), m = _.subtract(g[2], g[0]).length(), x = _.subtract(g[2], g[1]).length(), b = 0.25 * Math.sqrt(
        (y + m + x) * (-y + m + x) * (y - m + x) * (y + m - x)
      );
      l += b;
    }
    return l;
  }
  /**
   * Adds a point to the point list and updates the calculated polygon area.
   * Only points that are coplanar will be added.
   * Returns a bool representing if the point was accepted or not
   */
  addPoint(t) {
    if (this._positions.length >= 3 && (this._plane === null && (this._plane = ln.createFromPoints(
      this._positions[0],
      this._positions[1],
      this._positions[2]
    )), Math.abs(this._plane.distanceToPoint(t)) > 1e-4))
      return !1;
    this._positions.length === 2 && (this._plane = ln.createFromPoints(this._positions[0], this._positions[1], t)), this._positions.push(t.copy());
    const e = this._calculateArea(), i = this.getUnitMultiplier(), n = `${$c(e, i)}²`;
    return this._setMeasurementValue(e), this.setMeasurementText(n), !0;
  }
  getPoints() {
    return this._positions;
  }
  getLast() {
    return this._positions.length === 0 ? null : this._positions[this._positions.length - 1].copy();
  }
  // finalizes the measurement
  finalize() {
    if (this._positions.length > 2) {
      const t = this._calculateArea(), e = this.getUnitMultiplier(), i = `${$c(t, e)}²`;
      this._setMeasurementValue(t), this.setMeasurementText(i);
    }
    this._finalized = !0;
  }
  setUnitMultiplier(t) {
    this._unitMultiplier = t;
  }
  isValid() {
    return this._positions.length > 2;
  }
  getMeasurementText() {
    return this._textShape.getTextString();
  }
  /** Calculates the screen position for each point in the polygon */
  _updateProjectedPoints() {
    const t = [];
    this._behindView = !1;
    for (const e of this._positions) {
      const i = this._viewer.view.projectPoint(e);
      i.z <= 0 && (this._behindView = !0), t.push(K.fromPoint3(i));
    }
    return t;
  }
  _updateTextBoxCorners() {
    const t = this._viewer.markupManager.getRenderer().measureTextBox(this._textShape), e = this._textShape.getPosition();
    this._textboxCorners[0].assign(e), this._textboxCorners[1].set(e.x + t.x, e.y), this._textboxCorners[2].set(e.x + t.x, e.y + t.y), this._textboxCorners[3].set(e.x, e.y + t.y);
  }
  /** Finds and returns the closest corner of the text box.  Used as the endpoint of the leader line. */
  _calculateLeaderEndpoint(t) {
    this._updateTextBoxCorners();
    const e = K.zero();
    let i = Number.MAX_VALUE;
    for (const n of this._textboxCorners) {
      const r = K.distance(t, n);
      r < i && (e.assign(n), i = r);
    }
    return e;
  }
  draw() {
    if (!this._visibility)
      return;
    const t = this._updateProjectedPoints();
    if (this._behindView || t.length === 0)
      return;
    const e = this._viewer.markupManager.getRenderer();
    if (t.length === 1)
      this._initialPoint.set(t[0], this.pointRadius), e.drawCircle(this._initialPoint);
    else {
      this._polygon.clearPoints();
      for (const o of t)
        this._polygon.pushPoint(o);
      this._finalized && this._polygon.pushPoint(t[0]);
      const i = K.fromPoint3(this._viewer.view.projectPoint(this.textPosition));
      this._textShape.setPosition(i), e.drawPolygon(this._polygon);
      const n = K.fromPoint3(this._viewer.view.projectPoint(this.leaderPosition)), r = this._calculateLeaderEndpoint(n);
      this._leaderLine.setP1(n), this._leaderLine.setP2(r), e.drawLine(this._leaderLine), e.drawTextBox(this._textShape), this._endpoints.clear(), this._endpoints.addCircle(t[0], this.pointRadius), this._endpoints.addCircle(t[t.length - 1], this.pointRadius), e.drawCircles(this._endpoints);
    }
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    const t = [];
    for (const e of this._positions)
      t.push(e.toJson());
    return {
      name: this._name,
      points: t,
      textPoint: this.textPosition.toJson(),
      leaderPoint: this.leaderPosition.toJson(),
      measurementValue: this._measurementValue,
      unitMultiplier: this._unitMultiplier,
      text: this._textShape.getTextString(),
      className: this.getClassName()
    };
  }
  /**
   * Creates a new [[MeasurePolygonAreaMarkup]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t, e) {
    const i = t, n = new jc(e);
    return n._name = i.name, n._positions = Rn._constructPointArray(i.points), n.textPosition = _.fromJson(i.textPoint), n.leaderPosition = _.fromJson(i.leaderPoint), n._measurementValue = i.measurementValue, n._unitMultiplier = i.unitMultiplier || 1, n._textShape.setTextString(i.text), n._finalized = !0, n;
  }
  /** This measurement only allows clicking on the text box portion of the markup. */
  hit(t) {
    const e = this._viewer.markupManager.getRenderer().measureTextBox(this._textShape), i = this._textShape.getPosition();
    return !(t.x < i.x || t.x > i.x + e.x || t.y < i.y || t.y > i.y + e.y);
  }
  getClassName() {
    return jc.className;
  }
};
jc.className = "Communicator.Markup.Measure.MeasurePolygonAreaMarkup";
let El = jc;
as(El.className, El.fromJson);
class Iy extends Ai {
  /** @hidden */
  constructor(t, e, i) {
    super(t, e), this._markupItem = null, this._cameraInteractionActive = !1, this._textShapeOffset = new K(10, -25), this._anchor = ul.Last, this._dragPlane = null, this._measureManager = i, this._cursor = new Vh(t, e), this._viewer.setCallbacks({
      beginInteraction: () => {
        this._onBeginInteraction();
      },
      endInteraction: () => {
        this._onEndInteraction();
      }
    });
  }
  /** @hidden */
  getMarkupItem() {
    return this._markupItem;
  }
  /** Sets the anchor type that will be set for markups created by this operator. */
  setAnchor(t) {
    this._anchor = t;
  }
  /**
   * Determine if the given mouse event should cause snapping. This is influenced by
   * the snap configuration enabled value.
   */
  _useSnapping(t) {
    return this._cursor.snappingConfig.enabled && !t.altDown();
  }
  _getLastSelectedPoint() {
    return this._markupItem ? this._markupItem.getLast() : null;
  }
  _createNewMarkupItem(t) {
    this._markupItem = new El(this._viewer), this._markupItem.setUnitMultiplier(
      t.selectionItem.isNodeSelection() ? this._viewer.model.getNodeUnitMultiplier(t.selectionItem.getNodeId()) : 1
    ), this._markupItem.setName("MeasurePolygonAreaMarkup"), this._measureManager.addMeasurement(this._markupItem), this._markupItem.addPoint(t.worldPosition);
  }
  _updateMarkupItem(t, e) {
    if (this._markupItem === null || e.worldPosition == null)
      return;
    const i = this._markupItem.getPoints(), n = K.fromPoint3(this._view.projectPoint(i[0]));
    K.distance(n, t) < this._markupItem.pointRadius ? i.length > 2 && this._finalizeMeasurement() : this._markupItem.addPoint(e.worldPosition) && this._updateAnchor(t, e.worldPosition);
  }
  // Updates the cursor display and the measurement markup item based on a pointer position.
  async _updateMeasurementItem(t, e) {
    const i = this._getLastSelectedPoint(), n = await this._cursor.getSelectionCursorPoints(
      t,
      e,
      i
    );
    if (n === null || n.worldPosition === null) {
      this._cursor.activateCursorSprite(!1);
      return;
    } else
      this._cursor.activateCursorSprite(!0);
    this._markupItem === null ? this._createNewMarkupItem(n) : this._updateMarkupItem(t, n);
  }
  _isDraggingText() {
    return this._dragPlane !== null;
  }
  /** @hidden */
  onMouseDown(t) {
    if (super.onMouseDown(t), this._markupItem)
      return;
    const e = t.getPosition();
    this._pickExisting(e) && (this._dragPlane = this._calculateSelectionPlane(this._markupItem.leaderPosition), t.setHandled(!0));
  }
  /** @hidden */
  onMouseMove(t) {
    if (super.onMouseMove(t), this._isDraggingText())
      this._dragMarkupText(t), t.setHandled(!0);
    else if (!this._cameraInteractionActive) {
      const e = this._getLastSelectedPoint();
      this._cursor.updateCursorSprite(
        t.getPosition(),
        this._useSnapping(t),
        e
      ), this._draw();
    }
  }
  /** @hidden */
  async onMouseUp(t) {
    if (!this.isActive())
      return;
    const e = t.getPosition();
    if (this._isDraggingText())
      this._markupItem = null, this._dragPlane = null;
    else if (this._ptFirst.equals(e)) {
      const i = this._useSnapping(t), n = e;
      await this._updateMeasurementItem(n, i);
    }
    super.onMouseUp(t);
  }
  /** @hidden */
  onDoubleClick(t) {
    this._finalizeMeasurement();
  }
  _dragMarkupText(t) {
    if (this._markupItem === null || this._dragPlane === null)
      return;
    const e = this._view.raycastFromPoint(t.getPosition());
    this._dragPlane.intersectsRay(e, this._markupItem.textPosition), this._draw();
  }
  _finalizeMeasurement() {
    if (this._markupItem)
      if (this._markupItem.isValid()) {
        const t = this._markupItem;
        this._markupItem = null, t.finalize(), this._measureManager.finalizeMeasurement(t);
      } else
        this._clearMeasurement();
  }
  _updateAnchor(t, e) {
    if (!this._markupItem)
      return;
    const i = this._markupItem.getPoints();
    if (i.length !== 1)
      switch (this._anchor) {
        case ul.Last:
          this._calculateAnchorPos(t, e);
          break;
        case ul.First: {
          if (i.length !== 2)
            return;
          const n = this._view.projectPoint(i[0]);
          this._calculateAnchorPos(K.fromPoint3(n), i[0]);
          break;
        }
        case ul.Midpoint: {
          let n;
          const r = this._markupItem.getMeasurementValue() / 2;
          let o = 0;
          for (let h = 1; h < i.length; h++) {
            const u = _.subtract(i[h], i[h - 1]), d = u.length(), g = o + d;
            if (g > r) {
              const m = (r - o) / d;
              u.scale(m), n = _.add(i[h - 1], u);
              break;
            }
            o = g;
          }
          const l = this._view.projectPoint(n);
          this._calculateAnchorPos(K.fromPoint3(l), n);
          break;
        }
      }
  }
  _calculateSelectionPlane(t) {
    const e = this._view.getCamera(), i = _.subtract(e.getPosition(), t);
    return i.normalize(), ln.createFromPointAndNormal(t, i);
  }
  _calculateAnchorPos(t, e) {
    const i = this._view.getCamera();
    _.subtract(i.getPosition(), e).normalize();
    const r = this._calculateSelectionPlane(e), o = this._view.raycastFromPoint(K.add(t, this._textShapeOffset));
    o && (r.intersectsRay(o, this._markupItem.textPosition), this._markupItem.leaderPosition.assign(e));
  }
  // Cancels the currently measurement being created or removes the last created measurement
  _clearMeasurement() {
    this._markupItem !== null ? (this._measureManager.removeMeasurement(this._markupItem), this._markupItem = null) : this._measureManager.removeLastMeasurement();
  }
  _draw() {
    this._viewer.markupManager.refreshMarkup(this._viewer.view);
  }
  _pickExisting(t) {
    const e = this._viewer.markupManager.pickMarkupItem(t, this._viewer.view);
    return e && e.getClassName() === "Communicator.MeasurePolygonAreaMarkup" ? (this._markupItem = e, !0) : !1;
  }
  /** @hidden */
  onActivate() {
    this._cursor.onOperatorActivate();
  }
  /** @hidden */
  onDeactivate() {
    this._cursor.onOperatorDeactivate();
  }
  /** @hidden */
  onKeyDown(t) {
    t.getKeyCode() === ti.Escape && this._clearMeasurement();
  }
  _onBeginInteraction() {
    this._cameraInteractionActive = !0, this._cursor.activateCursorSprite(!1);
  }
  _onEndInteraction() {
    this._cameraInteractionActive = !1;
  }
}
const Wc = class Wc extends Rn {
  constructor(t) {
    super(t), this._polyline = new Ba(), this._initialPoint = new Gr(), this._leaderLine = new Qn(), this._endpoints = new Sg(), this._textboxCorners = [
      K.zero(),
      K.zero(),
      K.zero(),
      K.zero()
    ], this.textPosition = _.zero(), this.leaderPosition = _.zero(), this.isLoop = !1, this.pointRadius = 2.5, this._viewer = t;
    const e = this._viewer.measureManager.getMeasurementColor();
    this._initialPoint.setFillColor(e), this._initialPoint.setStrokeColor(e), this._polyline.setStrokeColor(e), this._polyline.setStrokeWidth(2), this._leaderLine.setStrokeColor(e), this._endpoints.setFillColor(e), this._endpoints.setStrokeColor(e), this._endpoints.setFillOpacity(1), this._textShape.getBoxPortion().setFillOpacity(1), this._textShape.getBoxPortion().setFillColor(vt.white());
  }
  /** Adds a point to the pointlist and updates the calculated polyline distance */
  addPoint(t) {
    if (this._positions.push(t.copy()), this._positions.length > 1) {
      const e = _.subtract(
        this._positions[this._positions.length - 1],
        this._positions[this._positions.length - 2]
      ).length();
      this._setMeasurementValue(this._measurementValue + e);
    }
  }
  getPoints() {
    return this._positions;
  }
  getlast() {
    return this._positions.length === 0 ? null : this._positions[this._positions.length - 1].copy();
  }
  // finalizes the measurement and sets the final distance if the polyline is a loop
  finalize() {
    if (this.isLoop && this._positions.length > 2) {
      const t = _.subtract(
        this._positions[this._positions.length - 1],
        this._positions[0]
      ).length();
      this._setMeasurementValue(this._measurementValue + t);
    }
    this._finalized = !0;
  }
  setUnitMultiplier(t) {
    this._unitMultiplier = t;
  }
  isValid() {
    return this._positions.length > 1;
  }
  getMeasurementText() {
    return this._textShape.getTextString();
  }
  /** Calculates the screen position for each point in the polyline */
  _updateProjectedPoints() {
    const t = [];
    this._behindView = !1, this._behindView = !1;
    for (const e of this._positions) {
      const i = this._viewer.view.projectPoint(e);
      i.z <= 0 && (this._behindView = !0), t.push(K.fromPoint3(i));
    }
    return t;
  }
  _updateTextBoxCorners() {
    const t = this._viewer.markupManager.getRenderer().measureTextBox(this._textShape), e = this._textShape.getPosition();
    this._textboxCorners[0].assign(e), this._textboxCorners[1].set(e.x + t.x, e.y), this._textboxCorners[2].set(e.x + t.x, e.y + t.y), this._textboxCorners[3].set(e.x, e.y + t.y);
  }
  /** Finds and returns the closest corner of the text box.  Used as the endpoint of the leader line. */
  _calculateLeaderEndpoint(t) {
    this._updateTextBoxCorners();
    const e = K.zero();
    let i = Number.MAX_VALUE;
    for (const n of this._textboxCorners) {
      const r = K.distance(t, n);
      r < i && (e.assign(n), i = r);
    }
    return e;
  }
  draw() {
    if (!this._visibility)
      return;
    const t = this._updateProjectedPoints();
    if (this._behindView || t.length === 0)
      return;
    const e = this._viewer.markupManager.getRenderer();
    if (t.length === 1)
      this._initialPoint.set(t[0], this.pointRadius), e.drawCircle(this._initialPoint);
    else {
      this._polyline.clearPoints();
      for (const o of t)
        this._polyline.pushPoint(o);
      this._finalized && this.isLoop && this._polyline.pushPoint(t[0]);
      const i = K.fromPoint3(this._viewer.view.projectPoint(this.textPosition));
      this._textShape.setPosition(i), e.drawPolyline(this._polyline);
      const n = K.fromPoint3(this._viewer.view.projectPoint(this.leaderPosition)), r = this._calculateLeaderEndpoint(n);
      this._leaderLine.setP1(n), this._leaderLine.setP2(r), e.drawLine(this._leaderLine), e.drawTextBox(this._textShape), this._endpoints.clear(), this.isLoop || (this._endpoints.addCircle(t[0], this.pointRadius), this._endpoints.addCircle(t[t.length - 1], this.pointRadius), e.drawCircles(this._endpoints));
    }
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    const t = [];
    for (const e of this._positions)
      t.push(e.toJson());
    return {
      name: this._name,
      points: t,
      textPoint: this.textPosition.toJson(),
      leaderPoint: this.leaderPosition.toJson(),
      measurementValue: this._measurementValue,
      unitMultiplier: this._unitMultiplier,
      isLoop: this.isLoop,
      text: this._textShape.getTextString(),
      className: this.getClassName()
    };
  }
  /**
   * Creates a new [[MeasurePolylineDistanceMarkup]] from an object given by [[toJson]].
   * @param objData An object given by [[toJson]].
   * @returns The prepared object.
   */
  static fromJson(t, e) {
    const i = t, n = new Wc(e);
    return n._name = i.name, n._positions = Rn._constructPointArray(i.points), n.textPosition = _.fromJson(i.textPoint), n.leaderPosition = _.fromJson(i.leaderPoint), n.isLoop = i.isLoop, n._measurementValue = i.measurementValue, n._unitMultiplier = i.unitMultiplier || 1, n._textShape.setTextString(i.text), n._finalized = !0, n;
  }
  /** This measurement only allows clicking on the text box portion of the markup. */
  hit(t) {
    const e = this._viewer.markupManager.getRenderer().measureTextBox(this._textShape), i = this._textShape.getPosition();
    return !(t.x < i.x || t.x > i.x + e.x || t.y < i.y || t.y > i.y + e.y);
  }
  getClassName() {
    return Wc.className;
  }
};
Wc.className = "Communicator.Markup.Measure.MeasurePolylineDistanceMarkup";
let Al = Wc;
as(
  Al.className,
  Al.fromJson
);
class Cy extends Ai {
  /** @hidden */
  constructor(t, e, i) {
    super(t, e), this._markupItem = null, this._cameraInteractionActive = !1, this._textShapeOffset = new K(10, -25), this._anchor = dl.Last, this._dragPlane = null, this._measureManager = i, this._cursor = new Vh(t, e), this._viewer.setCallbacks({
      beginInteraction: () => {
        this._onBeginInteraction();
      },
      endInteraction: () => {
        this._onEndInteraction();
      }
    });
  }
  /** @hidden */
  getMarkupItem() {
    return this._markupItem;
  }
  /** Sets the anchor type that will be set for markups created by this operator. */
  setAnchor(t) {
    this._anchor = t;
  }
  /**
   * Determine if the given mouse event should cause snapping. This is influenced by
   * the snap configuration enabled value.
   */
  _useSnapping(t) {
    return this._cursor.snappingConfig.enabled && !t.altDown();
  }
  _getLastSelectedPoint() {
    return this._markupItem ? this._markupItem.getlast() : null;
  }
  _createNewMarkupItem(t) {
    this._markupItem = new Al(this._viewer), this._markupItem.setUnitMultiplier(
      t.selectionItem.isNodeSelection() ? this._viewer.model.getNodeUnitMultiplier(t.selectionItem.getNodeId()) : 1
    ), this._markupItem.setName("MeasurePolylineDistanceMarkup"), this._measureManager.addMeasurement(this._markupItem), this._markupItem.addPoint(t.worldPosition);
  }
  _updateMarkupItem(t, e) {
    if (this._markupItem === null || e.worldPosition == null)
      return;
    const i = this._markupItem.getPoints(), n = K.fromPoint3(this._view.projectPoint(i[0]));
    K.distance(n, t) < this._markupItem.pointRadius ? i.length > 2 && (this._markupItem.isLoop = !0, this._finalizeMeasurement()) : (this._markupItem.addPoint(e.worldPosition), this._updateAnchor(t, e.worldPosition));
  }
  // Updates the cursor display and the measurement markup item based on a pointer position.
  async _updateMeasurementItem(t, e) {
    const i = this._getLastSelectedPoint(), n = await this._cursor.getSelectionCursorPoints(
      t,
      e,
      i
    );
    if (n === null || n.worldPosition === null) {
      this._cursor.activateCursorSprite(!1);
      return;
    } else
      this._cursor.activateCursorSprite(!0);
    this._markupItem === null ? this._createNewMarkupItem(n) : this._updateMarkupItem(t, n);
  }
  _isDraggingText() {
    return this._dragPlane !== null;
  }
  /** @hidden */
  onMouseDown(t) {
    if (super.onMouseDown(t), this._markupItem)
      return;
    const e = t.getPosition();
    this._pickExisting(e) && (this._dragPlane = this._calculateSelectionPlane(this._markupItem.leaderPosition), t.setHandled(!0));
  }
  /** @hidden */
  onMouseMove(t) {
    if (super.onMouseMove(t), this._isDraggingText())
      this._dragMarkupText(t), t.setHandled(!0);
    else if (!this._cameraInteractionActive) {
      const e = this._getLastSelectedPoint();
      this._cursor.updateCursorSprite(
        t.getPosition(),
        this._useSnapping(t),
        e
      ), this._draw();
    }
  }
  /** @hidden */
  async onMouseUp(t) {
    if (!this.isActive())
      return;
    const e = t.getPosition();
    if (this._isDraggingText())
      this._markupItem = null, this._dragPlane = null;
    else if (this._ptFirst.equals(e)) {
      const i = this._useSnapping(t), n = e;
      await this._updateMeasurementItem(n, i);
    }
    super.onMouseUp(t);
  }
  /** @hidden */
  onDoubleClick(t) {
    this._finalizeMeasurement();
  }
  _dragMarkupText(t) {
    if (this._markupItem === null || this._dragPlane === null)
      return;
    const e = this._view.raycastFromPoint(t.getPosition());
    this._dragPlane.intersectsRay(e, this._markupItem.textPosition), this._draw();
  }
  _finalizeMeasurement() {
    if (this._markupItem)
      if (this._markupItem.isValid()) {
        const t = this._markupItem;
        this._markupItem = null, t.finalize(), this._measureManager.finalizeMeasurement(t);
      } else
        this._clearMeasurement();
  }
  _updateAnchor(t, e) {
    if (!this._markupItem)
      return;
    const i = this._markupItem.getPoints();
    if (i.length !== 1)
      switch (this._anchor) {
        case dl.Last:
          this._calculateAnchorPos(t, e);
          break;
        case dl.First: {
          if (i.length !== 2)
            return;
          const n = this._view.projectPoint(i[0]);
          this._calculateAnchorPos(K.fromPoint3(n), i[0]);
          break;
        }
        case dl.Midpoint: {
          let n;
          const r = this._markupItem.getMeasurementValue() / 2;
          let o = 0;
          for (let h = 1; h < i.length; h++) {
            const u = _.subtract(i[h], i[h - 1]), d = u.length(), g = o + d;
            if (g > r) {
              const m = (r - o) / d;
              u.scale(m), n = _.add(i[h - 1], u);
              break;
            }
            o = g;
          }
          const l = this._view.projectPoint(n);
          this._calculateAnchorPos(K.fromPoint3(l), n);
          break;
        }
      }
  }
  _calculateSelectionPlane(t) {
    const e = this._view.getCamera(), i = _.subtract(e.getPosition(), t);
    return i.normalize(), ln.createFromPointAndNormal(t, i);
  }
  _calculateAnchorPos(t, e) {
    const i = this._view.getCamera();
    _.subtract(i.getPosition(), e).normalize();
    const r = this._calculateSelectionPlane(e), o = this._view.raycastFromPoint(K.add(t, this._textShapeOffset));
    o && (r.intersectsRay(o, this._markupItem.textPosition), this._markupItem.leaderPosition.assign(e));
  }
  // Cancels the currently measurement being created or removes the last created measurement
  _clearMeasurement() {
    this._markupItem !== null ? (this._measureManager.removeMeasurement(this._markupItem), this._markupItem = null) : this._measureManager.removeLastMeasurement();
  }
  _draw() {
    this._viewer.markupManager.refreshMarkup(this._viewer.view);
  }
  _pickExisting(t) {
    const e = this._viewer.markupManager.pickMarkupItem(t, this._viewer.view);
    return e && e.getClassName() === "Communicator.MeasurePolylineDistanceMarkup" ? (this._markupItem = e, !0) : !1;
  }
  /** @hidden */
  onActivate() {
    this._cursor.onOperatorActivate();
  }
  /** @hidden */
  onDeactivate() {
    this._cursor.onOperatorDeactivate();
  }
  /** @hidden */
  onKeyDown(t) {
    t.getKeyCode() === ti.Escape && this._clearMeasurement();
  }
  _onBeginInteraction() {
    this._cameraInteractionActive = !0, this._cursor.activateCursorSprite(!1);
  }
  _onEndInteraction() {
    this._cameraInteractionActive = !1;
  }
}
const ox = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  MeasureBodyBodyDistanceOperator: my,
  MeasureEdgeLengthOperator: _y,
  MeasureFaceFaceAngleOperator: yy,
  MeasureFaceFaceDistanceOperator: wy,
  MeasureLineLineAngleOperator: by,
  MeasurePointPointDistanceOperator: xy,
  MeasurePolygonAreaAnchor: ul,
  MeasurePolygonAreaOperator: Iy,
  MeasurePolylineDistanceAnchor: dl,
  MeasurePolylineDistanceOperator: Cy,
  PointCursor: Vh,
  SelectionPoints: vy,
  Stage: As,
  worldPointToScreenPoint: Ru
}, Symbol.toStringTag, { value: "Module" })), ax = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  MeasureBodyBodyDistanceMarkup: Il,
  MeasureCircleEdgeLengthMarkup: Cl,
  MeasureFaceFaceAngleMarkup: Sl,
  MeasureFaceFaceDistanceMarkup: Pl,
  MeasureLengthMarkup: dh,
  MeasureLineLineAngleMarkup: kl,
  MeasureMarkup: Rn,
  MeasurePointPointDistanceMarkup: Ml,
  MeasurePolygonAreaMarkup: El,
  MeasurePolylineDistanceMarkup: Al,
  MeasureStraightEdgeLengthMarkup: fh
}, Symbol.toStringTag, { value: "Module" })), gl = class gl extends go {
  constructor(t, e, i, n, r) {
    super(), this._uniqueId = Ss(), this._noteElementId = null, this._position = _.zero(), this._text = "", this._color = vt.white(), this._sphereRadius = 0.03, this._deleted = !1, this._active = !1, this._callbacks = null, this._viewer = t, this._noteTextManager = e, this._selectionPosition = i, this._selectionNormal = n, this._partId = r, this._noteTextManager.addNote(this), this._init();
  }
  async _init() {
    const t = this._createPinTransformationMatrix(
      this._selectionPosition,
      this._selectionNormal
    ), [e, i] = await Promise.all([
      this._createPinStemInstance(t),
      this._createPinSphereInstance(t)
    ]);
    this._stemInstanceId = e, this._sphereInstanceId = i, await this._restore(!1), this._callbacks = {
      visibilityChanged: () => {
        this._matchPartVisibility();
      }
    }, this._viewer.setCallbacks(this._callbacks), this._viewer.trigger("noteTextCreated", this);
  }
  _matchPartVisibility() {
    if (this._sphereInstanceId === void 0 || this._stemInstanceId === void 0)
      return;
    const t = this._viewer.model, e = t.getNodeVisibility(this._partId), i = t.getNodeVisibility(this._sphereInstanceId);
    e !== i && !this._noteTextManager.getExplodeActive() && t.setNodesVisibility([this._stemInstanceId, this._sphereInstanceId], e);
    const n = this._noteTextManager.getActiveItem();
    n !== null && n.getStemInstanceId() === this._stemInstanceId && !e && this.hide();
  }
  async updatePosition() {
    if (this._sphereInstanceId === void 0)
      return;
    const t = await this._viewer.model.getNodeRealBounding(this._sphereInstanceId);
    this._pinBoundingBox = t, this._position = this._pinBoundingBox.center(), this.setText(this._text);
  }
  async _restore(t) {
    this._noteTextManager.setActiveItemHandle(
      this._viewer.markupManager.registerMarkup(this, this._viewer.view)
    ), this._noteTextManager.setActiveItem(this), this._show(t), this._updateColor(), await this.draw();
  }
  async restore() {
    return this._restore(!0);
  }
  setText(t) {
    this._text = t, this._noteTextManager.getNoteTextElement().setText(t);
  }
  saveTextValue() {
    this._text = this._noteTextManager.getNoteTextElement().getText();
  }
  async draw() {
    if (this._deleted || !this._active)
      return;
    this._behindView = !1, await this.updatePosition();
    const t = this._viewer.view.projectPoint(this._position);
    if (t.z <= 0 && (this._behindView = !0), this._behindView)
      this._noteElementId !== null && document.getElementById(this._noteElementId) !== null && (this._viewer.markupManager.removeMarkupElement(this._noteElementId, this._viewer.view), this._noteElementId = null);
    else {
      const e = new K(t.x, t.y), i = this._noteTextManager.getNoteTextElement();
      i.setPosition(e), this._noteElementId === null && (this._noteElementId = this._viewer.markupManager.addMarkupElement(
        i.getHtmlContainer(),
        this._viewer.view
      ));
    }
  }
  hit(t, e) {
    return this.hitWithTolerance(t, e, 0);
  }
  hitWithTolerance(t, e, i) {
    if (!this._active)
      return !1;
    const n = this._noteTextManager.getNoteTextElement(), r = n.getPosition(), o = n.getSize();
    return Mm(t, r, o, i);
  }
  getClassName() {
    return gl.className;
  }
  getUniqueId() {
    return this._uniqueId;
  }
  getSphereInstanceId() {
    return this._sphereInstanceId;
  }
  getStemInstanceId() {
    return this._stemInstanceId;
  }
  onSelect() {
    this._noteTextManager.getNoteTextElement().focus();
  }
  onDeselect() {
    this._noteTextManager.getNoteTextElement().blur();
  }
  hide() {
    const t = this._noteTextManager.getNoteTextElement();
    t.hide(), this.setText(t.getText()), this._noteTextManager.setActiveItem(null), this._active = !1, this._viewer.trigger("noteTextHidden", this);
  }
  _show(t) {
    this._noteTextManager.getNoteTextElement().show(this), this._active = !0, t && this._viewer.trigger("noteTextShown", this);
  }
  show() {
    this._show(!0);
  }
  async remove(t) {
    if (this.getRemoved() === !0)
      return;
    this._callbacks !== null && (this._viewer.unsetCallbacks(this._callbacks), this._callbacks = null);
    const e = this._viewer.model, i = [];
    this._stemInstanceId !== void 0 && i.push(e.deleteMeshInstances([this._stemInstanceId])), this._sphereInstanceId !== void 0 && i.push(e.deleteMeshInstances([this._sphereInstanceId])), this.hide(), this._noteTextManager.removeNote(this), this._deleted = !0, await Ge(i), super.remove(t);
  }
  getRemoved() {
    return this._deleted;
  }
  setColor(t) {
    return this._color = t, this._updateColor(), Promise.resolve();
  }
  getColor() {
    return this._color;
  }
  getPartId() {
    return this._partId;
  }
  _updateColor() {
    this._sphereInstanceId !== void 0 && this._viewer.model.setNodesFaceColor([this._sphereInstanceId], this._color);
  }
  // pin methods
  _createPinTransformationMatrix(t, e) {
    let i = 0, n = e.x;
    Math.abs(e.y) < Math.abs(n) && (n = e.y, i = 1), Math.abs(e.z) < Math.abs(n) && (i = 2);
    const r = [0, 0, 0];
    r[i] = 1;
    const o = _.createFromArray(r), l = _.cross(e, o).normalize(), h = _.cross(e, l);
    let u = new mt();
    return u.m = [
      e.x,
      e.y,
      e.z,
      0,
      l.x,
      l.y,
      l.z,
      0,
      h.x,
      h.y,
      h.z,
      0,
      0,
      0,
      0,
      1
    ], u = mt.multiply(
      u,
      new mt().setScaleComponent(this._sphereRadius, this._sphereRadius, this._sphereRadius)
    ), u.setTranslationComponent(t.x, t.y, t.z), u;
  }
  async _createPinStemInstance(t) {
    const e = this._noteTextManager.getPinStemMeshId();
    if (e === null)
      throw new oe("stem mesh hasn't been created yet");
    const i = new Qs(
      e,
      t,
      "pin-stem-instance",
      void 0,
      vt.black()
    );
    i.setOpacity(1);
    const n = ee.SuppressCameraScale | ee.DoNotCut | ee.DoNotExplode | ee.DoNotXRay | ee.ExcludeBounding | ee.OverrideSceneVisibility | ee.AlwaysDraw;
    return i.setCreationFlags(n), this._viewer.model.createMeshInstance(i, void 0, !0, !0);
  }
  async _createPinSphereInstance(t) {
    const e = this._noteTextManager.getPinSphereMeshId();
    if (e === null)
      throw new oe("sphere mesh hasn't been created yet");
    const i = new Qs(
      e,
      t,
      "pin-sphere-instance",
      vt.white(),
      void 0
    );
    i.setOpacity(1);
    const n = ee.SuppressCameraScale | ee.DoNotCut | ee.DoNotExplode | ee.DoNotXRay | ee.ExcludeBounding | ee.OverrideSceneVisibility | ee.AlwaysDraw;
    return i.setCreationFlags(n), this._viewer.model.createMeshInstance(i, void 0, !0, !0);
  }
  // Serialization methods
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    return {
      uniqueId: this._uniqueId,
      className: this.getClassName(),
      selectionPosition: this._selectionPosition.toJson(),
      selectionNormal: this._selectionNormal.toJson(),
      text: this._text,
      color: this._color,
      partId: this._partId
    };
  }
  static _fromJson(t, e, i) {
    const n = t;
    if (!i.findById(n.uniqueId)) {
      const r = _.fromJson(n.selectionPosition), o = _.fromJson(n.selectionNormal), l = n.partId, h = new gl(
        e,
        i,
        r,
        o,
        l
      );
      return h._uniqueId = n.uniqueId, h.setText(n.text), h.setColor(vt.fromJson(n.color)), h;
    }
    return null;
  }
  /**
   * Creates a new [[NoteText]] from an object given by [[toJson]].
   * @param An object given by [[toJson]].
   * @returns The prepared object.
   */
  static async fromJson(t, e, i) {
    return gl._fromJson(t, e, i);
  }
};
gl.className = "Communicator.Markup.Note.NoteText";
let Oa = gl;
as(Oa.className, Oa.fromJson);
class Sy {
  constructor() {
    this._positionOffset = K.zero(), this._position = K.zero(), this._activeNoteText = null, this._createTextBox();
  }
  _createTextBox() {
    this._container = document.createElement("div"), this._container.className = "noteTextElement", this._textArea = document.createElement("textarea"), this._textArea.oninput = () => {
      this._activeNoteText !== null && this._activeNoteText.saveTextValue();
    }, this._container.appendChild(this._textArea);
    const t = ["blue", "red", "green", "white", "black"];
    let e = 7;
    t.forEach((n) => {
      const r = document.createElement("button");
      r.className = `noteButton color ${n}`, r.style.top = `${e}px`, e += 25, r.id = `${n}_button`;
      let o;
      switch (n) {
        case "blue":
          o = vt.blue();
          break;
        case "red":
          o = vt.red();
          break;
        case "green":
          o = vt.green();
          break;
        case "white":
          o = vt.white();
          break;
        case "black":
          o = vt.black();
          break;
        default:
          o = vt.white();
          break;
      }
      r.onmousedown = () => {
        this._activeNoteText !== null && this._activeNoteText.setColor(o);
      }, this._container.appendChild(r);
    });
    const i = document.createElement("button");
    i.className = "noteButton trash", i.style.top = `${e}px`, i.onmousedown = async () => {
      this._activeNoteText !== null && await this._activeNoteText.remove(null);
    }, this._container.appendChild(i);
  }
  /**
   * Sets the corner offset position of the HTML container.
   * @param positionOffset
   */
  setPositionOffset(t) {
    this._positionOffset = t;
  }
  /**
   * @returns the current HTML container offset position.
   */
  getPositionOffset() {
    return this._positionOffset.copy();
  }
  /**
   * Sets the position of the HTML container, taking into account the position offset.
   * @param position
   */
  setPosition(t) {
    this._position = K.add(t, this._positionOffset), this._container.style.left = `${this._position.x}px`, this._container.style.top = `${this._position.y}px`;
  }
  /**
   * @returns the position of the HTML container, taking into account the position offset.
   */
  getPosition() {
    return this._position.copy();
  }
  /**
   * Sets the text in the HTML container text area.
   * @param text
   */
  setText(t) {
    const e = this._container.querySelector("textarea");
    e !== null && (e.value = t);
  }
  /**
   * @returns the current text in the HTML container text area.
   */
  getText() {
    const t = this._container.querySelector("textarea");
    return t !== null ? t.value : "";
  }
  /**
   * Sets the size of the HTML container.
   * @param size
   */
  setSize(t) {
    this._container.style.width = `${t.x}px`, this._container.style.height = `${t.y}px`;
  }
  /**
   * @returns the size of the HTML container.
   */
  getSize() {
    const t = this._container.getBoundingClientRect();
    return new K(t.width, t.height);
  }
  /**
   * Puts the cursor focus in the HTML container text area.
   */
  focus() {
    this._textArea.focus(), this._textArea.style.pointerEvents = "auto";
  }
  /**
   * Removes the cursor focus from the HTML container text area.
   */
  blur() {
    this._container.blur();
  }
  /**
   * Hides the HTML container.
   */
  hide() {
    this._container.style.visibility = "hidden", this._activeNoteText = null;
  }
  /**
   * Sets the active NoteText and shows the HTML container.
   * @param noteText
   */
  show(t) {
    this._container.style.visibility = "visible", this._activeNoteText = t;
  }
  /**
   * @returns the HTML container element.
   */
  getHtmlContainer() {
    return this._container;
  }
  /**
   * Sets the HTML container element.
   * @param container
   */
  setHtmlContainer(t) {
    this._container = t;
  }
}
class Pd {
  /**
   * @returns JSON Array containing markup data.
   */
  exportMarkup() {
    return [];
  }
  /**
   * Loads JSON markup data
   * @param jsonData JSON Array containing markup data.
   */
  loadData(t) {
    return Promise.resolve([]);
  }
}
const Lr = class Lr extends Pd {
  constructor(t) {
    super(), this._pinSphereMeshId = null, this._pinStemMeshId = null, this._noteTextList = [], this._activeItemHandle = null, this._activeItem = null, this._explodeActive = !1, this._isolateActive = !1, this._stemLength = 2, this._sphereIterations = 2, this._viewer = t, this._noteTextElement = new Sy(), this._noteTextElement.setPositionOffset(new K(12, -24));
    const e = {
      sceneReady: async () => {
        await this._init();
      },
      modelSwitched: async () => {
        await this._init();
      }
    };
    this._viewer.setCallbacks(e);
  }
  async _init() {
    Lr._globalPinSphereMeshData === null && (Lr._globalPinSphereMeshData = this._createPinSphereMeshData()), Lr._globalPinStemMeshData === null && (Lr._globalPinStemMeshData = this._createPinStemMeshData());
    const t = this._viewer.model, e = t.createMesh(Lr._globalPinSphereMeshData), i = t.createMesh(Lr._globalPinStemMeshData), n = await Promise.all([e, i]);
    this._pinSphereMeshId = n[0], this._pinStemMeshId = n[1];
  }
  _createPinStemMeshData() {
    const t = new Cs();
    return t.addPolyline([0, 0, 0, this._stemLength, 0, 0]), t;
  }
  _createPinSphereMeshData() {
    const t = (1 + Math.sqrt(5)) / 2, e = Math.sqrt(10 + 2 * Math.sqrt(5)) / (4 * t), i = e / 2, n = e / (2 * t), r = [];
    r[0] = new _(-n, i, 0), r[1] = new _(n, i, 0), r[2] = new _(-n, -i, 0), r[3] = new _(n, -i, 0), r[4] = new _(0, -n, i), r[5] = new _(0, n, i), r[6] = new _(0, -n, -i), r[7] = new _(0, n, -i), r[8] = new _(i, 0, -n), r[9] = new _(i, 0, n), r[10] = new _(-i, 0, -n), r[11] = new _(-i, 0, n);
    for (const g of r)
      g.normalize();
    let o = [
      [0, 11, 5],
      [0, 5, 1],
      [0, 1, 7],
      [0, 7, 10],
      [0, 10, 11],
      [1, 5, 9],
      [5, 11, 4],
      [11, 10, 2],
      [10, 7, 6],
      [7, 1, 8],
      [3, 9, 4],
      [3, 4, 2],
      [3, 2, 6],
      [3, 6, 8],
      [3, 8, 9],
      [4, 9, 5],
      [2, 4, 11],
      [6, 2, 10],
      [8, 6, 7],
      [9, 8, 1]
    ], l = 12;
    for (let g = 0; g < this._sphereIterations; g++) {
      const y = [];
      o.map((m) => {
        const x = r[m[0]], b = r[m[1]], I = r[m[2]];
        r[l++] = new _(x.x + b.x, x.y + b.y, x.z + b.z).scale(0.5).normalize(), r[l++] = new _(b.x + I.x, b.y + I.y, b.z + I.z).scale(0.5).normalize(), r[l++] = new _(I.x + x.x, I.y + x.y, I.z + x.z).scale(0.5).normalize(), y.push([m[0], l - 3, l - 1]), y.push([l - 3, l - 2, l - 1]), y.push([l - 3, m[1], l - 2]), y.push([l - 2, m[2], l - 1]);
      }), o = y;
    }
    const h = [], u = [];
    for (const g of o)
      for (let y = 0; y < 3; y++) {
        const m = g[y], x = r[m];
        h.push(x.x + this._stemLength + 1), h.push(x.y), h.push(x.z);
        const b = x.normalize();
        u.push(b.x), u.push(b.y), u.push(b.z);
      }
    const d = new Cs();
    return d.addFaces(h, u), d.setFaceWinding(Zs.CounterClockwise), d;
  }
  /**
   * Retrieves the mesh id of the stem of the note pin, if there is one
   * @returns MeshId of the note pin stem, or null if there is none
   */
  getPinStemMeshId() {
    return this._pinStemMeshId;
  }
  /**
   * Retrieves the mesh id of the spherical head of the note pin, if there is one
   * @returns MeshId of the note pin sphere, or null if there is none
   */
  getPinSphereMeshId() {
    return this._pinSphereMeshId;
  }
  /**
   * Retrieves the note text element
   * @returns note text element
   */
  getNoteTextElement() {
    return this._noteTextElement;
  }
  /**
   * Sets the note text element
   * @param noteTextElement
   */
  setNoteTextElement(t) {
    this._noteTextElement.hide(), this._noteTextElement = t;
  }
  /**
   * Gets an array of all NoteText items that have been added to the manager
   * @returns array of all NoteText items
   */
  getNoteTextList() {
    return this._noteTextList;
  }
  /**
   * Adds a note and makes it active
   * @param note NoteText to be added to the manager
   */
  addNote(t) {
    this._noteTextList.push(t), this._activeItem = t;
  }
  /**
   * Removes a note from the manager
   * @param note NoteText to be removed from the manager
   */
  removeNote(t) {
    const e = this._noteTextList.indexOf(t);
    this._noteTextList.splice(e, 1);
  }
  /**
   * Updates note pin visibility based on manager state (namely the current explode state)
   */
  async updatePinVisibility() {
    if (this._noteTextList.length > 0) {
      const t = [];
      for (const i of this._noteTextList) {
        const n = i.getSphereInstanceId(), r = i.getStemInstanceId();
        n !== void 0 && t.push(n), r !== void 0 && t.push(r);
      }
      const e = this._viewer.model.setNodesVisibility(t, !this._explodeActive);
      return this._explodeActive && this._noteTextElement.hide(), e;
    }
  }
  /**
   * Sets manager explode state based on explosion magnitude. Active explosion hides note pins
   * @param magnitude Explosion magnitude
   */
  explode(t) {
    return this._explodeActive = t > 0, this.updatePinVisibility();
  }
  /**
   * Gets managers explosion state. Active explosion hides note pins
   */
  getExplodeActive() {
    return this._explodeActive;
  }
  /**
   * Sets whether an isolate is currently active or not
   * @param isolateActive
   */
  setIsolateActive(t) {
    this._isolateActive = t;
  }
  /**
   * Gets whether an isolate is currently active or not
   * @returns isolate status
   */
  getIsolateActive() {
    return this._isolateActive;
  }
  /**
   * Get the currently active note text
   * @returns Currently active note text
   */
  getActiveItem() {
    return this._activeItem;
  }
  /**
   * Sets a new currently active note text
   * @param activeItem note text to be marked as currently active
   */
  setActiveItem(t) {
    this._activeItem = t;
  }
  /**
   * Get the active handle string, such as the one returned by [[MarkupManager.registerMarkup]]
   * @returns Active handle string
   */
  getActiveItemHandle() {
    return this._activeItemHandle;
  }
  /**
   * Set the active handle string, should be provided by [[MarkupManager.registerMarkup]]
   * @param activeItemHandle Active handle string
   */
  setActiveItemHandle(t) {
    this._activeItemHandle = t;
  }
  /**
   * Attempts to set the active note to the one associated with the
   * pins elected by the provided [[SelectionItem]]
   * @param selection SelectionItem to attempt to find note from
   */
  selectPin(t) {
    this._activeItem && this._activeItem.hide();
    const e = t.getNodeId();
    if (e !== null) {
      const i = this._getNoteTextFromNodeId(e);
      if (i !== null)
        return i.restore(), !0;
    }
    return !1;
  }
  /**
   * Checks if a nodeId is part of a note pin
   * @param nodeId NodeId to be checked
   */
  checkPinInstance(t) {
    return this._getNoteTextFromNodeId(t) !== null;
  }
  _getNoteTextFromNodeId(t) {
    for (const e of this._noteTextList)
      if (e.getSphereInstanceId() === t || e.getStemInstanceId() === t)
        return e;
    return null;
  }
  /**
   * Checks if a UUID is associated with any existing notes
   * @param id UUID to check
   */
  findById(t) {
    for (const e of this._noteTextList)
      if (t === e.getUniqueId())
        return !0;
    return !1;
  }
  /**
   * Loads notes from an iterable of JSON data like that returned by [[exportMarkup]]
   * @param notes JSON note data iterable
   */
  loadData(t) {
    const e = [];
    for (const i of t) {
      const n = Oa.fromJson(i, this._viewer, this).then((r) => r !== null);
      e.push(n);
    }
    return Promise.all(e);
  }
  /**
   * Exports note texts to an array of JSON Objects that can be restored via [[loadData]]
   * @returns Array of JSON objects representing notes
   */
  exportMarkup() {
    const t = [];
    for (const e of this._noteTextList)
      t.push(e.toJson());
    return t;
  }
};
Lr._globalPinSphereMeshData = null, Lr._globalPinStemMeshData = null;
let ad = Lr;
const lx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  NoteText: Oa,
  NoteTextElement: Sy,
  NoteTextManager: ad
}, Symbol.toStringTag, { value: "Module" }));
class Ic {
  constructor(t, e, i, n, r, o) {
    this.vector = e, this.matrix = i, this.nodeId = n, this.position = t, this.handleType = r, this.translation = _.zero(), this.groupId = o;
  }
}
class Py {
  constructor() {
    this.axis = null, this.plane = null, this.viewPlane = null, this.rotate = null;
  }
}
const he = class he extends go {
  constructor(t) {
    super(), this._meshIds = new Py(), this._scaleModifier = 1, this._id = 0, this._handleData = /* @__PURE__ */ new Map(), this._translationFromInitialHandlePosition = _.zero(), this._groupIdRotationMatrix = /* @__PURE__ */ new Map(), this._viewer = t, this._callbacks = {
      camera: () => {
        this._updateCamera();
      },
      _assemblyTreeReady: async () => {
        this._updateViewport(), this._hideOverlay();
        const e = this._createMeshId(this._getAxisMeshData()).then((o) => {
          this._meshIds.axis = o;
        }), i = this._createMeshId(this._getPlaneMeshData()).then((o) => {
          this._meshIds.plane = o;
        }), n = this._createMeshId(this._getViewPlaneMeshData()).then((o) => {
          this._meshIds.viewPlane = o;
        }), r = this._createMeshId(this._getRotateMeshData()).then((o) => {
          this._meshIds.rotate = o;
        });
        await Promise.all([e, i, n, r]);
      },
      modelSwitchStart: () => {
        this.removeHandles();
      }
    }, this._viewer.setCallbacks(this._callbacks);
  }
  remove(t) {
    this._callbacks !== null && (this._viewer.unsetCallbacks(this._callbacks), this._callbacks = null), super.remove(t);
  }
  _getAxisMeshData() {
    return dg(
      he._cylinderRadius,
      he._segmentCount,
      he._cylinderHeight,
      he._coneBaseRadius,
      he._capHeight,
      he._taperHeight
    );
  }
  _getPlaneMeshData() {
    const t = new _(he._planeOffset, 0, he._planeOffset), e = new _(
      he._planeOffset + he._planeLength,
      0,
      he._planeOffset
    ), i = new _(
      he._planeOffset + he._planeLength,
      0,
      he._planeOffset + he._planeLength
    ), n = new _(
      he._planeOffset,
      0,
      he._planeOffset + he._planeLength
    ), r = [
      t.x,
      t.y,
      t.z,
      e.x,
      e.y,
      e.z,
      i.x,
      i.y,
      i.z,
      t.x,
      t.y,
      t.z,
      i.x,
      i.y,
      i.z,
      n.x,
      n.y,
      n.z
    ], o = new _(0, -1, 0), l = [
      o.x,
      o.y,
      o.z,
      o.x,
      o.y,
      o.z,
      o.x,
      o.y,
      o.z,
      o.x,
      o.y,
      o.z,
      o.x,
      o.y,
      o.z,
      o.x,
      o.y,
      o.z
    ], h = new Cs();
    return h.addFaces(r, l), h.setBackfacesEnabled(!0), h.addPolyline([t.x, t.y, t.z, e.x, e.y, e.z]), h.addPolyline([e.x, e.y, e.z, i.x, i.y, i.z]), h.addPolyline([i.x, i.y, i.z, n.x, n.y, n.z]), h.addPolyline([n.x, n.y, n.z, t.x, t.y, t.z]), h;
  }
  _getViewPlaneMeshData() {
    return t_();
  }
  _getRotateMeshData(t = 35, e = 12, i = 0.5) {
    const n = t * Math.PI / 180, r = 0.1, o = 0.5 * n, l = [];
    for (let g = -o; g <= o; g += r) {
      const y = Math.sin(g) * e, m = Math.cos(g) * e;
      l.push(m), l.push(0), l.push(y);
    }
    const h = new _(0, 0, 1), d = i_(l, h, 10, i);
    return d.setBackfacesEnabled(!0), d;
  }
  async setAxisMeshData(t) {
    if (this._meshIds.axis === null) {
      const e = await this._createMeshId(t);
      this._meshIds.axis = e;
    } else
      return this._viewer.model.replaceMesh(this._meshIds.axis, t);
  }
  async setPlaneMeshData(t) {
    if (this._meshIds.plane === null) {
      const e = await this._createMeshId(t);
      this._meshIds.plane = e;
    } else
      return this._viewer.model.replaceMesh(this._meshIds.plane, t);
  }
  async setViewPlaneMeshData(t) {
    if (this._meshIds.viewPlane === null) {
      const e = await this._createMeshId(t);
      this._meshIds.viewPlane = e;
    } else
      return this._viewer.model.replaceMesh(this._meshIds.viewPlane, t);
  }
  async setRotateMeshData(t) {
    if (this._meshIds.rotate === null) {
      const e = await this._createMeshId(t);
      this._meshIds.rotate = e;
    } else
      return this._viewer.model.replaceMesh(this._meshIds.rotate, t);
  }
  /**
   * Gets the associated overlay id
   */
  getOverlayId() {
    return be.Handles;
  }
  _hideOverlay() {
    this._viewer.overlayManager.setVisibility(be.Handles, !1);
  }
  hideOverlay() {
    return this._hideOverlay(), Promise.resolve();
  }
  _showOverlay() {
    this._viewer.overlayManager.setVisibility(be.Handles, !0), this._updateCamera();
  }
  showOverlay() {
    return this._showOverlay(), Promise.resolve();
  }
  _updateViewport() {
    this._viewer.overlayManager.setViewport(
      be.Handles,
      qe.UpperLeftCorner,
      0,
      Fe.ProportionOfCanvas,
      0,
      Fe.ProportionOfCanvas,
      1,
      Fe.ProportionOfCanvas,
      1,
      Fe.ProportionOfCanvas
    );
  }
  updateViewport() {
    return this._updateViewport(), Promise.resolve();
  }
  async addHandles(t, e, i) {
    this._scaleModifier = e, this._translationFromInitialHandlePosition.assign(_.zero()), await this.createDefaultHandles(t, i), this._showOverlay();
  }
  _updateCamera() {
    this._viewer.overlayManager.setCamera(
      be.Handles,
      this._viewer.view.getCamera()
    );
  }
  getVector(t) {
    const e = this._handleData.get(t);
    if (e !== void 0) {
      const i = e.vector;
      if (i !== null)
        return i.copy();
    }
    return null;
  }
  getHandleType(t) {
    const e = this._handleData.get(t);
    return e === void 0 ? null : e.handleType;
  }
  getHandleGroupId(t) {
    const e = this._handleData.get(t);
    return e === void 0 ? he.defaultGroupId : e.groupId;
  }
  getPosition(t) {
    const e = this._handleData.get(t);
    if (e) {
      const i = e.translation.copy();
      return e.position.copy().add(this._translationFromInitialHandlePosition).add(i);
    } else
      return null;
  }
  getHandleNodeIds(t = null) {
    let e = [];
    return this._handleData.forEach((i, n) => {
      e.push([n, i]);
    }), t !== null && (e = e.filter((i) => i[1].groupId === t)), e.map((i) => i[0]);
  }
  async removeHandles(t = null) {
    const e = this.getHandleNodeIds(t);
    t === null ? (this._handleData.clear(), this._groupIdRotationMatrix.clear()) : (e.forEach((i) => {
      this._handleData.delete(i);
    }), this._groupIdRotationMatrix.delete(t)), this._handleData.size === 0 && (this._id = 0, this._hideOverlay()), await this._viewer.model.deleteMeshInstances(e);
  }
  isEmpty() {
    return this._handleData.size === 0;
  }
  async createDefaultHandles(t, e) {
    const i = [];
    i.push(this.addViewPlaneHandle(t, he._viewPlaneColor, e)), i.push(
      this.addAxisTranslationHandle(
        t,
        new _(1, 0, 0),
        he._xColor,
        null,
        e
      )
    ), i.push(
      this.addAxisTranslationHandle(
        t,
        new _(0, 1, 0),
        he._yColor,
        null,
        e
      )
    ), i.push(
      this.addAxisTranslationHandle(
        t,
        new _(0, 0, 1),
        he._zColor,
        null,
        e
      )
    ), i.push(
      this.addPlaneTranslationHandle(
        t,
        new _(1, 0, 0),
        he._zColor,
        vt.black(),
        new _(0, -1, 0),
        e
      )
    ), i.push(
      this.addPlaneTranslationHandle(
        t,
        new _(0, 1, 0),
        he._xColor,
        vt.black(),
        new _(0, 0, -1),
        e
      )
    ), i.push(
      this.addPlaneTranslationHandle(
        t,
        new _(0, 0, 1),
        he._yColor,
        vt.black(),
        new _(-1, 0, 0),
        e
      )
    ), i.push(
      this.addRotateHandle(
        t,
        new _(1, 0, 0),
        he._zColor,
        new _(0, -1, 0),
        e
      )
    ), i.push(
      this.addRotateHandle(
        t,
        new _(0, 1, 0),
        he._xColor,
        new _(0, 0, -1),
        e
      )
    ), i.push(
      this.addRotateHandle(
        t,
        new _(0, 0, 1),
        he._yColor,
        new _(-1, 0, 0),
        e
      )
    ), await Promise.all(i);
  }
  async _createMeshId(t) {
    return await this._viewer.model.createMesh(t, { doNotDelete: !0 });
  }
  async addAxisTranslationHandle(t, e, i, n, r) {
    this._meshIds.axis === null && (this._meshIds.axis = await this._createMeshId(this._getAxisMeshData()));
    const o = `handle-axis-translation-${this._id++}`, l = this._getRotationMatrixFromVector(e, n), h = await this._createMeshInstance(
      this._meshIds.axis,
      o,
      i,
      null,
      t.copy(),
      l.copy()
    );
    return this._handleData.set(
      h,
      new Ic(
        t.copy(),
        e.copy(),
        l.copy(),
        h,
        Vr.Axis,
        r
      )
    ), h;
  }
  async addViewPlaneHandle(t, e, i) {
    this._meshIds.viewPlane === null && (this._meshIds.viewPlane = await this._createMeshId(this._getViewPlaneMeshData()));
    const n = await this._createMeshInstance(
      this._meshIds.viewPlane,
      "handle-sphere-instance",
      e,
      null,
      t,
      new mt()
    );
    return this._handleData.set(
      n,
      new Ic(t.copy(), null, new mt(), n, Vr.ViewPlane, i)
    ), n;
  }
  async addPlaneTranslationHandle(t, e, i, n, r, o) {
    this._meshIds.plane === null && (this._meshIds.plane = await this._createMeshId(this._getPlaneMeshData()));
    const l = `handle-plane-translation-${this._id++}`, h = this._getRotationMatrixFromVector(e, r), u = await this._createMeshInstance(
      this._meshIds.plane,
      l,
      i,
      n,
      t,
      h
    );
    return this._handleData.set(
      u,
      new Ic(
        t.copy(),
        e.copy(),
        h.copy(),
        u,
        Vr.Plane,
        o
      )
    ), u;
  }
  async addRotateHandle(t, e, i, n, r) {
    this._meshIds.rotate === null && (this._meshIds.rotate = await this._createMeshId(this._getRotateMeshData()));
    const o = `handle-rotate-${this._id++}`, l = this._getRotationMatrixFromVector(e, n), h = await this._createMeshInstance(
      this._meshIds.rotate,
      o,
      i,
      null,
      t,
      l
    );
    return this._handleData.set(
      h,
      new Ic(
        t.copy(),
        e.copy(),
        l.copy(),
        h,
        Vr.Rotate,
        r
      )
    ), h;
  }
  _getRotationMatrixFromVector(t, e) {
    e || (e = new _(1, 0, 0), _.cross(e, t).squaredLength() < 1e-3 && (e = new _(0, 1, 0)));
    const i = _.cross(e, t).normalize(), n = _.cross(i, t).normalize();
    t.normalize();
    const r = new mt();
    return r.m[0] = i.x, r.m[1] = i.y, r.m[2] = i.z, r.m[3] = 0, r.m[4] = t.x, r.m[5] = t.y, r.m[6] = t.z, r.m[7] = 0, r.m[8] = n.x, r.m[9] = n.y, r.m[10] = n.z, r.m[11] = 0, r.m[12] = 0, r.m[13] = 0, r.m[14] = 0, r.m[15] = 1, r;
  }
  async _createMeshInstance(t, e, i, n, r, o) {
    let l = this._createTransformationMatrix(r, new mt());
    l = mt.multiply(o, l);
    const h = new Qs(
      t,
      l,
      e,
      i ?? void 0,
      n ?? void 0
    );
    return h.setOpacity(1), h.setCreationFlags(
      ee.SuppressCameraScale | ee.DoNotCut | ee.DoNotExplode | ee.ExcludeBounding | ee.DoNotXRay | ee.OverrideSceneVisibility | ee.AlwaysDraw
    ), h.setOverlayIndex(be.Handles), this._viewer.model.createMeshInstance(h, void 0, !1, !0);
  }
  _createTransformationMatrix(t, e) {
    const i = he._defaultScale * this._scaleModifier;
    let n = new mt().setScaleComponent(i, i, i);
    return n = mt.multiply(n, e), n.setTranslationComponent(t.x, t.y, t.z), n;
  }
  _getHandlePosition(t) {
    let e = null;
    return this._handleData.forEach((i) => {
      i.groupId === t && (e = i.position.copy());
    }), e;
  }
  getGroupIdRotationMatrix(t) {
    const e = this._groupIdRotationMatrix.get(t);
    return e === void 0 ? new mt() : e.copy();
  }
  async updatePosition(t, e, i, n, r) {
    const o = this._viewer.model, l = [], h = /* @__PURE__ */ new Map(), u = this._getHandlePosition(n);
    u !== null && (this._handleData.forEach((d, g) => {
      const y = d.groupId, m = r.get(y) !== void 0;
      if (!(y === n) && !m)
        return;
      const b = d.position.copy();
      b.add(t.copy());
      const I = d.translation.copy();
      b.add(I);
      const C = mt.multiply(
        this.getGroupIdRotationMatrix(y),
        e
      ), P = mt.multiply(d.matrix, C);
      if (m) {
        const O = _.subtract(b, u);
        e.transform(O, b), b.add(u);
      }
      const k = this._createTransformationMatrix(b, P);
      i && (d.position.assign(b), h.set(
        y,
        mt.multiply(this.getGroupIdRotationMatrix(y), e)
      )), l.push(o.setNodeMatrix(g, k));
    }), h.forEach((d, g) => {
      this._groupIdRotationMatrix.set(g, d.copy());
    }), await Promise.all(l));
  }
  resetTranslation() {
    this._translationFromInitialHandlePosition && (this._handleData.forEach((t) => {
      t.translation.add(this._translationFromInitialHandlePosition);
    }), this._translationFromInitialHandlePosition.assign(_.zero()));
  }
  getTranslation() {
    return this._translationFromInitialHandlePosition;
  }
};
he.className = "Communicator.Markup.HandleMarkup", he.defaultGroupId = -1, he._defaultScale = 0.02, he._cylinderRadius = 0.5, he._coneBaseRadius = 0.9, he._cylinderHeight = 7, he._capHeight = 1.2, he._taperHeight = 0.2, he._segmentCount = 20, he._planeOffset = 1, he._planeLength = 2.5, he._xColor = new vt(168, 56, 59), he._yColor = new vt(96, 166, 50), he._zColor = new vt(41, 81, 185), he._viewPlaneColor = vt.white();
let gh = he;
const cx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CursorMarkup: Og,
  HandleData: Ic,
  HandleMarkup: gh,
  HandleMeshIds: Py,
  Measure: ax,
  Note: lx,
  Redline: jb
}, Symbol.toStringTag, { value: "Module" }));
class zh extends Ai {
  /** @hidden */
  constructor(t, e) {
    super(t, e), this._activeRedlineItem = null, this._newRedlineItem = null, this._viewer = t;
  }
  // Interface method for derived operators to implement
  /** @hidden */
  createRedlineItem(t) {
    return null;
  }
  // Interface method for derived operators to implement
  /** @hidden */
  updateRedlineItem(t) {
  }
  // Interface method for derived operators to implement
  /** @hidden */
  finalizeRedlineItem(t) {
    return null;
  }
  // Default behavior for redline operators
  /** @hidden */
  onMouseDown(t) {
    super.onMouseDown(t), this.isActive() && ((t.getButton() === Ee.Left || this._primaryTouchId !== null) && this._redlineOperatorStart(), t.setHandled(!0));
  }
  /** @hidden */
  onMouseMove(t) {
    super.onMouseMove(t), this.isActive() && (this._redlineOperatorMove(), t.setHandled(!0));
  }
  /** @hidden */
  onMouseUp(t) {
    this.isActive() && ((t.getButton() === Ee.Left || this._primaryTouchId !== null) && this._redlineOperatorEnd(), t.setHandled(!0)), super.onMouseUp(t);
  }
  /** @hidden */
  onMousewheel(t) {
    t.setHandled(!0);
  }
  /** @hidden */
  setDraggingEnabled(t) {
    this._dragging = t;
  }
  /** @hidden */
  setHandled() {
    return !0;
  }
  _isRedlineItem(t) {
    return Object.getPrototypeOf(t) instanceof Ll;
  }
  /** @hidden */
  onKeyUp(t) {
    const e = t.getKeyCode();
    if (e === ti.Backspace || e === ti.Delete) {
      const i = this._viewer.markupManager, n = i.getSelectedMarkup(), r = i.getActiveMarkupView(this._view);
      n !== null && this._isRedlineItem(n) && r !== null && (r.removeMarkup(n), i.selectMarkup(null, this._view));
    }
  }
  _removeRedlineTextIfInvalid(t) {
    const e = t;
    if (!e.isValid()) {
      const i = this._viewer.markupManager.getActiveMarkupView(this._view);
      i !== null && (i.removeMarkup(e), this._viewer.trigger("redlineDeleted", e)), e.remove(null);
    }
  }
  // Generic behavior to handle dragging of redline
  _redlineOperatorStart() {
    const t = this._viewer.markupManager, e = t.pickMarkupItem(this._ptFirst, this._view), i = t.getSelectedMarkup();
    if (!e)
      i != null && i.onDeselect(), t.selectMarkup(null, this._view), this._markupIsTextArea(i) ? this._removeRedlineTextIfInvalid(i) : this._newRedlineItem = this.createRedlineItem(this._ptFirst);
    else if (this._activeRedlineItem = e, this._dragging && this._activeRedlineItem.onDragStart(this._ptFirst, this._view)) {
      t.refreshMarkup(this._view);
      const n = this._viewer.markupManager.getActiveMarkupView(this._view);
      n && this._viewer.markupManager.refreshMarkupView(n);
    }
  }
  _redlineOperatorMove() {
    if (this._activeRedlineItem) {
      if (this._dragging && this._activeRedlineItem.onDragMove(this._ptCurrent, this._view)) {
        this._viewer.markupManager.refreshMarkup(this._view);
        const t = this._viewer.markupManager.getActiveMarkupView(this._view);
        t && this._viewer.markupManager.refreshMarkupView(t);
      }
    } else
      this.updateRedlineItem(this._ptCurrent);
  }
  _redlineOperatorEnd() {
    const t = this._viewer.markupManager;
    if (this._activeRedlineItem) {
      if (this._ptFirst.equals(this._ptCurrent))
        t.selectMarkup(this._activeRedlineItem, this._view);
      else if (this._viewer.trigger("redlineUpdated", this._activeRedlineItem), this._dragging && this._activeRedlineItem.onDragEnd(this._ptCurrent, this._view)) {
        t.refreshMarkup(this._view);
        const e = this._viewer.markupManager.getActiveMarkupView(this._view);
        e && this._viewer.markupManager.refreshMarkupView(e);
      }
    } else if (this._newRedlineItem) {
      const e = this.finalizeRedlineItem(this._ptCurrent);
      e && this._attachNewMarkupToView(e);
    }
    this._activeRedlineItem = null, this._newRedlineItem = null;
  }
  async _attachNewMarkupToView(t) {
    const e = this._viewer, i = e.model, n = e.markupManager;
    let r = n.getActiveMarkupView(this._view), o = !1;
    if (r === null) {
      const l = i.getAbsoluteRootNode(), h = await i.getVisibilityState(l), u = await i.getNodeColorMap(i.getAbsoluteRootNode(), Yt.Faces), d = n.createMarkupView(
        this._view,
        void 0,
        !1,
        h,
        u,
        null
      );
      r = n.getMarkupView(d), o = !0;
    }
    r !== null && (r.addMarkupItem(t), n.selectMarkup(t, this._view), n.refreshMarkupView(r)), o && r !== null && this._viewer.trigger("viewCreated", r), this._viewer.trigger("redlineCreated", t);
  }
  _markupIsTextArea(t) {
    return t ? t.getClassName() === Wo.className : !1;
  }
}
class ky extends zh {
  /** @hidden */
  constructor(t, e) {
    super(t, e), this._redlineCircle = null, this._previewHandle = null, this._centerSet = !1;
  }
  /** @hidden */
  createRedlineItem(t) {
    const e = this._view;
    this._redlineCircle = new Aa(this._viewer), this._previewHandle = this._viewer.markupManager.registerMarkup(
      this._redlineCircle,
      this._view
    );
    const i = e.getCamera().getCameraPlaneIntersectionPoint(t, e);
    return i !== null && (this._centerSet = !0, this._redlineCircle.setCenter(i), this._redlineCircle.setRadiusPoint(i)), this._redlineCircle;
  }
  /** @hidden */
  updateRedlineItem(t) {
    const e = this._view;
    if (this._redlineCircle) {
      const i = e.getCamera().getCameraPlaneIntersectionPoint(t, e);
      i !== null && (this._centerSet || (this._centerSet = !0, this._redlineCircle.setCenter(i)), this._redlineCircle.setRadiusPoint(i), this._viewer.markupManager.refreshMarkup(this._view));
    }
  }
  /** @hidden */
  finalizeRedlineItem(t) {
    const e = this._viewer.markupManager;
    let i = null;
    return this._redlineCircle && (this._redlineCircle.isValid() && (i = this._redlineCircle), this._redlineCircle = null, this._previewHandle !== null && (e.unregisterMarkup(this._previewHandle, this._view), this._previewHandle = null), e.refreshMarkup(this._view)), this._centerSet = !1, i;
  }
}
class My extends zh {
  /** @hidden */
  constructor(t, e) {
    super(t, e), this._redlinePolyline = null, this._previewHandle = null;
  }
  /** @hidden */
  createRedlineItem(t) {
    const e = this._view;
    this._redlinePolyline = new Ta(this._viewer), this._previewHandle = this._viewer.markupManager.registerMarkup(
      this._redlinePolyline,
      this._view
    );
    const i = e.getCamera().getCameraPlaneIntersectionPoint(t, e);
    return i !== null && this._redlinePolyline.addPoint(i), this._redlinePolyline;
  }
  /** @hidden */
  updateRedlineItem(t) {
    if (this._redlinePolyline) {
      const e = this._view, i = e.getCamera().getCameraPlaneIntersectionPoint(t, e);
      i !== null && (this._redlinePolyline.addPoint(i), this._viewer.markupManager.refreshMarkup(this._view));
    }
  }
  /** @hidden */
  finalizeRedlineItem(t) {
    const e = this._viewer.markupManager;
    let i = null;
    return this._redlinePolyline && (this._redlinePolyline.isValid() && (i = this._redlinePolyline), this._redlinePolyline = null, this._previewHandle !== null && (e.unregisterMarkup(this._previewHandle, this._view), this._previewHandle = null), e.refreshMarkup(this._view)), i;
  }
}
class Ey extends zh {
  /** @hidden */
  constructor(t, e) {
    super(t, e), this._redlineRectangle = null, this._previewHandle = null;
  }
  /** @hidden */
  createRedlineItem(t) {
    const e = this._view, i = e.getCamera().getCameraPlaneIntersectionPoint(t, e);
    return this._redlineRectangle = new Na(this._viewer), i !== null && (this._redlineRectangle.setPoint1(i), this._redlineRectangle.setPoint2(i)), this._previewHandle = this._viewer.markupManager.registerMarkup(
      this._redlineRectangle,
      this._view
    ), this._redlineRectangle;
  }
  /** @hidden */
  updateRedlineItem(t) {
    if (this._redlineRectangle) {
      const e = this._view, i = e.getCamera().getCameraPlaneIntersectionPoint(t, e);
      i !== null && this._redlineRectangle.setPoint2(i), this._viewer.markupManager.refreshMarkup(this._view);
    }
  }
  /** @hidden */
  finalizeRedlineItem(t) {
    let e = null;
    if (this._redlineRectangle && this._previewHandle) {
      const i = this._viewer.markupManager;
      this._redlineRectangle.isValid() && (e = this._redlineRectangle), i.unregisterMarkup(this._previewHandle, this._view), this._previewHandle = null, this._redlineRectangle = null, i.refreshMarkup(this._view);
    }
    return e;
  }
}
class Ay extends zh {
  /** @hidden */
  constructor(t, e) {
    super(t, e), this._redlineText = null;
  }
  /** @hidden */
  createRedlineItem(t) {
    return this._redlineText = new Wo(this._viewer), this._redlineText;
  }
  /** @hidden */
  finalizeRedlineItem(t) {
    if (this._redlineText === null)
      return null;
    const e = this._view, i = this._redlineText, n = e.getCamera().getCameraPlaneIntersectionPoint(t, e);
    return n !== null && i.setPosition(n), this._redlineText = null, i;
  }
}
const hx = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  RedlineCircleOperator: ky,
  RedlineOperator: zh,
  RedlinePolylineOperator: My,
  RedlineRectangleOperator: Ey,
  RedlineTextOperator: Ay
}, Symbol.toStringTag, { value: "Module" }));
class Ty extends Ai {
  /** @hidden */
  constructor(t, e) {
    super(t, e), this._forceEffectiveSceneVisibilityMask = Se.None, this._rectangleMarkup = new Dg(t, !1), this._incrementalSelection = Bh.create("SelectionManager", t), t.setCallbacks({
      _resetAssemblyTreeBegin: async () => (await this.clearSelection(), this.waitForIdle())
    });
  }
  /**
   * Gets the mask used for forcing effective scene visibility during selection.
   */
  getForceEffectiveSceneVisibilityMask() {
    return this._forceEffectiveSceneVisibilityMask;
  }
  /**
   * Sets the mask used for forcing effective scene visibility during selection.
   */
  setForceEffectiveSceneVisibilityMask(t) {
    this._forceEffectiveSceneVisibilityMask = t;
  }
  hasActiveSelection() {
    return !this._incrementalSelection.isIdle();
  }
  async waitForIdle() {
    return this._incrementalSelection.waitForIdle();
  }
  async clearSelection() {
    return this._incrementalSelection.clearSelection();
  }
  _allowSelection(t, e) {
    return !(t.x === e.x || t.y === e.y);
  }
  _createBeginConfig(t, e, i) {
    const n = new xd();
    return n.forceEffectiveSceneVisibilityMask = this._forceEffectiveSceneVisibilityMask, n.ignoreCuttingSections = !1, n.ignoreUnrequestedInstances = !0, i && (n.mustBeFullyContained = !0), {
      pickConfig: n,
      areaCssMin: t,
      areaCssMax: e
    };
  }
  async _performSelection(t) {
    const e = this._rectangleMarkup.min.copy(), i = this._rectangleMarkup.max.copy(), n = this._rectangleMarkup.initialPosition.x < this._rectangleMarkup.currentPosition.x;
    if (t && await this.clearSelection(), !this._allowSelection(e, i))
      return;
    const r = this._createBeginConfig(e, i, n);
    try {
      return await this._incrementalSelection.performSelection(r);
    } catch (o) {
      if (!(o instanceof no))
        throw o;
    }
  }
  ///////////////////////////////////////////////////////////////////////////////////
  /** @hidden */
  setHandled() {
    return !0;
  }
  /** @hidden */
  onKeyUp(t) {
    t.getKeyCode() === ti.Escape && this.clearSelection();
  }
  /** @hidden */
  onMouseDown(t) {
    super.onMouseDown(t), this.isActive() && (t.setHandled(!0), this._rectangleMarkup.isActive() && this._rectangleMarkup.deactivate(), this._rectangleMarkup.activate(t.getPosition()));
  }
  /** @hidden */
  onMouseMove(t) {
    super.onMouseMove(t), this.isActive() && this._rectangleMarkup.isActive() && (t.setHandled(!0), this._rectangleMarkup.updateCurrentPosition(t.getPosition()), this._viewer.markupManager.refreshMarkup(this._view));
  }
  /** @hidden */
  onMouseUp(t) {
    if (this.isActive() && this._rectangleMarkup.isActive()) {
      t.setHandled(!0), this._rectangleMarkup.updateCurrentPosition(t.getPosition());
      const e = !t.controlDown();
      this._performSelection(e);
    }
    this._rectangleMarkup.isActive() && this._rectangleMarkup.deactivate(), super.onMouseUp(t);
  }
}
class Ny extends Ai {
  /** @hidden */
  constructor(t, e) {
    super(t, e), this._axisTriad = e.getAxisTriad(), this._pickConfig = new Si(Se.Face), this._pickConfig.restrictToOverlays = !0;
  }
  /** @hidden */
  async onMouseUp(t) {
    if (this._axisTriad.getEnabled() && K.subtract(this._ptFirst, this._ptCurrent).squaredLength() < 25 && this._axisTriad.insideOverlay(t.getPosition())) {
      const e = await this._view.pickFromPoint(this._ptFirst, this._pickConfig);
      await this._axisTriad.onClickSelection(e);
    }
    super.onMouseUp(t);
  }
}
class Dy {
  constructor(t, e, i, n, r) {
    this.section = t, this.node = e, this.planeIndex = i, this.plane = n, this.selectionPosition = r, this.origPlaneD = n.d;
  }
}
class Oy extends Ai {
  constructor(t, e, i) {
    super(t, e), this._context = null, this._cuttingManager = i;
  }
  async onMouseDown(t) {
    super.onMouseDown(t), this._context === null && this.isActive() && this._cuttingManager.hasActiveCuttingSection() && (await this._startSelection(t), t.setHandled(this._context !== null));
  }
  async onMouseMove(t) {
    super.onMouseMove(t);
    const e = this._context;
    this.isActive() && e !== null && (t.setHandled(!0), await this._updatePlane(t.getPosition(), e, !1), this._viewer.trigger("cuttingPlaneDrag", e.section, e.planeIndex));
  }
  async _updatePlane(t, e, i) {
    const n = e.selectionPosition, r = e.plane.normal.copy().add(e.selectionPosition), o = this._view.unprojectPoint(t, 0), l = this._view.unprojectPoint(t, 0.5);
    if (o !== null && l !== null) {
      const h = Pm(n, r, o, l);
      if (h !== null) {
        const u = _.subtract(h, e.selectionPosition), d = _.dot(u, e.plane.normal) < 0 ? u.length() : -u.length();
        e.plane.d = e.origPlaneD + d;
        const g = e.plane.normal.copy().scale(-d), y = new mt().setTranslationComponent(g.x, g.y, g.z);
        await e.section.updatePlane(
          e.planeIndex,
          e.plane,
          y,
          i,
          !1
        );
      }
      this._cuttingManager.delayCapping();
    }
  }
  async onMouseUp(t) {
    const e = this._context;
    this.isActive() && e !== null && (t.setHandled(!0), await this._updatePlane(t.getPosition(), e, !0), this._viewer.trigger("cuttingPlaneDragEnd", e.section, e.planeIndex)), this._context = null, super.onMouseUp(t);
  }
  setHandled() {
    return this.isActive() && this._context !== null;
  }
  /**
   * Perform the selection operation. If successful, the cutting plane context will be properly
   * setup, otherwise the cutting plane context will be null.
   */
  async _startSelection(t) {
    this._context = null;
    const e = t.getPosition(), i = Se.Face | Se.Line, n = new Si(i);
    n.ignoreCappingGeometry = !0, n.forceEffectiveSceneVisibilityMask = Se.Face;
    const o = (await this._view.compositePickFromPoint(e, n)).fetchMostRelevant(i);
    if (o === null)
      return;
    const l = o.getNodeId(), h = this._cuttingManager.getCuttingSectionFromNodeId(l);
    if (h !== null) {
      const u = h.getPlaneIndexByNodeId(l);
      this._context = new Dy(
        h,
        l,
        u,
        h.getPlane(u),
        o.getPosition()
      ), this._cuttingManager.delayCapping(), this._viewer.trigger("cuttingPlaneDragStart", h, u);
    }
  }
}
class Ry extends Ai {
  /** @hidden */
  constructor(t, e) {
    super(t, e), this._draggingAvatar = !1, this._restrictToAvatar = !0, this._floorLocked = !1, this._manager = e.floorplanManager;
  }
  /** @hidden */
  async onMouseDown(t) {
    if (super.onMouseDown(t), !this._manager.isActive())
      return;
    const e = t.getPosition();
    let i;
    if (!this._restrictToAvatar)
      i = this._manager.insideOverlay(e);
    else {
      const n = new Si();
      n.restrictToOverlays = !0, i = (await this._view.pickFromPoint(e, n)).getNodeId() === this._manager.getAvatarNodeId();
    }
    i && (this._draggingAvatar = !0, this._floorLocked = this._manager.getFloorLock(), await this._manager.setFloorLock(!0), this._manager.snapAvatarToPoint(e), t.setHandled(!0));
  }
  /** @hidden */
  async onMouseUp(t) {
    super.onMouseUp(t), this._draggingAvatar && await this._manager.setFloorLock(this._floorLocked), this._draggingAvatar = !1;
  }
  /** @hidden */
  onMouseMove(t) {
    if (super.onMouseMove(t), !!this._manager.isActive() && this._draggingAvatar) {
      t.setHandled(!0);
      const e = t.getPosition();
      this._manager.insideOverlay(e) && this._manager.snapAvatarToPoint(e);
    }
  }
  /**
   * Set whether or not dragging is restricted to the avatar. If true the operator will only function if
   * the selection begins on the avatar
   */
  restrictToAvatar(t) {
    this._restrictToAvatar = t;
  }
}
class Ly extends Ai {
  constructor(t, e) {
    super(t, e), this._draggingHandle = !1, this._newRotationMatrix = new mt(), this._translation = _.zero(), this._newTranslation = _.zero(), this._nodeIdGroupMap = /* @__PURE__ */ new Map(), this._groupIdCount = 0, this._activeChildrenGroupIds = /* @__PURE__ */ new Map(), this._initialLocalNodeMatrices = [], this._newLocalNodeMatrices = [], this._trackedPoints = [], this._trackedPointsPositions = [], this._trackedPointCount = 0, this._previousContextClick = !1, this._overlayIndex = null, this._activeHandleNodeId = null, this._handleEventType = So.Translate, this._highlightedHandleId = null, this._handleSize = 1, this._explodeActive = !1, this._measureActive = !1, this._settingMatrixInProgress = !1, this._handleMarkup = new gh(t), this._pickConfig = new Si(Se.Face), this._pickConfig.restrictToOverlays = !0, t.setCallbacks({
      explode: (i) => {
        this._explodeActive = i > 0, this._explodeActive && this.removeHandles();
      },
      measurementBegin: () => {
        this._measureActive = !0, this.removeHandles();
      },
      measurementCreated: () => {
        this._measureActive = !1;
      },
      measurementDeleted: () => {
        this._measureActive = !1;
      }
    });
  }
  /**
   * Sets the mesh data for axis handles.
   * @param meshData
   */
  setAxisMeshData(t) {
    return this._handleMarkup.setAxisMeshData(t);
  }
  /**
   * Sets the mesh data for plane handles.
   * @param meshData
   */
  setPlaneMeshData(t) {
    return this._handleMarkup.setPlaneMeshData(t);
  }
  /**
   * Sets the mesh data for view plane handles.
   * @param meshData
   */
  setViewPlaneMeshData(t) {
    return this._handleMarkup.setViewPlaneMeshData(t);
  }
  /**
   * Sets the mesh data for rotation handles.
   * @param meshData
   */
  setRotateMeshData(t) {
    return this._handleMarkup.setRotateMeshData(t);
  }
  /**
   * Add a point to the tracked points list. When the handle moves, these points will update in world space.
   * @param point
   * @returns point index
   */
  addTrackedPoint(t) {
    const e = this._trackedPointCount;
    return this._trackedPoints[e] = t.copy(), this._trackedPointsPositions[e] = t.copy(), ++this._trackedPointCount, e;
  }
  /**
   * Gets the tracked point list.
   */
  getTrackedPoints() {
    return this._trackedPointsPositions;
  }
  /**
   * Clear the list of tracked points.
   */
  clearTrackedPoints() {
    this._trackedPoints.length = 0, this._trackedPointsPositions.length = 0, this._trackedPointCount = 0;
  }
  /**
   * Returns a boolean value indicating if handles are available to be added to the scene
   * If there is an active explode, active measure, or the model is a 2d drawing.
   * this will be false.
   */
  isEnabled() {
    return !this._explodeActive && !this._measureActive && !this._viewer.sheetManager.isDrawingSheetActive();
  }
  _guardEnabled() {
    if (!this.isEnabled()) {
      const t = this._explodeActive ? "Handles are not enabled when the model is exploded" : this._measureActive ? "Handles are not enabled while a measurement is in progress." : this._viewer.sheetManager.isDrawingSheetActive() ? "Handles are not enabled for 2d drawings." : "Handles are not enabled.";
      throw new oe(t);
    }
  }
  /**
   * Takes a scale value to change the handle size with 1 representing the default size
   * @param size
   */
  setHandleSize(t) {
    this._handleSize = t;
  }
  /**
   * Adds all handles into the scene, oriented along the primary axes
   * @param nodeIds corresponding to the parts that will move with the handles
   * @param position world space coordinates the the handle position
   */
  async addHandles(t, e = null, i = null) {
    if (this._previousContextClick = !1, this._guardEnabled(), !e) {
      const r = await this._viewer.model.getNodesBounding(t);
      return this.addHandles(t, r.center());
    }
    const n = this._findGroupId(t);
    return i === null && (i = n !== null ? n : this.generateGroupId()), this._nodeIdGroupMap.set(i, t), n !== null && await this._handleMarkup.removeHandles(i), this._handleMarkup.addHandles(e, this._handleSize, i);
  }
  /**
   * Returns the group id associated to the given group of node ids, returns null if does not exist
   * @param nodeIds
   */
  _findGroupId(t) {
    let e = null;
    return this._nodeIdGroupMap.forEach((i, n) => {
      i.length === t.length && i.every((r) => t.indexOf(r) !== -1) && (e = n);
    }), e;
  }
  /**
   * This will generate a unique id to associate a group of handles with a group of NodeIds.
   */
  generateGroupId() {
    return this._groupIdCount++;
  }
  _massageGroupId(t) {
    return t ?? gh.defaultGroupId;
  }
  /**
   * Adds a handle that moves along an axis.
   * @param position center of the handle.
   * @param axis axis to move along
   * @param color color of the handle geometry
   * @param positionNormal optional vector to control the orientation of the handle geometry.
   * @param groupId optional parameter to associate this handle with a group of NodeIds
   */
  async addAxisTranslationHandle(t, e, i, n = null, r = null) {
    return this._previousContextClick = !1, this._guardEnabled(), this._handleMarkup.addAxisTranslationHandle(
      t,
      e,
      i,
      n,
      this._massageGroupId(r)
    );
  }
  /**
   * Adds a handle that rotates around an axis
   * @param position center of the handle.
   * @param axis axis to rotate around
   * @param color color of the handle geometry
   * @param positionNormal optional vector to control the orientation of the handle geometry.
   * @param groupId optional parameter to associate this handle with a group of NodeIds
   */
  async addAxisRotationHandle(t, e, i, n = null, r = null) {
    return this._previousContextClick = !1, this._guardEnabled(), this._handleMarkup.addRotateHandle(
      t,
      e,
      i,
      n,
      this._massageGroupId(r)
    );
  }
  /**
   * Adds a handle that restricts movement to a plane.
   * @param position center of the handle.
   * @param normal normal of the plane
   * @param faceColor face color of the handle geometry
   * @param lineColor outline color of the handle geometry
   * @param positionNormal optional vector to control the orientation of the handle geometry.
   * @param groupId optional parameter to associate this handle with a group of NodeIds
   */
  async addPlaneTranslationHandle(t, e, i, n, r = null, o = null) {
    return this._previousContextClick = !1, this._guardEnabled(), this._handleMarkup.addPlaneTranslationHandle(
      t,
      e,
      i,
      n,
      r,
      this._massageGroupId(o)
    );
  }
  /**
   * Adds a handle that restricts movement to the viewplane.
   * @param position center of the handle
   * @param color geometry color
   * @param groupId optional parameter to associate this handle with a group of NodeIds
   */
  async addViewPlaneTranslationHandle(t, e, i = null) {
    return this._previousContextClick = !1, this._guardEnabled(), this._handleMarkup.addViewPlaneHandle(t, e, this._massageGroupId(i));
  }
  /**
   * Sets the NodeIds that any handles in the scene will move.
   * @param nodeIds
   * @param groupId optional parameter that associates a group of NodeIds with a group of handles.
   */
  setNodeIds(t, e = null) {
    this._nodeIdGroupMap.set(this._massageGroupId(e), t);
  }
  /**
   * Gets the NodeIds that the handles in the scene will move.
   * @param groupId optional parameter that specifies if the NodeIds to retrieve are part of a group.
   */
  getNodeIds(t = null) {
    const e = this._nodeIdGroupMap.get(this._massageGroupId(t));
    return e === void 0 ? [] : e.slice();
  }
  /**
   * Shows any handles that have been added to the scene.
   */
  showHandles() {
    this._handleMarkup.showOverlay();
  }
  /**
   * Updates the current handle position.
   * @param translation additional translation
   * @param rotation additional rotation
   * @param finalizePosition keep translation and rotation. If true, added translation and rotation
   * will not reset the next time the position is updated.
   */
  updatePosition(t, e, i, n = null) {
    return this._handleMarkup.updatePosition(
      t,
      e,
      i,
      this._massageGroupId(n),
      this._activeChildrenGroupIds
    );
  }
  /**
   * @returns the current handle position or null if not currently active.
   */
  getPosition() {
    const t = this._handleMarkup.getHandleNodeIds();
    if (t.length > 0) {
      const e = this._handleMarkup.getPosition(t[0]);
      if (e !== null)
        return e.copy();
    }
    return null;
  }
  /**
   * Removes all handles from the scene.
   */
  removeHandles() {
    return this._newRotationMatrix = new mt(), this._translation = _.zero(), this._highlightedHandleId = null, this._nodeIdGroupMap.clear(), this._groupIdCount = 0, this._handleMarkup.removeHandles();
  }
  /**
   * @returns the total translation applied to the handles.
   */
  getTranslation() {
    return this._translation;
  }
  _initLocalNodeMatrices(t) {
    const e = this._viewer.model;
    this._initialLocalNodeMatrices = [];
    for (const i of t)
      this._initialLocalNodeMatrices.push(e.getNodeMatrix(i));
  }
  _getHandleEventType(t) {
    return this._handleMarkup.getHandleType(t) === Vr.Rotate ? So.Rotate : So.Translate;
  }
  async _rotate(t, e, i, n) {
    if (!this._draggingHandle || this._settingMatrixInProgress)
      return;
    const r = this.getNodeIds(n);
    await this._genericTransform(
      t,
      e,
      _.zero(),
      i,
      r,
      n
    ), this._viewer.trigger(
      "handleEvent",
      So.Rotate,
      r,
      this._initialLocalNodeMatrices,
      this._newLocalNodeMatrices
    );
  }
  async _translate(t, e, i) {
    if (!this._draggingHandle || this._settingMatrixInProgress)
      return;
    const n = this.getNodeIds(i);
    await this._genericTransform(_.zero(), 0, t, e, n, i), this._viewer.trigger(
      "handleEvent",
      So.Translate,
      n,
      this._initialLocalNodeMatrices,
      this._newLocalNodeMatrices
    );
  }
  async _genericTransform(t, e, i, n, r, o) {
    this._settingMatrixInProgress = !0;
    const l = this._viewer.model;
    let h = new mt();
    this._newTranslation = i, t.squaredLength() > 0 && (h = this._getRotationMatrix(t, _.zero(), e), this._newRotationMatrix = h.copy());
    const u = [];
    u.push(this.updatePosition(this._newTranslation, this._newRotationMatrix, !1, o)), this._newLocalNodeMatrices = [];
    for (let g = 0; g < r.length; g++) {
      const y = this._newTranslation.copy(), m = r[g];
      let x = this._initialLocalNodeMatrices[g].copy();
      const b = t.copy(), I = n.copy();
      let C;
      const P = l.getNodeParent(m);
      if (P !== null) {
        C = l.getNodeNetMatrix(P);
        const k = mt.inverse(C);
        k !== null && (k.transform(I, I), k.setTranslationComponent(0, 0, 0), k.transform(b, b), k.transform(y, y));
      } else
        C = null;
      t.squaredLength() > 0 && (h = this._getRotationMatrix(
        b,
        I,
        C && C.upperLeft3x3Determinant() < 0 ? -e : e
      ), x = mt.multiply(x, h)), x.setTranslationComponent(
        x.m[12] + y.x,
        x.m[13] + y.y,
        x.m[14] + y.z
      ), u.push(l.setNodeMatrix(m, x)), this._newLocalNodeMatrices.push(x);
    }
    const d = this._newRotationMatrix.copy();
    d.setTranslationComponent(i.x, i.y, i.z);
    for (let g = 0; g < this._trackedPoints.length; ++g) {
      const y = this._trackedPoints[g].copy(), m = _.subtract(y, n);
      d.transform(m, m);
      const x = _.add(m, n);
      this._trackedPointsPositions[g] = x;
    }
    await Ge(u), this._settingMatrixInProgress = !1;
  }
  /** @hidden */
  async _testRotate(t, e, i = null) {
    i = this._massageGroupId(i);
    const n = this._getActiveNodeIdByGroupId(i);
    if (n !== null) {
      const r = this._handleMarkup.getPosition(n);
      if (r === null)
        return;
      this._startDragging(n, So.Rotate), await this._rotate(t, e, r, i), await this._stopDragging();
    }
  }
  /** @hidden */
  async _testTranslate(t, e = null) {
    e = this._massageGroupId(e);
    const i = this._getActiveNodeIdByGroupId(e);
    i !== null && (this._startDragging(i, So.Translate), await this._translate(t, _.zero(), e), await this._stopDragging());
  }
  _getActiveNodeIdByGroupId(t) {
    const e = this._handleMarkup.getHandleNodeIds();
    for (let i = 0; i < e.length; ++i) {
      const n = e[i];
      if (this._handleMarkup.getHandleGroupId(n) === t)
        return n;
    }
    return null;
  }
  _startDragging(t, e) {
    this._activeHandleNodeId = t, this._handleEventType = e;
    const i = this._handleMarkup.getHandleGroupId(t), n = this.getNodeIds(i), r = /* @__PURE__ */ new Map();
    this._nodeIdGroupMap.forEach((o, l) => {
      l !== i && o.forEach((h) => {
        let u = this._viewer.model.getNodeParent(h);
        for (; u !== null; ) {
          if (n.indexOf(u) !== -1) {
            r.set(l, h);
            break;
          }
          u = this._viewer.model.getNodeParent(u);
        }
      });
    }), this._activeChildrenGroupIds = r, n.length > 0 && (this._initLocalNodeMatrices(n), this._viewer.trigger(
      "handleEventStart",
      this._handleEventType,
      n,
      this._initialLocalNodeMatrices
    ), this._draggingHandle = !0);
  }
  async _stopDragging() {
    if (this._draggingHandle = !1, this._activeHandleNodeId !== null) {
      const t = this._handleMarkup.getHandleGroupId(this._activeHandleNodeId);
      await this.updatePosition(this._newTranslation, this._newRotationMatrix, !0, t);
      const e = this.getNodeIds(t);
      this._activeHandleNodeId = null, this._activeChildrenGroupIds.clear(), this._viewer.trigger(
        "handleEventEnd",
        this._handleEventType,
        e,
        this._initialLocalNodeMatrices,
        this._newLocalNodeMatrices
      ), this._newRotationMatrix = new mt(), this._handleMarkup.resetTranslation(), this._translation.add(this._newTranslation), this._newTranslation = _.zero(), this._trackedPoints = this._trackedPointsPositions.slice();
    }
  }
  /** @hidden */
  async onMouseDown(t) {
    super.onMouseDown(t), this._overlayIndex = null;
    const e = await this._view.pickFromPoint(t.getPosition(), this._pickConfig);
    if (e.isNodeEntitySelection()) {
      const i = e.getNodeId(), n = this._viewer.model.getNodeName(i);
      if (n !== null && n.slice(0, 7) === "handle-") {
        t.setHandled(!0);
        const r = this._getHandleEventType(i);
        this._startDragging(i, r);
      }
    }
  }
  _onHandleDrag() {
    if (this._activeHandleNodeId === null)
      return;
    const e = this._view.getCamera();
    let i = 0, n = _.zero(), r = _.zero();
    const o = this._handleMarkup.getHandleType(this._activeHandleNodeId), l = this._handleMarkup.getVector(this._activeHandleNodeId), h = this._handleMarkup.getPosition(this._activeHandleNodeId);
    if (o === null || h === null)
      return;
    const u = this._handleMarkup.getHandleGroupId(this._activeHandleNodeId);
    switch (o) {
      case Vr.Axis:
        l !== null && (r = this._getTranslationComponent(
          h,
          l,
          0,
          u
        ), this._translate(r, h, u));
        break;
      case Vr.Plane:
        l !== null && (r = this._getTranslationComponent(
          h,
          l,
          1,
          u
        ), this._translate(r, h, u));
        break;
      case Vr.ViewPlane:
        {
          const d = e.getTarget(), g = e.getPosition(), y = _.subtract(g, d).normalize();
          r = this._getTranslationComponent(
            h,
            y,
            2,
            u
          ), this._translate(r, h, u);
        }
        break;
      case Vr.Rotate:
        l !== null && (n = l, this._handleMarkup.getGroupIdRotationMatrix(u).copy().setTranslationComponent(0, 0, 0).transform(n, n), i = this._getRotationAngle(h, n), this._rotate(n, i, h, u));
        break;
      default:
        $r();
    }
  }
  /** @hidden */
  async onMouseMove(t) {
    if (super.onMouseMove(t), this._draggingHandle && this._activeHandleNodeId !== null)
      this._onHandleDrag();
    else {
      const e = await this._view.pickFromPoint(t.getPosition(), this._pickConfig);
      await this._highlightHandle(e);
    }
  }
  /** @hidden */
  onMouseUp(t) {
    !this._draggingHandle && this._dragCount < 3 && t.getButton() !== Ee.Right && !this._previousContextClick && !this._viewer.getContextMenuStatus() && (this._overlayIndex === 0 || this._overlayIndex === null) && this.removeHandles(), this._previousContextClick = t.getButton() === Ee.Right || this._viewer.getContextMenuStatus(), this._draggingHandle && this._stopDragging(), super.onMouseUp(t);
  }
  /** @hidden */
  setHandled() {
    return this._draggingHandle;
  }
  _getClosestPoint(t, e, i) {
    const n = t.copy(), r = t.copy().add(e), o = this._view.unprojectPoint(i, 0), l = this._view.unprojectPoint(i, 0.5);
    return o !== null && l !== null ? Pm(n, r, o, l) : null;
  }
  _getTranslationComponent(t, e, i, n) {
    i !== 2 && this._handleMarkup.getGroupIdRotationMatrix(n).copy().setTranslationComponent(0, 0, 0).transform(e, e);
    let r = null, o = null;
    return i === 1 || i === 2 ? (r = this._getPlaneIntersectionPoint(t, e, this._ptFirst), r !== null && (o = this._getPlaneIntersectionPoint(r, e, this._ptCurrent))) : i === 0 && (r = this._getClosestPoint(t, e, this._ptFirst), r !== null && (o = this._getClosestPoint(r, e, this._ptCurrent))), o !== null && r !== null ? _.subtract(o, r) : _.zero();
  }
  async _clearHighlightedHandle() {
    this._highlightedHandleId !== null && (await this._viewer.model.unsetNodesFaceColor([this._highlightedHandleId]), this._highlightedHandleId = null);
  }
  async _highlightHandle(t) {
    if (t.isNodeEntitySelection() && t.overlayIndex() === be.Handles) {
      const e = this._viewer.model, i = e.getNodeName(t.getNodeId());
      if (i !== null && i.slice(0, 7) === "handle-") {
        const n = t.getNodeId();
        if (this._highlightedHandleId === n)
          return;
        await this._clearHighlightedHandle(), this._highlightedHandleId = n, e.setNodesFaceColor([this._highlightedHandleId], vt.green());
        return;
      }
    }
    return this._clearHighlightedHandle();
  }
  _getPlaneIntersectionPoint(t, e, i) {
    const n = this._view.unprojectPoint(i, 0), r = this._view.unprojectPoint(i, 0.5);
    if (n === null || r === null)
      return null;
    const o = new wr(n, r.copy().subtract(n)), l = ln.createFromPointAndNormal(t, e), h = _.zero();
    return l.intersectsRay(o, h) ? h : null;
  }
  _getRotationAngle(t, e) {
    console.assert(t !== null);
    const i = this._getPlaneIntersectionPoint(
      t,
      e,
      this._ptFirst
    ), n = this._getPlaneIntersectionPoint(
      t,
      e,
      this._ptCurrent
    );
    if (i === null || n === null)
      return 0;
    const r = _.subtract(i, t).normalize(), o = _.subtract(n, t).normalize(), l = _.dot(r, o);
    let h = Math.acos(l) * 180 / Math.PI;
    return _.dot(_.cross(r, o), e) < 0 && (h = -h), h;
  }
  _getRotationMatrix(t, e, i) {
    const n = new mt().setTranslationComponent(
      -e.x,
      -e.y,
      -e.z
    ), r = mt.createFromOffAxisRotation(t, i), o = new mt().setTranslationComponent(
      e.x,
      e.y,
      e.z
    );
    return mt.multiply(
      mt.multiply(n, r),
      o
    );
  }
}
class Fy extends Ai {
  /** @hidden */
  constructor(t, e) {
    super(t, e), this._navCube = e.getNavCube(), this._pickConfig = new Si(Se.Face), this._pickConfig.restrictToOverlays = !0;
  }
  /** @hidden */
  async onMouseMove(t) {
    if (super.onMouseMove(t), !this._navCube.getEnabled() || this._dragging && this._dragCount > 1)
      return;
    const e = t.getPosition();
    if (this._navCube.insideOverlay(e)) {
      const i = await this._view.pickFromPoint(e, this._pickConfig);
      this._navCube.onMoveSelection(i);
    }
  }
  /** @hidden */
  async onMouseUp(t) {
    if (this._navCube.getEnabled() && K.subtract(this._ptFirst, this._ptCurrent).squaredLength() < 25) {
      const e = await this._view.pickFromPoint(this._ptFirst, this._pickConfig);
      await this._navCube.onClickSelection(e);
    }
    super.onMouseUp(t);
  }
}
class By extends Ai {
  /** @hidden */
  constructor(t, e, i) {
    super(t, e), this._insertNoteButton = Ee.Left, this._callbackFlag = !1, this._noteTextManager = i;
  }
  /** @hidden */
  onMouseDown(t) {
    super.onMouseDown(t), this.isActive() && (this._callbackFlag || (this._viewer.setCallbacks({
      explode: async (e) => {
        await this._noteTextManager.explode(e);
      }
    }), this._callbackFlag = !0), this._dragging = !1);
  }
  /** @hidden */
  onMouseUp(t) {
    if (this.isActive()) {
      const e = new Si(Se.Face);
      (this._ptFirst.equals(this._ptCurrent) && t.getButton() === this._insertNoteButton || this._primaryTouchId !== null) && this._view.pickFromPoint(t.getPosition(), e).then((i) => {
        if (!this._noteTextManager.selectPin(i) && !this._noteTextManager.getExplodeActive() && !this._noteTextManager.getIsolateActive() && i.overlayIndex() === 0) {
          if (i.isFaceSelection())
            return new Oa(
              this._viewer,
              this._noteTextManager,
              i.getPosition(),
              i.getFaceEntity().getNormal(),
              i.getNodeId()
            );
          t.setHandled(!0);
        }
        return null;
      });
    }
    super.onMouseUp(t);
  }
  /**
   * @returns a NoteTextElement that can be used to configure the NoteText HTML container.
   */
  getNoteTextElement() {
    return this._noteTextManager.getNoteTextElement();
  }
  /**
   * @param noteTextElement
   */
  setNoteTextElement(t) {
    this._noteTextManager.setNoteTextElement(t);
  }
  /**
   * Returns true if the nodeId is the id of a note pin instance.
   * @param nodeId
   */
  checkPinInstance(t) {
    return this._noteTextManager.checkPinInstance(t) !== null;
  }
}
class Vy extends Ai {
  /** @hidden */
  constructor(t, e) {
    super(t, e), this._selectionButton = Ee.Left, this._ignoreTransparency = !1, this._forceEffectiveSceneVisibilityMask = Se.None, this._incrementalSelection = Bh.create("SelectionManager", t), t.setCallbacks({
      _resetAssemblyTreeBegin: async () => (await this.clearSelection(), this.waitForIdle()),
      selectionArray: (i) => {
        i.length === 0 && this._incrementalSelection.stopSelection();
      }
    });
  }
  /**
   * Gets the mask used for forcing effective scene visibility during selection.
   */
  getForceEffectiveSceneVisibilityMask() {
    return this._forceEffectiveSceneVisibilityMask;
  }
  /**
   * Sets the mask used for forcing effective scene visibility during selection.
   */
  setForceEffectiveSceneVisibilityMask(t) {
    this._forceEffectiveSceneVisibilityMask = t;
  }
  setIgnoreTransparency(t) {
    this._ignoreTransparency = t;
  }
  getIgnoreTransparency() {
    return this._ignoreTransparency;
  }
  hasActiveSelection() {
    return !this._incrementalSelection.isIdle();
  }
  async waitForIdle() {
    return this._incrementalSelection.waitForIdle();
  }
  async clearSelection() {
    return this._incrementalSelection.clearSelection();
  }
  _createBeginConfig(t) {
    const e = new xd();
    return e.forceEffectiveSceneVisibilityMask = this._forceEffectiveSceneVisibilityMask, e.ignoreUnrequestedInstances = !0, {
      pickConfig: e,
      rayCssOrigin: t,
      rayCssBoxRadius: 10
    };
  }
  async _selectionPredicate(t) {
    const e = this._viewer.model, i = t.getNodeId();
    if (i === null)
      return !1;
    const [n] = await e.getNodesHaveTransparency([i]);
    return !n;
  }
  async _performSelection(t) {
    const e = this._createBeginConfig(t), i = this._ignoreTransparency ? (n) => this._selectionPredicate(n) : null;
    return this._incrementalSelection.performSelection(e, i);
  }
  ///////////////////////////////////////////////////////////////////////////////////
  /** @hidden */
  setHandled() {
    return !0;
  }
  /** @hidden */
  onKeyUp(t) {
    t.getKeyCode() === ti.Escape && this.clearSelection();
  }
  /** @hidden */
  onMouseUp(t) {
    this.isActive() && (async () => (t.getButton() === this._selectionButton || this._primaryTouchId !== null) && K.subtract(this._ptFirst, this._ptCurrent).squaredLength() < 25 && (t.controlDown() || await this.clearSelection(), await this._performSelection(t.getPosition())))(), super.onMouseUp(t);
  }
}
class zy extends Ai {
  /** @hidden */
  constructor(t, e, i) {
    super(t, e), this._selectionButton = Ee.Left, this._pickConfig = new Si(Se.Face | Se.Line), this._forceEffectiveSceneVisibilityMask = null, this._doubleClickFitWorld = !0, this._noteTextManager = i;
  }
  /** Sets the [[PickConfig]] that will be passed to [[View.pickFromPoint]]. */
  setPickConfig(t) {
    this._pickConfig = t.copy();
  }
  /** Returns the [[PickConfig]] that will be passed to [[View.pickFromPoint]]. */
  getPickConfig() {
    return this._pickConfig.copy();
  }
  /**
   * Gets the button used for selection.
   * @returns Button
   */
  getSelectionButton() {
    return this._selectionButton;
  }
  /**
   * Sets the button used for selection
   * @param button
   */
  setSelectionButton(t) {
    this._selectionButton = t;
  }
  /** @hidden */
  onKeyUp(t) {
    t.getKeyCode() === ti.Escape && this._viewer.selectionManager.clear();
  }
  /** @hidden */
  onMouseUp(t) {
    if (this.isActive() && K.subtract(this._ptFirst, this._ptCurrent).length() < 5 && (t.getButton() === this._selectionButton || this._primaryTouchId !== null)) {
      const i = this._view;
      let n = this._pickConfig;
      this._forceEffectiveSceneVisibilityMask !== null && (n = n.copy(), n.forceEffectiveSceneVisibilityMask = this._forceEffectiveSceneVisibilityMask), i.pickFromPoint(this._ptCurrent, n).then((r) => {
        const l = this._viewer.cuttingManager.getCuttingSectionFromNodeId(r.getNodeId()) !== null, h = this._noteTextManager.selectPin(r), u = this._viewer.markupManager.pickMarkupItem(
          this._ptCurrent,
          this._view
        );
        u instanceof Wo && this._viewer.markupManager.selectMarkup(u, i), !h && !l && u === null && (r.isNodeSelection() ? this._processSelectionClick(t, r) : this._isDoubleClick || this._viewer.selectionManager.clear());
      });
    }
    super.onMouseUp(t);
  }
  /** @hidden */
  async onDoubleClick() {
    if (this._doubleClickFitWorld)
      return this._view.fitWorld();
  }
  /**
   * When enabled, a double click will fit the view to the model bounding box.
   * @param doubleClickFitWorld
   */
  setDoubleClickFitWorldEnabled(t) {
    this._doubleClickFitWorld = t;
  }
  // helper function to get the parent selection item if the part is already selected
  _getSelectionOrParentIfSelected(t) {
    const e = this._viewer.selectionManager;
    if (!e.getSelectParentIfSelected())
      return t;
    const i = this._viewer.model, n = t.getNodeId();
    if (!i.isNodeLoaded(n) || i.getNodeType(n) === Le.PmiBody)
      return t;
    const o = e.containsParent(t);
    if (o !== null) {
      const l = _i.create(i.getNodeParent(o.getNodeId()));
      return l.isNodeSelection() ? l : t;
    } else if (e.contains(t)) {
      const l = _i.create(i.getNodeParent(n));
      return l.isNodeSelection() ? l : t;
    } else
      return t;
  }
  _processSelectionClick(t, e) {
    const i = e.overlayIndex();
    if (i !== 0 && i !== null)
      return;
    const n = this._viewer.selectionManager;
    if (t.controlDown() || t.commandDown())
      n.toggle(e);
    else {
      const r = this._getSelectionOrParentIfSelected(e);
      n.set(r);
    }
  }
}
const ux = `/**
* @license 3DconnexionJS
*
* Copyright (c) 2013-2022 3Dconnexion. All rights reserved.
* License:
*   This file is licensed under the terms of the "3Dconnexion
*   Software Development Kit" license agreement:
*   http://www.3dconnexion.com/service/software-developer/licence-agreement.html
*   All rights not expressly granted by 3Dconnexion are reserved.
*
* $Revision$
*/
var when,CryptoJS,AUTOBAHNJS_VERSION,global;_3Dconnexion=function(n){"use strict";this.version="0.7.0";this.client=n;this.session=null;this.defport=8181;this.connected=!1;this.connexion=null;this._3dcontroller=null;this.viewport=null;this.host="127.51.68.120";this.nlRpcUri=null;this.nlResourceUri=null;this._EVENT_TYPEID_RPC=0;this.V3DK_FIT=31;this.V3DK_MENU=30;this.fnUpdate={motion:this.onMotion.bind(this),"events.keyPress":this.onKeyPress.bind(this),"events.keyRelease":this.onKeyRelease.bind(this)};this.clientFnRead={"view.affine":n.getViewMatrix,"view.constructionPlane":n.getConstructionPlane,"view.extents":n.getViewExtents,"view.fov":n.getFov,"view.frustum":n.getViewFrustum,"view.perspective":n.getPerspective,"view.target":n.getViewTarget,"view.rotatable":n.getViewRotatable,"model.extents":n.getModelExtents,"model.floorPlane":n.getFloorPlane,"model.unitsToMeters":n.getUnitsToMeters,"pivot.position":n.getPivotPosition,"hit.lookat":n.getLookAt,"selection.affine":n.getSelectionAffine,"selection.empty":n.getSelectionEmpty,"selection.extents":n.getSelectionExtents,"pointer.position":n.getPointerPosition,coordinateSystem:n.getCoordinateSystem,"views.front":n.getFrontView,"frame.timingSource":n.getFrameTimingSource,"frame.time":n.getFrameTime};this.clientFnUpdate={motion:n.setMoving,transaction:n.setTransaction,"view.affine":n.setViewMatrix,"view.extents":n.setViewExtents,"view.fov":n.setFov,"view.target":n.setTarget,"commands.activeCommand":n.setActiveCommand,"pivot.position":n.setPivotPosition,"pivot.visible":n.setPivotVisible,"hit.lookfrom":n.setLookFrom,"hit.direction":n.setLookDirection,"hit.aperture":n.setLookAperture,"hit.selectionOnly":n.setSelectionOnly,"selection.affine":n.setSelectionAffine,"events.keyPress":n.setKeyPress,"events.keyRelease":n.setKeyRelease,"settings.changed":n.setSettingsChanged};this.debug=!1;window.hasOwnProperty("_3DCONNEXION_DEBUG")&&(this.debug=window._3DCONNEXION_DEBUG);this.blur=this.blur.bind(this);this.focus=this.focus.bind(this)};typeof module=="object"&&(module.exports=_3Dconnexion);_3Dconnexion.prototype={constructor:_3Dconnexion};Object.freeze(_3Dconnexion.nlOptions={none:0,rowMajorOrder:2});_3Dconnexion.prototype.connect=function(){"use strict";var n=this,e=this.client,u=1,t=new XMLHttpRequest,f,r,i;if(!e.onConnect)throw"onConnect handler required!";i="https://"+n.host+":"+n.defport+"/3dconnexion/nlproxy";t.onreadystatechange=function(){if(t.readyState===4&&t.status===200){n.debug&&console.log(t.responseText);n.nlRpcUri="wss://"+n.host+"/3dconnexion#";n.nlResourceUri="wss://"+n.host+"/3dconnexion";try{f=JSON.parse(t.responseText).port;r="wss://"+n.host+":"+f;n.debug&&console.log("Connecting to "+r+" ...");window.hasOwnProperty("AUTOBAHN_DEBUG")&&window.AUTOBAHN_DEBUG&&window.ab.debug(!0,!0,!0);window.ab.connect(r,function(t){n.session=t;n.connected=!0;n.debug&&console.log("Connected!");t.prefix("3dx_rpc",n.nlRpcUri);t.prefix("3dconnexion",n.nlResourceUri);t.prefix("self",window.location.href);n.client.onConnect()},function(t,i){if(n.client.onDisconnect!==undefined)n.client.onDisconnect(i);n.delete3dmouse();n.connected=!1;n.session=null;n.debug&&console.log("Socket closed!",i)},{maxRetries:3,retryDelay:500})}catch(i){console.error(i)}}};t.onerror=function(){n.debug&&console.log("_3Dconnexion.connect: No response from local 3dmouse server "+i)};t.ontimeout=function(){n.debug&&console.log("_3Dconnexion.connect: Timeout querying local 3dmouse server "+i)};try{t.open("GET",i,!0);t.setRequestHeader("Accept","application/json; charset=utf-8");t.msCaching="disabled";t.timeout=0;t.send()}catch(o){u=0;console.error(o.toString())}return u};_3Dconnexion.prototype.create3dmouse=function(n,t,i){"use strict";i=typeof i!="undefined"?i:_3Dconnexion.nlOptions.none;var r=this;r.viewport=n;r.debug&&console.log("create3dmouse "+r.viewport.id);r.viewport.addEventListener("focus",r.focus);r.viewport.addEventListener("blur",r.blur);r.session.call("3dx_rpc:create","3dconnexion:3dmouse",r.version).then(function(n){r.connexion=n.connexion;var u={version:parseFloat(r.version),name:t,rowMajorOrder:(i&_3Dconnexion.nlOptions.rowMajorOrder)!=0};r.session.call("3dx_rpc:create","3dconnexion:3dcontroller",r.connexion,u).then(function(n){r._3dcontroller=n.instance;r.session.subscribe("3dconnexion:3dcontroller/"+r._3dcontroller,r.onEvent.bind(r));document.hasFocus()&&(document.activeElement===document.body||document.activeElement===null?(r.viewport.focus(),window===r.viewport&&r.focus()):r.viewport.contains(document.activeElement)&&(r.focus(),r.debug&&console.log("self.viewport has focus")));r.client.on3dmouseCreated&&r.client.on3dmouseCreated()},function(n){console.log("3dx_rpc:create 3dconnexion:3dcontroller "+n)})},function(n){console.log("3dx_rpc:create "+n)})};_3Dconnexion.prototype.blur=function(){"use strict";var n=this;n.debug&&console.log("blur on ");n.session&&n._3dcontroller&&n.update3dcontroller({focus:!1})};_3Dconnexion.prototype.focus=function(){"use strict";var n=this;n.debug&&console.log("focus on ");n.session&&n._3dcontroller&&n.update3dcontroller({focus:!0})};_3Dconnexion.prototype.onKeyPress=function(n){"use strict";var t=this;t.debug&&console.log("onKeyPress "+n)};_3Dconnexion.prototype.onKeyRelease=function(n){"use strict";var t=this;t.debug&&console.log("onKeyRelease "+n)};_3Dconnexion.prototype.onMotion=function(n){"use strict";var t=this;n===!0?t.client.onStartMotion!==undefined&&t.client.onStartMotion():t.client.onStopMotion!==undefined&&t.client.onStopMotion()};_3Dconnexion.prototype.onEvent=function(n,t){"use strict";var i=this,f=null,r=null,u=null;if(i.debug&&(console.log(n),console.log(t)),t[0]===window.ab._MESSAGE_TYPEID_CALL){if(t[2]==="self:read")if(r=i.clientFnRead[t[4]],r!==undefined)f=r.bind(i.client)();else{u=[window.ab._MESSAGE_TYPEID_CALL_ERROR,t[1],t[2]+"#generic",t[4]+" unknown property"];i.session._send(u);return}else if(t[2]==="self:update")if(r=i.fnUpdate[t[4]],r!==undefined)f=r(t[5]);else if(r=i.clientFnUpdate[t[4]],r!==undefined)f=r.bind(i.client)(t[5]);else{u=[window.ab._MESSAGE_TYPEID_CALL_ERROR,t[1],t[2]+"#generic",t[4]+" unknown property"];i.session._send(u);return}else{u=[window.ab._MESSAGE_TYPEID_CALL_ERROR,t[1],t[2]+"#generic","unknown procedure"];i.session._send(u);return}u=[window.ab._MESSAGE_TYPEID_CALL_RESULT,t[1],f];i.session._send(u)}};_3Dconnexion.prototype.read3dcontroller=function(n,t){"use strict";var i=this;i.debug&&console.log("read3dcontroller "+i._3dcontroller);try{i.session.call("3dx_rpc:read","3dconnexion:3dcontroller/"+i._3dcontroller,n).then(function(n){t&&t(n)},function(t){console.log("3dx_rpc:read 3dconnexion:3dcontroller/"+i._3dcontroller+" "+n+" "+t)})}catch(r){console.error(r)}};_3Dconnexion.prototype.update3dcontroller=function(n){"use strict";var t=this;t.debug&&console.log("update3dmouse "+t._3dcontroller);try{if(!t._3dcontroller)throw"exception 3dx_rpc:update: 3dcontroller not initialized";t.session.call("3dx_rpc:update","3dconnexion:3dcontroller/"+t._3dcontroller,n).then(function(){return},function(n){console.log("3dx_rpc:update 3dconnexion:3dcontroller/"+t._3dcontroller+" "+n)})}catch(i){console.error(i)}};_3Dconnexion.prototype.delete3dmouse=function(){"use strict";var n=this,t=n.connexion;n.debug&&console.log("delete3dmouse ");n.connexion=null;n._3dcontroller=null;n.viewport!==null&&(n.viewport.removeEventListener("focus",n.focus),n.viewport.removeEventListener("blur",n.blur));n.session&&n.session.call("3dx_rpc:delete","3dconnexion:3dmouse/"+t).then(function(){n.debug&&console.log("deleted connexion "+t)},function(n){console.log("3dx_rpc:delete "+t+" "+n)})};Object.freeze(_3Dconnexion.SiActionNodeType_t={SI_ACTIONSET_NODE:0,SI_CATEGORY_NODE:1,SI_ACTION_NODE:2});_3Dconnexion.ActionNode=function(n,t,i){return this.id=n,this.label=t||n,this.type=i,this};_3Dconnexion.ActionNode.prototype={constructor:_3Dconnexion.ActionNode,id:{value:null,enumerable:!0},label:{value:null,writable:!0,enumerable:!0},type:{value:null,enumerable:!0}};_3Dconnexion.Action=function(n,t,i){return _3Dconnexion.ActionNode.call(this,n,t,_3Dconnexion.SiActionNodeType_t.SI_ACTION_NODE),this.description=i||"",this};_3Dconnexion.Action.prototype=Object.create(_3Dconnexion.ActionNode.prototype,{constructor:{value:_3Dconnexion.Action},description:{value:"",writable:!0,enumerable:!0}});_3Dconnexion.ActionTreeNode=function(){return this.nodes=[],this};_3Dconnexion.ActionTreeNode.prototype=Object.create(_3Dconnexion.ActionNode.prototype,{constructor:{value:_3Dconnexion.ActionTreeNode},nodes:{value:null,writable:!0,enumerable:!0},push:{value:function(n){return this.nodes.push(n),n}}});_3Dconnexion.ActionSet=function(n,t){return _3Dconnexion.ActionNode.call(this,n,t,_3Dconnexion.SiActionNodeType_t.SI_ACTIONSET_NODE),_3Dconnexion.ActionTreeNode.call(this),this};_3Dconnexion.ActionSet.prototype=Object.create(_3Dconnexion.ActionTreeNode.prototype,{constructor:{value:_3Dconnexion.ActionSet}});_3Dconnexion.Category=function(n,t){return _3Dconnexion.ActionNode.call(this,n,t,_3Dconnexion.SiActionNodeType_t.SI_CATEGORY_NODE),_3Dconnexion.ActionTreeNode.call(this),this};_3Dconnexion.Category.prototype=Object.create(_3Dconnexion.ActionTreeNode.prototype,{constructor:{value:_3Dconnexion.Category}});_3Dconnexion.ActionTree=function(){return this.nodes=[],this};_3Dconnexion.ActionTree.prototype=Object.create(null,{constructor:{value:_3Dconnexion.ActionTree},nodes:{value:null,writable:!0,enumerable:!0},push:{value:function(n){return this.nodes.push(n),n}}});_3Dconnexion.ImageItem=function(){};Object.freeze(_3Dconnexion.SiImageType_t={e_none:0,e_image_file:1,e_resource_file:2,e_image:3});_3Dconnexion.ImageItem.prototype={constructor:_3Dconnexion.ImageItem,id:{value:"",writable:!0},type:{value:"e_none",enumerable:!0}};_3Dconnexion.ImageItem.fromImage=function(n,t){var i=new _3Dconnexion.ImageItem;return Object.defineProperties(i,{id:{value:t||"",writable:!0,enumerable:!0},type:{value:_3Dconnexion.SiImageType_t.e_image,enumerable:!0},index:{value:0,writable:!0,enumerable:!0},data:{value:_3Dconnexion.ImageItem.base64FromArrayBuffer(n),enumerable:!0},status:{value:200}})};_3Dconnexion.ImageItem.fromURL=function(n,t){var r=new _3Dconnexion.ImageItem,i;return Object.defineProperties(r,{id:{value:t||"",writable:!0,enumerable:!0},type:{value:_3Dconnexion.SiImageType_t.e_image,enumerable:!0},index:{value:0,writable:!0,enumerable:!0},buffer:{value:null,writable:!0},data:{get:function(){return this.buffer},set:function(n){r.buffer=n;r.onload()},enumerable:!0},status:{value:100,writable:!0},onload:{value:function(){},writable:!0}}),i=new XMLHttpRequest,i.overrideMimeType("text/plain; charset=x-user-defined"),i.open("GET",n,!0),i.responseType="arraybuffer",i.onload=function(){if(r.status=i.status,i.status===200&&i.response!==null){r.data=_3Dconnexion.ImageItem.base64FromArrayBuffer(i.response);return}r.status=404;r.data=null},i.onerror=function(){r.status=i.status;r.data=null},i.send(null),r};_3Dconnexion.ImageItem.base64FromArrayBuffer=function(n){for(var u="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",t=new Uint8Array(n),e=t.length%3,f=t.length-e,i="",r=0;r<f;r+=3)i+=u[t[r]>>2],i+=u[(t[r]&3)<<4|t[r+1]>>4],i+=u[(t[r+1]&15)<<2|t[r+2]>>6],i+=u[t[r+2]&63];return e!==0&&(i+=u[t[f]>>2],e===2?(i+=u[(t[f]&3)<<4|t[f+1]>>4],i+=u[(t[f+1]&15)<<2],i+="="):(i+=u[(t[f]&3)<<4],i+="==")),i};_3Dconnexion.ImageCache=function(){this.images=[];this.outstanding_requests=0};_3Dconnexion.ImageCache.prototype={constructor:_3Dconnexion.ImageCache,images:{value:null,writable:!0,enumerable:!0},outstanding_requests:{value:0,writable:!0},push:function(n){var t=this;if(n.status===100)++t.outstanding_requests,n.onload=function(){var n=this,i;n.onload=function(){};n.status!==200&&(i=t.images.indexOf(n),i>-1&&t.images.splice(i,1));--t.outstanding_requests;t.outstanding_requests===0&&t.onload()}.bind(n);else if(n.data===null)return;t.images.push(n)},onload:function(){}};
/** @license AutobahnJS - http://autobahn.ws
 *
 * Copyright (C) 2011-2014 Tavendo GmbH.
 * Licensed under the MIT License.
 * See license text at http://www.opensource.org/licenses/mit-license.php
 *
 * AutobahnJS includes code from:
 *
 * when - http://cujojs.com
 *
 * (c) copyright B Cavalier & J Hann
 * Licensed under the MIT License at:
 * http://www.opensource.org/licenses/mit-license.php
 *
 * Crypto-JS - http://code.google.com/p/crypto-js/
 *
 * (c) 2009-2012 by Jeff Mott. All rights reserved.
 * Licensed under the New BSD License at:
 * http://code.google.com/p/crypto-js/wiki/License
 * 
 * console-normalizer - https://github.com/Zenovations/console-normalizer
 *
 * (c) 2012 by Zenovations.
 * Licensed under the MIT License at:
 * http://www.opensource.org/licenses/mit-license.php
 * 
 */
(function(n){n||(n=window.console={log:function(){},info:function(){},warn:function(){},error:function(){}});Function.prototype.bind||(Function.prototype.bind=function(n){var t=this,i=Array.prototype.slice.call(arguments,1);return function(){return t.apply(n,Array.prototype.concat.apply(i,arguments))}});typeof n.log=="object"&&(n.log=Function.prototype.call.bind(n.log,n),n.info=Function.prototype.call.bind(n.info,n),n.warn=Function.prototype.call.bind(n.warn,n),n.error=Function.prototype.call.bind(n.error,n));"group"in n||(n.group=function(t){n.info("\\n--- "+t+" ---\\n")});"groupEnd"in n||(n.groupEnd=function(){n.log("\\n")});"time"in n||function(){var t={};n.time=function(n){t[n]=(new Date).getTime()};n.timeEnd=function(i){var r=(new Date).getTime(),u=i in t?r-t[i]:0;n.info(i+": "+u+"ms")}}()})(window.console);
/** @license MIT License (c) copyright 2011-2013 original author or authors */
when=function(n){"use strict";function t(n,t,i,r){return at(n).then(t,i,r)}function e(n){return new f(n,h.PromiseStatus&&h.PromiseStatus())}function f(n,t){function c(){return f?f.inspect():ii()}function l(n,t,r,u,e){function o(i){i._when(n,t,r,u,e)}i?i.push(o):y(function(){o(f)})}function o(n){if(i){var r=i;i=u;y(function(){f=pt(e,n);t&&bt(f,t);w(r,f)})}}function s(n){o(new r(n))}function a(n){if(i){var t=i;y(function(){w(t,new b(n))})}}var e,f,i=[];e=this;this._status=t;this.inspect=c;this._when=l;try{n(o,s,a)}catch(h){s(h)}}function at(n){return n instanceof f?n:o(n)}function o(n){return e(function(t){t(n)})}function vt(n){return t(n,function(n){return new r(n)})}function yt(){function f(u,f,e){n.resolve=n.resolver.resolve=function(n){return t?o(n):(t=!0,u(n),i)};n.reject=n.resolver.reject=function(n){return t?o(new r(n)):(t=!0,f(n),i)};n.notify=n.resolver.notify=function(n){return e(n),n}}var n,i,t;return n={promise:u,resolve:u,reject:u,notify:u,resolver:{resolve:u,reject:u,notify:u}},n.promise=i=e(f),n}function w(n,t){for(var i=0;i<n.length;i++)n[i](t)}function pt(n,t){if(t===n)return new r(new TypeError);if(t instanceof f)return t;try{var i=t===Object(t)&&t.then;return typeof i=="function"?wt(i,t):new c(t)}catch(u){return new r(u)}}function wt(n,t){return e(function(i,r){d(n,t,i,r)})}function c(n){this.value=n}function r(n){this.value=n}function b(n){this.value=n}function bt(n,t){function i(){t.fulfilled()}function r(n){t.rejected(n)}n.then(i,r)}function rt(n){return n&&typeof n.then=="function"}function ut(n,i,r,u,f){return t(n,function(n){function o(r,u,f){function y(n){c(n)}function w(n){h(n)}var o,v,s,a,h,c,l,e;if(l=n.length>>>0,o=Math.max(0,Math.min(i,l)),s=[],v=l-o+1,a=[],o)for(c=function(n){a.push(n);--v||(h=c=p,u(a))},h=function(n){s.push(n);--o||(h=c=p,r(s))},e=0;e<l;++e)e in n&&t(n[e],w,y,f);else r(s)}return e(o).then(r,u,f)})}function kt(n,t,i,r){function u(n){return t?t(n[0]):n[0]}return ut(n,1,u,i,r)}function ft(n,t,i,r){return l(n,p).then(t,i,r)}function dt(){return l(arguments,p)}function gt(n){return l(n,et,ot)}function ni(n,t){return l(n,t)}function l(n,i,r){return t(n,function(n){function u(u,f,e){function l(n,o){t(n,i,r).then(function(n){s[o]=n;--h||u(s)},f,e)}var s,c,h,o;if(h=c=n.length>>>0,s=[],!h){u(s);return}for(o=0;o<c;o++)o in n?l(n[o],o):--h}return new f(u)})}function ti(n,i){var r=d(k,arguments,1);return t(n,function(n){var u;return u=n.length,r[0]=function(n,r,f){return t(n,function(n){return t(r,function(t){return i(n,t,f,u)})})},st.apply(n,r)})}function et(n){return{state:"fulfilled",value:n}}function ot(n){return{state:"rejected",reason:n}}function ii(){return{state:"pending"}}function y(n){v.push(n)===1&&s(lt)}function lt(){w(v);v=[]}function p(n){return n}function ri(n){typeof h.reportUnhandled=="function"?h.reportUnhandled():y(function(){throw n;});throw n;}t.promise=e;t.resolve=o;t.reject=vt;t.defer=yt;t.join=dt;t.all=ft;t.map=ni;t.reduce=ti;t.settle=gt;t.any=kt;t.some=ut;t.isPromise=rt;t.isPromiseLike=rt;i=f.prototype;i.then=function(n,t,i){var r=this;return new f(function(u,f,e){r._when(u,e,n,t,i)},this._status&&this._status.observed())};i["catch"]=i.otherwise=function(n){return this.then(u,n)};i["finally"]=i.ensure=function(n){function t(){return o(n())}return typeof n=="function"?this.then(t,t)["yield"](this):this};i.done=function(n,t){this.then(n,t)["catch"](ri)};i["yield"]=function(n){return this.then(function(){return n})};i.tap=function(n){return this.then(n)["yield"](this)};i.spread=function(n){return this.then(function(t){return ft(t,function(t){return n.apply(u,t)})})};i.always=function(n,t){return this.then(n,n,t)};a=Object.create||function(n){function t(){}return t.prototype=n,new t};c.prototype=a(i);c.prototype.inspect=function(){return et(this.value)};c.prototype._when=function(n,t,i){try{n(typeof i=="function"?i(this.value):this.value)}catch(u){n(new r(u))}};r.prototype=a(i);r.prototype.inspect=function(){return ot(this.value)};r.prototype._when=function(n,t,i,u){try{n(typeof u=="function"?u(this.value):this)}catch(f){n(new r(f))}};b.prototype=a(i);b.prototype._when=function(n,t,i,r,u){try{t(typeof u=="function"?u(this.value):this.value)}catch(f){t(f)}};var i,a,st,k,d,s,v,g,nt,tt,h,ht,it,ct,u;if(it=n,v=[],h=typeof console!="undefined"?console:t,typeof process=="object"&&process.nextTick)s=process.nextTick;else if(ct=typeof MutationObserver=="function"&&MutationObserver||typeof WebKitMutationObserver=="function"&&WebKitMutationObserver)s=function(n,t,i){var r=n.createElement("div");return new t(i).observe(r,{attributes:!0}),function(){r.setAttribute("x","x")}}(document,ct,lt);else try{s=it("vertx").runOnLoop||it("vertx").runOnContext}catch(ui){ht=setTimeout;s=function(n){ht(n,0)}}return g=Function.prototype,nt=g.call,d=g.bind?nt.bind(nt):function(n,t){return n.apply(t,k.call(arguments,2))},tt=[],k=tt.slice,st=tt.reduce||function(n){var i,u,r,f,t;if(t=0,i=Object(this),f=i.length>>>0,u=arguments,u.length<=1)for(;;){if(t in i){r=i[t++];break}if(++t>=f)throw new TypeError;}else r=u[1];for(;t<f;++t)t in i&&(r=n(r,i[t],t,i));return r},t}();CryptoJS=CryptoJS||function(n,t){var u={},f=u.lib={},i=f.Base=function(){function n(){}return{extend:function(t){n.prototype=this;var i=new n;return t&&i.mixIn(t),i.hasOwnProperty("init")||(i.init=function(){i.$super.init.apply(this,arguments)}),i.init.prototype=i,i.$super=this,i},create:function(){var n=this.extend();return n.init.apply(n,arguments),n},init:function(){},mixIn:function(n){for(var t in n)n.hasOwnProperty(t)&&(this[t]=n[t]);n.hasOwnProperty("toString")&&(this.toString=n.toString)},clone:function(){return this.init.prototype.extend(this)}}}(),r=f.WordArray=i.extend({init:function(n,i){n=this.words=n||[];this.sigBytes=i!=t?i:n.length*4},toString:function(n){return(n||h).stringify(this)},concat:function(n){var i=this.words,r=n.words,u=this.sigBytes,f=n.sigBytes,e,t;if(this.clamp(),u%4)for(t=0;t<f;t++)e=r[t>>>2]>>>24-t%4*8&255,i[u+t>>>2]|=e<<24-(u+t)%4*8;else if(r.length>65535)for(t=0;t<f;t+=4)i[u+t>>>2]=r[t>>>2];else i.push.apply(i,r);return this.sigBytes+=f,this},clamp:function(){var i=this.words,t=this.sigBytes;i[t>>>2]&=4294967295<<32-t%4*8;i.length=n.ceil(t/4)},clone:function(){var n=i.clone.call(this);return n.words=this.words.slice(0),n},random:function(t){for(var i=[],u=0;u<t;u+=4)i.push(n.random()*4294967296|0);return new r.init(i,t)}}),e=u.enc={},h=e.Hex={stringify:function(n){for(var r,u=n.words,f=n.sigBytes,i=[],t=0;t<f;t++)r=u[t>>>2]>>>24-t%4*8&255,i.push((r>>>4).toString(16)),i.push((r&15).toString(16));return i.join("")},parse:function(n){for(var i=n.length,u=[],t=0;t<i;t+=2)u[t>>>3]|=parseInt(n.substr(t,2),16)<<24-t%8*4;return new r.init(u,i/2)}},o=e.Latin1={stringify:function(n){for(var r,u=n.words,f=n.sigBytes,i=[],t=0;t<f;t++)r=u[t>>>2]>>>24-t%4*8&255,i.push(String.fromCharCode(r));return i.join("")},parse:function(n){for(var i=n.length,u=[],t=0;t<i;t++)u[t>>>2]|=(n.charCodeAt(t)&255)<<24-t%4*8;return new r.init(u,i)}},c=e.Utf8={stringify:function(n){try{return decodeURIComponent(escape(o.stringify(n)))}catch(t){throw new Error("Malformed UTF-8 data");}},parse:function(n){return o.parse(unescape(encodeURIComponent(n)))}},s=f.BufferedBlockAlgorithm=i.extend({reset:function(){this._data=new r.init;this._nDataBytes=0},_append:function(n){typeof n=="string"&&(n=c.parse(n));this._data.concat(n);this._nDataBytes+=n.sigBytes},_process:function(t){var e=this._data,h=e.words,c=e.sigBytes,o=this.blockSize,a=o*4,u=c/a,i,s,f,l;if(u=t?n.ceil(u):n.max((u|0)-this._minBufferSize,0),i=u*o,s=n.min(i*4,c),i){for(f=0;f<i;f+=o)this._doProcessBlock(h,f);l=h.splice(0,i);e.sigBytes-=s}return new r.init(l,s)},clone:function(){var n=i.clone.call(this);return n._data=this._data.clone(),n},_minBufferSize:0}),a=f.Hasher=s.extend({cfg:i.extend(),init:function(n){this.cfg=this.cfg.extend(n);this.reset()},reset:function(){s.reset.call(this);this._doReset()},update:function(n){return this._append(n),this._process(),this},finalize:function(n){n&&this._append(n);return this._doFinalize()},blockSize:16,_createHelper:function(n){return function(t,i){return new n.init(i).finalize(t)}},_createHmacHelper:function(n){return function(t,i){return new l.HMAC.init(n,i).finalize(t)}}}),l=u.algo={};return u}(Math),function(){var n=CryptoJS,t=n.lib,i=t.WordArray,r=n.enc,u=r.Base64={stringify:function(n){var u=n.words,e=n.sigBytes,o=this._map,i,t,r,f;for(n.clamp(),i=[],t=0;t<e;t+=3){var s=u[t>>>2]>>>24-t%4*8&255,h=u[t+1>>>2]>>>24-(t+1)%4*8&255,c=u[t+2>>>2]>>>24-(t+2)%4*8&255,l=s<<16|h<<8|c;for(r=0;r<4&&t+r*.75<e;r++)i.push(o.charAt(l>>>6*(3-r)&63))}if(f=o.charAt(64),f)while(i.length%4)i.push(f);return i.join("")},parse:function(n){var o=n.length,u=this._map,s=u.charAt(64),f,e,r,t,h,c;for(s&&(f=n.indexOf(s),f!=-1&&(o=f)),e=[],r=0,t=0;t<o;t++)t%4&&(h=u.indexOf(n.charAt(t-1))<<t%4*2,c=u.indexOf(n.charAt(t))>>>6-t%4*2,e[r>>>2]|=(h|c)<<24-r%4*8,r++);return i.create(e,r)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="}}(),function(){var n=CryptoJS,t=n.lib,i=t.Base,r=n.enc,u=r.Utf8,f=n.algo,e=f.HMAC=i.extend({init:function(n,t){var r,f,i;n=this._hasher=new n.init;typeof t=="string"&&(t=u.parse(t));r=n.blockSize;f=r*4;t.sigBytes>f&&(t=n.finalize(t));t.clamp();var e=this._oKey=t.clone(),o=this._iKey=t.clone(),s=e.words,h=o.words;for(i=0;i<r;i++)s[i]^=1549556828,h[i]^=909522486;e.sigBytes=o.sigBytes=f;this.reset()},reset:function(){var n=this._hasher;n.reset();n.update(this._iKey)},update:function(n){return this._hasher.update(n),this},finalize:function(n){var t=this._hasher,i=t.finalize(n);return t.reset(),t.finalize(this._oKey.clone().concat(i))}})}(),function(n){var i=CryptoJS,f=i.lib,s=f.WordArray,r=f.Hasher,h=i.algo,e=[],o=[],t,u;(function(){function u(t){for(var r=n.sqrt(t),i=2;i<=r;i++)if(!(t%i))return!1;return!0}function r(n){return(n-(n|0))*4294967296|0}for(var i=2,t=0;t<64;)u(i)&&(t<8&&(e[t]=r(n.pow(i,1/2))),o[t]=r(n.pow(i,1/3)),t++),i++})();t=[];u=h.SHA256=r.extend({_doReset:function(){this._hash=new s.init(e.slice(0))},_doProcessBlock:function(n,i){for(var r=this._hash.words,f=r[0],s=r[1],h=r[2],y=r[3],e=r[4],a=r[5],v=r[6],p=r[7],u=0;u<64;u++){if(u<16)t[u]=n[i+u]|0;else{var c=t[u-15],b=(c<<25|c>>>7)^(c<<14|c>>>18)^c>>>3,l=t[u-2],k=(l<<15|l>>>17)^(l<<13|l>>>19)^l>>>10;t[u]=b+t[u-7]+k+t[u-16]}var d=e&a^~e&v,g=f&s^f&h^s&h,nt=(f<<30|f>>>2)^(f<<19|f>>>13)^(f<<10|f>>>22),tt=(e<<26|e>>>6)^(e<<21|e>>>11)^(e<<7|e>>>25),w=p+tt+d+o[u]+t[u],it=nt+g;p=v;v=a;a=e;e=y+w|0;y=h;h=s;s=f;f=w+it|0}r[0]=r[0]+f|0;r[1]=r[1]+s|0;r[2]=r[2]+h|0;r[3]=r[3]+y|0;r[4]=r[4]+e|0;r[5]=r[5]+a|0;r[6]=r[6]+v|0;r[7]=r[7]+p|0},_doFinalize:function(){var r=this._data,t=r.words,u=this._nDataBytes*8,i=r.sigBytes*8;return t[i>>>5]|=128<<24-i%32,t[(i+64>>>9<<4)+14]=n.floor(u/4294967296),t[(i+64>>>9<<4)+15]=u,r.sigBytes=t.length*4,this._process(),this._hash},clone:function(){var n=r.clone.call(this);return n._hash=this._hash.clone(),n}});i.SHA256=r._createHelper(u);i.HmacSHA256=r._createHmacHelper(u)}(Math),function(){var n=CryptoJS,i=n.lib,r=i.Base,u=i.WordArray,t=n.algo,f=t.SHA1,e=t.HMAC,o=t.PBKDF2=r.extend({cfg:r.extend({keySize:4,hasher:f,iterations:1}),init:function(n){this.cfg=this.cfg.extend(n)},compute:function(n,t){for(var s=this.cfg,r=e.create(s.hasher,n),f=u.create(),l=u.create([1]),p=f.words,w=l.words,a=s.keySize,b=s.iterations,o,c,y,i;p.length<a;){o=r.update(t).finalize(l);r.reset();var v=o.words,k=v.length,h=o;for(c=1;c<b;c++)for(h=r.finalize(h),r.reset(),y=h.words,i=0;i<k;i++)v[i]^=y[i];f.concat(o);w[0]++}return f.sigBytes=a*4,f}});n.PBKDF2=function(n,t,i){return o.create(i).compute(n,t)}}();
/** @license MIT License (c) 2011-2013 Copyright Tavendo GmbH. */
AUTOBAHNJS_VERSION="0.8.2.1";global=this,function(n,t){n.ab=t(n,n.when)}(global,function(n,t){"use strict";var i={};return i._version=AUTOBAHNJS_VERSION,function(){Array.prototype.indexOf||(Array.prototype.indexOf=function(n){var u,r,t,i;if(this===null)throw new TypeError;if((u=new Object(this),r=u.length>>>0,r===0)||(t=0,arguments.length>0&&(t=Number(arguments[1]),t!==t?t=0:t!==0&&t!==Infinity&&t!==-Infinity&&(t=(t>0||-1)*Math.floor(Math.abs(t)))),t>=r))return-1;for(i=t>=0?t:Math.max(r-Math.abs(t),0);i<r;i++)if(i in u&&u[i]===n)return i;return-1});Array.prototype.forEach||(Array.prototype.forEach=function(n,t){var u,i,r,f,e;if(this===null)throw new TypeError(" this is null or not defined");if(r=new Object(this),f=r.length>>>0,{}.toString.call(n)!=="[object Function]")throw new TypeError(n+" is not a function");for(t&&(u=t),i=0;i<f;)i in r&&(e=r[i],n.call(u,e,i,r)),i++})}(),i._sliceUserAgent=function(n,t,i){var s=[],r=navigator.userAgent,h=r.indexOf(n),f=r.indexOf(t,h),e,o,u;for(f<0&&(f=r.length),e=r.slice(h,f).split(i),o=e[1].split("."),u=0;u<o.length;++u)s.push(parseInt(o[u],10));return{name:e[0],version:s}},i.getBrowser=function(){var n=navigator.userAgent;return n.indexOf("Chrome")>-1?i._sliceUserAgent("Chrome"," ","/"):n.indexOf("Safari")>-1?i._sliceUserAgent("Safari"," ","/"):n.indexOf("Firefox")>-1?i._sliceUserAgent("Firefox"," ","/"):n.indexOf("MSIE")>-1?i._sliceUserAgent("MSIE",";"," "):null},i.getServerUrl=function(t,i){if(n.location.protocol==="file:")return i?i:"ws://127.0.0.1/ws";var r=n.location.protocol==="https:"?"wss://":"ws://",u=n.location.port!==""?":"+n.location.port:"",f=t?t:"ws";return r+n.location.hostname+u+"/"+f},i.browserNotSupportedMessage="Browser does not support WebSockets (RFC6455)",i.deriveKey=function(n,t){if(t&&t.salt){var i=t.salt,r=t.keylen||32,u=t.iterations||1e4,f=CryptoJS.PBKDF2(n,i,{keySize:r/4,iterations:u,hasher:CryptoJS.algo.SHA256});return f.toString(CryptoJS.enc.Base64)}return n},i._idchars="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",i._idlen=16,i._subprotocol="wamp",i._newid=function(){for(var n="",t=0;t<i._idlen;t+=1)n+=i._idchars.charAt(Math.floor(Math.random()*i._idchars.length));return n},i._newidFast=function(){return Math.random().toString(36)},i.log=function(){if(arguments.length>1){console.group("Log Item");for(var n=0;n<arguments.length;n+=1)console.log(arguments[n]);console.groupEnd()}else console.log(arguments[0])},i._debugrpc=!1,i._debugpubsub=!1,i._debugws=!1,i._debugconnect=!1,i.debug=function(t,r,u){if("console"in n)i._debugrpc=t,i._debugpubsub=t,i._debugws=r,i._debugconnect=u;else throw"browser does not support console object";},i.version=function(){return i._version},i.PrefixMap=function(){var n=this;n._index={};n._rindex={}},i.PrefixMap.prototype.get=function(n){var t=this;return t._index[n]},i.PrefixMap.prototype.set=function(n,t){var i=this;i._index[n]=t;i._rindex[t]=n},i.PrefixMap.prototype.setDefault=function(n){var t=this;t._index[""]=n;t._rindex[n]=""},i.PrefixMap.prototype.remove=function(n){var t=this,i=t._index[n];i&&(delete t._index[n],delete t._rindex[i])},i.PrefixMap.prototype.resolve=function(n,t){var u=this,i=n.indexOf(":"),r;return i>=0&&(r=n.substring(0,i),u._index[r])?u._index[r]+n.substring(i+1):t===!0?n:null},i.PrefixMap.prototype.shrink=function(n,t){for(var u,r,f=this,i=n.length;i>0;i-=1)if(u=n.substring(0,i),r=f._rindex[u],r)return r+":"+n.substring(i);return t===!0?n:null},i._MESSAGE_TYPEID_WELCOME=0,i._MESSAGE_TYPEID_PREFIX=1,i._MESSAGE_TYPEID_CALL=2,i._MESSAGE_TYPEID_CALL_RESULT=3,i._MESSAGE_TYPEID_CALL_ERROR=4,i._MESSAGE_TYPEID_SUBSCRIBE=5,i._MESSAGE_TYPEID_UNSUBSCRIBE=6,i._MESSAGE_TYPEID_PUBLISH=7,i._MESSAGE_TYPEID_EVENT=8,i.CONNECTION_CLOSED=0,i.CONNECTION_LOST=1,i.CONNECTION_RETRIES_EXCEEDED=2,i.CONNECTION_UNREACHABLE=3,i.CONNECTION_UNSUPPORTED=4,i.CONNECTION_UNREACHABLE_SCHEDULED_RECONNECT=5,i.CONNECTION_LOST_SCHEDULED_RECONNECT=6,i.Deferred=t.defer,i._construct=function(t,i){return"WebSocket"in n?i?new WebSocket(t,i):new WebSocket(t):"MozWebSocket"in n?i?new MozWebSocket(t,i):new MozWebSocket(t):null},i.Session=function(n,t,r,u){var f=this;if(f._wsuri=n,f._options=u,f._websocket_onopen=t,f._websocket_onclose=r,f._websocket=null,f._websocket_connected=!1,f._session_id=null,f._wamp_version=null,f._server=null,f._calls={},f._subscriptions={},f._prefixes=new i.PrefixMap,f._txcnt=0,f._rxcnt=0,f._websocket=f._options&&f._options.skipSubprotocolAnnounce?i._construct(f._wsuri):i._construct(f._wsuri,[i._subprotocol]),!f._websocket){if(r!==undefined){r(i.CONNECTION_UNSUPPORTED);return}throw i.browserNotSupportedMessage;}f._websocket.onmessage=function(n){var t,r,h,e,c,s,v,y,p,w;if(i._debugws&&(f._rxcnt+=1,console.group("WS Receive"),console.info(f._wsuri+"  ["+f._session_id+"]"),console.log(f._rxcnt),console.log(n.data),console.groupEnd()),t=JSON.parse(n.data),t[1]in f._calls){if(t[0]===i._MESSAGE_TYPEID_CALL_RESULT){if(r=f._calls[t[1]],h=t[2],i._debugrpc&&r._ab_callobj!==undefined){for(console.group("WAMP Call",r._ab_callobj[2]),console.timeEnd(r._ab_tid),console.group("Arguments"),e=3;e<r._ab_callobj.length;e+=1)if(c=r._ab_callobj[e],c!==undefined)console.log(c);else break;console.groupEnd();console.group("Result");console.log(h);console.groupEnd();console.groupEnd()}r.resolve(h)}else if(t[0]===i._MESSAGE_TYPEID_CALL_ERROR){var u=f._calls[t[1]],l=t[2],a=t[3],o=t[4];if(i._debugrpc&&u._ab_callobj!==undefined){for(console.group("WAMP Call",u._ab_callobj[2]),console.timeEnd(u._ab_tid),console.group("Arguments"),s=3;s<u._ab_callobj.length;s+=1)if(v=u._ab_callobj[s],v!==undefined)console.log(v);else break;console.groupEnd();console.group("Error");console.log(l);console.log(a);o!==undefined&&console.log(o);console.groupEnd();console.groupEnd()}o!==undefined?u.reject({uri:l,desc:a,detail:o}):u.reject({uri:l,desc:a})}delete f._calls[t[1]]}else if(t[0]===i._MESSAGE_TYPEID_EVENT)y=f._prefixes.resolve(t[1],!0),y in f._subscriptions&&(p=t[1],w=t[2],i._debugpubsub&&(console.group("WAMP Event"),console.info(f._wsuri+"  ["+f._session_id+"]"),console.log(p),console.log(w),console.groupEnd()),f._subscriptions[y].forEach(function(n){n(p,w)}));else if(t[0]===i._MESSAGE_TYPEID_WELCOME)if(f._session_id===null)f._session_id=t[1],f._wamp_version=t[2],f._server=t[3],(i._debugrpc||i._debugpubsub)&&(console.group("WAMP Welcome"),console.info(f._wsuri+"  ["+f._session_id+"]"),console.log(f._wamp_version),console.log(f._server),console.groupEnd()),f._websocket_onopen!==null&&f._websocket_onopen();else throw"protocol error (welcome message received more than once)";};f._websocket.onopen=function(){if(f._websocket.protocol!==i._subprotocol)if(typeof f._websocket.protocol=="undefined")i._debugws&&(console.group("WS Warning"),console.info(f._wsuri),console.log("WebSocket object has no protocol attribute: WAMP subprotocol check skipped!"),console.groupEnd());else if(f._options&&f._options.skipSubprotocolCheck)i._debugws&&(console.group("WS Warning"),console.info(f._wsuri),console.log("Server does not speak WAMP, but subprotocol check disabled by option!"),console.log(f._websocket.protocol),console.groupEnd());else{f._websocket.close(1e3,"server does not speak WAMP");throw"server does not speak WAMP (but '"+f._websocket.protocol+"' !)";}i._debugws&&(console.group("WAMP Connect"),console.info(f._wsuri),console.log(f._websocket.protocol),console.groupEnd());f._websocket_connected=!0};f._websocket.onerror=function(){};f._websocket.onclose=function(n){i._debugws&&(f._websocket_connected?console.log("Autobahn connection to "+f._wsuri+" lost (code "+n.code+", reason '"+n.reason+"', wasClean "+n.wasClean+")."):console.log("Autobahn could not connect to "+f._wsuri+" (code "+n.code+", reason '"+n.reason+"', wasClean "+n.wasClean+")."));f._websocket_onclose!==undefined&&(f._websocket_connected?n.wasClean?f._websocket_onclose(i.CONNECTION_CLOSED,"WS-"+n.code+": "+n.reason):f._websocket_onclose(i.CONNECTION_LOST):f._websocket_onclose(i.CONNECTION_UNREACHABLE));f._websocket_connected=!1;f._wsuri=null;f._websocket_onopen=null;f._websocket_onclose=null;f._websocket=null};f.log=function(){f._options&&"sessionIdent"in f._options?console.group("WAMP Session '"+f._options.sessionIdent+"' ["+f._session_id+"]"):console.group("WAMP Session ["+f._session_id+"]");for(var n=0;n<arguments.length;++n)console.log(arguments[n]);console.groupEnd()}},i.Session.prototype._send=function(t){var r=this,u;if(!r._websocket_connected)throw"Autobahn not connected";switch(!0){case n.Prototype&&typeof top.root.__prototype_deleted=="undefined":case typeof t.toJSON=="function":u=t.toJSON();break;default:u=JSON.stringify(t)}r._websocket.send(u);r._txcnt+=1;i._debugws&&(console.group("WS Send"),console.info(r._wsuri+"  ["+r._session_id+"]"),console.log(r._txcnt),console.log(u),console.groupEnd())},i.Session.prototype.close=function(){var n=this;n._websocket_connected&&n._websocket.close()},i.Session.prototype.sessionid=function(){var n=this;return n._session_id},i.Session.prototype.wsuri=function(){var n=this;return n._wsuri},i.Session.prototype.shrink=function(n,t){var i=this;return t===undefined&&(t=!0),i._prefixes.shrink(n,t)},i.Session.prototype.resolve=function(n,t){var i=this;return t===undefined&&(t=!0),i._prefixes.resolve(n,t)},i.Session.prototype.prefix=function(n,t){var r=this,u;r._prefixes.set(n,t);(i._debugrpc||i._debugpubsub)&&(console.group("WAMP Prefix"),console.info(r._wsuri+"  ["+r._session_id+"]"),console.log(n),console.log(t),console.groupEnd());u=[i._MESSAGE_TYPEID_PREFIX,n,t];r._send(u)},i.Session.prototype.call=function(){for(var t=this,n=new i.Deferred,r,e,u,f;;)if(r=i._newidFast(),!(r in t._calls))break;for(t._calls[r]=n,e=t._prefixes.shrink(arguments[0],!0),u=[i._MESSAGE_TYPEID_CALL,r,e],f=1;f<arguments.length;f+=1)u.push(arguments[f]);return t._send(u),i._debugrpc&&(n._ab_callobj=u,n._ab_tid=t._wsuri+"  ["+t._session_id+"]["+r+"]",console.time(n._ab_tid),console.info()),n.promise.then?n.promise:n},i.Session.prototype.subscribe=function(n,t){var r=this,u=r._prefixes.resolve(n,!0),f,e;if(u in r._subscriptions||(i._debugpubsub&&(console.group("WAMP Subscribe"),console.info(r._wsuri+"  ["+r._session_id+"]"),console.log(n),console.log(t),console.groupEnd()),f=[i._MESSAGE_TYPEID_SUBSCRIBE,n],r._send(f),r._subscriptions[u]=[]),e=r._subscriptions[u].indexOf(t),e===-1)r._subscriptions[u].push(t);else throw"callback "+t+" already subscribed for topic "+u;},i.Session.prototype.unsubscribe=function(n,t){var r=this,u=r._prefixes.resolve(n,!0),f,e,o;if(u in r._subscriptions){if(t!==undefined)if(e=r._subscriptions[u].indexOf(t),e!==-1)f=t,r._subscriptions[u].splice(e,1);else throw"no callback "+t+" subscribed on topic "+u;else f=r._subscriptions[u].slice(),r._subscriptions[u]=[];r._subscriptions[u].length===0&&(delete r._subscriptions[u],i._debugpubsub&&(console.group("WAMP Unsubscribe"),console.info(r._wsuri+"  ["+r._session_id+"]"),console.log(n),console.log(f),console.groupEnd()),o=[i._MESSAGE_TYPEID_UNSUBSCRIBE,n],r._send(o))}else throw"not subscribed to topic "+u;},i.Session.prototype.publish=function(){var o=this,t=arguments[0],r=arguments[1],f=null,n=null,e=null,u=null;if(arguments.length>3){if(!(arguments[2]instanceof Array))throw"invalid argument type(s)";if(!(arguments[3]instanceof Array))throw"invalid argument type(s)";n=arguments[2];e=arguments[3];u=[i._MESSAGE_TYPEID_PUBLISH,t,r,n,e]}else if(arguments.length>2)if(typeof arguments[2]=="boolean")f=arguments[2],u=[i._MESSAGE_TYPEID_PUBLISH,t,r,f];else if(arguments[2]instanceof Array)n=arguments[2],u=[i._MESSAGE_TYPEID_PUBLISH,t,r,n];else throw"invalid argument type(s)";else u=[i._MESSAGE_TYPEID_PUBLISH,t,r];i._debugpubsub&&(console.group("WAMP Publish"),console.info(o._wsuri+"  ["+o._session_id+"]"),console.log(t),console.log(r),f!==null?console.log(f):n!==null&&(console.log(n),e!==null&&console.log(e)),console.groupEnd());o._send(u)},i.Session.prototype.authreq=function(n,t){return this.call("http://api.wamp.ws/procedure#authreq",n,t)},i.Session.prototype.authsign=function(n,t){return t||(t=""),CryptoJS.HmacSHA256(n,t).toString(CryptoJS.enc.Base64)},i.Session.prototype.auth=function(n){return this.call("http://api.wamp.ws/procedure#auth",n)},i._connect=function(t){var r=new i.Session(t.wsuri,function(){t.connects+=1;t.retryCount=0;t.onConnect(r)},function(r,u){var f=null;switch(r){case i.CONNECTION_CLOSED:t.onHangup(r,"Connection was closed properly ["+u+"]");break;case i.CONNECTION_UNSUPPORTED:t.onHangup(r,"Browser does not support WebSocket.");break;case i.CONNECTION_UNREACHABLE:if(t.retryCount+=1,t.connects===0)t.onHangup(r,"Connection could not be established.");else if(t.retryCount<=t.options.maxRetries)if(f=t.onHangup(i.CONNECTION_UNREACHABLE_SCHEDULED_RECONNECT,"Connection unreachable - scheduled reconnect to occur in "+t.options.retryDelay/1e3+" second(s) - attempt "+t.retryCount+" of "+t.options.maxRetries+".",{delay:t.options.retryDelay,retries:t.retryCount,maxretries:t.options.maxRetries}),f){i._debugconnect&&console.log("Connection unreachable - retrying stopped by app");t.onHangup(i.CONNECTION_RETRIES_EXCEEDED,"Number of connection retries exceeded.")}else i._debugconnect&&console.log("Connection unreachable - retrying ("+t.retryCount+") .."),n.setTimeout(function(){i._connect(t)},t.options.retryDelay);else t.onHangup(i.CONNECTION_RETRIES_EXCEEDED,"Number of connection retries exceeded.");break;case i.CONNECTION_LOST:if(t.retryCount+=1,t.retryCount<=t.options.maxRetries)if(f=t.onHangup(i.CONNECTION_LOST_SCHEDULED_RECONNECT,"Connection lost - scheduled "+t.retryCount+"th reconnect to occur in "+t.options.retryDelay/1e3+" second(s).",{delay:t.options.retryDelay,retries:t.retryCount,maxretries:t.options.maxRetries}),f){i._debugconnect&&console.log("Connection lost - retrying stopped by app");t.onHangup(i.CONNECTION_RETRIES_EXCEEDED,"Connection lost.")}else i._debugconnect&&console.log("Connection lost - retrying ("+t.retryCount+") .."),n.setTimeout(function(){i._connect(t)},t.options.retryDelay);else t.onHangup(i.CONNECTION_RETRIES_EXCEEDED,"Connection lost.");break;default:throw"unhandled close code in ab._connect";}},t.options)},i.connect=function(n,t,r,u){var f={};if(f.wsuri=n,f.options=u?u:{},f.options.retryDelay===undefined&&(f.options.retryDelay=5e3),f.options.maxRetries===undefined&&(f.options.maxRetries=10),f.options.skipSubprotocolCheck===undefined&&(f.options.skipSubprotocolCheck=!1),f.options.skipSubprotocolAnnounce===undefined&&(f.options.skipSubprotocolAnnounce=!1),t)f.onConnect=t;else throw"onConnect handler required!";f.onHangup=r?r:function(n,t,r){i._debugconnect&&console.log(n,t,r)};f.connects=0;f.retryCount=0;i._connect(f)},i.launch=function(n,t,r){i.connect(n.wsuri,function(r){n.appkey&&n.appkey!==""?r.authreq(n.appkey,n.appextra).then(function(u){var f=null,e;typeof n.appsecret=="function"?f=n.appsecret(u):(e=i.deriveKey(n.appsecret,JSON.parse(u).authextra),f=r.authsign(u,e));r.auth(f).then(function(){t?t(r):i._debugconnect&&r.log("Session opened.")},r.log)},r.log):r.authreq().then(function(){r.auth().then(function(){t?t(r):i._debugconnect&&r.log("Session opened.")},r.log)},r.log)},function(n,t,u){r?r(n,t,u):i._debugconnect&&i.log("Session closed.",n,t,u)},n.sessionConfig)},i});ab._UA_FIREFOX=new RegExp(".*Firefox/([0-9+]*).*");ab._UA_CHROME=new RegExp(".*Chrome/([0-9+]*).*");ab._UA_CHROMEFRAME=new RegExp(".*chromeframe/([0-9]*).*");ab._UA_WEBKIT=new RegExp(".*AppleWebKit/([0-9+.]*)w*.*");ab._UA_WEBOS=new RegExp(".*webOS/([0-9+.]*)w*.*");ab._matchRegex=function(n,t){var i=t.exec(n);return i?i[1]:i};ab.lookupWsSupport=function(){var n=navigator.userAgent,t;return n.indexOf("MSIE")>-1?n.indexOf("MSIE 10")>-1?[!0,!0,!0]:n.indexOf("chromeframe")>-1?(t=parseInt(ab._matchRegex(n,ab._UA_CHROMEFRAME)),t>=14)?[!0,!1,!0]:[!1,!1,!1]:n.indexOf("MSIE 8")>-1||n.indexOf("MSIE 9")>-1?[!0,!0,!0]:[!1,!1,!1]:n.indexOf("Firefox")>-1?(t=parseInt(ab._matchRegex(n,ab._UA_FIREFOX)),t)?t>=7?[!0,!1,!0]:t>=3?[!0,!0,!0]:[!1,!1,!0]:[!1,!1,!0]:n.indexOf("Safari")>-1&&n.indexOf("Chrome")==-1?(t=ab._matchRegex(n,ab._UA_WEBKIT),t)?n.indexOf("Windows")>-1&&t=="534+"?[!0,!1,!0]:n.indexOf("Macintosh")>-1&&(t=t.replace("+","").split("."),parseInt(t[0])==535&&parseInt(t[1])>=24||parseInt(t[0])>535)?[!0,!1,!0]:n.indexOf("webOS")>-1?(t=ab._matchRegex(n,ab._UA_WEBOS).split("."),parseInt(t[0])==2)?[!1,!0,!0]:[!1,!1,!1]:[!0,!0,!0]:[!1,!1,!1]:n.indexOf("Chrome")>-1?(t=parseInt(ab._matchRegex(n,ab._UA_CHROME)),t)?t>=14?[!0,!1,!0]:t>=4?[!0,!0,!0]:[!1,!1,!0]:[!1,!1,!1]:n.indexOf("Android")>-1?n.indexOf("Firefox")>-1?[!0,!1,!0]:n.indexOf("CrMo")>-1?[!0,!1,!0]:n.indexOf("Opera")>-1?[!1,!1,!0]:n.indexOf("CrMo")>-1?[!0,!0,!0]:[!1,!1,!1]:n.indexOf("iPhone")>-1||n.indexOf("iPad")>-1||n.indexOf("iPod")>-1?[!1,!1,!0]:[!1,!1,!1]};`;
window.eval(ux);
class Hy extends Ai {
  constructor(t, e) {
    super(t, e), this._modelBounding = new yn(), this._selectionBounding = new yn(), this._pivot = _.zero(), this._hitRayOrigin = null, this._hitRayDirection = null, this._hitRayAperture = 0, this._hitRaySelectionOnly = !1, this._hitRaySelectionItem = null, this._client = {
      onConnect: () => {
        if (this._connexion === null)
          return;
        const i = this._viewer.getViewElement();
        i.addEventListener("focusin", () => {
          this._connexion !== null && this._connexion.update3dcontroller({ focus: !0 });
        }), i.addEventListener("focusout", () => {
          this._connexion !== null && this._connexion.update3dcontroller({ focus: !1 });
        }), this._connexion.create3dmouse(i, "WebViewer");
      },
      on3dmouseCreated: () => {
        this._3dMouseInitialized = !0, this._connexion !== null && (this._updateModelBounding(), this._connexion.update3dcontroller({ focus: !0 }));
      },
      onDisconnect: (i) => {
        console.log(`3Dconnexion NL-Server disconnected ${i}`);
      },
      getCoordinateSystem: () => [
        1,
        0,
        0,
        0,
        0,
        0,
        -1,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        1
      ],
      getConstructionPlane: () => {
        const i = this._viewer.model.getViewAxes().upVector;
        return [i.x, i.y, i.z, 0];
      },
      getFov: () => {
        const i = this._view.getCamera(), n = i.getHeight() / i.getWidth(), r = i.getWidth() / (2 * _.subtract(i.getTarget(), i.getPosition()).length());
        return 2 * Math.atan(r / n);
      },
      setFov: (i) => {
        const n = this._view.getCamera(), r = Math.tan(i / 2), l = _.subtract(n.getTarget(), n.getPosition()).length() * r, h = n.getHeight() / n.getWidth();
        n.setWidth(l), n.setHeight(l * h), this._view.setCamera(n);
      },
      getPerspective: () => this._view.getCamera().getProjection() === ri.Perspective,
      getViewExtents: () => {
        const i = this._view.getCamera(), n = i.getPosition(), r = i.getTarget(), o = i.getWidth() / 2, l = i.getHeight() / 2, h = _.subtract(n, r), u = i.getNearLimit(), d = h.z / u;
        return [-o, -l, -d, o, l, -u];
      },
      setViewExtents: (i) => {
        const n = new K(i[0], i[4]), r = new K(i[3], i[4]), o = new K(i[3], i[1]), l = K.distance(n, r), h = K.distance(r, o), u = this._view.getCamera();
        u.setWidth(l), u.setHeight(h), this._view.setCamera(u);
      },
      getViewFrustum: () => {
        const i = this._view.getCamera(), n = i.getHeight(), r = _.subtract(i.getTarget(), i.getPosition()).length(), o = 2 * Math.atan(n / (2 * r)), l = this._view.getCanvasSize().x / this._view.getCanvasSize().y, h = i.getNearLimit(), u = Math.tan(o * 0.5) * h, d = -u, g = l * d, y = l * u, m = _.distance(i.getPosition(), i.getTarget()) / h;
        return [g, y, d, u, h, m];
      },
      getViewMatrix: () => {
        const i = this._view.getCamera(), n = i.getUp().normalize(), r = _.subtract(i.getTarget(), i.getPosition()).normalize(), o = _.cross(r, n).normalize(), l = i.getPosition();
        return [
          o.x,
          o.y,
          o.z,
          0,
          n.x,
          n.y,
          n.z,
          0,
          -r.x,
          -r.y,
          -r.z,
          0,
          l.x,
          l.y,
          l.z,
          1
        ];
      },
      setViewMatrix: (i) => {
        const n = this._view.getCamera(), r = new _(i[4], i[5], i[6]), o = new _(-i[8], -i[9], -i[10]), l = new _(i[12], i[13], i[14]), h = _.subtract(n.getPosition(), n.getTarget()).length(), u = l.copy().add(o.copy().scale(h));
        n.setTarget(u), n.setPosition(l), n.setUp(r), this._view.setCamera(n);
      },
      getViewRotatable: () => !this._viewer.model.isDrawing(),
      getFrontView: () => [
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        1,
        0,
        0,
        0,
        0,
        0,
        0,
        1
      ],
      getPivotPosition: () => [this._pivot.x, this._pivot.y, this._pivot.z],
      setPivotPosition: (i) => {
        this._pivot = _.createFromArray(i);
      },
      setPivotVisible: (i) => {
        if (this._pivotMarkup.enable(i), i) {
          const n = this._view.projectPoint(this._pivot), r = new K(n.x, n.y);
          this._pivotMarkup.setPosition(r);
        }
        this._viewer.markupManager.refreshMarkup(this._view);
      },
      getPointerPosition: () => {
        const i = this._view.unprojectPoint(this._ptCurrent, 0);
        return i === null ? [0, 0, 0] : [i.x, i.y, i.z];
      },
      getModelExtents: () => [
        this._modelBounding.min.x,
        this._modelBounding.min.y,
        this._modelBounding.min.z,
        this._modelBounding.max.x,
        this._modelBounding.max.y,
        this._modelBounding.max.z
      ],
      getFloorPlane: () => {
        const i = this._viewer.model.getViewAxes().upVector, n = this._modelBounding.min, r = new _(
          n.x * i.x,
          n.y * i.y,
          n.z * i.z
        );
        return [i.x, i.y, i.z, -r.length()];
      },
      getUnitsToMeters: () => 1e-3,
      setTransaction: (i) => {
        i === 0 && this._viewer.redraw();
      },
      setLookFrom: (i) => {
        this._hitRayOrigin = _.createFromArray(i), this._updateHitTest();
      },
      setLookDirection: (i) => {
        this._hitRayDirection = _.createFromArray(i);
      },
      setLookAperture: (i) => {
        this._hitRayAperture = i;
      },
      setSelectionOnly: (i) => {
        this._hitRaySelectionOnly = i, this._updateHitTest();
      },
      getLookAt: () => {
        if (this._hitRaySelectionItem === null)
          return null;
        const i = this._hitRaySelectionItem.getPosition();
        return i === null ? null : [i.x, i.y, i.z];
      },
      getSelectionEmpty: () => this._viewer.selectionManager.getFirst() === null,
      getSelectionExtents: () => [
        this._selectionBounding.min.x,
        this._selectionBounding.min.y,
        this._selectionBounding.min.z,
        this._selectionBounding.max.x,
        this._selectionBounding.max.y,
        this._selectionBounding.max.z
      ]
    }, this._connexion = null, this._3dMouseInitialized = !1, this._pivotMarkup = new Og(t, e), this._viewer.setCallbacks({
      modelStructureReady: () => {
        this._updateModelBounding();
      },
      subtreeLoaded: () => {
        this._updateModelBounding();
      },
      subtreeDeleted: () => {
        this._updateModelBounding();
      },
      selectionArray: () => {
        this._updateSelectionBounding();
      },
      frameDrawn: () => {
        const i = this._view.projectPoint(this._pivot), n = new K(i.x, i.y);
        this._pivotMarkup.setPosition(n), this._pivotMarkup.draw();
      }
    });
  }
  async _updateModelBounding() {
    if (this._connexion === null || !this._3dMouseInitialized)
      return;
    this._modelBounding = await this._viewer.model.getModelBounding(!0, !0);
    const t = this._modelBounding.center();
    this._pivot = t, this._connexion.update3dcontroller({
      model: {
        extents: [
          this._modelBounding.min.x,
          this._modelBounding.min.y,
          this._modelBounding.min.z,
          this._modelBounding.max.x,
          this._modelBounding.max.y,
          this._modelBounding.max.z
        ]
      }
    });
  }
  async _updateSelectionBounding() {
    if (this._connexion === null || !this._3dMouseInitialized)
      return;
    const t = this._viewer.selectionManager.getResults().map((e) => e.getNodeId());
    if (t.length === 0) {
      this._selectionBounding = new yn();
      return;
    }
    this._selectionBounding = await this._viewer.model.getNodesBounding(t);
  }
  async _updateHitTest() {
    this._hitRayAperture;
    const t = this._viewer;
    if (this._hitRayOrigin === null || this._hitRayDirection === null)
      return;
    const e = new wr(this._hitRayOrigin, this._hitRayDirection), i = new Si(), n = await this._view.pickFromRay(e, i), r = n.getNodeId();
    if (r === vg) {
      this._hitRaySelectionItem = null;
      return;
    }
    if (this._hitRaySelectionOnly && !t.selectionManager.isNodeSelected(r)) {
      this._hitRaySelectionItem = null;
      return;
    }
    this._hitRaySelectionItem = n;
  }
  /**
   * Connect to the space mouse. To be successful, this method
   * should be called in the sceneReady callback. If you want to
   * connect at a later time, the canvas where the mouse is
   * to be used must have focus.
   *
   * Note: If this is called but the 3d connexion software is not running,
   * a connection error will be shown in the console.
   */
  connect() {
    this._connexion = new _3Dconnexion(this._client), this._connexion.connect();
  }
}
const s1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AreaSelectionOperator: Ty,
  AxisTriadOperator: Ny,
  ButtonModifier: Jf,
  Camera: rx,
  CuttingPlaneOperator: Oy,
  CuttingPlaneOperatorContext: Dy,
  FloorplanOperator: Ry,
  HandleOperator: Ly,
  Markup: cx,
  Measure: ox,
  NavCubeOperator: Fy,
  NoteOperator: By,
  OperatorBase: Ai,
  RayDrillSelectionOperator: Vy,
  Redline: hx,
  SelectionOperator: zy,
  SelectionRectangleMarkup: Dg,
  SpaceMouseOperator: Hy
}, Symbol.toStringTag, { value: "Module" }));
var Yf = /* @__PURE__ */ ((s) => (s[s.Cutoff = 476837158203125e-21] = "Cutoff", s))(Yf || {});
class Kp {
  constructor() {
    this.plane = new ln(), this.referenceGeometry = null, this.meshId = null, this.instanceNodeId = null, this.color = vt.createFromFloat(0.65, 0.65, 0.65), this.lineColor = vt.black(), this.opacity = 0.35, this.matrix = new mt();
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return {
      plane: {
        normal: this.plane.normal,
        d: this.plane.d
      },
      referenceGeometry: this.referenceGeometry
    };
  }
  fromJson(t) {
    const e = Yc(t), i = e.plane;
    this.plane = new ln();
    const n = i.normal;
    this.plane.normal = new _(n.x, n.y, n.z), this.plane.d = i.d;
    const r = e.referenceGeometry;
    if (Array.isArray(r))
      for (let o = 0; o < r.length; ++o)
        r[o] = _.fromJson(r[o]);
    this.referenceGeometry = r;
  }
  getMatrix() {
    return this.matrix.copy();
  }
  setMatrix(t) {
    this.matrix = t.copy();
  }
  setReferenceGeometry(t) {
    if (t) {
      this.referenceGeometry = [];
      for (const e of t)
        this.referenceGeometry.push(e.copy());
    } else
      this.referenceGeometry = null;
  }
  getReferenceGeometry() {
    if (this.referenceGeometry) {
      const t = [];
      for (const e of this.referenceGeometry)
        t.push(e.copy());
      return t;
    } else
      return null;
  }
  createMeshData() {
    const t = this.referenceGeometry;
    if (t === null)
      return null;
    const e = new Cs(), i = [], n = [];
    i.push(t[0].x, t[0].y, t[0].z), i.push(t[1].x, t[1].y, t[1].z), i.push(t[3].x, t[3].y, t[3].z), i.push(t[1].x, t[1].y, t[1].z), i.push(t[2].x, t[2].y, t[2].z), i.push(t[3].x, t[3].y, t[3].z);
    const o = ln.createFromPoints(t[0], t[1], t[2]).normal;
    for (let l = 0; l < 6; l++)
      n.push(o.x, o.y, o.z);
    return e.addFaces(i, n), e.addPolyline([t[0].x, t[0].y, t[0].z, t[1].x, t[1].y, t[1].z]), e.addPolyline([t[1].x, t[1].y, t[1].z, t[2].x, t[2].y, t[2].z]), e.addPolyline([t[2].x, t[2].y, t[2].z, t[3].x, t[3].y, t[3].z]), e.addPolyline([t[3].x, t[3].y, t[3].z, t[0].x, t[0].y, t[0].z]), e;
  }
}
class dx {
  /** @hidden */
  constructor(t, e, i, n, r) {
    this._cuttingPlanes = [], this._isActive = !1, this._viewer = t, this._model = e, this._callbackManager = i, this._cuttingManager = n, this._engine = r;
  }
  /**
   * Adds a plane to the cutting section.
   * @param plane The plane to be used for cutting.
   * @param referenceGeometry An optional list of four points representing a quad to be used as reference geometry for the cutting plane. Pass null to use no reference geometry for this cutting plane.
   */
  async addPlane(t, e = null) {
    const i = this._engine.getCuttingSectionLimits();
    if (this._cuttingPlanes.length >= i.maxCuttingPlanesPerSection)
      return !1;
    const n = new Kp();
    return n.plane = t.copy(), n.setReferenceGeometry(e), this._cuttingPlanes.push(n), this._isActive && (await this._resetCuttingPlane(n), await this._engine.updateCuttingSection(this)), !0;
  }
  /**
   * Sets a plane currently in the cutting section at a given index.
   * @param index The index of the cutting plane to replace.
   * @param plane The plane to be used for cutting.
   * @param referenceGeometry a list of four points representing a quad to be used as reference geometry for the cutting plane. Pass null to use no reference geometry for this cutting plane.
   */
  async setPlane(t, e, i = null) {
    const n = this._cuttingPlanes[t];
    if (n !== void 0 && (n.plane = e.copy(), n.setReferenceGeometry(i), this._isActive))
      return await this._resetCuttingPlane(n), this._engine.updateCuttingSection(this);
  }
  /**
   * Updates the position of a cutting plane and stand-in geometry if present.
   * @param index The index of the cutting plane.
   * @param plane The plane to use for cutting.
   * @param geometryMatrix A matrix that is multiplied by the previous position matrix to update the geometry position.
   * @param finalizePosition If true, sets the result of the geometry matrix multiplication as the new position matrix.
   * @param resetTranslation If true, uses the provided geometry matrix for the geometry position.
   */
  async updatePlane(t, e, i = new mt(), n = !1, r = !1) {
    const o = this._cuttingPlanes[t];
    if (o !== void 0 && (o.plane = e.copy(), this._isActive))
      if (o.instanceNodeId !== null) {
        this._engine.pauseAllRendering();
        let l = o.getMatrix();
        r && (l = new mt());
        const h = mt.multiply(l, i);
        n && o.setMatrix(h), await Promise.all([
          this._model.setNodeMatrix(o.instanceNodeId, h),
          this._engine.updateCuttingSection(this)
        ]), this._engine.resumeAllRendering();
      } else
        return this._engine.updateCuttingSection(this);
  }
  /**
   * Removes the cutting plane at the specified index.
   * @param index The index of the cutting plane to remove.
   */
  removePlane(t) {
    const e = [], i = this._cuttingPlanes[t];
    return i !== void 0 && (i.meshId !== null && i.instanceNodeId !== null && e.push(this._destroyMeshes([i.meshId], [i.instanceNodeId])), this._cuttingPlanes.splice(t, 1)), this._isActive && e.push(this._engine.updateCuttingSection(this)), Ge(e);
  }
  /**
   * Gets the plane for the item at the given index. In the case of an invalid index, null will be returned.
   * @param index The index of the cutting plane.
   * @returns Plane that is used for cutting at the given index or null.
   */
  getPlane(t) {
    const e = this._cuttingPlanes[t];
    return e !== void 0 ? e.plane.copy() : null;
  }
  /**
   * Gets the [[NodeId]] for the reference geometry for the cutting plane at the given index.
   * In the case of an invalid index or a cutting plane with no reference geometry, null will be returned.
   * @param index the index of the cutting plane.
   * @returns [[NodeId]] of the reference geometry for the cutting plane at the given index or null.
   */
  getNodeId(t) {
    const e = this._cuttingPlanes[t];
    return e !== void 0 ? e.instanceNodeId : null;
  }
  /**
   * Gets the reference geometry for the item at the given index. In the case of an invalid index, null will be returned
   * @param index The index of the cutting plane.
   * @returns A list of four points representing a quad to be used as reference geometry for the cutting plane, or null if there is no reference geometry.
   */
  getReferenceGeometry(t) {
    const e = this._cuttingPlanes[t];
    return e !== void 0 ? e.getReferenceGeometry() : null;
  }
  /**
   * Gets the index of a plane for the corresponding node id. In the case of an invalid id, null will be returned.
   * @param id The [[NodeId]] for the plane reference geometry.
   * @returns The index of a plane associated with the provided [[NodeId]], or null if no plane is found.
   */
  getPlaneIndexByNodeId(t) {
    for (let e = 0; e < this._cuttingPlanes.length; e++)
      if (this._cuttingPlanes[e].instanceNodeId === t)
        return e;
    return null;
  }
  /**
   * Gets the opacity for the plane at the given index.
   * @param index The index of the cutting plane.
   */
  getPlaneOpacity(t) {
    const e = this._cuttingPlanes[t];
    if (e)
      return e.opacity;
  }
  /**
   * Sets the opacity for the plane at the given index.
   *
   * Equivalent to `section.applyPlaneOpacity(index, opacity)`
   *
   * @param index The index of the cutting plane.
   * @param opacity A number between 0 and 1.
   */
  setPlaneOpacity(t, e) {
    this.applyPlaneOpacity(t, e);
  }
  /**
   * Apply the opacity factor to the plane.
   *
   * @param index The index of the cutting plane.
   * @param opacity The value used to change the opacity if needed
   */
  applyPlaneOpacity(t, e) {
    const i = this._cuttingPlanes[t];
    i !== void 0 && (e && (i.opacity = e), i.instanceNodeId !== null && this._model.setNodesOpacity([i.instanceNodeId], i.opacity));
  }
  /**
   * Reapply the opacity of the cutting planes to the engine
   * This function must be explicitly called after _resetOpacity has been emitted by the engine
   */
  resetPlanesOpacity() {
    this._cuttingPlanes.forEach((t, e) => {
      this.applyPlaneOpacity(e);
    });
  }
  /**
   * Sets the color for all planes in the cutting section
   * @param color Color to set
   * @returns Promise that resolves when the operation has completed.
   */
  setColor(t) {
    const e = [];
    for (const i of this._cuttingPlanes)
      i.color.assign(t), i.instanceNodeId !== null && e.push(i.instanceNodeId);
    return this._model.setNodesFaceColor(e, t), Promise.resolve();
  }
  /**
   * Sets the opacity for all planes in the cutting section
   * @param opacity opacity to set
   */
  setOpacity(t) {
    const e = [];
    for (const i of this._cuttingPlanes)
      i.opacity = t, i.instanceNodeId !== null && e.push(i.instanceNodeId);
    this._model.setNodesOpacity(e, t);
  }
  /**
   * Gets the number of planes in this cutting secton.
   * @returns the number of planes in this cutting section
   */
  getCount() {
    return this._cuttingPlanes.length;
  }
  /**
   * Removes all planes from this cutting section. This will also deactivate the cutting section.
   */
  async clear() {
    await this.deactivate(), this._cuttingPlanes.length = 0;
  }
  /**
   * Activates a cutting section for use. A cutting section must have at least one plane to be activated.
   * @returns a promise if the cutting section was activated.
   */
  async activate() {
    if (!this._isActive) {
      if (this._isActive = !0, this._cuttingPlanes.length > 0) {
        if (!this._cuttingManager.hasActiveCuttingSection())
          for (const i of this._viewer.views)
            this._engine.setDefaultDepthRange(i.id, 0, 1 - Yf.Cutoff);
        const t = [], e = [];
        for (const i of this._cuttingPlanes)
          t.push(
            this._createCuttingPlaneGeometry(i).then((n) => {
              n !== null && e.push(n);
            })
          );
        await Ge(t), this._initCuttingPlanesByNodeId(e);
      }
      return this._engine.addCuttingSection(this);
    }
  }
  /**
   * Removes a cutting section from use.
   */
  async deactivate() {
    if (this._isActive) {
      this._isActive = !1;
      const t = [];
      if (t.push(this._destroyGeometry()), t.push(this._engine.removeCuttingSection(this)), !this._cuttingManager.hasActiveCuttingSection())
        for (const e of this._viewer.views)
          this._engine.setDefaultDepthRange(e.id, 0, 1);
      return Ge(t);
    }
  }
  /**
   * Gets whether a cutting section is active
   * @returns boolean value indicating whether this cutting section is active
   */
  isActive() {
    return this._isActive;
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    const t = [];
    for (let e = 0; e < this._cuttingPlanes.length; e++)
      t[e] = this._cuttingPlanes[e].toJson();
    return {
      planes: t
    };
  }
  async fromJson(t) {
    await this.clear();
    const i = Yc(t).planes;
    for (const n of i) {
      const r = new Kp();
      r.fromJson(n), this._cuttingPlanes.push(r);
    }
    return this.activate();
  }
  _initCuttingPlanesByNodeId(t) {
    this._model.setInstanceModifier(Qi.DoNotCut, t, !0), this._model.setInstanceModifier(Qi.DoNotExplode, t, !0), this._cuttingManager.getStandinGeometryPickable() || this._model.setInstanceModifier(Qi.DoNotSelect, t, !0);
  }
  _destroyGeometry() {
    const t = [], e = [];
    for (const i of this._cuttingPlanes)
      i.meshId !== null && t.push(i.meshId), i.instanceNodeId !== null && e.push(i.instanceNodeId), i.meshId = null, i.instanceNodeId = null;
    return this._destroyMeshes(t, e);
  }
  /** @hidden */
  _getInstanceNodeIds() {
    const t = [];
    for (const e of this._cuttingPlanes) {
      const i = e.instanceNodeId;
      i !== null && t.push(i);
    }
    return t;
  }
  async _resetCuttingPlane(t) {
    if (t.meshId !== null && t.instanceNodeId !== null) {
      const e = this._destroyMeshes([t.meshId], [t.instanceNodeId]);
      return t.meshId = null, t.instanceNodeId = null, await e, this._createInstanceGeometry(t);
    } else if (t.referenceGeometry !== null)
      return this._createInstanceGeometry(t);
  }
  async _createInstanceGeometry(t) {
    const e = [], i = await this._createCuttingPlaneGeometry(t);
    i !== null && e.push(i), this._initCuttingPlanesByNodeId(e);
  }
  async _destroyMeshes(t, e) {
    const i = [];
    i.push(this._model.deleteMeshInstances(e)), i.push(this._model.deleteMeshes(t)), await Ge(i);
    for (const n of e)
      this._viewer.selectionManager._incrementalBlacklistedInstanceNodes.delete(n);
  }
  async _createCuttingPlaneGeometry(t) {
    const e = t.createMeshData();
    if (e === null)
      return null;
    e.setBackfacesEnabled(!0);
    const i = await this._model.createMesh(e);
    t.meshId = i;
    const n = ee.OverrideSceneVisibility | ee.ExcludeBounding | ee.DoNotXRay, r = t.plane.copy(), o = r.normal.copy().scale(-r.d), l = new mt().setTranslationComponent(o.x, o.y, o.z);
    t.setMatrix(l.copy());
    const h = new Qs(
      i,
      l,
      null,
      t.color,
      null,
      null,
      n
    );
    h.setLineColor(t.lineColor), this._engine.pauseAllRendering();
    const u = await this._model.createMeshInstance(h, void 0, !0, !0);
    return t.instanceNodeId = u, this._viewer.selectionManager._incrementalBlacklistedInstanceNodes.add(u), this._model.setDepthRange([u], Yf.Cutoff, 1), this._model.setNodesOpacity([u], t.opacity), this._engine.resumeAllRendering(), u;
  }
}
const Zi = class Zi {
  /** @hidden */
  constructor(t, e) {
    this._position = new $o(0, Fe.Pixels, 0, Fe.Pixels), this._viewportSize = new $o(
      0.2,
      Fe.MinimumProportionOfCanvas,
      0.2,
      Fe.MinimumProportionOfCanvas
    ), this._anchor = qe.LowerLeftCorner, this._instanceKeys = [], this._enabled = !1, this._sceneReady = wi(), this._assemblyTreeReady = wi(), this._axisTriadReadyToInit = [this._sceneReady, this._assemblyTreeReady], this._geometryCreated = !1, this._viewer = t, this._view = e, this._viewer.getSceneReady() && this._sceneReady.resolve(), this._viewer.getModelReady() && this._assemblyTreeReady.resolve(), this._viewer.setCallbacks({
      sceneReady: async () => {
        this._sceneReady.resolve();
      },
      _assemblyTreeReady: async () => {
        this._assemblyTreeReady.resolve();
      },
      _firstAttachment: async () => {
        await this._onCameraUpdate(), this._updateVisibility();
      },
      overlayViewportSet: (i, n) => {
        var r;
        n.id === ((r = this._view) == null ? void 0 : r.id) && i === be.AxisTriad && this._onViewportSet();
      },
      _drawContextDestroyed: (i) => {
        this._view !== void 0 && i === this._view.id && delete this._view;
      }
    }), Promise.all(this._axisTriadReadyToInit).then(async () => {
      this._createViewport(), this._updateVisibility(), await this._createGeometry();
      const i = this._viewer.model;
      for (const n of this._instanceKeys) {
        const r = i._getNodeFromInstanceInc(!0, Ei.Local, n, !0);
        i._preventNodeDeletion(r);
      }
    });
  }
  /**
   * Sets the color of one axis on this [[AxisTriad]]
   * @param axis The axis that will change color
   * @param color The color to set
   */
  async setAxisColor(t, e) {
    await this._sceneReady;
    let i, n;
    switch (t) {
      case Qe.X:
        i = this._instanceKeys[0], n = this._instanceKeys[3];
        break;
      case Qe.Y:
        i = this._instanceKeys[1], n = this._instanceKeys[4];
        break;
      case Qe.Z:
        i = this._instanceKeys[2], n = this._instanceKeys[5];
        break;
      default:
        return;
    }
    const r = this._getScEngine();
    r.setPartColor([Ei.Local, i], Yt.Faces, e), r.setPartColor([Ei.Local, n], Yt.Lines, e);
  }
  /**
   * Sets the anchor position for this [[AxisTriad]].
   * @param anchor The anchor position.
   * @returns A promise that resolves on completion.
   */
  async setAnchor(t) {
    return this._anchor = t, await this._sceneReady, this._updateViewport();
  }
  /**
   * Gets the anchor position for this [[AxisTriad]].
   * Default position is in the lower left corner.
   * @returns The overlay anchor value of the triad.
   */
  getAnchor() {
    return this._anchor;
  }
  /**
   * Enables this [[AxisTriad]].
   * @returns A promise that resolves on completion.
   */
  enable() {
    return this._enabled = !0, this._updateVisibility(), Promise.resolve();
  }
  /**
   * Disables this [[AxisTriad]].
   * @returns A promise that resolves on completion.
   */
  disable() {
    return this._enabled = !1, this._updateVisibility(), Promise.resolve();
  }
  /**
   * Updates the visibility of this [[AxisTriad]] based on the enabled status.
   * @returns A promise that resolves on completion.
   */
  _updateVisibility() {
    this._enabled ? this._showOverlay() : this._hideOverlay();
  }
  /**
   * Hides the overlay window.
   * @returns A promise that resolves on completion.
   */
  _hideOverlay() {
    this._view && this._view.overlayManager.setVisibility(be.AxisTriad, !1);
  }
  /**
   * Shows the overlay window.
   * @returns A promise that resolves on completion.
   */
  _showOverlay() {
    this._view && this._view.overlayManager.setVisibility(be.AxisTriad, !0);
  }
  /**
   * Gets the current state of this [[AxisTriad]].
   * @returns `true` if enabled and `false` otherwise.
   */
  getEnabled() {
    return this._enabled;
  }
  /**
   * Gets the overlay id. This id should be considered reserved and not be used by client applications.
   * @returns The overlay id used by this [[AxisTriad]].
   */
  getOverlayId() {
    return be.AxisTriad;
  }
  _updateViewport() {
    if (!this._view)
      return;
    this._view.overlayManager.setViewport(
      be.AxisTriad,
      this._anchor,
      this._position.x,
      Fe.Pixels,
      this._position.y,
      Fe.Pixels,
      this._viewportSize.x,
      this._viewportSize.xUnit,
      this._viewportSize.y,
      this._viewportSize.yUnit
    );
  }
  _createViewport() {
    if (!this._view)
      return;
    const t = this._view.overlayManager;
    this._updateViewport();
    const e = new Cn();
    e.setPosition(new _(0, 0, 10)), e.setTarget(_.zero()), e.setUp(new _(0, 1, 0)), e.setWidth(Zi._fieldSize), e.setHeight(Zi._fieldSize), e.setProjection(ri.Orthographic), t.setCamera(be.AxisTriad, e);
  }
  _onViewportSet() {
    if (!this._view)
      return;
    const t = this._view.overlayManager, e = t._getViewportPosition(be.AxisTriad), i = t._getViewportSize(be.AxisTriad), n = t.getViewportAnchor(be.AxisTriad);
    e === null || i === null || n === null || (this._position = e, this._viewportSize = i, this._anchor = n);
  }
  async _createGeometry() {
    if (this._geometryCreated)
      return;
    const t = [
      this._createAxis(Zi._xRotMatrix, 0, Zi._xColor),
      this._createAxis(Zi._yRotMatrix, 1, Zi._yColor),
      this._createAxis(Zi._zRotMatrix, 2, Zi._zColor),
      this._createAxisLabel(Qe.X, Zi._xColor, 3),
      this._createAxisLabel(Qe.Y, Zi._yColor, 4),
      this._createAxisLabel(Qe.Z, Zi._zColor, 5)
    ], e = await Promise.all(t);
    this._onCameraUpdate();
    const i = [];
    for (const r of e)
      i.push(Ei.Local, r);
    this._getScEngine().setPartVisibility(i, !0, !0), this._createGeomCallbacks(), this._geometryCreated = !0;
  }
  _createGeomCallbacks() {
    this._viewer.setCallbacks({
      camera: (t, e) => {
        this._view !== void 0 && e.id === this._view.id && this._onCameraUpdate();
      }
    });
  }
  /** @hidden */
  _geometryHasBeenCreated() {
    return this._geometryCreated;
  }
  /**
   * Determines whether or not a point is inside the axis triad overlay
   * @param mousePos
   * @returns Boolean indicating whether the provided point is inside the axis triad overlay
   */
  insideOverlay(t) {
    if (!this._view)
      return !1;
    const e = this._view.overlayManager._toPixelPoint(this._viewportSize), i = this._getOverlayOffset();
    return t.x >= i.x && t.y >= i.y && t.x <= i.x + e.x && t.y <= i.y + e.y;
  }
  /** @hidden */
  _getOverlayOffset() {
    if (!this._view)
      return K.zero();
    const t = this._view.overlayManager._toPixelPoint(this._viewportSize);
    return this._view.overlayManager._getOverlayOffset(this._anchor, t);
  }
  /** @hidden */
  _getViewportSize() {
    return this._viewportSize;
  }
  /** @hidden */
  _getViewportPixelSize() {
    return this._view ? this._view.overlayManager._toPixelPoint(this._viewportSize) : K.zero();
  }
  /**
   * Checks if a selection is part of the axis triad, and return the corresponding axis.
   * @param selectionItem selection item to check.
   * @returns Axis if selected, null otherwise.
   */
  getSelectionAxis(t) {
    if (console.assert(this._enabled), t === null || !t.isFaceSelection() || t.overlayIndex() !== be.AxisTriad)
      return null;
    const e = this._viewer.model, i = t.getNodeId(), n = e._gatherInstanceIncsFromNodeIds([i], $t.BodyInstance);
    if (n.length !== 2 || n[0] !== Ei.Local)
      return null;
    const r = n[1];
    for (let o = 0; o < this._instanceKeys.length; ++o)
      if (this._instanceKeys[o] === r)
        switch (o % 3) {
          case 0:
            return Qe.X;
          case 1:
            return Qe.Y;
          case 2:
            return Qe.Z;
        }
    return null;
  }
  /**
   * Called when the axis triad is clicked. Realigns the view along the axis selected by `selection`
   * or does nothing if no axis is selected.
   * @param selection
   */
  async onClickSelection(t) {
    if (this._view === void 0)
      return;
    const e = this.getSelectionAxis(t);
    if (e === null)
      return;
    const i = this._viewer.model, n = this._view;
    let r;
    switch (e) {
      case Qe.X:
        r = fc.EyeX_UpY;
        break;
      case Qe.Y:
        r = fc.EyeY_UpZ;
        break;
      case Qe.Z:
        r = fc.EyeZ_UpX;
        break;
    }
    const o = await i.getModelBounding(!0, !1), l = n.getCamera();
    let h = this._alignedFitBounding(r, !1, !1, o);
    l.equals(h) && (h = this._alignedFitBounding(r, !0, !1, o)), await n._setCameraPromise(h, rs);
    const u = this._viewer.model.getAbsoluteRootNode();
    if (this._viewer.model.getNodeChildren(u).length === 0)
      return this._viewer._getScEngine().markCameraAsEmpty(this._view.id);
  }
  _getScEngine() {
    return this._viewer._getScEngine();
  }
  async _createInstance(t, e, i, n, r, o) {
    const l = await this._viewer.model.createMesh(t), h = new Qs(l);
    if (h.setCreationFlags(
      o | ee.DoNotCut | ee.DoNotExplode | ee.ExcludeBounding | ee.Invisible
    ), !this._view)
      throw Error("Impossible to create a axis triad without an associated view");
    h.overlayId = {
      viewKey: this._view.id,
      overayIndex: be.AxisTriad
    }, h.setFaceColor(i), h.setLineColor(n), h.setMatrix(r);
    const g = (await this._getScEngine().createMeshInstance(h))[1];
    return this._instanceKeys[e] = g, g;
  }
  _createAxis(t, e, i) {
    const n = dg(
      $s.CylinderRadius,
      $s.SegmentCount,
      $s.StemHeight,
      $s.ConeBaseRadius,
      $s.CapHeight,
      $s.TaperHeight
    );
    return this._createInstance(
      n,
      e,
      i,
      vt.black(),
      t,
      ee.None
    );
  }
  _createAxisLabel(t, e, i) {
    const n = new Cs();
    n.setFaceWinding(Zs.Clockwise);
    const r = 0.5 * $s.LetterWidth, o = 0.5 * $s.LetterHeight, l = $s.StemHeight + $s.CapHeight + $s.LetterOffsetPos, h = new mt();
    return t === Qe.X ? (n.addPolyline([r, o, 0, -r, -o, 0]), n.addPolyline([-r, o, 0, r, -o, 0]), h.setTranslationComponent(l, 0, 0)) : t === Qe.Y ? (n.addPolyline([-r, o, 0, 0, 0, 0]), n.addPolyline([0, 0, 0, r, o, 0]), n.addPolyline([0, 0, 0, 0, -1.25 * o, 0]), h.setTranslationComponent(0, l, 0)) : t === Qe.Z && (n.addPolyline([-r, o, 0, r, o, 0]), n.addPolyline([r, o, 0, -r, -o, 0]), n.addPolyline([-r, -o, 0, r, -o, 0]), h.setTranslationComponent(0, 0, l)), this._createInstance(
      n,
      i,
      vt.black(),
      e,
      h,
      ee.ScreenOriented
    );
  }
  _onCameraUpdate() {
    if (this._view === void 0)
      return;
    const t = new Cn(), e = this._view.getCamera();
    t.setPosition(
      e.getPosition().subtract(e.getTarget()).normalize()
    ), t.setTarget(_.zero()), t.setUp(e.getUp()), t.setProjection(ri.Orthographic), t.setWidth(Zi._fieldSize), t.setHeight(Zi._fieldSize), this._view.overlayManager.setCamera(be.AxisTriad, t);
  }
  _alignedFitBounding(t, e, i, n) {
    if (this._view === void 0)
      return;
    const r = _.subtract(n.max, n.min).length(), o = _.add(_.scale(n.min, 0.5), _.scale(n.max, 0.5)), l = new _(o.x, o.y, o.z + r), h = _.subtract(o, l);
    let u = -h.length();
    const d = i ? -1 : 1;
    let g, y;
    t === fc.None ? (g = h, y = new _(0, d, 0), e && g.negate()) : (e && (u = -u), t & Pu.X ? g = new _(u, 0, 0) : t & Pu.Y ? g = new _(0, u, 0) : (console.assert((t & Pu.Z) !== 0), g = new _(0, 0, u)), t & ku.X ? y = new _(d, 0, 0) : t & ku.Y ? y = new _(0, d, 0) : (console.assert((t & ku.Z) !== 0), y = new _(0, 0, d)));
    const m = _.subtract(o, g), x = this._view.getCamera();
    return Cn.create(
      m,
      o,
      y,
      x.getProjection(),
      r,
      r,
      x.getNearLimit()
    );
  }
};
Zi._xRotMatrix = mt.createFromOffAxisRotation(new _(0, 0, 1), -90), Zi._yRotMatrix = new mt(), Zi._zRotMatrix = mt.createFromOffAxisRotation(new _(1, 0, 0), 90), Zi._xColor = new vt(168, 56, 59), Zi._yColor = new vt(96, 166, 50), Zi._zColor = new vt(41, 81, 185), Zi._fieldSize = 8;
let Zf = Zi;
class fx {
  /** @hidden */
  constructor(t, e, i, n) {
    this._cuttingSections = [], this._isInit = !1, this._standinGeometryPickable = !0, this._cappingFaceColor = vt.createFromFloat(0.5, 0.5, 0.5), this._cappingLineColor = vt.createFromFloat(0.5, 0.5, 0.5), this._cappingIdleCallbackEnabled = !1, this._cappingIdlePromise = null, this._conservativeIsCappingIdle = !1, this._viewer = t, this._model = e, this._callbackManager = i, this._engine = n, t.setCallbacks({
      cappingIdle: (r) => {
        this._conservativeIsCappingIdle = r, r && this._cappingIdlePromise !== null && (this._cappingIdlePromise.resolve(), this._cappingIdlePromise = null);
      },
      _resetAssemblyTreeBegin: () => (this._cappingIdlePromise !== null && (this._cappingIdlePromise.reject(new oe("Model became reset.")), this._cappingIdlePromise = null), Promise.resolve()),
      _resetOpacity: () => {
        this._cuttingSections.forEach((r) => r.resetPlanesOpacity());
      }
    });
  }
  /**
   * generates reference geometry for a cutting plane.
   * @param axis axis for reference geometry.
   * @param modelBounding modelBounding for geometry size.
   */
  createReferenceGeometryFromAxis(t, e) {
    const i = [];
    switch (t) {
      case Qe.X:
        i.push(new _(0, e.max.y, e.min.z)), i.push(new _(0, e.max.y, e.max.z)), i.push(new _(0, e.min.y, e.max.z)), i.push(new _(0, e.min.y, e.min.z));
        break;
      case Qe.Y:
        i.push(new _(e.min.x, 0, e.min.z)), i.push(new _(e.max.x, 0, e.min.z)), i.push(new _(e.max.x, 0, e.max.z)), i.push(new _(e.min.x, 0, e.max.z));
        break;
      case Qe.Z:
        i.push(new _(e.min.x, e.max.y, 0)), i.push(new _(e.max.x, e.max.y, 0)), i.push(new _(e.max.x, e.min.y, 0)), i.push(new _(e.min.x, e.min.y, 0));
        break;
    }
    return i;
  }
  /**
   * Uses a selection normal and position to create reference geometry for a cutting plane.
   * @param normal face normal.
   * @param position face position.
   * @param modelBounding model bounding for geometry size.
   */
  createReferenceGeometryFromFaceNormal(t, e, i) {
    const n = [], r = new ln().setFromPointAndNormal(e, t).d, o = e.copy().add(_.scale(t, r)), l = i.center(), h = _.add(
      l,
      _.scale(t, _.dot(t, _.subtract(o, l)))
    ), u = i.extents().length() / 2, d = _.subtract(h, o), g = _.cross(t, d), y = d.copy().scale(-1), m = g.copy().scale(-1), x = _.add(d, g).normalize().scale(u).add(h), b = _.add(y, g).normalize().scale(u).add(h), I = _.add(y, m).normalize().scale(u).add(h), C = _.add(d, m).normalize().scale(u).add(h);
    return n.push(x), n.push(b), n.push(I), n.push(C), n;
  }
  /**
   * Activates all cutting sections, and restores any planes contained to the scene.
   */
  activateCuttingSections() {
    const t = [];
    for (const e of this._cuttingSections)
      t.push(e.activate());
    return Ge(t);
  }
  /**
   * Deactivates all cutting sections.
   * Cutting planes are not removed from section and can be restored using [[activateCuttingSections]]
   */
  deactivateAllCuttingSections() {
    const t = [];
    for (const e of this._cuttingSections)
      t.push(e.deactivate());
    return Ge(t);
  }
  /**
   * Clears all cutting sections.
   * This causes all cutting sections to be deactivated and all their cutting planes removed.
   */
  clearAllCuttingSections() {
    const t = [];
    for (const e of this._cuttingSections)
      t.push(e.clear());
    return Ge(t);
  }
  /**
   * Sets the color for all cutting plane reference geometry.
   * @param color
   */
  setCuttingPlaneColor(t) {
    for (const e of this._cuttingSections)
      e.setColor(t);
    return Promise.resolve();
  }
  /**
   * Sets the color to be used for capping geometry faces. If null is passed in as the color object, no capping face will be shown.
   * @param color color to use for capping geometry faces.
   */
  setCappingFaceColor(t) {
    return this._cappingFaceColor = t ? t.copy() : null, this._engine.setCappingFaceColor(this._cappingFaceColor), Promise.resolve();
  }
  /**
   * Gets the color used for capping geometry faces.
   * @returns color used for capping geometry faces.
   */
  getCappingFaceColor() {
    return this._cappingFaceColor ? this._cappingFaceColor.copy() : null;
  }
  /**
   * Sets the color to be used for capping geometry lines. If null is passed in as the color object, no capping line will be shown.
   * @param color color to use for capping geometry lines.
   */
  setCappingLineColor(t) {
    return this._cappingLineColor = t ? t.copy() : null, this._engine.setCappingLineColor(this._cappingLineColor), Promise.resolve();
  }
  /**
   * Gets the color used for capping geometry lines.
   * @returns color used for capping geometry lines.
   */
  getCappingLineColor() {
    return this._cappingLineColor ? this._cappingLineColor.copy() : null;
  }
  /**
   * Gets a cutting section by index. Cutting sections are created automatically by the system and may be queried at any point during or after the sceneReady callback has been triggered.
   * @returns the cutting section for the given index.
   */
  getCuttingSection(t) {
    return this._isInit && t < this._cuttingSections.length ? this._cuttingSections[t] : null;
  }
  /**
   * Gets the total number of planes supported by each cutting section.
   * Cutting planes contained in the same cutting section will work together (an object is only cut if all cutting planes in a section would cut it).
   * Cutting planes in separate cutting sections do not work together when cutting (an object is cut if any one of the cutting sections would cut it).
   * @returns the number of planes each cutting section may contain.
   */
  getCuttingSectionCapacity() {
    return this._cuttingLimits !== void 0 ? this._cuttingLimits.maxCuttingPlanesPerSection : 0;
  }
  /**
   * Gets the total number of cutting sections supported by the system.
   * @returns the number of cutting sections supported by the system.
   */
  getCuttingSectionCount() {
    return this._cuttingLimits !== void 0 ? this._cuttingLimits.maxCuttingSections : 0;
  }
  /**
   * Gets the cutting section containing the cutting plane with the given node ID. If the supplied node ID is not contained by any cutting section null will be returned.
   * @param nodeId a node ID for cutting plane stand-in geometry.
   * @returns the CuttingSection that contains the plane with the given node id or null if none contain it.
   */
  getCuttingSectionFromNodeId(t) {
    if (t !== null) {
      for (const e of this._cuttingSections)
        if (e._getInstanceNodeIds().indexOf(t) >= 0)
          return e;
    }
    return null;
  }
  /**
   * Gets all nodes that have capping drawn for them.
   * @returns an array of node IDs that have capping drawn for them
   */
  async getNodesWithCapping() {
    const t = await this._engine.getCappedInstances(), e = [];
    for (let i = 0; i < t.length - 1; i += 2) {
      const n = this._model._getNodeFromInstanceInc(
        !1,
        t[i],
        t[i + 1],
        !1
      );
      e.push(n);
    }
    return e;
  }
  /**
   * Sets whether stand-in geometry for cutting sections should be pickable.
   * If this option is set to false, picking rays will pass though stand-in geometry for cutting planes.
   * The default value is not pickable.
   * @param pickable boolean value indicating whether stand-in geometry should be pickable in the scene.
   */
  setStandinGeometryPickable(t) {
    this._standinGeometryPickable = t;
    const e = this._gatherStandinGeometryIds();
    return this._model.setInstanceModifier(Qi.DoNotSelect, e, !t), Promise.resolve();
  }
  /**
   * Gets whether stand-in geometry for cutting sections is pickable.
   * @returns boolean value indicating whether stand-in geometry for cutting sections is pickable.
   */
  getStandinGeometryPickable() {
    return this._standinGeometryPickable;
  }
  /** @hidden */
  _setStandinGeometryVisible(t) {
    const e = this._gatherStandinGeometryIds(), i = this._model._gatherInstanceIncsFromNodeIds(e);
    this._engine.pauseAllRendering(() => {
      this._engine.setPartVisibility(i, t, !1);
    });
  }
  /**
   * Sets the delay used by delayCapping() in milliseconds.
   * @param delayInMilliseconds The delay amount.
   */
  setCappingDelay(t) {
    this._engine.setCappingDelay(t);
  }
  /**
   * Delays capping processing by a fixed time interval.
   */
  delayCapping() {
    this._engine.delayCapping();
  }
  /**
   * Enables or disables activation of "cappingIdle" callback event.
   * @param enable Enables or disables activation of "cappingIdle" callback event.
   * @returns A promise returning whether or not capping generation was idle when this call resolves.
   */
  enableCappingIdleCallback(t) {
    return t !== this._cappingIdleCallbackEnabled && (this._cappingIdleCallbackEnabled = t, this._conservativeIsCappingIdle = !1, !t && this._cappingIdlePromise !== null && (this._cappingIdlePromise.reject(
      new oe("Capping idle callback became disabled.")
    ), this._cappingIdlePromise = null)), this._engine.enableCappingIdleCallback(t);
  }
  async waitForCappingIdle() {
    if (!this._cappingIdleCallbackEnabled)
      throw console.assert(this._cappingIdlePromise === null), new oe("Capping idle callback is not enabled.");
    if (!this._conservativeIsCappingIdle)
      return this._cappingIdlePromise === null && (this._cappingIdlePromise = wi()), this._cappingIdlePromise;
  }
  /**
   * Sets whether capping geometry will show.
   * The default value is true.
   * @param cappingGeometryVisibility
   */
  setCappingGeometryVisibility(t) {
    for (const e of this._viewer.views)
      this._engine.setCappingGeometryVisibility(e.id, t);
    return Promise.resolve();
  }
  /**
   * Gets whether capping geometry will show
   * @returns boolean value indicating whether capping geometry will show
   */
  getCappingGeometryVisibility() {
    return this._engine.getCappingGeometryVisibility();
  }
  /**
   * @returns the number of active cutting sections.
   */
  getActiveCuttingSectionCount() {
    let t = 0;
    if (this._cuttingLimits)
      for (let e = 0; e < this._cuttingLimits.maxCuttingSections; e++) {
        const i = this.getCuttingSection(e);
        i != null && i.isActive() && (t += i.getCount());
      }
    return t;
  }
  /** @hidden */
  _init() {
    if (!this._isInit) {
      this._cuttingLimits = this._engine.getCuttingSectionLimits();
      for (let t = 0; t < this._cuttingLimits.maxCuttingSections; t++) {
        const e = new dx(
          this._viewer,
          this._model,
          this._callbackManager,
          this,
          this._engine
        );
        this._cuttingSections.push(e);
      }
      this._isInit = !0;
    }
  }
  /** @hidden */
  _isInitialized() {
    return this._isInit;
  }
  /**
   * Updates all cutting plane geometry.
   */
  refreshPlaneGeometry() {
    const t = [];
    for (const e of this._cuttingSections)
      for (let i = 0; i < e.getCount(); i++) {
        const n = e.getPlane(i);
        n !== null && t.push(e.updatePlane(i, n, new mt(), !1, !1));
      }
    return Ge(t);
  }
  /**
   * @returns true if there is an active cutting section.
   */
  hasActiveCuttingSection() {
    if (this._cuttingLimits)
      for (let t = 0; t < this._cuttingLimits.maxCuttingSections; t++) {
        const e = this.getCuttingSection(t);
        if (e !== null && e.isActive())
          return !0;
      }
    return !1;
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this._toJson();
  }
  _toJson() {
    const t = [];
    for (let e = 0; e < this._cuttingSections.length; e++)
      t[e] = this._cuttingSections[e].toJson();
    return {
      cuttingSections: t,
      cappingGeometryVisibility: this.getCappingGeometryVisibility(),
      cappingFaceColor: this.getCappingFaceColor(),
      cappingLineColor: this.getCappingLineColor(),
      pickable: this.getStandinGeometryPickable()
    };
  }
  /**
   * Removes any cutting planes in the scene, and restores cutting planes from a json object.
   * @param json
   */
  async fromJson(t) {
    const e = Yc(t), i = [], n = e.cuttingSections;
    for (let r = 0; r < n.length; r++) {
      const o = n[r], l = this._cuttingSections[r];
      i.push(l.fromJson(o));
    }
    this.setStandinGeometryPickable(e.pickable), i.push(this.setCappingGeometryVisibility(e.cappingGeometryVisibility)), i.push(this.setCappingFaceColor(vt.fromJson(e.cappingFaceColor))), i.push(this.setCappingLineColor(vt.fromJson(e.cappingLineColor))), await Promise.all(i), this._callbackManager.trigger("cuttingSectionsLoaded");
  }
  _gatherStandinGeometryIds() {
    const t = [];
    for (const e of this._cuttingSections) {
      const i = e._getInstanceNodeIds();
      for (const n of i)
        t.push(n);
    }
    return t;
  }
}
class gx {
  /** @hidden */
  constructor(t, e, i) {
    this._explodeActive = !1, this._explodeMagnitude = 0, this._model = t, this._engine = e, i.bind({
      _modelSwitched: async () => {
        this.stop();
      }
    });
  }
  /**
   * Starts an explode operation. This will cancel any currently active explode operation.
   * @param nodeIds an array of NodeId for the parts that should be exploded. If this parameter is omitted or is an empty array, the entire model will be considered for explosion.
   * @param explosionVector the vector to use for the center of the explosion.
   * @returns a promise that resolves when this operation is complete.
   */
  start(t, e) {
    return this.getActive() ? (this.stop(), this._doExplode(t, e)) : this._doExplode(t, e);
  }
  /**
   * Sets the explosion magnitude if there is an active explosion operation.
   * A value of 1.0 indicates that the distance between a part's exploded center, and exploded center will be double.
   * @param magnitude the magnitude for the explosion.
   * @returns a promise that resolves when this operation is complete.
   */
  async setMagnitude(t) {
    if (t > 0 && !this._explodeActive ? await this.start() : t === 0 && this._explodeActive && this.stop(), this._explodeActive)
      return this._explodeMagnitude = t, this._engine.setExplodeMagnitude(t);
  }
  /**
   * Terminates any active explode operation.
   * @returns a promise that resolves when this operation is complete.
   */
  stop() {
    return this._engine.stopExplode(), this._explodeMagnitude = 0, this._explodeActive = !1, this._engine.setExplodeMagnitude(0), Promise.resolve();
  }
  /**
   * Gets the current explode magnitude. This will always return 0 when there is no active explode operation.
   * @returns the current explode magnitude.
   */
  getMagnitude() {
    return this._explodeMagnitude;
  }
  /**
   * Indicates whether there is a currently active explode operation.
   * @returns boolean value indicating if there is an active explode operation.
   */
  getActive() {
    return this._explodeActive;
  }
  async _doExplode(t, e) {
    this._explodeActive = !0;
    let i;
    if (t !== void 0 && t.length > 0 ? i = this._model._gatherInstanceIncsFromNodeIds(t) : i = [], e)
      this._engine.startExplode(i, e);
    else {
      const n = await this._model.getModelBounding(!0, !1);
      this._engine.startExplode(i, n.center());
    }
  }
}
class Uy {
  /**
   * @param type The light's type. See [[type]].
   * @param space The space in which a light is defined. See [[space]]
   * @param position The light's position. See [[position]].
   * @param color The light's color. See [[color]].
   */
  constructor(t, e, i, n) {
    this.type = t, this.space = e, this.position = i, this.color = n;
  }
}
class px extends Uy {
  constructor(t, e, i, n) {
    super(t, e, i, n);
  }
}
class mx extends Uy {
  /**
   * @param type The light's type. See [[type]].
   * @param space The space in which a light is defined. See [[space]]
   * @param position The light's position. See [[position]].
   * @param color The light's color. See [[color]].
   * @param power The light's power. See [[power]].
   * @param decay The light's power. See [[decay]].
   */
  constructor(t, e, i, n, r, o) {
    super(t, e, i, n), this.power = r, this.decay = o;
  }
}
class _x extends Pd {
  /** @hidden */
  constructor(t, e) {
    super(), this._markupArray = [], this._viewer = t, this._callbackManager = e, this._callbackManager.bind({
      modelSwitched: () => {
        this.removeAllLines();
      }
    });
  }
  /**
   * Adds a new Line to the Line Manager
   * @param lineItem LineMarkup Object that will be added
   */
  async addLine(t) {
    this._markupArray.push(t), await t.updateLine(), this._callbackManager.trigger("lineCreated", t);
  }
  /**
   * Removes an existing line item.
   * @param lineItem the line item to remove.
   */
  async removeLine(t) {
    for (let e = 0; e < this._markupArray.length; e++)
      this._markupArray[e].getId() === t.getId() && (await t.removeLine(), this._markupArray.splice(e, 1), this._callbackManager.trigger("lineDeleted", t));
  }
  /**
   * Removes all line items.
   */
  removeAllLines() {
    const t = [];
    for (let e = this._markupArray.length - 1; e >= 0; e--) {
      const i = this._markupArray[e];
      t.push(
        i.removeLine().then(() => {
          this._callbackManager.trigger("lineDeleted", i);
        })
      ), this._markupArray.splice(e, 1);
    }
    return Ge(t);
  }
  /**
   * Return an array of line items.
   * @returns array of all line items.
   */
  getAllLines() {
    return this._markupArray.slice(0);
  }
  /**
   * Removes the most recently added line item.
   */
  async removeLastLine() {
    this._markupArray.length > 0 && await this.removeLine(this._markupArray[this._markupArray.length - 1]);
  }
  /**
   * Gets a line markup item associated with a node id.
   * @param id
   */
  getLineByNodeId(t) {
    for (const e of this._markupArray) {
      const i = e.getNodeId();
      if (i !== null && i === t)
        return e;
    }
    return null;
  }
  /**
   * @returns JSON Array with line markup
   */
  exportMarkup() {
    const t = [];
    for (const e of this._markupArray)
      t.push(e.toJson());
    return t;
  }
  async _handleLoadLine(t) {
    return t instanceof Da ? (await this.addLine(t), this._callbackManager.trigger("lineLoaded", t), !0) : !1;
  }
  /**
   * Loads JSON markup data
   * @param lineData
   * @param viewer
   */
  loadData(t) {
    const e = [];
    for (const i of t) {
      if (!i.hasOwnProperty("className"))
        continue;
      const n = hg(i.className);
      if (n) {
        const r = n(i, this._viewer);
        r instanceof Promise ? e.push(
          r.then((o) => this._handleLoadLine(o))
        ) : e.push(this._handleLoadLine(r));
      }
    }
    return Promise.all(e);
  }
}
class yx extends Pd {
  constructor(t, e, i, n, r, o) {
    super(), this._markupViews = /* @__PURE__ */ new Map(), this._defaultViewCounter = 1, this._markupItemManager = e, this._callbackManager = i, this._explodeManager = n, this._cuttingManager = r, this._viewer = t, this._sheetManager = o, this._initEvents();
  }
  _initEvents() {
    this._callbackManager.bind({
      modelSwitchStart: () => {
        this._markupItemManager.shutdown();
      }
    });
  }
  getView(t) {
    const e = this._markupViews.get(t);
    return e !== void 0 ? e : null;
  }
  getViewKeys() {
    const t = [];
    return this._markupViews.forEach((e, i) => {
      t.push(i);
    }), t;
  }
  async loadData(t) {
    const e = [];
    for (const i of t) {
      const n = uh._fromJson(i, this._viewer).then((r) => {
        if (!r.itemResults.every(Boolean))
          return !1;
        const o = r.markupView, l = o.getUniqueId();
        return this._markupViews.has(l) ? !1 : (this._markupViews.set(l, o), this._callbackManager.trigger("viewLoaded", o), !0);
      });
      e.push(n);
    }
    return Promise.all(e);
  }
  exportMarkup() {
    const t = [];
    return this._markupViews.forEach((e) => {
      t.push(e.toJson());
    }), t;
  }
  createView(t = this._createDefaultViewName(), e, i = !0, n = null, r = null, o = null, l = null) {
    const h = Ss(), u = new uh(
      h,
      t,
      e.getCamera(),
      this._explodeManager.getMagnitude(),
      this._cuttingManager.toJson(),
      n
    );
    return this._markupViews.set(h, u), u.setLineVisibility(e.getLineVisibility()), u.setFaceVisibility(e.getFaceVisibility()), r !== null && (u.setDefaultVisibility(r.defaultVisibility), u.setVisibilityExceptions(r.visibilityExceptions)), o !== null && u.setColorMap(o), l !== null && u.setSnapshotImage(l), this._markupItemManager.setActiveView(e, u), i && this._callbackManager.trigger("viewCreated", u), u;
  }
  async _activateSheet(t) {
    if (t !== null)
      return this._sheetManager.setActiveSheetId(t, !0, !1);
  }
  async _activateViewImpl(t, e, i) {
    await this._activateSheet(t.getSheetId()), e.setFaceVisibility(t.getFaceVisibility()), e.setLineVisibility(t.getLineVisibility()), i > 0 ? (await this._markupItemManager.setActiveView(e, null), await e._setCameraPromise(t.getCamera(), i)) : e.setCamera(t.getCamera()), await this._setActiveView(t, e);
  }
  _activateView(t, e, i) {
    const n = this._markupViews.get(t);
    if (n !== void 0) {
      const r = this._activateViewImpl(n, e, i);
      return No(!0, r);
    } else
      return No(!1, Promise.resolve());
  }
  async activateView(t, e, i = rs) {
    return this._activateView(t, e, i);
  }
  /** This is a helper for `activateView`. */
  async _setActiveView(t, e) {
    if (this._viewer.model.isDrawing())
      if (t.getSheetId() === null)
        await this._viewer.sheetManager.deactivateSheets(!0, !0);
      else {
        const i = t.getVisibilityExceptions(), n = t.getDefaultVisibility();
        if (i.size > 0 && n) {
          const r = [];
          i.forEach((o) => {
            r.push(o);
          }), await this._viewer.model.setNodesVisibility(r, !1);
        }
      }
    else {
      const i = t.getDefaultVisibility(), n = t.getVisibilityExceptions();
      await this._viewer.model.setBodyNodesVisibility(
        this._viewer.model.getAbsoluteRootNode(),
        (r) => n.has(r) ? !i : i
      );
    }
    await this._markupItemManager.setActiveView(e, t), await this._cuttingManager.fromJson(t.getCuttingPlaneData()), await this._viewer.model.setNodesColors(t.getColorMap()), await this._explodeManager.setMagnitude(t.getExplodeMagnitude());
  }
  deleteView(t) {
    const e = this._markupViews.get(t);
    return e !== void 0 ? (this._callbackManager.trigger("viewDeleted", e), this._markupItemManager.markupViewDeleted(e), this._markupViews.delete(t), !0) : !1;
  }
  _createDefaultViewName() {
    return `View ${this._defaultViewCounter++}`;
  }
  /**
   * Creates an object ready for JSON serialization.
   * @returns The prepared object.
   */
  toJson() {
    return this.exportMarkup();
  }
}
class wx {
  /** @hidden */
  constructor(t, e, i, n, r, o) {
    this._markupTypeMap = /* @__PURE__ */ new Map(), this._callbackManager = i, this._viewer = o, this._sheetManager = n, this._sheetManager.setMarkupManager(this), this._noteTextManager = r, this._renderer = new Z_(), this._itemManager = new q_(this._callbackManager, this._renderer), this._viewManager = new yx(
      this._viewer,
      this._itemManager,
      this._callbackManager,
      o.explodeManager,
      o.cuttingManager,
      this._sheetManager
    ), this._measurementManager = t, this._lineManager = e;
  }
  /**
   * Registers a MarkupTypeManager to add markup to exported data.
   * @param markupTypeManager
   */
  registerMarkupTypeManager(t, e) {
    this._markupTypeMap.set(t, e);
  }
  /**
   * Registers a factory to load custom markups in markup views when using loadMarkupData.
   * @param className identifier of the markup item type, this is what's returned by getClassName function of MarkupItem.
   * @param factory a function to create the markup object from a json object outputed by toJson function of MarkupItem.
   */
  registerMarkupFactory(t, e) {
    as(t, e);
  }
  /**
   * Creates a new markup view based on a given view, line, and face visibility values.
   * @param view the reference view for values used to create the markup view (camera, line and face visibility).
   * @param name optional name for the markup view. If omitted or null, the system will generate a default name
   * @param triggerEvent optional parameter indicating whether a [[CallbackMap.viewCreated]] event should be triggered. This parameter defaults to true
   * @param visibilityState optional parameter
   * @returns Unique identifier for the new view
   */
  createMarkupView(t, e, i = !0, n = null, r = null, o = null) {
    const l = this._viewer.sheetManager.getActiveSheetId();
    return this._viewManager.createView(
      e,
      t,
      i,
      l,
      n,
      r,
      o
    ).getUniqueId();
  }
  /**
   * Gets a [[MarkupView]] object from the viewer.
   * @param uniqueId the handle for the view object to retreive
   * @returns [[MarkupView]] object for the corresponding ID or null if no view was found
   */
  getMarkupView(t) {
    return this._viewManager.getView(t);
  }
  /**
   * @returns an array of string keys for all markup views
   */
  getMarkupViewKeys() {
    return this._viewManager.getViewKeys();
  }
  /**
   * Activates a [[MarkupView]] in the given view.
   * @param uniqueId the handle for the [[MarkupView]] object to activate
   * @param view the view to activate the markup view
   * @param duration the time in milliseconds for the transition to this view
   */
  async activateMarkupViewWithPromise(t, e, i = rs) {
    return this._viewManager.activateView(t, e, i);
  }
  /**
   * Returns the currently active [[MarkupView]].
   * @returns [[MarkupView]] object for the currently active view, or null if no view is active
   */
  getActiveMarkupView(t) {
    return this._itemManager.getActiveView(t);
  }
  /**
   * Deletes a [[MarkupView]] object.
   * @param uniqueId the handle for the view object to delete
   * @returns true if a [[MarkupView]] with the supplied uniqueId was deleted, false otherwise
   */
  deleteMarkupView(t) {
    return this._viewManager.deleteView(t);
  }
  /**
   * Registers a [[MarkupItem]] to be rendered with the 3D view in the given view.
   * @param markupItem the item to register
   * @param view the view where display markup
   * @returns unique handle to this [[MarkupItem]].
   */
  registerMarkup(t, e) {
    const i = this._itemManager.registerMarkupItem(t, e);
    return this.updateLater(e), i;
  }
  /**
   * Unregisters a [[MarkupItem]]. It will no longer be rendered with the 3D view.
   * @param uniqueId unique handle to the object that was returned from [[registerMarkup]]
   * @param view the view the markup belongs to
   */
  unregisterMarkup(t, e) {
    this._itemManager.unregisterMarkupItem(t, e), this.updateLater(e);
  }
  /**
   * Add an HTML element to the markup element layer of a given view. The element will have its ID set to a system generated unique identifier.
   * @param element the HTML Element to add
   * @param view the view where to add the HTML element
   * @returns system generated unique identifier which is the id of the passed in object
   */
  addMarkupElement(t, e) {
    const i = Ss();
    return t.id = i, e.domElements.getRedlineElement().appendChild(t), i;
  }
  /**
   * Removes a markup element from the markup element layer of the given view
   * @param uniqueId unique handle to the object that was returned from [[registerMarkup]]
   * @param view the view where to remove the HTML element
   */
  removeMarkupElement(t, e) {
    const i = e.domElements.getRedlineElement();
    for (let n = 0; n < i.children.length; n++) {
      const r = i.children.item(n);
      r !== null && r.id === t && i.removeChild(r);
    }
  }
  /**
   * Redraws the markup without rendering the scene. Useful when markup is added or removed but the scene is not affected.
   * @param view the view where markups need to be redrawn
   */
  refreshMarkup(t) {
    this.updateLater(t);
  }
  /**
   * Redraws all views where the given markup view is active. Scene is not rendered.
   * Useful when something in a markup view has been updated and views need to reflect the changes.
   * @param markupView the markup view that has changed.
   */
  refreshMarkupView(t) {
    const e = this._itemManager.getViews(t);
    for (let i of e)
      this.refreshMarkup(i);
  }
  updateLater(t) {
    this._itemManager.updateLater(t);
  }
  /**
   * Picks a [[MarkupItem]]. Tests scene based and markup attached to the active view (if any)
   * @param point position to pick against
   * @param view view where the test is triggered
   * @returns [[MarkupItem]] that was selected or null if none was picked
   */
  pickMarkupItem(t, e) {
    return this._itemManager.pick(t, e);
  }
  /**
   * Gets the pick tolerance in pixels for picking a [[MarkupItem]]
   * @returns Current tolerance
   */
  getPickTolerance() {
    return this._itemManager.getPickTolerance();
  }
  /**
   * Sets the pick tolerance in pixels for picking a [[MarkupItem]]
   * @param tolerance The new tolerance
   */
  setPickTolerance(t) {
    return this._itemManager.setPickTolerance(t);
  }
  /**
   * Selects a [[MarkupItem]]. Pass null to clear the selection.
   * Will refresh all views with markups.
   * @param markupItem The [[MarkupItem]] to select.
   * @param view The view the selection come from.
   */
  selectMarkup(t, e) {
    this._itemManager.select(t, e);
  }
  /**
   * Returns the currently selected [[MarkupItem]], or null if nothing is currently selected
   * @returns selected [[MarkupItem]]
   */
  getSelectedMarkup() {
    return this._itemManager.getSelected();
  }
  /**
   * export markup from the viewer
   * @returns Serialized markup objects
   */
  exportMarkup() {
    const t = {
      views: this._viewManager.exportMarkup(),
      notes: this._noteTextManager.exportMarkup(),
      measurement: this._measurementManager.exportMarkup(),
      lines: this._lineManager.exportMarkup()
    };
    return this._markupTypeMap.forEach((e, i) => {
      t[i] = e.exportMarkup();
    }), t;
  }
  /**
   * Loads markup data into the viewer.
   * @param data markup data to be loaded into the viewer
   */
  async loadMarkupData(t) {
    return typeof t == "string" && (t = JSON.parse(t)), this._loadMarkupData(t);
  }
  async _loadMarkupData(t) {
    const e = [];
    if (t.hasOwnProperty("views")) {
      const i = this._viewManager.loadData(t.views).then((n) => n.every(Boolean));
      e.push(i);
    }
    if (t.hasOwnProperty("notes")) {
      const i = this._noteTextManager.loadData(t.notes).then((n) => n.every(Boolean));
      e.push(i);
    }
    if (t.hasOwnProperty("measurement")) {
      const i = this._measurementManager.loadData(t.measurement).then((n) => n.every(Boolean));
      e.push(i);
    }
    if (t.hasOwnProperty("lines")) {
      const i = this._lineManager.loadData(t.lines).then((n) => n.every(Boolean));
      e.push(i);
    }
    return this._markupTypeMap.forEach((i, n) => {
      if (t.hasOwnProperty(n)) {
        const r = i.loadData(t[n]).then((o) => o.every(Boolean));
        e.push(r);
      }
    }), Promise.all(e).then((i) => i.every(Boolean));
  }
  /**
   * Returns a the interface to the [[MarkupRenderer]].
   * @returns [[MarkupRenderer]] interface
   */
  getRenderer() {
    return this._renderer;
  }
  /** @hidden */
  _shutdown() {
    this._itemManager.shutdown(), this._renderer._clear();
  }
  /** @hidden */
  _update() {
    this._itemManager.update();
  }
  /** @hidden */
  async _setActiveMarkupView(t, e) {
    return this._itemManager.setActiveView(t, e);
  }
  /** @hidden */
  _getItemManager() {
    return this._itemManager;
  }
  /** @hidden */
  _viewDeleted(t) {
    this._itemManager.viewDeleted(t);
  }
}
class vx extends Pd {
  /** @hidden */
  constructor(t, e) {
    super(), this._markupArray = [], this._color = new vt(0, 0, 0), this._edgeColor = new vt(0, 0, 0), this._viewer = t, this._callbackManager = e, this._callbackManager.bind({
      modelSwitched: () => {
        this.removeAllMeasurements();
      }
    });
  }
  /**
   * Adds a new Measurement to the Measure Manager
   * @param measurementItem MeasureMarkup Object that will be added
   */
  addMeasurement(t) {
    this._markupArray.push(t);
    const e = this._viewer.markupManager.registerMarkup(t, this._viewer.view);
    return t._setId(e), e;
  }
  /**
   * Triggers a measurementCreated callback
   * @param measureItem
   * @param triggerEvent boolean trigger a callback event
   */
  finalizeMeasurement(t) {
    this._callbackManager.trigger("measurementCreated", t);
  }
  /**
   * Removes an existing measurement item.
   * @param measurementItem the measurement item to remove.
   */
  removeMeasurement(t) {
    for (let e = 0; e < this._markupArray.length; e++)
      if (this._markupArray[e]._getId() === t._getId()) {
        this._markupArray.splice(e, 1), this._viewer.markupManager.unregisterMarkup(t._getId(), this._viewer.view), this._callbackManager.trigger("measurementDeleted", t);
        break;
      }
  }
  /**
   * Removes all measurement items.
   */
  removeAllMeasurements() {
    for (let t = this._markupArray.length - 1; t >= 0; t--) {
      const e = this._markupArray[t];
      this._viewer.markupManager.unregisterMarkup(e._getId(), this._viewer.view), this._markupArray.splice(t, 1), this._callbackManager.trigger("measurementDeleted", e);
    }
  }
  /**
   * Return an array of measurement items.
   * @returns array of all measurement items.
   */
  getAllMeasurements() {
    return this._markupArray.slice(0);
  }
  /**
   * Removes the most recently added measurement item.
   */
  removeLastMeasurement() {
    this._markupArray.length > 0 && this.removeMeasurement(this._markupArray[this._markupArray.length - 1]);
  }
  /**
   * Sets the current measurement color.
   * @param color the measurement color to set.
   */
  setMeasurementColor(t) {
    this._color.assign(t);
  }
  /**
   * Gets the current measurement color.
   * @returns color current measurement color.
   */
  getMeasurementColor() {
    return this._color.copy();
  }
  /**
   * Sets the current measurement edge color.
   * @param color the measurement edge color to set.
   */
  setMeasurementEdgeColor(t) {
    this._edgeColor.assign(t);
  }
  /**
   * Gets the current measurement edge color.
   * @returns color current measurement edge color.
   */
  getMeasurementEdgeColor() {
    return this._edgeColor.copy();
  }
  /**
   * @returns JSON Array with measurement markup
   */
  exportMarkup() {
    const t = [];
    for (const e of this._markupArray)
      e != null && e.isMarkupValid() && t.push(e.toJson());
    return t;
  }
  _handleLoadMeasurement(t) {
    return t instanceof Rn ? (this.addMeasurement(t), this._callbackManager.trigger("measurementLoaded", t), !0) : !1;
  }
  /**
   * Loads JSON markup data
   * @param measurementData
   * @param viewer
   */
  loadData(t) {
    const e = [];
    for (const i of t) {
      if (!i.hasOwnProperty("className"))
        continue;
      const n = hg(i.className);
      if (n) {
        const r = n(i, this._viewer);
        r instanceof Promise ? e.push(
          r.then((o) => this._handleLoadMeasurement(o))
        ) : e.push(Promise.resolve(this._handleLoadMeasurement(r)));
      }
    }
    return Promise.all(e);
  }
}
const Gc = class Gc {
  /** @hidden */
  constructor(t, e) {
    this._position = new $o(0, Fe.Pixels, 0, Fe.Pixels), this._viewportSize = new $o(
      0.2,
      Fe.MinimumProportionOfCanvas,
      0.2,
      Fe.MinimumProportionOfCanvas
    ), this._anchor = qe.UpperRightCorner, this._dimension = 3, this._fieldSize = 8, this._instanceKeys = [], this._enabled = !1, this._textImageId = null, this._selectionFaceColor = new vt(76, 186, 240), this._outlineColor = new vt(17, 94, 133), this._lastSelectedNodes = [], this._nodeIds = [], this._adjacentFaces = [], this._preserveModelUp = !0, this._cameraRotation = 0, this._lastOrientation = null, this._lastCamera = null, this._lastFaceIndex = null, this._textWidths = [], this._sceneReady = wi(), this._assemblyTreeReady = wi(), this._navcubeReadyToInit = [this._sceneReady, this._assemblyTreeReady], this._texturesReady = !1, this._geometryCreated = !1, this._viewer = t, this._view = e, this._fontSize = 25, this._fontInfo = `${this._fontSize}px Arial`, this._textureSize = 512, this._viewer.getSceneReady() && this._sceneReady.resolve(), this._viewer.getModelReady() && this._assemblyTreeReady.resolve(), this._viewer.setCallbacks({
      sceneReady: () => {
        this._sceneReady.resolve();
      },
      _assemblyTreeReady: async () => {
        this._assemblyTreeReady.resolve();
      },
      _firstAttachment: async () => {
        this._onCameraUpdate(), this._updateVisibility();
      },
      camera: (i, n) => {
        var r;
        n.id === ((r = this._view) == null ? void 0 : r.id) && this._onCameraUpdate();
      },
      overlayViewportSet: (i, n) => {
        var r;
        n.id === ((r = this._view) == null ? void 0 : r.id) && i === be.NavCube && this._onViewportSet();
      },
      transitionEnd: (i) => {
        var n;
        i.id === ((n = this._view) == null ? void 0 : n.id) && this._onCameraUpdate();
      },
      viewAxes: () => {
        this._updateOrientationMatrices();
      },
      _resetOpacity: () => {
        this._viewer.model.setNodesOpacity(this._nodeIds.slice(1), 0);
      },
      viewOrientation: (i, n) => {
        var r;
        this._view !== void 0 && n.id === ((r = this._view) == null ? void 0 : r.id) && (this._lastOrientation = i, this._cameraRotation = 0, this._lastCamera = this._view.getCamera());
      },
      _drawContextDestroyed: (i) => {
        this._view !== void 0 && i === this._view.id && delete this._view;
      }
    }), Promise.all(this._navcubeReadyToInit).then(async () => {
      this._createViewport(), this._updateVisibility(), await this._createGeometry(), this._setTextures();
    });
  }
  /**
   * Sets the anchor position for the NavCube.
   * @param anchor the anchor position.
   */
  async setAnchor(t) {
    return this._anchor = t, await this._sceneReady, this._updateViewport();
  }
  /**
   * Gets the anchor position for the NavCube. Default position is in the UpperRightCorner, see [[OverlayAnchor]] for more details.
   */
  getAnchor() {
    return this._anchor;
  }
  /**
   * Enables the NavCube.
   */
  enable() {
    return this._enabled = !0, this._updateVisibility(), Promise.resolve();
  }
  /**
   * Disables the NavCube.
   */
  disable() {
    return this._enabled = !1, this._updateVisibility(), Promise.resolve();
  }
  /**
   * Determines if model up or camera up will the preserved when navigating with the NavCube.
   * If model up is preserved, navigation with the NavCube will keep the model upright all the time.
   * If camera up is preserved, navigation with the NavCube will attempt to preserve the current up direction of
   * the camera as much as possible.
   * Defaults to `true`.
   * @param preserve If true, model up is preserved. Otherwise, camera up is preserved.
   */
  setPreserveModelUp(t) {
    this._preserveModelUp = t;
  }
  /**
   * Gets the NavCube preserveModelUp state.
   * @returns true if model up is preserved, false if camera up is preserved.
   */
  getPreserveModelUp() {
    return this._preserveModelUp;
  }
  /**
   * Sets the visibility for the NavCube based on the enabled and textures state.
   */
  _updateVisibility() {
    this._enabled && this._texturesReady ? this._showOverlay() : this._hideOverlay();
  }
  /**
   * Hides the overlay window
   */
  _hideOverlay() {
    this._view && this._view.overlayManager.setVisibility(be.NavCube, !1);
  }
  /**
   * Shows the overlay window
   */
  _showOverlay() {
    this._view && this._view.overlayManager.setVisibility(be.NavCube, !0);
  }
  /**
   * Gets whether the NavCube is currently enabled.
   */
  getEnabled() {
    return this._enabled;
  }
  /**
   * Gets the associated overlay id.
   */
  getOverlayId() {
    return be.NavCube;
  }
  async _setTextures() {
    if (!this._textImageId || this._nodeIds.length > 0 || this._instanceKeys.length <= 0)
      return;
    const t = this._viewer.model;
    for (const e of this._instanceKeys) {
      const i = t._getNodeFromInstanceInc(!0, Ei.Local, e, !0);
      this._nodeIds.push(i), t._preventNodeDeletion(i);
    }
    t.setNodesOpacity(this._nodeIds.slice(1), 0), await t.setNodesTexture([this._nodeIds[0]], {
      imageId: this._textImageId
    }), this._texturesReady = !0, this._updateVisibility();
  }
  _updateViewport() {
    if (!this._view)
      return;
    this._view.overlayManager.setViewport(
      be.NavCube,
      this._anchor,
      this._position.x,
      Fe.Pixels,
      this._position.y,
      Fe.Pixels,
      this._viewportSize.x,
      this._viewportSize.xUnit,
      this._viewportSize.y,
      this._viewportSize.yUnit
    );
  }
  _createViewport() {
    if (!this._view)
      return;
    const t = this._view.overlayManager;
    this._updateViewport();
    const e = new Cn();
    e.setPosition(new _(0, 0, 10)), e.setTarget(_.zero()), e.setUp(new _(0, 1, 0)), e.setWidth(this._fieldSize), e.setHeight(this._fieldSize), e.setProjection(ri.Orthographic), t.setCamera(be.NavCube, e);
  }
  _onViewportSet() {
    if (!this._view)
      return;
    const t = this._view.overlayManager, e = t._getViewportPosition(be.NavCube), i = t._getViewportSize(be.NavCube), n = t.getViewportAnchor(be.NavCube);
    e === null || i === null || n === null || (this._position = e, this._viewportSize = i, this._anchor = n);
  }
  async _createGeometry() {
    if (this._geometryCreated)
      return;
    const t = this._initializeTextures();
    let e = 0;
    const i = [];
    i.push(this._createCube(e++, this._dimension));
    const n = [];
    n.push(this._makeRotationMatrixX(-0.5 * Math.PI)), n.push(this._makeRotationMatrixX(0.5 * Math.PI)), n.push(this._makeRotationMatrixY(0.5 * Math.PI)), n.push(this._makeRotationMatrixY(-0.5 * Math.PI)), n.push(this._makeRotationMatrixZ(0.5 * Math.PI)), n.push(this._makeRotationMatrixZ(-0.5 * Math.PI));
    const r = this._dimension / 4, o = this._dimension / 2, l = -0.01, h = [], u = new _(0, 0, 0);
    let d = new _(0, 0, 0), g = new _(0, 0, 0);
    for (let I = 0; I < n.length; I++) {
      const C = this._dimension, P = n[I];
      let k = !1;
      I === n.length - 1 && (k = !0, u.z += this._dimension + 0.02), d = new _(
        0.5 * C - r,
        -0.5 * C + r,
        -0.5 * C + l
      ), g = new _(d.x + r, d.y - r, d.z), i.push(
        this._createSelectionFace(
          e++,
          d,
          g,
          P,
          k,
          u,
          h
        )
      ), d = new _(-0.5 * C, -0.5 * C + r, -0.5 * C + l), g = new _(d.x + r, d.y - r, d.z), i.push(
        this._createSelectionFace(
          e++,
          d,
          g,
          P,
          k,
          u,
          h
        )
      ), d = new _(-0.5 * C, 0.5 * C, -0.5 * C + l), g = new _(d.x + r, d.y - r, d.z), i.push(
        this._createSelectionFace(
          e++,
          d,
          g,
          P,
          k,
          u,
          h
        )
      ), d = new _(0.5 * C - r, 0.5 * C, -0.5 * C + l), g = new _(d.x + r, d.y - r, d.z), i.push(
        this._createSelectionFace(
          e++,
          d,
          g,
          P,
          k,
          u,
          h
        )
      ), d = new _(-0.5 * C + r, 0.5 * C, -0.5 * C + l), g = new _(d.x + o, d.y - r, d.z), i.push(
        this._createSelectionFace(
          e++,
          d,
          g,
          P,
          k,
          u,
          h
        )
      ), d = new _(
        -0.5 * C + r,
        -0.5 * C + r,
        -0.5 * C + l
      ), g = new _(d.x + o, d.y - r, d.z), i.push(
        this._createSelectionFace(
          e++,
          d,
          g,
          P,
          k,
          u,
          h
        )
      ), d = new _(-0.5 * C, 0.5 * C - r, -0.5 * C + l), g = new _(d.x + r, d.y - o, d.z), i.push(
        this._createSelectionFace(
          e++,
          d,
          g,
          P,
          k,
          u,
          h
        )
      ), d = new _(0.5 * C - r, 0.5 * C - r, -0.5 * C + l), g = new _(d.x + r, d.y - o, d.z), i.push(
        this._createSelectionFace(
          e++,
          d,
          g,
          P,
          k,
          u,
          h
        )
      ), d = new _(
        -0.5 * C + r,
        0.5 * C - r,
        -0.5 * C + l
      ), g = new _(d.x + o, d.y - o, d.z), i.push(
        this._createSelectionFace(
          e++,
          d,
          g,
          P,
          k,
          u,
          h
        )
      );
    }
    const y = 9;
    for (let I = 0; I < h.length; I++) {
      const C = Math.floor(I / y), P = [], k = h[I];
      for (let O = 0; O < k.length; O += 2) {
        const B = k[O], j = k[O + 1];
        for (let V = 0; V < h.length; V++) {
          if (Math.floor(V / y) === C)
            continue;
          const q = h[V];
          for (let st = 0; st < q.length; st += 2) {
            const dt = q[st], U = q[st + 1];
            this._isSameEdge(B, j, dt, U) && P.push(V);
          }
        }
      }
      this._adjacentFaces.push(P);
    }
    const m = await Promise.all(i);
    this._updateOrientationMatrices(), this._onCameraUpdate();
    const x = [];
    for (const I of m)
      x.push(Ei.Local, I);
    return this._getScEngine().setPartVisibility(x, !0, !0), this._geometryCreated = !0, t;
  }
  _createTexture(t, e) {
    const n = t.getImageData(0, 0, e, e).data, r = new ArrayBuffer(e * e * 3), o = new Uint8Array(r);
    let l = 0;
    for (let u = 0; u < n.length; u += 4)
      o[l] = n[u], o[l + 1] = n[u], o[l + 2] = n[u], l += 3;
    return this._viewer.model.createImage({
      format: _s.Rgb24,
      data: o,
      width: this._textureSize,
      height: this._textureSize
    });
  }
  /** @hidden */
  _geometryHasBeenCreated() {
    return this._geometryCreated;
  }
  /**
   * Determines whether or not a point is inside the NavCube overlay.
   * @param mousePos
   * @returns Boolean indicating whether the provided point is inside the NavCube overlay
   */
  insideOverlay(t) {
    if (!this._view)
      return !1;
    const e = this._view.overlayManager._toPixelPoint(this._viewportSize), i = this._getOverlayOffset();
    return t.x >= i.x && t.y >= i.y && t.x <= i.x + e.x && t.y <= i.y + e.y;
  }
  /** @hidden */
  _getOverlayOffset() {
    if (!this._view)
      return K.zero();
    const t = this._view.overlayManager._toPixelPoint(this._viewportSize);
    return this._view.overlayManager._getOverlayOffset(this._anchor, t);
  }
  /** @hidden */
  _getViewportSize() {
    return this._viewportSize;
  }
  /** @hidden */
  _getViewportPixelSize() {
    return this._view ? this._view.overlayManager._toPixelPoint(this._viewportSize) : K.zero();
  }
  /** @hidden */
  _onNoSelection() {
    this._enabled && this._lastSelectedNodes.length > 0 && (this._viewer.model.setNodesOpacity(this._lastSelectedNodes, 0), this._lastSelectedNodes.length = 0);
  }
  /**
   * Called when the NavCube is clicked. Realigns the view to the side/edge/corner
   * selected by `selection`, or rotates the view 90 degrees if the selection matches
   * the current view orientation, or does nothing if no side is selected.
   * @param selection
   */
  async onClickSelection(t) {
    if (console.assert(this._enabled), t === null || !t.isFaceSelection() || t.overlayIndex() !== be.NavCube) {
      this._onNoSelection();
      return;
    }
    const e = this._getFaceIndexFromNodeId(t.getNodeId());
    e < this._nodeIds.length && e > 0 && await this._setViewOrientation(e);
  }
  /**
   * Called when the NavCube is "moused over". Displays face/edge/corner that will be selected.
   * @param selection
   */
  onMoveSelection(t) {
    if (console.assert(this._enabled), t === null || !t.isFaceSelection() || t.overlayIndex() !== be.NavCube) {
      this._onNoSelection();
      return;
    }
    const e = t.getNodeId(), i = this._getFaceIndexFromNodeId(e) - 1;
    i >= 0 && e !== this._nodeIds[0] && this._viewer.pauseRendering(() => {
      const n = this._viewer.model;
      n.setNodesOpacity(this._lastSelectedNodes, 0), this._lastSelectedNodes.length = 0, this._lastSelectedNodes.push(e), console.assert(i < this._adjacentFaces.length);
      const r = this._adjacentFaces[i];
      for (const o of r) {
        const l = o + 1, h = this._getNodeIdFromFaceIndex(l);
        this._lastSelectedNodes.push(h);
      }
      n.setNodesOpacity(this._lastSelectedNodes, 1);
    });
  }
  /**
   * Returns the corresponding view orientation for each node index.
   * If the node indexes change in the future, this will need to be updated.
   */
  _getViewOrientationFromFaceIndex(t) {
    let e = Ct.Front;
    switch (t) {
      case 1:
        e = Ct.LeftBottomBack;
        break;
      case 2:
        e = Ct.LeftBottomFront;
        break;
      case 3:
        e = Ct.LeftTopFront;
        break;
      case 4:
        e = Ct.LeftTopBack;
        break;
      case 5:
        e = Ct.LeftTop;
        break;
      case 6:
        e = Ct.LeftBottom;
        break;
      case 7:
        e = Ct.LeftFront;
        break;
      case 8:
        e = Ct.LeftBack;
        break;
      case 9:
        e = Ct.Left;
        break;
      case 10:
        e = Ct.RightTopBack;
        break;
      case 11:
        e = Ct.RightTopFront;
        break;
      case 12:
        e = Ct.RightBottomFront;
        break;
      case 13:
        e = Ct.RightBottomBack;
        break;
      case 14:
        e = Ct.RightBottom;
        break;
      case 15:
        e = Ct.RightTop;
        break;
      case 16:
        e = Ct.RightFront;
        break;
      case 17:
        e = Ct.RightBack;
        break;
      case 18:
        e = Ct.Right;
        break;
      case 19:
        e = Ct.BackTopRight;
        break;
      case 20:
        e = Ct.BackBottomRight;
        break;
      case 21:
        e = Ct.BackBottomLeft;
        break;
      case 22:
        e = Ct.BackTopLeft;
        break;
      case 23:
        e = Ct.BackLeft;
        break;
      case 24:
        e = Ct.BackRight;
        break;
      case 25:
        e = Ct.BackBottom;
        break;
      case 26:
        e = Ct.BackTop;
        break;
      case 27:
        e = Ct.Back;
        break;
      case 28:
        e = Ct.FrontBottomRight;
        break;
      case 29:
        e = Ct.FrontTopRight;
        break;
      case 30:
        e = Ct.FrontTopLeft;
        break;
      case 31:
        e = Ct.FrontBottomLeft;
        break;
      case 32:
        e = Ct.FrontLeft;
        break;
      case 33:
        e = Ct.FrontRight;
        break;
      case 34:
        e = Ct.FrontTop;
        break;
      case 35:
        e = Ct.FrontBottom;
        break;
      case 36:
        e = Ct.Front;
        break;
      case 37:
        e = Ct.BottomRightFront;
        break;
      case 38:
        e = Ct.BottomLeftFront;
        break;
      case 39:
        e = Ct.BottomLeftBack;
        break;
      case 40:
        e = Ct.BottomRightBack;
        break;
      case 41:
        e = Ct.BottomBack;
        break;
      case 42:
        e = Ct.BottomFront;
        break;
      case 43:
        e = Ct.BottomLeft;
        break;
      case 44:
        e = Ct.BottomRight;
        break;
      case 45:
        e = Ct.Bottom;
        break;
      case 46:
        e = Ct.TopLeftBack;
        break;
      case 47:
        e = Ct.TopRightBack;
        break;
      case 48:
        e = Ct.TopRightFront;
        break;
      case 49:
        e = Ct.TopLeftFront;
        break;
      case 50:
        e = Ct.TopFront;
        break;
      case 51:
        e = Ct.TopBack;
        break;
      case 52:
        e = Ct.TopRight;
        break;
      case 53:
        e = Ct.TopLeft;
        break;
      case 54:
        e = Ct.Top;
        break;
      default:
        e = Ct.Front;
    }
    return e;
  }
  async _setViewOrientation(t) {
    const e = this._view;
    if (e === void 0)
      return;
    const i = this._getViewOrientationFromFaceIndex(t), n = await e.getViewOrientationCamera(
      i,
      void 0,
      this._preserveModelUp
    );
    let r = !1;
    console.assert(t - 1 >= 0), console.assert(t - 1 < this._adjacentFaces.length);
    const o = this._adjacentFaces[t - 1];
    for (const d of o)
      if (d + 1 === this._lastFaceIndex) {
        r = !0;
        break;
      }
    this._lastFaceIndex = t;
    const l = this._lastCamera !== null && this._lastCamera.equals(e.getCamera());
    if ((this._lastOrientation === i || r) && l ? this._cameraRotation = this._preserveModelUp ? (this._cameraRotation + 90) % 360 : 90 : this._cameraRotation = 0, this._lastOrientation = i, this._cameraRotation > 0) {
      const d = _.subtract(n.getPosition(), n.getTarget()).normalize(), g = mt.createFromOffAxisRotation(d, this._cameraRotation), y = n.getUp();
      g.transform(y, y), n.setUp(y);
    }
    await e.fitWorld(rs, n);
    const u = this._viewer.model.getAbsoluteRootNode();
    if (this._viewer.model.getNodeChildren(u).length === 0)
      return this._getScEngine().markCameraAsEmpty(e.id);
    this._lastCamera = e.getCamera();
  }
  _getScEngine() {
    return this._viewer._getScEngine();
  }
  async _createInstance(t, e) {
    var h;
    const i = await this._viewer.model.createMesh(t), n = new Qs(i);
    if (n.setCreationFlags(
      ee.DoNotCut | ee.DoNotExplode | ee.ExcludeBounding | ee.DoNotLight | ee.Invisible
    ), !this._view)
      throw Error("Impossible to create a navcube without an associated view");
    n.overlayId = {
      viewKey: (h = this._view) == null ? void 0 : h.id,
      overayIndex: be.NavCube
    };
    const l = (await this._getScEngine().createMeshInstance(n))[1];
    return this._instanceKeys[e] = l, l;
  }
  _createCube(t, e) {
    const i = [], n = [], r = [], o = [];
    let l = this._textWidths[0];
    for (const O of this._textWidths)
      O > l && (l = O);
    l += 10, i.push(new _(0.5 * e, 0.5 * e, 0.5 * e)), i.push(new _(-0.5 * e, 0.5 * e, -0.5 * e)), i.push(new _(-0.5 * e, 0.5 * e, 0.5 * e)), i.push(new _(0.5 * e, 0.5 * e, -0.5 * e)), i.push(new _(-0.5 * e, 0.5 * e, -0.5 * e)), i.push(new _(0.5 * e, 0.5 * e, 0.5 * e)), n.push(new _(0, 1, 0)), n.push(new _(0, 1, 0)), n.push(new _(0, 1, 0)), n.push(new _(0, 1, 0)), n.push(new _(0, 1, 0)), n.push(new _(0, 1, 0));
    const h = 60;
    let u = 22 / this._textureSize, d = (22 + h) / this._textureSize;
    u = 1 - u, d = 1 - d;
    let g = (l - this._textWidths[0]) / 2, y = -(g / this._textureSize), m = (this._textWidths[0] + g) / this._textureSize;
    r.push(new K(y, u)), r.push(new K(m, d)), r.push(new K(m, u)), r.push(new K(y, d)), r.push(new K(m, d)), r.push(new K(y, u)), o.push(new _(-0.5 * e, 0.5 * e, -0.5 * e)), o.push(new _(0.5 * e, 0.5 * e, -0.5 * e)), o.push(new _(0.5 * e, 0.5 * e, -0.5 * e)), o.push(new _(0.5 * e, 0.5 * e, 0.5 * e)), o.push(new _(0.5 * e, 0.5 * e, 0.5 * e)), o.push(new _(-0.5 * e, 0.5 * e, 0.5 * e)), o.push(new _(-0.5 * e, 0.5 * e, 0.5 * e)), o.push(new _(-0.5 * e, 0.5 * e, -0.5 * e)), i.push(new _(-0.5 * e, -0.5 * e, 0.5 * e)), i.push(new _(-0.5 * e, -0.5 * e, -0.5 * e)), i.push(new _(0.5 * e, -0.5 * e, 0.5 * e)), i.push(new _(0.5 * e, -0.5 * e, 0.5 * e)), i.push(new _(-0.5 * e, -0.5 * e, -0.5 * e)), i.push(new _(0.5 * e, -0.5 * e, -0.5 * e)), n.push(new _(0, -1, 0)), n.push(new _(0, -1, 0)), n.push(new _(0, -1, 0)), n.push(new _(0, -1, 0)), n.push(new _(0, -1, 0)), n.push(new _(0, -1, 0)), u -= h / this._textureSize, d -= h / this._textureSize, g = (l - this._textWidths[1]) / 2, y = -(g / this._textureSize), m = (this._textWidths[1] + g) / this._textureSize, r.push(new K(y, u)), r.push(new K(y, d)), r.push(new K(m, u)), r.push(new K(m, u)), r.push(new K(y, d)), r.push(new K(m, d)), o.push(new _(-0.5 * e, -0.5 * e, -0.5 * e)), o.push(new _(0.5 * e, -0.5 * e, -0.5 * e)), o.push(new _(0.5 * e, -0.5 * e, -0.5 * e)), o.push(new _(0.5 * e, -0.5 * e, 0.5 * e)), o.push(new _(0.5 * e, -0.5 * e, 0.5 * e)), o.push(new _(-0.5 * e, -0.5 * e, 0.5 * e)), o.push(new _(-0.5 * e, -0.5 * e, 0.5 * e)), o.push(new _(-0.5 * e, -0.5 * e, -0.5 * e)), i.push(new _(-0.5 * e, 0.5 * e, 0.5 * e)), i.push(new _(-0.5 * e, 0.5 * e, -0.5 * e)), i.push(new _(-0.5 * e, -0.5 * e, -0.5 * e)), i.push(new _(-0.5 * e, 0.5 * e, 0.5 * e)), i.push(new _(-0.5 * e, -0.5 * e, -0.5 * e)), i.push(new _(-0.5 * e, -0.5 * e, 0.5 * e)), n.push(new _(-1, 0, 0)), n.push(new _(-1, 0, 0)), n.push(new _(-1, 0, 0)), n.push(new _(-1, 0, 0)), n.push(new _(-1, 0, 0)), n.push(new _(-1, 0, 0)), u -= h / this._textureSize, d -= h / this._textureSize, g = (l - this._textWidths[2]) / 2, y = -(g / this._textureSize), m = (this._textWidths[2] + g) / this._textureSize, r.push(new K(y, u)), r.push(new K(y, d)), r.push(new K(m, d)), r.push(new K(y, u)), r.push(new K(m, d)), r.push(new K(m, u)), o.push(new _(-0.5 * e, 0.5 * e, -0.5 * e)), o.push(new _(-0.5 * e, 0.5 * e, 0.5 * e)), o.push(new _(-0.5 * e, 0.5 * e, 0.5 * e)), o.push(new _(-0.5 * e, -0.5 * e, 0.5 * e)), o.push(new _(-0.5 * e, -0.5 * e, 0.5 * e)), o.push(new _(-0.5 * e, -0.5 * e, -0.5 * e)), o.push(new _(-0.5 * e, -0.5 * e, -0.5 * e)), o.push(new _(-0.5 * e, 0.5 * e, -0.5 * e)), i.push(new _(0.5 * e, 0.5 * e, 0.5 * e)), i.push(new _(0.5 * e, -0.5 * e, -0.5 * e)), i.push(new _(0.5 * e, 0.5 * e, -0.5 * e)), i.push(new _(0.5 * e, 0.5 * e, 0.5 * e)), i.push(new _(0.5 * e, -0.5 * e, 0.5 * e)), i.push(new _(0.5 * e, -0.5 * e, -0.5 * e)), n.push(new _(1, 0, 0)), n.push(new _(1, 0, 0)), n.push(new _(1, 0, 0)), n.push(new _(1, 0, 0)), n.push(new _(1, 0, 0)), n.push(new _(1, 0, 0)), u -= h / this._textureSize, d -= h / this._textureSize, g = (l - this._textWidths[3]) / 2, y = -(g / this._textureSize), m = (this._textWidths[3] + g) / this._textureSize, r.push(new K(m, u)), r.push(new K(y, d)), r.push(new K(m, d)), r.push(new K(m, u)), r.push(new K(y, u)), r.push(new K(y, d)), o.push(new _(0.5 * e, 0.5 * e, -0.5 * e)), o.push(new _(0.5 * e, 0.5 * e, 0.5 * e)), o.push(new _(0.5 * e, 0.5 * e, 0.5 * e)), o.push(new _(0.5 * e, -0.5 * e, 0.5 * e)), o.push(new _(0.5 * e, -0.5 * e, 0.5 * e)), o.push(new _(0.5 * e, -0.5 * e, -0.5 * e)), o.push(new _(0.5 * e, -0.5 * e, -0.5 * e)), o.push(new _(0.5 * e, 0.5 * e, -0.5 * e)), i.push(new _(0.5 * e, -0.5 * e, -0.5 * e)), i.push(new _(-0.5 * e, -0.5 * e, -0.5 * e)), i.push(new _(-0.5 * e, 0.5 * e, -0.5 * e)), i.push(new _(0.5 * e, 0.5 * e, -0.5 * e)), i.push(new _(0.5 * e, -0.5 * e, -0.5 * e)), i.push(new _(-0.5 * e, 0.5 * e, -0.5 * e)), n.push(new _(0, 0, -1)), n.push(new _(0, 0, -1)), n.push(new _(0, 0, -1)), n.push(new _(0, 0, -1)), n.push(new _(0, 0, -1)), n.push(new _(0, 0, -1)), u -= h / this._textureSize, d -= h / this._textureSize, g = (l - this._textWidths[4]) / 2, y = -(g / this._textureSize), m = (this._textWidths[4] + g) / this._textureSize, r.push(new K(y, u)), r.push(new K(y, d)), r.push(new K(m, d)), r.push(new K(m, u)), r.push(new K(y, u)), r.push(new K(m, d)), i.push(new _(-0.5 * e, 0.5 * e, 0.5 * e)), i.push(new _(-0.5 * e, -0.5 * e, 0.5 * e)), i.push(new _(0.5 * e, -0.5 * e, 0.5 * e)), i.push(new _(-0.5 * e, 0.5 * e, 0.5 * e)), i.push(new _(0.5 * e, -0.5 * e, 0.5 * e)), i.push(new _(0.5 * e, 0.5 * e, 0.5 * e)), n.push(new _(0, 0, 1)), n.push(new _(0, 0, 1)), n.push(new _(0, 0, 1)), n.push(new _(0, 0, 1)), n.push(new _(0, 0, 1)), n.push(new _(0, 0, 1)), u -= h / this._textureSize, d -= h / this._textureSize, g = (l - this._textWidths[5]) / 2, y = -(g / this._textureSize), m = (this._textWidths[5] + g) / this._textureSize, r.push(new K(y, d)), r.push(new K(m, d)), r.push(new K(m, u)), r.push(new K(y, d)), r.push(new K(m, u)), r.push(new K(y, u));
    const x = new Cs();
    x.setFaceWinding(Zs.CounterClockwise);
    let b = [], I = [], C = [], P = 0;
    for (let O = 0; O < i.length; O++) {
      const B = i[O];
      b.push(B.x), b.push(B.y), b.push(B.z);
      const j = n[O];
      I.push(j.x), I.push(j.y), I.push(j.z);
      const V = r[O];
      if (C.push(V.x), C.push(V.y), b.length >= 18) {
        const q = [
          // y
          [0, 255, 0, 255],
          [0, 255, 0, 255],
          // x
          [255, 0, 0, 255],
          [255, 0, 0, 255],
          // z
          [0, 0, 255, 255],
          [0, 0, 255, 255]
        ][P], st = [];
        for (let dt = 0; dt < 6; dt++)
          st.push(q[0]), st.push(q[1]), st.push(q[2]), st.push(q[3]);
        x.addFaces(b, I, new Uint8Array(st), C), b = [], I = [], C = [], ++P;
      }
    }
    b = [];
    const k = new Uint8Array(4 * o.length);
    for (let O = 0; O < o.length; O++) {
      const B = o[O];
      b.push(B.x), b.push(B.y), b.push(B.z);
      const j = 4 * O;
      k[j] = this._outlineColor.r, k[j + 1] = this._outlineColor.g, k[j + 2] = this._outlineColor.b, k[j + 3] = 255;
    }
    return x.addPolyline(b, k), this._createInstance(x, t);
  }
  _onCameraUpdate() {
    if (this._view === void 0)
      return;
    const t = new Cn(), e = this._view.getCamera();
    t.setPosition(
      e.getPosition().subtract(e.getTarget()).normalize()
    ), t.setTarget(_.zero()), t.setUp(e.getUp()), t.setProjection(ri.Orthographic), t.setWidth(this._fieldSize), t.setHeight(this._fieldSize), this._view.overlayManager.setCamera(be.NavCube, t);
  }
  _updateOrientationMatrices() {
    const e = this._viewer.model.getViewAxes(), i = e.upVector.copy(), n = e.frontVector.copy(), r = _.cross(i, n.copy().scale(-1)), o = new mt();
    o.m[0] = -n.x, o.m[1] = -n.y, o.m[2] = -n.z, o.m[4] = r.x, o.m[5] = r.y, o.m[6] = r.z, o.m[8] = i.x, o.m[9] = i.y, o.m[10] = i.z;
    const l = this._getScEngine(), h = [];
    for (const u of this._instanceKeys)
      h.push(Ei.Local, u);
    l.setInstancesMatrix(h, o);
  }
  _createSelectionFace(t, e, i, n, r, o, l) {
    const h = new Cs();
    h.setFaceWinding(Zs.CounterClockwise);
    const u = [];
    this._createQuad(e, i, u, n, o, r);
    let d = [], g = [], y = [];
    for (const I of u)
      d.push(I.x), d.push(I.y), d.push(I.z), g.push(0), g.push(0), g.push(-1), y.push(this._selectionFaceColor.r), y.push(this._selectionFaceColor.g), y.push(this._selectionFaceColor.b), y.push(128);
    const m = [], x = [
      this._outlineColor.r,
      this._outlineColor.g,
      this._outlineColor.b,
      255,
      this._outlineColor.r,
      this._outlineColor.g,
      this._outlineColor.b,
      255
    ];
    h.addFaces(d, g, new Uint8Array(y)), d = [], g = [], y = [];
    let b = [];
    return r ? (b.push(u[4].x, u[4].y, u[4].z), b.push(u[5].x, u[5].y, u[5].z)) : (b.push(u[0].x, u[0].y, u[0].z), b.push(u[1].x, u[1].y, u[1].z)), h.addPolyline(b, new Uint8Array(x)), m.push(
      new _(b[0], b[1], b[2]),
      new _(b[3], b[4], b[5])
    ), b = [], b.push(u[1].x, u[1].y, u[1].z), b.push(u[2].x, u[2].y, u[2].z), h.addPolyline(b, new Uint8Array(x)), m.push(
      new _(b[0], b[1], b[2]),
      new _(b[3], b[4], b[5])
    ), b = [], b.push(u[3].x, u[3].y, u[3].z), b.push(u[4].x, u[4].y, u[4].z), h.addPolyline(b, new Uint8Array(x)), m.push(
      new _(b[0], b[1], b[2]),
      new _(b[3], b[4], b[5])
    ), b = [], r ? (b.push(u[3].x, u[3].y, u[3].z), b.push(u[2].x, u[2].y, u[2].z)) : (b.push(u[5].x, u[5].y, u[5].z), b.push(u[3].x, u[3].y, u[3].z)), h.addPolyline(b, new Uint8Array(x)), m.push(
      new _(b[0], b[1], b[2]),
      new _(b[3], b[4], b[5])
    ), b = [], l.push(m), this._createInstance(h, t);
  }
  _createQuad(t, e, i, n, r, o = !1) {
    const l = new _(t.x, t.y, t.z), h = new _(e.x, e.y, e.z);
    r && (l.x += r.x, l.y += r.y, l.z += r.z, h.x += r.x, h.y += r.y, h.z += r.z);
    const u = i.length;
    let d = new _(h.x, h.y, l.z), g = n.transform(d);
    if (i.push(g), d = new _(l.x, h.y, l.z), g = n.transform(d), i.push(g), d = new _(l.x, l.y, l.z), g = n.transform(d), i.push(g), d = new _(h.x, l.y, l.z), g = n.transform(d), i.push(g), d = new _(h.x, h.y, l.z), g = n.transform(d), i.push(g), d = new _(l.x, l.y, l.z), g = n.transform(d), i.push(g), o)
      for (let y = 0; y < 3; y++) {
        const m = u + y, x = i[u + y], b = new _(x.x, x.y, x.z), I = u + (6 - y - 1);
        i[m].x = i[I].x, i[m].y = i[I].y, i[m].z = i[I].z, i[I].x = b.x, i[I].y = b.y, i[I].z = b.z;
      }
  }
  _makeRotationMatrixX(t) {
    const e = Math.cos(t), i = Math.sin(t), n = new mt();
    return n.m[5] = e, n.m[6] = -i, n.m[9] = i, n.m[10] = e, n;
  }
  _makeRotationMatrixY(t) {
    const e = Math.cos(t), i = Math.sin(t), n = new mt();
    return n.m[0] = e, n.m[2] = i, n.m[8] = -i, n.m[10] = e, n;
  }
  _makeRotationMatrixZ(t) {
    const e = Math.cos(t), i = Math.sin(t), n = new mt();
    return n.m[0] = e, n.m[1] = -i, n.m[4] = i, n.m[5] = e, n;
  }
  _getFaceIndexFromNodeId(t) {
    for (let e = 0; e < this._nodeIds.length; e++)
      if (this._nodeIds[e] === t)
        return e;
    return -1;
  }
  _getNodeIdFromFaceIndex(t) {
    return this._nodeIds[t];
  }
  _isSameEdge(t, e, i, n) {
    const r = _.subtract(t, i).squaredLength() + _.subtract(e, n).squaredLength(), o = _.subtract(e, i).squaredLength() + _.subtract(t, n).squaredLength();
    return Math.min(r, o) < 0.03;
  }
  async _initializeTextures() {
    const t = document.createElement("canvas");
    t.width = this._textureSize, t.height = this._textureSize;
    const e = t.getContext("2d"), i = 2 * (this._fontSize + 5);
    e.beginPath(), e.rect(0, 0, this._textureSize, this._textureSize), e.fillStyle = "gray", e.fill(), e.fillStyle = "black", e.font = this._fontInfo;
    for (let r = 0; r < Gc._faceTexts.length; r++) {
      const o = Gc._faceTexts[r];
      e.fillText(o, 0, i * (r + 1));
      const l = e.measureText(o);
      this._textWidths.push(l.width);
    }
    const n = await this._createTexture(e, this._textureSize);
    this._textImageId = n;
  }
};
Gc._faceTexts = [
  "LEFT",
  "RIGHT",
  "FRONT",
  "BACK",
  "BOTTOM",
  "TOP"
];
let Qf = Gc;
class bx {
  /** @hidden */
  constructor(t) {
    this._operatorStack = [], this._operators = /* @__PURE__ */ new Map(), this._customOperatorIdCount = 0, this._customOperatorIdIndex = 1e4, this._mergeableEvents = [
      ae.MouseMove,
      ae.Mousewheel,
      ae.TouchMove,
      ae.KeyUp,
      ae.KeyDown
    ], this._eventSequencePromise = Promise.resolve(), this._events = [], this._viewer = t, this._viewer.setCallbacks({
      _resetAssemblyTreeBegin: async () => {
        const e = [];
        return this._operators.forEach((i, n) => {
          let r;
          r = this._deactivateOperator(n), r !== void 0 && e.push(r), r = this._activateOperator(n), r !== void 0 && e.push(r);
        }), Ge(e);
      }
    });
  }
  /** @hidden */
  _shutdown() {
    for (; this.pop() !== void 0; )
      ;
  }
  /** @hidden */
  _registerOperator(t, e) {
    this._operators.set(t, e);
  }
  /**
   * Registers a custom operator
   * @param operator
   * @returns operatorId
   */
  registerCustomOperator(t) {
    const e = this._customOperatorIdIndex + this._customOperatorIdCount++;
    return this._operators.set(e, t), e;
  }
  /**
   * Removes a custom operator from the registered operator list.
   * @param operatorId
   */
  unregisterCustomOperator(t) {
    t >= this._customOperatorIdIndex && this._operators.delete(t);
  }
  /**
   * Replaces the operator that the specified id refers to. Returns a boolean indicating success or failure.
   * @param previousOperatorId operator id for the operator to be replaced.
   * @param newOperatorId operator id for the new operator.
   */
  replaceOperator(t, e) {
    const i = this.getOperator(e);
    return i !== null ? (this._operators.set(t, i), !0) : !1;
  }
  /**
   * Returns the index of an operator on the stack
   * @param operatorId
   * @returns operator index or -1 if not found
   */
  indexOf(t) {
    for (let e = this.size() - 1; e >= 0; e--)
      if (this._operatorStack[e] === t)
        return e;
    return -1;
  }
  /**
   * Adds an operator on the stack if it's not already on the stack
   * @param operatorId id of the operator to add to the stack
   * @returns boolean indicating success or failure
   */
  push(t) {
    return this._isValid(t) && !this._contains(t) ? (this._operatorStack.push(t), this._activateOperator(t), !0) : !1;
  }
  /**
   * Sets a position on the stack to an operator if it's not already on the stack
   * If there is already an operator in that position, it is replaced.
   * @param operatorId id of the operator to add to the stack
   * @param position position on the stack to assign
   * @returns boolean indicating success or failure
   */
  set(t, e) {
    const i = this._operatorStack[e];
    return t === i ? !1 : this._isValid(t) && !this._contains(t) ? (this._deactivateOperator(i), this._activateOperator(t), this._operatorStack[e] = t, !0) : !1;
  }
  /**
   * Removes an operator from the top of the stack
   * @returns the operator id
   */
  pop() {
    const t = this._operatorStack.pop();
    return t !== void 0 && this._deactivateOperator(t), t;
  }
  /**
   * Removes an operator from the stack
   * @param operatorId id of the operator to remove from the stack
   */
  remove(t) {
    const e = this.indexOf(t);
    e !== -1 && (this._operatorStack.splice(e, 1), this._deactivateOperator(t));
  }
  /**
   * @returns the operator id at the top of the stack
   */
  peek() {
    return this.size() > 0 ? this._operatorStack[this.size() - 1] : ve.Invalid;
  }
  /**
   * @returns the operator id at the given position of the stack
   * Will return OperatorId.Invalid if position is out of bounds.
   */
  get(t) {
    return t < 0 || t >= this._operatorStack.length ? ve.Invalid : this._operatorStack[t];
  }
  /**
   * Removes all operators from the stack
   */
  clear() {
    for (let t = this.size() - 1; t >= 0; t--)
      this.pop();
  }
  /**
   * @returns the operator stack size
   */
  size() {
    return this._operatorStack.length;
  }
  getOperator(t) {
    return this._operators.get(t) ?? null;
  }
  async _injectEvent(t, e) {
    for (let i = this.size() - 1; i >= 0; i--) {
      const n = this._operators.get(this._operatorStack[i]);
      if (n !== void 0)
        try {
          switch (e) {
            case ae.KeyDown:
              n.onKeyDown && await n.onKeyDown(t);
              break;
            case ae.KeyUp:
              n.onKeyUp && await n.onKeyUp(t);
              break;
            case ae.MouseDown:
              n.onMouseDown && await n.onMouseDown(t);
              break;
            case ae.MouseMove:
              n.onMouseMove && await n.onMouseMove(t);
              break;
            case ae.MouseUp:
              n.onMouseUp && await n.onMouseUp(t);
              break;
            case ae.Mousewheel:
              n.onMousewheel && await n.onMousewheel(t);
              break;
            case ae.TouchStart:
              n.onTouchStart && await n.onTouchStart(t);
              break;
            case ae.TouchMove:
              n.onTouchMove && await n.onTouchMove(t);
              break;
            case ae.TouchEnd:
              n.onTouchEnd && await n.onTouchEnd(t);
              break;
            case ae.ViewOrientationChange:
              n.onViewOrientationChange && await n.onViewOrientationChange();
              break;
            default:
              $r(e);
          }
        } catch (r) {
          r instanceof Oo || console.log(r);
        }
      if (t.getHandled()) {
        (e === ae.MouseUp || e === ae.TouchEnd) && await this._stopInteraction();
        break;
      }
    }
  }
  async injectEvent(t, e) {
    return this._addOrMergeEventToQueue(t, e, t.viewKey), this._eventSequencePromise = this._eventSequencePromise.then(async () => {
      await this._injectNextEvent();
    }), this._eventSequencePromise;
  }
  _addOrMergeEventToQueue(t, e, i) {
    let n = !1;
    if (this._mergeableEvents.indexOf(e) !== -1)
      for (let r = 0; r < this._events.length; r++) {
        const o = this._events[r];
        if (!(e !== o.eventType || i !== o.event.viewKey) && !((e === ae.KeyDown || e === ae.KeyUp) && t.getKeyCode() !== o.event.getKeyCode()) && !(e === ae.TouchMove && t.getId() !== o.event.getId())) {
          o.event = t, n = !0;
          break;
        }
      }
    n || this._events.push({ event: t, eventType: e });
  }
  async _injectNextEvent() {
    const t = this._events.shift();
    t !== void 0 && await this._injectEvent(t.event, t.eventType);
  }
  async _stopInteraction() {
    const t = [];
    for (let e = this.size() - 1; e >= 0; e--) {
      const i = this._operators.get(this._operatorStack[e]);
      if (i != null && i.stopInteraction) {
        const n = i.stopInteraction();
        n !== void 0 && t.push(n);
      }
    }
    return Ge(t);
  }
  /** @hidden */
  _injectViewOrientationChangeEvent() {
    for (let t = this.size() - 1; t >= 0; t--) {
      const e = this._operators.get(this._operatorStack[t]);
      e != null && e.onViewOrientationChange && e.onViewOrientationChange();
    }
  }
  _isValid(t) {
    return this._operators.has(t) || t === ve.None;
  }
  _contains(t) {
    return this.indexOf(t) !== -1;
  }
  _activateOperator(t) {
    const e = this._operators.get(t);
    if (e != null && e.onActivate)
      return e.onActivate();
  }
  _deactivateOperator(t) {
    const e = this._operators.get(t);
    if (e != null && e.onDeactivate)
      return e.onDeactivate();
  }
}
class xx {
  /* @hidden */
  constructor(t, e, i, n) {
    this._activeSheetId = null, this._backgroundSheetMeshId = null, this._sheetIds = [null, null, null], this._backgroundSheetEnabled = !1, this._backgroundSelectionEnabled = !1, this._backgroundColor = new vt(180, 180, 180), this._sheetColor = vt.white(), this._sheetShadowColor = new vt(75, 75, 75), this._viewer = t, this._engine = e, this._callbackManager = i;
    const r = async () => {
      if (!this._viewer.model.isDrawing())
        return;
      const o = this._viewer.sheetManager.getActiveSheetId();
      if (o == null) {
        await this.deactivateSheets(!1);
        const l = this.getSheetIds();
        this.get3DNodes().length === 0 && l.length > 0 && await this.setActiveSheetId(l[0], !0, !0);
      } else
        await this._activateSheetId(o, !0, !0);
    };
    this._viewer.setCallbacks({
      _modelStructureHeaderParsed: async () => {
        if (this._viewer.model.isDrawing() && !n)
          return this.setBackgroundSheetEnabled(!0);
      },
      _firstModelLoaded: async () => {
        await r();
      },
      _resetAssemblyTreeBegin: async () => {
        await this.setBackgroundSheetEnabled(!1), await this.setBackgroundSelectionEnabled(!1), this._activeSheetId = null, this._backgroundSheetMeshId = null;
        const o = this._viewer.view, l = o.getBackgroundColor();
        o.setBackgroundColor(l.top, l.bottom);
      },
      _resetDrawing: async () => {
        await r();
      }
    });
  }
  /**
   * @returns an array of 2D [[SheetId]]s.
   */
  getSheetIds() {
    const t = this._viewer.model, e = (n) => {
      let r = [];
      const o = t.getNodeChildren(n);
      for (const l of o)
        r = r.concat(e(l));
      return t.getNodeType(n) === Le.DrawingSheet && r.push(n), r;
    }, i = t.getAbsoluteRootNode();
    return e(i);
  }
  /**
   * Returns Ids of sheet nodes which contain 3D data.
   */
  get3DNodes() {
    const t = this._viewer.model, e = t.getAbsoluteRootNode(), i = t.getNodeChildren(e), n = t.getNodeChildren(i[0]), r = t.getNodeChildren(n[0]), o = [];
    for (const l of r)
      t.getNodeType(l) !== Le.DrawingSheet && o.push(l);
    return o;
  }
  /**
   * Deactivate sheets and only display 3D content
   * @param triggerCallback triggers a "sheetDeactivated" callback if true
   * @param ignoreFitNodes camera will not fit nodes if true
   * @returns promise that resolves when the operation has completed
   */
  async deactivateSheets(t = !0, e = !1) {
    this._activeSheetId = null, this._viewer.pauseRendering();
    const i = this.get3DNodes(), n = e ? !1 : i.length > 0;
    await this._viewer.view.isolateNodes(i, 0, n), await this._refreshBackgroundSheets();
    const r = this._viewer.view, o = r.getBackgroundColor();
    r.setBackgroundColor(o.top, o.bottom), this._viewer.resumeRendering(), t && this._callbackManager.trigger("sheetDeactivated");
  }
  /**
   * Sets the id of the current active sheet
   * @param activeSheetId id of the sheet which will be activated.
   * @param isolateNodes indicates whether the nodes in the sheet should be isolated
   * @param fitNodes indicates whether a fit world should be performed after isolating the nodes.  Note: This parameter has no effect if `isolateNodes` is `false`.
   * @returns promise that resolves when the operation has completed
   */
  async setActiveSheetId(t, e = !0, i = !0) {
    this._activeSheetId !== t && (this._activeSheetId = t, await this._activateSheetId(t, e, i));
  }
  async _activateSheetId(t, e, i) {
    await this._markupManager._setActiveMarkupView(this._viewer.view, null), e && (this._viewer.pauseRendering(), await this._viewer.view.isolateNodes([t], 0, i), await this._refreshBackgroundSheets(), this._viewer.resumeRendering()), this._callbackManager.trigger("sheetActivated", this._activeSheetId);
  }
  /**
   * @returns gets the id of the current active sheet. null if none has been set.
   */
  getActiveSheetId() {
    return this._activeSheetId;
  }
  /**
   * @returns true if a drawing sheet is activated, false otherwise
   */
  isDrawingSheetActive() {
    return this._viewer.model.isDrawing() && this._activeSheetId !== null;
  }
  /** @hidden */
  setMarkupManager(t) {
    this._markupManager = t;
  }
  async _createBackgroundSheetMesh() {
    const t = [
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      1,
      0,
      0,
      1,
      1,
      0
    ], e = [
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      1,
      0,
      0,
      1
    ], i = new Cs();
    return i.addFaces(t, e), i.setBackfacesEnabled(!0), this._viewer.model.createMesh(i);
  }
  _createBackgroundSheetMatrix(t, e) {
    const i = t.min, n = t.max, r = this._viewer.view.getCamera(), o = r.getPosition(), l = r.getTarget(), h = _.subtract(l, o);
    let u = n.x - i.x, d = n.y - i.y;
    const g = Math.max(0.1 * u, 0.1 * (n.z - i.z)), y = i.x + 0.5 * u, m = i.y + 0.5 * d, x = 0.05, b = Math.max(u * x, d * x);
    u += b, d += b;
    let I = y - 0.5 * u, C = m - 0.5 * d, P = h.z > 0 ? n.z + g : i.z - g;
    if (e) {
      const O = r.getUp();
      let B = 0.3 * b;
      I += B, O.y > 0 && (B = -B), C += B, P += h.z > 0 ? g : -g;
    }
    const k = new mt();
    return k.setTranslationComponent(I, C, P), k.setScaleComponent(u, d, 1), k;
  }
  async _createBackgroundSheetInstance(t, e, i, n, r, o) {
    let l = ee.DoNotExplode | ee.DoNotCut | ee.OverrideSceneVisibility | ee.DoNotLight | ee.DoNotOutlineHighlight | ee.AlwaysDraw | ee.ExcludeBounding;
    o || (l |= ee.DoNotSelect);
    const h = new Qs(
      t,
      i,
      e,
      n,
      null,
      null,
      l
    ), u = await this._viewer.model.createMeshInstance(h, null, !1, !0);
    return this._viewer.model.setNodesOpacity([u], r), u;
  }
  /**
   * Deletes background sheets described by sheetTypes, but only if they exist.
   * @param sheetTypes An array with the sheets to delete. Omitting will delete all sheets.
   */
  async _deleteBackgroundSheetInstances(t = [
    0,
    2,
    1
    /* Shadow */
  ]) {
    const e = [];
    for (const i of t) {
      const n = this._sheetIds[i];
      n !== null && (this._sheetIds[i] = null, e.push(n));
    }
    if (e.length > 0)
      return this._viewer.model.deleteMeshInstances(e);
  }
  /**
   *  Creates the sheet-type into our array, or if the sheet already exists updates the necessary state values
   */
  async _createOrUpdateSheet(t, e, i, n, r, o) {
    const l = this._viewer.model;
    if (this._sheetIds[t] === null)
      return this._sheetIds[t] = await this._createBackgroundSheetInstance(
        this._backgroundSheetMeshId,
        e,
        i,
        n,
        r,
        o
      ), Promise.resolve();
    {
      const h = this._sheetIds[t];
      return l.setNodesFaceColor([h], n), l.setNodesOpacity([h], r), o !== null && l.setInstanceModifier(Qi.DoNotSelect, [h], !o), l.setNodeMatrix(h, i, !0);
    }
  }
  /**
   * Refreshes the background sheets used for 2D drawings.
   */
  async _refreshBackgroundSheets() {
    const t = this._viewer.model;
    if (!this.isDrawingSheetActive())
      return this._backgroundSelectionEnabled = !1, this._deleteBackgroundSheetInstances();
    this._backgroundSheetMeshId === null && (this._backgroundSheetMeshId = await this._createBackgroundSheetMesh());
    const e = await t.getModelBounding(!0, !1), i = this._createBackgroundSheetMatrix(e, !1), n = [];
    this._backgroundSelectionEnabled ? await this._createOrUpdateSheet(
      2,
      "2d_drawing_background_selection_sheet",
      i,
      vt.black(),
      0,
      !0
    ) : n.push(
      2
      /* Selection */
    );
    for (const r of this._viewer.views)
      this._engine.setBackgroundGradient(r.id, this._backgroundColor, this._backgroundColor);
    if (this._backgroundSheetEnabled) {
      const r = this._createBackgroundSheetMatrix(e, !0);
      await this._createOrUpdateSheet(
        0,
        "2d_drawing_background_sheet",
        i,
        this._sheetColor,
        1,
        !1
      ), await this._createOrUpdateSheet(
        1,
        "2d_drawing_background_shadow_sheet",
        r,
        this._sheetShadowColor,
        1,
        !1
      );
    } else
      n.push(
        0,
        1
        /* Shadow */
      );
    if (n.length > 0)
      return this._deleteBackgroundSheetInstances(n);
  }
  /**
   * Sets custom sheet colors.
   * @param backgroundColor viewer background color.
   * @param sheetColor sheet background color.
   * @param sheetShadowColor sheet shadow effect color.
   */
  setSheetColors(t, e, i) {
    return this._backgroundColor = t.copy(), this._sheetColor = e.copy(), this._sheetShadowColor = i.copy(), this._refreshBackgroundSheets();
  }
  /**
   * Gets the sheet Background Color.
   */
  getSheetBackgroundColor() {
    return this._backgroundColor;
  }
  /**
   * Gets the Sheet Color.
   */
  getSheetColor() {
    return this._sheetColor;
  }
  /**
   * Gets the Sheet Shadow Color.
   */
  getSheetShadowColor() {
    return this._sheetShadowColor;
  }
  /**
   * Enables or disables the background sheet used for 2D drawings.
   */
  async setBackgroundSheetEnabled(t) {
    t !== this._backgroundSheetEnabled && (this._backgroundSheetEnabled = t, this._viewer.pauseRendering(), await this._refreshBackgroundSheets(), this._viewer.resumeRendering());
  }
  /**
   * Gets the current state of the background sheet.
   * @returns `true` if enabled and `false` otherwise.
   */
  getBackgroundSheetEnabled() {
    return this._backgroundSheetEnabled;
  }
  /**
   * Sets whether the background for 2D drawings is selectable. By default it is not.
   * 2D drawings have an invisible selection plane with a single face. Note that this setting
   * is unaffected by the background-sheet enable setting.
   */
  async setBackgroundSelectionEnabled(t) {
    this.isDrawingSheetActive() || (t = !1), t !== this._backgroundSelectionEnabled && (this._backgroundSelectionEnabled = t, this._viewer.pauseRendering(), await this._refreshBackgroundSheets(), this._viewer.resumeRendering());
  }
  /** Gets the current state of the background sheet.
   * @returns `true` if enabled and `false` otherwise.
   */
  getBackgroundSelectionEnabled() {
    return this._backgroundSelectionEnabled;
  }
  /**
   * Enables a visual comparison of two drawing sheets. The nodes specified
   * by `sheetId1` are filled with one color, the nodes specified by
   * `sheetId2` with another color, and overlapping areas are filled
   * with a third color.
   *
   * See [[endSheetComparison]], [[View.startComparison]].
   *
   * @param sheetId1 the drawing sheet to compare against `sheetId2`
   * @param sheetId2 the drawing sheet to compare against `sheetId1`
   * @param config settings controlling the behavior of the comparison
   */
  async startComparison(t, e, i) {
    const n = this._viewer.view;
    n.startComparison([t], [e], i), await this.setActiveSheetId(t, !1, !1), await n.isolateNodes([t, e], 0, !0), await this._refreshBackgroundSheets();
  }
  /**
   * Disables a visual comparison of two drawing sheets enabled by
   * [[startSheetComparison]]. The `Promise` returned by that function
   * should be waited upon before calling [[endSheetComparison]].
   */
  async endComparison() {
    this._activeSheetId !== null && (await this.setActiveSheetId(this._activeSheetId, !0, !1), this._viewer.view.endComparison());
  }
}
class Ix {
  /**
   * Creates a new SnapshotConfig object.
   */
  constructor(t = 0, e = 0, i = Oc.All, n = Me.Default) {
    this.viewKey = n, this.width = t, this.height = e, this.layers = i;
  }
}
class Xp {
  constructor() {
    this.svgXmlPrologEnabled = !0, this.svgBackgroundCssColor = "", this.silhouettesEnabled = !0, this.linesDrawModelLinesEnabled = !0, this.linesStrokeWidth = 20, this.linesCssColor = "#000000", this.linesClipProximityToPlane = 5.5, this.linesClipZNudgeFactor = 5.5, this.polygonsForceDrawCssColor = "", this.logProgress = !1, this.logDiagnostics = !1;
  }
}
class jy {
  constructor(t, e) {
    this.top = t, this.bottom = e;
  }
}
class Cx {
  constructor(t, e) {
    this._callbackManager = t, this._operatorManager = e, this._contextEventChecker = new Sx(this._callbackManager);
  }
  injectMouseDownEvent(t, e, i, n, r, o) {
    const l = new Wr(
      t,
      e,
      i,
      n,
      r,
      mr.Down,
      o
    ), h = ae.MouseDown;
    this._callbackManager.trigger("_inputInteraction", l, h), this._operatorManager.injectEvent(l, h), this._contextEventChecker.onMouseDownEvent(l);
  }
  injectMouseMoveEvent(t, e, i, n, r, o) {
    const l = new Wr(
      t,
      e,
      i,
      n,
      r,
      mr.Move,
      o
    ), h = ae.MouseMove;
    this._callbackManager.trigger("_inputInteraction", l, h), this._operatorManager.injectEvent(l, h);
  }
  injectMouseUpEvent(t, e, i, n, r, o) {
    const l = new Wr(t, e, i, n, r, mr.Up, o), h = ae.MouseUp;
    this._callbackManager.trigger("_inputInteraction", l, h), this._operatorManager.injectEvent(l, h), this._contextEventChecker.onMouseUpEvent(l);
  }
  injectMousewheelEvent(t, e, i, n, r, o) {
    const l = new W_(
      t,
      e,
      i,
      n,
      r,
      mr.Wheel,
      o
    ), h = ae.Mousewheel;
    this._callbackManager.trigger("_inputInteraction", l, h), this._operatorManager.injectEvent(l, h);
  }
  injectKeyDownEvent(t, e, i) {
    const n = new Uf(t, e, Df.Down, i), r = ae.KeyDown;
    this._callbackManager.trigger("_inputInteraction", n, r), this._operatorManager.injectEvent(n, r);
  }
  injectKeyUpEvent(t, e, i) {
    const n = new Uf(t, e, Df.Up, i), r = ae.KeyUp;
    this._callbackManager.trigger("_inputInteraction", n, r), this._operatorManager.injectEvent(n, r);
  }
  injectTouchStartEvent(t, e, i, n, r) {
    const o = new Ou(t, e, i, n, Eu.Start, r), l = ae.TouchStart;
    this._callbackManager.trigger("_inputInteraction", o, l), this._operatorManager.injectEvent(o, l), this._contextEventChecker.onTouchStartEvent(o);
  }
  injectTouchMoveEvent(t, e, i, n, r) {
    const o = new Ou(t, e, i, n, Eu.Start, r), l = ae.TouchMove;
    this._callbackManager.trigger("_inputInteraction", o, l), this._operatorManager.injectEvent(o, l), this._contextEventChecker.onTouchMoveEvent(o);
  }
  injectTouchEndEvent(t, e, i, n, r) {
    const o = new Ou(t, e, i, n, Eu.End, r), l = ae.TouchEnd;
    this._callbackManager.trigger("_inputInteraction", o, l), this._operatorManager.injectEvent(o, l), this._contextEventChecker.onTouchEndEvent(o);
  }
  injectViewOrientationChangeEvent(t) {
    this._operatorManager._injectViewOrientationChangeEvent();
  }
}
class Sx {
  constructor(t) {
    this._contextMenuMouseButton = Ee.Right, this._contextMenuPositionStart = K.zero(), this._touchTimer = new Xo(), this._activeTouchCount = 0, this._initialPosition = K.zero(), this._callbackManager = t;
  }
  onMouseDownEvent(t) {
    t.getHandled() || this._contextMenuPositionStart.assign(t.getPosition());
  }
  onMouseUpEvent(t) {
    if (!t.getHandled()) {
      const e = t.getPosition();
      t.getButton() === this._contextMenuMouseButton && this._contextMenuPositionStart.equals(e) && this._callbackManager.trigger("contextMenu", e, t.getModifiers());
    }
  }
  onTouchStartEvent(t) {
    const e = t.getPosition().copy();
    this._activeTouchCount === 0 && (this._initialPosition = e), ++this._activeTouchCount, t.getHandled() || this._touchTimer.set(600, () => {
      this._callbackManager.trigger("contextMenu", e, Ci.None);
    });
  }
  onTouchMoveEvent(t) {
    if (!this._touchTimer.isIdle(Dn.BeforeAction)) {
      const e = K.subtract(this._initialPosition, t.getPosition()), i = Math.abs(e.squaredLength()), n = window.outerHeight * 0.02, r = n * n;
      i > r && this._touchTimer.clear();
    }
  }
  onTouchEndEvent(t) {
    this._activeTouchCount > 0 && --this._activeTouchCount, this._touchTimer.clear();
  }
}
class Px {
  static calculate(t, e, i, n) {
    let r;
    const o = 2 / (e + 2 * i + n);
    return t <= e ? r = this._PA(t, o, e) : t >= e && t <= e + i ? r = this._PA(t, o, e) : r = this._PC(t, o, e, i, n), r = Math.min(r, 1), r;
  }
  static _PA(t, e, i) {
    return t * t * 0.5 * e / i;
  }
  static _PB(t, e, i) {
    return this._PA(i, e, i) + (t - i) * e;
  }
  static _PC(t, e, i, n, r) {
    return this._PB(i + n, e, i) + (t - (i + n)) * e * (1 - 0.5 * (t - (i + n)) / r);
  }
}
class kx {
  constructor(t, e, i, n, r) {
    this._completeCallback = null, this._startTime = null, this._progress = 0, this._positionMoveDelta = null, this._targetMoveDelta = null, this._interpolationUsesRotation = !1, this._beginQuaternion = null, this._endQuaternion = null, this._viewVectorLength = 0, this._viewVectorLengthDelta = 0, this._fieldWidthDelta = 0, this._fieldHeightDelta = 0, this._beginCam = t.copy(), this._endCam = e.copy();
    const o = _.subtract(
      this._endCam.getTarget(),
      this._endCam.getPosition()
    ).normalize(), l = this._endCam.getUp().normalize(), h = _.cross(l, o), u = _.cross(o, h);
    this._endCam.setUp(u.normalize()), this._completeCallback = n, this._duration = i, this._view = r;
  }
  isComplete() {
    return this._progress >= 1;
  }
  getCallback() {
    return this._completeCallback;
  }
  stop() {
  }
  start() {
    this._startTime = Date.now(), this._progress = 0, this._init(), this._view.getProjectionMode() !== this._endCam.getProjection() && this._view.setProjectionMode(this._endCam.getProjection());
  }
  update() {
    if (this._startTime === null)
      return;
    let e = (Date.now() - this._startTime) / this._duration;
    e = Math.min(e, 1), e = Math.max(e, 0), e = Px.calculate(e, 0.49, 0.02, 0.49), e = Math.min(e, 1), e = Math.max(e, 0);
    const i = _.scale(this._positionMoveDelta, e), n = _.scale(this._targetMoveDelta, e), r = this._beginCam.getUp();
    let o = _.add(this._beginCam.getPosition(), i);
    const l = _.add(this._beginCam.getTarget(), n), h = this._beginCam.getWidth() + e * this._fieldWidthDelta, u = this._beginCam.getHeight() + e * this._fieldHeightDelta;
    if (this._interpolationUsesRotation) {
      const g = this._viewVectorLength + this._viewVectorLengthDelta * e, y = Zn.interpolate(this._beginQuaternion, this._endQuaternion, e), m = Zn.toMatrix(y);
      o = new _(
        l.x - m.m[8] * g,
        l.y - m.m[9] * g,
        l.z - m.m[10] * g
      ), r.set(m.m[4], m.m[5], m.m[6]);
    }
    const d = Cn.create(
      o,
      l,
      r,
      this._endCam.getProjection(),
      h,
      u,
      this._endCam.getNearLimit()
    );
    this._view.setCamera(d), this._progress = e, this._progress >= 1 && this._view.setCamera(this._endCam);
  }
  /**
   * Returns the transpose of the camera's view matrix without the
   * translation component and with the x- and z- axes flipped.
   *
   * Reproduced here because the public version is deprecated.
   */
  getMatrixFromCamera(t) {
    const e = _.subtract(t.getTarget(), t.getPosition()).normalize(), i = t.getUp().normalize(), n = _.cross(i, e), r = _.cross(e, n);
    return mt.createFromBasis(n, r, e);
  }
  _init() {
    const t = _.subtract(
      this._beginCam.getTarget(),
      this._beginCam.getPosition()
    ), e = _.subtract(this._endCam.getTarget(), this._endCam.getPosition()), i = t.length(), n = e.length() - i;
    t.normalize(), e.normalize();
    const r = _.subtract(t, e), o = _.subtract(this._endCam.getUp(), this._beginCam.getUp());
    let l = !0;
    r.length() < 1e-4 && o.length() < 1e-4 && (l = !1);
    let h = null, u = null;
    if (l) {
      const d = this.getMatrixFromCamera(this._beginCam), g = this.getMatrixFromCamera(this._endCam);
      h = Zn.createFromMatrix(d), u = Zn.createFromMatrix(g);
      const y = Zn.subtract(h, u).magnitudeSquared();
      Zn.add(h, u).magnitudeSquared() < y && u.negate();
    }
    this._interpolationUsesRotation = l, this._beginQuaternion = h, this._endQuaternion = u, this._viewVectorLength = i, this._viewVectorLengthDelta = n, this._positionMoveDelta = _.subtract(
      this._endCam.getPosition(),
      this._beginCam.getPosition()
    ), this._targetMoveDelta = _.subtract(this._endCam.getTarget(), this._beginCam.getTarget()), this._fieldWidthDelta = this._endCam.getWidth() - this._beginCam.getWidth(), this._fieldHeightDelta = this._endCam.getHeight() - this._beginCam.getHeight();
  }
}
class Mx {
  constructor() {
    this._obscuredLineColor = vt.black(), this._obscuredLineOpacity = 0.2, this._visibleLineColor = vt.black(), this._visibleLineOpacity = 1, this._backgroundColorTop = vt.white(), this._backgroundColorBottom = vt.white();
  }
  /**
   * Returns the `Color` used for rendering obscured lines.
   * @returns The color used for obscured lines.
   */
  getObscuredLineColor() {
    return this._obscuredLineColor.copy();
  }
  /**
   * Sets the `Color` used for rendering obscured lines.
   * @param color The color used for obscured lines.
   */
  setObscuredLineColor(t) {
    this._obscuredLineColor.assign(t);
  }
  /**
   * Returns the opacity used for rendering obscured lines.
   * @returns The opacity used for obscured lines.
   */
  getObscuredLineOpacity() {
    return this._obscuredLineOpacity;
  }
  /**
   * Sets the opacity used for rendering obscured lines.
   * @param opacity The opacity used for obscured lines.
   */
  setObscuredLineOpacity(t) {
    0 <= t && t <= 1 && (this._obscuredLineOpacity = t);
  }
  /**
   * Gets the `Color` used for rendering visible lines.
   * @returns The color used for visible lines.
   */
  getVisibleLineColor() {
    return this._visibleLineColor.copy();
  }
  /**
   * Sets the `Color` used for rendering visible lines.
   * @param color The color used for visible lines.
   */
  setVisibleLineColor(t) {
    this._visibleLineColor.assign(t);
  }
  /**
   * Gets the opacity used for rendering visible lines.
   * @returns The opacity used for visible lines.
   */
  getVisibleLineOpacity() {
    return this._visibleLineOpacity;
  }
  /**
   * Sets the opacity used for rendering visible lines.
   * @param opacity The opacity used for visible lines.
   */
  setVisibleLineOpacity(t) {
    0 <= t && t <= 1 && (this._visibleLineOpacity = t);
  }
  /**
   * Gets the colors used for the background in hidden line rendering.
   * @returns The background colors used for hidden line.
   */
  getBackgroundColor() {
    const t = this._backgroundColorTop !== null ? this._backgroundColorTop.copy() : null, e = this._backgroundColorBottom !== null ? this._backgroundColorBottom.copy() : null;
    return new jy(t, e);
  }
  /**
   * Sets the background color in hidden line rendering to a gradient interpolating from the top to bottom color.
   * For a solid color, the top and bottom color should have the same values.
   * To enable a transparent background, pass null to the parameters of this function.
   *
   * @param top the top color for the the background gradient, null for transparent.
   * @param bottom the bottom color for the the background gradient, null for transparent.
   */
  setBackgroundColor(t = null, e = null) {
    this._backgroundColorTop = t !== null ? t.copy() : null, this._backgroundColorBottom = e !== null ? e.copy() : null;
  }
}
class Ex extends go {
  constructor(t) {
    super(), this._position = new K(10, 10), this._nextItemPosition = K.zero(), this._statItemOffset = new K(5, 5), this._maxStatWidth = 0, this._viewer = t, this._backgroundPanel = new vd(this._position, new K(300, 100)), this._backgroundPanel.setFillColor(vt.white()), this._backgroundPanel.setStrokeWidth(0), this._statsText = new Y_();
  }
  draw() {
    this._updateBackgroundSize();
    const t = this._viewer.markupManager.getRenderer();
    t.drawRectangle(this._backgroundPanel), t.drawTexts(this._statsText);
  }
  clearStatsText() {
    this._statsText.clear(), this._nextItemPosition.assign(this._position);
  }
  setPosition(t) {
    this._position.assign(t), this._backgroundPanel.setPosition(this._position);
  }
  addStatistic(t, e) {
    const i = K.add(this._nextItemPosition, this._statItemOffset), n = `${t}: ${e}`;
    this._statsText.addString(n, i), this._nextItemPosition.y += this._statsText.getFontSize();
  }
  _updateBackgroundSize() {
    const t = this._viewer.markupManager.getRenderer(), e = this._statsText.getStrings(), i = this._statsText.getFontSize();
    for (const o of e) {
      const l = t.measureText(o.text, this._statsText);
      this._maxStatWidth = Math.max(this._maxStatWidth, l.x);
    }
    const n = 2 * this._statItemOffset.x + this._maxStatWidth, r = e.length * (i + this._statItemOffset.y);
    this._backgroundPanel.setSize(new K(n, r));
  }
}
class Wy {
  constructor() {
    this.total_element_count = 0, this.total_triangle_count = 0;
  }
}
class Ax {
  constructor(t, e) {
    this._statisticsDisplayHandle = null, this._statistics = new Wy(), this._viewer = e, this._callbackManager = t, this._callbackManager.bind({
      frameDrawn: async () => {
        await this.update();
      }
    }), this._statisticsDisplay = new Ex(this._viewer);
  }
  async update() {
    const t = await this._viewer.getStatistics();
    this._statistics = t, this._statisticsDisplay.clearStatsText();
    const e = Object.keys(this._statistics);
    for (const i of e) {
      const n = i, r = this._statistics[n];
      this._statisticsDisplay.addStatistic(n, r.toString());
    }
  }
  isShown() {
    return this._statisticsDisplayHandle !== null;
  }
  getStatistics() {
    return this._statistics;
  }
  async showDisplay() {
    this.isShown() || (await this.update(), this._statisticsDisplayHandle = this._viewer.markupManager.registerMarkup(
      this._statisticsDisplay,
      this._viewer.view
    ));
  }
  hideDisplay() {
    this.isShown() && (this._viewer.markupManager.unregisterMarkup(
      this._statisticsDisplayHandle,
      this._viewer.view
    ), this._statisticsDisplayHandle = null);
  }
}
class Tx {
  constructor() {
    this.left = 0, this.top = 0;
  }
}
const Vi = class Vi {
  constructor(t, e, i) {
    this._isIE = !1, this._isFirefox = !1, this._canvas = null, this._canvasEventFunctions = /* @__PURE__ */ new Map(), this._documentEventFunctions = /* @__PURE__ */ new Map(), this._pointerEventsEnabled = !0, this._processInput = !1, this._eventsBound = !1, this._dragStarted = !1, this._captureInput = !1, this._elementOffset = new Tx(), this._pointerUp = !1, this._buttons = ys.None, this._viewKey = t, this._eventDispatcher = e, this._timeoutMonitor = i, this._document = document;
    const n = navigator.userAgent.toLowerCase();
    this._isIE = n.indexOf("trident") >= 0 || n.indexOf("edge") >= 0, this._isFirefox = n.indexOf("firefox") > -1;
  }
  _tryLockEventDispatcher() {
    return !Vi._activeEventDispatcherLocked || Vi._activeEventDispatcher === this._eventDispatcher ? (this._calculateElementOffset(), Vi._activeEventDispatcher = this._eventDispatcher, Vi._activeOffset = this._elementOffset, Vi._activeEventDispatcherLocked = !0, !0) : !1;
  }
  _unlockEventDispatcher() {
    Vi._activeEventDispatcherLocked = !1;
  }
  shutdown() {
    this.unbindEvents();
  }
  setDocument(t) {
    this._unbindDocumentEvents(), this._document = t, this._initDocumentEvents();
  }
  setOptions(t) {
    t.hasOwnProperty("usePointerEvents") && this.setPointerEventsEnabled(!!t.usePointerEvents);
  }
  elementResize() {
    this._calculateElementOffset();
  }
  setPointerEventsEnabled(t) {
    this._pointerEventsEnabled = t;
  }
  getPointerEventsEnabled() {
    return this._pointerEventsEnabled;
  }
  _browserSupportsPointerEvents() {
    return window.hasOwnProperty("PointerEvent");
  }
  _usePointerEvents() {
    return this._browserSupportsPointerEvents() && this._pointerEventsEnabled && this._isIE;
  }
  _calculateElementOffset() {
    if (this._canvas !== null) {
      const t = this._canvas.getBoundingClientRect();
      this._elementOffset.left = t.left, this._elementOffset.top = t.top;
    }
  }
  _initDocumentEvents() {
    this._usePointerEvents() ? (this._bindDocumentEvent("pointermove", (t) => {
      this._processDocumentPointerMove(t);
    }), this._bindDocumentEvent("pointerup", (t) => {
      this._processDocumentPointerUp(t);
    })) : (this._bindDocumentEvent("mousemove", (t) => {
      this._processDocumentMouseMove(t);
    }), this._bindDocumentEvent("mouseup", (t) => {
      this._processDocumentMouseUp(t);
    }));
  }
  _initCanvasEvents() {
    this._usePointerEvents() ? (this._bindCanvasEvent("pointerdown", (t) => {
      this._processPointerDown(t);
    }), this._bindCanvasEvent("pointermove", (t) => {
      this._processPointerMove(t);
    }), this._bindCanvasEvent("pointerup", (t) => {
      this._processPointerUp(t);
    }), this._bindCanvasEvent("pointerenter", (t) => {
      this._processPointerEnter(t);
    }), this._bindCanvasEvent("pointerleave", (t) => {
      this._processPointerLeave(t);
    })) : (this._bindCanvasEvent("mousedown", (t) => {
      this._processMouseDown(t);
    }), this._bindCanvasEvent("mousemove", (t) => {
      this._processMouseMove(t);
    }), this._bindCanvasEvent("mouseup", (t) => {
      this._processMouseUp(t);
    }), this._bindCanvasEvent("mouseenter", (t) => {
      this._processMouseEnter(t);
    }), this._bindCanvasEvent("mouseleave", (t) => {
      this._processMouseLeave(t);
    }), this._bindCanvasEvent("touchstart", (t) => {
      this._processTouchStart(t);
    }), this._bindCanvasEvent("touchmove", (t) => {
      this._processTouchMove(t);
    }), this._bindCanvasEvent("touchend", (t) => {
      this._processTouchEnd(t);
    }), this._bindCanvasEvent("touchcancel", (t) => {
      this._processTouchEnd(t);
    })), this._isFirefox ? this._bindCanvasEvent("DOMMouseScroll", (t) => {
      this._processMousewheel(t);
    }) : this._bindCanvasEvent("mousewheel", (t) => {
      this._processMousewheel(t);
    }), this._bindCanvasEvent("keydown", (t) => {
      this._processKeyDownEvent(t);
    }), this._bindCanvasEvent("keyup", (t) => {
      this._processKeyUpEvent(t);
    });
  }
  bindEvents(t) {
    this._eventsBound || (this._canvas = t, this.elementResize(), this._processInput = !0, this._initCanvasEvents(), this._initDocumentEvents(), this._eventsBound = !0);
  }
  _bindDocumentEvent(t, e) {
    if (this._document === null)
      return;
    const i = this._documentEventFunctions.get(t);
    i !== void 0 && this._document.removeEventListener(t, i), this._documentEventFunctions.set(t, e), this._document.addEventListener(t, e);
  }
  _bindCanvasEvent(t, e) {
    if (this._canvas === null)
      return;
    const i = this._canvasEventFunctions.get(t);
    i !== void 0 && this._canvas.removeEventListener(t, i), this._canvasEventFunctions.set(t, e), this._canvas.addEventListener(t, e);
  }
  _unbindDocumentEvents() {
    this._documentEventFunctions.forEach((t, e) => {
      this._document.removeEventListener(e, t);
    }), this._documentEventFunctions.clear();
  }
  _unbindCanvasEvents() {
    this._canvas !== null && (this._canvasEventFunctions.forEach((t, e) => {
      this._canvas.removeEventListener(e, t);
    }), this._canvasEventFunctions.clear()), console.assert(this._canvasEventFunctions.size === 0);
  }
  unbindEvents() {
    this._unbindCanvasEvents(), this._unbindDocumentEvents(), this._processInput = !1, this._eventsBound = !1, Vi._activeEventDispatcher === this._eventDispatcher && this._unlockEventDispatcher();
  }
  _convertEventCoordsToTargetCoords(t, e, i = !0) {
    let n;
    return i && Vi._activeOffset !== null ? n = Vi._activeOffset : n = this._elementOffset, new K(t - n.left, e - n.top);
  }
  focusInput(t) {
    this._canvas !== null && (t ? this._canvas.focus() : this._canvas.blur());
  }
  _setButtons(t) {
    t.buttons && (this._buttons = t.buttons);
  }
  ////Mouse Events
  _processMouseDown(t) {
    if (this._tryLockEventDispatcher()) {
      switch (t.button) {
        case 0:
          this._buttons |= ys.Left;
          break;
        case 1:
          this._buttons |= ys.Middle;
          break;
        case 2:
          this._buttons |= ys.Right;
          break;
      }
      if (t.preventDefault(), this._timeoutMonitor.resetTimeout(), this._processInput) {
        const e = this._convertEventCoordsToTargetCoords(t.clientX, t.clientY), i = this._getEventModifiers(t);
        Vi._activeEventDispatcher.injectMouseDownEvent(
          e.x,
          e.y,
          t.button,
          this._buttons,
          i,
          this._viewKey
        ), this._dragStarted = !0;
      }
    }
  }
  _processMouseMove(t, e = !1) {
    if (t.preventDefault(), this._timeoutMonitor.resetTimeout(), !(!e && !this._tryLockEventDispatcher()) && this._processInput) {
      const i = this._convertEventCoordsToTargetCoords(t.clientX, t.clientY), n = this._getEventModifiers(t);
      Vi._activeEventDispatcher !== null && Vi._activeEventDispatcher.injectMouseMoveEvent(
        i.x,
        i.y,
        Ee.None,
        this._buttons,
        n,
        this._viewKey
      );
    }
  }
  _processMouseUp(t, e = !1) {
    switch (t.button) {
      case 0:
        this._buttons &= ~ys.Left;
        break;
      case 1:
        this._buttons &= ~ys.Middle;
        break;
      case 2:
        this._buttons &= ~ys.Right;
        break;
    }
    if (t.preventDefault(), this._timeoutMonitor.resetTimeout(), !!this._tryLockEventDispatcher() && (t.stopPropagation(), this._processInput)) {
      const i = this._convertEventCoordsToTargetCoords(t.clientX, t.clientY), n = this._getEventModifiers(t);
      Vi._activeEventDispatcher.injectMouseUpEvent(
        i.x,
        i.y,
        t.button,
        this._buttons,
        n,
        this._viewKey
      ), this._buttons === ys.None && (this._dragStarted = !1, this._captureInput = !1, e && this._unlockEventDispatcher());
    }
  }
  _processMousewheel(t) {
    if (t.preventDefault(), this._timeoutMonitor.resetTimeout(), this._processInput) {
      let e;
      const i = this._convertEventCoordsToTargetCoords(t.clientX, t.clientY), n = this._getEventModifiers(t);
      this._isFirefox ? e = t.detail > 0 ? -1 : 1 : e = t.wheelDelta > 0 ? 1 : -1, this._eventDispatcher.injectMousewheelEvent(
        i.x,
        i.y,
        e,
        this._buttons,
        n,
        this._viewKey
      );
    }
  }
  _processDocumentMouseMove(t) {
    this._dragStarted && this._captureInput && this._processMouseMove(t, !0);
  }
  _processDocumentMouseUp(t) {
    this._dragStarted && this._captureInput && this._processMouseUp(t, !0);
  }
  _processMouseLeave(t) {
    if (this._dragStarted) {
      this._captureInput = !0;
      return;
    }
    this._unlockEventDispatcher();
  }
  _processMouseEnter(t) {
    this._tryLockEventDispatcher() && this._dragStarted && (this._captureInput = !1);
  }
  //KeyEvents
  _isFunctionKey(t) {
    return 112 <= t.which && t.which <= 123;
  }
  _processKeyDownEvent(t) {
    if (this._isFunctionKey(t) || t.preventDefault(), this._timeoutMonitor.resetTimeout(), this._processInput) {
      const e = this._getEventModifiers(t);
      this._eventDispatcher.injectKeyDownEvent(
        // tslint:disable-next-line:deprecation
        t.which,
        e,
        this._viewKey
      );
    }
  }
  _processKeyUpEvent(t) {
    if (t.preventDefault(), this._timeoutMonitor.resetTimeout(), this._processInput) {
      const e = this._getEventModifiers(t);
      this._eventDispatcher.injectKeyUpEvent(
        // tslint:disable-next-line:deprecation
        t.which,
        e,
        this._viewKey
      );
    }
  }
  //Touch Events
  _processTouchStart(t) {
    if (t.preventDefault(), this._timeoutMonitor.resetTimeout(), this._processInput)
      for (let e = 0; e < t.changedTouches.length; e++) {
        const i = t.changedTouches.item(e), n = this._convertEventCoordsToTargetCoords(i.clientX, i.clientY, !1);
        this._eventDispatcher.injectTouchStartEvent(
          i.identifier,
          n.x,
          n.y,
          this._buttons,
          this._viewKey
        );
      }
  }
  _processTouchMove(t) {
    if (t.preventDefault(), this._timeoutMonitor.resetTimeout(), this._processInput)
      for (let e = 0; e < t.changedTouches.length; e++) {
        const i = t.changedTouches.item(e), n = this._convertEventCoordsToTargetCoords(i.clientX, i.clientY, !1);
        this._eventDispatcher.injectTouchMoveEvent(
          i.identifier,
          n.x,
          n.y,
          this._buttons,
          this._viewKey
        );
      }
  }
  _processTouchEnd(t) {
    if (t.preventDefault(), this._timeoutMonitor.resetTimeout(), this._processInput)
      for (let e = 0; e < t.changedTouches.length; e++) {
        const i = t.changedTouches.item(e), n = this._convertEventCoordsToTargetCoords(i.clientX, i.clientY, !1);
        this._eventDispatcher.injectTouchEndEvent(
          i.identifier,
          n.x,
          n.y,
          this._buttons,
          this._viewKey
        );
      }
  }
  //PointerEvents
  _processPointerDown(t) {
    if (this._tryLockEventDispatcher() && (this._setButtons(t), t.preventDefault(), this._timeoutMonitor.resetTimeout(), this._processInput)) {
      const e = this._convertEventCoordsToTargetCoords(t.clientX, t.clientY), i = this._getEventModifiers(t);
      t.pointerType === "mouse" ? Vi._activeEventDispatcher.injectMouseDownEvent(
        e.x,
        e.y,
        t.button,
        this._buttons,
        i,
        this._viewKey
      ) : t.pointerType === "touch" && Vi._activeEventDispatcher.injectTouchStartEvent(
        t.pointerId,
        e.x,
        e.y,
        this._buttons,
        this._viewKey
      ), this._pointerUp = !1;
    }
  }
  _processPointerMove(t, e = !1) {
    if (t.preventDefault(), this._timeoutMonitor.resetTimeout(), !(!e && !this._tryLockEventDispatcher()) && (this._setButtons(t), this._processInput)) {
      const i = this._convertEventCoordsToTargetCoords(t.clientX, t.clientY), n = this._getEventModifiers(t);
      Vi._activeEventDispatcher !== null && (t.pointerType === "mouse" ? Vi._activeEventDispatcher.injectMouseMoveEvent(
        i.x,
        i.y,
        t.button,
        this._buttons,
        n,
        this._viewKey
      ) : t.pointerType === "touch" && Vi._activeEventDispatcher.injectTouchMoveEvent(
        t.pointerId,
        i.x,
        i.y,
        this._buttons,
        this._viewKey
      ));
    }
  }
  _processPointerUp(t, e = !1) {
    if (this._setButtons(t), t.preventDefault(), this._timeoutMonitor.resetTimeout(), !!this._tryLockEventDispatcher() && this._processInput) {
      const i = this._convertEventCoordsToTargetCoords(t.clientX, t.clientY), n = this._getEventModifiers(t);
      t.pointerType === "mouse" && !this._pointerUp ? Vi._activeEventDispatcher.injectMouseUpEvent(
        i.x,
        i.y,
        t.button,
        this._buttons,
        n,
        this._viewKey
      ) : t.pointerType === "touch" && this._eventDispatcher.injectTouchEndEvent(
        t.pointerId,
        i.x,
        i.y,
        this._buttons,
        this._viewKey
      ), this._buttons === ys.None && (this._dragStarted = !1, this._captureInput = !1, this._pointerUp = !0, e && this._unlockEventDispatcher());
    }
  }
  _processPointerEnter(t) {
    this._tryLockEventDispatcher() && (this._pointerUp || (this._captureInput = !1));
  }
  _processPointerLeave(t) {
    if (!this._pointerUp) {
      this._captureInput = !0;
      return;
    }
    this._unlockEventDispatcher();
  }
  _processDocumentPointerMove(t) {
    !this._pointerUp && this._captureInput && this._processPointerMove(t, !0);
  }
  _processDocumentPointerUp(t) {
    !this._pointerUp && this._captureInput && this._processPointerUp(t, !0);
  }
  _getEventModifiers(t) {
    let e = Ci.None;
    return t.altKey && (e |= Ci.Alt), t.ctrlKey && (e |= Ci.Control), t.shiftKey && (e |= Ci.Shift), t.metaKey && (e |= Ci.Command), e;
  }
};
Vi._activeEventDispatcher = null, Vi._activeEventDispatcherLocked = !1, Vi._activeOffset = null;
let tg = Vi;
class Jp {
  /** @hidden */
  constructor(t, e, i, n, r, o) {
    this._backfacesVisible = !1, this._initialCamera = null, this._lineVisibility = !0, this._faceVisibility = !0, this._boundingCalculationIgnoresInvisible = !0, this._backgroundColorTop = null, this._backgroundColorBottom = null, this._drawMode = lr.WireframeOnShaded, this._ambientOcclusionEnabled = !1, this._ambientOcclusionRadius = 0.03, this._antiAliasingMode = bg.SMAA, this._lightingEnabled = !0, this._ambientLightColor = vt.black(), this._massageExtremeCameras = !0, this._bloomEnabled = !1, this._bloomThreshold = 0, this._bloomThresholdRampWidth = 0, this._bloomIntensityScale = 0, this._bloomLayers = [], this._simpleShadowEnabled = !1, this._simpleReflectionEnabled = !1, this._silhouetteEnabled = !1, this._hardEdgesEnabled = !1, this._imageBasedLightingEnabled = !0, this._lineJitterEnabled = !1, this._hiddenLineSettings = new Mx(), this._projectionMode = ri.Orthographic, this._drawStrategy = k_.FixedFramerate, this._id = o.id, this._viewer = t, this._engine = e, this._callbackManager = i, this._interpolationManager = r, this.operatorManager = new bx(t), this._eventDispatcher = new Cx(this._callbackManager, this.operatorManager), this._model = t.model, this._statistics = new Ax(i, t), this._navCube = new Qf(t, this), this._axisTriad = new Zf(t, this), this.overlayManager = new j_(this, t.model, i, this._engine), this._inputMonitor = new tg(o.id, this._eventDispatcher, n), this._inputMonitor.setOptions(t.config), this._determineInitialAxes = ll(t.config.calculateDefaultViewAxes, !0);
    const l = new Oh();
    ll(
      t.config.disableAutomaticFloorplanOverlay,
      !1
    ) && (l.autoActivate = Go.Never), this.floorplanManager = new sd(
      t,
      t.model,
      this.overlayManager,
      this._engine,
      l
    ), this._initEvents(), this._initEventDispatcher(), this.domElements = o.domElements;
  }
  get id() {
    return this._id;
  }
  get inputMonitor() {
    return this._inputMonitor;
  }
  _initEvents() {
    this._callbackManager.bind({
      _resetAssemblyTreeBegin: async () => {
        this._initialCamera = null;
      },
      _firstAttachment: async (t) => {
        if (t === ws.Direct)
          return this._massageInitialCamera(!1);
      },
      _firstModelLoaded: (t, e) => e ? Promise.resolve() : this._massageInitialCamera(!1),
      _modelSwitched: async (t) => {
        if (!t)
          return await this._massageInitialCamera(!1), this._setInitialView(0);
      },
      hwfParseComplete: () => this._massageInitialCamera(!0),
      _modelStructureHeaderParsed: async () => {
        if (this._viewer.sheetManager.isDrawingSheetActive())
          return this._model.setViewAxes(new _(0, 0, 1), new _(0, 1, 0)), this.setViewOrientation(Ct.Front, 0);
      },
      _sessionStarted: async () => {
        this._initEffects();
      },
      _drawContextCreated: (t) => {
        t == this._id && this._initEffects();
      },
      viewAxes: (t, e) => {
        this._updateGroundPlane(t, e), this._updateImageBasedLightingOrientation(t, e);
      }
    });
  }
  _initEffects() {
    this.setBloomIntensityScale(1), this.setBloomThreshold(0.65), this.setBloomThresholdRampWidth(0.1), this.setBloomLayers([
      {
        intensity: 0.5,
        blurSamples: 5,
        blurInterval: [1 / 400, Ks.ProportionOfHeight]
      },
      {
        intensity: 0.5,
        blurSamples: 5,
        blurInterval: [1 / 200, Ks.ProportionOfHeight]
      },
      {
        intensity: 0.5,
        blurSamples: 9,
        blurInterval: [1 / 100, Ks.ProportionOfHeight]
      },
      {
        intensity: 1,
        blurSamples: 9,
        blurInterval: [1 / 50, Ks.ProportionOfHeight]
      },
      {
        intensity: 2,
        blurSamples: 11,
        blurInterval: [1 / 25, Ks.ProportionOfHeight]
      }
    ]), this.setGroundPlane({
      normal: new _(0, 0, 1),
      followViewAxes: !0
    }), this.setSimpleShadowColor(vt.black()), this.setSimpleShadowOpacity(0.65), this.setSimpleShadowResolution(512), this.setSimpleShadowBlurSamples(5), this.setSimpleShadowBlurInterval(1), this.setSimpleShadowInteractiveUpdateEnabled(), this.setSimpleReflectionOpacity(0.65), this.setSimpleReflectionFadeAngle(10), this.setSimpleReflectionBlurSamples(9), this.setSimpleReflectionBlurInterval(1, Ks.Pixels), this.setSimpleReflectionAttenuation(
      0,
      1,
      Lf.ProportionOfBoundingHeight
    ), this.setSilhouetteColor(vt.black()), this.setSilhouetteOpacity(1), this.setSilhouetteThreshold(0.05), this.setSilhouetteThresholdRampWidth(0.025), this.setHardEdgeColor(vt.black()), this.setHardEdgeOpacity(1), this.setHardEdgeThreshold(30), this.setHardEdgeThresholdRampWidth(20), this.setImageBasedLightingIntensity(1), this.setImageBasedLightingOrientation({
      matrix: new mt(),
      followViewAxes: !0
    }), this.setGoochBlue(0.55), this.setGoochYellow(0.3), this.setGoochBaseColorProminence(0.25), this.setGoochLuminanceShiftStrength(0.5), this.setLineJitterInstanceCount(4), this.setLineJitterFrequency(5), this.setLineJitterRadius(5e-3), this.setToonShadingBandCount(3), this.setToonShadingSpecularFactor(1);
  }
  _initEventDispatcher() {
    const t = new Ng(this._viewer, this), e = new hy(this._viewer, this), i = new py(this._viewer, this), n = new gy(this._viewer, this), r = new cy(
      this._viewer,
      this,
      t,
      e,
      i
    ), o = new fy(this._viewer, this), l = new od(this._viewer, this), h = new dy(
      this._viewer,
      o,
      l
    ), u = new uy(this._viewer, this), d = new zy(this._viewer, this, this._viewer.noteTextManager), g = new Ty(this._viewer, this), y = new Vy(this._viewer, this), m = new ky(this._viewer, this), x = new Ay(this._viewer, this), b = new Ey(this._viewer, this), I = new My(this._viewer, this), C = new _y(
      this._viewer,
      this,
      this._viewer.measureManager
    ), P = new wy(
      this._viewer,
      this,
      this._viewer.measureManager
    ), k = new by(
      this._viewer,
      this,
      this._viewer.measureManager
    ), O = new xy(
      this._viewer,
      this,
      this._viewer.measureManager
    ), B = new my(
      this._viewer,
      this,
      this._viewer.measureManager
    ), j = new yy(
      this._viewer,
      this,
      this._viewer.measureManager
    ), V = new Cy(
      this._viewer,
      this,
      this._viewer.measureManager
    ), Y = new Iy(
      this._viewer,
      this,
      this._viewer.measureManager
    ), q = new By(this._viewer, this, this._viewer.noteTextManager), st = new Oy(
      this._viewer,
      this,
      this._viewer.cuttingManager
    ), dt = new Ly(this._viewer, this), U = new Fy(this._viewer, this), J = new Ny(this._viewer, this), A = new Ry(this._viewer, this), R = new Hy(this._viewer, this);
    this.operatorManager._registerOperator(ve.Navigate, r), this.operatorManager._registerOperator(ve.Orbit, t), this.operatorManager._registerOperator(ve.Pan, e), this.operatorManager._registerOperator(ve.Zoom, i), this.operatorManager._registerOperator(ve.WindowZoom, n), this.operatorManager._registerOperator(ve.Walk, o), this.operatorManager._registerOperator(ve.KeyboardWalk, l), this.operatorManager._registerOperator(ve.WalkMode, h), this.operatorManager._registerOperator(ve.Turntable, u), this.operatorManager._registerOperator(ve.Select, d), this.operatorManager._registerOperator(ve.AreaSelect, g), this.operatorManager._registerOperator(ve.RayDrillSelect, y), this.operatorManager._registerOperator(ve.RedlineCircle, m), this.operatorManager._registerOperator(ve.RedlineText, x), this.operatorManager._registerOperator(ve.RedlineRectangle, b), this.operatorManager._registerOperator(ve.RedlinePolyline, I), this.operatorManager._registerOperator(ve.MeasureEdgeLength, C), this.operatorManager._registerOperator(
      ve.MeasureFaceFaceDistance,
      P
    ), this.operatorManager._registerOperator(
      ve.MeasureLineLineAngle,
      k
    ), this.operatorManager._registerOperator(
      ve.MeasurePointPointDistance,
      O
    ), this.operatorManager._registerOperator(
      ve.MeasureBodyBodyDistance,
      B
    ), this.operatorManager._registerOperator(
      ve.MeasureFaceFaceAngle,
      j
    ), this.operatorManager._registerOperator(
      ve.MeasurePolylineDistance,
      V
    ), this.operatorManager._registerOperator(
      ve.MeasurePolygonArea,
      Y
    ), this.operatorManager._registerOperator(ve.Note, q), this.operatorManager._registerOperator(ve.Cutting, st), this.operatorManager._registerOperator(ve.Handle, dt), this.operatorManager._registerOperator(ve.NavCube, U), this.operatorManager._registerOperator(ve.AxisTriad, J), this.operatorManager._registerOperator(ve.Floorplan, A), this.operatorManager._registerOperator(ve.SpaceMouse, R), r.setBimNavigationEnabled(!1), C.addMapping(Ee.Left), P.addMapping(Ee.Left), O.addMapping(Ee.Left), O.addMapping(Ee.Left, Ci.Alt), j.addMapping(Ee.Left), n.addMapping(Ee.Left), st.addMapping(Ee.Left), g.addMapping(Ee.Left), g.addMapping(Ee.Left, Ci.Control), this.operatorManager.set(ve.Navigate, 0), this.operatorManager.set(ve.Select, 1), this.operatorManager.push(ve.Cutting), this.operatorManager.push(ve.Handle), this.operatorManager.push(ve.NavCube), this.operatorManager.push(ve.AxisTriad), this.operatorManager.push(ve.Floorplan), this.operatorManager.push(ve.SpaceMouse);
  }
  /** hidden */
  injectViewOrientationChangeEvent() {
    this._eventDispatcher.injectViewOrientationChangeEvent(this._id);
  }
  async _massageInitialCamera(t) {
    this._initialCamera === null && (this._initialCamera = await this._engine.getCameraPromise(this._id), this._projectionMode = this._initialCamera.getProjection(), this._determineInitialAxes && !this._viewer.sheetManager.isDrawingSheetActive() && !this._model.viewAxesHaveBeenSet() && this._determineViewAxes(this._initialCamera), t && (await this.fitWorld(), this._initialCamera = this.getCamera()));
  }
  /**
   * Sets the line visibility for the view.
   * @param lineVisibility indicates whether to draw lines.
   */
  setLineVisibility(t) {
    return this._setLineVisibility(t), Promise.resolve();
  }
  _setLineVisibility(t) {
    t !== this._lineVisibility && (this._lineVisibility = t, this._engine.setLineVisibility(this._id, t));
  }
  /**
   * Gets the line visibility for the view.
   * @returns whether lines are currently being drawn.
   */
  getLineVisibility() {
    return this._lineVisibility;
  }
  /**
   * Sets the face visibility for the view.
   * @param faceVisibility indicates whether to draw faces.
   */
  setFaceVisibility(t) {
    return this._setFaceVisibility(t), Promise.resolve();
  }
  _setFaceVisibility(t) {
    return t !== this._faceVisibility && (this._faceVisibility = t, this._engine.setFaceVisibility(this._id, t)), Promise.resolve();
  }
  /**
   * Gets the face visibility for the view.
   * @returns whether faces are currently being drawn.
   */
  getFaceVisibility() {
    return this._faceVisibility;
  }
  /**
   * Sets the projection mode.
   * @param projection the projection mode to set.
   */
  setProjectionMode(t) {
    this._projectionMode !== t && (this._projectionMode = t, this._engine.isInit() && this._engine.setProjection(this._id, t), this._eventDispatcher.injectViewOrientationChangeEvent(this._id));
  }
  /**
   * Gets the projection mode.
   * @returns The current projection mode.
   */
  getProjectionMode() {
    return this._projectionMode;
  }
  /**
   * Gets the draw strategy.
   * @returns The current draw strategy.
   */
  getDrawStrategy() {
    return this._drawStrategy;
  }
  /**
   * Gets the view matrix.
   * @returns The current view matrix.
   */
  getViewMatrix() {
    const t = this.getCamera();
    return this._engine.getViewMatrix(t);
  }
  /**
   * Gets the projection matrix.
   * @returns The current projection matrix.
   */
  getProjectionMatrix() {
    const t = this.getCamera();
    return this._engine.getProjectionMatrix(t, this.id);
  }
  /**
   * This is equivalent to (projectionMatrix * viewMatrix).
   * @returns The current full camera matrix.
   */
  getFullCameraMatrix() {
    const t = this.getCamera();
    return this._engine.getFullCameraMatrix(t, this.id);
  }
  /**
   * Creates a ray based on a viewport position.
   * @param point The (X, Y) viewport position.
   * @returns The ray if it was generated, otherwise null.
   */
  raycastFromPoint(t) {
    const e = this.getCanvasSize(), i = this.getCamera(), n = this._engine.getViewMatrix(i), r = this._engine.getProjectionMatrix(i, this.id), o = new _(t.x, e.y - t.y, 0), l = this._unproject(o, r, n, e);
    if (l === null)
      return null;
    o.z = 0.5;
    const h = this._unproject(o, r, n, e);
    if (h === null)
      return null;
    const u = _.subtract(h, l).normalize();
    return new wr(l, u);
  }
  /**
   * @param source
   * @param projectionMatrix
   * @param viewMatrix
   * @param viewSize
   */
  _unproject(t, e, i, n) {
    const r = mt.multiply(i, e), o = mt.inverse(r);
    if (o === null)
      return null;
    const l = new Hr(t.x, t.y, t.z, 1);
    l.x = l.x / n.x, l.y = l.y / n.y, l.x = l.x * 2 - 1, l.y = l.y * 2 - 1, l.z = l.z * 2 - 1;
    const h = o.transform4(l);
    return h.w === 0 ? null : (h.scale(1 / h.w), new _(h.x, h.y, h.z));
  }
  _rectifySelectionItem(t) {
    const e = t.getInclusionKey(), i = t.getNodeId(), n = this._model._getNodeFromInstanceInc(!1, e, i, !0);
    t._setNodeId(n);
  }
  // TODO:
  // Mark this as hidden and rename to have an underscore?
  // Or is it too late? It wouldn't be a bad thing
  // to expose this functionality as public.
  /** @hidden */
  isOutsideCanvasArea(t) {
    const e = this.getCanvasSize();
    return t.x < 0 || t.y < 0 || t.x >= e.x || t.y >= e.y;
  }
  /**
   * Performs a picking operation from the given position on the canvas. The best candidate entity is be returned.
   * This method does not trigger a selection event.
   * This method will reject if the point is outside the canvas area.
   * @param point Canvas position to pick from.
   * @param config The configuration object used for this picking operation.
   * @returns An object containing the result of the picking operation.
   */
  async pickFromPoint(t, e) {
    if (this.isOutsideCanvasArea(t))
      throw new Oo();
    const i = await this._engine.pickFromScreen(
      this._id,
      t,
      e,
      this._viewer.sheetManager.isDrawingSheetActive()
    );
    return i ? (this._rectifySelectionItem(i), i) : _i.create();
  }
  /**
   * Performs a picking operation from the given position on the canvas. All candidate entities are returned.
   * This method does not trigger a selection event.
   * This method will reject if the point is outside the canvas area.
   * @param point Canvas position to pick from.
   * @param config The configuration object used for this picking operation.
   * @returns An object containing the result of the picking operation.
   */
  async pickAllFromPoint(t, e) {
    if (this.isOutsideCanvasArea(t))
      throw new Oo();
    const i = await this._engine.pickAllFromScreen(
      this._id,
      t,
      e,
      this._viewer.sheetManager.isDrawingSheetActive()
    );
    for (const n of i)
      this._rectifySelectionItem(n);
    return i;
  }
  /**
   * Performs a composite picking operation.  This operation will return all candidate Node entities according to the PickConfig.
   * @param point Canvas position to pick from.
   * @param config The configuration object used for this picking operation.
   * @returns An object containing the result of the picking operation.
   */
  async compositePickFromPoint(t, e) {
    if (this.isOutsideCanvasArea(t))
      throw new Oo();
    const { faceItem: i, lineItem: n, pointItem: r } = await this._engine.compositePickFromScreen(
      this._id,
      t,
      e,
      this._viewer.sheetManager.isDrawingSheetActive()
    ), o = new rd(i, n, r);
    return o.faceItem !== null && this._rectifySelectionItem(o.faceItem), o.lineItem !== null && this._rectifySelectionItem(o.lineItem), o.pointItem !== null && this._rectifySelectionItem(o.pointItem), new rd(
      o.faceItem,
      o.lineItem,
      o.pointItem
    );
  }
  /**
   * Performs a selection operation from the given world-space ray. The best candidate entity is be returned.
   * This method does not trigger a selection event.
   * @param ray The world-space ray to perform the selection with.
   * @param config The configuration object used for this picking operation.
   * @param selectionMode The mode to use for this selection.
   * @returns An object containing the result of the picking operation.
   */
  async pickFromRay(t, e) {
    const i = await this._engine.pickFromRay(t, e);
    return i ? (this._rectifySelectionItem(i), i) : _i.create();
  }
  /**
   * Performs a selection operation from the given world-space ray. All candidate entities are returned.
   * This method does not trigger a selection event.
   * @param ray The world-space ray to perform the selection with.
   * @param config The configuration object used for this picking operation.
   * @param selectionMode The mode to use for this selection.
   * @returns An object containing the result of the picking operation.
   */
  async pickAllFromRay(t, e) {
    const i = await this._engine.pickAllFromRay(t, e);
    for (const n of i)
      this._rectifySelectionItem(n);
    return i;
  }
  /**
   * Creates a new and active selection context for the provided selection window.
   * @param areaCssMin The minimum coodinate in CSS pixel space for the selection window.
   * @param areaCssMax The maximum coodinate in CSS pixel space for the selection window.
   * @param config The configuration object used for this selection operation.
   * @returns The handle for the selection context.
   */
  async beginScreenSelectByArea(t, e, i) {
    if (this.isOutsideCanvasArea(t) || this.isOutsideCanvasArea(e))
      throw new Oo();
    return this._engine.beginScreenAreaSelection(this._id, t, e, i);
  }
  /**
   * Creates a new and active selection context for the provided selection ray.
   * The ray is created at the supplied ray origin and is cast into the scene.
   * Faces are selected if they lie along the ray.
   * Lines and points are selected if they lie within the ray's box radius.
   *
   * Note: Somewhat confusingly ray drill selection is actually a selection by volume.
   * The provided ray origin and radius are used to create a frustum to preform the selection.
   * This has some consequences. For example, the `SelectionResult`s returned by advancing a
   * ray drill selection will not have selection positions, since they were not selected at
   * a single point.
   * @param rayCssOrigin The coordinate in CSS pixel space for the selection ray's origin.
   * @param rayCssBoxRadius The radius around the ray in CSS pixel space used for line and point selection proximity.
   * @param config The configuration object used for this selection operation.
   * @returns The handle for the selection context.
   */
  async beginRayDrillSelection(t, e, i) {
    if (this.isOutsideCanvasArea(t))
      throw new Oo();
    return this._engine.beginRayDrillSelection(this._id, t, e, i);
  }
  /**
   * Creates a new and active selection context for the provided selection volume.
   * The selection volume is a convex polyhedron defined by the bounded intersection of its half-spaces.
   * @param volumePlanes The planes used to define volume. A point p is inside the volume if and only if (plane.determineSide(p) == true) for all supplied planes.
   * @param heuristicOrigin A point used to compute distances against for prioritizing returned results. This is typically (but not necessarily) the center of the volume.
   * @param config The configuration object used for this selection operation.
   * @returns The handle for the selection context.
   */
  async beginConvexPolyhedronSelection(t, e, i) {
    return this._engine.beginConvexPolyhedronSelection(t, e, i);
  }
  /**
   * Creates a new and active selection context for the provided selection sphere.
   * @param sphereCenter The center of the selection sphere.
   * @param sphereRadius The radius of the selection sphere.
   * @param config The configuration object used for this selection operation.
   * @returns The handle for the selection context.
   */
  async beginSphereSelection(t, e, i) {
    const n = vl(t);
    return this._engine.beginSphereSelection(n, e, i);
  }
  /**
   * Deactivates and destroys the provided selection context.
   * @param handle The selection context to destroy.
   */
  endIncrementalSelection(t) {
    return this._endIncrementalSelection(t), Promise.resolve();
  }
  _endIncrementalSelection(t) {
    this._engine.endIncrementalSelection(t);
  }
  /**
   * Returns the next batch of geometry selected by the supplied selection context.
   * @param handle The handle to an active area selection context.
   * @returns Returns selected items. If the resulting list is null then there are no more items to select.
   */
  async advanceIncrementalSelection(t) {
    try {
      const e = await this._engine.advanceIncrementalSelection(t);
      if (e === null)
        return null;
      const i = this._viewer.selectionManager, n = [];
      for (const r of e) {
        this._rectifySelectionItem(r);
        const o = r, l = o.getNodeId();
        if (!l)
          continue;
        i._incrementalBlacklistedInstanceNodes.has(l) || n.push(o);
      }
      return n;
    } catch (e) {
      throw e.scFunction === "advanceVolumeSelection" ? new no() : e;
    }
  }
  /**
   * Projects a 3d world space point to a 3d screen space point.
   * @param point world space point to be projected.
   * @param camera if a camera is provided, its projection and view matrix will be used.
   * @returns point projected into 3d screen space.
   */
  projectPoint(t, e) {
    let i, n;
    e === void 0 && (e = this.getCamera()), i = e.getProjectionMatrix(this._viewer, this), n = e.getViewMatrix(this._viewer);
    const r = this.getCanvasSize(), o = this._project(t, i, n, r);
    return o.y = r.y - o.y, o;
  }
  /**
   * @param source
   * @param projectionMatrix
   * @param viewMatrix
   * @param viewSize
   */
  _project(t, e, i, n) {
    const r = new Hr(t.x, t.y, t.z, 1);
    i.transform4(r, r), e.transform4(r, r);
    const o = r.w <= 0, l = r.w;
    return r.w <= 0 && (r.w = 1e-3), r.scale(1 / r.w), r.x = r.x * 0.5 + 0.5, r.y = r.y * 0.5 + 0.5, r.z = r.z * 0.5 + 0.5, r.x = r.x * n.x, r.y = r.y * n.y, o && (r.z = l), new _(r.x, r.y, r.z);
  }
  /**
   * Unprojects a 2d screen space point to a 3d world space point.
   * @param point 2d screen space
   * @param z z value, default 0
   * @returns point world space point
   */
  unprojectPoint(t, e) {
    const i = this.getCanvasSize(), n = this.getProjectionMatrix(), r = this.getViewMatrix(), o = new _(t.x, i.y - t.y, e);
    return this._unproject(o, n, r, i);
  }
  /**
   * Creates a normalized window position in the range of (-1, 1) for a given point in window space.
   * @returns the normalized window position
   */
  pointToWindowPosition(t) {
    const e = this._engine.getCanvasSize(this.id);
    return new K(t.x / e.x * 2 - 1, 1 - t.y / e.y * 2);
  }
  /**
   * Sets the camera that will be used for the initial camera view.
   * @param camera
   */
  setInitialCamera(t) {
    this._initialCamera = t.copy();
  }
  /**
   * Sets the current camera
   * @param camera the camera to set
   * @param duration camera transition time in milliseconds
   */
  setCamera(t, e = 0) {
    return t === null ? !1 : this._setCameraImpl(t, e).unsafeValue;
  }
  /** @hidden */
  _setCameraPromise(t, e) {
    return this._setCameraImpl(t, e).readyPromise;
  }
  _setCameraImpl(t, e) {
    if (e > 0)
      return this._interpolateCamera(t, e);
    if (this._engine.isInit()) {
      const i = t.getProjection();
      this._projectionMode !== i && this.setProjectionMode(i), this._engine.setCamera(this._id, t);
      let n = this._viewer.markupManager._setActiveMarkupView(this, null);
      return this._callbackManager.trigger("camera", t, this), No(!0, n);
    } else
      return No(!1, Promise.resolve());
  }
  _interpolateCamera(t, e) {
    if (this._engine.isInit()) {
      const i = this.getCamera();
      if (i.equals(t))
        return this._viewer.markupManager && this._viewer.markupManager._update(), No(!1, Promise.resolve());
      {
        this._callbackManager.trigger("transitionBegin", e, this);
        const n = wi(), r = () => {
          this._eventDispatcher.injectViewOrientationChangeEvent(this._id), this._callbackManager.trigger("transitionEnd", this), n.resolve();
        };
        return this._interpolationManager.start(
          new kx(i, t, e, r, this)
        ), No(!0, n);
      }
    } else
      return No(!1, Promise.resolve());
  }
  /**
   * Updates camera properties individually. This method should be used to incrementally update camera properties individually.
   * @param camera the camera to set.
   * @returns updated camera object.
   */
  updateCamera(t) {
    return t = this._engine.updateCamera(this._id, t), this._callbackManager.trigger("camera", t, this), t;
  }
  /**
   * Resets the camera to the initial view of the model when first loaded.
   * @param duration the amount of time in milliseconds that the camera transition between the current and initial view should take.
   */
  resetCamera(t = rs) {
    return this._setInitialView(t);
  }
  /**
   * Unsets the default camera. After this is called the next camera to be set will be the new default
   */
  unsetDefaultCamera() {
    this._engine.markCameraAsEmpty(this._id);
  }
  /**
   * Gets the current camera
   * @returns the current camera
   */
  getCamera() {
    if (this._engine.isInit())
      return this._engine.getCamera(this._id);
    throw new oe("getCamera() called before sceneReady");
  }
  /**
   * Returns a camera set to a ViewOrientation
   * @param orientation The desired view orientation for the camera.
   * @param bounding Optional bounding to fit the camera about. If not supplied, the model bounding will be used.
   */
  async getViewOrientationCamera(t, e, i = !0) {
    const n = this.getCamera(), r = n.getUp().copy().normalize(), o = this._model.getViewAxes(), l = o.upVector.copy(), h = o.frontVector.copy();
    e === void 0 ? e = await this._model.getModelBounding(
      this._boundingCalculationIgnoresInvisible,
      !1
    ) : this._fitCameraToBounding(n, e);
    const u = e.center();
    let d = u.copy();
    const g = u.copy(), y = _.subtract(n.getPosition(), n.getTarget()).length(), m = _.subtract(n.getPosition(), u).length();
    let x = new _(0, 0, 1), b = new _(-1, 0, 0);
    l !== null && (x = l.copy()), h !== null && (b = h.copy());
    const I = b.copy().scale(-1), C = b.copy(), P = x.copy(), k = x.copy().scale(-1), O = _.cross(P, I), B = O.copy().scale(-1), j = (st) => {
      const dt = _.subtract(g, st);
      let U = x;
      const J = yr(dt, x);
      (J === 0 || J === 180) && (U = b);
      const A = _.cross(dt, U), R = A.copy().negate(), wt = _.cross(dt, A), z = wt.copy().negate(), St = [A, R, wt, z];
      let X = 1 / 0, At = A;
      for (const at of St) {
        const ot = yr(r, at);
        ot <= X && (X = ot, At = at);
      }
      return At.normalize();
    };
    let V = null;
    switch (t) {
      case Ct.Front:
        d = _.add(g, C);
        break;
      case Ct.Back:
        d = _.add(g, I);
        break;
      case Ct.Left:
        d = _.add(g, O);
        break;
      case Ct.Right:
        d = _.add(g, B);
        break;
      case Ct.Bottom:
        d = _.add(g, k), V = I.copy();
        break;
      case Ct.Top:
        d = _.add(g, P), V = I.copy();
        break;
      case Ct.FrontTop:
      case Ct.TopFront:
        d = _.add(g, _.add(C, P)), V = _.add(I, P).normalize();
        break;
      case Ct.FrontTopLeft:
      case Ct.LeftTopFront:
      case Ct.TopLeftFront:
        d = _.add(g, _.add(C, _.add(O, P))), V = _.add(I, _.add(B, P)).normalize();
        break;
      case Ct.Iso:
      case Ct.FrontTopRight:
      case Ct.RightTopFront:
      case Ct.TopRightFront:
        d = _.add(g, _.add(C, _.add(B, P))), V = _.add(I, _.add(O, P)).normalize();
        break;
      case Ct.FrontLeft:
      case Ct.LeftFront:
        d = _.add(g, _.add(C, O));
        break;
      case Ct.FrontRight:
      case Ct.RightFront:
        d = _.add(g, _.add(C, B));
        break;
      case Ct.FrontBottom:
      case Ct.BottomFront:
        d = _.add(g, _.add(C, k)), V = _.add(C, P).normalize();
        break;
      case Ct.FrontBottomLeft:
      case Ct.LeftBottomFront:
      case Ct.BottomLeftFront:
        d = _.add(g, _.add(C, _.add(O, k))), V = _.add(C, _.add(O, P)).normalize();
        break;
      case Ct.FrontBottomRight:
      case Ct.RightBottomFront:
      case Ct.BottomRightFront:
        d = _.add(g, _.add(C, _.add(B, k))), V = _.add(C, _.add(B, P)).normalize();
        break;
      case Ct.BackTop:
      case Ct.TopBack:
        d = _.add(g, _.add(I, P)), V = _.add(C, P).normalize();
        break;
      case Ct.BackTopLeft:
      case Ct.LeftTopBack:
      case Ct.TopLeftBack:
        d = _.add(g, _.add(I, _.add(O, P))), V = _.add(C, _.add(B, P)).normalize();
        break;
      case Ct.BackTopRight:
      case Ct.RightTopBack:
      case Ct.TopRightBack:
        d = _.add(g, _.add(I, _.add(B, P))), V = _.add(C, _.add(O, P)).normalize();
        break;
      case Ct.BackLeft:
      case Ct.LeftBack:
        d = _.add(g, _.add(I, O));
        break;
      case Ct.BackRight:
      case Ct.RightBack:
        d = _.add(g, _.add(I, B));
        break;
      case Ct.BackBottom:
      case Ct.BottomBack:
        d = _.add(g, _.add(I, k)), V = _.add(I, P).normalize();
        break;
      case Ct.BackBottomLeft:
      case Ct.LeftBottomBack:
      case Ct.BottomLeftBack:
        d = _.add(g, _.add(I, _.add(O, k))), V = _.add(I, _.add(O, P)).normalize();
        break;
      case Ct.BackBottomRight:
      case Ct.RightBottomBack:
      case Ct.BottomRightBack:
        d = _.add(g, _.add(I, _.add(B, k))), V = _.add(I, _.add(B, P)).normalize();
        break;
      case Ct.LeftBottom:
      case Ct.BottomLeft:
        d = _.add(g, _.add(O, k)), V = _.add(O, P).normalize();
        break;
      case Ct.LeftTop:
      case Ct.TopLeft:
        d = _.add(g, _.add(O, P)), V = _.add(B, P).normalize();
        break;
      case Ct.RightBottom:
      case Ct.BottomRight:
        d = _.add(g, _.add(B, k)), V = _.add(B, P).normalize();
        break;
      case Ct.RightTop:
      case Ct.TopRight:
        d = _.add(g, _.add(B, P)), V = _.add(O, P).normalize();
        break;
      default:
        $r();
    }
    i || (V = j(d)), V === null && (V = x);
    const Y = _.add(
      _.subtract(d, u).normalize().scale(m),
      u
    ), q = _.add(
      _.subtract(d, u).normalize().scale(m - y),
      u
    );
    return n.setPosition(Y), n.setTarget(q), n.setUp(V), n;
  }
  /**
   * Sets the view to a standard orientation.
   * @param orientation The desired view orientation for the camera.
   * @param duration The number of milliseconds used to transition to the new camera.
   * @param bounding Optional bounding to fit the camera about. If not supplied, the model bounding will be used.
   * @param preserveModelUp Indicates whether the camera up will be set according to model up or current camera.
   */
  async setViewOrientation(t, e = rs, i, n = !0) {
    const r = await this.getViewOrientationCamera(t, i, n);
    i === void 0 ? await this.fitWorld(e, r) : await this.fitBounding(i, e, r), this._callbackManager.trigger("viewOrientation", t, this);
  }
  /**
   * Centers the camera on a specified node id.
   * @param nodeId
   * @param duration the number of milliseconds to transition to the new camera.
   */
  async centerCameraOnNode(t, e = 0, i = this.getCamera()) {
    const r = (await this._model.getNodesBounding([t])).center(), o = i.getPosition(), l = i.getTarget(), h = _.subtract(l, r);
    if (o.subtract(h), i.setPosition(o), i.setTarget(r), e > 0)
      return this._setCameraPromise(i, e);
    this.setCamera(i);
  }
  /** @hidden */
  async _setInitialView(t) {
    if (!this._initialCamera)
      return this.fitWorld(t);
    if (t > 0)
      return this._setCameraPromise(this._initialCamera, t);
    this.setCamera(this._initialCamera), this._eventDispatcher.injectViewOrientationChangeEvent(this._id);
  }
  /**
   * Returns the size of the viewer canvas.
   * @returns the current size of the viewer canvas.
   */
  getCanvasSize() {
    return this._engine.getCanvasSize(this.id);
  }
  /**
   * Sets the display for the default statistic overlay.
   * @param visible whether the default statistics overlay should be drawn.
   */
  async setStatisticsDisplayVisibility(t) {
    t ? await this._statistics.showDisplay() : this._statistics.hideDisplay();
  }
  /**
   * Returns the background colors of the canvas.
   * @returns the canvas background colors.
   */
  getBackgroundColor() {
    var i, n;
    const t = ((i = this._backgroundColorTop) == null ? void 0 : i.copy()) ?? null, e = ((n = this._backgroundColorBottom) == null ? void 0 : n.copy()) ?? null;
    return new jy(t, e);
  }
  /**
   * Sets the viewer background color to a gradient interpolating from the top to bottom color.
   * For a solid color, the top and bottom color should have the same values.
   * Background Transparency is only available with client-side rendering.
   * To re-enable a transparent background, pass null to the parameters of this function.
   *
   * When draw mode is set to {@link DrawMode.HiddenLine}, the background color is defined in {@link HiddenLineSettings HiddenLineSettings}.
   * See {@link HiddenLineSettings.setBackgroundColor HiddenLineSettings.setBackgroundColor}.
   * @param top the top color for the the background gradient.
   * @param bottom the bottom color for the the background gradient.
   * @returns a promise that resolves when the operation has completed.
   */
  setBackgroundColor(t = null, e = null) {
    return this._backgroundColorTop = t !== null ? t.copy() : null, this._backgroundColorBottom = e !== null ? e.copy() : null, this._drawMode !== lr.HiddenLine && !this._viewer.sheetManager.isDrawingSheetActive() && this._engine.setBackgroundGradient(
      this._id,
      this._backgroundColorTop,
      this._backgroundColorBottom
    ), Promise.resolve();
  }
  /**
   * Hides all nodes except those specified. Also fits the camera to those nodes' bounding box.
   * @param nodeIds An array of the node IDs to be isolated.
   * @param duration Time in milliseconds for the camera transition to the new camera view.
   * @param fitNodes If true, then the view is fitted around the isolated nodes.
   * @param initiallyHiddenStayHidden Controls whether or not initially hidden geometries stay hidden. Default behavior is driven by [[setBehaviorInitiallyHidden]].
   */
  async isolateNodes(t, e = rs, i = !0, n = null) {
    const r = this._model.getAbsoluteRootNode(), o = /* @__PURE__ */ new Map();
    o.set(r, !1);
    for (const l of t)
      o.set(l, !0);
    if (await this._model.setNodesVisibilities(o, n), i)
      return this.fitNodes(t, e);
  }
  /**
   * Fits the camera to the bounding box containing the node ids.
   * @param nodeIds Array of node ids to fit the camera.
   * @param duration Time in milliseconds for the camera transition to the new camera view.
   * @returns A promise that will be resolved once the transition is complete.
   */
  async fitNodes(t, e = rs) {
    const i = await this._model.getNodesBounding(t);
    return this.fitBounding(i, e);
  }
  /**
   * Fits the view to the model bounding box.
   * @param duration the number of milliseconds to transition to the new camera.
   * @returns A promise that will be resolved once the transition is complete.
   */
  async fitWorld(t = 0, e) {
    e || (e = this.getCamera());
    const i = await this._model.getModelBounding(
      this._boundingCalculationIgnoresInvisible,
      !1
    );
    await this.fitBounding(i, t, e);
  }
  _fitCameraToBounding(t, e) {
    if (this._viewer.sheetManager.isDrawingSheetActive()) {
      const i = e.extents(), n = e.center(), r = new _(n.x, n.y, e.min.z + i.length());
      t.setProjection(ri.Orthographic), t.setPosition(r), t.setTarget(n), t.setWidth(i.x * 1.25), t.setHeight(i.y * 1.25);
    } else {
      const n = e.extents().length();
      if (n !== 0) {
        const r = t.getWidth(), o = _.subtract(t.getPosition(), t.getTarget()), l = o.length(), h = n * l / r, u = e.center(), d = _.add(u, o.normalize().scale(h));
        t.setTarget(u), t.setPosition(d), t.setWidth(n), t.setHeight(n);
      } else {
        const r = _.subtract(t.getPosition(), t.getTarget()), o = e.center(), l = _.add(o, r);
        t.setTarget(o), t.setPosition(l);
      }
    }
  }
  /**
   * Fits the camera to the bounding box.
   * @param bounding bounding box to fit the camera.
   * @param duration Time in milliseconds for the camera transition to the new camera view.
   * @returns A promise that will be resolved once the transition is complete.
   */
  async fitBounding(t, e = rs, i = this.getCamera()) {
    if (t) {
      if (t.isDegenerate() || this._fitCameraToBounding(i, t), e > 0)
        return this._setCameraPromise(i, e);
      this.setCamera(i);
    }
  }
  /**
   * Sets whether backfaces should be rendered in the scene.
   * @param visible Boolean value indicating whether backfaces should be rendered.
   * @returns Promise that is resolved when this operation has completed.
   */
  setBackfacesVisible(t) {
    return this._backfacesVisible = t, this._engine.setBackFacesVisible(this._id, t), Promise.resolve();
  }
  /**
   * Gets whether backfaces are being rendered in the scene.
   * @returns Boolean value indicating whether backfaces are being rendered in the scene.
   */
  getBackfacesVisible() {
    return this._backfacesVisible;
  }
  /**
   * Sets the drawing mode for the scene.
   * @param drawMode The drawing mode to set.
   */
  setDrawMode(t) {
    return this._setDrawMode(t), Promise.resolve();
  }
  _setDrawMode(t) {
    switch (this._drawMode = t, this._drawMode !== lr.HiddenLine && this.setBackgroundColor(this._backgroundColorTop, this._backgroundColorBottom), t) {
      case lr.Wireframe:
        this._engine.setDrawMode(this._id, dr.Highlight), this._setLineVisibility(!0), this._setFaceVisibility(!1);
        break;
      case lr.Shaded:
        this._engine.setDrawMode(this._id, dr.Highlight), this._setLineVisibility(!1), this._setFaceVisibility(!0);
        break;
      case lr.WireframeOnShaded:
        this._engine.setDrawMode(this._id, dr.Highlight), this._setLineVisibility(!0), this._setFaceVisibility(!0);
        break;
      case lr.HiddenLine:
        {
          const e = this._hiddenLineSettings.getBackgroundColor();
          this._setLineVisibility(!0), this._setFaceVisibility(!0), this._engine.enableHiddenLineRendering(this._id, this._hiddenLineSettings), this._engine.setBackgroundGradient(
            this._id,
            e.top,
            e.bottom
          );
        }
        break;
      case lr.XRay:
        this._engine.setDrawMode(this._id, dr.XRay), this._setLineVisibility(!0), this._setFaceVisibility(!0);
        break;
      case lr.Gooch:
        this._engine.setDrawMode(this._id, dr.Gooch);
        break;
      case lr.Toon:
        this._setLineVisibility(!1), this._engine.setDrawMode(this._id, dr.Toon);
    }
  }
  /**
   * @returns The current draw mode
   */
  getDrawMode() {
    return this._drawMode;
  }
  /**
   * Sets the anti-aliasing mode for the scene.
   * @param antiAliasingMode
   */
  setAntiAliasingMode(t) {
    return this._setAntiAliasingMode(t), Promise.resolve();
  }
  _setAntiAliasingMode(t) {
    this._antiAliasingMode = t, this._engine.setAntiAliasingMode(this._id, t);
  }
  /**
   * Gets the anti-aliasing mode for the scene. The Default value is AntiAliasingMode.SMAA
   * @returns the current anti-aliasing mode.
   */
  getAntiAliasingMode() {
    return this._antiAliasingMode;
  }
  /**
   * @returns a [[HiddenLineSettings]] object.
   */
  getHiddenLineSettings() {
    return this._hiddenLineSettings;
  }
  /**
   * Sets whether ambient occlusion is enabled
   * @param enabled sets whether ambient occlusion will be enabled
   */
  setAmbientOcclusionEnabled(t = !0) {
    return this._setAmbientOcclusionEnabled(t), Promise.resolve();
  }
  _setAmbientOcclusionEnabled(t = !0) {
    this._ambientOcclusionEnabled = t, this._engine.setAmbientOcclusionEnabled(this._id, t);
  }
  /**
   * @returns boolean value indicating whether ambient occlusion is enabled
   */
  getAmbientOcclusionEnabled() {
    return this._ambientOcclusionEnabled;
  }
  /**
   * Sets the ambient occlusion radius. This value represents the maximum screen-proportional distance between two points such that one will cast a shadow on the other.
   * @param radius the ambient occlusion radius.
   */
  setAmbientOcclusionRadius(t) {
    return this._setAmbientOcclusionRadius(t), Promise.resolve();
  }
  _setAmbientOcclusionRadius(t) {
    this._ambientOcclusionRadius = t, this._engine.setAmbientOcclusionRadius(this._id, t);
  }
  /**
   * @returns the ambient occlusion radius
   */
  getAmbientOcclusionRadius() {
    return this._ambientOcclusionRadius;
  }
  /**
   * Sets whether lighting is enabled. When disabled, material colors
   * are drawn at full intensity.
   *
   * See also [[InstanceModifier.DoNotLight]], [[clearLights]].
   */
  setLightingEnabled(t = !0) {
    return this._setLightingEnabled(t), Promise.resolve();
  }
  _setLightingEnabled(t = !0) {
    this._lightingEnabled = t, this._engine.setLightingEnabled(this._id, t);
  }
  /**
   * Returns whether lighting is enabled.
   *
   * See also [[setLightingEnabled]].
   */
  getLightingEnabled() {
    return this._lightingEnabled;
  }
  /**
   * Sets how transparent objects are blended.
   */
  setTransparencyMode(t) {
    this._engine.setTransparencyMode(this._id, t);
  }
  /**
   * Sets the opacity of unselected items in x-ray mode.
   * @param opacity a number between 0 and 1
   * @param element the type of element to which the opacity will apply.
   * If unspecified, the opacity will apply to all element types.
   */
  setXRayOpacity(t, e) {
    return this._setXRayOpacity(t, e), Promise.resolve();
  }
  _setXRayOpacity(t, e) {
    this._engine.setXRayOpacity(this._id, t, e);
  }
  /**
   * Sets how transparent (unselected) objects are blended in x-ray mode.
   */
  setXRayTransparencyMode(t) {
    return this._setXRayTransparencyMode(t), Promise.resolve();
  }
  _setXRayTransparencyMode(t) {
    this._engine.setXRayTransparencyMode(this._id, t);
  }
  /**
   * Sets the color applied to nodes in x-ray mode.
   * By default, the color is unset.
   *
   * See [[unsetXRayColor]].
   *
   * @param element the type of geometry to apply the color to
   * @param color the color to apply
   * @param group the category of nodes that will be affected.
   * If unspecified, [[XRayGroup.Selected]] will be used.
   */
  setXRayColor(t, e, i = hh.Selected) {
    return this._engine.setXRayColor(this._id, i, t, e), Promise.resolve();
  }
  /**
   * Unsets the color applied to selected items in x-ray mode.
   * Selected items will be displayed without overriding their colors.
   *
   * See [[setXRayColor]].
   *
   * @param element the type of geometry affected by the change
   * @param group the category of nodes that will be affected.
   * If unspecified, [[XRayGroup.Selected]] will be used.
   */
  unsetXRayColor(t, e = hh.Selected) {
    return this._engine.unsetXRayColor(this._id, e, t);
  }
  /**
   * Sets the value to use as the blue tone in Gooch shading.
   * @param blue the blue tone.  This value should be in the range [0,1]
   */
  setGoochBlue(t) {
    this._goochBlue = t, this._engine.setGoochBlue(this._id, t);
  }
  /**
   * Gets the value to use as the blue tone in Gooch shading.
   */
  getGoochBlue() {
    return this._goochBlue;
  }
  /**
   * Sets the prominence of the object's base color in Gooch shading.
   * @param prominence this scalar value determines the amount of the object's base color is applied to the final shaded color.
   */
  setGoochBaseColorProminence(t) {
    this._goochBaseColorProminence = t, this._engine.setGoochBaseColorProminence(this._id, t);
  }
  /**
   * Gets the prominence of the object's base color in Gooch shading.
   */
  getGoochBaseColorProminence() {
    return this._goochBaseColorProminence;
  }
  /**
   * Sets the value to use as the yellow tone in Gooch shading.
   * @param yellow the yellow tone. This value should be in the range [0,1]
   *
   */
  setGoochYellow(t) {
    this._goochYellow = t, this._engine.setGoochYellow(this._id, t);
  }
  /**
   * Gets the value to use as the yellow tone in Gooch shading.
   */
  getGoochYellow() {
    return this._goochYellow;
  }
  /**
   * Sets the number of discrete shading bands that will be used when toon shading is enabled.  Each band represents a shade between dark and light which will control the final color of the pixel based on its light intensity.  The default band count is 3.
   */
  setToonShadingBandCount(t) {
    this._toonBandCount = t, this._engine.setToonShadingBandCount(this._id, t);
  }
  /**
   * Gets the current number of discrete shading bands that will be used when toon shading is enabled.
   */
  getToonShadingBandCount() {
    return this._toonBandCount;
  }
  /**
   * Sets a scale factor which controls the size of specular highlights when toon shading is enabled.  The default value is 1.0.
   */
  setToonShadingSpecularFactor(t) {
    this._toonSpecularFactor = t, this._engine.setToonShadingSpecularFactor(this._id, t);
  }
  /**
   * Gets the current toon shading specular scale factor.
   */
  getToonShadingSpecularFactor() {
    return this._toonSpecularFactor;
  }
  /**
   * Sets the strength of the luminance shift in Gooch shading.
   * @param shiftStrength this scalar values determines the amount of luminance shift that is applied to the object's base color
   */
  setGoochLuminanceShiftStrength(t) {
    this._goochLuminanceShiftStrength = t, this._engine.setGoochLuminanceShiftStrength(this._id, t);
  }
  /**
   * Gets the strength of the luminance shift in Gooch shading.
   */
  getGoochLuminanceShiftStrength() {
    return this._goochLuminanceShiftStrength;
  }
  /**
   * Sets the diameter of rendered points. (default: 1, ScreenPixels) See [[PointSizeUnit]].
   */
  setPointSize(t, e) {
    return this._setPointSize(t, e), Promise.resolve();
  }
  _setPointSize(t, e) {
    this._engine.setPointSize(this._id, t, e);
  }
  /**
   * Gets the diameter of rendered points. See [[PointSizeUnit]].
   */
  getPointSize() {
    return this._engine.getPointSize(this._id);
  }
  /**
   * Controls the appearance of rendered points. (default: Square) See [[PointShape]].
   */
  setPointShape(t) {
    return this._setPointShape(t), Promise.resolve();
  }
  _setPointShape(t) {
    this._engine.setPointShape(this._id, t);
  }
  /**
   * Gets the PointShape. See [[PointShape]]
   */
  getPointShape() {
    return this._engine.getPointShape(this._id);
  }
  /**
   * Enables or disables eye-dome lighting for point clouds. (default: disabled)
   */
  setEyeDomeLightingEnabled(t = !0) {
    return this._setEyeDomeLightingEnabled(t), Promise.resolve();
  }
  _setEyeDomeLightingEnabled(t = !0) {
    this._engine.setEyeDomeLightingEnabled(this._id, t);
  }
  /**
   * @returns boolean value indicating if eye-dome lighting is enabled or disabled.
   */
  getEyeDomeLightingEnabled() {
    return this._engine.getEyeDomeLightingEnabled(this._id);
  }
  /**
   * Sets the diameter of the blur filter used in eye-dome lighting for point clouds.
   * Setting the value to 0 will disable blurring. (default: 7)
   */
  setEyeDomeLightingBlurSamples(t) {
    return this._setEyeDomeLightingBlurSamples(t), Promise.resolve();
  }
  _setEyeDomeLightingBlurSamples(t) {
    this._engine.setEyeDomeLightingBlurSamples(this._id, t);
  }
  /**
   * Returns the diameter of the blur filter used in eye-dome lighting for point clouds.
   * A value of 0 means that blurring is disabled.
   */
  getEyeDomeLightingBlurSamples() {
    return this._engine.getEyeDomeLightingBlurSamples(this._id);
  }
  /**
   * Sets the distance in pixels between samples taken by the blur filter used in eye-dome lighting
   * for point clouds. (default: 1)
   */
  setEyeDomeLightingBlurInterval(t) {
    return this._setEyeDomeLightingBlurInterval(t), Promise.resolve();
  }
  _setEyeDomeLightingBlurInterval(t) {
    this._engine.setEyeDomeLightingBlurInterval(this._id, t);
  }
  /**
   * Returns the distance in pixels between samples taken by the blur filter used in eye-dome lighting
   * for point clouds.
   */
  getEyeDomeLightingBlurInterval() {
    return this._engine.getEyeDomeLightingBlurInterval(this._id);
  }
  /**
   * Controls the maximum Z-distance between samples taken by the blur filter used in eye-dome
   * lighting for point clouds. The value is taken as a proportion of the screen size.
   * Decreasing the value will result in sharper edges, and increasing the value will result
   * in softer edges. (default: .03)
   */
  setEyeDomeLightingBlurEdgeDistance(t) {
    return this._setEyeDomeLightingBlurEdgeDistance(t), Promise.resolve();
  }
  _setEyeDomeLightingBlurEdgeDistance(t) {
    this._engine.setEyeDomeLightingBlurEdgeDistance(this._id, t);
  }
  /**
   * Returns a value that controls the maximum Z-distance between samples taken by
   * the blur filter used in eye-dome lighting for point clouds.
   * The value is a proportion of the screen size.
   */
  getEyeDomeLightingBlurEdgeDistance() {
    return this._engine.getEyeDomeLightingBlurEdgeDistance(this._id);
  }
  /**
   * Controls the shading contrast in eye-dome lighting for point clouds. The value is taken
   * as a number of pixels. Increasing the value will result in overall lighter shading, and
   * decreasing the value will result in overall darker shading. (default: 2)
   */
  setEyeDomeLightingShadingEdgeDistance(t) {
    return this._setEyeDomeLightingShadingEdgeDistance(t), Promise.resolve();
  }
  _setEyeDomeLightingShadingEdgeDistance(t) {
    this._engine.setEyeDomeLightingShadingEdgeDistance(this._id, t);
  }
  /**
   * Returns a value that controls the shading contrast in eye-dome lighting for point clouds.
   * The value is a number of pixels.
   */
  getEyeDomeLightingShadingEdgeDistance() {
    return this._engine.getEyeDomeLightingShadingEdgeDistance(this._id);
  }
  /**
   * Sets the opacity of the shading rendered by eye-dome lighting for point clouds. (default: 1)
   * @param value A number in the range [0,1].
   */
  setEyeDomeLightingOpacity(t) {
    return this._setEyeDomeLightingOpacity(t), Promise.resolve();
  }
  _setEyeDomeLightingOpacity(t) {
    this._engine.setEyeDomeLightingOpacity(this._id, t);
  }
  /**
   * Returns the opacity of the shading rendered by eye-dome lighting for point clouds.
   * The value is in the range [0,1].
   */
  getEyeDomeLightingOpacity() {
    return this._engine.getEyeDomeLightingOpacity(this._id);
  }
  /**
   * Sets whether or not bounding calculations by this View object ignores invisible geometry.
   */
  setBoundingCalculationIgnoresInvisible(t) {
    this._boundingCalculationIgnoresInvisible = t;
  }
  /**
   * @returns whether or not bounding calculations by this View object ignores invisible geometry.
   */
  getBoundingCalculationIgnoresInvisible() {
    return this._boundingCalculationIgnoresInvisible;
  }
  /**
   * Sets whether intermediate frames of an incremental draw will be displayed. (default: true)
   *
   * If false, the image will only be displayed once completely drawn, except immediately
   * after certain operations, such as setting the camera. To disable these exceptions,
   * call [[setInteractiveDrawDelay]] with a value of 0.
   */
  setDisplayIncompleteFrames(t) {
    return this._setDisplayIncompleteFrames(t), Promise.resolve();
  }
  _setDisplayIncompleteFrames(t) {
    this._engine.setDisplayIncompleteFrames(t, this.id);
  }
  /**
   * Sets whether to change cad view cameras with extreme values to functionally identical cameras with
   * better behavior. This should be disabled if it is important that cameras have their authored values
   * Default: true
   * @param value Whether to modify cameras
   */
  setMassageExtremeCameras(t) {
    this._massageExtremeCameras = t;
  }
  getMassageExtremeCameras() {
    return this._massageExtremeCameras;
  }
  /**
   * Sets how long after certain operations, such as setting the camera, to wait before
   * starting a redraw. This delay exists in order to prevent flicker during continuous
   * interaction. The initial value is 200ms.
   * @param value The delay in milliseconds
   */
  setInteractiveDrawDelay(t) {
    return this._setInteractiveDrawDelay(t), Promise.resolve();
  }
  _setInteractiveDrawDelay(t) {
    this._engine.setInteractiveDrawDelay(t, this.id);
  }
  /**
   * Sets whether or not the viewer will periodically attempt to increase the amount drawn during interaction.
   * Setting this to `false` may improve periodic framerate dips caused by such adjustments.
   * @param enable
   */
  setInteractiveDrawLimitIncreaseEnabled(t) {
    this._engine.setInteractiveDrawLimitIncreaseEnabled(t, this.id);
  }
  /**
   * Gets whether or not the viewer will periodically attempt to increase the amount drawn during interaction.
   * @return boolean value indicating whether this feature is enabled or not
   */
  getInteractiveDrawLimitIncreaseEnabled() {
    return this._engine.getInteractiveDrawLimitIncreaseEnabled(this.id);
  }
  /**
   * Sets a minimum frame rate that will be maintained by this views.
   * The view will use various culling techniques in order to maintain the value passed in.
   *
   * Passing `0` will cause the entire scene to be drawn for every frame.
   * @param minimum The minimum framerate to be maintained by this view.
   */
  setMinimumFramerate(t) {
    this._engine.setMinimumFramerate(this.id, t);
  }
  /**
   * Forces the a redraw of this view.
   * @param callback A function to be called once the draw is complete.
   * This is provided instead of a `Promise` to ensure the callback is
   * called before the start of another redraw.
   */
  redraw(t) {
    if (t) {
      const e = (i) => {
        i === this.id && (this._callbackManager.unbind({ _drawComplete: e }), t());
      };
      this._callbackManager.bind({ _drawComplete: e });
    }
    this._engine.redraw(this.id);
  }
  getNavCube() {
    return this._navCube;
  }
  get navCube() {
    return this._navCube;
  }
  getAxisTriad() {
    return this._axisTriad;
  }
  get axisTriad() {
    return this._axisTriad;
  }
  _determineViewAxes(t) {
    const e = t.getUp().normalize(), i = _.subtract(t.getTarget(), t.getPosition()).normalize();
    let n = Dp(e), r = Dp(i);
    n === null && r === null ? (n = new _(0, 1, 0), r = new _(0, 0, 1)) : n === null ? r.y === 0 ? n = new _(0, 1, 0) : n = new _(0, 0, 1) : r === null && (n.z === 0 ? r = new _(0, 0, 1) : r = new _(0, 1, 0));
    try {
      this._model.setViewAxes(r, n);
    } catch {
    }
  }
  /**
   * Sets the color of the ambient light applied to the scene.
   * This is a constant source of light that affects every point
   * in the scene in the same way regardless of position
   * or surface normal.
   *
   * See also [[getAmbientLightColor]].
   */
  setAmbientLightColor(t) {
    this._ambientLightColor = t, this._engine.setAmbientLightColor(this._id, t);
  }
  /**
   * Gets the color of the ambient light applied to the scene.
   *
   * See also [[setAmbientLightColor]].
   */
  getAmbientLightColor() {
    return this._ambientLightColor;
  }
  /**
   * Get the list of light keys in the scene.
   * @returns The list of light keys in the scene.
   */
  getLightKeys() {
    return this._engine.getLightKeys(this._id);
  }
  /**
   * Get a Light given its key if it exists.
   * @param key The key of the light to get.
   * @returns A Light given its key if it exists.
   */
  getLight(t) {
    return this._engine.getLight(this._id, t);
  }
  /**
   * Removes all lights from the scene. When there are no lights,
   * material colors are drawn at full intensity. This has the same
   * visual effect as calling `setLightingEnabled(false)`.
   *
   * See also:
   *  - [[InstanceModifier.DoNotLight]]
   *  - [[setLightingEnabled]]
   */
  clearLights() {
    this._engine.clearLights(this._id);
  }
  /**
   * Adds a light to the scene. The returned promise may be rejected if
   * there are too many lights in the scene. See [[Light]].
   *
   * See also:
   *  - [[clearLights]]
   *  - [[removeLight]]
   *  - [[updateLight]]
   *  - [[setAmbientLightColor]]
   */
  addLight(t) {
    return this._engine.addLight(this._id, t);
  }
  /**
   * removes a light from the scene. See [[Light]].
   *
   * See also:
   *  - [[addLight]]
   *  - [[clearLights]]
   *  - [[updateLight]]
   */
  removeLight(t) {
    this._engine.removeLight(this._id, t);
  }
  /**
   * Updates a light in the scene. See [[Light]].
   *
   * See also:
   *  - [[addLight]]
   *  - [[clearLights]]
   *  - [[removeLight]]
   */
  updateLight(t, e) {
    this._engine.updateLight(this._id, t, e);
  }
  /**
   * Sets whether bloom is enabled.
   *
   * See [[getBloomEnabled]].
   */
  setBloomEnabled(t = !0) {
    this._engine.setBloomEnabled(this._id, t), this._bloomEnabled = t;
  }
  /**
   * Returns whether bloom is enabled.
   *
   * See [[setBloomEnabled]].
   */
  getBloomEnabled() {
    return this._bloomEnabled;
  }
  /**
   * Sets the minimum luminance value a pixel must have for it to
   * contribute to bloom. The value should be in the range `[0,1]`.
   *
   * See [[getBloomThreshold]], [[setBloomThresholdRampWidth]].
   */
  setBloomThreshold(t) {
    this._engine.setBloomThreshold(this._id, t), this._bloomThreshold = t;
  }
  /**
   * Returns the minimum luminance value a pixel must have for it to
   * contribute to bloom.
   *
   * See [[setBloomThreshold]], [[getBloomThresholdRampWidth]].
   */
  getBloomThreshold() {
    return this._bloomThreshold;
  }
  /**
   * Sets how much greater than the threshold set by [[setBloomThreshold]]
   * a pixel's luminance value must be before it contributes fully to
   * the bloom effect.
   *
   * If the pixel's luminance value does not exceed
   * the threshold by at least the amount set by this function,
   * the pixel's contribution will be diminished based on how close
   * its luminance value is to the threshold.
   *
   * See [[getBloomThresholdRampWidth]].
   */
  setBloomThresholdRampWidth(t) {
    this._engine.setBloomThresholdRampWidth(this._id, t), this._bloomThresholdRampWidth = t;
  }
  /**
   * Returns how much greater than the threshold set by [[setBloomThreshold]]
   * a pixel's luminance value must be before it contributes fully to
   * the bloom effect.
   *
   * See [[setBloomThresholdRampWidth]].
   */
  getBloomThresholdRampWidth() {
    return this._bloomThresholdRampWidth;
  }
  /**
   * Sets the intensity of the bloom effect. This value is multiplied
   * by the intensities of the individual layers set by [[setBloomLayers]].
   *
   * See [[getBloomIntensityScale]].
   */
  setBloomIntensityScale(t) {
    this._engine.setBloomIntensityScale(this._id, t), this._bloomIntensityScale = t;
  }
  /**
   * Gets the intensity of the bloom effect.
   *
   * See [[setBloomIntensityScale]].
   */
  getBloomIntensityScale() {
    return this._bloomIntensityScale;
  }
  /**
   * Sets the number of layers in the bloom effect and the layers'
   * attributes.
   *
   * The bloom effect is achieved by applying a luminance filter to the
   * source image, then progressively downsampling, blurring, and adding
   * the results together. The result of each downsample/blur operation is
   * fed into the next, which is executed at half the resolution of the
   * previous. The number of stages and the behavior of each stage
   * are controlled by this function.
   *
   * See [[BloomLayerInfo]], [[getBloomLayers]].
   */
  setBloomLayers(t) {
    const e = Yc(t);
    for (const i of e)
      i.intensity === void 0 && (i.intensity = 1), i.blurSamples === void 0 && (i.blurSamples = 9), i.blurInterval === void 0 && (i.blurInterval = [1, Ks.Pixels]);
    this._engine.setBloomLayers(this._id, e), this._bloomLayers = e;
  }
  /**
   * Returns an array of objects describing each layer in the bloom
   * effect.
   *
   * See [[setBloomLayers]].
   */
  getBloomLayers() {
    return Yc(this._bloomLayers);
  }
  /**
   * Enables a visual comparison of two sets of nodes. The nodes specified
   * by `nodeIdSet1` are filled with one color, the nodes specified by
   * `nodeIdSet2` with another color, and overlapping areas are filled
   * with a third color.
   *
   * See [[endComparison]].
   *
   * @param nodeIdSet1 the nodes to compare against `nodeIdSet2`
   * @param nodeIdSet2 the nodes to compare against `nodeIdSet1`
   * @param config settings controlling the behavior of the comparison
   */
  startComparison(t, e, i) {
    const n = this._model._getModelStructure(), r = n.gatherInstanceIncsFromNodeIds(
      t,
      $t.All,
      Vt.None
    ), o = n.gatherInstanceIncsFromNodeIds(
      e,
      $t.All,
      Vt.None
    );
    this._engine.startComparison(this._id, r, o, i);
  }
  /**
   * Disables a visual comparison of two sets of nodes enabled by
   * [[startComparison]].
   */
  endComparison() {
    this._engine.endComparison(this._id);
  }
  /**
   * Enables or disables a full-scene shadow projected onto an
   * invisible ground plane.
   *
   * See also:
   *  - [[getSimpleShadowEnabled]]
   *  - [[setSimpleShadowColor]]
   *  - [[setSimpleShadowOpacity]]
   *  - [[setGroundPlane]]
   *  - [[setSimpleShadowResolution]]
   *  - [[setSimpleShadowInteractiveUpdateEnabled]]
   *
   * @param value Whether simple shadows should be enabled.
   */
  setSimpleShadowEnabled(t = !0) {
    this._simpleShadowEnabled = t, this._engine.setSimpleShadowEnabled(this._id, t);
  }
  /**
   * Returns whether simple shadows are enabled.
   *
   * See [[setSimpleShadowEnabled]].
   */
  getSimpleShadowEnabled() {
    return this._simpleShadowEnabled;
  }
  /**
   * Sets the color of simple shadows.
   *
   * See also:
   *  - [[getSimpleShadowColor]]
   *  - [[setSimpleShadowEnabled]]
   *
   * @param color The color to set.
   */
  setSimpleShadowColor(t) {
    this._simpleShadowColor = t.copy(), this._engine.setSimpleShadowColor(this._id, t);
  }
  /**
   * Returns the color of simple shadows.
   *
   * See also:
   *  - [[setSimpleShadowColor]]
   *  - [[setSimpleShadowEnabled]]
   */
  getSimpleShadowColor() {
    return this._simpleShadowColor.copy();
  }
  /**
   * Sets the opacity of simple shadows.
   *
   * See also:
   *  - [[getSimpleShadowOpacity]]
   *  - [[setSimpleShadowEnabled]]
   *
   * @param opacity The opacity to set.
   */
  setSimpleShadowOpacity(t) {
    this._simpleShadowOpacity = t, this._engine.setSimpleShadowOpacity(this._id, t);
  }
  /**
   * Returns the opacity of simple shadows.
   *
   * See also:
   *  - [[setSimpleShadowOpacity]]
   *  - [[setSimpleShadowEnabled]]
   */
  getSimpleShadowOpacity() {
    return this._simpleShadowOpacity;
  }
  /**
   * Defines the invisible ground plane onto which simple shadows
   * and reflections are projected.
   *
   * See also:
   *  - [[getGroundPlane]]
   *  - [[setSimpleShadowEnabled]]
   *  - [[setSimpleReflectionEnabled]]
   *
   * @param plane The plane to set.
   */
  setGroundPlane(t) {
    this._groundPlane = { ...t }, this._updateGroundPlane();
  }
  _updateGroundPlane(t, e) {
    if (!(this._groundPlane.followViewAxes && (t !== void 0 && e !== void 0 || this._model.viewAxesHaveBeenSet()))) {
      this._engine.setGroundPlane(this._id, this._groundPlane.normal, this._groundPlane.position);
      return;
    }
    if (t === void 0 || e === void 0) {
      const h = this._model.getViewAxes();
      t = h.frontVector, e = h.upVector;
    }
    const i = t.copy().negate(), n = e, r = _.cross(n, i), o = mt.createFromBasis(i, r, n), l = new _(0, 0, 0);
    o.transform(this._groundPlane.normal, l), this._engine.setGroundPlane(this._id, l, this._groundPlane.position);
  }
  /**
   * Returns information about the invisible ground plane onto which
   * simple shadows and reflections are projected.
   *
   * See also:
   *  - [[setGroundPlane]]
   */
  getGroundPlane() {
    return { ...this._groundPlane };
  }
  /**
   * Sets the width and height in pixels of the texture image into which
   * simple shadows are drawn.
   *
   * See also:
   *  - [[getSimpleShadowResolution]]
   *  - [[setSimpleShadowEnabled]]
   *
   * @param pixels The resolution to set.
   */
  setSimpleShadowResolution(t) {
    this._simpleShadowResolution = t, this._engine.setSimpleShadowResolution(this._id, t);
  }
  /**
   * Returns the width and height in pixels of the texture image
   * into which simple shadows are drawn.
   *
   * See also:
   *  - [[getSimpleShadowResolution]]
   *  - [[setSimpleShadowEnabled]]
   */
  getSimpleShadowResolution() {
    return this._simpleShadowResolution;
  }
  /**
   * Sets the diameter of the blur filter used for simple shadows.
   * Setting the value to `0` will disable blurring.
   *
   * See also:
   *  - [[getSimpleShadowBlurSamples]]
   *  - [[setSimpleShadowEnabled]]
   *
   * @param value The number of samples.
   */
  setSimpleShadowBlurSamples(t) {
    this._simpleShadowBlurSamples = t, this._engine.setSimpleShadowBlurSamples(this._id, t);
  }
  /**
   * Returns the diameter of the blur filter used for simple shadows.
   *
   * See also:
   *  - [[setSimpleShadowBlurSamples]]
   *  - [[setSimpleShadowEnabled]]
   */
  getSimpleShadowBlurSamples() {
    return this._simpleShadowBlurSamples;
  }
  /**
   * Sets the distance in pixels between samples taken by the blur filter
   * used for simple shadows.
   *
   * See also:
   *  - [[getSimpleShadowBlurInterval]]
   *  - [[setSimpleShadowEnabled]]
   *
   * @param value The interval to set.
   */
  setSimpleShadowBlurInterval(t) {
    this._simpleShadowBlurInterval = t, this._engine.setSimpleShadowBlurInterval(this._id, t);
  }
  /**
   * Returns the distance in pixels between samples taken by the blur
   * filter used for simple shadows.
   *
   * See also:
   *  - [[setSimpleShadowBlurInterval]]
   *  - [[setSimpleShadowEnabled]]
   */
  getSimpleShadowBlurInterval() {
    return this._simpleShadowBlurInterval;
  }
  /**
   * Enables or disables updates to simple shadows during user
   * interaction.
   *
   * See also:
   *  - [[getSimpleShadowInteractiveUpdateEnabled]]
   *  - [[setSimpleShadowEnabled]]
   */
  setSimpleShadowInteractiveUpdateEnabled(t = !0) {
    this._simpleShadowInteractiveUpdateEnabled = t, this._engine.setSimpleShadowInteractiveUpdateEnabled(this._id, t);
  }
  /**
   * Returns whether simple shadows will be updated during user
   * interaction.
   *
   * See also:
   *  - [[setSimpleShadowInteractiveUpdateEnabled]]
   *  - [[setSimpleShadowEnabled]]
   */
  getSimpleShadowInteractiveUpdateEnabled() {
    return this._simpleShadowInteractiveUpdateEnabled;
  }
  /**
   * Enables or disables silhouette edges.
   *
   * Silhouette edges are always enabled in hidden line mode.
   *
   * See also:
   * - [[getSilhouetteEnabled]]
   * - [[setSilhouetteColor]]
   * - [[setSilhouetteOpacity]]
   * - [[setSilhouetteThreshold]]
   * - [[setSilhouetteThresholdRampWidth]]
   *
   * @param value Whether silhouette edges should be enabled.
   */
  setSilhouetteEnabled(t = !0) {
    this._silhouetteEnabled = t, this._engine.setSilhouetteEnabled(this._id, t);
  }
  /**
   * Returns whether silhouette edges are enabled.
   *
   * Silhouette edges are always enabled in hidden line mode, regardless
   * of the return value.
   *
   * See [[setSilhouetteEnabled]].
   */
  getSilhouetteEnabled() {
    return this._silhouetteEnabled;
  }
  /**
   * Sets the color of silhouette edges.
   *
   * See also:
   * - [[getSilhouetteColor]]
   * - [[setSilhouetteEnabled]]
   *
   * @param value The color to set.
   */
  setSilhouetteColor(t) {
    this._silhouetteColor = t.copy(), this._engine.setSilhouetteColor(this._id, t);
  }
  /**
   * Returns the color of silhouette edges.
   *
   * See also:
   * - [[setSilhouetteColor]]
   * - [[setSilhouetteEnabled]]
   */
  getSilhouetteColor() {
    return this._silhouetteColor.copy();
  }
  /**
   * Sets the opacity of silhouette edges.
   *
   * See also:
   * - [[getSilhouetteOpacity]]
   * - [[setSilhouetteEnabled]]
   *
   * @param value The opacity to set.
   */
  setSilhouetteOpacity(t) {
    this._silhouetteOpacity = t, this._engine.setSilhouetteOpacity(this._id, t);
  }
  /**
   * Returns the opacity of silhouette edges.
   *
   * See also:
   * - [[setSilhouetteOpacity]]
   * - [[setSilhouetteEnabled]]
   */
  getSilhouetteOpacity() {
    return this._silhouetteOpacity;
  }
  /**
   * Sets the distance threshold for silhouette edges. This value
   * affects the minimum z-distance required between two pixels
   * for an edge to be drawn. A smaller value will result in more edges
   * being drawn on finer details.
   *
   * The value is a proportion of the canvas size and not a world-space
   * distance.
   *
   * See also:
   * - [[getSilhouetteThreshold]]
   * - [[setSilhouetteThresholdRampWidth]]
   * - [[setSilhouetteEnabled]]
   *
   * @param value The threshold to set.
   */
  setSilhouetteThreshold(t) {
    this._silhouetteThreshold = t, this._engine.setSilhouetteThreshold(this._id, t);
  }
  /**
   * Returns the distance threshold for silhouette edges. This value
   * affects the minimum z-distance required between two pixels
   * for an edge to be drawn. A smaller value will result in more edges
   * being drawn on finer details.
   *
   * The value is a proportion of the canvas size and not a world-space
   * distance.
   *
   * See also:
   * - [[setSilhouetteThreshold]]
   * - [[setSilhouetteThresholdRampWidth]]
   * - [[setSilhouetteEnabled]]
   *
   * @param value The threshold to set.
   */
  getSilhouetteThreshold() {
    return this._silhouetteThreshold;
  }
  /**
   * Controls how quickly edges fade as z-distance between pixels
   * decreases.
   *
   * This value is added to the one set by [[setSilhouetteThreshold]]
   * to create a secondary threshold. Distances greater than the
   * secondary threshold will result in edges with full opacity, and
   * distances between the two thresholds will result in edges with
   * reduced opacity.
   *
   * Setting this value to `0` will cause all edges to be drawn
   * at full opacity.
   *
   * See also:
   * - [[getSilhouetteThresholdRampWidth]]
   * - [[setSilhouetteEnabled]]
   */
  setSilhouetteThresholdRampWidth(t) {
    this._silhouetteThresholdRampWidth = t, this._engine.setSilhouetteThresholdRampWidth(this._id, t);
  }
  /**
   * Returns the value set by [[setSilhouetteThresholdRampWidth]].
   *
   * This value is added to the one set by [[setSilhouetteThreshold]]
   * to create a secondary threshold. Distances greater than the
   * secondary threshold will result in edges with full opacity, and
   * distances between the two thresholds will result in edges with
   * reduced opacity.
   *
   * A value of `0` means that all edges are drawn at full opacity.
   *
   * See also:
   * - [[setSilhouetteThresholdRampWidth]]
   * - [[setSilhouetteEnabled]]
   */
  getSilhouetteThresholdRampWidth() {
    return this._silhouetteThresholdRampWidth;
  }
  /**
   * Enables or disables hard edges. Hard edges are edges between two
   * faces whose normals diverge beyond a given angle.
   *
   * Hard edges are always enabled in hidden line mode.
   *
   * See also:
   * - [[getHardEdgesEnabled]]
   * - [[setHardEdgeColor]]
   * - [[setHardEdgeOpacity]]
   * - [[setHardEdgeThreshold]]
   * - [[setHardEdgeThresholdRampWidth]]
   *
   * @param value Whether hard edges should be enabled.
   */
  setHardEdgesEnabled(t = !0) {
    this._hardEdgesEnabled = t, this._engine.setHardEdgesEnabled(this._id, t);
  }
  /**
   * Returns whether hard edges are enabled. Hard edges are edges between
   * two faces whose normals diverge beyond a given angle.
   *
   * Hard edges are always enabled in hidden line mode, regardless of the
   * return value.
   *
   * See [[setHardEdgesEnabled]].
   */
  getHardEdgesEnabled() {
    return this._hardEdgesEnabled;
  }
  /**
   * Sets the color of hard edges.
   *
   * See also:
   * - [[getHardEdgeColor]]
   * - [[setHardEdgesEnabled]]
   *
   * @param value The color to set.
   */
  setHardEdgeColor(t) {
    this._hardEdgeColor = t.copy(), this._engine.setHardEdgeColor(this._id, t);
  }
  /**
   * Returns the color of hard edges.
   *
   * See also:
   * - [[setHardEdgeColor]]
   * - [[setHardEdgesEnabled]]
   */
  getHardEdgeColor() {
    return this._hardEdgeColor.copy();
  }
  /**
   * Sets the opacity of hard edges.
   *
   * See also:
   * - [[getHardEdgeOpacity]]
   * - [[setHardEdgesEnabled]]
   *
   * @param value The opacity to set.
   */
  setHardEdgeOpacity(t) {
    this._hardEdgeOpacity = t, this._engine.setHardEdgeOpacity(this._id, t);
  }
  /**
   * Returns the opacity of hard edges.
   *
   * See also:
   * - [[setHardEdgeOpacity]]
   * - [[setHardEdgesEnabled]]
   */
  getHardEdgeOpacity() {
    return this._hardEdgeOpacity;
  }
  /**
   * Sets the angle threshold for hard edges. Edges will be drawn between
   * two faces whose normals diverge beyond this angle.
   *
   * See also:
   * - [[getHardEdgeThreshold]]
   * - [[setHardEdgeThresholdRampWidth]]
   * - [[setHardEdgesEnabled]]
   *
   * @param degrees The threshold to set.
   */
  setHardEdgeThreshold(t) {
    this._hardEdgeThreshold = t, this._engine.setHardEdgeThreshold(this._id, t);
  }
  /**
   * Returns the angle threshold for hard edges. Edges will be drawn
   * between two faces whose normals diverge beyond this angle.
   *
   * See also:
   * - [[setHardEdgeThreshold]]
   * - [[setHardEdgeThresholdRampWidth]]
   * - [[setHardEdgesEnabled]]
   *
   * @param value The threshold to set.
   */
  getHardEdgeThreshold() {
    return this._hardEdgeThreshold;
  }
  /**
   * Controls how quickly edges fade as the angle between adjacent faces
   * decreases.
   *
   * This value is added to the one set by [[setHardEdgeThreshold]] to
   * create a secondary threshold. Angles greater than the secondary
   * threshold will result in edges with full opacity, and angles between
   * the two thresholds will result in edges with reduced opacity.
   *
   * Setting this value to `0` will cause all edges to be drawn at full
   * opacity.
   *
   * See also:
   * - [[getHardEdgeThresholdRampWidth]]
   * - [[setHardEdgesEnabled]]
   */
  setHardEdgeThresholdRampWidth(t) {
    this._hardEdgeThresholdRampWidth = t, this._engine.setHardEdgeThresholdRampWidth(this._id, t);
  }
  /**
   * Returns the value set by [[setHardEdgeThresholdRampWidth]].
   *
   * This value is added to the one set by [[setHardEdgeThreshold]] to
   * create a secondary threshold. Angles greater than the secondary
   * threshold will result in edges with full opacity, and angles between
   * the two thresholds will result in edges with reduced opacity.
   *
   * A value of `0` means that all edges are drawn at full opacity.
   *
   * See also:
   * - [[setHardEdgeThresholdRampWidth]]
   * - [[setHardEdgesEnabled]]
   */
  getHardEdgeThresholdRampWidth() {
    return this._hardEdgeThresholdRampWidth;
  }
  /**
   * Enables or disables simple reflections projected onto an
   * invisible ground plane.
   *
   * See also:
   * - [[getSimpleReflectionEnabled]]
   * - [[setSimpleReflectionOpacity]]
   * - [[setSimpleReflectionBlurSamples]]
   * - [[setSimpleReflectionBlurInterval]]
   * - [[setSimpleReflectionFadeAngle]]
   */
  setSimpleReflectionEnabled(t = !0) {
    this._simpleReflectionEnabled = t, this._engine.setSimpleReflectionEnabled(this._id, t);
  }
  /**
   * Returns whether simple reflections are enabled.
   *
   * See [[setSimpleReflectionEnabled]].
   */
  getSimpleReflectionEnabled() {
    return this._simpleReflectionEnabled;
  }
  /**
   * Sets the distance between samples taken by the blur filter used for
   * simple reflections.
   *
   * See also:
   *  - [[getSimpleReflectionBlurInterval]]
   *  - [[setSimpleReflectionEnabled]]
   *
   * @param value The interval to set.
   * @param unit The unit in which the `value` argument is specified.
   */
  setSimpleReflectionBlurInterval(t, e = Ks.Pixels) {
    this._simpleReflectionBlurInterval = [t, e], this._engine.setSimpleReflectionBlurInterval(this._id, t, e);
  }
  /**
   * Returns the distance between samples taken by the blur filter used
   * for simple reflections.
   *
   * See also:
   *  - [[setSimpleReflectionBlurInterval]]
   *  - [[setSimpleReflectionEnabled]]
   */
  getSimpleReflectionBlurInterval() {
    return [this._simpleReflectionBlurInterval[0], this._simpleReflectionBlurInterval[1]];
  }
  /**
   * Sets the diameter of the blur filter used for simple reflections.
   * Setting the value less than or equal to `1` will disable blurring.
   *
   * See also:
   * - [[getSimpleReflectionBlurSamples]]
   * - [[setSimpleReflectionEnabled]]
   */
  setSimpleReflectionBlurSamples(t) {
    this._simpleReflectionBlurSamples = t, this._engine.setSimpleReflectionBlurSamples(this._id, t);
  }
  /**
   * Returns the diameter of the blur filter used for simple reflections.
   * A value less than or equal to `1` means that blurring is disabled.
   *
   * See also:
   * - [[setSimpleReflectionBlurSamples]]
   * - [[setSimpleReflectionEnabled]]
   */
  getSimpleReflectionBlurSamples() {
    return this._simpleReflectionBlurSamples;
  }
  /**
   * Sets the angle, in degrees, between the view vector and the ground
   * plane at which simple reflections begin to fade.
   *
   * Settings the value to `0` will disable the fading effect.
   *
   * Regardless of the value, simple reflections will not be drawn
   * if the camera is below the ground plane.
   *
   * See also:
   * - [[getSimpleReflectionFadeAngle]]
   * - [[setSimpleReflectionEnabled]]
   *
   * @param degrees The angle in degrees.
   */
  setSimpleReflectionFadeAngle(t) {
    this._simpleReflectionFadeAngle = t, this._engine.setSimpleReflectionFadeAngle(this._id, t);
  }
  /**
   * Returns the angle, in degrees, between the view vector and the ground
   * plane at which simple reflections begin to fade.
   *
   * A value to `0` means that the fading effect is disabled.
   *
   * Regardless of the value, simple reflections will not be drawn
   * if the camera is below the ground plane.
   *
   * See also:
   * - [[setSimpleReflectionFadeAngle]]
   * - [[setSimpleReflectionEnabled]]
   */
  getSimpleReflectionFadeAngle() {
    return this._simpleReflectionFadeAngle;
  }
  /**
   * Sets the opacity of simple reflections.
   *
   * See also:
   *  - [[getSimpleReflectionOpacity]]
   *  - [[setSimpleReflectionEnabled]]
   *
   * @param opacity The opacity to set.
   */
  setSimpleReflectionOpacity(t) {
    this._simpleReflectionOpacity = t, this._engine.setSimpleReflectionOpacity(this._id, t);
  }
  /**
   * Returns the opacity of simple reflections.
   *
   * See also:
   *  - [[setSimpleReflectionOpacity]]
   *  - [[setSimpleReflectionEnabled]]
   */
  getSimpleReflectionOpacity() {
    return this._simpleReflectionOpacity;
  }
  /**
   * Controls how objects drawn in simple reflections fade as they
   * move further from the ground plane.
   *
   * Attenuation begins at `nearDistance` and increases linearly
   * such that the model is not visible in the reflection beyond
   * `farDistance`.
   *
   * Attenuation is disabled if `farDistance` is less than or equal to
   * `nearDistance`.
   *
   * See also:
   *  - [[getSimpleReflectionAttenuation]]
   *  - [[setSimpleReflectionEnabled]]
   *
   * @param nearDistance The distance from the ground plane at which
   * objects begin to fade.
   * @param farDistance The distance from the ground plane at which
   * objects are completely faded.
   * @param unit The unit in which `nearDistance` and `farDistance` are
   * specified. If unspecified, [[SimpleReflectionAttenuationUnit.World]]
   * will be used.
   */
  setSimpleReflectionAttenuation(t, e, i = Lf.World) {
    this._simpleReflectionAttenuation = {
      nearDistance: t,
      farDistance: e,
      unit: i
    }, this._engine.setSimpleReflectionAttenuation(t, e, i);
  }
  /**
   * Returns properties that control how objects drawn in simple
   * reflections fade as they move further from the ground plane.
   *
   * Attenuation begins at `nearDistance` and increases linearly
   * such that the model is not visible in the reflection beyond
   * `farDistance`.
   *
   * Attenuation is disabled if `farDistance` is less than or equal to
   * `nearDistance`.
   *
   * See also:
   *  - [[setSimpleReflectionAttenuation]]
   *  - [[setSimpleReflectionEnabled]]
   *
   * @returns An object with the following properties:
   */
  // return type properties are listed by Typedoc
  getSimpleReflectionAttenuation() {
    return { ...this._simpleReflectionAttenuation };
  }
  /**
   * Tests whether the given points are visible by comparing them to
   * the depth buffer of the most-recently-drawn frame. Points that
   * are partially obscured by transparent objects are considered visible.
   *
   * If the test is to be run every time a frame is drawn,
   * [[setPointVisibilityTest]] should be used instead for proper
   * synchronization.
   *
   * @param points The points to test.
   * @returns A list of indices of the visible points.
   */
  testPointVisibility(t) {
    return this._engine.testPointVisibility(this._id, t);
  }
  /**
   * Sets a list of points whose visibility will be tested every time a
   * frame is drawn by comparing them to the frame's depth buffer. Points
   * that are partially obscured by transparent objects are considered
   * visible.
   *
   * The results are passed to the [[CallbackMap.frameDrawn]] callback so
   * that UI elements may be updated in sync with rendering.
   *
   * See also [[testPointVisibility]].
   *
   * @param points The points to test. An empty array will disable the test.
   */
  setPointVisibilityTest(t) {
    this._engine.setPointVisibilityTest(this._id, t);
  }
  /**
   * Sets whether image-based lighting is enabled for physically-based
   * materials.
   *
   * See also:
   * - [[getImageBasedLightingEnabled]]
   * - [[setImageBasedLightingIntensity]]
   * - [[setImageBasedLightingOrientation]]
   */
  setImageBasedLightingEnabled(t) {
    this._engine.setImageBasedLightingEnabled(this._id, t), this._imageBasedLightingEnabled = t;
  }
  /**
   * Returns whether image-based lighting is enabled for physically-based
   * materials.
   *
   * See also:
   * - [[setImageBasedLightingEnabled]]
   * - [[setImageBasedLightingIntensity]]
   * - [[setImageBasedLightingOrientation]]
   */
  getImageBasedLightingEnabled() {
    return this._imageBasedLightingEnabled;
  }
  /**
   * Sets the intensity (brightness) of image-based lighting applied to
   * physically-based materials.
   *
   * The default value is 1.
   *
   * See also:
   * - [[getImageBasedLightingIntensity]]
   * - [[setImageBasedLightingEnabled]]
   * - [[setImageBasedLightingOrientation]]
   */
  setImageBasedLightingIntensity(t) {
    this._engine.setImageBasedLightingIntensity(this._id, t), this._imageBasedLightingIntensity = t;
  }
  /**
   * Returns the intensity (brightness) of image-based lighting applied to
   * physically-based materials.
   *
   * The default value is 1.
   *
   * See also:
   * - [[setImageBasedLightingIntensity]]
   * - [[setImageBasedLightingEnabled]]
   * - [[setImageBasedLightingOrientation]]
   */
  getImageBasedLightingIntensity() {
    return this._imageBasedLightingIntensity;
  }
  _copyImageBasedLightingOrientation(t) {
    return { ...t, matrix: t.matrix.copy() };
  }
  /**
   * Sets the orientation of the image-based lighting environment applied
   * to physically-based materials.
   *
   * See also:
   * - [[getImageBasedLightingOrientation]]
   * - [[setImageBasedLightingEnabled]]
   * - [[setImageBasedLightingIntensity]]
   */
  setImageBasedLightingOrientation(t) {
    this._imageBasedLightingOrientation = this._copyImageBasedLightingOrientation(t), this._updateImageBasedLightingOrientation();
  }
  /**
   * Returns the orientation of the image-based lighting environment
   * applied to physically-based materials.
   *
   * See also:
   * - [[setImageBasedLightingOrientation]]
   * - [[setImageBasedLightingEnabled]]
   * - [[setImageBasedLightingIntensity]]
   */
  getImageBasedLightingOrientation() {
    return this._copyImageBasedLightingOrientation(this._imageBasedLightingOrientation);
  }
  _updateImageBasedLightingOrientation(t, e) {
    let i;
    if (this._imageBasedLightingOrientation.followViewAxes) {
      if (t === void 0 || e === void 0)
        if (this._model.viewAxesHaveBeenSet()) {
          const r = this._model.getViewAxes();
          t = r.frontVector, e = r.upVector;
        } else
          t = new _(0, 0, 1), e = new _(0, 1, 0);
      const n = mt.createFromBasis(
        _.cross(e, t),
        e,
        t
      );
      i = mt.multiply(this._imageBasedLightingOrientation.matrix, n);
    } else
      i = this._imageBasedLightingOrientation.matrix;
    this._engine.setImageBasedLightingMatrix(this._id, i);
  }
  /**
   * Sets the environment image used by image-based lighting applied to
   * physically-based materials.
   *
   * Passing `null` will cause the default environment image to be used.
   *
   * The image should be a cube map in KTX2 format with a space-separated
   * list of spherical harmonics coefficients stored under the "sh"
   * metadata key.
   *
   * A compatible image can be created from an equirectangular source
   * image (such as those found at [HDRI Haven](https://hdrihaven.com))
   * with the following process:
   *
   * - cmgen: https://github.com/google/filament
   * - ktx2ktx2, ktx2sc: https://github.com/KhronosGroup/KTX-Software/
   *
   * ```
   * cmgen -x out --format=ktx --size=256 in.hdr
   * ktx2ktx2 -o uncompressed.ktx2 out/out_ibl.ktx
   * ktxsc --zcmp 20 -o out.ktx2 uncompressed.ktx2
   * ```
   */
  setImageBasedLightingEnvironment(t) {
    t != null ? this._engine.setImageBasedLightingEnvironment(this._id, t) : this._engine.setImageBasedLightingEnvironmentToDefault(this._id);
  }
  /**
   * Sets whether line jitter is enabled.
   *
   * Line jitter makes lines look 'sketchy' by drawing them multiple times
   * with randomized offsets applied to the vertices.
   *
   * See also:
   * - [[getLineJitterEnabled]]
   * - [[setLineJitterInstanceCount]]
   * - [[setLineJitterRadius]]
   * - [[setLineJitterFrequency]]
   */
  setLineJitterEnabled(t = !0) {
    this._engine.setLineJitterEnabled(this._id, t), this._lineJitterEnabled = t;
  }
  /**
   * Returns whether line jitter is enabled.
   *
   * Line jitter makes lines look 'sketchy' by drawing them multiple times
   * with randomized offsets applied to the vertices.
   *
   * See also:
   * - [[setLineJitterEnabled]]
   * - [[getLineJitterInstanceCount]]
   * - [[getLineJitterRadius]]
   * - [[getLineJitterFrequency]]
   */
  getLineJitterEnabled() {
    return this._lineJitterEnabled;
  }
  /**
   * Sets the number of times lines are drawn when line jitter is enabled.
   * The default value is 4.
   *
   * Increasing this number can make the lines look more 'sketchy.'
   *
   * See also:
   * - [[setLineJitterEnabled]]
   * - [[getLineJitterInstanceCount]]
   * - [[setLineJitterRadius]]
   * - [[setLineJitterFrequency]]
   */
  setLineJitterInstanceCount(t) {
    this._engine.setLineJitterInstanceCount(this._id, t), this._lineJitterInstanceCount = t;
  }
  /**
   * Returns the number of times lines are drawn when line jitter is
   * enabled. The default value is 4.
   *
   * See also:
   * - [[getLineJitterEnabled]]
   * - [[setLineJitterInstanceCount]]
   * - [[getLineJitterRadius]]
   * - [[getLineJitterFrequency]]
   */
  getLineJitterInstanceCount() {
    return this._lineJitterInstanceCount;
  }
  /**
   * Sets the radius of the random offset applied to line vertices when
   * line jitter is enabled. The default value is 0.005.
   *
   * The value is specified as a proportion of the canvas height, where 1
   * means the full height of the canvas.
   *
   * See also:
   * - [[setLineJitterEnabled]]
   * - [[setLineJitterInstanceCount]]
   * - [[getLineJitterRadius]]
   * - [[setLineJitterFrequency]]
   */
  setLineJitterRadius(t) {
    this._engine.setLineJitterRadius(this._id, t), this._lineJitterRadius = t;
  }
  /**
   * Returns the radius of the random offset applied to line vertices when
   * line jitter is enabled. The default value is 0.005.
   *
   * The value is specified as a proportion of the canvas height, where 1
   * means the full height of the canvas.
   *
   * See also:
   * - [[getLineJitterEnabled]]
   * - [[getLineJitterInstanceCount]]
   * - [[setLineJitterRadius]]
   * - [[getLineJitterFrequency]]
   */
  getLineJitterRadius() {
    return this._lineJitterRadius;
  }
  /**
   * Sets the frequency of the noise used to offset line vertices when
   * line jitter is enabled. The default value is 5.
   *
   * Decreasing this value causes lines to appear smoother, while
   * increasing it causes lines to look more noisy.
   *
   * See also:
   * - [[setLineJitterEnabled]]
   * - [[setLineJitterInstanceCount]]
   * - [[setLineJitterRadius]]
   * - [[getLineJitterFrequency]]
   */
  setLineJitterFrequency(t) {
    this._engine.setLineJitterFrequency(this._id, t), this._lineJitterFrequency = t;
  }
  /**
   * Returns the frequency of the noise used to offset line vertices when
   * line jitter is enabled. The default value is 5.
   *
   * See also:
   * - [[getLineJitterEnabled]]
   * - [[getLineJitterInstanceCount]]
   * - [[getLineJitterRadius]]
   * - [[setLineJitterFrequency]]
   */
  getLineJitterFrequency() {
    return this._lineJitterFrequency;
  }
}
class sl {
  constructor() {
    this._remappedModelKeys = /* @__PURE__ */ new Map(), this._remappedInclusionKeys = /* @__PURE__ */ new Map();
  }
  remapModel(t, e) {
    this._remappedModelKeys.set(e, t), this._remappedInclusionKeys.has(t) || this._remappedInclusionKeys.set(t, /* @__PURE__ */ new Map());
  }
  remapInclusion(t, e, i) {
    const n = this._remappedInclusionKeys.get(t);
    console.assert(n !== void 0), n.set(i, e);
  }
  getEffectiveModelKey(t) {
    const e = this._remappedModelKeys.get(t);
    return e !== void 0 ? e : t;
  }
  getEffectiveInclusionKey(t, e) {
    const i = this._remappedInclusionKeys.get(e);
    if (i !== void 0) {
      const n = i.get(t);
      if (n !== void 0)
        return n;
    }
    return t;
  }
}
async function Nx(s) {
  const t = [], i = {
    enterProductOccurrence: (n) => {
      n.hasPendingExternalModels() && t.push(n);
    }
  };
  return await Ln.walk(i, s, Vt.None), t;
}
class Dx {
  constructor() {
    this._currentTime = 0, this._stopTime = 0;
  }
  stop() {
    this._stopTime = this._currentTime;
  }
  isTicking() {
    return this._refreshCurrentTime(), this._remainingDuration() > 0;
  }
  tickFor(t) {
    this._refreshCurrentTime(), !(this._remainingDuration() >= t) && (this._stopTime = this._currentTime + t);
  }
  _remainingDuration() {
    return this._stopTime - this._currentTime;
  }
  _refreshCurrentTime() {
    this._currentTime = Date.now();
  }
}
const Ox = 4294967296;
class Rx {
  constructor() {
    this.prototypes = /* @__PURE__ */ new Map(), this.partDefinitions = /* @__PURE__ */ new Map();
  }
}
class Lx {
  constructor() {
    this.bodies = /* @__PURE__ */ new Map(), this.contexts = [];
  }
}
class Fx {
  constructor(t, e, i, n, r) {
    this._centralQueueClock = new Dx(), this._productOccurrences = /* @__PURE__ */ new Map(), this._pmis = /* @__PURE__ */ new Map(), this._cadViews = /* @__PURE__ */ new Map(), this._bodyInstances = /* @__PURE__ */ new Map(), this._pmiBodies = /* @__PURE__ */ new Map(), this._viewFrames = /* @__PURE__ */ new Map(), this._partDefinitions = /* @__PURE__ */ new Map(), this._representationItems = /* @__PURE__ */ new Map(), this._partToInstance = /* @__PURE__ */ new Map(), this._filters = [], this._layers = /* @__PURE__ */ new Map(), this._layersIds = /* @__PURE__ */ new Map(), this._nextLayerId = 0, this._genericTypeToNodes = /* @__PURE__ */ new Map(), this._genericIdToNodes = /* @__PURE__ */ new Map(), this._cadConfigurations = /* @__PURE__ */ new Set(), this._modelContents = /* @__PURE__ */ new Map(), this._inclusionContents = /* @__PURE__ */ new Map(), this._nodeDeletionBlackList = /* @__PURE__ */ new Set(), this._meshDeletionBlackList = /* @__PURE__ */ new Set(), this._dynamicNodeIdSeed = Ts, this._currentNodeIdOffset = 0, this._initialEmptyNodeIdOffsetObtained = !1, this._activeCadView = null, this._activeCadConfiguration = null, this._defaultCadConfiguration = null, this._defaultCadViewsByConfiguration = /* @__PURE__ */ new Map(), this._firstProductOccurrenceWithView = null, this._containsDrawings = !1, this._isMeasurable = !1, this._automaticMeasurementUnitScaling = !0, this._initiallyHiddenStayHidden = !0, this._nextLoadId = 0, this._activeLoadIds = /* @__PURE__ */ new Set(), this._requestedNodes = /* @__PURE__ */ new Map(), this._unnamedProductCount = 0, this._unnamedGroupCount = 0, this._unnamedDrawingSheetCount = 0, this._unnamedDrawingViewCount = 0, this._isInitialized = !1, this._seenExternalModel = !1, this._config = { ...t }, this._engine = e, this._callbackManager = i, this._cuttingManager = n, this._model = r, this._isScs = this._engine.getSessionType() === en.Scs, console.assert(!this._isScs || this._engine.getRendererType() === lh.Client);
  }
  initialize(t) {
    console.assert(this._rootLoadContext === void 0), console.assert(this._rootNode === void 0), console.assert(!this._isInitialized), this._isInitialized = !0, console.assert(this._centralQueue === void 0), this._centralQueue = new jo(t.maxConcurrentAttachments(), !1), this._callbackManager.bind({
      _inputInteraction: (n, r) => {
        this._onUserInteraction(n, r);
      }
    }), this._rootLoadContext = new Ls(null, ba, null);
    const e = new Pn(
      new sl(),
      Ia.OfInitialEmptyModel,
      !1,
      Ur.Local,
      this._rootLoadContext
    );
    this._rootLoadContext.addAttachContext(e);
    const i = new Gn(
      this,
      e,
      Ei.Local,
      xs.Local
    );
    e.addInclusionContext(i), this._rootNode = _e.createDynamic(
      this,
      i,
      "Models",
      null,
      null,
      !0
    ), i.addProductOccurrence(this._rootNode), console.assert(this._rootNode.isAbsoluteRoot()), this.preventNodeDeletion(this._rootLoadContext), this.preventNodeDeletion(e), this.preventNodeDeletion(i), this.preventNodeDeletion(this._rootNode), this._rootNode.markLoaded();
  }
  isInitialized() {
    return this._isInitialized;
  }
  getRootNode() {
    return this._rootNode;
  }
  getAbstractScEngine() {
    return this._engine;
  }
  generateDynamicNodeId() {
    return --this._dynamicNodeIdSeed;
  }
  newNodeIdOffset() {
    if (!this._initialEmptyNodeIdOffsetObtained)
      return this._initialEmptyNodeIdOffsetObtained = !0, console.assert(this._currentNodeIdOffset === 0), 0;
    const t = this._currentNodeIdOffset;
    return this._currentNodeIdOffset += Ox, t;
  }
  /**
   * Please don't use me. This was kept for legacy reasons with Erwan's tree, which
   * had fundamental design problems with NodeIds (because they could conflict).
   */
  getLowestAvailableNodeId() {
    return this._currentNodeIdOffset;
  }
  tryParseHeader(t) {
    const e = Ys.parseBinary(t);
    return e === null ? null : (this._containsDrawings = this._containsDrawings || e.isDrawing, this._isMeasurable = this._isMeasurable || e.isMeasurable, this._callbackManager.promiseTrigger("_modelStructureHeaderParsed", null, e).then(() => (this._callbackManager.trigger(
      "modelStructureHeaderParsed",
      e.originalFileName,
      e.originalFileType
    ), e)));
  }
  _isRegistered(t) {
    return this._productOccurrences.has(t) || this._pmis.has(t) || this._cadViews.has(t) || this._bodyInstances.has(t) || this._pmiBodies.has(t) || this._viewFrames.has(t) || this._partDefinitions.has(t) || this._representationItems.has(t);
  }
  registerProductOccurrence(t) {
    if (!t.isMissing()) {
      const e = t.getRuntimeId();
      console.assert(!this._isRegistered(e)), this._productOccurrences.set(e, t);
      const i = ah(t);
      i !== null && this.registerGenericType(t, i);
      const n = t.getGenericId();
      n !== null && this.registerGenericGlobalId(t, n), t.isAConfigurationNode() && this._registerCadConfiguration(t), (t.isADrawingSheetNode() || t.isADrawingViewNode()) && (this._containsDrawings = !0);
    }
  }
  lookupProductOccurrence(t) {
    const e = this._productOccurrences.get(t);
    return e !== void 0 ? e : null;
  }
  registerPmi(t) {
    const e = t.getRuntimeId();
    console.assert(!this._isRegistered(e)), this._pmis.set(e, t);
  }
  lookupPmi(t) {
    const e = this._pmis.get(t);
    return e !== void 0 ? e : null;
  }
  registerCadView(t) {
    this._firstProductOccurrenceWithView === null && (this._firstProductOccurrenceWithView = t.getParent());
    const e = t.getRuntimeId();
    console.assert(!this._isRegistered(e)), this._cadViews.set(e, t), t.isDefaultView() && this._defaultCadViewsByConfiguration.set(this._firstProductOccurrenceWithView, t);
  }
  getFirstProductOccurrenceWithView() {
    return this._firstProductOccurrenceWithView;
  }
  lookupCadView(t) {
    const e = this._cadViews.get(t);
    return e !== void 0 ? e : null;
  }
  registerBodyInstance(t, e) {
    const i = t.getRuntimeId();
    console.assert(!this._isRegistered(i)), this._bodyInstances.set(i, t), this._registerAnyBodyByInstanceInc(t, e);
  }
  lookupBodyInstance(t) {
    const e = this._bodyInstances.get(t);
    return e !== void 0 ? e : null;
  }
  registerPmiBody(t, e) {
    const i = t.getRuntimeId();
    console.assert(!this._isRegistered(i)), this._pmiBodies.set(i, t), this._registerAnyBodyByInstanceInc(t, e);
  }
  lookupPmiBody(t) {
    const e = this._pmiBodies.get(t);
    return e !== void 0 ? e : null;
  }
  registerViewFrame(t, e) {
    const i = t.getRuntimeId();
    console.assert(!this._isRegistered(i)), this._viewFrames.set(i, t), this._registerAnyBodyByInstanceInc(t, e);
  }
  lookupViewFrame(t) {
    const e = this._viewFrames.get(t);
    return e !== void 0 ? e : null;
  }
  registerPartDefinition(t) {
    if (!t.isMissing()) {
      const e = t.getRuntimeId();
      console.assert(!this._isRegistered(e)), this._partDefinitions.set(e, t);
    }
  }
  lookupPartDefinition(t) {
    const e = this._partDefinitions.get(t);
    return e !== void 0 ? e : null;
  }
  registerRepresentationItem(t) {
    const e = t.getRuntimeId();
    console.assert(!this._isRegistered(e)), this._representationItems.set(e, t);
  }
  lookupRepresentationItem(t) {
    const e = this._representationItems.get(t);
    return e !== void 0 ? e : null;
  }
  lookupAnyBody(t) {
    return this.lookupBodyInstance(t) || this.lookupPmiBody(t) || this.lookupViewFrame(t);
  }
  lookupAnyTreeNode(t) {
    return this.lookupProductOccurrence(t) || this.lookupPmi(t) || this.lookupCadView(t) || this.lookupAnyBody(t);
  }
  lookupAnyNonTreeNode(t) {
    return this.lookupRepresentationItem(t) || this.lookupPartDefinition(t);
  }
  lookupAnyNode(t) {
    return this.lookupAnyTreeNode(t) || this.lookupAnyNonTreeNode(t);
  }
  _registerCadConfiguration(t) {
    console.assert(t.isAConfigurationNode()), console.assert(!this._cadConfigurations.has(t)), this._cadConfigurations.add(t), t.isADefaultNode() && this._defaultCadConfiguration === null && (this._defaultCadConfiguration = t);
  }
  getInstanceCountByInclusion(t) {
    return this._getInclusionContent(t).bodies.size;
  }
  lookupAnyBodyByInstanceInc(t, e) {
    const n = this._getInclusionContent(t).bodies.get(e);
    return n !== void 0 ? n : null;
  }
  _registerAnyBodyByInstanceInc(t, e) {
    const i = t.getInstanceInc(), n = this._getInclusionContent(e), r = n.bodies.get(i[1]);
    if (r !== void 0)
      if (console.assert(t.hasAuthoredId()), r.hasAuthoredId()) {
        console.assert(r.constructor === t.constructor);
        return;
      } else {
        const o = r;
        console.assert(o.constructor === Ui);
        const l = o.getRuntimeId();
        o.getParent().removeBodyInstance(o), t instanceof Ui ? this._bodyInstances.set(l, t) : t instanceof Bs ? this._pmiBodies.set(l, t) : this._viewFrames.set(l, t);
      }
    n.bodies.set(i[1], t);
  }
  _getInclusionContent(t) {
    console.assert(t !== Ei.Invalid);
    let e = this._inclusionContents.get(t);
    return e === void 0 && (e = new Lx(), this._inclusionContents.set(t, e)), e;
  }
  _getModelContent(t, e) {
    console.assert(e !== xs.Invalid);
    let i = this._modelContents.get(t);
    i === void 0 && (i = /* @__PURE__ */ new Map(), this._modelContents.set(t, i));
    let n = i.get(e);
    return n === void 0 && (n = new Rx(), i.set(e, n)), n;
  }
  registerPrototypeByDataId(t, e, i, n) {
    const r = this._getModelContent(t, e);
    console.assert(!r.prototypes.has(i)), r.prototypes.set(i, n);
  }
  registerPartDefinitionByDataId(t, e, i, n) {
    const r = this._getModelContent(t, e);
    console.assert(!r.partDefinitions.has(i)), r.partDefinitions.set(i, n);
  }
  lookupPrototypeByDataId(t, e, i) {
    const r = this._getModelContent(t, e).prototypes.get(i);
    return r !== void 0 ? r : null;
  }
  lookupPartDefinitionByDataId(t, e, i) {
    const r = this._getModelContent(t, e).partDefinitions.get(i);
    return r !== void 0 ? r : null;
  }
  registerInclusionContext(t) {
    const e = t.getInclusionKey();
    this._getInclusionContent(e).contexts.push(t);
  }
  getInclusionContexts(t) {
    return this._getInclusionContent(t).contexts;
  }
  _createLayer(t, e, i, n) {
    const r = new lo(t, e, i, n);
    return console.assert(!this._layers.has(t)), this._layers.set(t, r), e !== null && this._updateNameToLayersMap(e, t), r;
  }
  _updateNameToLayersMap(t, e) {
    const i = this._layersIds.get(t);
    i !== void 0 ? i.push(e) : this._layersIds.set(t, [e]);
  }
  /**
   * Creates a new layer in the assembly tree. Also creates a mapping in the supplied assembly tree from
   * the authored layer id to the effective, runtime, id.
   * @param authoredLayerId The authored ID of the layer. Used to create the mapping in the assembly tree
   * @param layerName Name of the layer
   * @param loadContext Attach context of the node creating the layer. A layer mapping will be created in it
   */
  createLayer(t, e, i) {
    const n = this._nextLayerId++, r = this._createLayer(n, e, [], []);
    return i.addLayerIdToMap(n, t), r;
  }
  /**
   * Changes the name of an existing layer.
   * @param layerId Layer id to update
   * @param layerName Name to be set
   */
  updateLayerName(t, e) {
    const i = this._layers.get(t);
    i !== void 0 && (i.name = e, this._updateNameToLayersMap(e, t));
  }
  _registerNodeInLayer(t, e, i) {
    const n = Js(t);
    let r = n.getRuntimeLayerId(e);
    e === lo.NoLayerId && r === null ? r = this.createLayer(lo.NoLayerId, "No layer", n).id : r === null && (r = this._nextLayerId++, this._createLayer(r, null, [], []), n.addLayerIdToMap(r, e));
    const o = this._layers.get(r);
    o !== void 0 ? i(o).push(t) : (console.assert(!1, "Layer has mapping in LoadContext but not represented in AssemblyTree"), this._createLayer(r, null, [t], []), n.addLayerIdToMap(r, e));
  }
  /**
   * Registers a node as part of a layer. This will create a layer if one doesn't exist.
   * @param node Node to be registered
   * @param authoredLayerId Authored id of the Layer
   */
  registerNodeInLayer(t, e) {
    return this._registerNodeInLayer(t, e, (i) => i.nodes);
  }
  /**
   * Registers a tree node as part of a layer. This will create a layer if one doesn't exist.
   * @param node Node to be registered
   * @param authoredLayerId Authored id of the Layer
   */
  registerTreeNodeInLayer(t, e) {
    return this._registerNodeInLayer(t, e, (i) => i.treeNodes);
  }
  addFilter(t, e) {
    this._filters.push({ filter: t, loadContext: e });
  }
  getFilters() {
    const t = /* @__PURE__ */ new Map();
    for (let e = 0; e < this._filters.length; e++) {
      const i = this.getFilterName(e) || "";
      t.set(e, i);
    }
    return t;
  }
  getFilterName(t) {
    if (t < this._filters.length) {
      const { filter: e } = this._filters[t];
      return e.name || "";
    }
    return null;
  }
  getFiltersWithNode(t) {
    const e = t.getAuthoredId(), i = this._filters, n = [];
    for (let r = 0; r < i.length; r++) {
      const { filter: o, loadContext: l } = i[r];
      if (o.layers !== null)
        for (const h of o.layers.authoredIds) {
          const u = l.getRuntimeLayerId(h);
          if (u === null)
            continue;
          const d = this.getNodesFromLayer(u);
          if (d !== null)
            for (const g of d)
              t === g && n.push(r);
        }
      if (o.entities !== null)
        for (const h of o.entities.ids)
          e === h && n.push(r);
    }
    return n;
  }
  getNodesFromFilterIds(t) {
    const e = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set();
    let n = null;
    for (const r of t) {
      const { filter: o, loadContext: l } = this._filters[r], h = o.layers;
      if (h !== null) {
        const d = h.isInclusive;
        n === null && (n = d);
        for (const g of h.authoredIds) {
          const y = l.getRuntimeLayerId(g);
          if (y === null)
            continue;
          const m = this._layers.get(y);
          if (m && m.nodes !== null)
            for (const x of m.nodes) {
              const b = x.getRuntimeId();
              d ? (e.add(b), i.delete(b)) : (e.delete(b), i.add(b));
            }
        }
      }
      const u = o.entities;
      if (u !== null) {
        const d = u.isInclusive;
        n === null && (n = d);
        for (const g of u.ids)
          d ? (e.add(g), i.delete(g)) : (e.delete(g), i.add(g));
      }
    }
    return n === null ? null : n ? new Gp(!0, e) : new Gp(!1, i);
  }
  getLayers() {
    const t = /* @__PURE__ */ new Map();
    return this._layers.forEach((e, i) => {
      const n = e.name || "";
      t.set(i, n);
    }), t;
  }
  getUniqueLayerNames() {
    const t = /* @__PURE__ */ new Set(), e = [];
    return this._layers.forEach((i) => {
      const n = i.name;
      n !== null && (t.has(n) || (t.add(n), e.push(n)));
    }), e;
  }
  getLayerName(t) {
    const e = this._layers.get(t);
    return e !== void 0 ? e.name || "" : null;
  }
  getLayersIdFromName(t) {
    const e = this._layersIds.get(t);
    return e !== void 0 ? e : null;
  }
  getNodesFromLayer(t, e) {
    const i = this._layers.get(t);
    return i !== void 0 ? e ? i.treeNodes : i.nodes : null;
  }
  getNodesFromLayers(t, e) {
    const i = [];
    for (const n of t) {
      const r = this.getNodesFromLayer(n, e);
      if (r !== null)
        for (const o of r)
          i.push(o);
    }
    return i;
  }
  getNodesFromLayerName(t, e) {
    const i = this._layersIds.get(t);
    return i !== void 0 ? this.getNodesFromLayers(i, e) : null;
  }
  generateProductName() {
    return `Product ${this._unnamedProductCount++}`;
  }
  generateGroupName() {
    return `Product ${this._unnamedGroupCount++}`;
  }
  generateDrawingSheetName() {
    return `Product ${this._unnamedDrawingSheetCount++}`;
  }
  generateDrawingViewName() {
    return `Product ${this._unnamedDrawingViewCount++}`;
  }
  forEachCadView(t) {
    this._cadViews.forEach(t);
  }
  forEachPmi(t) {
    this._pmis.forEach(t);
  }
  forEachCadConfiguration(t) {
    this._cadConfigurations.forEach(t);
  }
  hasActiveCadView() {
    return this._activeCadView !== null;
  }
  activateCadView(t, e, i, n) {
    return console.assert(this._activeCadView === null), this._activeCadView = e, e.activate(
      this,
      this._engine,
      this._callbackManager,
      this._cuttingManager,
      t,
      i,
      n,
      this._activeCadConfiguration
    );
  }
  async deactivateActiveCadView() {
    this._activeCadView !== null && (await this._activeCadView.deactivate(this._cuttingManager), console.assert(this._activeCadView !== null), this._activeCadView = null);
  }
  getDefaultCadView(t) {
    let e;
    return t === null ? this._defaultCadViewsByConfiguration.size === 1 && (e = this._defaultCadViewsByConfiguration.values().next().value) : e = this._defaultCadViewsByConfiguration.get(t), e !== void 0 ? e : null;
  }
  getCadViewPmis(t) {
    const e = [];
    return this._pmis.forEach((i) => {
      t.hasPmi(i) && e.push(i);
    }), e;
  }
  isMeasurable() {
    return this._isMeasurable;
  }
  containsDrawings() {
    return this._containsDrawings;
  }
  getCadConfigurations() {
    const t = [];
    return this._cadConfigurations.forEach((e) => {
      t.push(e);
    }), t;
  }
  getDefaultCadConfiguration() {
    return this._defaultCadConfiguration;
  }
  getActiveCadConfiguration() {
    return this._activeCadConfiguration;
  }
  activateCadConfiguration(t) {
    console.assert(t.isAConfigurationNode()), this._activeCadConfiguration = t;
  }
  massageAuthoredUserId(t, e) {
    if (e === null)
      return this.generateDynamicNodeId();
    {
      const i = t.toRuntimeId(e);
      return this.lookupAnyNode(i) !== null ? this.generateDynamicNodeId() : e;
    }
  }
  createNode(t, e, i, n, r, o = null) {
    const l = _e.createDynamic(
      this,
      t,
      e,
      i,
      n,
      r,
      !1,
      o
    );
    return t.addProductOccurrence(l), l.markLoaded(), l;
  }
  createPart(t) {
    const e = ns.createDynamic(this, t, null);
    return e.markLoaded(), e;
  }
  setPart(t, e) {
    e.addReferrer(t);
    let i = this._partToInstance.get(e);
    if (i === void 0) {
      const n = Gi(this._rootNode), r = () => {
        const l = {}, h = Ro.create(() => (console.assert(l.node !== void 0), new pg(jn.create(l.node))));
        return l.instance = new cl(h, n), l.node = _e.createDynamic(
          this,
          l.instance,
          null,
          null,
          null,
          !0
        ), l.node.setPartDefinition(e), l.node.markLoaded(), l;
      }, { instance: o } = r();
      i = o;
    }
    t.setPrototype(i);
  }
  _createCadView(t, e, i, n, r, o, l, h) {
    const u = ss.createDynamic(
      this,
      t,
      e,
      i,
      n,
      r,
      o,
      l,
      h
    );
    return t.addCadView(u), u.markLoaded(), u;
  }
  async _createCadViewInstance(t, e, i) {
    if (i !== null) {
      const [n, r] = await t.createMeshInstance(i), h = {
        nodeInfo: {
          nodeId: this.generateDynamicNodeId(),
          bits: zi.IsShownSpecified | zi.IsShown,
          name: null,
          localTransform: null,
          attributes: [],
          header: Ys.dynamic,
          exchangeId: null,
          layerId: null,
          genericTypeId: null,
          genericId: null,
          userDatas: null
        },
        inclusionKey: n,
        instanceKey: r,
        bits: 0,
        modifierbits: 0
      }, d = Fi(e).getMasterModelKey();
      console.assert(e.isLoaded());
      const g = co.reify(this, d, e, h);
      e.setViewFrame(g), g.markLoaded();
    }
  }
  createCadView(t, e, i, n, r, o, l, h, u, d) {
    const g = this._createCadView(
      e,
      i,
      n,
      r,
      o,
      l,
      h,
      u
    );
    return d !== null && this._createCadViewInstance(t, g, d), g;
  }
  createMeshInstance(t, e, i, n, r, o, l, h, u, d) {
    let g = 0;
    u && (g |= zi.InitiallyShown);
    let y = 0;
    l && (y |= Br.PreventFromResetting), h && (y |= Br.OutOfHierarchy), d && (y |= Br.ImplicitBody);
    const m = Ui.createDynamic(
      this,
      e,
      i,
      n,
      r,
      o,
      g,
      y
    );
    return o.addBodyInstance(m), t && m.markLoaded(), m;
  }
  createPmiInstance(t, e, i, n, r, o, l, h) {
    const u = Gi(r), y = {
      nodeInfo: {
        nodeId: this.massageAuthoredUserId(u, i),
        bits: zi.InitiallyShown,
        name: n,
        localTransform: null,
        attributes: [],
        header: Ys.dynamic,
        exchangeId: null,
        layerId: null,
        genericTypeId: null,
        genericId: null,
        userDatas: null
      },
      inclusionKey: t,
      instanceKey: e,
      bits: 0,
      modifierbits: 0
    }, m = Sn.createDynamic(
      this,
      u,
      r,
      n,
      o,
      l,
      [y],
      h
    );
    return r.addPmi(m), m.markLoaded(), m;
  }
  getRelationshipsOfItem(t, e) {
    const i = /* @__PURE__ */ new Map();
    let n = [];
    const r = this.lookupAnyTreeNode(t);
    if (r === null)
      return i;
    n = Gi(r).getRelationships();
    for (const l of n)
      if (l.relating !== null && l.relating.relationElt.id === e)
        ma.addFromRelatingElt(l, i);
      else {
        const h = l.related;
        let u = -1;
        h !== null && (u = ma.findIndexInRelated(e, h.relationships)), u >= 0 && ma.addFromRelatedElt(l, i);
      }
    return i;
  }
  getAutomaticMeasurementUnitScaling() {
    return this._automaticMeasurementUnitScaling;
  }
  setAutomaticMeasurementUnitScaling(t) {
    this._automaticMeasurementUnitScaling = t;
  }
  getInitiallyHiddenStayHidden() {
    return this._initiallyHiddenStayHidden;
  }
  setInitiallyHiddenStayHidden(t) {
    this._initiallyHiddenStayHidden = t;
  }
  async _removeIdMappingsRecursive(t) {
    const e = (h) => {
      const u = h.getGenericId();
      if (u !== null) {
        const g = this._genericIdToNodes.get(u);
        g !== void 0 && g.delete(h);
      }
      const d = ah(h);
      if (d !== null) {
        const g = this._genericTypeToNodes.get(d);
        g !== void 0 && g.delete(h);
      }
    }, i = (h) => {
      const u = /* @__PURE__ */ new Map();
      for (const d of h) {
        const g = d.getAuthoredLayerId();
        if (g === null)
          continue;
        const m = Js(d).getRuntimeLayerId(g);
        if (m === null)
          continue;
        const x = u.get(m);
        x === void 0 ? u.set(m, [d]) : x.push(d);
      }
      u.forEach((d, g) => {
        const y = this._layers.get(g);
        y.nodes = y.nodes.filter((m) => d.indexOf(m) === -1), y.treeNodes = y.treeNodes.filter(
          (m) => d.indexOf(m) === -1
        );
      });
    }, n = (h) => {
      const u = /* @__PURE__ */ new Set();
      h.forEach((d) => {
        const g = d.getInstanceInc();
        u.add(g[0]);
      }), u.forEach((d) => {
        const g = this._inclusionContents.get(d);
        if (g !== void 0)
          for (const y of h) {
            const m = y.getInstanceInc();
            m[0] === d && g.bodies.delete(m[1]);
          }
      });
    }, r = [], o = [], l = {
      enterProductOccurrence: (h) => {
        e(h), this._productOccurrences.delete(h.getRuntimeId()), r.push(h);
      },
      enterAnyBody: (h) => {
        e(h);
        const u = h.getRuntimeId();
        h instanceof Ui ? this._bodyInstances.delete(u) : h instanceof Bs ? this._pmiBodies.delete(u) : this._viewFrames.delete(u), r.push(h), o.push(h);
      },
      enterCadView: (h) => {
        this._cadViews.delete(h.getRuntimeId());
      },
      enterPmi: (h) => {
        this._pmis.delete(h.getRuntimeId());
      }
    };
    await Ln.walk(l, t, Vt.None), i(r), n(o);
  }
  async deleteNode(t) {
    if (!this._canDeleteNode(t)) {
      const i = t.getRuntimeId();
      throw new oe(`Cannot delete node (${i})`);
    }
    const e = ih(
      t,
      $t.All,
      !0,
      /* @__PURE__ */ new Set(),
      Vt.None
    );
    if (this._engine.setPartVisibility(e, !1, !1), this._engine.setInstanceModifier(Qi.DoNotSelect, e, !0), t instanceof _e) {
      this._cadConfigurations.delete(t) && (t === this._activeCadConfiguration && (this._activeCadConfiguration = null), t === this._defaultCadConfiguration && (this._defaultCadConfiguration = null));
      const i = t.getParent(), n = Js(i);
      if (console.assert(i !== null), i !== null) {
        let r;
        if (i instanceof cl)
          r = i.removeReferrer(t);
        else if (i instanceof Gn && i.getChildren().length === 1) {
          const o = i.getInclusionKey();
          this._inclusionContents.delete(o);
          const l = i.getModelKey(), h = this._modelContents.get(n);
          h !== void 0 && (h.delete(l), h.size === 0 && this._modelContents.delete(n)), r = i.removeProductOccurrence(t);
        } else
          r = i.removeProductOccurrence(t);
        console.assert(r);
      }
      return this._productOccurrences.delete(t.getRuntimeId()), await this._removeIdMappingsRecursive(t), n.getChildren().length === 0 ? n.purgeContents() : t.purgeContents();
    } else if (t instanceof Sn)
      t.getParent().removePmi(t), this._pmis.delete(t.getRuntimeId());
    else {
      t.getParent().removeBodyInstance(t);
      const n = t.getInstanceInc();
      this._getInclusionContent(n[0]).bodies.delete(n[1]), this._bodyInstances.delete(t.getRuntimeId());
    }
  }
  _canDeleteNode(t) {
    return !this._nodeDeletionBlackList.has(t);
  }
  allowNodeDeletion(t) {
    this._nodeDeletionBlackList.delete(t);
  }
  preventNodeDeletion(t) {
    const e = t.getParent();
    if (e instanceof cl)
      throw new oi();
    if (e !== null) {
      if (console.assert(e === null || this._nodeDeletionBlackList.has(e)), t instanceof _e)
        console.assert(!t.hasAuthoredId()), console.assert(!t.isOutOfHierarchy());
      else if (t instanceof Ui) {
        const i = t.getInstanceInc();
        console.assert(!t.hasAuthoredId()), console.assert(i[0] === Ei.Local), console.assert(t.isOutOfHierarchy());
      }
    }
    this._nodeDeletionBlackList.add(t);
  }
  preventMeshDeletion(t) {
    this._meshDeletionBlackList.add(t);
  }
  async _resetContents() {
    if (this.hasActiveCadView())
      return await this.deactivateActiveCadView(), this._resetContents();
    await this._rootLoadContext.purgeContents(), this._productOccurrences.clear(), this._pmis.clear(), this._cadViews.clear(), this._bodyInstances.clear(), this._pmiBodies.clear(), this._viewFrames.clear(), this._partDefinitions.clear(), this._representationItems.clear(), this._partToInstance.clear(), this._filters.length = 0, this._layers.clear(), this._layersIds.clear(), this._genericTypeToNodes.clear(), this._genericIdToNodes.clear(), this._cadConfigurations.clear(), this._modelContents.clear(), this._inclusionContents.clear(), this._currentNodeIdOffset = 0, this._activeCadView = null, this._activeCadConfiguration = null, this._defaultCadConfiguration = null, this._firstProductOccurrenceWithView = null, this._containsDrawings = !1, this._isMeasurable = !1, this._requestedNodes.clear(), this._unnamedProductCount = 0, this._unnamedGroupCount = 0, this._unnamedDrawingSheetCount = 0, this._unnamedDrawingViewCount = 0, this._seenExternalModel = !1, this._rootNode.unsetMeasurementUnit(), this._nodeDeletionBlackList.forEach((t) => {
      if (t instanceof _e) {
        const e = t.getRuntimeId();
        this._productOccurrences.set(e, t);
        const i = t.getParent();
        i instanceof cl ? console.assert(!1) : i.addProductOccurrence(t), t.setVisibility(!0), t.unsetMeasurementUnit(), t.hasLocalTransformOverride() && t.removeLocalTransformOverride();
      } else if (t instanceof Ui) {
        const e = t.getRuntimeId();
        this._bodyInstances.set(e, t);
        const i = t.getInstanceInc(), n = i[0];
        console.assert(n === Ei.Local), this._getInclusionContent(n).bodies.set(i[1], t), t.getParent().addBodyInstance(t);
      } else if (t instanceof Sn) {
        const e = t.getRuntimeId();
        this._pmis.set(e, t), t.getParent().addPmi(t);
      } else if (t instanceof Ls) {
        const e = t.getParent();
        e !== null && e.addLoadContext(t);
      } else if (t instanceof Pn) {
        const e = t.getParent();
        e instanceof _e, e.addAttachContext(t);
      } else {
        const e = t.getInclusionKey();
        console.assert(e === Ei.Local), this._getInclusionContent(e).contexts.push(t), t.getParent().addInclusionContext(t);
      }
    });
  }
  async reset() {
    await this._callbackManager.promiseTrigger("_resetAssemblyTreeBegin", null), await this._resetContents();
    const t = [];
    this._nodeDeletionBlackList.forEach((i) => {
      if (i instanceof Ui) {
        const n = i.getInstanceInc();
        console.assert(n[0] === Ei.Local), t.push(n[1]);
      }
    });
    const e = [];
    this._meshDeletionBlackList.forEach((i) => {
      e.push(i);
    }), await this._engine.resetToEmpty(t, e), await this._resetContents();
  }
  setViewAxes(t, e) {
    this._model.setViewAxes(t, e);
  }
  async _requestIncsOfNodes(t) {
    if (this._config.streamingMode !== Lo.OnDemand)
      return;
    const e = /* @__PURE__ */ new Set(), i = [], n = [];
    for (const l of t) {
      const h = m_(l, $t.All, !1, e).then((u) => {
        for (const d of u)
          i.push(d);
      });
      n.push(h);
    }
    await Ge(n);
    const r = [], o = [];
    e.forEach((l) => {
      if (!l.isRequested()) {
        l.setRequested();
        const h = l.isInitiallyShown();
        h !== l.isVisible() && (h ? (l.setVisibility(!0), r.push(l.getRuntimeId())) : (l.setVisibility(!1), o.push(l.getRuntimeId())));
      }
    }), r.length + o.length > 0 && this._callbackManager.trigger("visibilityChanged", r, o), this._engine.requestMeshInstances(i);
  }
  async _requestExternalModelsLocal(t, e, i) {
    const n = await e.loadPendingExternalModels(t);
    return n.length !== 0 && (await _a(n), await this._requestNodes(t, [e], i)), n;
  }
  async _requestExternalModelsNonLocal(t, e, i) {
    const n = await Nx(e);
    if (n.length === 0)
      return [];
    const r = [];
    for (const l of n) {
      const h = this._requestExternalModelsLocal(t, l, i);
      r.push(h);
    }
    return (await Promise.all(r)).flat();
  }
  async _requestExternalModelsOfNodes(t, e, i) {
    const n = [];
    for (const o of e) {
      const l = this._requestExternalModelsNonLocal(t, o, i);
      n.push(l);
    }
    return (await Promise.all(n)).flat();
  }
  async _requestNodes(t, e, i) {
    if (!i) {
      const h = this._activeLoadIds.size !== 0, u = [];
      h && this._activeLoadIds.forEach((d) => {
        u.push(d);
      });
      for (const d of e)
        h && this._requestedNodes.set(d, u), d instanceof _e && t.notifyDirectRequest(d);
    }
    const n = this._requestIncsOfNodes(e), r = this._requestExternalModelsOfNodes(
      t,
      e,
      i
    ), o = [n, r];
    return (await Promise.all(o))[1];
  }
  async requestNodes(t, e, i) {
    const n = await this._requestNodes(t, e, i), r = [];
    for (const o of n) {
      const l = o.getChildren();
      r.push(...l);
    }
    if (r.length > 0) {
      const o = r.map((l) => l.getRuntimeId());
      await this._callbackManager.promiseTrigger(
        "_subtreeLoaded",
        "subtreeLoaded",
        o,
        ho.LoadModel
      );
    }
  }
  isBeingRequested(t) {
    let e = t;
    const i = !1;
    do
      if (e instanceof ts) {
        if (this._requestedNodes.has(e))
          return !0;
        e = e.getParent();
      } else if (e instanceof Pn)
        e = e.getParent();
      else if (e instanceof Gn)
        e = e.getParent();
      else if (e instanceof Ls) {
        const n = e.getParent();
        if (n === null)
          return !1;
        e = n;
      } else
        return console.assert(!1), !1;
    while (!i);
    return !1;
  }
  onDemandRequestsActive() {
    return this._requestedNodes.size !== 0;
  }
  onLoadBegin() {
    const t = this._nextLoadId++;
    return this._activeLoadIds.add(t), t;
  }
  onLoadEnd(t) {
    this._activeLoadIds.delete(t);
    const e = [];
    this._requestedNodes.forEach((i, n) => {
      let r = !0;
      for (const o of i)
        if (this._activeLoadIds.has(o)) {
          r = !1;
          break;
        }
      r && e.push(n);
    });
    for (const i of e)
      this._requestedNodes.delete(i);
  }
  markSeenExternalModel() {
    this._seenExternalModel = !0;
  }
  seenExternalModel() {
    return this._seenExternalModel;
  }
  getNodesByGenericId(t) {
    return this._genericIdToNodes.get(t) || null;
  }
  getNodesByGenericType(t) {
    return this._genericTypeToNodes.get(t) || null;
  }
  genericTypeToNodes() {
    return this._genericTypeToNodes;
  }
  registerGenericGlobalId(t, e) {
    let i = this._genericIdToNodes.get(e);
    i === void 0 && (i = /* @__PURE__ */ new Set()), i.add(t), this._genericIdToNodes.set(e, i);
  }
  registerGenericType(t, e) {
    let i = this._genericTypeToNodes.get(e);
    i === void 0 && (i = /* @__PURE__ */ new Set()), i.add(t), this._genericTypeToNodes.set(e, i);
  }
  disableAutomaticFitWorld() {
    return this._config.disableAutomaticFitWorld;
  }
  markImplicitNodesOutOfHierarchy() {
    return this._config.markImplicitNodesOutOfHierarchy;
  }
  async _throttleLoad() {
    this._engine.throttleLoad(200, 200), await this._engine.sleep(20);
  }
  /**
   * Enqueues an action that can be throttled by user interactions.
   */
  enqueue(t) {
    const e = typeof t == "function" ? Is.create(t) : t;
    return this._centralQueue.push(async () => {
      const i = this._isScs && this._centralQueueClock.isTicking();
      i && await this._throttleLoad();
      const n = await e.get();
      return i && await this._throttleLoad(), n;
    });
  }
  _onUserInteraction(t, e) {
    if (!this._isScs)
      return;
    let i = !1;
    switch (e) {
      case ae.MouseDown:
      case ae.MouseUp:
      case ae.Mousewheel:
      case ae.TouchStart:
      case ae.TouchMove:
      case ae.TouchEnd:
      case ae.KeyDown:
      case ae.KeyUp:
      case ae.ViewOrientationChange:
        i = !0;
        break;
      case ae.MouseMove:
        i = t.getButtons() !== ys.None;
        break;
      default:
        $r();
    }
    i && this._centralQueueClock.tickFor(1e3);
  }
}
class Yp {
  constructor(t, e) {
    this._inclusionsOf = /* @__PURE__ */ new Map(), this._masterModelKey = Ur.Invalid, this._prototypeInstanceCount = -1, this._attachScope = t, this._attachedInvisibly = e;
  }
  getAttachScope() {
    return this._attachScope;
  }
  getMasterModelKey() {
    return console.assert(this._masterModelKey !== Ur.Invalid), this._masterModelKey;
  }
  getModelKeys() {
    const t = [];
    return this._inclusionsOf.forEach((e, i) => {
      t.push(i);
    }), t;
  }
  hasInclusions() {
    return this._inclusionsOf.size > 0;
  }
  getAllInclusions() {
    const t = [];
    return this._inclusionsOf.forEach((e, i) => {
      for (const n of e)
        t.push(n, i);
    }), t;
  }
  getInclusionsOf(t) {
    t = t;
    const e = this._inclusionsOf.get(t);
    if (e === void 0)
      return [];
    const i = [];
    for (const n of e)
      i.push(n, t);
    return i;
  }
  hasModelIncluded(t) {
    return this._inclusionsOf.has(t);
  }
  attachedInvisibly() {
    return this._attachedInvisibly;
  }
  prototypeInstanceCount() {
    return console.assert(this._prototypeInstanceCount >= 0), this._prototypeInstanceCount;
  }
  registerInclusion(t, e) {
    const i = this._inclusionsOf.get(e);
    i === void 0 ? this._inclusionsOf.set(e, [t]) : i.push(t);
  }
  registerMasterModelKey(t) {
    console.assert(this._masterModelKey === Ur.Invalid), this._masterModelKey = t;
  }
  registerPrototypeInstanceCount(t) {
    console.assert(this._prototypeInstanceCount === -1), this._prototypeInstanceCount = t;
  }
}
class Bx {
  constructor() {
    this._calculatedCutoff = 0, this._requireBoundingInfo = !1, this._prevPriorityValue = 1, this._priorityProxies = /* @__PURE__ */ new Map();
  }
  getPriorityCompareValue(t) {
    if (typeof t == "number")
      return t;
    {
      const e = this._priorityProxies.get(t);
      return e.worldBounding !== null && console.assert(e.priorityHeuristic <= 1), e.priorityHeuristic;
    }
  }
  setRequireBoundingInfo(t) {
    this._requireBoundingInfo = t;
  }
  comparePriority(t, e) {
    const i = this.getPriorityCompareValue(t), n = this.getPriorityCompareValue(e);
    return i < n;
  }
  _updateHeuristicInfo(t, e) {
    var i;
    if (e.worldBounding !== null) {
      const n = vl(e.worldBounding.center()), r = vl(e.worldBounding.extents()), o = t.calculateAttachHeuristic(r, n);
      e.priorityHeuristic = o;
    }
    if ((i = e.xmlAttachInfo) != null && i.directlyRequested) {
      e.worldBounding === null && (e.priorityHeuristic = 0);
      const n = -1e6;
      e.priorityHeuristic += n;
    }
  }
  createPriority(t, e, i) {
    if (i === null)
      return ++this._prevPriorityValue;
    const n = /* @__PURE__ */ Object.create(null);
    let r, o;
    if (i.bounding !== null)
      r = e.transformBox(i.bounding), o = 0;
    else {
      if (this._requireBoundingInfo)
        throw new Error("WorldBounding must be specified when streamCutoff is enabled");
      r = null, o = ++this._prevPriorityValue;
    }
    const l = {
      xmlAttachInfo: i,
      worldBounding: r,
      priorityHeuristic: o
    };
    return this._updateHeuristicInfo(t, l), this._priorityProxies.set(n, l), n;
  }
  destroyPriority(t) {
    typeof t == "object" && this._priorityProxies.delete(t);
  }
  onViewChange(t, e, i) {
    this._calculateCutoff(i.getProjectionMatrix(e.getCamera(), e.id)), this._priorityProxies.forEach((n) => {
      this._updateHeuristicInfo(t, n);
    });
  }
  reset() {
    this._priorityProxies.clear();
  }
  _calculateCutoff(t) {
    let i = 0.98;
    t.m[11] !== 0 && (i = (1 - t.m[15]) / t.m[11] * t.m[10] + t.m[14]);
    const n = mt.inverse(t);
    if (!n)
      throw new Error();
    const r = df(n.transform4(new Hr(0, 0, i, 1))), o = df(
      n.transform4(new Hr(0.0125, 0, i, 1))
    ), l = df(
      n.transform4(new Hr(0, 0.0125, i, 1))
    );
    ff(1 / r[3], r), ff(1 / o[3], o), ff(1 / l[3], l), this._calculatedCutoff = Math.min(
      jp(Nf(o, r)),
      jp(Nf(l, r))
    );
  }
  getCalculatedCutoff() {
    return this._calculatedCutoff;
  }
  // this will be true if streamcutoff is enabled.
}
class ld {
  constructor(t) {
    this._planes = [], this._absPlanes = [], this._signs = [], this._distanceScale = [];
    const e = t.length;
    for (const i of t)
      this._planes.push(i.slice());
    for (let i = 0; i < e; ++i) {
      this._planes[i][3] = -this._planes[i][3], this._absPlanes[i] = fb(this._planes[i]), this._signs[i] = [0, 0, 0];
      for (let n = 0; n < 3; ++n)
        this._signs[i][n] = this._planes[i][n] >= 0 ? 1 : -1;
    }
    for (let i = 0; i < e; ++i) {
      const n = wg(this._planes[i]);
      this._distanceScale[i] = n === 0 ? 0 : 1 / n;
    }
  }
  static fromPlaneCoefficients(t) {
    const e = [];
    for (const i of t) {
      const n = [i.x, i.y, i.z, i.w];
      e.push(n);
    }
    return new ld(e);
  }
  static createFrustumFromMatrix(t) {
    const e = [];
    for (let i = 0; i < 3; ++i)
      e[i] = Nf(_c(t, 3), _c(t, i));
    for (let i = 0; i < 3; ++i)
      e[i + 3] = _b(_c(t, 3), _c(t, i));
    return new ld(e);
  }
  testAxisAlignedBox(t, e) {
    const i = this._planes.length;
    let n = Mu.FullyInside;
    for (let r = 0; r < i; ++r) {
      const o = io(this._planes[r], t), l = io(this._absPlanes[r], e);
      if (o + l <= this._planes[r][3])
        return Mu.Outside;
      o - l < this._planes[r][3] && (n = Mu.PartiallyInside);
    }
    return n;
  }
  axisAlignedBoxNotOutside(t, e) {
    const i = this._planes.length;
    for (let n = 0; n < i; ++n)
      if (io(this._planes[n], pb(t, gb(e, this._signs[n]))) <= this._planes[n][3])
        return !1;
    return !0;
  }
  sphereNotOutside(t, e) {
    const i = this._planes.length;
    for (let n = 0; n < i; ++n) {
      const r = io(this._planes[n], t) - this._planes[n][3];
      if (r < 0 && r * r * this._distanceScale[n] >= e)
        return !1;
    }
    return !0;
  }
  sphereFullyInside(t, e) {
    const i = this._planes.length;
    for (let n = 0; n < i; ++n) {
      const r = io(this._planes[n], t) - this._planes[n][3];
      if (r < 0 || r * r * this._distanceScale[n] < e)
        return !1;
    }
    return !0;
  }
  pointInside(t) {
    const e = this._planes.length;
    for (let i = 0; i < e; ++i)
      if (io(this._planes[i], t) - this._planes[i][3] < 0)
        return !1;
    return !0;
  }
  // 1 / (a^2 + b^2 + c^2) for each plane
}
function Vx(s) {
  return 1 / (1 + Math.exp(s));
}
class Zp {
  constructor(t) {
    const e = t.getCamera(), i = e.getPosition(), n = e.getTarget(), r = _.subtract(n, i);
    let o = r.length();
    o < 1e-7 && (o = 1e-7), this._eyeDistanceInverse = 1 / o, r.scale(this._eyeDistanceInverse);
    const l = t.getFullCameraMatrix();
    this._frustum = ld.createFrustumFromMatrix(l), this._viewProjectionW = _c(l, 3), this._cameraIsOrtho = e.getProjection() === Jc.Orthographic, this._position = vl(i), this._eye = vl(r);
  }
  calculateAttachHeuristic(t, e) {
    let i = 0;
    if (this._frustum.axisAlignedBoxNotOutside(e, t)) {
      const n = wg(t), r = wb(e, n, this._viewProjectionW);
      if (r > 0) {
        let o = mb(e, this._position);
        const h = 1 / (io(this._eye, o) * this._eyeDistanceInverse + 1e-5);
        o = yb(1 / Up(o), o);
        const u = io(this._eye, o);
        let d = Math.pow(h, 6);
        this._cameraIsOrtho || (d *= Math.pow(u, 10) * 5), d < 1e-5 && (d = 1e-5), i = r * d;
      }
      return console.assert(0 <= i), -i - 1;
    }
    return i = Vx(Up(t)), console.assert(0 <= i && i < 1), i;
  }
}
const ud = class ud {
  static isSupported() {
    return ud._enabled && typeof fetch == "function" && typeof ReadableStream == "function";
  }
  static async request(t) {
    const e = await fetch(t);
    if (e.status === 200)
      return e;
    throw new qr(`Failed to fetch "${t}" with status ${e.status}.`);
  }
};
ud._enabled = !0;
let Ra = ud;
const zx = 13;
class cd {
  constructor(t, e, i, n) {
    this._cameraTimeoutId = null, this._isFirstAttachment = !0, this._attachScope = 0, n === null && (n = zx), console.assert(n > 0), this._engine = t, this._view = e, this._callbackManager = i, this._parentToXmlAttachInfos = /* @__PURE__ */ new Map(), this._viewInfo = new Zp(this._view), this._attachPriorityManager = new Bx(), this._comparePriority = (r, o) => this._attachPriorityManager.comparePriority(r, o), this._attachQueue = this._createAttachQueue(n), this._prefetchScsQueue = this._createPrefetchScsQueue(n), this._registerCameraListener();
  }
  static async createWithEmptyModel(t, e, i, n) {
    return await t.loadEmpty(), new cd(t, e, i, n);
  }
  setPrefetchScsCutoffScale(t) {
    this._prefetchScsQueue.setCutoffScale(t), this._attachPriorityManager.setRequireBoundingInfo(this._prefetchScsQueue.cutoffEnabled());
  }
  /**
   * Used in the constructor only.
   */
  _createAttachQueue(t) {
    return new f_(
      t,
      this._comparePriority,
      !1
    );
  }
  /**
   * Used in the constructor only.
   */
  _createPrefetchScsQueue(t) {
    const e = t + 15;
    return new k0(
      0,
      this._attachPriorityManager,
      e,
      (i, n) => this._comparePriority(i, n),
      !1
    );
  }
  _reprioritizeAttachments() {
    this._viewInfo = new Zp(this._view), this._attachPriorityManager.onViewChange(this._viewInfo, this._view, this._engine), this._attachQueue.markDirty(), this._prefetchScsQueue.update();
  }
  /**
   * Used in the constructor only.
   */
  _registerCameraListener() {
    const t = () => {
      this._onCameraChange();
    };
    this._callbackManager.bind({
      camera: t,
      _shutdownBegin: () => {
        this._cameraTimeoutId !== null && (clearTimeout(this._cameraTimeoutId), this._cameraTimeoutId = null), this._callbackManager.unbind({ camera: t });
      }
    });
  }
  reprioritizeAttachmentsNow() {
    this._cameraTimeoutId !== null && (clearTimeout(this._cameraTimeoutId), this._cameraTimeoutId = null), this._reprioritizeAttachments();
  }
  _onCameraChange() {
    this._cameraTimeoutId !== null && clearTimeout(this._cameraTimeoutId), this._cameraTimeoutId = this._engine.setTimeout(() => {
      this._cameraTimeoutId = null, this._reprioritizeAttachments();
    }, 500);
  }
  /**
   * This listens on SC messages relevant for a given attachment.
   * This abstracts away the low-level details about an attachment
   * and bundles relevant information in a promise return value.
   */
  _awaitAttachInfo(t, e, i, n, r) {
    const o = n === null, l = new Yp(e, i);
    let h = !1;
    const u = [], d = wi(), g = wi();
    let y = !1;
    const m = () => {
      console.assert(!y), y = !0, this._cleanupAttachLowLevel(), this._callbackManager.unbind(b);
    };
    let x = null;
    const b = {
      _priorityMetaDataSent: (I, C) => {
        I === e && (l.registerPrototypeInstanceCount(C), d.resolve());
      },
      _announceModel: (I, C) => {
        I === e && (h = !0, l.registerMasterModelKey(C));
      },
      _inclusion: (I, C, P) => {
        I === e && (l.registerInclusion(C, P), u.push(P));
      },
      _remapModel: (I, C, P) => {
        I === e && t.remapModel(C, P);
      },
      _remapInclusion: (I, C, P, k) => {
        I === e && t.remapInclusion(C, P, k);
      },
      _missingModel: (I, C) => {
        I === e && (x = C);
      },
      _attached: (I) => {
        if (I !== e)
          return;
        if (!h) {
          if (x !== null && (o || r)) {
            console.assert(u.length === 0), g.reject(new yd(x));
            return;
          }
          if (u.length !== 1) {
            g.reject(new qr("Bad model: Could not find master model key."));
            return;
          }
          const k = u[0];
          l.registerMasterModelKey(k);
        }
        const C = [d], P = this._isFirstAttachment;
        if (P) {
          this._isFirstAttachment = !1;
          const k = o ? ws.Direct : ws.Indirect, O = this._callbackManager.promiseTrigger("_firstAttachment", null, k);
          C.push(O);
        }
        Ge(C).catch((k) => {
          throw console.assert(!1), k;
        }).then(async () => {
          P && this._engine.getSessionType() === en.Network && await this._callbackManager.promiseTrigger("_firstBoundingReady", null), m(), g.resolve(l);
        });
      }
    };
    return this._callbackManager.bind(b), g.catch((I) => {
      throw m(), I;
    });
  }
  _createPriority(t, e) {
    return this._attachPriorityManager.createPriority(
      this._viewInfo,
      t,
      e
    );
  }
  _cleanupAttachLowLevel() {
  }
  async _cleanupAttachHighLevel(t, e, i) {
    try {
      return await t;
    } finally {
      i !== null && this._forgetXmlAttachment(i), this._attachPriorityManager.destroyPriority(e);
    }
  }
  newAttachScope() {
    return ++this._attachScope;
  }
  _attachByStream(t, e, i, n, r, o, l, h) {
    const u = mt.toMatrix12(n.m), d = this._createPriority(n, l), g = this._attachQueue.push(async () => {
      const y = this.newAttachScope(), m = this._awaitAttachInfo(
        e,
        y,
        o.get(),
        l,
        h
      );
      try {
        return await t.enqueue(() => this._engine.attachModel(
          y,
          i,
          u,
          r,
          o.get()
        )), await m;
      } catch (x) {
        throw this._cleanupAttachLowLevel(), x;
      }
    }, d);
    return this._cleanupAttachHighLevel(g, d, l);
  }
  static _getAllModelKeys(t) {
    const e = t.getMasterModelKey(), i = t.getAllInclusions();
    if (i[1] !== e) {
      for (let r = 2; r < i.length; r += 2)
        if (i[r + 1] === e) {
          const l = i[r];
          i[r] = i[0], i[r + 1] = i[1], i[0] = l, i[1] = e;
          break;
        }
    }
    const n = [];
    for (let r = 0, o = 1; o < i.length; ++r, o += 2)
      n[r] = i[o];
    return n;
  }
  /**
   * This function is used to attach SCS buffers that are keyed to an `ExternalModelName`.
   * This happens when attaching an SCS from a model found in a shattered XML file.
   *
   * This function should be used over `simpleAttach` for this case. This is because `simpleAttach`
   * only takes a buffer as an argument. Without storing the entire buffer as a key to the attached
   * model keys of the SCS model, subsequent attachments of equivalent buffers cannot leverage
   * making new inclusions of the existing attached models. On the other hand, this keys the
   * attached models from the SCS buffer, allowing model sharing for subsequent attachments.
   *
   * cancelUnitMatrix is a patch to tell to the engine to cancel the undesired scale matrix for
   * some model type in some version when using the shattered workflow.
   *
   * Returns `Promise<null>` when the attachment is skipped (due to `toAttachData` returning `null`).
   */
  async attachByNamedScsBuffer(t, e, i, n, r, o, l, h, u) {
    t.getAutomaticMeasurementUnitScaling() || (o = Ns);
    const d = Js(h.parent), g = mt.toMatrix12(r.m), y = this._createPriority(r, h);
    if (typeof y == "number")
      throw new oi();
    const m = async (b) => {
      const I = await (async () => {
        const O = d.getScsModelKeysOf(e);
        return O === null ? (d.initializeScsModelKeysOf(e), b) : O;
      })(), C = d.getScsModelKeysOf(e);
      if (C === null)
        throw new oi();
      const P = this.newAttachScope();
      let k;
      if (I instanceof Uint8Array || Ra.isSupported() && I instanceof Response) {
        const B = this._awaitAttachInfo(
          i,
          P,
          l.get(),
          h,
          !1
        );
        try {
          await t.enqueue(() => {
            const j = this._engine.attachScsBuffer(
              P,
              I instanceof Uint8Array ? I : null,
              // if attachData is not an array, then data will be fed into SC as it arrives
              g,
              o,
              l.get(),
              !0,
              u
            );
            return I instanceof Uint8Array || this.streamScsData(P, I), j;
          }), k = await B;
        } catch (j) {
          throw this._cleanupAttachLowLevel(), j;
        }
        if (C.state === jr.Pending) {
          const j = cd._getAllModelKeys(k);
          C.resolve(j);
        }
      } else if (I === null)
        k = null, C.state === jr.Pending && C.resolve(null);
      else if (I instanceof Array) {
        console.assert(C.state !== jr.Pending);
        const O = new Yp(P, l.get());
        O.registerPrototypeInstanceCount(0);
        for (let B = 0; B < I.length; ++B) {
          const j = I[B], V = this._engine.attachScsModelByKey(
            P,
            j,
            g,
            o,
            l.get()
          );
          O.registerInclusion(V, j), B === 0 && O.registerMasterModelKey(j);
        }
        k = O;
      } else
        throw new oi();
      return k;
    }, x = (async () => {
      const b = await this._prefetchScsQueue.push(async () => d.toScsBuffer(e, n), y);
      return h.directlyRequested = !0, this._attachQueue.push(() => m(b), y);
    })();
    return this._cleanupAttachHighLevel(x, y, h);
  }
  // Streams the data from a fetch response into the the buffer associated with the attach scope
  streamScsData(t, e) {
    this._callbackManager.trigger("_fetchBegin", e.url, t);
    const i = e.body.getReader(), n = async () => {
      for (; ; ) {
        const { done: r, value: o } = await i.read();
        if (r) {
          this._engine.feedScsBuffer(t, null), this._callbackManager.trigger("_fetchEnd", e.url, t);
          return;
        }
        this._engine.feedScsBuffer(t, o);
      }
    };
    this._engine.setTimeout(n, 0);
  }
  _attachByScsBuffer(t, e, i, n, r, o, l) {
    const u = mt.toMatrix12(n.m), d = this._createPriority(n, null), g = this._attachQueue.push(async () => {
      const y = this.newAttachScope(), m = this._awaitAttachInfo(
        e,
        y,
        o.get(),
        null,
        !1
      );
      try {
        return await t.enqueue(() => {
          const b = this._engine.attachScsBuffer(
            y,
            i instanceof Uint8Array ? i : null,
            // if scsBuffer is not an array, then data will be fed into SC as it arrives
            u,
            r,
            o.get(),
            !1,
            l
          );
          return i instanceof Uint8Array || this.streamScsData(y, i), b;
        }), await m;
      } catch (x) {
        throw this._cleanupAttachLowLevel(), x;
      }
    }, d);
    return this._cleanupAttachHighLevel(g, d, null);
  }
  simpleAttach(t, e, i, n, r, o, l, h) {
    if (t.getAutomaticMeasurementUnitScaling() || (r = Ns), typeof i == "string")
      return this._attachByStream(
        t,
        e,
        i,
        n,
        r,
        o,
        l,
        h
      );
    if (l === null)
      return this._attachByScsBuffer(
        t,
        e,
        i,
        n,
        r,
        o,
        !1
      );
    throw new oi();
  }
  reset() {
    return this._isFirstAttachment = !0, this._attachScope = 0, this._parentToXmlAttachInfos.clear(), this._attachPriorityManager.reset(), this.clearAttachQueues();
  }
  /**
   * This method will effectively cancel an active LoadSubtreeByXML operation.
   * All deferred promises in the prefetch queue will be canceled.
   * Note that any open promises i.e. SCS files that are being fetched when this method is called will resolve before this method returns.
   */
  async clearAttachQueues() {
    return this._prefetchScsQueue.killDeferred(), this._attachQueue.killDeferred(), await this._prefetchScsQueue.waitForIdle(), this._attachQueue.waitForIdle();
  }
  isIdle() {
    return this._attachQueue.isIdle();
  }
  /**
   * Call this when a node has been directly requested by `Model.prototype.requestNodes`.
   */
  notifyDirectRequest(t) {
    const e = this._parentToXmlAttachInfos.get(t);
    if (e !== void 0) {
      let i = !1;
      for (const n of e)
        n.directlyRequested || (n.directlyRequested = !0, i = !0);
      i && this._reprioritizeAttachments();
    }
  }
  registerXmlAttachInfo(t) {
    const e = t.parent;
    let i = this._parentToXmlAttachInfos.get(e);
    i === void 0 && (i = [], this._parentToXmlAttachInfos.set(e, i)), i.push(t);
  }
  _forgetXmlAttachment(t) {
    const e = t.parent, i = this._parentToXmlAttachInfos.get(e);
    if (i.length === 1)
      console.assert(i[0] === t), this._parentToXmlAttachInfos.delete(e);
    else {
      console.assert(i.length > 1);
      const n = i.indexOf(t);
      console.assert(n >= 0), i.splice(n, 1);
    }
  }
  maxConcurrentAttachments() {
    return this._attachQueue.maxActivePromises();
  }
}
function Rg(s, t) {
  return new Promise((e, i) => {
    const n = new XMLHttpRequest();
    n.open("GET", s, !0), t && (n.responseType = t), n.onload = function(r) {
      if (n.readyState === s_.Done)
        if (n.status === r_.Ok)
          e(n);
        else {
          const o = new qr(
            `XMLHttpRequest failed to GET "${s}" with status ${n.status}.`
          );
          i(o);
        }
    }, n.onerror = function(r) {
      i(r);
    }, n.send();
  });
}
async function Gy(s) {
  const t = await Rg(s, "arraybuffer");
  return new Uint8Array(t.response);
}
class Hx {
  constructor() {
    this._cache = /* @__PURE__ */ new Map();
  }
  clear() {
    this._cache.clear();
  }
  async load(t, e) {
    const i = this._cache.get(t);
    return i !== void 0 ? i : (this._cache.set(t, e), e);
  }
}
const $y = "Missing";
function qy(s) {
  return new DOMParser().parseFromString(s, "application/xml");
}
async function Ux(s) {
  const t = await Rg(s);
  let e = t.responseXML;
  return e === null && (e = qy(t.responseText)), e;
}
function jx(s) {
  if (!s.hasChildNodes)
    return null;
  const t = s.firstChild;
  if (!(t instanceof Comment))
    return null;
  const e = t.data.split(" ");
  if (e.length !== 2 || e[0] !== "HC")
    return null;
  const i = e[1].split(".");
  if (i.length < 2)
    return null;
  const n = [];
  for (const r of i) {
    if (!o_(r))
      return null;
    n.push(parseInt(r, 10));
  }
  return n;
}
function Wx(s) {
  return Zc(yg, s);
}
function Gx(s) {
  const t = s.getElementsByTagName("parsererror");
  if (t.length > 0)
    throw new si(t[0].textContent || "unknown error");
}
function $x(s) {
  const t = s.getParent();
  return t instanceof Pn && t.getParent() instanceof Ls;
}
function qx(s, t, e, i, n, r) {
  const o = new Pn(
    t,
    n,
    r,
    Ur.Local,
    e
  );
  switch (i) {
    case 0:
      return o;
    case 1: {
      const l = new Gn(
        s,
        o,
        Ei.Local,
        xs.Local
      );
      o.addInclusionContext(l);
      const h = _e.createDynamic(
        s,
        l,
        $y,
        null,
        // authored node id
        null,
        // local transform
        !r
      );
      return l.addProductOccurrence(h), o;
    }
    default:
      return $r();
  }
}
function Kx(s, t, e, i) {
  return {
    getAttachScope() {
      return s;
    },
    getMasterModelKey() {
      return i;
    },
    getModelKeys() {
      return [i];
    },
    hasInclusions() {
      return !0;
    },
    getAllInclusions() {
      return [e, i];
    },
    getInclusionsOf(n) {
      return n === i ? [e, i] : [];
    },
    hasModelIncluded(n) {
      return n === i;
    },
    attachedInvisibly() {
      return t;
    },
    prototypeInstanceCount() {
      return 0;
    }
  };
}
class Lg {
  constructor(t, e, i, n, r) {
    this._loadQueue = new jo(1024, !1), this._activeLoadCount = 0, this._activeLoadGeneration = 0, this._isFirstLoad = !0, this._firstAssemblyDataHeader = null, console.assert(t.isInitialized()), this._assemblyTree = t, this._scAttacher = e, this._engine = i, this._view = n, this._callbackManager = r, this._isScsSession = this._engine.getSessionType() === en.Scs, this._nodesUntilNextSleep = 2e3;
  }
  // Modify the scale of the PO if needed, depends of the unit
  _resolveMeasurementUnits(t, e, i, n) {
    if (!this._assemblyTree.getAutomaticMeasurementUnitScaling())
      return;
    const r = pr(t.getParent());
    if (r === null)
      throw new oi();
    const o = r.getMeasurementUnit(), l = t.getMeasurementUnit();
    let h = t.getLocalTransform();
    if (h === null && (h = Wn.getIdentity()), o !== l) {
      const u = l / o;
      h[0] *= u, h[5] *= u, h[10] *= u;
    }
    this._applyScalePatchIfNeeded(
      h,
      e,
      i,
      n,
      l
    ), t.setLocalTransformAsInitial(h);
  }
  // Will directly modify localChildMatrix to apply the scale patch
  // COM-4049 Fix for Aras to manage loading monolithic scs from shattered XML
  // Inventor after 2021 (HC v9) + solidedge after 2023 add an unit scale in the first PO root child
  // Because data is in a different unit than the real unit defined in nodeUnit
  // We need to revert it because the scale is already applied in the master assembly (xml)
  // Only if the shattered part is generated with output_scs, else the scale is already skiped during conversion
  _applyScalePatchIfNeeded(t, e, i, n, r) {
    const o = n === pl.Inventor, l = n === pl.Se, h = o && Zc(i, [9, 0, 0]) || l && Zc(i, [23, 0, 0]), g = o ? 10 : 1e3;
    if (e && h && r !== g) {
      const y = r / g;
      t[0] *= y, t[5] *= y, t[10] *= y;
    }
  }
  /**
   * Used to create assembly tree data for instances that don't have authored assembly tree data.
   */
  async _patchImplicitNodesByModelInc(t, e, i, n, r) {
    let o = 0;
    if (n.length === 0)
      return;
    let l;
    const h = Is.create(() => {
      const u = t.get(), d = Fi(u), g = d.getAttachScope();
      l = d.attachedInvisibly();
      const y = d.split(g, l, u);
      u.addAttachContext(y);
      const m = new Gn(
        this._assemblyTree,
        y,
        e,
        i
      );
      y.addInclusionContext(m);
      const x = _e.createDynamic(
        this._assemblyTree,
        m,
        `Of Inclusion (${e})`,
        null,
        null,
        !l,
        r
      );
      return m.addProductOccurrence(x), x;
    });
    for (const u of n) {
      let d = this._assemblyTree.lookupAnyBodyByInstanceInc(e, u);
      if (d === null) {
        const g = h.get(), y = `Implicit Body ${++o}`, m = await this._engine.getPartsBounding(
          [e, u],
          !0,
          !1
        ), x = m.max !== m.min && !m.isDegenerate();
        d = this._assemblyTree.createMeshInstance(
          !0,
          // mark loaded
          e,
          u,
          null,
          // authored node id
          y,
          g,
          // parent
          !1,
          // prevent from resetting
          !1,
          // out of hierarchy
          x,
          !0
          // is implicit
        ), l && d.setVisibility(!1);
      }
    }
  }
  _getPrototypeInstanceCountByAttachment(t) {
    const e = /* @__PURE__ */ new Set();
    let i = 0;
    const n = t.getAllInclusions();
    for (let r = 0; r < n.length; r += 2) {
      const o = n[r], l = n[r + 1];
      e.has(l) || (e.add(l), i += this._assemblyTree.getInstanceCountByInclusion(o));
    }
    return i;
  }
  /**
   * Used to create assembly tree data for instances that don't have authored assembly tree data.
   */
  async _patchImplicitNodesByAttachment(t, e, i) {
    console.assert(t.isLoaded());
    let n = null;
    const r = Is.create(() => {
      const d = new sl(), g = e.getMasterModelKey();
      n = new Pn(
        d,
        e.getAttachScope(),
        e.attachedInvisibly(),
        g,
        t
      );
      const y = new Gn(
        this._assemblyTree,
        n,
        Ei.Local,
        xs.Local
      );
      n.addInclusionContext(y);
      const m = _e.createDynamic(
        this._assemblyTree,
        y,
        "Implicit Bodies",
        null,
        // authored node id
        null,
        // local transform
        !e.attachedInvisibly(),
        i
      );
      return y.addProductOccurrence(m), m;
    });
    let o = e.prototypeInstanceCount();
    o === 0 && ([o] = await this._engine.instanceKeyInfo(
      e.getAttachScope(),
      Xu.Attachment,
      Ju.KeyCountOnly
    ));
    let l = this._getPrototypeInstanceCountByAttachment(e);
    if (l === o)
      return;
    const h = await this._engine.instanceKeyInfo(
      e.getAttachScope(),
      Xu.Attachment,
      Ju.AllKeys
    ), u = e.getAllInclusions();
    for (let d = 0; d < u.length; d += 2) {
      const g = u[d], y = u[d + 1], m = h.get(y);
      m !== void 0 && await this._patchImplicitNodesByModelInc(
        r,
        g,
        y,
        m,
        i
      );
    }
    if (l = this._getPrototypeInstanceCountByAttachment(e), l < o)
      throw new oi();
    n !== null && (await _a([n]), t instanceof Ls, t.addAttachContext(n));
  }
  /**
   * Newly loaded children should have their instances demanded if any of their
   * ancestors are currently being demanded. This function performs this logic.
   */
  async _updateOnDemandRequests(t) {
    if (!this._assemblyTree.onDemandRequestsActive())
      return;
    const e = t.getChildren(), i = [];
    for (const n of e)
      this._assemblyTree.isBeingRequested(n) && i.push(n);
    return this._assemblyTree.requestNodes(this, i, !0);
  }
  async _populateAttachment(t, e, i, n, r, o) {
    console.assert(r === ws.Indirect == (o !== null));
    const l = await this._parseRootNodes(
      t,
      e,
      i,
      n,
      o
    );
    return await this._postProcessAttachContext(e, n, r, l), l;
  }
  async _postProcessAttachContext(t, e, i, n) {
    await Ln.forceLazyPromises(n), await this._assemblyTree.enqueue(() => C0(this._engine, n));
    let r = this._assemblyTree.markImplicitNodesOutOfHierarchy();
    r && (r = n.getChildren().length > 0 || i === ws.Indirect), await this._patchImplicitNodesByAttachment(t, e, r), await this._updateOnDemandRequests(n);
    const l = n.getChildren().map((h) => h.getRuntimeId());
    this._callbackManager.trigger("_attachmentPopulated", l);
  }
  async _parseRootNodes(t, e, i, n, r) {
    const o = n.getMasterModelKey(), l = n.getInclusionsOf(o);
    o === Ur.Invalid && (console.assert(l.length === 0), l.push(Ei.Invalid, xs.Invalid));
    const h = new Pn(
      i,
      n.getAttachScope(),
      n.attachedInvisibly(),
      o,
      e
    );
    r !== null && h.setReservedNodeIdOffset(r);
    const u = new jo(1, !0), d = await this._assemblyTree.enqueue(() => h.getRootNodeMetaData(this._assemblyTree));
    for (let g = 0; g < l.length; g += 2)
      u.push(() => {
        const y = l[g], m = l[g + 1];
        return this._parseRootNode(t, h, d, y, m);
      });
    return await u.waitForIdle(), h;
  }
  async _parseRootNode(t, e, i, n, r) {
    console.assert(n !== Ei.Local);
    const o = await this._populateInclusion(
      t,
      e,
      i,
      n,
      r
    );
    if (o.hasAuthoredId()) {
      console.assert(!o.isLoaded());
      const l = Gi(o);
      $x(l) && this._setupRootNode(o, !1);
    } else
      o.getName() === null && (e.removeProductOccurrence(o) || console.assert(!1));
  }
  _setupRootNode(t, e, i = !1, n = [], r = pl.Unknown) {
    console.assert(!t.isAbsoluteRoot()), e && t.markIsExternalModelRoot(this._assemblyTree), this._resolveMeasurementUnits(t, i, n, r);
  }
  async _populateInclusion(t, e, i, n, r) {
    console.assert(n !== Ei.Local);
    const o = new Gn(
      this._assemblyTree,
      e,
      n,
      r
    );
    e.addInclusionContext(o);
    const l = await (async () => {
      if (i === null || i.bytes.length === 0) {
        let d = null;
        return i === null && (d = $y), _e.createDynamic(
          this._assemblyTree,
          o,
          d,
          null,
          // authored node id
          null,
          // local transform
          !e.attachedInvisibly()
        );
      }
      const h = new rh(i), u = _e.parseBinary(
        t,
        this._assemblyTree,
        o,
        h
      );
      return _e.reify(
        t,
        this,
        this._assemblyTree,
        o,
        u,
        o
      );
    })();
    return o.addProductOccurrence(l), l;
  }
  /**
   * COM-1701
   */
  async _rectifyLateVisibilityChange(t, e) {
    const i = Fi(e.getParent()), n = pr(e.getParent());
    if (console.assert(n === pr(i)), t.attachInvisibly || n === null || !n.isLoaded())
      return;
    const r = n.isVisible();
    if (i.attachedInvisibly() === !r)
      return;
    const o = r ? oo.Initial : oo.Hide;
    return x0({
      assemblyTree: this._assemblyTree,
      engine: this._engine,
      attachContext: i,
      setVisibility: o
    });
  }
  _loadCleanup(t, e, i) {
    console.assert(this._activeLoadCount > 0), t.onLoadComplete(), e !== null && this._callbackManager.unbind(e), --this._activeLoadCount, this._assemblyTree.onLoadEnd(i), this._callbackManager.trigger("visibilityChanged", [], []);
  }
  _wrap(t, e, i, n) {
    const r = this._activeLoadGeneration;
    return this._loadQueue.push(async () => {
      const o = this._assemblyTree.onLoadBegin();
      let l = null;
      if (r !== this._activeLoadGeneration)
        throw this._loadCleanup(e, l, o), new _d();
      this._firstAssemblyDataHeader === null && (l = {
        _modelStructureHeaderParsed: async (y) => {
          l !== null && (this._firstAssemblyDataHeader === null && (this._firstAssemblyDataHeader = y), this._callbackManager.unbind(l), l = null);
        }
      }, this._callbackManager.bind(l, !0));
      try {
        await i;
      } catch (y) {
        throw await e.purgeContents(), this._loadCleanup(e, l, o), y;
      }
      const h = e.getParent();
      if (h === null)
        throw this._loadCleanup(e, l, o), new oi();
      n === ws.Direct && (e.hasChildren() ? h.addLoadContext(e) : await e.purgeContents()), this._loadCleanup(e, l, o);
      const d = e.getChildren(), g = [];
      for (const y of d) {
        const m = this._rectifyLateVisibilityChange(t, y);
        g.push(m);
      }
      if (await Ge(g), this._isFirstLoad) {
        this._isFirstLoad = !1, e.markAsFirstLoad();
        const y = d.map((x) => x.getRuntimeId()), m = !1;
        try {
          await this._callbackManager.promiseTrigger(
            "_firstModelLoaded",
            "firstModelLoaded",
            y,
            m,
            n,
            t
          );
        } catch (x) {
          throw console.assert(!1), x;
        }
      }
      return e;
    });
  }
  _initLoad(t, e, i) {
    ++this._activeLoadCount;
    const n = this._isScsSession && i ? new Hx() : null;
    return new Ls(t, e, n);
  }
  static _getNetMatrix(t, e) {
    let i = mt.createFromArray(oh(t));
    return e !== null && (i = mt.multiply(e, i)), i;
  }
  _lazyAttachInvisibly(t, e) {
    return Is.create(() => e.attachInvisibly || !t.isVisible());
  }
  _loadBySingleAttach(t, e, i, n) {
    const r = this._initLoad(e, n, !1), o = jn.create(async () => {
      const l = await i, h = new sl(), u = Lg._getNetMatrix(e, t.additionalMatrix), d = e.getMeasurementUnit(), g = this._lazyAttachInvisibly(e, t), y = await this._scAttacher.simpleAttach(
        this._assemblyTree,
        h,
        l,
        u,
        d,
        g,
        null,
        // xml attach info
        !1
      ), m = await this._populateAttachment(
        t,
        r,
        h,
        y,
        ws.Direct,
        null
      );
      return await _a([r, m]), m.hasChildren() && r.addAttachContext(m), {};
    });
    return this._wrap(t, r, o, ws.Direct);
  }
  async _populateFromXml(t, e, i, n) {
    let o = i.documentElement.firstElementChild, l = null, h = null;
    for (; o !== null; ) {
      if (o.localName === "ModelFile" && (console.assert(l === null), l = hf.parseXml(
        t,
        this._assemblyTree,
        e,
        o,
        n
      )), o.localName === "DefaultCamera" && (h = gi.parseCamera(o), !h))
        throw new si(`"DefaultCamera" element exists but couldn't be parsed`);
      o = o.nextElementSibling;
    }
    if (l === null)
      throw new si('Expected "ModelFile" element.');
    let u = !1;
    if (this._isFirstLoad) {
      let g = Ns;
      if (this._assemblyTree.getAutomaticMeasurementUnitScaling() && (g = pr(e).getMeasurementUnit()), h != null)
        u = !0, await this._view._setCameraPromise(h, 0);
      else {
        const y = hf.parseBounding(l, g);
        !y.isDegenerate() && h === null && (u = !0, await this._view.setViewOrientation(Ct.Iso, 0, y));
      }
    }
    const d = await hf.reify(
      t,
      this._callbackManager,
      this,
      this._assemblyTree,
      e,
      l
    );
    for (const g of d)
      this._setupRootNode(g, !1);
    this._isFirstLoad && !u && await this._view.setViewOrientation(Ct.Iso, 0);
  }
  _loadByXml(t, e, i, n, r) {
    const o = this._initLoad(e, r, !0), l = jn.create(async () => {
      const h = await i;
      Gx(h);
      const u = jx(h);
      if (u === null || !Wx(u))
        throw new si("Bad version.");
      const d = (C) => n(C, u);
      this._scAttacher.reprioritizeAttachmentsNow(), e.addLoadContext(o);
      const g = Gi(e), y = Fi(g), m = this._scAttacher.newAttachScope(), x = this._lazyAttachInvisibly(e, t), b = y.split(
        m,
        x.get(),
        o
      );
      o.addAttachContext(b);
      const I = g.split(
        this._assemblyTree,
        b
      );
      return b.addInclusionContext(I), await this._populateFromXml(t, I, h, d), await _a([o, b]), {};
    });
    return this._wrap(t, o, l, ws.Indirect);
  }
  // For external models built-directly inside SC metadata (i.e. not from a shattered XML file).
  async _attachExternalModelByInc(t, e) {
    console.assert(t.inclusionKey !== Ei.Local);
    const i = Fi(e).getAttachScope(), n = t.modelKey, r = this._lazyAttachInvisibly(e, t.config), o = new sl(), l = new Pn(
      o,
      i,
      r.get(),
      n,
      e
    ), h = await l.getRootNodeMetaData(this._assemblyTree);
    return await this._populateInclusion(
      t.config,
      l,
      h,
      t.inclusionKey,
      t.modelKey
    ), l;
  }
  // For external models given by shattered XML files.
  async _attachExternalModelInfoByName(t, e, i) {
    const n = new sl(), r = this._lazyAttachInvisibly(e, t.config), o = e.getMeasurementUnit(), l = (() => {
      const d = mt.createFromArray(oh(e));
      if (o <= 0 || !this._assemblyTree.getAutomaticMeasurementUnitScaling())
        return d;
      const g = (() => {
        const x = i.getAttachContext().getParent();
        if (x === null)
          return Ns;
        const b = x.getParent();
        return b === null ? Ns : b.getMeasurementUnit();
      })(), y = g === Ns ? 1 : o / g;
      return y === 1 ? d : mt.multiply(
        d,
        new mt().setScaleComponent(y, y, y)
      );
    })(), h = {
      bounding: t.bounding,
      parent: e,
      directlyRequested: !1
    };
    let u;
    if (this._isScsSession)
      this._scAttacher.registerXmlAttachInfo(h), u = await this._scAttacher.attachByNamedScsBuffer(
        this._assemblyTree,
        t.modelName,
        n,
        t.toAttachData,
        l,
        o,
        r,
        h,
        t.cancelUnitScale
      ) || 0;
    else
      try {
        const d = await t.toAttachData(t.modelName);
        if (d === null || d === ba)
          u = 0;
        else {
          if (typeof d != "string")
            throw new oi();
          this._scAttacher.registerXmlAttachInfo(h), u = await this._scAttacher.simpleAttach(
            this._assemblyTree,
            n,
            d,
            l,
            o,
            r,
            h,
            t.config.allowMissingExternalModels
          );
        }
      } catch (d) {
        if (t.config.allowMissingExternalModels && d instanceof yd)
          u = 1;
        else
          throw d;
      }
    if (typeof u == "number") {
      const d = this._scAttacher.newAttachScope(), g = !r.get();
      return qx(
        this._assemblyTree,
        n,
        e,
        u,
        d,
        g
      );
    } else
      return this._populateAttachment(
        t.config,
        e,
        n,
        u,
        ws.Indirect,
        t.reservedNodeIdOffset
      );
  }
  setPrefetchScsCutoffScale(t) {
    this._scAttacher.setPrefetchScsCutoffScale(t);
  }
  isIdle() {
    return this._activeLoadCount === 0 ? (console.assert(this._scAttacher.isIdle()), !0) : !1;
  }
  waitOnCurrentLoads() {
    return this._loadQueue.waitForIdle();
  }
  cancelPendingLoads() {
    return ++this._activeLoadGeneration, this.waitOnCurrentLoads();
  }
  async cancelActiveAttachmentProcess() {
    return this._scAttacher.clearAttachQueues();
  }
  loadByStream(t, e, i) {
    if (i === ba) {
      const n = new Ls(e, ba, null);
      return Promise.resolve(n);
    }
    return this._loadBySingleAttach(t, e, Promise.resolve(i), i);
  }
  loadByScsBuffer(t, e, i) {
    return this._loadBySingleAttach(t, e, Promise.resolve(i), "*SCS Buffer*");
  }
  async loadByScsFile(t, e, i) {
    if (Ra.isSupported())
      return this._loadBySingleAttach(t, e, Ra.request(i), i);
    {
      const n = Gy(i);
      return this._loadBySingleAttach(t, e, n, i);
    }
  }
  loadByXmlDoc(t, e, i, n) {
    let r;
    return typeof i == "string" ? r = qy(i) : r = i, this._loadByXml(t, e, Promise.resolve(r), n, "*XML Document*");
  }
  loadByXmlFile(t, e, i, n) {
    const r = Ux(i);
    return this._loadByXml(t, e, r, n, i);
  }
  async attachByExternalModelInfo(t, e, i) {
    let n, r = !1;
    sh(t) ? (r = t.cancelUnitScale, n = await this._attachExternalModelInfoByName(t, e, i)) : n = await this._attachExternalModelByInc(t, e);
    const o = [], l = n.getChildren(), h = n.getAssemblyDataVersion(), u = n.getOriginalFileType();
    for (const d of l) {
      this._setupRootNode(d, !0, r, h, u);
      const g = this._rectifyLateVisibilityChange(t.config, d);
      o.push(g);
    }
    return await Ge(o), n;
  }
  /**
   * I don't think this is used at all. If so, this should be removed.
   */
  async loadByAssemblyData(t, e, i, n) {
    const r = ws.Direct, [o, l] = i, h = this._scAttacher.newAttachScope(), u = !e.isVisible(), d = Kx(h, u, o, l), g = this._initLoad(e, "*Assembly Data*", !1), y = jn.create(async () => {
      const m = new sl(), x = d.getMasterModelKey(), b = new Pn(
        m,
        h,
        d.attachedInvisibly(),
        x,
        g
      );
      return await this._parseRootNode(t, b, n, o, l), await this._postProcessAttachContext(g, d, r, b), await _a([g, b]), b.hasChildren() && g.addAttachContext(b), {};
    });
    return this._wrap(t, g, y, r);
  }
  reset() {
    return this._isFirstLoad = !0, this._firstAssemblyDataHeader = null, this._scAttacher.reset();
  }
  notifyDirectRequest(t) {
    this._scAttacher.notifyDirectRequest(t);
  }
  onLoadChildProductOccurrence() {
    if (this._nodesUntilNextSleep === 0)
      return this._nodesUntilNextSleep = 2e3, this._engine.sleep(
        10
        /* sleepLengthMilliseconds */
      );
    --this._nodesUntilNextSleep;
  }
  firstAssemblyDataHeader() {
    return this._firstAssemblyDataHeader;
  }
}
function Xx(s, t, e, i, n) {
  const r = [], o = (g) => {
    g.getInclusionContexts().forEach((m) => {
      r.push(m.getInclusionKey());
    });
  }, l = (g) => {
    g.getAttachContexts().forEach(o);
  }, u = {
    enterProductOccurrence: (g) => {
      if (i.has(g) || (i.add(g), g.isOutOfHierarchy() && !e))
        return;
      g.getChildContexts().forEach((m) => {
        m instanceof Ls ? l(m) : o(m);
      });
    }
  }, d = s.walk(u, t, n);
  return d ? d.then(() => r) : r;
}
function Jx(s, t, e, i) {
  return Xx(
    Nh,
    s,
    t,
    e,
    i
  );
}
function Yx(s, t, e) {
  const i = [], n = /* @__PURE__ */ new Set();
  for (const r of t) {
    const o = s.lookupAnyTreeNode(r);
    if (o === null)
      throw new Ds(r);
    const l = Do(o), h = Jx(o, l, n, e);
    for (const u of h)
      i.push(u);
  }
  return i;
}
async function Zx(s) {
  let t = !1;
  const e = (n) => {
    n.hasLocalTransformOverride() && (n.removeLocalTransformOverride(), t = !0);
  }, i = {
    enterProductOccurrence: e,
    enterPmi: e,
    enterCadView: e,
    enterAnyBody: (n) => {
      n.preventFromResetting() || e(n);
    }
  };
  return await Ln.walk(i, s, Vt.None), t;
}
function Qx(s, t, e) {
  const i = [], n = /* @__PURE__ */ new Set(), r = (l) => n.has(l) ? !1 : (n.add(l), !0), o = {
    followProductOccurrence: r,
    followPmi: r,
    followCadView: r,
    followAnyBody: r,
    enterAnyBody: (l) => {
      if (!l.isOutOfHierarchy()) {
        const h = l.getInstanceInc();
        i.push(h[0], h[1]);
      }
    }
  };
  for (const l of t)
    Nh.walk(o, l, Vt.None);
  s.setMeshLevel(i, e);
}
function tI(s) {
  return s instanceof Li || s instanceof Wi || s instanceof Ca || s instanceof Sa || s instanceof Pa || s instanceof vh || s instanceof bh || s instanceof xh || s instanceof Ih || s instanceof Ch || s instanceof Sh || s instanceof Ph || s instanceof kh || s instanceof Mh || s instanceof Eh || s instanceof Ah || s instanceof Th || s instanceof wh;
}
function eI(s) {
  return s instanceof yh || s instanceof Ol || s instanceof Ho;
}
function Qp(s) {
  return async (t, e) => {
    const i = Zc(e, [7, 3]) ? `${t}.scs` : t, n = await s(i);
    return typeof n == "string" ? Ra.isSupported() ? Ra.request(n) : Gy(n) : n;
  };
}
class iI {
  constructor(t, e, i, n, r) {
    this._clearQueue = new jo(1, !1), this._clearInProgress = !1, this._cadConfigurationsEnabled = !0, this._engine = e, this._callbackManager = i, this._cuttingManager = n, this._model = r, this._assemblyTree = new Fx(
      t,
      this._engine,
      this._callbackManager,
      this._cuttingManager,
      this._model
    ), this._readyPromise = pd();
  }
  async init(t, e) {
    const i = await cd.createWithEmptyModel(
      this._engine,
      t,
      this._callbackManager,
      e
    );
    this._assemblyTree.initialize(i);
    const n = new Lg(
      this._assemblyTree,
      i,
      this._engine,
      t,
      this._callbackManager
    );
    console.assert(this._treeLoader === void 0), this._treeLoader = n, this._readyPromise.resolve();
  }
  async _loadSubtreePrologue(t, e, i) {
    if (this._engine.getSessionType() !== t)
      throw new qr("Incompatible load types.");
    if (i && await this._clearQueue.waitOnLatest(), this._clearInProgress)
      throw new _d();
    const n = this._assemblyTree.lookupProductOccurrence(e);
    if (n === null)
      throw new is(e, In.ProductOccurrence);
    return n;
  }
  async _loadSubtreeEpilogue(t, e) {
    t.isFirstLoad() && this._engine.getSessionType() === en.Scs && await this._callbackManager.promiseTrigger("_firstBoundingReady", null);
    const n = t.getChildren().map((r) => r.getRuntimeId());
    return e && await this._callbackManager.promiseTrigger(
      "_subtreeLoaded",
      "subtreeLoaded",
      n,
      ho.LoadModel
    ), n;
  }
  async loadSubtreeFromXmlFile(t, e, i, n) {
    await this._disableCadConfigurations();
    const r = en.Network, o = await this._loadSubtreePrologue(r, t, !0), l = await this._treeLoader.loadByXmlFile(
      n,
      o,
      e,
      i
    );
    return this._loadSubtreeEpilogue(l, !1);
  }
  async loadSubtreeFromXmlDoc(t, e, i, n) {
    await this._disableCadConfigurations();
    const r = en.Network, o = await this._loadSubtreePrologue(r, t, !0), l = await this._treeLoader.loadByXmlDoc(n, o, e, i);
    return this._loadSubtreeEpilogue(l, !1);
  }
  async loadSubtreeFromScsXmlFile(t, e, i, n) {
    await this._disableCadConfigurations();
    const r = en.Scs, o = await this._loadSubtreePrologue(r, t, !0), l = Qp(i), h = await this._treeLoader.loadByXmlFile(n, o, e, l);
    return this._loadSubtreeEpilogue(h, !1);
  }
  async loadSubtreeFromScsXmlDoc(t, e, i, n) {
    await this._disableCadConfigurations();
    const r = en.Scs, o = await this._loadSubtreePrologue(r, t, !0), l = Qp(i), h = await this._treeLoader.loadByXmlDoc(n, o, e, l);
    return this._loadSubtreeEpilogue(h, !1);
  }
  async _loadSubtreeFromStream(t, e, i, n) {
    const r = en.Network, o = await this._loadSubtreePrologue(r, t, i), l = await this._treeLoader.loadByStream(n, o, e);
    return this._loadSubtreeEpilogue(l, n._allowSubtreeLoadedCallback);
  }
  async loadSubtreeFromStream(t, e, i) {
    return this._loadSubtreeFromStream(t, e, !0, i);
  }
  async loadSubtreeFromScsFile(t, e, i) {
    const n = en.Scs, r = await this._loadSubtreePrologue(n, t, !0), o = await this._treeLoader.loadByScsFile(i, r, e);
    return this._loadSubtreeEpilogue(o, i._allowSubtreeLoadedCallback);
  }
  async loadSubtreeFromScsBuffer(t, e, i) {
    const n = en.Scs, r = await this._loadSubtreePrologue(n, t, !0), o = await this._treeLoader.loadByScsBuffer(i, r, e);
    return this._loadSubtreeEpilogue(o, i._allowSubtreeLoadedCallback);
  }
  /**
   * I don't think this is used at all. If so, this should be removed.
   */
  async loadSubtreeFromAssemblyData(t, e, i, n) {
    const r = en.Network, o = await this._loadSubtreePrologue(r, t, !0), l = await this._treeLoader.loadByAssemblyData(
      n,
      o,
      e,
      i
    );
    return this._loadSubtreeEpilogue(l, n._allowSubtreeLoadedCallback);
  }
  async loadMeasurementFromJson(t) {
    const e = Object.keys(t);
    for (const i of e) {
      const n = parseInt(i, 10);
      if (isNaN(n))
        continue;
      const r = t[n], o = parseInt(r.instance_id, 10);
      if (isNaN(o))
        continue;
      const l = await this._getNodeOrRepItemFromId(o);
      if (!(l instanceof tn))
        continue;
      const h = r.edge_properties;
      for (let d = 0; d < h.length; d++) {
        const g = h[d], y = g.id, m = g.data;
        let x = null;
        switch (g.type) {
          case "circle":
            x = Ol.fromJson(m);
            break;
          case "line":
            x = yh.fromJson(m);
            break;
          case "unknown_edge":
            x = Ho.fromJson(m);
            break;
        }
        x !== null && l.setEdgeMeasurementProperty(y, x);
      }
      const u = r.face_properties;
      for (let d = 0; d < u.length; d++) {
        const g = u[d], y = g.id, m = g.data;
        let x = null;
        switch (g.type) {
          case "cylinder":
            x = Li.fromJson(m);
            break;
          case "plane":
            x = Wi.fromJson(m);
            break;
          case "cone":
            x = Ca.fromJson(m);
            break;
          case "sphere":
            x = Sa.fromJson(m);
            break;
          case "torus":
            x = Pa.fromJson(m);
            break;
        }
        x !== null && l.setFaceMeasurementProperty(y, x);
      }
    }
  }
  async loadMeasurementFromString(t) {
    const e = JSON.parse(t);
    return this.loadMeasurementFromJson(e);
  }
  async loadMeasurementFromFile(t) {
    const e = await Rg(t, "blob");
    if (e.status !== 200)
      throw new Error(`Cannot pull measurement file '${t}': ${e.response}`);
    const n = (await Ig.loadAsync(e.response)).file("measurement.json");
    if (!n)
      throw new Error(`Cannot pull measurement data from '${t}'`);
    const r = await n.async("string");
    return this.loadMeasurementFromString(r);
  }
  async _clearImpl() {
    console.assert(!this._clearInProgress), this._clearInProgress = !0;
    try {
      await this._treeLoader.cancelActiveAttachmentProcess(), await this._treeLoader.cancelPendingLoads(), console.assert(this._treeLoader.isIdle()), console.assert(this._clearInProgress), await this._treeLoader.reset(), console.assert(this._treeLoader.isIdle()), console.assert(this._clearInProgress), await this._assemblyTree.reset(), console.assert(this._treeLoader.isIdle()), console.assert(this._clearInProgress), this._clearInProgress = !1;
    } catch (t) {
      throw console.assert(this._clearInProgress), this._clearInProgress = !1, t;
    }
  }
  clear() {
    return this._clearQueue.push(async () => (this._callbackManager.trigger("modelSwitchStart", !0), await this._clearImpl(), this._callbackManager.promiseTrigger(
      "_modelSwitched",
      "modelSwitched",
      !0,
      [],
      ws.Direct
    )));
  }
  switchToModel(t) {
    const e = t === ba;
    return this._clearQueue.push(async () => {
      this._callbackManager.trigger("modelSwitchStart", !1), await this._clearImpl();
      let i;
      return e ? i = [] : i = await this._loadSubtreeFromStream(
        this.getAbsoluteRootNodeId(),
        t,
        !1,
        new Ma()
      ), await this._callbackManager.promiseTrigger(
        "_modelSwitched",
        "modelSwitched",
        e,
        i,
        ws.Direct
      ), i;
    });
  }
  getAbsoluteRootNodeId() {
    return this._assemblyTree.getRootNode().getRuntimeId();
  }
  isIdValid(t) {
    return this._assemblyTree.lookupAnyNode(t) !== null;
  }
  _getNodeChildren(t, e) {
    let i = t.getChildrenSync();
    e || (i = i.filter((o) => !o.isOutOfHierarchy()));
    const n = t.getBodyInstances();
    for (const o of n)
      (!o.isOutOfHierarchy() || e) && i.push(o);
    const r = t.getPmis();
    for (const o of r)
      i.push(o);
    return i;
  }
  getChildIds(t, e) {
    const i = this._assemblyTree.lookupProductOccurrence(t);
    if (i === null)
      return [];
    const n = this._getNodeChildren(i, e), r = [];
    for (const o of n)
      r.push(o.getRuntimeId());
    return r;
  }
  isOutOfHierarchy(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    return e !== null && Do(e);
  }
  getParentId(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    if (e === null)
      return null;
    const i = I_(e.getParent());
    return i === null ? null : i.getRuntimeId();
  }
  async getPartReferrers(t) {
    const e = this._assemblyTree.lookupProductOccurrence(t);
    if (e === null)
      return null;
    const i = this._assemblyTree.getRootNode();
    await Af(i), await T0(i);
    const n = e.getPartDefinitionSync();
    if (n === null)
      return null;
    const r = n.getReferrers(), o = /* @__PURE__ */ new Set();
    for (const l of r) {
      const u = l.getParent().getReferrers();
      for (const d of u)
        o.add(d.getRuntimeId());
    }
    return Array.from(o);
  }
  async getAttributes(t) {
    const e = await this._getNodeOrRepItemFromId(t);
    return e === null ? [] : e.getAttributes();
  }
  async getProperties(t, e) {
    const i = await this._getNodeOrRepItemFromId(t);
    if (i === null)
      return null;
    const n = await this._getNodeAttributes(i), r = {};
    if (i instanceof tn) {
      const o = i.getPhysicalProperties();
      o !== null && Object.assign(n, this._handlePhysicalProperties(t, o));
    } else if (i instanceof _e) {
      await nh(i);
      const o = await i.getPhysicalProperties(e);
      o !== null && Object.assign(n, this._handlePhysicalProperties(t, o));
      const l = await i.getPartDefinition();
      l !== null && Object.assign(r, await this._getPartDefAttributes(await l.value));
    }
    return { ...r, ...n };
  }
  addProperty(t, e, i, n) {
    const r = this._assemblyTree.lookupAnyNode(t);
    if (r === null)
      return !1;
    const o = new gr(
      zr.String,
      e,
      null,
      i,
      n
    );
    return r.addAttribute(o), !0;
  }
  setPhysicalProperties(t, e, i, n) {
    const r = this._assemblyTree.lookupRepresentationItem(t);
    if (r === null)
      return !1;
    const o = new wa(i, n, e);
    return r.setPhysicalProperties(o), !0;
  }
  getUserDataIndices(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    if (e === null)
      throw new Ds(t);
    return e.getUserDataIndices();
  }
  getUserData(t, e) {
    const i = this._assemblyTree.lookupAnyTreeNode(t);
    if (i === null)
      throw new Ds(t);
    return i.getUserData(e);
  }
  getInstanceIncs(t, e) {
    const i = this._assemblyTree.lookupAnyTreeNode(t);
    if (i === null)
      return console.assert(!1), [];
    const n = Do(i);
    return ih(
      i,
      e,
      n,
      /* @__PURE__ */ new Set(),
      Vt.None
    );
  }
  getNodeFromInstanceInc(t, e, i, n) {
    let r = this._assemblyTree.lookupAnyBodyByInstanceInc(
      e,
      i
    );
    if (r === null) {
      const o = t ? this._rectifyParent(e, null) : this._assemblyTree.getRootNode();
      r = this._assemblyTree.createMeshInstance(
        t,
        e,
        i,
        null,
        // authored ID
        null,
        // name
        o,
        !1,
        // prevent from resetting
        n,
        !0,
        // initially visible
        !1
        // implicit body
      );
    } else
      r instanceof Bs && (r = r.getParent());
    return r.getRuntimeId();
  }
  _getAssociatedModelKey(t) {
    return t instanceof ns ? t.getModelKey() : this._getAssociatedModelKey(t.getParent());
  }
  getAssociatedModelKey(t) {
    let e = this._assemblyTree.lookupAnyTreeNode(t);
    return e === null ? (e = this._assemblyTree.lookupAnyNonTreeNode(t), e === null ? null : this._getAssociatedModelKey(e)) : Fi(e).getMasterModelKey();
  }
  getMatrix(t) {
    const e = this._assemblyTree.lookupAnyNode(t);
    if (e === null)
      return new mt();
    const i = e.getLocalTransform();
    return i === null ? new mt() : mt.createFromArray(i);
  }
  async setMatrix(t, e, i) {
    const n = this._assemblyTree.lookupAnyTreeNode(t);
    if (n === null)
      return;
    i ? n.setLocalTransformAsInitial(e.m) : n.overrideLocalTransform(e.m);
    const r = Do(n);
    return mc(this._engine, this._callbackManager, [n], r);
  }
  setMatrices(t, e, i) {
    const n = [];
    let r = !1;
    for (let o = 0; o < t.length; o++) {
      const l = this._assemblyTree.lookupAnyTreeNode(t[o]), h = e[o];
      l !== null && (i ? l.setLocalTransformAsInitial(h.m) : l.overrideLocalTransform(h.m), r = r || Do(l), n.push(l));
    }
    return mc(this._engine, this._callbackManager, n, r);
  }
  async resetToInitialMatrix(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    if (e !== null && e.hasLocalTransformOverride()) {
      e.removeLocalTransformOverride();
      const i = Do(e);
      return mc(this._engine, this._callbackManager, [e], i);
    }
  }
  getNetMatrix(t) {
    const e = this._assemblyTree.lookupAnyNode(t);
    return e === null ? Wn.getIdentity() : oh(e);
  }
  _getBodyInstanceIndexFrom(t, e, i) {
    i === void 0 && (i = {});
    const n = t.getBodyInstances();
    for (const l of n)
      if (i.value !== void 0 ? i.value++ : i.value = 0, l === e)
        return i.value;
    let r;
    const o = t.getChildrenSync();
    for (const l of o)
      if (r = this._getBodyInstanceIndexFrom(l, e, i), r !== void 0)
        return r;
  }
  async getNodeOrRepItem(t) {
    if (t instanceof Ui) {
      const e = t.getParent();
      let i, n = e;
      for (; ; ) {
        if (!(n instanceof _e))
          return null;
        await nh(n);
        const l = await n.getPartDefinition();
        if (l !== null) {
          i = await l.value;
          break;
        }
        n = n.getParent();
      }
      const r = this._getBodyInstanceIndexFrom(n, t), o = i.getRepresentationItems();
      return r !== void 0 && r < o.length ? o[r] : null;
    } else if (t instanceof _e || t instanceof Sn || t instanceof ss || t instanceof ns || t instanceof tn)
      return t;
    return null;
  }
  async _getNodeOrRepItemFromId(t) {
    const e = this._assemblyTree.lookupAnyNode(t);
    return e === null ? null : this.getNodeOrRepItem(e);
  }
  async getPointAttributes(t, e) {
    const i = await this._getNodeOrRepItemFromId(t);
    if (i instanceof tn) {
      const n = i.getPointAttributes(e);
      if (n !== null)
        return n.copy();
    }
    return null;
  }
  async getEdgeCount(t) {
    const e = await this._getNodeOrRepItemFromId(t);
    return e instanceof tn ? e.getEdgeCount() : 0;
  }
  async getEdgeAttributes(t, e) {
    const i = await this._getNodeOrRepItemFromId(t);
    if (i instanceof tn) {
      const n = i.getEdgeAttributes(e);
      if (n !== null)
        return n.copy();
    }
    return null;
  }
  async getEdgeProperty(t, e) {
    const i = await this._getNodeOrRepItemFromId(t);
    if (i instanceof tn) {
      const n = i.getEdgeMeasurementProperty(e);
      if (n !== null)
        return n.copy();
    }
    return null;
  }
  async getFaceCount(t) {
    const e = await this._getNodeOrRepItemFromId(t);
    return e instanceof tn ? e.getFaceCount() : 0;
  }
  async getFaceAttributes(t, e) {
    const i = await this._getNodeOrRepItemFromId(t);
    if (i instanceof tn) {
      const n = i.getFaceAttributes(e);
      if (n != null)
        return n.copy();
    }
    return null;
  }
  async getFaceProperty(t, e) {
    const i = await this._getNodeOrRepItemFromId(t);
    if (i instanceof tn) {
      const n = i.getFaceMeasurementProperty(e);
      if (n !== null)
        return n.copy();
    }
    return null;
  }
  setEdgeProperty(t, e, i) {
    const n = this._assemblyTree.lookupRepresentationItem(t);
    n !== null && eI(i) && n.setEdgeMeasurementProperty(e, i);
  }
  setFaceProperty(t, e, i) {
    const n = this._assemblyTree.lookupRepresentationItem(t);
    n !== null && tI(i) && n.setFaceMeasurementProperty(e, i);
  }
  getName(t) {
    const e = this._assemblyTree.lookupAnyNode(t);
    return e !== null ? e.getName() : null;
  }
  getNodeExchangeId(t) {
    const e = this._assemblyTree.lookupAnyNode(t);
    return e !== null ? e.getExchangeId() : null;
  }
  getFilters() {
    return this._assemblyTree.getFilters();
  }
  getFilterName(t) {
    return this._assemblyTree.getFilterName(t);
  }
  getFiltersWithNode(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    return e === null ? [] : this._assemblyTree.getFiltersWithNode(e);
  }
  getNodesFromFilterIds(t) {
    return this._assemblyTree.getNodesFromFilterIds(t);
  }
  getLayers() {
    return this._assemblyTree.getLayers();
  }
  getUniqueLayerNames() {
    return this._assemblyTree.getUniqueLayerNames();
  }
  getLayerName(t) {
    return this._assemblyTree.getLayerName(t);
  }
  getLayerIdsFromName(t) {
    return this._assemblyTree.getLayersIdFromName(t);
  }
  getNodeLayerId(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    if (e === null)
      return null;
    const i = e.getAuthoredLayerId();
    return i === null ? null : Js(e).getRuntimeLayerId(i);
  }
  getAuthoredNodesFromLayer(t, e) {
    const i = this._assemblyTree.getNodesFromLayer(t, e);
    return i === null ? null : i.map((n) => n.getAuthoredId());
  }
  getAuthoredNodesFromLayers(t, e) {
    const i = this._assemblyTree.getNodesFromLayers(t, e);
    return i === null ? null : i.map((n) => n.getAuthoredId());
  }
  getRuntimeNodesFromLayer(t, e) {
    const i = this._assemblyTree.getNodesFromLayer(t, e);
    return i === null ? null : i.map((n) => n.getRuntimeId());
  }
  getRuntimeNodesFromLayers(t, e) {
    const i = this._assemblyTree.getNodesFromLayers(t, e);
    return i === null ? null : i.map((n) => n.getRuntimeId());
  }
  getRuntimeNodesFromLayerName(t, e) {
    const i = this._assemblyTree.getNodesFromLayerName(t, e);
    return i === null ? null : i.map((n) => n.getRuntimeId());
  }
  createCadView(t, e, i, n, r, o, l, h, u) {
    if (this._assemblyTree.lookupProductOccurrence(t) === null)
      return null;
    const g = this._assemblyTree.lookupProductOccurrence(t);
    if (g === null)
      return null;
    let y = null;
    if (n != null) {
      y = [];
      for (const b of n) {
        const I = this._assemblyTree.lookupPmi(b);
        I !== null && y.push(I);
      }
    }
    const m = /* @__PURE__ */ new Map();
    for (const [b, I] of l)
      m.set(b, I.m);
    return this._assemblyTree.createCadView(
      this._engine,
      g,
      e,
      i,
      y,
      r,
      o,
      m,
      h,
      u
    ).getRuntimeId();
  }
  getCadViewMap() {
    const t = this._assemblyTree.getFirstProductOccurrenceWithView(), e = /* @__PURE__ */ new Map();
    return this._assemblyTree.forEachCadView((i) => {
      const n = i.getRuntimeId(), r = i.getParent();
      let o;
      r === t ? o = i.getName() || "(null)" : o = `${r.getName()} - ${i.getName()}`, e.set(n, o);
    }), e;
  }
  async activateCadView(t, e, i, n) {
    if (this.applyFilters(this.getFiltersFromView(e)), this._assemblyTree.hasActiveCadView())
      return await this._assemblyTree.deactivateActiveCadView(), this.activateCadView(t, e, i, n);
    const r = this._assemblyTree.lookupCadView(e);
    if (r !== null)
      return this._assemblyTree.activateCadView(t, r, i, n);
  }
  getCadViewPmis(t) {
    const e = this._assemblyTree.lookupCadView(t);
    if (e === null)
      return [];
    const i = [], n = this._assemblyTree.getCadViewPmis(e);
    for (const r of n)
      i.push(r.getRuntimeId());
    return i;
  }
  async _disableCadConfigurations() {
    this._cadConfigurationsEnabled = !1, await this._assemblyTree.deactivateActiveCadView();
  }
  async cadConfigurationsEnabled() {
    return this._cadConfigurationsEnabled && this._assemblyTree.seenExternalModel() && await this._disableCadConfigurations(), this._cadConfigurationsEnabled;
  }
  getCadConfigurations() {
    const t = {};
    return this._assemblyTree.forEachCadConfiguration((e) => {
      const i = e.getRuntimeId(), n = e.getName() || "(null)";
      t[i] = n;
    }), t;
  }
  getDefaultCadConfiguration() {
    const t = this._assemblyTree.getDefaultCadConfiguration();
    return t !== null ? t.getRuntimeId() : null;
  }
  getActiveCadConfiguration() {
    const t = this._assemblyTree.getActiveCadConfiguration();
    return t !== null ? t.getRuntimeId() : null;
  }
  getCadViewConfiguration(t) {
    const e = this._assemblyTree.lookupCadView(t);
    if (e === null)
      return null;
    const i = e.getParent();
    return i !== null && i.isAConfigurationNode() ? i.getRuntimeId() : null;
  }
  async _activateCadConfiguration(t, e, i) {
    this._assemblyTree.activateCadConfiguration(e);
    const n = e.getRuntimeId(), r = this._assemblyTree.getCadConfigurations().filter((u) => u !== e).map((u) => u.getRuntimeId()), o = /* @__PURE__ */ new Map();
    o.set(n, !0), r.forEach((u) => {
      o.set(u, !1);
    }), await this.setVisibilitiesByMap(o);
    const l = await m_(e, $t.All, !0, /* @__PURE__ */ new Set());
    i && l !== null && l.length > 0 && await t.fitNodes([n], rs), this._callbackManager.trigger("configurationActivated", n);
  }
  async activateCadConfiguration(t, e, i) {
    const n = this._assemblyTree.lookupProductOccurrence(e);
    if (n !== null)
      return this._activateCadConfiguration(t, n, i);
  }
  async activateDefaultCadConfiguration(t, e) {
    const i = this._assemblyTree.getDefaultCadConfiguration();
    i !== null && await this._activateCadConfiguration(t, i, e);
  }
  getDefaultCadView() {
    const t = this._assemblyTree.getDefaultCadConfiguration(), e = this._assemblyTree.getDefaultCadView(t);
    return e !== null ? e.getRuntimeId() : null;
  }
  async activateDefaultCadView(t, e, i) {
    const n = this.getDefaultCadView();
    n !== null && await this.activateCadView(t, n, e, i);
  }
  getPmis() {
    const t = {};
    return this._assemblyTree.forEachPmi((e) => {
      const i = e.getRuntimeId(), n = e.getName() || "(null)";
      t[i] = n;
    }), t;
  }
  getPmiType(t) {
    const e = this._assemblyTree.lookupPmi(t);
    return e === null ? C_.Unknown : e.getPmiType();
  }
  getPmiSubType(t) {
    const e = this._assemblyTree.lookupPmi(t);
    return e === null ? S_.Unknown : e.getPmiSubType();
  }
  getUnit(t) {
    const e = this._assemblyTree.lookupAnyNode(t);
    return e instanceof _e ? e.getMeasurementUnit() : e instanceof Ui ? e.getParent().getMeasurementUnit() : 1;
  }
  _rectifyParent(t, e) {
    if (e !== null) {
      const n = this._assemblyTree.lookupProductOccurrence(e);
      if (n !== null)
        return n;
      console.assert(!1);
    }
    const i = this._assemblyTree.getInclusionContexts(t);
    if (i.length > 0) {
      const r = i[0].getChildren();
      return console.assert(r.length > 0), r[0];
    }
    return this._assemblyTree.getRootNode();
  }
  createMeshInstance(t, e, i, n, r, o, l) {
    const h = this._rectifyParent(t, n);
    return this._assemblyTree.createMeshInstance(
      !0,
      // mark loaded
      t,
      e,
      null,
      // authored id
      i,
      h,
      r,
      o,
      !0,
      // initially visible
      l
    ).getRuntimeId();
  }
  createPmiInstance(t, e, i, n, r, o, l) {
    const h = this._rectifyParent(t, l);
    return this._assemblyTree.createPmiInstance(
      t,
      e,
      null,
      o,
      h,
      i,
      n,
      r
    ).getRuntimeId();
  }
  setVisibilitiesByMap(t, e) {
    const i = /* @__PURE__ */ new Map();
    t.forEach((l, h) => {
      const u = this._assemblyTree.lookupAnyTreeNode(h);
      u !== null && i.set(u, l);
    });
    let n = null;
    const r = this.getActiveCadConfiguration();
    r !== null && (n = this._assemblyTree.lookupProductOccurrence(r));
    const o = this._assemblyTree.getRootNode();
    return Ef({
      assemblyTree: this._assemblyTree,
      engine: this._engine,
      startNode: o,
      visibilityFormatter: (l) => i.get(l),
      resetNonAffectedToDefault: !1,
      configurationNode: n !== null ? n : void 0,
      callbackManager: this._callbackManager,
      initiallyHiddenStayHidden: e
    });
  }
  setBodyNodesVisibility(t, e) {
    const i = typeof e == "boolean" ? (n) => e : e;
    return I0({
      assemblyTree: this._assemblyTree,
      engine: this._engine,
      startNode: t,
      visibilityFormatter: i,
      resetNonAffectedToDefault: !1,
      callbackManager: this._callbackManager,
      initiallyHiddenStayHidden: !1
    });
  }
  setVisibilitiesByValue(t, e, i) {
    const n = /* @__PURE__ */ new Map();
    for (const r of t)
      n.set(r, e);
    return this.setVisibilitiesByMap(
      n,
      i !== null ? i : void 0
    );
  }
  resetAllVisibilities() {
    const t = this._assemblyTree.getRootNode(), e = this._assemblyTree.getActiveCadConfiguration();
    return Ef({
      assemblyTree: this._assemblyTree,
      engine: this._engine,
      startNode: t,
      visibilityFormatter: () => {
      },
      resetNonAffectedToDefault: !0,
      configurationNode: e !== null ? e : void 0,
      callbackManager: this._callbackManager
    });
  }
  async resetAllTransforms() {
    const t = this._assemblyTree.getRootNode();
    if (await Zx(t))
      return mc(this._engine, this._callbackManager, [t], !1);
  }
  async reset() {
    if (this._cadConfigurationsEnabled = !0, this.isACadDrawing())
      return this._callbackManager.promiseTrigger("_resetDrawing", null);
    this._assemblyTree.hasActiveCadView() && await this._assemblyTree.deactivateActiveCadView();
    const t = [this.resetAllVisibilities(), this.resetAllTransforms()];
    await Ge(t);
  }
  setPmiColor(t, e) {
    e === void 0 && (e = this.getAbsoluteRootNodeId());
    const i = this.getInstanceIncs(
      e,
      $t.PmiBody | $t.ViewFrame
    );
    i.length > 0 && (this._engine.setPartColor(i, Yt.Faces, t), this._engine.setPartColor(i, Yt.Lines, t));
  }
  resetPmiColor(t) {
    t === void 0 && (t = this.getAbsoluteRootNodeId());
    const e = this.getInstanceIncs(
      t,
      $t.PmiBody | $t.ViewFrame
    );
    e.length > 0 && (this._engine.unsetPartColor(e, Yt.Faces), this._engine.unsetPartColor(e, Yt.Lines));
  }
  getPmiTopologyReferences(t) {
    const e = this._assemblyTree.lookupPmi(t);
    return e === null ? null : e.getPmiTopologyReferences(this._assemblyTree);
  }
  createNode(t, e, i, n = null, r = !0, o = null) {
    let l = null;
    t !== null && (l = this._assemblyTree.lookupProductOccurrence(t)), l === null && (l = this._assemblyTree.getRootNode()), i !== null && !Dl(i) && (i = null);
    const h = (() => {
      if (o) {
        const g = o / l.getMeasurementUnit(), y = new mt().setScaleComponent(g, g, g);
        return n ? mt.multiply(n, y) : y;
      } else
        return n;
    })(), u = h === null ? null : h.m;
    return this._assemblyTree.createNode(
      l,
      e,
      i,
      u,
      r,
      o
    ).getRuntimeId();
  }
  async deleteNode(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    if (e !== null) {
      if (e instanceof _e || e instanceof Ui || e instanceof Sn)
        return this._assemblyTree.deleteNode(e);
      throw new is(
        t,
        In.ProductOccurrence,
        In.BodyInstance
      );
    }
  }
  createPart(t) {
    return this._assemblyTree.createPart(t).getRuntimeId();
  }
  setPart(t, e) {
    const i = this._assemblyTree.lookupProductOccurrence(t);
    if (i === null)
      return !1;
    const n = this._assemblyTree.lookupPartDefinition(e);
    return n === null ? !1 : (this._assemblyTree.setPart(i, n), !0);
  }
  createAndAddRepItem(t, e) {
    const i = this._assemblyTree.lookupPartDefinition(t);
    return i === null ? null : i.createRepItem(this._assemblyTree, e).getRuntimeId();
  }
  getLowestAvailableNodeId() {
    return this._assemblyTree.getLowestAvailableNodeId();
  }
  getType(t) {
    const e = this._assemblyTree.lookupAnyNode(t);
    return e === null ? Le.Unknown : G0(e);
  }
  isVisible(t) {
    const e = this._assemblyTree.lookupAnyNode(t);
    return e !== null ? e.isVisible() : !1;
  }
  getBranchVisibility(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    return e !== null ? W0(e) : de.Hidden;
  }
  setMeshLevel(t, e) {
    const i = [];
    for (const n of t) {
      const r = this._assemblyTree.lookupAnyTreeNode(n);
      r !== null && i.push(r);
    }
    return Qx(this._engine, i, e);
  }
  setEnableAutomaticUnitScaling(t) {
    this._assemblyTree.setAutomaticMeasurementUnitScaling(t);
  }
  setBehaviorInitiallyHidden(t) {
    this._assemblyTree.setInitiallyHiddenStayHidden(t);
  }
  isACadDrawing() {
    return this._assemblyTree.containsDrawings();
  }
  isMeasurable() {
    return this._assemblyTree.isMeasurable();
  }
  async isLineMeasurable(t, e) {
    const i = await this._getNodeOrRepItemFromId(t);
    return i instanceof tn ? i.getEdgeMeasurementProperty(e) !== null : !1;
  }
  async isFaceMeasurable(t, e) {
    const i = await this._getNodeOrRepItemFromId(t);
    return i instanceof tn ? i.getFaceMeasurementProperty(e) !== null : !1;
  }
  getModelFileNameFromNode(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    return e !== null ? Fi(e).getOriginalFileName() : null;
  }
  getModelFileTypeFromNode(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    return e !== null ? Fi(e).getOriginalFileType() : null;
  }
  isAnnotationView(t) {
    const e = this._assemblyTree.lookupCadView(t);
    if (e !== null)
      return e.isAnnotationView();
    throw new is(t, In.CadView);
  }
  isCombineStateView(t) {
    const e = this._assemblyTree.lookupCadView(t);
    if (e)
      return e.isCombineStateView();
    throw new is(t, In.CadView);
  }
  /** This will undo the effect of calling preventNodeDeletion() for the given node. */
  allowNodeDeletion(t) {
    const e = this._assemblyTree.lookupBodyInstance(t);
    if (e === null)
      throw new oi();
    this._assemblyTree.allowNodeDeletion(e);
  }
  preventNodeDeletion(t) {
    const e = this._assemblyTree.lookupBodyInstance(t);
    if (e === null)
      throw new oi();
    this._assemblyTree.preventNodeDeletion(e);
  }
  preventMeshDeletion(t) {
    this._assemblyTree.preventMeshDeletion(t);
  }
  getBounding(t, e, i, n) {
    return y_(
      this._assemblyTree,
      this._engine,
      t,
      e,
      i,
      n
    );
  }
  getIdOffset(t) {
    const e = this._assemblyTree.lookupAnyNode(t);
    if (e !== null) {
      let i;
      return e instanceof ns ? i = e.getInclusionContextForNodeId() : e instanceof tn ? i = e.getParent().getInclusionContextForNodeId() : i = Gi(e), i.getIdOffset();
    }
    return 0;
  }
  /**
   * Motivation for this function:
   *
   * It is possible to begin a load where some SC geometry gets streamed in
   * but the assembly tree has not been fully parsed. Suppose an SC instance
   * (A) gets streamed, and has its node parsed by the assembly tree. If the
   * user attempts to select (A), our internals will find the NodeId associated
   * with (A). This is so far okay (but not ideal perhaps). The big issue comes
   * when the user starts to query the parents or children of the node. Since
   * the entire loaded subtree has not been fully parsed, querying such things
   * may not make sense because they might not be available. (Querying other
   * things might also be problematic.)
   *
   * It might make sense to not expose this function publically (as it is today
   * in `Model`) and do all the required filtering of selection results in the
   * selection internals. This, however might be 'problematic' when loading a
   * giant model (such as the Boeing). In this case, it might take ages for the
   * tree to completely load, which would make geometry not selectable in the
   * meantime. This might be interpreted as a bug from our users because they might
   * want to highlight such selected geometries.
   *
   * Related: COM-1169
   */
  isNodeLoaded(t) {
    const e = this._assemblyTree.lookupAnyNode(t);
    if (e === null)
      throw new Ds(t);
    return e.isLoaded();
  }
  shutdown() {
    this._treeLoader && this._treeLoader.cancelPendingLoads();
  }
  isReady() {
    return console.assert(this._readyPromise.state !== jr.Rejected), this._readyPromise.state !== jr.Pending;
  }
  waitForReady() {
    return this._readyPromise;
  }
  lookupAnyTreeNode(t) {
    return this._assemblyTree.lookupAnyTreeNode(t);
  }
  lookupAnyBody(t) {
    return this._assemblyTree.lookupAnyBody(t);
  }
  lookupBodyInstance(t) {
    return this._assemblyTree.lookupBodyInstance(t);
  }
  gatherInstanceIncsFromNodeIds(t, e, i) {
    return __(this._assemblyTree, t, e, i);
  }
  gatherInclusionKeysFromNodeIds(t) {
    return Yx(this._assemblyTree, t, Vt.None);
  }
  async requestNodes(t) {
    const e = [];
    for (const i of t) {
      const n = this._assemblyTree.lookupAnyTreeNode(i);
      n !== null && e.push(n);
    }
    return this._assemblyTree.requestNodes(this._treeLoader, e, !1);
  }
  isWithinExternalModel(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    if (e === null)
      return !1;
    let i = pr(e);
    for (; i !== null; ) {
      if (i.isExternalModelRoot())
        return !0;
      i = pr(i.getParent());
    }
    return !1;
  }
  getNodeGenericType(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    return e !== null ? ah(e) : null;
  }
  getNodeGenericId(t) {
    const e = this._assemblyTree.lookupAnyTreeNode(t);
    return e !== null ? e.getGenericId() : null;
  }
  getNodesByGenericId(t) {
    const e = this._assemblyTree.getNodesByGenericId(t);
    if (e !== null) {
      const i = /* @__PURE__ */ new Set();
      return e.forEach((n) => {
        i.add(n.getRuntimeId());
      }), i;
    }
    return null;
  }
  getNodesByGenericType(t) {
    const e = this._assemblyTree.getNodesByGenericType(t);
    if (e !== null) {
      const i = /* @__PURE__ */ new Set();
      return e.forEach((n) => {
        i.add(n.getRuntimeId());
      }), i;
    }
    return null;
  }
  getGenericTypes() {
    const t = [];
    return this._assemblyTree.genericTypeToNodes().forEach((i, n) => {
      t.push(n);
    }), t;
  }
  getGenericTypeIdMap() {
    const t = /* @__PURE__ */ new Map();
    return this._assemblyTree.genericTypeToNodes().forEach((i, n) => {
      const r = /* @__PURE__ */ new Set();
      i.forEach((o) => {
        r.add(o.getRuntimeId());
      }), t.set(n, r);
    }), t;
  }
  hasEffectiveGenericType(t, e) {
    const i = this.lookupAnyTreeNode(t);
    if (i === null)
      throw new Ds(t);
    return rb(i, e);
  }
  registerGenericId(t, e) {
    return this._assemblyTree.registerGenericGlobalId(t, e);
  }
  registerGenericType(t, e) {
    return this._assemblyTree.registerGenericType(t, e);
  }
  hasRelationships(t) {
    const e = this.lookupAnyTreeNode(t);
    if (e === null)
      throw new Ds(t);
    return Gi(e).getRelationships().length > 0;
  }
  getBimIdFromNode(t) {
    const e = this.lookupAnyTreeNode(t);
    return e === null || !e.hasAuthoredId() ? null : e.getAuthoredId().toString();
  }
  getRuntimeNodeFromBimId(t, e) {
    const i = this.lookupAnyTreeNode(t);
    return i === null ? null : Gi(i).getRuntimeNodeFromBimId(e);
  }
  getRelationsByTypeFromNode(t, e) {
    return this._assemblyTree.getRelationshipsOfItem(t, e);
  }
  firstAssemblyDataHeader() {
    return this._treeLoader.firstAssemblyDataHeader();
  }
  setPrefetchScsCutoffScale(t) {
    this._treeLoader.setPrefetchScsCutoffScale(t);
  }
  getAllRelationships(t) {
    const e = this.lookupAnyTreeNode(t);
    return e === null ? [] : Gi(e).getRelationships();
  }
  getAllBimInfos(t) {
    const e = this.lookupAnyTreeNode(t);
    return e === null ? [] : Gi(e).getBimInfos();
  }
  getInfoOfBimId(t, e) {
    const i = this.getAllBimInfos(t);
    for (const n of i)
      if (n.id === e) {
        let r = n.name, o = !1;
        if (n.category === Bo.Connected) {
          const l = this.getRuntimeNodeFromBimId(t, e);
          l !== null && this.getName(l) !== null && (r = this.getName(l), o = !0);
        }
        return { name: r, connected: o };
      }
    return { name: "", connected: !1 };
  }
  getBimIdRelationshipTypes(t, e) {
    var h, u;
    const i = this.lookupAnyTreeNode(t);
    if (i === null)
      return [];
    const r = Gi(i).getRelationships(), o = /* @__PURE__ */ new Map();
    for (const d of r) {
      const g = o.has(d.type) ? o.get(d.type) : { relateds: /* @__PURE__ */ new Set(), relatings: [] };
      ((h = d.relating) == null ? void 0 : h.relationElt.id) === e ? (u = d.related) == null || u.relationships.forEach((y) => g.relateds.add(y.id)) : d.related !== null && d.relating !== null && d.related.relationships.filter((y) => y.id === e).forEach(() => g.relatings.push(d.relating.relationElt.id)), o.set(d.type, g);
    }
    return Array.from(o.entries()).map((d) => ({
      type: d[0],
      relateds: Array.from(d[1].relateds),
      relatings: Array.from(d[1].relatings)
    }));
  }
  getFiltersFromView(t) {
    var e;
    return ((e = this._assemblyTree.lookupCadView(t)) == null ? void 0 : e.getFilters()) ?? [];
  }
  applyFilters(t) {
    const e = this.getNodesFromFilterIds(t);
    if (!e)
      return;
    const i = [...e.nodeIds];
    this._applyFiltersAsync(e.isInclusive, i).catch((n) => {
      console.error("Unhandled error in _applyFiltersAsync:", n);
    });
  }
  async _applyFiltersAsync(t, e) {
    try {
      await this._engine.pauseAllRendering(), await this.reset(), t && await this.setVisibilitiesByValue([this.getAbsoluteRootNodeId()], !1, !1), await this.setVisibilitiesByValue(e, t, !1), await this._engine.resumeAllRendering();
    } catch (i) {
      console.error("Error resetting model:", i);
    }
  }
  async _getNodeAttributes(t) {
    return (await t.getAttributes()).reduce((i, n) => {
      const r = n.getValueName(), o = r ? `${n.getTitle() ?? ""}/${r}` : n.getTitle() ?? "";
      return i[o] = `${n.getValue()}${n.getUnit()}`, i;
    }, {});
  }
  _handlePhysicalProperties(t, e) {
    const i = {}, n = this.getNetMatrix(t), r = new _(n[0], n[1], n[2]), o = this.getUnit(t), l = r.length() / o, h = e.surfaceArea * l * l, u = e.volume * l * l * l;
    i["Surface Area"] = `${$c(h, o)}${xv}`, i.Volume = `${$c(u, o)}${Iv}`;
    const d = _.scale(
      mt.createFromArray(n).transform(e.centerOfGravity),
      1 / o
    );
    return i.COG = `x:${d.x.toLocaleString()} y:${d.y.toLocaleString()} z:${d.z.toLocaleString()}`, i;
  }
  async _getPartDefAttributes(t) {
    const e = {}, i = await t.getAttributes();
    for (const n of i) {
      const r = n.getValueName();
      let o = n.getTitle();
      r !== null && (o = o ? `${o}/${r}` : r);
      const h = `${n.getValue()}${n.getUnit()}`;
      e[o] = h;
    }
    return e;
  }
}
class nI {
  constructor(t) {
    this._engine = t;
  }
  getIdentityInc() {
    return this._identityInc;
  }
  // SC does not guarante an identity matrix to be created on the client
  // XXX: We should probably just reserve Matrix Inc (0, 1) for an eternal identity matrix in SC C++ code.
  async init() {
    const t = await this._engine.createIdentityMatrix();
    this._identityInc = t;
  }
}
function sI(s, t) {
  const e = [];
  for (let i = 0; i < s.length; i += t)
    e.push(s.slice(i, i + t));
  return e;
}
function pf(s, t, e) {
  if (s.selectionMask === Se.None)
    throw new oe("selectionMask is None");
  return {
    ...s,
    cullSuboptimalEntities: t,
    enableOcclusionChecks: t,
    restrictLinesAndPointsToSelectedFaceInstances: e ? !1 : s.restrictLinesAndPointsToSelectedFaceInstances
  };
}
function rI(s) {
  let t = Number.POSITIVE_INFINITY, e = Number.POSITIVE_INFINITY, i = null;
  for (const n of s)
    if (n.length > 0) {
      const r = n[0];
      r.radialMetric < t ? (t = r.radialMetric, e = r.zMetric, i = n) : r.radialMetric === t && r.zMetric < e && (e = r.zMetric, i = n);
    }
  return i;
}
function oI(s, t, e, i) {
  const n = t !== null ? t.entities : [], r = e !== null ? e.entities : [], o = i !== null ? i.entities : [], l = [n, r, o];
  for (; ; ) {
    const h = rI(l);
    if (h === null) {
      console.assert(n.length === 0), console.assert(r.length === 0), console.assert(o.length === 0);
      return;
    }
    console.assert(h.length > 0);
    let u;
    if (h === n) {
      const d = n.pop();
      u = Fg(d);
    } else if (h === r) {
      const d = r.pop();
      u = Bg(d);
    } else {
      console.assert(h === o);
      const d = o.pop();
      u = Tl(d, !0);
    }
    s.push(u);
  }
}
function Tl(s, t) {
  const e = _.createFromArray(s.rayPoint), i = _.createFromArray(s.normal), n = new _(s.bounding.min[0], s.bounding.min[1], s.bounding.min[2]), r = new _(s.bounding.max[0], s.bounding.max[1], s.bounding.max[2]), o = new yn(n, r), l = new Rh(
    e,
    i,
    s.elementIndex,
    s.overlayIndex,
    s.elementBits,
    o,
    t
  ), h = s.instanceInc;
  return _i.create(h[1], h[0], l, null, null);
}
function Fg(s) {
  const t = new _(s.bounding.min[0], s.bounding.min[1], s.bounding.min[2]), e = new _(s.bounding.max[0], s.bounding.max[1], s.bounding.max[2]), i = new yn(t, e), n = new Lh(
    s.elementIndex,
    _.createFromArray(s.point),
    s.lineSegmentVertices,
    s.bestLineSegmentVertexIndex,
    i,
    s.overlayIndex,
    s.elementBits
  ), r = s.instanceInc;
  return _i.create(r[1], r[0], null, n, null);
}
function Bg(s) {
  const t = new Fh(
    _.createFromArray(s.point),
    s.elementIndex,
    s.overlayIndex,
    s.elementBits
  ), e = s.instanceInc;
  return _i.create(e[1], e[0], null, null, t);
}
function tm(s) {
  if (s.point !== null) {
    const t = s.point.entities[0];
    return Bg(t);
  }
  if (s.line !== null) {
    const t = s.line.entities[0];
    return Fg(t);
  }
  if (s.face !== null) {
    const t = s.face.entities[0];
    return Tl(t, !1);
  }
  if (s.proximityFace !== null) {
    const t = s.proximityFace.entities[0];
    return Tl(t, !0);
  }
  return null;
}
function em(s) {
  let t = null;
  if (s.face !== null) {
    const n = s.face.entities[0];
    t = Tl(n, !1);
  } else if (s.proximityFace !== null) {
    const n = s.proximityFace.entities[0];
    t = Tl(n, !0);
  }
  let e = null;
  if (s.line !== null) {
    const n = s.line.entities[0];
    e = Fg(n);
  }
  let i = null;
  if (s.point !== null) {
    const n = s.point.entities[0];
    i = Bg(n);
  }
  return new rd(t, e, i);
}
function im(s) {
  const t = [];
  if (s.face !== null)
    for (const e of s.face.entities) {
      const i = Tl(e, !1);
      t.push(i);
    }
  return oI(t, s.line, s.point, s.proximityFace), t;
}
class aI {
  constructor(t) {
    this._pickTolerance = 20, this._incrementalChunkedItems = /* @__PURE__ */ new Map(), this._sc = t;
  }
  setPickTolerance(t) {
    this._pickTolerance = t;
  }
  getPickTolerance() {
    return this._pickTolerance;
  }
  async beginScreenAreaSelection(t, e, i, n) {
    const r = n;
    let o;
    try {
      o = await this._sc.beginScreenAreaSelection(
        t,
        e.x,
        e.y,
        i.x,
        i.y,
        r
      );
    } catch (l) {
      throw ha(l) && l.scFunction === "beginScreenAreaSelection" ? new no() : l;
    }
    return new xc(o);
  }
  async beginRayDrillSelection(t, e, i, n) {
    const r = n;
    let o;
    try {
      o = await this._sc.beginRayDrillSelection(
        t,
        e.x,
        e.y,
        i,
        r
      );
    } catch (l) {
      throw ha(l) && l.scFunction === "beginRayDrillSelection" ? new no() : l;
    }
    return new xc(o);
  }
  async beginConvexPolyhedronSelection(t, e, i) {
    const n = i, r = [];
    for (const h of t)
      r.push(h.getCoefficients());
    const o = [e.x, e.y, e.z];
    let l;
    try {
      l = await this._sc.beginConvexPolyhedronSelection(
        r,
        o,
        n,
        Me.Default
      );
    } catch (h) {
      throw ha(h) && h.scFunction === "beginConvexPolyhedronSelection" ? new no() : h;
    }
    return new xc(l);
  }
  async beginSphereSelection(t, e, i) {
    const n = i;
    let r;
    try {
      r = await this._sc.beginSphereSelection(
        Me.Default,
        t,
        e,
        n
      );
    } catch (o) {
      throw ha(o) && o.scFunction === "beginSphereSelection" ? new no() : o;
    }
    return new xc(r);
  }
  endIncrementalSelection(t) {
    this._incrementalChunkedItems.delete(t._handle), this._sc.endVolumeSelection(t._handle);
  }
  async advanceIncrementalSelection(t, e) {
    const i = this._incrementalChunkedItems.get(t._handle);
    if (i && i.length !== 0)
      return i.pop();
    let n;
    try {
      n = await this._sc.advanceVolumeSelection(
        t._handle,
        5e3
        /* Batch */
      );
    } catch (l) {
      throw ha(l) && l.scFunction === "advanceVolumeSelection" ? new no() : l;
    }
    if (n.length === 2 && n[1] === ag.Invalid)
      return e ? (await this._sc.setStreamIdleMarker(), this.advanceIncrementalSelection(t, !1)) : null;
    const r = [];
    for (let l = 0; l < n.length; l += 2) {
      const h = n[l], u = n[l + 1];
      r.push(_i.create(u, h));
    }
    if (r.length <= 500)
      return r;
    const o = sI(
      r,
      500
      /* Chunk */
    ).reverse();
    return this._incrementalChunkedItems.set(t._handle, o), o.pop();
  }
  async _screenSelectByRay(t, e, i, n, r) {
    const o = pf(i, n, r), l = i.selectionMask, u = i.selectionMask !== Se.Face || i.enableProximityFaces ? this._pickTolerance : -1;
    return this._sc.screenSelectByRay(t, l, e.x, e.y, u, o);
  }
  async _worldSelectByRay(t, e, i) {
    const n = pf(e, i, !1), r = Ku(t);
    return this._sc.worldSelectByRay(Me.Default, r, n);
  }
  async pickFromScreen(t, e, i, n) {
    const r = await this._screenSelectByRay(t, e, i, !0, n);
    return tm(r);
  }
  async pickAllFromScreen(t, e, i, n) {
    const r = await this._screenSelectByRay(t, e, i, !1, n);
    return im(r);
  }
  async compositePickFromScreen(t, e, i, n) {
    const r = await this._screenSelectByRay(t, e, i, !0, n);
    return em(r);
  }
  async pickFromRay(t, e) {
    const i = await this._worldSelectByRay(t, e, !0);
    return tm(i);
  }
  async pickAllFromRay(t, e) {
    const i = await this._worldSelectByRay(t, e, !1);
    return im(i);
  }
  async pickCompositeFromRay(t, e) {
    const i = pf(e, !0, !1), n = Ku(t), r = await this._sc.worldSelectByRay(Me.Default, n, i);
    return em(r);
  }
}
class lI {
  constructor(t, e) {
    this._viewIndices = /* @__PURE__ */ new Set([Me.Default]), this._windowSizes = /* @__PURE__ */ new Map(), this._engineReadyPromise = wi(), this._sessionStartedPromise = wi(), this._connectionlessEmpty = !1, this._uri = "ws://localhost:9999", this._streamingMode = Lo.Default, this._rendererType = lh.Client, this._meshLevel = 0, this._memoryLimit = 0, this._boundingPreviewMode = Po.All, this._streamCutoffScale = 1, this._loadFinished = !1, this._statistics = new Wy(), this._cachedTriangleCount = null, this._cachedElementCount = null, this._cuttingSectionToKeyMap = /* @__PURE__ */ new Map(), this._cappingQuantizationGranularity = -1e4, this._cappingFaceColor = vt.createFromFloat(0.5, 0.5, 0.5), this._cappingLineColor = vt.createFromFloat(0.5, 0.5, 0.5), this._cappingGeometryVisibility = !0, this._cappingNeedsUpdate = !0, this._cappingDelayTimeoutId = null, this._cappingDelay = 500, this._requestBatchCountByType = [], this._pendingRequestsByType = [], this._callbackManager = t, this._applyOptions(e);
    for (let i = 0; i < pc.Count; ++i)
      this._requestBatchCountByType.push(0), this._pendingRequestsByType.push([]);
  }
  async addView(t) {
    const e = await this._sc.addDrawContext();
    ro.setupNewView(this._sc, e, t), this._viewIndices.add(e), this._canvasContainers.set(e, t);
    const i = document.createElement("canvas");
    this._canvases.set(e, i);
    const n = i.getContext("2d");
    if (!n)
      throw new Error("Unable to create 2d context for canvas");
    return this._canvas2dContexts.set(e, n), i.setAttribute(
      "style",
      "position: absolute; top: 0; left: 0; width: 100%; height: 100%; padding: 0; margin: 0; border: 0;"
    ), i.style.display = "", t.appendChild(i), this.resize(e), e;
  }
  removeView(t) {
    this._viewIndices.delete(t), this._sc.removeDrawContext(t);
  }
  getNetworkModelName() {
    if (console.assert(this._sessionType === en.Network), this._model !== void 0)
      return this._model;
    throw new oi();
  }
  // Method inherited from AbstractScEngine.  Mainly used as an avenue for the AssemblyTree to log messages for debugging purposes.
  logMessage(t) {
    console.log(t);
  }
  // Method inherited from AbstractScEngine.  Used to abstract the setTimeout method as this method is not available in pure non browser based javascript environments, i.e. v8, JsCore.
  setTimeout(t, e) {
    return setTimeout(t, e);
  }
  // Method inherited from AbstractScEngine. The default Communicator implementation of this method makes use of setTimeout (see above).
  sleep(t) {
    return md(t);
  }
  getScsInfo() {
    return console.assert(this._sessionType === en.Scs), this._buffer !== void 0 ? this._buffer : /^wss?:\/\//i.test(this._uri) ? null : this._uri;
  }
  _applyOptions(t) {
    t.empty !== void 0 && (this._connectionlessEmpty = t.empty), t.endpointUri !== void 0 && (this._uri = t.endpointUri), t.model && (this._model = t.model), t.sessionToken !== void 0 && (this._sessionToken = t.sessionToken), t.buffer !== void 0 && (this._buffer = t.buffer), t.streamingMode !== void 0 && (this._streamingMode = t.streamingMode), t.rendererType !== void 0 && (this._rendererType = t.rendererType), t.defaultMeshLevel !== void 0 && (this._meshLevel = t.defaultMeshLevel), t.memoryLimit !== void 0 && (this._memoryLimit = t.memoryLimit), t.boundingPreviewMode !== void 0 && (this._boundingPreviewMode = t.boundingPreviewMode), t.streamCutoffScale !== void 0 && this._setStreamCutoffScale(t.streamCutoffScale);
  }
  start(t, e) {
    this._canvasContainers = /* @__PURE__ */ new Map(), this._canvasContainers.set(Me.Default, t), this._initOptions = e;
    const i = document.createElement("canvas");
    this._canvases = /* @__PURE__ */ new Map(), this._canvases.set(Me.Default, i);
    const n = i.getContext("2d");
    if (!n)
      throw new Error("Unable to create 2d context for canvas");
    return this._canvas2dContexts = /* @__PURE__ */ new Map(), this._canvas2dContexts.set(Me.Default, n), i.setAttribute(
      "style",
      "position: absolute; top: 0; left: 0; width: 100%; height: 100%; padding: 0; margin: 0; border: 0;"
    ), i.style.display = "", ro.createInstance({
      container: t,
      onReady: (r) => {
        t.appendChild(i), this._onEngineReady(r);
      },
      onError: (r) => {
        this._callbackManager.trigger(
          "modelLoadFailure",
          this._model || "",
          `failed to load engine: ${r}`
        );
      },
      enginePath: e.enginePath
    }), !0;
  }
  setPickTolerance(t) {
    this._scSelectionManager.setPickTolerance(t);
  }
  getPickTolerance() {
    return this._scSelectionManager.getPickTolerance();
  }
  _onEngineReady(t) {
    this._sc = t, this._sessionType = en.Uninitialized, this._matrixCache = new nI(this), this._scSelectionManager = new aI(this._sc), this._callbackManager.bind({
      _firstBoundingReady: async () => {
        for (const e of this._viewIndices)
          this._regenerateCapping(e);
      },
      _drawContextCreated: (e) => {
        this._sc.setDrawMode(e, dr.Highlight), this._sc.setHighlightedInstanceFilter(e, Or.Colorize), this._sc.setUnhighlightedFilter(e, Or.None), this._sc.setHighlightMode(e, Uu.VisibleWithFullOutline), this._sc.setAntiAliasingMode(e, ol.SMAA);
      }
    }), this._sc.setEventHandler("session_started", () => {
      const e = () => (this._callbackManager.unbind(i), this._sessionStartedPromise), i = {
        _sessionStarted: () => this._onSessionStarted(),
        _assemblyTreeReady: e,
        _modelSwitched: e
      };
      this._callbackManager.bind(i), this._sessionStartedPromise.resolve(
        this._callbackManager.promiseTrigger("_sessionStarted", null)
      );
    }), this._sc.setEventHandler(
      "announce_model",
      (e, i, n) => {
        this._callbackManager.trigger("_announceModel", i, n);
      }
    ), this._sc.setEventHandler("first_instance", () => {
      this._callbackManager.trigger("_firstInstance");
    }), this._sc.setEventHandler(
      "inclusion",
      (e, i, n, r) => {
        this._callbackManager.trigger("_inclusion", i, n, r);
      }
    ), this._sc.setEventHandler(
      "remap_model",
      (e, i, n, r) => {
        this._callbackManager.trigger(
          "_remapModel",
          i,
          n,
          r
        );
      }
    ), this._sc.setEventHandler(
      "remap_inclusion",
      (e, i, n, r, o) => {
        this._callbackManager.trigger(
          "_remapInclusion",
          i,
          n,
          r,
          o
        );
      }
    ), this._sc.setEventHandler(
      "capping_idle",
      (e, i, n) => {
        this._callbackManager.trigger("cappingIdle", i, n);
      }
    ), this._sc.setEventHandler("stream_active", this._initOptions.streamingActivated), this._sc.setEventHandler("stream_idle", this._initOptions.streamingDeactivated), this._sc.setEventHandler("open_model_failed", (e, i) => {
      let n;
      switch (i.reason) {
        case "UNKNOWN_MODEL":
          n = "Unknown model";
          break;
        case "BAD_NETWORK_VERSION":
          n = "Client/Server network version mismatch";
          break;
        case "BAD_STREAM_VERSION":
        case "BAD_STORE_VERSION":
          n = "Unsupported file version";
          break;
        default:
          n = "Internal Error";
      }
      this._callbackManager.trigger("modelLoadFailure", this._model || "", n);
    }), this._sc.setEventHandler(
      "missing_model",
      (e, i, n) => {
        this._callbackManager.trigger("_missingModel", i, n), this._callbackManager.trigger("missingModel", n);
      }
    ), this._sc.setEventHandler("bad_data", (e, i) => {
      let n;
      switch (i.type) {
        case "TRUNCATED_BLOCK":
          n = "Failed to parse truncated data block.";
          break;
        case "ZFRAME_DECOMPRESS_FAILED":
          n = "Failed to decompress data.";
          break;
        case "UNMATCHED_CODE":
          n = "Unknown opcode.";
          break;
        case "STORE_VERSION_MISMATCHED":
          n = "Store version mismatched.", n += ` Expected='${i.expected}'.`, n += ` Actual='${i.actual}'.`;
          break;
        case "STREAM_VERSION_MISMATCHED":
          n = "Stream version mismatched.", n += ` Expected='${i.expected}'.`, n += ` Actual='${i.actual}'.`;
          break;
        case "PARSE_BOUNDING_TREE_FAILED":
          n = "Failed to parse bounding ";
          break;
        default:
          n = "Unknown error.";
      }
      this._callbackManager.trigger("modelLoadFailure", this._model || "", n);
    }), this._sc.setEventHandler("socket_open_failed", () => {
      this._callbackManager.trigger(
        "modelLoadFailure",
        this._model || "",
        "WebSocket connection failed."
      );
    }), this._sc.setEventHandler(
      "post_draw",
      (e, i, n, r, o) => {
        const l = this._canvases.get(i), h = this._canvas2dContexts.get(i);
        h.clearRect(0, 0, l.width, l.height);
        const u = this._sc.canvas.height - l.height, d = l.width, g = l.height;
        h.drawImage(
          this._sc.canvas,
          0,
          u,
          // source offset 
          d,
          g,
          // source dimensions
          0,
          0,
          // destination offset
          d,
          g
          // destination dimensions
        ), this._statistics = n, this._initOptions.renderComplete(), this._fillStatTotalCounts();
        const y = this._fromScCamera(r);
        this._callbackManager.trigger("frameDrawn", y, o, i);
      }
    ), this._sc.setEventHandler(
      "priority_meta_data_sent",
      (e, i, n) => {
        this._initOptions.priorityMetaDataSent(i, n);
      }
    ), this._sc.setEventHandler(
      "meta_data",
      (e, i, n, r) => {
        i < 0 && (i += 4294967296), this._callbackManager.trigger("_metaData", i, n, r);
      }
    ), this._sc.setEventHandler("draw_complete", (e, i) => {
      this._callbackManager.trigger("_drawComplete", i);
    }), this._sc.setEventHandler("webgl_context_lost", () => {
      this._callbackManager.trigger("webGlContextLost");
    }), this._sc.setEventHandler("websocket_connection_closed", () => {
      this._callbackManager.trigger("websocketConnectionClosed");
    }), this._initOptions.engineReady(this._sessionStartedPromise), this._engineReadyPromise.resolve();
  }
  loadFinished() {
    return this._loadFinished;
  }
  resetCachedStatistics() {
    this._cachedElementCount = null, this._cachedTriangleCount = null;
  }
  setAmbientOcclusionEnabled(t, e) {
    this._sc.setAmbientOcclusionEnabled(t, e);
  }
  setAmbientOcclusionRadius(t, e) {
    this._sc.setAmbientOcclusionRadius(t, e);
  }
  setLightingEnabled(t, e) {
    this._sc.setLightingEnabled(t, e);
  }
  _fillStatTotalCounts() {
    this._cachedElementCount !== null && this._cachedTriangleCount !== null && (this._statistics.total_element_count = this._cachedElementCount, this._statistics.total_triangle_count = this._cachedTriangleCount);
  }
  async _updateCachedStats() {
    const t = this._sc.getElementCount(), e = this._sc.getTriangleCount(), i = await Promise.all([t, e]);
    this._cachedElementCount = i[0], this._cachedTriangleCount = i[1], this._fillStatTotalCounts();
  }
  _toVector3(t) {
    return t.toArray();
  }
  startExplode(t, e) {
    this.delayCapping(), this._sc.startExplode(t, this._toVector3(e));
  }
  setExplodeMagnitude(t) {
    this._callbackManager.trigger("explode", t), this.delayCapping(), this._sc.explode(t);
  }
  stopExplode() {
    this.delayCapping(), this._sc.resetExplode();
  }
  async getStatistics(t = !1) {
    return t && !this.loadFinished() ? (await this._updateCachedStats(), this._fillStatTotalCounts(), this._statistics) : this.loadFinished() && this._cachedTriangleCount === null ? (await this._updateCachedStats(), this._fillStatTotalCounts(), this._statistics) : (this._fillStatTotalCounts(), this._statistics);
  }
  setStreamIdleMarker() {
    return this._sc.setStreamIdleMarker();
  }
  hasDepthRange(t) {
    return this._sc.MeshInstance.hasDepthRange(t);
  }
  setDepthRange(t, e, i) {
    this._sc.MeshInstance.setDepthRange(t, e, i);
  }
  unsetDepthRange(t) {
    this._sc.MeshInstance.unsetDepthRange(t);
  }
  setDefaultDepthRange(t, e, i) {
    this._sc.setDefaultDepthRange(t, e, i);
  }
  _getScPlaneArray(t) {
    const e = [];
    for (let i = 0; i < t.getCount(); i++) {
      const n = t.getPlane(i);
      if (n === null)
        continue;
      const r = [];
      n.normal.toArray(r), r[3] = n.d, e.push(r);
    }
    return e;
  }
  getCuttingSectionLimits() {
    return this._sc.cuttingSectionLimits();
  }
  async _addCuttingSection(t, e) {
    let i = rl.Invalid;
    const n = this._getScPlaneArray(t);
    if (n.length > 0 && (i = await this._sc.addCuttingSection(n), i === rl.Invalid)) {
      const r = e === gc.Add ? "add" : "update";
      throw new oe(`Failed to ${r} cutting section.`);
    }
    this._cuttingSectionToKeyMap.set(t, i), e === gc.Add && this._callbackManager.trigger("addCuttingSection", t);
  }
  addCuttingSection(t) {
    return this._addCuttingSection(t, gc.Add);
  }
  async removeCuttingSection(t) {
    const e = this._cuttingSectionToKeyMap.get(t);
    if (e === void 0) {
      console.assert(!1);
      return;
    }
    if (this._cuttingSectionToKeyMap.delete(t), this._callbackManager.trigger("removeCuttingSection"), e !== rl.Invalid)
      return this._sc.removeCuttingSections([e]);
  }
  removeAllCuttingSections() {
    return this._cuttingSectionToKeyMap.clear(), this._callbackManager.trigger("removeCuttingSection"), this._sc.removeAllCuttingSections();
  }
  async updateCuttingSection(t) {
    const e = this._cuttingSectionToKeyMap.get(t);
    if (e === void 0) {
      console.assert(!1);
      return;
    }
    if (e === rl.Invalid)
      return this._addCuttingSection(t, gc.Update);
    const i = this._getScPlaneArray(t);
    return this._sc.replaceCuttingSection(i, e);
  }
  setCappingDelay(t) {
    this._cappingDelay = t;
  }
  enableCappingIdleCallback(t) {
    return this._sc.setCappingIdleHookEnabled(t);
  }
  getCappedInstances() {
    return this._sc.getCappedInstances();
  }
  delayCapping() {
    this._cappingDelayTimeoutId === null ? this._sc.pauseCapping() : clearTimeout(this._cappingDelayTimeoutId), this._cappingDelayTimeoutId = setTimeout(() => {
      this._cappingDelayTimeoutId = null, this._sc.resumeCapping();
    }, this._cappingDelay);
  }
  setCappingGeometryVisibility(t, e) {
    if (!(this._cappingGeometryVisibility === e && !this._cappingNeedsUpdate))
      if (this._cappingDelayTimeoutId !== null && (clearTimeout(this._cappingDelayTimeoutId), this._cappingDelayTimeoutId = null), this._cappingNeedsUpdate = !1, this._cappingGeometryVisibility = e, e) {
        const i = this._cappingLineColor !== null ? this._toRgba(this._cappingLineColor, 1) : [-1, -1, -1, -1], n = this._cappingFaceColor !== null ? this._toRgba(this._cappingFaceColor, 1) : [-1, -1, -1, -1];
        this._sc.enableCapping(t, i, n, this._cappingQuantizationGranularity);
      } else
        this._sc.disableCapping(t);
  }
  _regenerateCapping(t) {
    this._cappingNeedsUpdate = !0, this.setCappingGeometryVisibility(t, this._cappingGeometryVisibility);
  }
  getCappingGeometryVisibility() {
    return this._cappingGeometryVisibility;
  }
  _toRgb(t) {
    return t.toFloatArray();
  }
  _toRgba(t, e) {
    return t.toFloatArray([0, 0, 0, e]);
  }
  setCappingFaceColor(t) {
    if (!(t === null && this._cappingFaceColor === null || t !== null && this._cappingFaceColor !== null && t.equals(this._cappingFaceColor))) {
      t !== null ? this._cappingFaceColor = t.copy() : this._cappingFaceColor = null;
      for (const e of this._viewIndices)
        this._regenerateCapping(e);
    }
  }
  setCappingLineColor(t) {
    if (!(t === null && this._cappingLineColor === null || t !== null && this._cappingLineColor !== null && t.equals(this._cappingLineColor))) {
      t !== null ? this._cappingLineColor = t.copy() : this._cappingLineColor = null;
      for (const e of this._viewIndices)
        this._regenerateCapping(e);
    }
  }
  async _onSessionStarted() {
    this.setAllowHighDpi(!0), this._sc.suspendDrawing(Me.Default), this._sc.setDrawMode(Me.Default, dr.Highlight), this._sc.setHighlightedInstanceFilter(Me.Default, Or.Colorize), this._sc.setUnhighlightedFilter(Me.Default, Or.None), this._sc.setHighlightMode(Me.Default, Uu.VisibleWithFullOutline), this._sc.setAntiAliasingMode(Me.Default, ol.SMAA);
    const t = [];
    t.push(this._matrixCache.init()), this._regenerateCapping(Me.Default), await Promise.all(t), this._initOptions.sceneReady(), this._sc.resumeDrawing(Me.Default);
  }
  isInit() {
    return this._sc !== void 0;
  }
  setRemoteEndpoint(t, e) {
    this._uri = t, this._model = e;
  }
  getSessionType() {
    return this._sessionType;
  }
  _awaitEmptyLoad() {
    const t = wi(), e = {
      _attached: (i) => {
        this._callbackManager.unbind(e), i === Ia.OfInitialEmptyModel ? t.resolve() : t.reject(new oi());
      }
    };
    return this._callbackManager.bind(e), t;
  }
  async loadEmpty() {
    await this._engineReadyPromise;
    try {
      if (this._sessionType !== en.Uninitialized)
        throw new qr("Incompatible load types.");
      const t = this._awaitEmptyLoad();
      return this._connectionlessEmpty || this._buffer !== void 0 || this._model === void 0 ? this._sessionType = this._loadEmptyScs() : this._sessionType = this._loadEmptyNetwork(), t;
    } catch (t) {
      throw this._callbackManager.trigger("modelLoadFailure", this._model || "", t.message), t;
    }
  }
  _loadEmpty(t) {
    return console.assert(t.XHRonprogress === void 0), console.assert(t.XHRonerror === void 0), console.assert(t.XHRonloadend === void 0), t.XHRonprogress = (e) => {
      this._callbackManager.trigger("XHRonprogress", e);
    }, t.XHRonerror = (e) => {
      this._callbackManager.trigger("XHRonerror", e);
    }, t.XHRonloadend = (e, i, n) => {
      this._callbackManager.trigger("XHRonloadend", e, i, n);
    }, this._sc.load(t);
  }
  _loadEmptyScs() {
    console.assert(this._model === void 0);
    const t = {
      empty: !0
    };
    return this._streamingMode === Lo.OnDemand && (t.streamInstancesOnDemand = !0), this._loadEmpty(t);
  }
  _loadEmptyNetwork() {
    console.assert(this._model !== void 0);
    const t = {
      model: ba,
      uri: this._uri,
      serverSideRendering: this._rendererType === lh.Server,
      meshLevel: this._meshLevel,
      streamCutoffScale: this._streamCutoffScale
    };
    switch (this._sessionToken !== void 0 && (t.sessionToken = this._sessionToken), this._memoryLimit > 0 && (t.limitMiB = this._memoryLimit), (this._boundingPreviewMode & Po.Model) === Po.Model && (t.streamModelBoundingPreviews = !0), (this._boundingPreviewMode & Po.Instance) === Po.Instance && (t.streamInstanceBoundingPreviews = !0), (this._boundingPreviewMode & Po.Ejected) === Po.Ejected && (t.streamEjectedBoundingPreviews = !0), this._streamingMode) {
      case Lo.OnDemand:
        t.streamInstancesOnDemand = !0;
        break;
      case Lo.All:
        t.streamCulled = !0, t.streamMetaDataOnIdle = !0;
        break;
    }
    return this._loadEmpty(t);
  }
  setProjection(t, e) {
    const i = this.getCamera(t);
    i.getProjection() !== e && (i.setProjection(e), this.setCamera(t, i));
  }
  getViewMatrix(t) {
    const e = this._toCamera(Me.Default, t);
    return mt.createFromArray(e.viewMatrix());
  }
  getProjectionMatrix(t, e) {
    const i = this._toCamera(e, t), n = this._windowSizes.get(e);
    if (n === void 0)
      throw new oe("Getting projection matrix of non-existent view");
    return mt.createFromArray(i.projectionMatrix(n.x, n.y));
  }
  getFullCameraMatrix(t, e) {
    const i = this._toCamera(e, t), n = this._windowSizes.get(e);
    if (n === void 0)
      throw new oe("Getting full matrix of non-existent view");
    return mt.createFromArray(i.fullMatrix(n.x, n.y));
  }
  getPrimaryModelKey() {
    return this._sc.primaryModelKey();
  }
  getPartsBounding(t, e, i) {
    return this.getBounding(t, e, !1, i);
  }
  async getDrawnPartsBounding(t, e) {
    const i = await this._sc.MeshInstance.getDrawnWorldSpaceBounding(t, e), n = new yn();
    return n.min.fromArray(i.min), n.max.fromArray(i.max), n;
  }
  async getBounding(t, e, i, n) {
    const r = await this._sc.MeshInstance.getWorldSpaceBounding(
      t,
      e,
      i,
      n
    ), o = new yn();
    return o.min.fromArray(r.min), o.max.fromArray(r.max), o;
  }
  async getLooseBounding() {
    const t = await this._sc.getLooseBounding(), e = new yn();
    return e.min.fromArray(t.min), e.max.fromArray(t.max), e;
  }
  getClientDimensions(t) {
    const e = this._sc.containers.get(t);
    return [e.clientWidth, e.clientHeight];
  }
  async getModelBounding(t, e, i) {
    return this.getBounding([], t, e, i);
  }
  async pickFromScreen(t, e, i, n) {
    return this._scSelectionManager.pickFromScreen(t, e, i, n);
  }
  async pickAllFromScreen(t, e, i, n) {
    return this._scSelectionManager.pickAllFromScreen(t, e, i, n);
  }
  async compositePickFromScreen(t, e, i, n) {
    return this._scSelectionManager.compositePickFromScreen(t, e, i, n);
  }
  async beginScreenAreaSelection(t, e, i, n) {
    return this._scSelectionManager.beginScreenAreaSelection(
      t,
      e,
      i,
      n
    );
  }
  async beginRayDrillSelection(t, e, i, n) {
    return this._scSelectionManager.beginRayDrillSelection(
      t,
      e,
      i,
      n
    );
  }
  async beginConvexPolyhedronSelection(t, e, i) {
    return this._scSelectionManager.beginConvexPolyhedronSelection(
      t,
      e,
      i
    );
  }
  async beginSphereSelection(t, e, i) {
    return this._scSelectionManager.beginSphereSelection(t, e, i);
  }
  endIncrementalSelection(t) {
    this._scSelectionManager.endIncrementalSelection(t);
  }
  async advanceIncrementalSelection(t) {
    return this._scSelectionManager.advanceIncrementalSelection(t, !1);
  }
  flushMetaDataCache() {
    this._sc.flushMetaDataCache();
  }
  async safeGetMetaDatas(t, e) {
    const i = [];
    for (const n of e)
      i.push(t, n);
    try {
      return await this.getDataFromIds(i);
    } catch {
      return null;
    }
  }
  async safeGetMetaData(t, e) {
    const i = await this.safeGetMetaDatas(t, [e]);
    return i !== null ? i[0] : null;
  }
  async safeLoadMetaDatas(t) {
    await this.getDataFromIds(t);
  }
  getDataFromIds(t) {
    if (this._requestBatchCountByType[pc.MetaData] === 0)
      return this._getDataFromIds(t);
    const e = new kv(t);
    return this._pendingRequestsByType[pc.MetaData].push(e), e.promise;
  }
  _getDataFromIds(t) {
    return this._sc.getMetaData(t);
  }
  pickFromRay(t, e) {
    return this._scSelectionManager.pickFromRay(t, e);
  }
  pickAllFromRay(t, e) {
    return this._scSelectionManager.pickAllFromRay(t, e);
  }
  updateCamera(t, e) {
    const i = e._getFlags(), n = this._sc.getCamera(t);
    return (i & Jn.Position) === Jn.Position && n.setPosition(this._toVector3(e.getPosition())), (i & Jn.Target) === Jn.Target && n.setTarget(this._toVector3(e.getTarget())), (i & Jn.Up) === Jn.Up && n.setUpVector(this._toVector3(e.getUp())), this._setCamera(t, n), this.getCamera(t);
  }
  _toProjection(t) {
    switch (t) {
      default:
      case ri.Orthographic:
        return Jc.Orthographic;
      case ri.Perspective:
        return Jc.Perspective;
    }
  }
  _toCamera(t, e) {
    const i = this._sc.getCamera(t);
    return i.reset(
      this._toProjection(e.getProjection()),
      this._toVector3(e.getPosition()),
      this._toVector3(e.getTarget()),
      this._toVector3(e.getUp()),
      e.getWidth(),
      e.getHeight()
    ), i.setNearLimit(e.getNearLimit()), i;
  }
  setCamera(t, e) {
    const i = this._toCamera(t, e);
    this._setCamera(t, i);
  }
  _setCamera(t, e) {
    this.delayCapping(), this._sc.setCamera(t, e);
  }
  markCameraAsEmpty(t) {
    this._sc.markCameraAsEmpty(t);
  }
  setInstancesMatrix(t, e) {
    this._sc.MeshInstance.setAnonymousMatrix(t, e.m);
  }
  // This implementation attempts to reduce saturation when setting large quantities of matrices in SSR (i.e. Animation System)
  // A single message containing all new matrix values is sent via setAnonymousMatrices as opposed to individual messages via setAnonymousMatrix
  setMatrices(t, e) {
    const i = [];
    for (let n = 0; n < e.length; n++)
      i.push(...e[n].m);
    this._sc.MeshInstance.setAnonymousMatrices(t, i);
  }
  highlightParts(t, e) {
    this._sc.MeshInstance.setHighlighted(t, e), this._sc.MeshInstance.setXRay(t, e);
  }
  highlightElements(t, e, i, n, r) {
    const o = this._toElementType(e);
    this._sc.MeshInstance.setElementHighlighted(
      t,
      o,
      i,
      n,
      r
    ), this._sc.MeshInstance.setElementXRay(t, o, i, n, r);
  }
  getPartHighlighted(t) {
    return this._sc.MeshInstance.getHighlighted(t);
  }
  getElementHighlighted(t, e, i) {
    return this._sc.MeshInstance.getElementHighlighted(
      t,
      this._toElementType(e),
      i
    );
  }
  setNodeHighlightColor(t, e, i) {
    let n;
    e ? (this._sc.setHighlightedInstanceFilter(t, Or.Colorize), n = this._toRgba(e, 1), this._sc.setHiddenLineHighlightedInstanceFillColor(t, n), this._sc.setHighlightedInstanceColor(t, n)) : this._sc.setHighlightedInstanceFilter(t, Or.None), i ? n = this._toRgba(i, 1) : n = [0, 0, 0, 0], this._sc.setHiddenLineHighlightedInstanceOutlineColor(t, n), this._sc.setHighlightedInstanceOutlineColor(t, n);
  }
  setElementHighlightColor(t, e, i) {
    let n;
    e ? (this._sc.setHighlightedElementFilter(t, Or.Colorize), n = this._toRgba(e, 1), this._sc.setHighlightedElementColor(t, n), this._sc.setHiddenLineHighlightedElementFillColor(t, n)) : this._sc.setHighlightedElementFilter(t, Or.None), i ? n = this._toRgba(i, 1) : n = [0, 0, 0, 0], this._sc.setHighlightedElementOutlineColor(t, n), this._sc.setHiddenLineHighlightedElementOutlineColor(t, n);
  }
  setHighlightColorizeCompression(t, e) {
    this._sc.setHighlightColorizeCompression(t, e);
  }
  async computeMinimumBodyBodyDistance(t, e) {
    if (t.length !== 2 || e.length !== 2)
      throw new oe("Invalid instance inc.");
    const i = await this._sc.MeshInstance.computeMinimalBodyBodyDistance(
      Me.Default,
      t,
      e
    );
    return gu(i);
  }
  async computeMininimumFaceFaceDistance(t, e, i, n) {
    if (t.length !== 2 || i.length !== 2)
      throw new oe("Invalid instance inc.");
    const r = await this._sc.MeshInstance.computeMinimalFaceFaceDistance(
      Me.Default,
      t,
      e,
      i,
      n
    );
    return gu(r);
  }
  async computeMinimumFaceRayDistance(t, e, i) {
    if (t.length !== 2)
      throw new oe("Invalid instance inc.");
    const n = Ku(i), r = await this._sc.MeshInstance.computeMinimalFaceRayDistance(
      Me.Default,
      t,
      e,
      n
    );
    return gu(r);
  }
  async computeMinimumFaceLineDistance(t, e, i) {
    if (t.length !== 2)
      throw new oe("Invalid instance inc.");
    const n = Ku(i), r = await this._sc.MeshInstance.computeMinimalFaceLineDistance(
      Me.Default,
      t,
      e,
      n
    );
    return gu(r);
  }
  pauseRendering(t, e) {
    if (this._sc.suspendDrawing(t), typeof e == "function")
      try {
        e();
      } finally {
        this._sc.resumeDrawing(t);
      }
  }
  pauseAllRendering(t) {
    for (const e of this._viewIndices)
      this._sc.suspendDrawing(e);
    if (typeof t == "function")
      try {
        t();
      } finally {
        for (const e of this._viewIndices)
          this._sc.resumeDrawing(e);
      }
  }
  resumeRendering(t) {
    this._sc.resumeDrawing(t);
  }
  resumeAllRendering() {
    for (const t of this._viewIndices)
      this._sc.resumeDrawing(t);
  }
  beginRequestBatch(t) {
    ++this._requestBatchCountByType[t];
  }
  endRequestBatch(t) {
    this._requestBatchCountByType[t] > 0 && --this._requestBatchCountByType[t], this._flushBatchedRequests(t);
  }
  _flushBatchedRequests(t) {
    const e = this._pendingRequestsByType[t];
    this._pendingRequestsByType[t] = [];
    const i = [];
    for (const n of e)
      for (const r of n.ids)
        i.push(r);
    switch (t) {
      case pc.MetaData:
        return this._flushBatchedMetaDataRequests(e, i);
      default:
        return console.assert(!1), Promise.resolve();
    }
  }
  async _flushBatchedMetaDataRequests(t, e) {
    const i = await this._getDataFromIds(e);
    let n = 0;
    for (const r of t) {
      const o = [], l = r.ids.length / 2;
      for (let h = 0; h < l; ++h) {
        const u = i[n++];
        o.push(u);
      }
      r.promise.resolve(o);
    }
    console.assert(n === i.length);
  }
  clearHighlight() {
    this._sc.unsetAllHighlighted(), this._sc.unsetAllXRay();
  }
  resetColors() {
    this._sc.unsetAllColors();
  }
  resetOpacity() {
    this._sc.unsetAllOpacity();
  }
  setPartOpacity(t, e) {
    this.pauseAllRendering(() => {
      this._sc.MeshInstance.setOpacity(t, an.Faces, e), this._sc.MeshInstance.setOpacity(t, an.Lines, e), this._sc.MeshInstance.setOpacity(t, an.Points, e);
    });
  }
  unsetPartOpacity(t) {
    this.pauseAllRendering(() => {
      this._sc.MeshInstance.unsetOpacity(t, an.Faces), this._sc.MeshInstance.unsetOpacity(t, an.Lines), this._sc.MeshInstance.unsetOpacity(t, an.Points);
    });
  }
  getPartOpacity(t) {
    return this._sc.MeshInstance.getOpacity(t, an.Faces);
  }
  getEffectivePartOpacity(t, e) {
    return this._sc.MeshInstance.getEffectiveOpacity(t, this._toElementType(e));
  }
  async getPartHasTransparency(t) {
    const e = [];
    e.push(this._sc.MeshInstance.hasTransparency(t, an.Faces)), e.push(this._sc.MeshInstance.hasTransparency(t, an.Lines)), e.push(this._sc.MeshInstance.hasTransparency(t, an.Points));
    const [i, n, r] = await Promise.all(e);
    for (let o = 0; o < i.length; ++o)
      i[o] || (i[o] = n[o] || r[o]);
    return i;
  }
  setPartColor(t, e, i) {
    this._sc.MeshInstance.setColor(t, this._toElementType(e), An.Base, i.getFloatArray());
  }
  unsetPartColor(t, e) {
    this._sc.MeshInstance.unsetColor(t, this._toElementType(e), An.Base);
  }
  getPartColor(t, e) {
    return this._sc.MeshInstance.getColor(t, this._toElementType(e), An.Base).then(
      (i) => i.map((n) => n ? vt.createFromFloatArray(n) : null)
    );
  }
  async getEffectivePartColor(t, e) {
    const i = this._toElementType(e);
    return (await this._sc.MeshInstance.getEffectiveColor(t, i, An.Base)).map(vt.createFromFloatArray);
  }
  setPartAmbientColor(t, e, i) {
    this._sc.MeshInstance.setColor(
      t,
      this._toElementType(e),
      An.Ambient,
      i.getFloatArray()
    );
  }
  unsetPartAmbientColor(t, e) {
    this._sc.MeshInstance.unsetColor(t, this._toElementType(e), An.Ambient);
  }
  getPartAmbientColor(t, e) {
    return this._sc.MeshInstance.getColor(t, this._toElementType(e), An.Ambient).then(
      (i) => i.map((n) => n ? vt.createFromFloatArray(n) : null)
    );
  }
  getPartEffectiveAmbientColor(t, e) {
    return this._sc.MeshInstance.getEffectiveColor(t, this._toElementType(e), An.Ambient).then(
      (i) => i.map((n) => vt.createFromFloatArray(n))
    );
  }
  setPartAmbientMix(t, e, i) {
    this._sc.MeshInstance.setAmbientMix(t, this._toElementType(e), i);
  }
  setPartEmissiveColor(t, e, i) {
    this._sc.MeshInstance.setColor(
      t,
      this._toElementType(e),
      An.Emissive,
      i.getFloatArray()
    );
  }
  getPartEmissiveColor(t, e) {
    return this._sc.MeshInstance.getColor(t, this._toElementType(e), An.Emissive).then(
      (i) => i.map((n) => n ? vt.createFromFloatArray(n) : null)
    );
  }
  getPartEffectiveEmissiveColor(t, e) {
    return this._sc.MeshInstance.getEffectiveColor(t, this._toElementType(e), An.Emissive).then(
      (i) => i.map((n) => vt.createFromFloatArray(n))
    );
  }
  unsetPartEmissiveColor(t, e) {
    this._sc.MeshInstance.unsetColor(t, this._toElementType(e), An.Emissive);
  }
  setPartSpecularColor(t, e, i) {
    this._sc.MeshInstance.setColor(
      t,
      this._toElementType(e),
      An.Specular,
      i.getFloatArray()
    );
  }
  getPartSpecularColor(t, e) {
    return this._sc.MeshInstance.getColor(t, this._toElementType(e), An.Specular).then(
      (i) => i.map((n) => n ? vt.createFromFloatArray(n) : null)
    );
  }
  getPartEffectiveSpecularColor(t, e) {
    return this._sc.MeshInstance.getEffectiveColor(t, this._toElementType(e), An.Specular).then(
      (i) => i.map((n) => vt.createFromFloatArray(n))
    );
  }
  unsetPartSpecularColor(t, e) {
    this._sc.MeshInstance.unsetColor(t, this._toElementType(e), An.Specular);
  }
  setPartSpecularIntensity(t, e, i) {
    this._sc.MeshInstance.setSpecularIntensity(t, this._toElementType(e), i);
  }
  unsetPartSpecularIntensity(t, e) {
    this._sc.MeshInstance.unsetSpecularIntensity(t, this._toElementType(e));
  }
  setElementColor(t, e, i, n, r) {
    this._sc.MeshInstance.setElementColor(
      t,
      this._toElementType(e),
      i,
      n,
      r.getFloatArray()
    );
  }
  unsetElementColor(t, e, i, n) {
    this._sc.MeshInstance.unsetElementColor(
      t,
      this._toElementType(e),
      i,
      n
    );
  }
  getElementColor(t, e, i) {
    return this._sc.MeshInstance.getElementColor(
      t,
      this._toElementType(e),
      i
    ).then((n) => n.map((r) => r ? vt.createFromFloatArray(r) : null));
  }
  async getEffectiveElementColor(t, e, i, n) {
    const r = this._toElementType(e);
    return (await this._sc.MeshInstance.getEffectiveElementColor(
      t,
      n,
      r,
      i
    )).map(vt.createFromFloatArray);
  }
  synchronizeVisibilities(t, e) {
    t.length > 0 && this._sc.MeshInstance.synchronizeVisibilities(t, e);
  }
  setPartVisibility(t, e, i) {
    t.length > 0 && this._sc.MeshInstance.setVisible(t, e, i);
  }
  setElementVisibility(t, e, i, n, r) {
    t.length > 0 && this._sc.MeshInstance.setElementVisible(
      t,
      this._toElementType(e),
      i,
      n,
      r
    );
  }
  clearElementVisibility(t, e) {
    t.length > 0 && this._sc.MeshInstance.clearElementVisible(t, this._toElementType(e));
  }
  setVisibilityByAttachment(t, e) {
    this._sc.setVisibilityByAttachment(t, e);
  }
  requestMeshInstances(t) {
    this._sc.demandMeshInstances(t);
  }
  getRendererType() {
    return this._rendererType;
  }
  _toMeshDataBuilder(t) {
    const e = t._getFaceData(), i = t._getPointData(), n = t._getPolylineData(), r = new this._sc.MeshDataBuilder();
    for (const d of e)
      r.addFace(d.vertexData, {
        normals: d.normalData,
        rgba32s: d.rgba32data,
        uvs: d.uvData,
        bits: d.bits
      });
    for (const d of i)
      r.addPoints(d.vertexData, {
        rgba32s: d.rgba32data,
        bits: d.bits
      });
    for (const d of n)
      r.addPolyline(d.vertexData, {
        rgba32s: d.rgba32data,
        bits: d.bits
      });
    let o;
    ((d) => {
      d[d.None = 0] = "None", d[d.ClockwiseWinding = 1] = "ClockwiseWinding", d[d.CounterClockwiseWinding = 2] = "CounterClockwiseWinding", d[d.TwoSided = 4] = "TwoSided", d[d.Manifold = 65536] = "Manifold";
    })(o || (o = {}));
    let l = 0;
    switch (t.getFaceWinding()) {
      case Zs.Clockwise:
        l = 1;
        break;
      case Zs.CounterClockwise:
        l = 2;
        break;
      case Zs.Unknown:
      default:
        l = 0;
        break;
    }
    const h = t.getBackfacesEnabled() ? 4 : 0, u = t.isManifold() ? 65536 : 0;
    return r.formatBits |= l | h | u, r;
  }
  createMesh(t) {
    const e = this._toMeshDataBuilder(t);
    return this._sc.MeshData.create(e);
  }
  replaceMesh(t, e) {
    const i = this._toMeshDataBuilder(e);
    return this._sc.MeshData.replace(t, i);
  }
  destroyMeshes(t) {
    return this._sc.MeshData.destroy(t);
  }
  _toImageFormat(t) {
    switch (t) {
      case _s.Gray8:
        return ko.Gray8;
      case _s.GrayAlpha16:
        return ko.GrayAlpha16;
      case _s.Rgb24:
        return ko.Rgb24;
      case _s.Rgba32:
        return ko.Rgba32;
      case _s.Jpeg:
        return ko.Jpeg;
      case _s.Png:
        return ko.Png;
    }
  }
  _validateImage(t) {
    if (t.format === void 0)
      throw new Rs("missing 'format' property");
    if (t.data === void 0)
      throw new Rs("missing 'data' property");
    if ((t.format === _s.Gray8 || t.format === _s.GrayAlpha16 || t.format === _s.Rgb24 || t.format === _s.Rgba32) && (t.width === void 0 || t.width <= 0 || t.height === void 0 || t.height <= 0))
      throw new Rs("uncompressed format requested but missing width or height");
  }
  async _pngImageHasAlpha(t) {
    let e;
    try {
      e = await new Promise((l, h) => {
        const u = new Image();
        u.onload = () => {
          l(u);
        }, u.onerror = () => {
          h();
        }, u.src = `data:image/png;base64, ${wv(t)}`;
      });
    } catch {
      return console.warn(
        "Unable to read PNG image to check alpha component. Will be considered with alpha."
      ), !0;
    }
    const i = document.createElement("canvas"), n = i.getContext("2d");
    if (n === null)
      return console.warn(
        "Unable to create 2d context to check alpha component. Will be considered with alpha."
      ), !0;
    i.width = e.width, i.height = e.height, n.drawImage(e, 0, 0);
    const o = n.getImageData(0, 0, e.width, e.height).data;
    for (let l = 0; l < o.length; l += 4)
      if (o[l + 3] < 255)
        return !0;
    return !1;
  }
  async createImage(t, e) {
    this._validateImage(t);
    let i = !1;
    if (t.format === _s.Png && (i = await this._pngImageHasAlpha(t.data)), e !== void 0) {
      this._validateImage(e);
      let n = !1;
      return e.format === _s.Png && (n = await this._pngImageHasAlpha(e.data)), this._sc.Image.create(
        this._toImageFormat(t.format),
        t.data,
        i,
        t.width,
        t.height,
        this._toImageFormat(e.format),
        e.data,
        n,
        e.width,
        e.height
      );
    } else
      return this._sc.Image.create(
        this._toImageFormat(t.format),
        t.data,
        i,
        t.width,
        t.height
      );
  }
  destroyImages(t) {
    return this._sc.Image.destroy(t);
  }
  _toTextureTiling(t) {
    switch (t) {
      default:
      case Ff.Repeat:
        return $u.Repeat;
      case Ff.Clamp:
        return $u.Clamp;
    }
  }
  _toTextureInterpolation(t) {
    return t === !1 ? ju.Off : ju.On;
  }
  _toTextureMipMapping(t) {
    return t === !1 ? Wu.Off : Wu.On;
  }
  _toTextureParameterization(t) {
    switch (t) {
      default:
      case Gu.UV:
        return Gu.UV;
    }
  }
  _toTextureModifier(t) {
    switch (t) {
      default:
      case 0:
        return Mc.None;
      case Mc.Decal:
        return Mc.Decal;
    }
  }
  async setTexture(t, e) {
    if (e.imageId === void 0)
      throw new Rs("missing 'imageId' property");
    return this._sc.MeshInstance.setTexture(
      t,
      an.Faces,
      e.imageId,
      e.matrix !== void 0 ? e.matrix.m : new mt().m,
      this._toTextureTiling(e.tiling),
      this._toTextureInterpolation(e.interpolation),
      this._toTextureMipMapping(e.mipMapping),
      this._toTextureParameterization(e.parameterization),
      this._toTextureModifier(e.modifiers)
    );
  }
  unsetTexture(t) {
    this._sc.MeshInstance.unsetTexture(t, an.Faces);
  }
  createMatrix(t) {
    return this._sc.Matrix.create(t);
  }
  createIdentityMatrix() {
    return this._sc.Matrix.create();
  }
  async createMeshInstance(t) {
    const e = t.getMeshId();
    if (e === null)
      throw new oe("MeshId is not set");
    let i = this._matrixCache.getIdentityInc();
    const n = [], r = t.getMatrix();
    if (r) {
      const g = this.createMatrix(r.m).then((y) => {
        i = y;
      });
      n.push(g);
    }
    const o = new vt(255, 0, 0), l = this._toRgba(
      t.getFaceColor() || o,
      t.getOpacity()
    ), h = this._toRgba(
      t.getLineColor() || o,
      t.getLineOpacity()
    ), u = this._toRgba(
      t.getPointColor() || o,
      t.getPointOpacity()
    );
    await Promise.all(n);
    const d = await this._sc.MeshInstance.create(
      e,
      i,
      l,
      h,
      u,
      t.getCreationFlags(),
      t.overlayId.overayIndex,
      t.overlayId.viewKey
    );
    return this._callbackManager.trigger("_geometryCreated", d), d;
  }
  destroyLocalInstances(t) {
    return this._sc.MeshInstance.destroy(t);
  }
  _fromScCamera(t) {
    let e = ri.Orthographic;
    return t.projection() === ri.Perspective && (e = ri.Perspective), Cn.create(
      _.createFromArray(t.position()),
      _.createFromArray(t.target()),
      _.createFromArray(t.upVector()),
      e,
      t.fieldWidth(),
      t.fieldHeight(),
      t.nearLimit()
    );
  }
  async getCameraPromise(t) {
    const e = await this._sc.getCameraPromise(t);
    return this._fromScCamera(e);
  }
  getCamera(t) {
    const e = this._sc.getCamera(t);
    return this._fromScCamera(e);
  }
  resize(t) {
    t === void 0 && (t = Me.Default);
    let e = 1;
    this.getAllowHighDpi() && (e = window.devicePixelRatio || 1);
    const i = this._canvases.get(t), n = this._canvasContainers.get(t);
    i.width = n.clientWidth * e, i.height = n.clientHeight * e;
    const r = this._windowSizes.get(t);
    r === void 0 ? this._windowSizes.set(
      t,
      new K(n.offsetWidth, n.offsetHeight)
    ) : r.set(n.offsetWidth, n.offsetHeight), this._resizeRenderCanvas(), this._sc.onResize(t);
  }
  _resizeRenderCanvas() {
    const t = this._sc.canvas;
    let e = 0, i = 0;
    this._canvases.forEach((n) => {
      e = Math.max(e, n.width), i = Math.max(i, n.height);
    }), t.width = e, t.height = i;
  }
  setFaceVisibility(t, e) {
    this._sc.setFacesVisible(t, e);
  }
  setLineVisibility(t, e) {
    this._sc.setLinesVisible(t, e);
  }
  getCanvasSize(t) {
    const e = this._windowSizes.get(t);
    return e === void 0 ? K.zero() : e.copy();
  }
  setBackgroundGradient(t, e, i) {
    this._sc.setBackgroundGradient(
      t,
      e ? this._toRgba(e, 1) : [0, 0, 0, 0],
      i ? this._toRgba(i, 1) : [0, 0, 0, 0]
    );
  }
  setBoundingPreviewUnderDrawColor(t, e) {
    this._sc.setBoundingPreviewUnderdrawColor(e, this._toRgba(t, 0.7));
  }
  setBoundingPreviewTestedColor(t, e) {
    this._sc.setBoundingPreviewTestedColor(e, this._toRgba(t, 0.7));
  }
  setBoundingPreviewEjectedColor(t, e) {
    this._sc.setBoundingPreviewEjectedColor(e, this._toRgba(t, 0.7));
  }
  setBoundingPreviewUnderDraw(t, e) {
    this._sc.setBoundingPreviewUnderdraw(
      t.reduce((i, n) => (i.push(this._toVector3(n.min), this._toVector3(n.max)), i), []),
      e
    );
  }
  setBoundingDebugLevel(t, e) {
    this._sc.setBoundingDebugLevel(e, t);
  }
  setBoundingPreviewTested(t, e) {
    this._sc.setBoundingPreviewTested(
      t.reduce((i, n) => (i.push(this._toVector3(n.min), this._toVector3(n.max)), i), []),
      e
    );
  }
  setBoundingPreviewEjected(t, e) {
    this._sc.setBoundingPreviewEjected(
      t.reduce((i, n) => (i.push(this._toVector3(n.min), this._toVector3(n.max)), i), []),
      e
    );
  }
  setServerRenderQuality(t, e, i, n) {
    this._sc.setSsrQuality({
      jpegQualityLow: t,
      jpegQualityHigh: e,
      scaleLow: i,
      scaleHigh: n
    });
  }
  setMinimumFramerate(t, e) {
    this._sc.setMinFrameRate(t, e);
  }
  getMinimumFramerate(t) {
    return this._sc.getMinFrameRate(t);
  }
  setBackFacesVisible(t, e) {
    this._sc.setBackFacesVisible(t, e);
  }
  setDrawMode(t, e) {
    this._sc.setDrawMode(t, e);
  }
  enableHiddenLineRendering(t, e) {
    this.setDrawMode(t, dr.HiddenLine), this._sc.setHiddenLineVisibleLineColor(
      t,
      this._toRgba(e.getVisibleLineColor(), e.getVisibleLineOpacity())
    ), this._sc.setHiddenLineHiddenLineColor(
      t,
      this._toRgba(e.getObscuredLineColor(), e.getObscuredLineOpacity())
    );
  }
  setAntiAliasingMode(t, e) {
    const i = e == bg.SMAA ? ol.SMAA : ol.None;
    this._sc.setAntiAliasingMode(t, i);
  }
  setInstanceModifier(t, e, i) {
    switch (t) {
      case Qi.DoNotCut:
        this._sc.MeshInstance.setDoNotCut(e, i);
        break;
      case Qi.DoNotExplode:
        this._sc.MeshInstance.setDoNotExplode(e, i);
        break;
      case Qi.DoNotSelect:
        this._sc.MeshInstance.setDoNotSelect(e, i);
        break;
      case Qi.SuppressCameraScale:
        this._sc.MeshInstance.setSuppressCameraScale(e, i);
        break;
      case Qi.OverrideSceneVisibility:
        this._sc.MeshInstance.setOverrideSceneVisibility(e, i);
        break;
      case Qi.DoNotLight:
        this._sc.MeshInstance.setDoNotLight(e, i);
        break;
      case Qi.DoNotOutlineHighlight:
        this._sc.MeshInstance.setDoNotOutlineHighlight(e, i);
        break;
      case Qi.ExcludeBounding:
        this._sc.MeshInstance.setExcludeBounding(e, i);
        break;
      case Qi.DoNotUseVertexColors:
        this._sc.MeshInstance.setDoNotUseVertexColors(e, i);
        break;
      case Qi.AlwaysDraw:
        this._sc.MeshInstance.setAlwaysDraw(e, i);
        break;
      case Qi.DoNotXRay:
        this._sc.MeshInstance.setDoNotXRay(e, i);
        break;
      case Qi.ScreenOriented:
        this._sc.MeshInstance.setScreenOriented(e, i);
        break;
      case Qi.ScreenSpace:
        this._sc.MeshInstance.setScreenSpace(e, i);
        break;
      case Qi.ScreenSpaceStretched:
        this._sc.MeshInstance.setScreenSpaceStretched(e, i);
        break;
    }
  }
  attachModel(t, e, i, n, r) {
    const o = [e, i];
    return this._attachModels(t, [o], n, r);
  }
  attachScsModelByKey(t, e, i, n, r) {
    return console.assert(this._sessionType === en.Scs), this._sc.attachScsModelByKey(
      t,
      i,
      e,
      n,
      r
    );
  }
  async _attachModels(t, e, i, n) {
    await this._sc.attachModels(
      t,
      e,
      i,
      n
    ), this._callbackManager.trigger("_attached", t);
  }
  async attachScsBuffer(t, e, i, n, r, o, l) {
    await this._sc.attachScsBuffer(
      t,
      e,
      i,
      n,
      r,
      o,
      l
    ), this._callbackManager.trigger("_attached", t);
  }
  feedScsBuffer(t, e) {
    this._sc.feedScsBuffer(t, e);
  }
  _parseKeyInfo(t, e, i) {
    if (t || e)
      return i;
    const n = /* @__PURE__ */ new Map();
    for (let r = 0; r < i.length; ++r) {
      const o = i[r++], l = [];
      for (; r < i.length && i[r] !== xs.Invalid; ++r)
        l.push(i[r]);
      n.set(o, l);
    }
    return n;
  }
  async instanceKeyInfo(t, e, i) {
    const n = e === Xu.Model, r = i === Ju.KeyCountOnly, o = await this._sc.meshInstanceKeyInfo(t, n, r);
    return this._parseKeyInfo(n, r, o);
  }
  async metaDataKeyInfo(t, e, i) {
    const n = await this._sc.metaDataKeyInfo(t, e, i);
    return this._parseKeyInfo(e, i, n);
  }
  modelKeysFromInclusionKeys(t) {
    return this._sc.modelKeysFromInclusionKeys(t);
  }
  detachInclusions(t) {
    return this._sc.detachInclusions(t);
  }
  async resetToEmpty(t, e) {
    for (let i = 0; i < this._requestBatchCountByType.length; ++i) {
      this._requestBatchCountByType[i] = 0;
      for (const n of this._pendingRequestsByType[i])
        n.promise.reject(n.ids);
      this._pendingRequestsByType[i].length = 0;
    }
    await this._sc.resetToEmpty(t, e), this.flushMetaDataCache();
  }
  setDrawStrategy(t, e) {
    console.warn(
      "This API has been deactivated for lack of stability it is recommended not to use it"
    ), this._sc.setDrawStrategy(t, e);
  }
  redraw(t) {
    this._sc.queueRedraw(t);
  }
  disconnectNetwork() {
    this._sc.disconnectNetwork();
  }
  shutdown() {
    this._cappingDelayTimeoutId !== null && (clearTimeout(this._cappingDelayTimeoutId), this._cappingDelayTimeoutId = null), this._sessionType = en.Uninitialized, this._sc.shutDown();
  }
  getVersionString() {
    return this._sc.getStreamVersion().toString();
  }
  setAllowHighDpi(t) {
    this._sc.allowHighDpi = t, this.resize();
  }
  getAllowHighDpi() {
    return this._sc.allowHighDpi;
  }
  setMeshLevel(t, e) {
    this._sc.MeshInstance.setMeshLevel(t, e);
  }
  setMetallicRoughness(t, e, i) {
    this._sc.MeshInstance.setMetallicRoughness(t, e, i);
  }
  setMetallicRoughnessMaterialOverride(t, e) {
    this._sc.setMetallicRoughnessMaterialOverride(t, e);
  }
  async getMetallicRoughness(t) {
    const e = await this._sc.MeshInstance.getMetallicRoughness(t), i = [];
    for (let n = 0; n < e.length; n += 2) {
      if (e[n] < 0 || e[n + 1] < 0) {
        i.push(null);
        continue;
      }
      i.push({
        metallic: e[n],
        roughness: e[n + 1]
      });
    }
    return i;
  }
  unsetMetallicRoughness(t) {
    this._sc.MeshInstance.unsetMetallicRoughness(t);
  }
  setOverlayVisibility(t, e, i) {
    this._sc.Overlay.setVisible(i, t, e);
  }
  setOverlayCamera(t, e, i) {
    const n = this._toCamera(i, e);
    this._sc.Overlay.setCamera(i, t, n);
  }
  destroyOverlay(t, e) {
    this._sc.Overlay.destroy(e, t);
  }
  _overlayUnit(t) {
    switch (t) {
      case Fe.ProportionOfCanvas:
        return al.ProportionOfScreen;
      case Fe.MinimumProportionOfCanvas:
        return al.MinimumProportionOfScreen;
      case Fe.ProportionOfOtherDimension:
        return al.ProportionOfOtherDimension;
      default:
        return al.Pixels;
    }
  }
  getMaxOverlayIndex() {
    return this._sc.Overlay.maxIndex();
  }
  _overlayAnchor(t) {
    switch (t) {
      case qe.BottomCenter:
        return ur.BottomCenter;
      case qe.Center:
        return ur.Center;
      case qe.LeftCenter:
        return ur.LeftCenter;
      case qe.LowerLeftCorner:
        return ur.LowerLeftCorner;
      case qe.LowerRightCorner:
        return ur.LowerRightCorner;
      case qe.RightCenter:
        return ur.RightCenter;
      case qe.TopCenter:
        return ur.TopCenter;
      case qe.UpperRightCorner:
        return ur.UpperRightCorner;
      default:
        return ur.UpperLeftCorner;
    }
  }
  setOverlayViewport(t, e, i, n, r, o, l, h, u, d, g) {
    this._sc.Overlay.setViewport(
      g,
      t,
      this._overlayAnchor(e),
      i,
      this._overlayUnit(n),
      r,
      this._overlayUnit(o),
      l,
      this._overlayUnit(h),
      u,
      this._overlayUnit(d)
    );
  }
  addNodesToOverlay(t, e, i) {
    this._sc.MeshInstance.setOverlayId(t, e, i);
  }
  getInstancesMeshData(t) {
    return this._sc.MeshInstance.getMeshData(t);
  }
  getInstancesCappingMeshData(t) {
    return this._sc.MeshInstance.getCappingMeshData(t);
  }
  getMeshData(t) {
    return this._sc.MeshData.getData(t);
  }
  _toElementType(t) {
    switch (t) {
      case Yt.Faces:
        return an.Faces;
      case Yt.Lines:
        return an.Lines;
      case Yt.Points:
        return an.Points;
    }
  }
  _toXRayGroup(t) {
    switch (t) {
      case hh.Selected:
        return qu.Selected;
      case hh.Unselected:
        return qu.Unselected;
    }
  }
  setXRayColor(t, e, i, n) {
    this._sc.setXRayMaterial(
      t,
      this._toXRayGroup(e),
      this._toElementType(i),
      this._toRgba(n, 1)
    );
  }
  unsetXRayColor(t, e, i) {
    return this._sc.unsetXRayMaterial(
      t,
      this._toXRayGroup(e),
      this._toElementType(i)
    );
  }
  setXRayOpacity(t, e, i) {
    i !== void 0 ? this._sc.setXRayOpacity(t, this._toElementType(i), e) : (this._sc.setXRayOpacity(t, an.Faces, e), this._sc.setXRayOpacity(t, an.Lines, e), this._sc.setXRayOpacity(t, an.Points, e));
  }
  setXRayTransparencyMode(t, e) {
    this._sc.setXRayTransparencyMode(t, e);
  }
  setGoochBlue(t, e) {
    this._sc.setGoochBlue(t, e);
  }
  setGoochBaseColorProminence(t, e) {
    this._sc.setGoochBaseColorProminence(t, e);
  }
  setGoochYellow(t, e) {
    this._sc.setGoochYellow(t, e);
  }
  setGoochLuminanceShiftStrength(t, e) {
    this._sc.setGoochLuminanceShiftStrength(t, e);
  }
  setToonShadingBandCount(t, e) {
    this._sc.setToonBandCount(t, e);
  }
  setToonShadingSpecularFactor(t, e) {
    this._sc.setToonSpecularFactor(t, e);
  }
  setTransparencyMode(t, e) {
    this._sc.setTransparencyMode(t, e);
  }
  setPointSize(t, e, i) {
    this._sc.setPointSize(t, e, i);
  }
  async getPointSize(t) {
    const e = await Promise.all([
      this._sc.getPointSize(t),
      this._sc.getPointSizeUnit(t)
    ]);
    return [e[0], e[1]];
  }
  setPointShape(t, e) {
    this._sc.setPointShape(t, e);
  }
  async getPointShape(t) {
    return await this._sc.getPointShape(t);
  }
  setEyeDomeLightingEnabled(t, e) {
    this._sc.setEyeDomeLightingEnabled(t, e);
  }
  getEyeDomeLightingEnabled(t) {
    return this._sc.getEyeDomeLightingEnabled(t);
  }
  setEyeDomeLightingBlurSamples(t, e) {
    this._sc.setEyeDomeLightingBlurSamples(t, e);
  }
  getEyeDomeLightingBlurSamples(t) {
    return this._sc.getEyeDomeLightingBlurSamples(t);
  }
  setEyeDomeLightingBlurInterval(t, e) {
    this._sc.setEyeDomeLightingBlurInterval(t, e);
  }
  getEyeDomeLightingBlurInterval(t) {
    return this._sc.getEyeDomeLightingBlurInterval(t);
  }
  setEyeDomeLightingBlurEdgeDistance(t, e) {
    this._sc.setEyeDomeLightingBlurEdgeDistance(t, e);
  }
  getEyeDomeLightingBlurEdgeDistance(t) {
    return this._sc.getEyeDomeLightingBlurEdgeDistance(t);
  }
  setEyeDomeLightingShadingEdgeDistance(t, e) {
    this._sc.setEyeDomeLightingShadingEdgeDistance(t, e);
  }
  getEyeDomeLightingShadingEdgeDistance(t) {
    return this._sc.getEyeDomeLightingShadingEdgeDistance(t);
  }
  setEyeDomeLightingOpacity(t, e) {
    this._sc.setEyeDomeLightingOpacity(t, e);
  }
  getEyeDomeLightingOpacity(t) {
    return this._sc.getEyeDomeLightingOpacity(t);
  }
  setDisplayIncompleteFrames(t, e) {
    this._sc.setDisplayIncompleteFrames(e, t);
  }
  setInteractiveDrawDelay(t, e) {
    this._sc.setPostInputDelay(e, t);
  }
  setInteractiveDrawLimitIncreaseEnabled(t, e) {
    this._sc.setInteractiveDrawLimitIncreaseEnabled(e, t);
  }
  getInteractiveDrawLimitIncreaseEnabled(t) {
    return this._sc.getInteractiveDrawLimitIncreaseEnabled(t);
  }
  setCullingVector(t, e, i, n) {
    this._sc.MeshInstance.setCullingVector(
      t,
      e,
      [i.x, i.y, i.z],
      n
    );
  }
  unsetCullingVector(t) {
    this._sc.MeshInstance.unsetCullingVector(t);
  }
  async getCullingVector(t) {
    const e = await this._sc.MeshInstance.getCullingVector(t), i = [];
    for (const n of e)
      n.vector[0] === 0 && n.vector[1] === 0 && n.vector[2] === 0 ? i.push(null) : i.push({
        space: n.space,
        vector: _.createFromArray(n.vector),
        toleranceDegrees: n.toleranceDegrees
      });
    return i;
  }
  _setStreamCutoffScale(t) {
    this._streamCutoffScale = Math.max(0, Math.min(t, 2));
  }
  setStreamCutoffScale(t) {
    this._setStreamCutoffScale(t), this._sc.setStreamCutoffScale(this._streamCutoffScale);
  }
  getStreamCutoffScale() {
    return this._streamCutoffScale;
  }
  loseWebGlContext() {
    return this._sc._loseWebGlContext();
  }
  triangulatePolygon(t, e) {
    const i = this._sc.triangulatePolygon(t, e);
    return new Float32Array(i);
  }
  debug_log(t) {
    return this._sc.debug_log(t);
  }
  debug_stateFailure(t) {
    return this._sc.debug_stateFailure(t);
  }
  debug_sync() {
    return this._sc.debug_sync();
  }
  setLinePattern(t, e, i, n) {
    this._sc.MeshInstance.setLinePattern(t, e, i, n);
  }
  unsetLinePattern(t) {
    this._sc.MeshInstance.unsetLinePattern(t);
  }
  async createFloorplanMesh(t) {
    return this._sc.createFloorplanMesh(t);
  }
  async exportToSvg(t) {
    return (await this._sc.exportToSvg(t)).map((n) => String.fromCharCode(n)).join("");
  }
  async beginExportToSvg(t) {
    return this._sc.beginExportToSvg(t);
  }
  async advanceExportToSvg() {
    const t = await this._sc.advanceExportToSvg();
    if (t.length !== 0)
      return t.reduce((e, i) => {
        const n = String.fromCharCode(i);
        switch (n) {
          case `
`:
            return e;
          case "'":
            return `${e}"`;
          default:
            return `${e}${n}`;
        }
      }, "");
  }
  waitForImageDecoding() {
    return this._sc.waitForImageDecoding();
  }
  registerBimInstances(t, e) {
    return this._sc.registerBimInstances(t, e);
  }
  setAmbientLightColor(t, e) {
    this._sc.setAmbientLightColor(t, this._toRgb(e));
  }
  getLightKeys(t) {
    return this._sc.getLightKeys(t);
  }
  async getLight(t, e) {
    try {
      const i = await this._sc.getLight(t, e);
      switch (i.type.value) {
        case Hu.Point:
          const r = i;
          return new mx(
            i.type.value,
            i.space.value,
            new _(...i.position),
            vt.createFromFloatArray(i.color),
            r.power,
            r.decay
          );
        case Hu.Directional:
          return new px(
            i.type.value,
            i.space.value,
            new _(...i.position),
            vt.createFromFloatArray(i.color)
          );
        default:
          console.error(`No light of type ${i.type} could be instanciated.`);
          return;
      }
    } catch {
      return;
    }
  }
  clearLights(t) {
    this._sc.clearLights(t);
  }
  addLight(t, e) {
    return this._sc.addLight(
      t,
      e.type,
      e.space,
      this._toVector3(e.position),
      this._toRgb(e.color)
    );
  }
  async addPointLight(t, e) {
    const i = await this._sc.addLight(
      t,
      e.type,
      e.space,
      this._toVector3(e.position),
      this._toRgb(e.color)
    );
    return this._sc.setLightPower(t, i, e.power), this._sc.setLightDecay(t, i, e.decay), i;
  }
  removeLight(t, e) {
    this._sc.removeLight(t, e);
  }
  updateLight(t, e, i) {
    this._sc.updateLight(
      t,
      e,
      i.type,
      i.space,
      this._toVector3(i.position),
      this._toRgb(i.color)
    );
  }
  setBloomEnabled(t, e) {
    this._sc.setBloomEnabled(t, e);
  }
  setBloomThreshold(t, e) {
    this._sc.setBloomThreshold(t, e);
  }
  setBloomThresholdRampWidth(t, e) {
    this._sc.setBloomThresholdRampWidth(t, e);
  }
  setBloomIntensityScale(t, e) {
    this._sc.setBloomIntensityScale(t, e);
  }
  _toBlurIntervalUnit(t) {
    switch (t) {
      default:
      case Ks.Pixels:
        return kc.Pixels;
      case Ks.ProportionOfWidth:
        return kc.ProportionOfWidth;
      case Ks.ProportionOfHeight:
        return kc.ProportionOfHeight;
    }
  }
  setBloomLayers(t, e) {
    for (const i of e)
      if (i.blurInterval !== void 0 && i.blurInterval.length !== 2)
        throw new oe(
          "'blurInterval' must be an array containing a number followed by a BlurIntervalUnit"
        );
    this._sc.suspendDrawing(t), this._sc.setBloomLayerCount(t, e.length);
    for (let i = 0; i < e.length; ++i) {
      const n = e[i];
      n.intensity !== void 0 && this._sc.setBloomIntensity(t, i, n.intensity), n.blurSamples !== void 0 && this._sc.setBloomBlurSamples(t, i, n.blurSamples), n.blurInterval !== void 0 && this._sc.setBloomBlurInterval(
        t,
        i,
        n.blurInterval[0],
        this._toBlurIntervalUnit(n.blurInterval[1])
      );
    }
    this._sc.resumeDrawing(t);
  }
  startComparison(t, e, i, n) {
    const r = n != null && n.sameColor ? this._toRgb(n.sameColor) : [0, 0, 0], o = n != null && n.only1Color ? this._toRgb(n.only1Color) : [1, 0, 0], l = n != null && n.only2Color ? this._toRgb(n.only2Color) : [0, 1, 0];
    this._sc.setComparisonColors(t, r, o, l), this._sc.startComparison(t, e, i);
  }
  endComparison(t) {
    this._sc.endComparison(t);
  }
  setSimpleShadowColor(t, e) {
    this._sc.setSimpleShadowColor(t, this._toRgb(e));
  }
  setSimpleShadowEnabled(t, e) {
    this._sc.setSimpleShadowEnabled(t, e);
  }
  setSimpleShadowOpacity(t, e) {
    this._sc.setSimpleShadowOpacity(t, e);
  }
  setGroundPlane(t, e, i) {
    i !== void 0 ? this._sc.setGroundPlaneWithPosition(
      t,
      this._toVector3(e),
      this._toVector3(i)
    ) : this._sc.setGroundPlane(t, this._toVector3(e));
  }
  setSimpleShadowResolution(t, e) {
    this._sc.setSimpleShadowResolution(t, e);
  }
  setSimpleShadowBlurSamples(t, e) {
    this._sc.setSimpleShadowBlurSamples(t, e);
  }
  setSimpleShadowBlurInterval(t, e) {
    this._sc.setSimpleShadowBlurInterval(t, e);
  }
  setSimpleShadowInteractiveUpdateEnabled(t, e = !0) {
    this._sc.setSimpleShadowInteractiveUpdateEnabled(t, e);
  }
  setSilhouetteColor(t, e) {
    this._sc.setSilhouetteColor(t, this._toRgb(e));
  }
  setSilhouetteEnabled(t, e = !0) {
    this._sc.setSilhouetteEnabled(t, e);
  }
  setSilhouetteOpacity(t, e) {
    this._sc.setSilhouetteOpacity(t, e);
  }
  setSilhouetteThreshold(t, e) {
    this._sc.setSilhouetteThreshold(t, e);
  }
  setSilhouetteThresholdRampWidth(t, e) {
    this._sc.setSilhouetteThresholdRampWidth(t, e);
  }
  setHardEdgeColor(t, e) {
    this._sc.setHardEdgeColor(t, this._toRgb(e));
  }
  setHardEdgesEnabled(t, e = !0) {
    this._sc.setHardEdgesEnabled(t, e);
  }
  setHardEdgeOpacity(t, e) {
    this._sc.setHardEdgeOpacity(t, e);
  }
  setHardEdgeThreshold(t, e) {
    this._sc.setHardEdgeThreshold(t, e);
  }
  setHardEdgeThresholdRampWidth(t, e) {
    this._sc.setHardEdgeThresholdRampWidth(t, e);
  }
  setSimpleReflectionEnabled(t, e = !0) {
    this._sc.setSimpleReflectionEnabled(t, e);
  }
  setSimpleReflectionBlurInterval(t, e, i) {
    this._sc.setSimpleReflectionBlurInterval(t, e, this._toBlurIntervalUnit(i));
  }
  setSimpleReflectionBlurSamples(t, e) {
    this._sc.setSimpleReflectionBlurSamples(t, e);
  }
  setSimpleReflectionFadeAngle(t, e) {
    this._sc.setSimpleReflectionFadeAngle(t, e);
  }
  setSimpleReflectionOpacity(t, e) {
    this._sc.setSimpleReflectionOpacity(t, e);
  }
  setSimpleReflectionAttenuation(t, e, i, n = lg.World) {
    this._sc.setSimpleReflectionAttenuation(t, e, i, n);
  }
  throttleLoad(t, e) {
    this._sc.throttleLoad(t, e);
  }
  _toVector3Array(t) {
    const e = [];
    for (const i of t)
      e.push([i.x, i.y, i.z]);
    return e;
  }
  testPointVisibility(t, e) {
    return this._sc.testPointVisibility(this._toVector3Array(e), t);
  }
  setPointVisibilityTest(t, e) {
    this._sc.setPointVisibilityTest(this._toVector3Array(e), t);
  }
  setImageBasedLightingEnabled(t, e) {
    this._sc.setImageBasedLightingEnabled(t, e);
  }
  setImageBasedLightingIntensity(t, e) {
    this._sc.setImageBasedLightingIntensity(t, e);
  }
  _toMatrix9(t) {
    return [
      t.m[0],
      t.m[1],
      t.m[2],
      t.m[4],
      t.m[5],
      t.m[6],
      t.m[8],
      t.m[9],
      t.m[10]
    ];
  }
  setImageBasedLightingMatrix(t, e) {
    this._sc.setImageBasedLightingMatrix(t, this._toMatrix9(e));
  }
  setImageBasedLightingEnvironment(t, e) {
    this._sc.setImageBasedLightingEnvironment(t, e);
  }
  setImageBasedLightingEnvironmentToDefault(t) {
    this._sc.setImageBasedLightingEnvironmentToDefault(t);
  }
  setLineJitterEnabled(t, e) {
    this._sc.setLineJitterEnabled(t, e);
  }
  setLineJitterInstanceCount(t, e) {
    this._sc.setLineJitterInstanceCount(t, e);
  }
  setLineJitterRadius(t, e) {
    this._sc.setLineJitterRadius(t, e);
  }
  setLineJitterFrequency(t, e) {
    this._sc.setLineJitterFrequency(t, e);
  }
}
const cI = () => new window.XMLHttpRequest();
function hI(s, t) {
  let e, i, n, r;
  t || (t = {}), typeof t == "function" ? (r = t, t = {}) : typeof t.callback == "function" && (r = t.callback), !r && typeof Promise < "u" ? e = new Promise(function(o, l) {
    i = o, n = l;
  }) : (i = function(o) {
    r(null, o);
  }, n = function(o) {
    r(o, null);
  });
  try {
    const o = cI();
    if (o.open("GET", s, !0), "responseType" in o && (o.responseType = "arraybuffer"), o.overrideMimeType && o.overrideMimeType("text/plain; charset=x-user-defined"), o.onreadystatechange = function() {
      if (o.readyState === 4)
        if (o.status === 200 || o.status === 0)
          try {
            i(o.response ?? o.responseText);
          } catch (l) {
            n(l);
          }
        else
          n(new Error("Ajax error for " + s + " : " + this.status + " " + this.statusText));
    }, t.progress) {
      const l = t.progress;
      o.onprogress = function(h) {
        l({
          path: s,
          originalEvent: h,
          percent: h.loaded / h.total * 100,
          loaded: h.loaded,
          total: h.total
        });
      };
    }
    o.send();
  } catch (o) {
    n(o, null);
  }
  return e;
}
class uI {
  constructor(t) {
    this._id = 0, this._bcfMap = /* @__PURE__ */ new Map(), this._viewer = t;
  }
  _getId() {
    return ++this._id;
  }
  /**
   * Gets a map containing BCF data correlated with the BCF filename.
   */
  getBCFMap() {
    return this._bcfMap;
  }
  /**
   * Gets the parsed BCF data for a BCF file.
   * @param id corresponding to the BCF file.
   */
  getBCFData(t) {
    return this._bcfMap.get(t) || null;
  }
  /**
   * Removes the parsed BCF data for a BCF file.
   * @param id corresponding to the BCF file.
   */
  removeBCFData(t) {
    this._bcfMap.delete(t), this._viewer.trigger("bcfRemoved", t);
  }
  /**
   * Creates a BCF file.
   * @param filename
   */
  createBCFData(t) {
    const e = this._getId(), i = new Du(t, e);
    return this._bcfMap.set(e, i), this._viewer.trigger("bcfLoaded", i.getId(), i.getFilename()), i;
  }
  /**
   * Imports BCF data from a BCF file.
   * @param filename
   */
  async addBCFFromFile(t) {
    const e = this._getId(), i = new Du(t, e);
    this._bcfMap.set(e, i);
    const n = await new O_.external.Promise((r, o) => {
      hI(t, (l, h) => {
        l ? o(l) : r(h);
      });
    });
    await this._loadBCFData(n, i);
  }
  /**
   * Imports BCF data from a buffer.
   * @param buffer
   * @param filename
   */
  async addBCFFromBuffer(t, e) {
    const i = this._getId(), n = new Du(e, i);
    this._bcfMap.set(i, n), await this._loadBCFData(t, n);
  }
  async _getVersion(t) {
    const e = t.file("bcf.version");
    if (e === null)
      return Xs.v1_0;
    {
      const r = (await this._getDocument(e)).documentElement.firstElementChild;
      if (r != null && r.textContent)
        switch (r.textContent) {
          case "2.0 RC":
            return Xs.v2_0;
          case "2.1":
            return Xs.v2_1;
        }
      return Xs.Unknown;
    }
  }
  async _loadBCFData(t, e) {
    const i = this._viewer.model, n = await i.getModelBounding(!0, !1), r = i.getNodeUnitMultiplier(i.getAbsoluteRootNode()), o = e.getId(), l = e.getFilename(), h = await Ig.loadAsync(t);
    e.setVersion(await this._getVersion(h));
    const u = [];
    h.forEach(async (d) => {
      const g = wi();
      u.push(g);
      const y = this._getFileType(d);
      if (y === Xn.Markup || y === Xn.Snapshot || y === Xn.Viewpoint) {
        const m = d.split("/"), x = m[0], b = m[1];
        let I = e.getTopic(x);
        if (I === null && (I = new bd(o, l, x, this._viewer), e.addTopic(x, I)), b.length) {
          const C = h.file(d);
          if (C !== null)
            switch (y) {
              case Xn.Markup:
                I.addMarkup(b, await this._getDocument(C));
                break;
              case Xn.Viewpoint:
                I.addViewpoint(
                  b,
                  await this._getDocument(C),
                  e.getVersion(),
                  n,
                  r
                );
                break;
              case Xn.Snapshot:
                I.addSnapshot(b, await C.async("uint8array"));
                break;
            }
        }
      }
      g.resolve();
    }), await Ge(u), this._viewer.trigger("bcfLoaded", o, l);
  }
  async _getDocument(t) {
    return new DOMParser().parseFromString(await t.async("text"), "application/xml");
  }
  _getFileType(t) {
    if (t.slice(-1) === "/")
      return Xn.TopicFolder;
    const e = t.split(".");
    switch (console.assert(e.length === 2), e[1]) {
      case "bcf":
        return Xn.Markup;
      case "bcfv":
        return Xn.Viewpoint;
      case "png":
        return Xn.Snapshot;
      case "version":
        return Xn.Version;
      case "xsd":
        return Xn.Schema;
      case "bcfp":
        return Xn.Project;
    }
    return Xn.Unknown;
  }
}
class dI {
  constructor() {
    this._activeInterpolation = null, this._updateTimer = new Xo(), this._updateInterval = 16;
  }
  stop() {
    this._activeInterpolation && this._activeInterpolation.stop(), this._activeInterpolation = null, this._updateTimer.clear();
  }
  start(t, e = !0) {
    return this._activeInterpolation && !e ? !1 : (this.stop(), this._activeInterpolation = t, this._activeInterpolation.start(), this.update(), !0);
  }
  update() {
    if (this._activeInterpolation)
      if (this._activeInterpolation.update(), this._activeInterpolation.isComplete()) {
        const t = this._activeInterpolation.getCallback();
        t !== null && t();
      } else
        this._updateTimer.isIdle(Dn.BeforeAction) && this._updateTimer.set(this._updateInterval, () => {
          this.update();
        });
  }
}
var kd = { exports: {} }, Cc = { exports: {} };
(function() {
  var s, t, e, i, n, r;
  typeof performance < "u" && performance !== null && performance.now ? Cc.exports = function() {
    return performance.now();
  } : typeof process < "u" && process !== null && process.hrtime ? (Cc.exports = function() {
    return (s() - n) / 1e6;
  }, t = process.hrtime, s = function() {
    var o;
    return o = t(), o[0] * 1e9 + o[1];
  }, i = s(), r = process.uptime() * 1e9, n = i - r) : Date.now ? (Cc.exports = function() {
    return Date.now() - e;
  }, e = Date.now()) : (Cc.exports = function() {
    return (/* @__PURE__ */ new Date()).getTime() - e;
  }, e = (/* @__PURE__ */ new Date()).getTime());
}).call(ga);
var fI = Cc.exports, gI = fI, uo = typeof window > "u" ? ga : window, bu = ["moz", "webkit"], ml = "AnimationFrame", Nl = uo["request" + ml], ph = uo["cancel" + ml] || uo["cancelRequest" + ml];
for (var lc = 0; !Nl && lc < bu.length; lc++)
  Nl = uo[bu[lc] + "Request" + ml], ph = uo[bu[lc] + "Cancel" + ml] || uo[bu[lc] + "CancelRequest" + ml];
if (!Nl || !ph) {
  var mf = 0, nm = 0, oa = [], pI = 1e3 / 60;
  Nl = function(s) {
    if (oa.length === 0) {
      var t = gI(), e = Math.max(0, pI - (t - mf));
      mf = e + t, setTimeout(function() {
        var i = oa.slice(0);
        oa.length = 0;
        for (var n = 0; n < i.length; n++)
          if (!i[n].cancelled)
            try {
              i[n].callback(mf);
            } catch (r) {
              setTimeout(function() {
                throw r;
              }, 0);
            }
      }, Math.round(e));
    }
    return oa.push({
      handle: ++nm,
      callback: s,
      cancelled: !1
    }), nm;
  }, ph = function(s) {
    for (var t = 0; t < oa.length; t++)
      oa[t].handle === s && (oa[t].cancelled = !0);
  };
}
kd.exports = function(s) {
  return Nl.call(uo, s);
};
kd.exports.cancel = function() {
  ph.apply(uo, arguments);
};
kd.exports.polyfill = function(s) {
  s || (s = uo), s.requestAnimationFrame = Nl, s.cancelAnimationFrame = ph;
};
var mI = kd.exports;
const _f = /* @__PURE__ */ fd(mI);
var _I = function(s) {
  this.ok = !1, this.alpha = 1, s.charAt(0) == "#" && (s = s.substr(1, 6)), s = s.replace(/ /g, ""), s = s.toLowerCase();
  var t = {
    aliceblue: "f0f8ff",
    antiquewhite: "faebd7",
    aqua: "00ffff",
    aquamarine: "7fffd4",
    azure: "f0ffff",
    beige: "f5f5dc",
    bisque: "ffe4c4",
    black: "000000",
    blanchedalmond: "ffebcd",
    blue: "0000ff",
    blueviolet: "8a2be2",
    brown: "a52a2a",
    burlywood: "deb887",
    cadetblue: "5f9ea0",
    chartreuse: "7fff00",
    chocolate: "d2691e",
    coral: "ff7f50",
    cornflowerblue: "6495ed",
    cornsilk: "fff8dc",
    crimson: "dc143c",
    cyan: "00ffff",
    darkblue: "00008b",
    darkcyan: "008b8b",
    darkgoldenrod: "b8860b",
    darkgray: "a9a9a9",
    darkgreen: "006400",
    darkkhaki: "bdb76b",
    darkmagenta: "8b008b",
    darkolivegreen: "556b2f",
    darkorange: "ff8c00",
    darkorchid: "9932cc",
    darkred: "8b0000",
    darksalmon: "e9967a",
    darkseagreen: "8fbc8f",
    darkslateblue: "483d8b",
    darkslategray: "2f4f4f",
    darkturquoise: "00ced1",
    darkviolet: "9400d3",
    deeppink: "ff1493",
    deepskyblue: "00bfff",
    dimgray: "696969",
    dodgerblue: "1e90ff",
    feldspar: "d19275",
    firebrick: "b22222",
    floralwhite: "fffaf0",
    forestgreen: "228b22",
    fuchsia: "ff00ff",
    gainsboro: "dcdcdc",
    ghostwhite: "f8f8ff",
    gold: "ffd700",
    goldenrod: "daa520",
    gray: "808080",
    green: "008000",
    greenyellow: "adff2f",
    honeydew: "f0fff0",
    hotpink: "ff69b4",
    indianred: "cd5c5c",
    indigo: "4b0082",
    ivory: "fffff0",
    khaki: "f0e68c",
    lavender: "e6e6fa",
    lavenderblush: "fff0f5",
    lawngreen: "7cfc00",
    lemonchiffon: "fffacd",
    lightblue: "add8e6",
    lightcoral: "f08080",
    lightcyan: "e0ffff",
    lightgoldenrodyellow: "fafad2",
    lightgrey: "d3d3d3",
    lightgreen: "90ee90",
    lightpink: "ffb6c1",
    lightsalmon: "ffa07a",
    lightseagreen: "20b2aa",
    lightskyblue: "87cefa",
    lightslateblue: "8470ff",
    lightslategray: "778899",
    lightsteelblue: "b0c4de",
    lightyellow: "ffffe0",
    lime: "00ff00",
    limegreen: "32cd32",
    linen: "faf0e6",
    magenta: "ff00ff",
    maroon: "800000",
    mediumaquamarine: "66cdaa",
    mediumblue: "0000cd",
    mediumorchid: "ba55d3",
    mediumpurple: "9370d8",
    mediumseagreen: "3cb371",
    mediumslateblue: "7b68ee",
    mediumspringgreen: "00fa9a",
    mediumturquoise: "48d1cc",
    mediumvioletred: "c71585",
    midnightblue: "191970",
    mintcream: "f5fffa",
    mistyrose: "ffe4e1",
    moccasin: "ffe4b5",
    navajowhite: "ffdead",
    navy: "000080",
    oldlace: "fdf5e6",
    olive: "808000",
    olivedrab: "6b8e23",
    orange: "ffa500",
    orangered: "ff4500",
    orchid: "da70d6",
    palegoldenrod: "eee8aa",
    palegreen: "98fb98",
    paleturquoise: "afeeee",
    palevioletred: "d87093",
    papayawhip: "ffefd5",
    peachpuff: "ffdab9",
    peru: "cd853f",
    pink: "ffc0cb",
    plum: "dda0dd",
    powderblue: "b0e0e6",
    purple: "800080",
    rebeccapurple: "663399",
    red: "ff0000",
    rosybrown: "bc8f8f",
    royalblue: "4169e1",
    saddlebrown: "8b4513",
    salmon: "fa8072",
    sandybrown: "f4a460",
    seagreen: "2e8b57",
    seashell: "fff5ee",
    sienna: "a0522d",
    silver: "c0c0c0",
    skyblue: "87ceeb",
    slateblue: "6a5acd",
    slategray: "708090",
    snow: "fffafa",
    springgreen: "00ff7f",
    steelblue: "4682b4",
    tan: "d2b48c",
    teal: "008080",
    thistle: "d8bfd8",
    tomato: "ff6347",
    turquoise: "40e0d0",
    violet: "ee82ee",
    violetred: "d02090",
    wheat: "f5deb3",
    white: "ffffff",
    whitesmoke: "f5f5f5",
    yellow: "ffff00",
    yellowgreen: "9acd32"
  };
  s = t[s] || s;
  for (var e = [
    {
      re: /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3}),\s*((?:\d?\.)?\d)\)$/,
      example: ["rgba(123, 234, 45, 0.8)", "rgba(255,234,245,1.0)"],
      process: function(h) {
        return [
          parseInt(h[1]),
          parseInt(h[2]),
          parseInt(h[3]),
          parseFloat(h[4])
        ];
      }
    },
    {
      re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
      example: ["rgb(123, 234, 45)", "rgb(255,234,245)"],
      process: function(h) {
        return [
          parseInt(h[1]),
          parseInt(h[2]),
          parseInt(h[3])
        ];
      }
    },
    {
      re: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
      example: ["#00ff00", "336699"],
      process: function(h) {
        return [
          parseInt(h[1], 16),
          parseInt(h[2], 16),
          parseInt(h[3], 16)
        ];
      }
    },
    {
      re: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
      example: ["#fb0", "f0f"],
      process: function(h) {
        return [
          parseInt(h[1] + h[1], 16),
          parseInt(h[2] + h[2], 16),
          parseInt(h[3] + h[3], 16)
        ];
      }
    }
  ], i = 0; i < e.length; i++) {
    var n = e[i].re, r = e[i].process, o = n.exec(s);
    if (o) {
      var l = r(o);
      this.r = l[0], this.g = l[1], this.b = l[2], l.length > 3 && (this.alpha = l[3]), this.ok = !0;
    }
  }
  this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.alpha = this.alpha < 0 ? 0 : this.alpha > 1 || isNaN(this.alpha) ? 1 : this.alpha, this.toRGB = function() {
    return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")";
  }, this.toRGBA = function() {
    return "rgba(" + this.r + ", " + this.g + ", " + this.b + ", " + this.alpha + ")";
  }, this.toHex = function() {
    var h = this.r.toString(16), u = this.g.toString(16), d = this.b.toString(16);
    return h.length == 1 && (h = "0" + h), u.length == 1 && (u = "0" + u), d.length == 1 && (d = "0" + d), "#" + h + u + d;
  }, this.getHelpXML = function() {
    for (var h = new Array(), u = 0; u < e.length; u++)
      for (var d = e[u].example, g = 0; g < d.length; g++)
        h[h.length] = d[g];
    for (var y in t)
      h[h.length] = y;
    var m = document.createElement("ul");
    m.setAttribute("id", "rgbcolor-examples");
    for (var u = 0; u < h.length; u++)
      try {
        var x = document.createElement("li"), b = new RGBColor(h[u]), I = document.createElement("div");
        I.style.cssText = "margin: 3px; border: 1px solid black; background:" + b.toHex() + "; color:" + b.toHex(), I.appendChild(document.createTextNode("test"));
        var C = document.createTextNode(
          " " + h[u] + " -> " + b.toRGB() + " -> " + b.toHex()
        );
        x.appendChild(I), x.appendChild(C), m.appendChild(x);
      } catch {
      }
    return m;
  };
};
const eg = /* @__PURE__ */ fd(_I);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Ky = function(s, t) {
  return (Ky = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(e, i) {
    e.__proto__ = i;
  } || function(e, i) {
    for (var n in i)
      Object.prototype.hasOwnProperty.call(i, n) && (e[n] = i[n]);
  })(s, t);
};
function Xy(s, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  function e() {
    this.constructor = s;
  }
  Ky(s, t), s.prototype = t === null ? Object.create(t) : (e.prototype = t.prototype, new e());
}
function yI(s) {
  var t = "";
  Array.isArray(s) || (s = [s]);
  for (var e = 0; e < s.length; e++) {
    var i = s[e];
    if (i.type === Et.CLOSE_PATH)
      t += "z";
    else if (i.type === Et.HORIZ_LINE_TO)
      t += (i.relative ? "h" : "H") + i.x;
    else if (i.type === Et.VERT_LINE_TO)
      t += (i.relative ? "v" : "V") + i.y;
    else if (i.type === Et.MOVE_TO)
      t += (i.relative ? "m" : "M") + i.x + " " + i.y;
    else if (i.type === Et.LINE_TO)
      t += (i.relative ? "l" : "L") + i.x + " " + i.y;
    else if (i.type === Et.CURVE_TO)
      t += (i.relative ? "c" : "C") + i.x1 + " " + i.y1 + " " + i.x2 + " " + i.y2 + " " + i.x + " " + i.y;
    else if (i.type === Et.SMOOTH_CURVE_TO)
      t += (i.relative ? "s" : "S") + i.x2 + " " + i.y2 + " " + i.x + " " + i.y;
    else if (i.type === Et.QUAD_TO)
      t += (i.relative ? "q" : "Q") + i.x1 + " " + i.y1 + " " + i.x + " " + i.y;
    else if (i.type === Et.SMOOTH_QUAD_TO)
      t += (i.relative ? "t" : "T") + i.x + " " + i.y;
    else {
      if (i.type !== Et.ARC)
        throw new Error('Unexpected command type "' + i.type + '" at index ' + e + ".");
      t += (i.relative ? "a" : "A") + i.rX + " " + i.rY + " " + i.xRot + " " + +i.lArcFlag + " " + +i.sweepFlag + " " + i.x + " " + i.y;
    }
  }
  return t;
}
function ig(s, t) {
  var e = s[0], i = s[1];
  return [e * Math.cos(t) - i * Math.sin(t), e * Math.sin(t) + i * Math.cos(t)];
}
function hr() {
  for (var s = [], t = 0; t < arguments.length; t++)
    s[t] = arguments[t];
  for (var e = 0; e < s.length; e++)
    if (typeof s[e] != "number")
      throw new Error("assertNumbers arguments[" + e + "] is not a number. " + typeof s[e] + " == typeof " + s[e]);
  return !0;
}
var Eo = Math.PI;
function yf(s, t, e) {
  s.lArcFlag = s.lArcFlag === 0 ? 0 : 1, s.sweepFlag = s.sweepFlag === 0 ? 0 : 1;
  var i = s.rX, n = s.rY, r = s.x, o = s.y;
  i = Math.abs(s.rX), n = Math.abs(s.rY);
  var l = ig([(t - r) / 2, (e - o) / 2], -s.xRot / 180 * Eo), h = l[0], u = l[1], d = Math.pow(h, 2) / Math.pow(i, 2) + Math.pow(u, 2) / Math.pow(n, 2);
  1 < d && (i *= Math.sqrt(d), n *= Math.sqrt(d)), s.rX = i, s.rY = n;
  var g = Math.pow(i, 2) * Math.pow(u, 2) + Math.pow(n, 2) * Math.pow(h, 2), y = (s.lArcFlag !== s.sweepFlag ? 1 : -1) * Math.sqrt(Math.max(0, (Math.pow(i, 2) * Math.pow(n, 2) - g) / g)), m = i * u / n * y, x = -n * h / i * y, b = ig([m, x], s.xRot / 180 * Eo);
  s.cX = b[0] + (t + r) / 2, s.cY = b[1] + (e + o) / 2, s.phi1 = Math.atan2((u - x) / n, (h - m) / i), s.phi2 = Math.atan2((-u - x) / n, (-h - m) / i), s.sweepFlag === 0 && s.phi2 > s.phi1 && (s.phi2 -= 2 * Eo), s.sweepFlag === 1 && s.phi2 < s.phi1 && (s.phi2 += 2 * Eo), s.phi1 *= 180 / Eo, s.phi2 *= 180 / Eo;
}
function sm(s, t, e) {
  hr(s, t, e);
  var i = s * s + t * t - e * e;
  if (0 > i)
    return [];
  if (i === 0)
    return [[s * e / (s * s + t * t), t * e / (s * s + t * t)]];
  var n = Math.sqrt(i);
  return [[(s * e + t * n) / (s * s + t * t), (t * e - s * n) / (s * s + t * t)], [(s * e - t * n) / (s * s + t * t), (t * e + s * n) / (s * s + t * t)]];
}
var pn, Qr = Math.PI / 180;
function rm(s, t, e) {
  return (1 - e) * s + e * t;
}
function om(s, t, e, i) {
  return s + Math.cos(i / 180 * Eo) * t + Math.sin(i / 180 * Eo) * e;
}
function am(s, t, e, i) {
  var n = 1e-6, r = t - s, o = e - t, l = 3 * r + 3 * (i - e) - 6 * o, h = 6 * (o - r), u = 3 * r;
  return Math.abs(l) < n ? [-u / h] : function(d, g, y) {
    var m = d * d / 4 - g;
    if (m < -y)
      return [];
    if (m <= y)
      return [-d / 2];
    var x = Math.sqrt(m);
    return [-d / 2 - x, -d / 2 + x];
  }(h / l, u / l, n);
}
function lm(s, t, e, i, n) {
  var r = 1 - n;
  return s * (r * r * r) + t * (3 * r * r * n) + e * (3 * r * n * n) + i * (n * n * n);
}
(function(s) {
  function t() {
    return n(function(l, h, u) {
      return l.relative && (l.x1 !== void 0 && (l.x1 += h), l.y1 !== void 0 && (l.y1 += u), l.x2 !== void 0 && (l.x2 += h), l.y2 !== void 0 && (l.y2 += u), l.x !== void 0 && (l.x += h), l.y !== void 0 && (l.y += u), l.relative = !1), l;
    });
  }
  function e() {
    var l = NaN, h = NaN, u = NaN, d = NaN;
    return n(function(g, y, m) {
      return g.type & Et.SMOOTH_CURVE_TO && (g.type = Et.CURVE_TO, l = isNaN(l) ? y : l, h = isNaN(h) ? m : h, g.x1 = g.relative ? y - l : 2 * y - l, g.y1 = g.relative ? m - h : 2 * m - h), g.type & Et.CURVE_TO ? (l = g.relative ? y + g.x2 : g.x2, h = g.relative ? m + g.y2 : g.y2) : (l = NaN, h = NaN), g.type & Et.SMOOTH_QUAD_TO && (g.type = Et.QUAD_TO, u = isNaN(u) ? y : u, d = isNaN(d) ? m : d, g.x1 = g.relative ? y - u : 2 * y - u, g.y1 = g.relative ? m - d : 2 * m - d), g.type & Et.QUAD_TO ? (u = g.relative ? y + g.x1 : g.x1, d = g.relative ? m + g.y1 : g.y1) : (u = NaN, d = NaN), g;
    });
  }
  function i() {
    var l = NaN, h = NaN;
    return n(function(u, d, g) {
      if (u.type & Et.SMOOTH_QUAD_TO && (u.type = Et.QUAD_TO, l = isNaN(l) ? d : l, h = isNaN(h) ? g : h, u.x1 = u.relative ? d - l : 2 * d - l, u.y1 = u.relative ? g - h : 2 * g - h), u.type & Et.QUAD_TO) {
        l = u.relative ? d + u.x1 : u.x1, h = u.relative ? g + u.y1 : u.y1;
        var y = u.x1, m = u.y1;
        u.type = Et.CURVE_TO, u.x1 = ((u.relative ? 0 : d) + 2 * y) / 3, u.y1 = ((u.relative ? 0 : g) + 2 * m) / 3, u.x2 = (u.x + 2 * y) / 3, u.y2 = (u.y + 2 * m) / 3;
      } else
        l = NaN, h = NaN;
      return u;
    });
  }
  function n(l) {
    var h = 0, u = 0, d = NaN, g = NaN;
    return function(y) {
      if (isNaN(d) && !(y.type & Et.MOVE_TO))
        throw new Error("path must start with moveto");
      var m = l(y, h, u, d, g);
      return y.type & Et.CLOSE_PATH && (h = d, u = g), y.x !== void 0 && (h = y.relative ? h + y.x : y.x), y.y !== void 0 && (u = y.relative ? u + y.y : y.y), y.type & Et.MOVE_TO && (d = h, g = u), m;
    };
  }
  function r(l, h, u, d, g, y) {
    return hr(l, h, u, d, g, y), n(function(m, x, b, I) {
      var C = m.x1, P = m.x2, k = m.relative && !isNaN(I), O = m.x !== void 0 ? m.x : k ? 0 : x, B = m.y !== void 0 ? m.y : k ? 0 : b;
      function j(ot) {
        return ot * ot;
      }
      m.type & Et.HORIZ_LINE_TO && h !== 0 && (m.type = Et.LINE_TO, m.y = m.relative ? 0 : b), m.type & Et.VERT_LINE_TO && u !== 0 && (m.type = Et.LINE_TO, m.x = m.relative ? 0 : x), m.x !== void 0 && (m.x = m.x * l + B * u + (k ? 0 : g)), m.y !== void 0 && (m.y = O * h + m.y * d + (k ? 0 : y)), m.x1 !== void 0 && (m.x1 = m.x1 * l + m.y1 * u + (k ? 0 : g)), m.y1 !== void 0 && (m.y1 = C * h + m.y1 * d + (k ? 0 : y)), m.x2 !== void 0 && (m.x2 = m.x2 * l + m.y2 * u + (k ? 0 : g)), m.y2 !== void 0 && (m.y2 = P * h + m.y2 * d + (k ? 0 : y));
      var V = l * d - h * u;
      if (m.xRot !== void 0 && (l !== 1 || h !== 0 || u !== 0 || d !== 1))
        if (V === 0)
          delete m.rX, delete m.rY, delete m.xRot, delete m.lArcFlag, delete m.sweepFlag, m.type = Et.LINE_TO;
        else {
          var Y = m.xRot * Math.PI / 180, q = Math.sin(Y), st = Math.cos(Y), dt = 1 / j(m.rX), U = 1 / j(m.rY), J = j(st) * dt + j(q) * U, A = 2 * q * st * (dt - U), R = j(q) * dt + j(st) * U, wt = J * d * d - A * h * d + R * h * h, z = A * (l * d + h * u) - 2 * (J * u * d + R * l * h), St = J * u * u - A * l * u + R * l * l, X = (Math.atan2(z, wt - St) + Math.PI) % Math.PI / 2, At = Math.sin(X), at = Math.cos(X);
          m.rX = Math.abs(V) / Math.sqrt(wt * j(at) + z * At * at + St * j(At)), m.rY = Math.abs(V) / Math.sqrt(wt * j(At) - z * At * at + St * j(at)), m.xRot = 180 * X / Math.PI;
        }
      return m.sweepFlag !== void 0 && 0 > V && (m.sweepFlag = +!m.sweepFlag), m;
    });
  }
  function o() {
    return function(l) {
      var h = {};
      for (var u in l)
        h[u] = l[u];
      return h;
    };
  }
  s.ROUND = function(l) {
    function h(u) {
      return Math.round(u * l) / l;
    }
    return l === void 0 && (l = 1e13), hr(l), function(u) {
      return u.x1 !== void 0 && (u.x1 = h(u.x1)), u.y1 !== void 0 && (u.y1 = h(u.y1)), u.x2 !== void 0 && (u.x2 = h(u.x2)), u.y2 !== void 0 && (u.y2 = h(u.y2)), u.x !== void 0 && (u.x = h(u.x)), u.y !== void 0 && (u.y = h(u.y)), u.rX !== void 0 && (u.rX = h(u.rX)), u.rY !== void 0 && (u.rY = h(u.rY)), u;
    };
  }, s.TO_ABS = t, s.TO_REL = function() {
    return n(function(l, h, u) {
      return l.relative || (l.x1 !== void 0 && (l.x1 -= h), l.y1 !== void 0 && (l.y1 -= u), l.x2 !== void 0 && (l.x2 -= h), l.y2 !== void 0 && (l.y2 -= u), l.x !== void 0 && (l.x -= h), l.y !== void 0 && (l.y -= u), l.relative = !0), l;
    });
  }, s.NORMALIZE_HVZ = function(l, h, u) {
    return l === void 0 && (l = !0), h === void 0 && (h = !0), u === void 0 && (u = !0), n(function(d, g, y, m, x) {
      if (isNaN(m) && !(d.type & Et.MOVE_TO))
        throw new Error("path must start with moveto");
      return h && d.type & Et.HORIZ_LINE_TO && (d.type = Et.LINE_TO, d.y = d.relative ? 0 : y), u && d.type & Et.VERT_LINE_TO && (d.type = Et.LINE_TO, d.x = d.relative ? 0 : g), l && d.type & Et.CLOSE_PATH && (d.type = Et.LINE_TO, d.x = d.relative ? m - g : m, d.y = d.relative ? x - y : x), d.type & Et.ARC && (d.rX === 0 || d.rY === 0) && (d.type = Et.LINE_TO, delete d.rX, delete d.rY, delete d.xRot, delete d.lArcFlag, delete d.sweepFlag), d;
    });
  }, s.NORMALIZE_ST = e, s.QT_TO_C = i, s.INFO = n, s.SANITIZE = function(l) {
    l === void 0 && (l = 0), hr(l);
    var h = NaN, u = NaN, d = NaN, g = NaN;
    return n(function(y, m, x, b, I) {
      var C = Math.abs, P = !1, k = 0, O = 0;
      if (y.type & Et.SMOOTH_CURVE_TO && (k = isNaN(h) ? 0 : m - h, O = isNaN(u) ? 0 : x - u), y.type & (Et.CURVE_TO | Et.SMOOTH_CURVE_TO) ? (h = y.relative ? m + y.x2 : y.x2, u = y.relative ? x + y.y2 : y.y2) : (h = NaN, u = NaN), y.type & Et.SMOOTH_QUAD_TO ? (d = isNaN(d) ? m : 2 * m - d, g = isNaN(g) ? x : 2 * x - g) : y.type & Et.QUAD_TO ? (d = y.relative ? m + y.x1 : y.x1, g = y.relative ? x + y.y1 : y.y2) : (d = NaN, g = NaN), y.type & Et.LINE_COMMANDS || y.type & Et.ARC && (y.rX === 0 || y.rY === 0 || !y.lArcFlag) || y.type & Et.CURVE_TO || y.type & Et.SMOOTH_CURVE_TO || y.type & Et.QUAD_TO || y.type & Et.SMOOTH_QUAD_TO) {
        var B = y.x === void 0 ? 0 : y.relative ? y.x : y.x - m, j = y.y === void 0 ? 0 : y.relative ? y.y : y.y - x;
        k = isNaN(d) ? y.x1 === void 0 ? k : y.relative ? y.x : y.x1 - m : d - m, O = isNaN(g) ? y.y1 === void 0 ? O : y.relative ? y.y : y.y1 - x : g - x;
        var V = y.x2 === void 0 ? 0 : y.relative ? y.x : y.x2 - m, Y = y.y2 === void 0 ? 0 : y.relative ? y.y : y.y2 - x;
        C(B) <= l && C(j) <= l && C(k) <= l && C(O) <= l && C(V) <= l && C(Y) <= l && (P = !0);
      }
      return y.type & Et.CLOSE_PATH && C(m - b) <= l && C(x - I) <= l && (P = !0), P ? [] : y;
    });
  }, s.MATRIX = r, s.ROTATE = function(l, h, u) {
    h === void 0 && (h = 0), u === void 0 && (u = 0), hr(l, h, u);
    var d = Math.sin(l), g = Math.cos(l);
    return r(g, d, -d, g, h - h * g + u * d, u - h * d - u * g);
  }, s.TRANSLATE = function(l, h) {
    return h === void 0 && (h = 0), hr(l, h), r(1, 0, 0, 1, l, h);
  }, s.SCALE = function(l, h) {
    return h === void 0 && (h = l), hr(l, h), r(l, 0, 0, h, 0, 0);
  }, s.SKEW_X = function(l) {
    return hr(l), r(1, 0, Math.atan(l), 1, 0, 0);
  }, s.SKEW_Y = function(l) {
    return hr(l), r(1, Math.atan(l), 0, 1, 0, 0);
  }, s.X_AXIS_SYMMETRY = function(l) {
    return l === void 0 && (l = 0), hr(l), r(-1, 0, 0, 1, l, 0);
  }, s.Y_AXIS_SYMMETRY = function(l) {
    return l === void 0 && (l = 0), hr(l), r(1, 0, 0, -1, 0, l);
  }, s.A_TO_C = function() {
    return n(function(l, h, u) {
      return Et.ARC === l.type ? function(d, g, y) {
        var m, x, b, I;
        d.cX || yf(d, g, y);
        for (var C = Math.min(d.phi1, d.phi2), P = Math.max(d.phi1, d.phi2) - C, k = Math.ceil(P / 90), O = new Array(k), B = g, j = y, V = 0; V < k; V++) {
          var Y = rm(d.phi1, d.phi2, V / k), q = rm(d.phi1, d.phi2, (V + 1) / k), st = q - Y, dt = 4 / 3 * Math.tan(st * Qr / 4), U = [Math.cos(Y * Qr) - dt * Math.sin(Y * Qr), Math.sin(Y * Qr) + dt * Math.cos(Y * Qr)], J = U[0], A = U[1], R = [Math.cos(q * Qr), Math.sin(q * Qr)], wt = R[0], z = R[1], St = [wt + dt * Math.sin(q * Qr), z - dt * Math.cos(q * Qr)], X = St[0], At = St[1];
          O[V] = { relative: d.relative, type: Et.CURVE_TO };
          var at = function(ot, Ut) {
            var Pt = ig([ot * d.rX, Ut * d.rY], d.xRot), Lt = Pt[0], Je = Pt[1];
            return [d.cX + Lt, d.cY + Je];
          };
          m = at(J, A), O[V].x1 = m[0], O[V].y1 = m[1], x = at(X, At), O[V].x2 = x[0], O[V].y2 = x[1], b = at(wt, z), O[V].x = b[0], O[V].y = b[1], d.relative && (O[V].x1 -= B, O[V].y1 -= j, O[V].x2 -= B, O[V].y2 -= j, O[V].x -= B, O[V].y -= j), B = (I = [O[V].x, O[V].y])[0], j = I[1];
        }
        return O;
      }(l, l.relative ? 0 : h, l.relative ? 0 : u) : l;
    });
  }, s.ANNOTATE_ARCS = function() {
    return n(function(l, h, u) {
      return l.relative && (h = 0, u = 0), Et.ARC === l.type && yf(l, h, u), l;
    });
  }, s.CLONE = o, s.CALCULATE_BOUNDS = function() {
    var l = function(y) {
      var m = {};
      for (var x in y)
        m[x] = y[x];
      return m;
    }, h = t(), u = i(), d = e(), g = n(function(y, m, x) {
      var b = d(u(h(l(y))));
      function I(At) {
        At > g.maxX && (g.maxX = At), At < g.minX && (g.minX = At);
      }
      function C(At) {
        At > g.maxY && (g.maxY = At), At < g.minY && (g.minY = At);
      }
      if (b.type & Et.DRAWING_COMMANDS && (I(m), C(x)), b.type & Et.HORIZ_LINE_TO && I(b.x), b.type & Et.VERT_LINE_TO && C(b.y), b.type & Et.LINE_TO && (I(b.x), C(b.y)), b.type & Et.CURVE_TO) {
        I(b.x), C(b.y);
        for (var P = 0, k = am(m, b.x1, b.x2, b.x); P < k.length; P++)
          0 < (X = k[P]) && 1 > X && I(lm(m, b.x1, b.x2, b.x, X));
        for (var O = 0, B = am(x, b.y1, b.y2, b.y); O < B.length; O++)
          0 < (X = B[O]) && 1 > X && C(lm(x, b.y1, b.y2, b.y, X));
      }
      if (b.type & Et.ARC) {
        I(b.x), C(b.y), yf(b, m, x);
        for (var j = b.xRot / 180 * Math.PI, V = Math.cos(j) * b.rX, Y = Math.sin(j) * b.rX, q = -Math.sin(j) * b.rY, st = Math.cos(j) * b.rY, dt = b.phi1 < b.phi2 ? [b.phi1, b.phi2] : -180 > b.phi2 ? [b.phi2 + 360, b.phi1 + 360] : [b.phi2, b.phi1], U = dt[0], J = dt[1], A = function(At) {
          var at = At[0], ot = At[1], Ut = 180 * Math.atan2(ot, at) / Math.PI;
          return Ut < U ? Ut + 360 : Ut;
        }, R = 0, wt = sm(q, -V, 0).map(A); R < wt.length; R++)
          (X = wt[R]) > U && X < J && I(om(b.cX, V, q, X));
        for (var z = 0, St = sm(st, -Y, 0).map(A); z < St.length; z++) {
          var X;
          (X = St[z]) > U && X < J && C(om(b.cY, Y, st, X));
        }
      }
      return y;
    });
    return g.minX = 1 / 0, g.maxX = -1 / 0, g.minY = 1 / 0, g.maxY = -1 / 0, g;
  };
})(pn || (pn = {}));
var or, Jy = function() {
  function s() {
  }
  return s.prototype.round = function(t) {
    return this.transform(pn.ROUND(t));
  }, s.prototype.toAbs = function() {
    return this.transform(pn.TO_ABS());
  }, s.prototype.toRel = function() {
    return this.transform(pn.TO_REL());
  }, s.prototype.normalizeHVZ = function(t, e, i) {
    return this.transform(pn.NORMALIZE_HVZ(t, e, i));
  }, s.prototype.normalizeST = function() {
    return this.transform(pn.NORMALIZE_ST());
  }, s.prototype.qtToC = function() {
    return this.transform(pn.QT_TO_C());
  }, s.prototype.aToC = function() {
    return this.transform(pn.A_TO_C());
  }, s.prototype.sanitize = function(t) {
    return this.transform(pn.SANITIZE(t));
  }, s.prototype.translate = function(t, e) {
    return this.transform(pn.TRANSLATE(t, e));
  }, s.prototype.scale = function(t, e) {
    return this.transform(pn.SCALE(t, e));
  }, s.prototype.rotate = function(t, e, i) {
    return this.transform(pn.ROTATE(t, e, i));
  }, s.prototype.matrix = function(t, e, i, n, r, o) {
    return this.transform(pn.MATRIX(t, e, i, n, r, o));
  }, s.prototype.skewX = function(t) {
    return this.transform(pn.SKEW_X(t));
  }, s.prototype.skewY = function(t) {
    return this.transform(pn.SKEW_Y(t));
  }, s.prototype.xSymmetry = function(t) {
    return this.transform(pn.X_AXIS_SYMMETRY(t));
  }, s.prototype.ySymmetry = function(t) {
    return this.transform(pn.Y_AXIS_SYMMETRY(t));
  }, s.prototype.annotateArcs = function() {
    return this.transform(pn.ANNOTATE_ARCS());
  }, s;
}(), wI = function(s) {
  return s === " " || s === "	" || s === "\r" || s === `
`;
}, cm = function(s) {
  return 48 <= s.charCodeAt(0) && s.charCodeAt(0) <= 57;
}, vI = function(s) {
  function t() {
    var e = s.call(this) || this;
    return e.curNumber = "", e.curCommandType = -1, e.curCommandRelative = !1, e.canParseCommandOrComma = !0, e.curNumberHasExp = !1, e.curNumberHasExpDigits = !1, e.curNumberHasDecimal = !1, e.curArgs = [], e;
  }
  return Xy(t, s), t.prototype.finish = function(e) {
    if (e === void 0 && (e = []), this.parse(" ", e), this.curArgs.length !== 0 || !this.canParseCommandOrComma)
      throw new SyntaxError("Unterminated command at the path end.");
    return e;
  }, t.prototype.parse = function(e, i) {
    var n = this;
    i === void 0 && (i = []);
    for (var r = function(g) {
      i.push(g), n.curArgs.length = 0, n.canParseCommandOrComma = !0;
    }, o = 0; o < e.length; o++) {
      var l = e[o], h = !(this.curCommandType !== Et.ARC || this.curArgs.length !== 3 && this.curArgs.length !== 4 || this.curNumber.length !== 1 || this.curNumber !== "0" && this.curNumber !== "1"), u = cm(l) && (this.curNumber === "0" && l === "0" || h);
      if (!cm(l) || u)
        if (l !== "e" && l !== "E")
          if (l !== "-" && l !== "+" || !this.curNumberHasExp || this.curNumberHasExpDigits)
            if (l !== "." || this.curNumberHasExp || this.curNumberHasDecimal || h) {
              if (this.curNumber && this.curCommandType !== -1) {
                var d = Number(this.curNumber);
                if (isNaN(d))
                  throw new SyntaxError("Invalid number ending at " + o);
                if (this.curCommandType === Et.ARC) {
                  if (this.curArgs.length === 0 || this.curArgs.length === 1) {
                    if (0 > d)
                      throw new SyntaxError('Expected positive number, got "' + d + '" at index "' + o + '"');
                  } else if ((this.curArgs.length === 3 || this.curArgs.length === 4) && this.curNumber !== "0" && this.curNumber !== "1")
                    throw new SyntaxError('Expected a flag, got "' + this.curNumber + '" at index "' + o + '"');
                }
                this.curArgs.push(d), this.curArgs.length === bI[this.curCommandType] && (Et.HORIZ_LINE_TO === this.curCommandType ? r({ type: Et.HORIZ_LINE_TO, relative: this.curCommandRelative, x: d }) : Et.VERT_LINE_TO === this.curCommandType ? r({ type: Et.VERT_LINE_TO, relative: this.curCommandRelative, y: d }) : this.curCommandType === Et.MOVE_TO || this.curCommandType === Et.LINE_TO || this.curCommandType === Et.SMOOTH_QUAD_TO ? (r({ type: this.curCommandType, relative: this.curCommandRelative, x: this.curArgs[0], y: this.curArgs[1] }), Et.MOVE_TO === this.curCommandType && (this.curCommandType = Et.LINE_TO)) : this.curCommandType === Et.CURVE_TO ? r({ type: Et.CURVE_TO, relative: this.curCommandRelative, x1: this.curArgs[0], y1: this.curArgs[1], x2: this.curArgs[2], y2: this.curArgs[3], x: this.curArgs[4], y: this.curArgs[5] }) : this.curCommandType === Et.SMOOTH_CURVE_TO ? r({ type: Et.SMOOTH_CURVE_TO, relative: this.curCommandRelative, x2: this.curArgs[0], y2: this.curArgs[1], x: this.curArgs[2], y: this.curArgs[3] }) : this.curCommandType === Et.QUAD_TO ? r({ type: Et.QUAD_TO, relative: this.curCommandRelative, x1: this.curArgs[0], y1: this.curArgs[1], x: this.curArgs[2], y: this.curArgs[3] }) : this.curCommandType === Et.ARC && r({ type: Et.ARC, relative: this.curCommandRelative, rX: this.curArgs[0], rY: this.curArgs[1], xRot: this.curArgs[2], lArcFlag: this.curArgs[3], sweepFlag: this.curArgs[4], x: this.curArgs[5], y: this.curArgs[6] })), this.curNumber = "", this.curNumberHasExpDigits = !1, this.curNumberHasExp = !1, this.curNumberHasDecimal = !1, this.canParseCommandOrComma = !0;
              }
              if (!wI(l))
                if (l === "," && this.canParseCommandOrComma)
                  this.canParseCommandOrComma = !1;
                else if (l !== "+" && l !== "-" && l !== ".")
                  if (u)
                    this.curNumber = l, this.curNumberHasDecimal = !1;
                  else {
                    if (this.curArgs.length !== 0)
                      throw new SyntaxError("Unterminated command at index " + o + ".");
                    if (!this.canParseCommandOrComma)
                      throw new SyntaxError('Unexpected character "' + l + '" at index ' + o + ". Command cannot follow comma");
                    if (this.canParseCommandOrComma = !1, l !== "z" && l !== "Z")
                      if (l === "h" || l === "H")
                        this.curCommandType = Et.HORIZ_LINE_TO, this.curCommandRelative = l === "h";
                      else if (l === "v" || l === "V")
                        this.curCommandType = Et.VERT_LINE_TO, this.curCommandRelative = l === "v";
                      else if (l === "m" || l === "M")
                        this.curCommandType = Et.MOVE_TO, this.curCommandRelative = l === "m";
                      else if (l === "l" || l === "L")
                        this.curCommandType = Et.LINE_TO, this.curCommandRelative = l === "l";
                      else if (l === "c" || l === "C")
                        this.curCommandType = Et.CURVE_TO, this.curCommandRelative = l === "c";
                      else if (l === "s" || l === "S")
                        this.curCommandType = Et.SMOOTH_CURVE_TO, this.curCommandRelative = l === "s";
                      else if (l === "q" || l === "Q")
                        this.curCommandType = Et.QUAD_TO, this.curCommandRelative = l === "q";
                      else if (l === "t" || l === "T")
                        this.curCommandType = Et.SMOOTH_QUAD_TO, this.curCommandRelative = l === "t";
                      else {
                        if (l !== "a" && l !== "A")
                          throw new SyntaxError('Unexpected character "' + l + '" at index ' + o + ".");
                        this.curCommandType = Et.ARC, this.curCommandRelative = l === "a";
                      }
                    else
                      i.push({ type: Et.CLOSE_PATH }), this.canParseCommandOrComma = !0, this.curCommandType = -1;
                  }
                else
                  this.curNumber = l, this.curNumberHasDecimal = l === ".";
            } else
              this.curNumber += l, this.curNumberHasDecimal = !0;
          else
            this.curNumber += l;
        else
          this.curNumber += l, this.curNumberHasExp = !0;
      else
        this.curNumber += l, this.curNumberHasExpDigits = this.curNumberHasExp;
    }
    return i;
  }, t.prototype.transform = function(e) {
    return Object.create(this, { parse: { value: function(i, n) {
      n === void 0 && (n = []);
      for (var r = 0, o = Object.getPrototypeOf(this).parse.call(this, i); r < o.length; r++) {
        var l = o[r], h = e(l);
        Array.isArray(h) ? n.push.apply(n, h) : n.push(h);
      }
      return n;
    } } });
  }, t;
}(Jy), Et = function(s) {
  function t(e) {
    var i = s.call(this) || this;
    return i.commands = typeof e == "string" ? t.parse(e) : e, i;
  }
  return Xy(t, s), t.prototype.encode = function() {
    return t.encode(this.commands);
  }, t.prototype.getBounds = function() {
    var e = pn.CALCULATE_BOUNDS();
    return this.transform(e), e;
  }, t.prototype.transform = function(e) {
    for (var i = [], n = 0, r = this.commands; n < r.length; n++) {
      var o = e(r[n]);
      Array.isArray(o) ? i.push.apply(i, o) : i.push(o);
    }
    return this.commands = i, this;
  }, t.encode = function(e) {
    return yI(e);
  }, t.parse = function(e) {
    var i = new vI(), n = [];
    return i.parse(e, n), i.finish(n), n;
  }, t.CLOSE_PATH = 1, t.MOVE_TO = 2, t.HORIZ_LINE_TO = 4, t.VERT_LINE_TO = 8, t.LINE_TO = 16, t.CURVE_TO = 32, t.SMOOTH_CURVE_TO = 64, t.QUAD_TO = 128, t.SMOOTH_QUAD_TO = 256, t.ARC = 512, t.LINE_COMMANDS = t.LINE_TO | t.HORIZ_LINE_TO | t.VERT_LINE_TO, t.DRAWING_COMMANDS = t.HORIZ_LINE_TO | t.VERT_LINE_TO | t.LINE_TO | t.CURVE_TO | t.SMOOTH_CURVE_TO | t.QUAD_TO | t.SMOOTH_QUAD_TO | t.ARC, t;
}(Jy), bI = ((or = {})[Et.MOVE_TO] = 2, or[Et.LINE_TO] = 2, or[Et.HORIZ_LINE_TO] = 1, or[Et.VERT_LINE_TO] = 1, or[Et.CLOSE_PATH] = 0, or[Et.QUAD_TO] = 4, or[Et.SMOOTH_QUAD_TO] = 2, or[Et.CURVE_TO] = 6, or[Et.SMOOTH_CURVE_TO] = 4, or[Et.ARC] = 7, or);
function Lu(s) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Lu = function(t) {
    return typeof t;
  } : Lu = function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Lu(s);
}
function xI(s, t) {
  if (!(s instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
var II = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259], CI = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];
function SI(s, t, e, i, n) {
  if (typeof s == "string" && (s = document.getElementById(s)), !s || Lu(s) !== "object" || !("getContext" in s))
    throw new TypeError("Expecting canvas with `getContext` method in processCanvasRGB(A) calls!");
  var r = s.getContext("2d");
  try {
    return r.getImageData(t, e, i, n);
  } catch (o) {
    throw new Error("unable to access image data: " + o);
  }
}
function PI(s, t, e, i, n, r) {
  if (!(isNaN(r) || r < 1)) {
    r |= 0;
    var o = SI(s, t, e, i, n);
    o = kI(o, t, e, i, n, r), s.getContext("2d").putImageData(o, t, e);
  }
}
function kI(s, t, e, i, n, r) {
  for (var o = s.data, l = 2 * r + 1, h = i - 1, u = n - 1, d = r + 1, g = d * (d + 1) / 2, y = new hm(), m = y, x, b = 1; b < l; b++)
    m = m.next = new hm(), b === d && (x = m);
  m.next = y;
  for (var I = null, C = null, P = 0, k = 0, O = II[r], B = CI[r], j = 0; j < n; j++) {
    m = y;
    for (var V = o[k], Y = o[k + 1], q = o[k + 2], st = o[k + 3], dt = 0; dt < d; dt++)
      m.r = V, m.g = Y, m.b = q, m.a = st, m = m.next;
    for (var U = 0, J = 0, A = 0, R = 0, wt = d * V, z = d * Y, St = d * q, X = d * st, At = g * V, at = g * Y, ot = g * q, Ut = g * st, Pt = 1; Pt < d; Pt++) {
      var Lt = k + ((h < Pt ? h : Pt) << 2), Je = o[Lt], Bi = o[Lt + 1], re = o[Lt + 2], xe = o[Lt + 3], He = d - Pt;
      At += (m.r = Je) * He, at += (m.g = Bi) * He, ot += (m.b = re) * He, Ut += (m.a = xe) * He, U += Je, J += Bi, A += re, R += xe, m = m.next;
    }
    I = y, C = x;
    for (var Be = 0; Be < i; Be++) {
      var Ne = Ut * O >>> B;
      if (o[k + 3] = Ne, Ne !== 0) {
        var cn = 255 / Ne;
        o[k] = (At * O >>> B) * cn, o[k + 1] = (at * O >>> B) * cn, o[k + 2] = (ot * O >>> B) * cn;
      } else
        o[k] = o[k + 1] = o[k + 2] = 0;
      At -= wt, at -= z, ot -= St, Ut -= X, wt -= I.r, z -= I.g, St -= I.b, X -= I.a;
      var T = Be + r + 1;
      T = P + (T < h ? T : h) << 2, U += I.r = o[T], J += I.g = o[T + 1], A += I.b = o[T + 2], R += I.a = o[T + 3], At += U, at += J, ot += A, Ut += R, I = I.next;
      var _t = C, ft = _t.r, $ = _t.g, W = _t.b, nt = _t.a;
      wt += ft, z += $, St += W, X += nt, U -= ft, J -= $, A -= W, R -= nt, C = C.next, k += 4;
    }
    P += i;
  }
  for (var bt = 0; bt < i; bt++) {
    k = bt << 2;
    var It = o[k], rt = o[k + 1], xt = o[k + 2], Rt = o[k + 3], Dt = d * It, Ht = d * rt, Ue = d * xt, pe = d * Rt, sn = g * It, kn = g * rt, $i = g * xt, es = g * Rt;
    m = y;
    for (var ai = 0; ai < d; ai++)
      m.r = It, m.g = rt, m.b = xt, m.a = Rt, m = m.next;
    for (var Vs = i, zs = 0, Fn = 0, Qt = 0, Bn = 0, Vn = 1; Vn <= r; Vn++) {
      k = Vs + bt << 2;
      var ls = d - Vn;
      sn += (m.r = It = o[k]) * ls, kn += (m.g = rt = o[k + 1]) * ls, $i += (m.b = xt = o[k + 2]) * ls, es += (m.a = Rt = o[k + 3]) * ls, Bn += It, zs += rt, Fn += xt, Qt += Rt, m = m.next, Vn < u && (Vs += i);
    }
    k = bt, I = y, C = x;
    for (var qi = 0; qi < n; qi++) {
      var Ti = k << 2;
      o[Ti + 3] = Rt = es * O >>> B, Rt > 0 ? (Rt = 255 / Rt, o[Ti] = (sn * O >>> B) * Rt, o[Ti + 1] = (kn * O >>> B) * Rt, o[Ti + 2] = ($i * O >>> B) * Rt) : o[Ti] = o[Ti + 1] = o[Ti + 2] = 0, sn -= Dt, kn -= Ht, $i -= Ue, es -= pe, Dt -= I.r, Ht -= I.g, Ue -= I.b, pe -= I.a, Ti = bt + ((Ti = qi + d) < u ? Ti : u) * i << 2, sn += Bn += I.r = o[Ti], kn += zs += I.g = o[Ti + 1], $i += Fn += I.b = o[Ti + 2], es += Qt += I.a = o[Ti + 3], I = I.next, Dt += It = C.r, Ht += rt = C.g, Ue += xt = C.b, pe += Rt = C.a, Bn -= It, zs -= rt, Fn -= xt, Qt -= Rt, C = C.next, k += i;
    }
  }
  return s;
}
var hm = (
  /**
   * Set properties.
   */
  function s() {
    xI(this, s), this.r = 0, this.g = 0, this.b = 0, this.a = 0, this.next = null;
  }
);
function Bl(s) {
  return s.replace(/(?!\u3000)\s+/gm, " ");
}
function MI(s) {
  return s.replace(/^[\n \t]+/, "");
}
function EI(s) {
  return s.replace(/[\n \t]+$/, "");
}
function Fs(s) {
  const t = s.match(/-?(\d+(?:\.\d*(?:[eE][+-]?\d+)?)?|\.\d+)(?=\D|$)/gm);
  return t ? t.map(parseFloat) : [];
}
function AI(s) {
  const t = Fs(s);
  return [
    t[0] || 0,
    t[1] || 0,
    t[2] || 0,
    t[3] || 0,
    t[4] || 0,
    t[5] || 0
  ];
}
const TI = /^[A-Z-]+$/;
function NI(s) {
  return TI.test(s) ? s.toLowerCase() : s;
}
function Yy(s) {
  const t = /url\(('([^']+)'|"([^"]+)"|([^'")]+))\)/.exec(s);
  return t && (t[2] || t[3] || t[4]) || "";
}
function DI(s) {
  if (!s.startsWith("rgb"))
    return s;
  let t = 3;
  return s.replace(
    /\d+(\.\d+)?/g,
    (i, n) => t-- && n ? String(Math.round(parseFloat(i))) : i
  );
}
const OI = /(\[[^\]]+\])/g, RI = /(#[^\s+>~.[:]+)/g, LI = /(\.[^\s+>~.[:]+)/g, FI = /(::[^\s+>~.[:]+|:first-line|:first-letter|:before|:after)/gi, BI = /(:[\w-]+\([^)]*\))/gi, VI = /(:[^\s+>~.[:]+)/g, zI = /([^\s+>~.[:]+)/g;
function aa(s, t) {
  const e = t.exec(s);
  return e ? [
    s.replace(t, " "),
    e.length
  ] : [
    s,
    0
  ];
}
function HI(s) {
  const t = [
    0,
    0,
    0
  ];
  let e = s.replace(/:not\(([^)]*)\)/g, "     $1 ").replace(/{[\s\S]*/gm, " "), i = 0;
  return [e, i] = aa(e, OI), t[1] += i, [e, i] = aa(e, RI), t[0] += i, [e, i] = aa(e, LI), t[1] += i, [e, i] = aa(e, FI), t[2] += i, [e, i] = aa(e, BI), t[1] += i, [e, i] = aa(e, VI), t[1] += i, e = e.replace(/[*\s+>~]/g, " ").replace(/[#.]/g, " "), [e, i] = aa(e, zI), t[2] += i, t.join("");
}
const _l = 1e-8;
function um(s) {
  return Math.sqrt(Math.pow(s[0], 2) + Math.pow(s[1], 2));
}
function ng(s, t) {
  return (s[0] * t[0] + s[1] * t[1]) / (um(s) * um(t));
}
function dm(s, t) {
  return (s[0] * t[1] < s[1] * t[0] ? -1 : 1) * Math.acos(ng(s, t));
}
function fm(s) {
  return s * s * s;
}
function gm(s) {
  return 3 * s * s * (1 - s);
}
function pm(s) {
  return 3 * s * (1 - s) * (1 - s);
}
function mm(s) {
  return (1 - s) * (1 - s) * (1 - s);
}
function _m(s) {
  return s * s;
}
function ym(s) {
  return 2 * s * (1 - s);
}
function wm(s) {
  return (1 - s) * (1 - s);
}
class se {
  static empty(t) {
    return new se(t, "EMPTY", "");
  }
  split() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : " ";
    const { document: e, name: i } = this;
    return Bl(this.getString()).trim().split(t).map(
      (n) => new se(e, i, n)
    );
  }
  hasValue(t) {
    const e = this.value;
    return e !== null && e !== "" && (t || e !== 0) && typeof e < "u";
  }
  isString(t) {
    const { value: e } = this, i = typeof e == "string";
    return !i || !t ? i : t.test(e);
  }
  isUrlDefinition() {
    return this.isString(/^url\(/);
  }
  isPixels() {
    if (!this.hasValue())
      return !1;
    const t = this.getString();
    switch (!0) {
      case t.endsWith("px"):
      case /^[0-9]+$/.test(t):
        return !0;
      default:
        return !1;
    }
  }
  setValue(t) {
    return this.value = t, this;
  }
  getValue(t) {
    return typeof t > "u" || this.hasValue() ? this.value : t;
  }
  getNumber(t) {
    if (!this.hasValue())
      return typeof t > "u" ? 0 : parseFloat(t);
    const { value: e } = this;
    let i = parseFloat(e);
    return this.isString(/%$/) && (i /= 100), i;
  }
  getString(t) {
    return typeof t > "u" || this.hasValue() ? typeof this.value > "u" ? "" : String(this.value) : String(t);
  }
  getColor(t) {
    let e = this.getString(t);
    return this.isNormalizedColor || (this.isNormalizedColor = !0, e = DI(e), this.value = e), e;
  }
  getDpi() {
    return 96;
  }
  getRem() {
    return this.document.rootEmSize;
  }
  getEm() {
    return this.document.emSize;
  }
  getUnits() {
    return this.getString().replace(/[0-9.-]/g, "");
  }
  getPixels(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    if (!this.hasValue())
      return 0;
    const [i, n] = typeof t == "boolean" ? [
      void 0,
      t
    ] : [
      t
    ], { viewPort: r } = this.document.screen;
    switch (!0) {
      case this.isString(/vmin$/):
        return this.getNumber() / 100 * Math.min(r.computeSize("x"), r.computeSize("y"));
      case this.isString(/vmax$/):
        return this.getNumber() / 100 * Math.max(r.computeSize("x"), r.computeSize("y"));
      case this.isString(/vw$/):
        return this.getNumber() / 100 * r.computeSize("x");
      case this.isString(/vh$/):
        return this.getNumber() / 100 * r.computeSize("y");
      case this.isString(/rem$/):
        return this.getNumber() * this.getRem();
      case this.isString(/em$/):
        return this.getNumber() * this.getEm();
      case this.isString(/ex$/):
        return this.getNumber() * this.getEm() / 2;
      case this.isString(/px$/):
        return this.getNumber();
      case this.isString(/pt$/):
        return this.getNumber() * this.getDpi() * (1 / 72);
      case this.isString(/pc$/):
        return this.getNumber() * 15;
      case this.isString(/cm$/):
        return this.getNumber() * this.getDpi() / 2.54;
      case this.isString(/mm$/):
        return this.getNumber() * this.getDpi() / 25.4;
      case this.isString(/in$/):
        return this.getNumber() * this.getDpi();
      case (this.isString(/%$/) && n):
        return this.getNumber() * this.getEm();
      case this.isString(/%$/):
        return this.getNumber() * r.computeSize(i);
      default: {
        const o = this.getNumber();
        return e && o < 1 ? o * r.computeSize(i) : o;
      }
    }
  }
  getMilliseconds() {
    return this.hasValue() ? this.isString(/ms$/) ? this.getNumber() : this.getNumber() * 1e3 : 0;
  }
  getRadians() {
    if (!this.hasValue())
      return 0;
    switch (!0) {
      case this.isString(/deg$/):
        return this.getNumber() * (Math.PI / 180);
      case this.isString(/grad$/):
        return this.getNumber() * (Math.PI / 200);
      case this.isString(/rad$/):
        return this.getNumber();
      default:
        return this.getNumber() * (Math.PI / 180);
    }
  }
  getDefinition() {
    const t = this.getString(), e = /#([^)'"]+)/.exec(t), i = (e == null ? void 0 : e[1]) || t;
    return this.document.definitions[i];
  }
  getFillStyleDefinition(t, e) {
    let i = this.getDefinition();
    if (!i)
      return null;
    if (typeof i.createGradient == "function" && "getBoundingBox" in t)
      return i.createGradient(this.document.ctx, t, e);
    if (typeof i.createPattern == "function") {
      if (i.getHrefAttribute().hasValue()) {
        const n = i.getAttribute("patternTransform");
        i = i.getHrefAttribute().getDefinition(), i && n.hasValue() && i.getAttribute("patternTransform", !0).setValue(n.value);
      }
      if (i)
        return i.createPattern(this.document.ctx, t, e);
    }
    return null;
  }
  getTextBaseline() {
    if (!this.hasValue())
      return null;
    const t = this.getString();
    return se.textBaselineMapping[t] || null;
  }
  addOpacity(t) {
    let e = this.getColor();
    const i = e.length;
    let n = 0;
    for (let r = 0; r < i && (e[r] === "," && n++, n !== 3); r++)
      ;
    if (t.hasValue() && this.isString() && n !== 3) {
      const r = new eg(e);
      r.ok && (r.alpha = t.getNumber(), e = r.toRGBA());
    }
    return new se(this.document, this.name, e);
  }
  constructor(t, e, i) {
    this.document = t, this.name = e, this.value = i, this.isNormalizedColor = !1;
  }
}
se.textBaselineMapping = {
  baseline: "alphabetic",
  "before-edge": "top",
  "text-before-edge": "top",
  middle: "middle",
  central: "middle",
  "after-edge": "bottom",
  "text-after-edge": "bottom",
  ideographic: "ideographic",
  alphabetic: "alphabetic",
  hanging: "hanging",
  mathematical: "alphabetic"
};
class mh {
  clear() {
    this.viewPorts = [];
  }
  setCurrent(t, e) {
    this.viewPorts.push({
      width: t,
      height: e
    });
  }
  removeCurrent() {
    this.viewPorts.pop();
  }
  getRoot() {
    const [t] = this.viewPorts;
    return t || vm();
  }
  getCurrent() {
    const { viewPorts: t } = this, e = t[t.length - 1];
    return e || vm();
  }
  get width() {
    return this.getCurrent().width;
  }
  get height() {
    return this.getCurrent().height;
  }
  computeSize(t) {
    return typeof t == "number" ? t : t === "x" ? this.width : t === "y" ? this.height : Math.sqrt(Math.pow(this.width, 2) + Math.pow(this.height, 2)) / Math.sqrt(2);
  }
  constructor() {
    this.viewPorts = [];
  }
}
mh.DEFAULT_VIEWPORT_WIDTH = 800;
mh.DEFAULT_VIEWPORT_HEIGHT = 600;
function vm() {
  return {
    width: mh.DEFAULT_VIEWPORT_WIDTH,
    height: mh.DEFAULT_VIEWPORT_HEIGHT
  };
}
class Hi {
  static parse(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    const [i = e, n = e] = Fs(t);
    return new Hi(i, n);
  }
  static parseScale(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    const [i = e, n = i] = Fs(t);
    return new Hi(i, n);
  }
  static parsePath(t) {
    const e = Fs(t), i = e.length, n = [];
    for (let r = 0; r < i; r += 2)
      n.push(new Hi(e[r], e[r + 1]));
    return n;
  }
  angleTo(t) {
    return Math.atan2(t.y - this.y, t.x - this.x);
  }
  applyTransform(t) {
    const { x: e, y: i } = this, n = e * t[0] + i * t[2] + t[4], r = e * t[1] + i * t[3] + t[5];
    this.x = n, this.y = r;
  }
  constructor(t, e) {
    this.x = t, this.y = e;
  }
}
class UI {
  isWorking() {
    return this.working;
  }
  start() {
    if (this.working)
      return;
    const { screen: t, onClick: e, onMouseMove: i } = this, n = t.ctx.canvas;
    n.onclick = e, n.onmousemove = i, this.working = !0;
  }
  stop() {
    if (!this.working)
      return;
    const t = this.screen.ctx.canvas;
    this.working = !1, t.onclick = null, t.onmousemove = null;
  }
  hasEvents() {
    return this.working && this.events.length > 0;
  }
  runEvents() {
    if (!this.working)
      return;
    const { screen: t, events: e, eventElements: i } = this, { style: n } = t.ctx.canvas;
    let r;
    n && (n.cursor = ""), e.forEach((o, l) => {
      let { run: h } = o;
      for (r = i[l]; r; )
        h(r), r = r.parent;
    }), this.events = [], this.eventElements = [];
  }
  checkPath(t, e) {
    if (!this.working || !e)
      return;
    const { events: i, eventElements: n } = this;
    i.forEach((r, o) => {
      let { x: l, y: h } = r;
      !n[o] && e.isPointInPath && e.isPointInPath(l, h) && (n[o] = t);
    });
  }
  checkBoundingBox(t, e) {
    if (!this.working || !e)
      return;
    const { events: i, eventElements: n } = this;
    i.forEach((r, o) => {
      let { x: l, y: h } = r;
      !n[o] && e.isPointInBox(l, h) && (n[o] = t);
    });
  }
  mapXY(t, e) {
    const { window: i, ctx: n } = this.screen, r = new Hi(t, e);
    let o = n.canvas;
    for (; o; )
      r.x -= o.offsetLeft, r.y -= o.offsetTop, o = o.offsetParent;
    return i != null && i.scrollX && (r.x += i.scrollX), i != null && i.scrollY && (r.y += i.scrollY), r;
  }
  onClick(t) {
    const { x: e, y: i } = this.mapXY(t.clientX, t.clientY);
    this.events.push({
      type: "onclick",
      x: e,
      y: i,
      run(n) {
        n.onClick && n.onClick();
      }
    });
  }
  onMouseMove(t) {
    const { x: e, y: i } = this.mapXY(t.clientX, t.clientY);
    this.events.push({
      type: "onmousemove",
      x: e,
      y: i,
      run(n) {
        n.onMouseMove && n.onMouseMove();
      }
    });
  }
  constructor(t) {
    this.screen = t, this.working = !1, this.events = [], this.eventElements = [], this.onClick = this.onClick.bind(this), this.onMouseMove = this.onMouseMove.bind(this);
  }
}
const Zy = typeof window < "u" ? window : null, Qy = typeof fetch < "u" ? fetch.bind(void 0) : void 0;
class po {
  wait(t) {
    this.waits.push(t);
  }
  ready() {
    return this.readyPromise ? this.readyPromise : Promise.resolve();
  }
  isReady() {
    if (this.isReadyLock)
      return !0;
    const t = this.waits.every(
      (e) => e()
    );
    return t && (this.waits = [], this.resolveReady && this.resolveReady()), this.isReadyLock = t, t;
  }
  setDefaults(t) {
    t.strokeStyle = "rgba(0,0,0,0)", t.lineCap = "butt", t.lineJoin = "miter", t.miterLimit = 4;
  }
  setViewBox(t) {
    let { document: e, ctx: i, aspectRatio: n, width: r, desiredWidth: o, height: l, desiredHeight: h, minX: u = 0, minY: d = 0, refX: g, refY: y, clip: m = !1, clipX: x = 0, clipY: b = 0 } = t;
    const I = Bl(n).replace(/^defer\s/, ""), [C, P] = I.split(" "), k = C || "xMidYMid", O = P || "meet", B = r / o, j = l / h, V = Math.min(B, j), Y = Math.max(B, j);
    let q = o, st = h;
    O === "meet" && (q *= V, st *= V), O === "slice" && (q *= Y, st *= Y);
    const dt = new se(e, "refX", g), U = new se(e, "refY", y), J = dt.hasValue() && U.hasValue();
    if (J && i.translate(-V * dt.getPixels("x"), -V * U.getPixels("y")), m) {
      const A = V * x, R = V * b;
      i.beginPath(), i.moveTo(A, R), i.lineTo(r, R), i.lineTo(r, l), i.lineTo(A, l), i.closePath(), i.clip();
    }
    if (!J) {
      const A = O === "meet" && V === j, R = O === "slice" && Y === j, wt = O === "meet" && V === B, z = O === "slice" && Y === B;
      k.startsWith("xMid") && (A || R) && i.translate(r / 2 - q / 2, 0), k.endsWith("YMid") && (wt || z) && i.translate(0, l / 2 - st / 2), k.startsWith("xMax") && (A || R) && i.translate(r - q, 0), k.endsWith("YMax") && (wt || z) && i.translate(0, l - st);
    }
    switch (!0) {
      case k === "none":
        i.scale(B, j);
        break;
      case O === "meet":
        i.scale(V, V);
        break;
      case O === "slice":
        i.scale(Y, Y);
        break;
    }
    i.translate(-u, -d);
  }
  start(t) {
    let { enableRedraw: e = !1, ignoreMouse: i = !1, ignoreAnimation: n = !1, ignoreDimensions: r = !1, ignoreClear: o = !1, forceRedraw: l, scaleWidth: h, scaleHeight: u, offsetX: d, offsetY: g } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const { mouse: y } = this, m = 1e3 / po.FRAMERATE;
    if (this.isReadyLock = !1, this.frameDuration = m, this.readyPromise = new Promise((P) => {
      this.resolveReady = P;
    }), this.isReady() && this.render(t, r, o, h, u, d, g), !e)
      return;
    let x = Date.now(), b = x, I = 0;
    const C = () => {
      x = Date.now(), I = x - b, I >= m && (b = x - I % m, this.shouldUpdate(n, l) && (this.render(t, r, o, h, u, d, g), y.runEvents())), this.intervalId = _f(C);
    };
    i || y.start(), this.intervalId = _f(C);
  }
  stop() {
    this.intervalId && (_f.cancel(this.intervalId), this.intervalId = null), this.mouse.stop();
  }
  shouldUpdate(t, e) {
    if (!t) {
      const { frameDuration: i } = this;
      if (this.animations.reduce(
        (r, o) => o.update(i) || r,
        !1
      ))
        return !0;
    }
    return !!(typeof e == "function" && e() || !this.isReadyLock && this.isReady() || this.mouse.hasEvents());
  }
  render(t, e, i, n, r, o, l) {
    const { viewPort: h, ctx: u, isFirstRender: d } = this, g = u.canvas;
    h.clear(), g.width && g.height && h.setCurrent(g.width, g.height);
    const y = t.getStyle("width"), m = t.getStyle("height");
    !e && (d || typeof n != "number" && typeof r != "number") && (y.hasValue() && (g.width = y.getPixels("x"), g.style && (g.style.width = "".concat(g.width, "px"))), m.hasValue() && (g.height = m.getPixels("y"), g.style && (g.style.height = "".concat(g.height, "px"))));
    let x = g.clientWidth || g.width, b = g.clientHeight || g.height;
    if (e && y.hasValue() && m.hasValue() && (x = y.getPixels("x"), b = m.getPixels("y")), h.setCurrent(x, b), typeof o == "number" && t.getAttribute("x", !0).setValue(o), typeof l == "number" && t.getAttribute("y", !0).setValue(l), typeof n == "number" || typeof r == "number") {
      const I = Fs(t.getAttribute("viewBox").getString());
      let C = 0, P = 0;
      if (typeof n == "number") {
        const O = t.getStyle("width");
        O.hasValue() ? C = O.getPixels("x") / n : I[2] && !isNaN(I[2]) && (C = I[2] / n);
      }
      if (typeof r == "number") {
        const O = t.getStyle("height");
        O.hasValue() ? P = O.getPixels("y") / r : I[3] && !isNaN(I[3]) && (P = I[3] / r);
      }
      C || (C = P), P || (P = C), t.getAttribute("width", !0).setValue(n), t.getAttribute("height", !0).setValue(r);
      const k = t.getStyle("transform", !0, !0);
      k.setValue("".concat(k.getString(), " scale(").concat(1 / C, ", ").concat(1 / P, ")"));
    }
    i || u.clearRect(0, 0, x, b), t.render(u), d && (this.isFirstRender = !1);
  }
  constructor(t, { fetch: e = Qy, window: i = Zy } = {}) {
    if (this.ctx = t, this.viewPort = new mh(), this.mouse = new UI(this), this.animations = [], this.waits = [], this.frameDuration = 0, this.isReadyLock = !1, this.isFirstRender = !0, this.intervalId = null, this.window = i, !e)
      throw new Error("Can't find 'fetch' in 'globalThis', please provide it via options");
    this.fetch = e;
  }
}
po.defaultWindow = Zy;
po.defaultFetch = Qy;
po.FRAMERATE = 30;
po.MAX_VIRTUAL_PIXELS = 3e4;
const { defaultFetch: jI } = po, WI = typeof DOMParser < "u" ? DOMParser : void 0;
class wf {
  async parse(t) {
    return t.startsWith("<") ? this.parseFromString(t) : this.load(t);
  }
  parseFromString(t) {
    const e = new this.DOMParser();
    try {
      return this.checkDocument(e.parseFromString(t, "image/svg+xml"));
    } catch {
      return this.checkDocument(e.parseFromString(t, "text/xml"));
    }
  }
  checkDocument(t) {
    const e = t.getElementsByTagName("parsererror")[0];
    if (e)
      throw new Error(e.textContent || "Unknown parse error");
    return t;
  }
  async load(t) {
    const i = await (await this.fetch(t)).text();
    return this.parseFromString(i);
  }
  constructor({ fetch: t = jI, DOMParser: e = WI } = {}) {
    if (!t)
      throw new Error("Can't find 'fetch' in 'globalThis', please provide it via options");
    if (!e)
      throw new Error("Can't find 'DOMParser' in 'globalThis', please provide it via options");
    this.fetch = t, this.DOMParser = e;
  }
}
class GI {
  apply(t) {
    const { x: e, y: i } = this.point;
    t.translate(e || 0, i || 0);
  }
  unapply(t) {
    const { x: e, y: i } = this.point;
    t.translate(-1 * e || 0, -1 * i || 0);
  }
  applyToPoint(t) {
    const { x: e, y: i } = this.point;
    t.applyTransform([
      1,
      0,
      0,
      1,
      e || 0,
      i || 0
    ]);
  }
  constructor(t, e) {
    this.type = "translate", this.point = Hi.parse(e);
  }
}
class $I {
  apply(t) {
    const { cx: e, cy: i, originX: n, originY: r, angle: o } = this, l = e + n.getPixels("x"), h = i + r.getPixels("y");
    t.translate(l, h), t.rotate(o.getRadians()), t.translate(-l, -h);
  }
  unapply(t) {
    const { cx: e, cy: i, originX: n, originY: r, angle: o } = this, l = e + n.getPixels("x"), h = i + r.getPixels("y");
    t.translate(l, h), t.rotate(-1 * o.getRadians()), t.translate(-l, -h);
  }
  applyToPoint(t) {
    const { cx: e, cy: i, angle: n } = this, r = n.getRadians();
    t.applyTransform([
      1,
      0,
      0,
      1,
      e || 0,
      i || 0
      // this.p.y
    ]), t.applyTransform([
      Math.cos(r),
      Math.sin(r),
      -Math.sin(r),
      Math.cos(r),
      0,
      0
    ]), t.applyTransform([
      1,
      0,
      0,
      1,
      -e || 0,
      -i || 0
      // -this.p.y
    ]);
  }
  constructor(t, e, i) {
    this.type = "rotate";
    const n = Fs(e);
    this.angle = new se(t, "angle", n[0]), this.originX = i[0], this.originY = i[1], this.cx = n[1] || 0, this.cy = n[2] || 0;
  }
}
class qI {
  apply(t) {
    const { scale: { x: e, y: i }, originX: n, originY: r } = this, o = n.getPixels("x"), l = r.getPixels("y");
    t.translate(o, l), t.scale(e, i || e), t.translate(-o, -l);
  }
  unapply(t) {
    const { scale: { x: e, y: i }, originX: n, originY: r } = this, o = n.getPixels("x"), l = r.getPixels("y");
    t.translate(o, l), t.scale(1 / e, 1 / i || e), t.translate(-o, -l);
  }
  applyToPoint(t) {
    const { x: e, y: i } = this.scale;
    t.applyTransform([
      e || 0,
      0,
      0,
      i || 0,
      0,
      0
    ]);
  }
  constructor(t, e, i) {
    this.type = "scale";
    const n = Hi.parseScale(e);
    (n.x === 0 || n.y === 0) && (n.x = _l, n.y = _l), this.scale = n, this.originX = i[0], this.originY = i[1];
  }
}
class tw {
  apply(t) {
    const { originX: e, originY: i, matrix: n } = this, r = e.getPixels("x"), o = i.getPixels("y");
    t.translate(r, o), t.transform(n[0], n[1], n[2], n[3], n[4], n[5]), t.translate(-r, -o);
  }
  unapply(t) {
    const { originX: e, originY: i, matrix: n } = this, r = n[0], o = n[2], l = n[4], h = n[1], u = n[3], d = n[5], g = 0, y = 0, m = 1, x = 1 / (r * (u * m - d * y) - o * (h * m - d * g) + l * (h * y - u * g)), b = e.getPixels("x"), I = i.getPixels("y");
    t.translate(b, I), t.transform(x * (u * m - d * y), x * (d * g - h * m), x * (l * y - o * m), x * (r * m - l * g), x * (o * d - l * u), x * (l * h - r * d)), t.translate(-b, -I);
  }
  applyToPoint(t) {
    t.applyTransform(this.matrix);
  }
  constructor(t, e, i) {
    this.type = "matrix", this.matrix = AI(e), this.originX = i[0], this.originY = i[1];
  }
}
class ew extends tw {
  constructor(t, e, i) {
    super(t, e, i), this.type = "skew", this.angle = new se(t, "angle", e);
  }
}
class KI extends ew {
  constructor(t, e, i) {
    super(t, e, i), this.type = "skewX", this.matrix = [
      1,
      0,
      Math.tan(this.angle.getRadians()),
      1,
      0,
      0
    ];
  }
}
class XI extends ew {
  constructor(t, e, i) {
    super(t, e, i), this.type = "skewY", this.matrix = [
      1,
      Math.tan(this.angle.getRadians()),
      0,
      1,
      0,
      0
    ];
  }
}
function JI(s) {
  return Bl(s).trim().replace(/\)([a-zA-Z])/g, ") $1").replace(/\)(\s?,\s?)/g, ") ").split(/\s(?=[a-z])/);
}
function YI(s) {
  const [t = "", e = ""] = s.split("(");
  return [
    t.trim(),
    e.trim().replace(")", "")
  ];
}
class La {
  static fromElement(t, e) {
    const i = e.getStyle("transform", !1, !0);
    if (i.hasValue()) {
      const [n, r = n] = e.getStyle("transform-origin", !1, !0).split();
      if (n && r) {
        const o = [
          n,
          r
        ];
        return new La(t, i.getString(), o);
      }
    }
    return null;
  }
  apply(t) {
    this.transforms.forEach(
      (e) => e.apply(t)
    );
  }
  unapply(t) {
    this.transforms.forEach(
      (e) => e.unapply(t)
    );
  }
  // TODO: applyToPoint unused ... remove?
  applyToPoint(t) {
    this.transforms.forEach(
      (e) => e.applyToPoint(t)
    );
  }
  constructor(t, e, i) {
    this.document = t, this.transforms = [], JI(e).forEach((r) => {
      if (r === "none")
        return;
      const [o, l] = YI(r), h = La.transformTypes[o];
      h && this.transforms.push(new h(this.document, l, i));
    });
  }
}
La.transformTypes = {
  translate: GI,
  rotate: $I,
  scale: qI,
  matrix: tw,
  skewX: KI,
  skewY: XI
};
let nn = class sg {
  getAttribute(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    const i = this.attributes[t];
    if (!i && e) {
      const n = new se(this.document, t, "");
      return this.attributes[t] = n, n;
    }
    return i || se.empty(this.document);
  }
  getHrefAttribute() {
    let t;
    for (const e in this.attributes)
      if (e === "href" || e.endsWith(":href")) {
        t = this.attributes[e];
        break;
      }
    return t || se.empty(this.document);
  }
  getStyle(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
    const n = this.styles[t];
    if (n)
      return n;
    const r = this.getAttribute(t);
    if (r.hasValue())
      return this.styles[t] = r, r;
    if (!i) {
      const { parent: o } = this;
      if (o) {
        const l = o.getStyle(t);
        if (l.hasValue())
          return l;
      }
    }
    if (e) {
      const o = new se(this.document, t, "");
      return this.styles[t] = o, o;
    }
    return se.empty(this.document);
  }
  render(t) {
    if (!(this.getStyle("display").getString() === "none" || this.getStyle("visibility").getString() === "hidden")) {
      if (t.save(), this.getStyle("mask").hasValue()) {
        const e = this.getStyle("mask").getDefinition();
        e && (this.applyEffects(t), e.apply(t, this));
      } else if (this.getStyle("filter").getValue("none") !== "none") {
        const e = this.getStyle("filter").getDefinition();
        e && (this.applyEffects(t), e.apply(t, this));
      } else
        this.setContext(t), this.renderChildren(t), this.clearContext(t);
      t.restore();
    }
  }
  setContext(t) {
  }
  applyEffects(t) {
    const e = La.fromElement(this.document, this);
    e && e.apply(t);
    const i = this.getStyle("clip-path", !1, !0);
    if (i.hasValue()) {
      const n = i.getDefinition();
      n && n.apply(t);
    }
  }
  clearContext(t) {
  }
  renderChildren(t) {
    this.children.forEach((e) => {
      e.render(t);
    });
  }
  addChild(t) {
    const e = t instanceof sg ? t : this.document.createElement(t);
    e.parent = this, sg.ignoreChildTypes.includes(e.type) || this.children.push(e);
  }
  matchesSelector(t) {
    var e;
    const { node: i } = this;
    if (typeof i.matches == "function")
      return i.matches(t);
    const n = (e = i.getAttribute) === null || e === void 0 ? void 0 : e.call(i, "class");
    return !n || n === "" ? !1 : n.split(" ").some(
      (r) => ".".concat(r) === t
    );
  }
  addStylesFromStyleDefinition() {
    const { styles: t, stylesSpecificity: e } = this.document;
    let i;
    for (const n in t)
      if (!n.startsWith("@") && this.matchesSelector(n)) {
        const r = t[n], o = e[n];
        if (r)
          for (const l in r) {
            let h = this.stylesSpecificity[l];
            typeof h > "u" && (h = "000"), o && o >= h && (i = r[l], i && (this.styles[l] = i), this.stylesSpecificity[l] = o);
          }
      }
  }
  removeStyles(t, e) {
    return e.reduce((n, r) => {
      const o = t.getStyle(r);
      if (!o.hasValue())
        return n;
      const l = o.getString();
      return o.setValue(""), [
        ...n,
        [
          r,
          l
        ]
      ];
    }, []);
  }
  restoreStyles(t, e) {
    e.forEach((i) => {
      let [n, r] = i;
      t.getStyle(n, !0).setValue(r);
    });
  }
  isFirstChild() {
    var t;
    return ((t = this.parent) === null || t === void 0 ? void 0 : t.children.indexOf(this)) === 0;
  }
  constructor(t, e, i = !1) {
    if (this.document = t, this.node = e, this.captureTextNodes = i, this.type = "", this.attributes = {}, this.styles = {}, this.stylesSpecificity = {}, this.animationFrozen = !1, this.animationFrozenValue = "", this.parent = null, this.children = [], !e || e.nodeType !== 1)
      return;
    Array.from(e.attributes).forEach((o) => {
      const l = NI(o.nodeName);
      this.attributes[l] = new se(t, l, o.value);
    }), this.addStylesFromStyleDefinition(), this.getAttribute("style").hasValue() && this.getAttribute("style").getString().split(";").map(
      (l) => l.trim()
    ).forEach((l) => {
      if (!l)
        return;
      const [h, u] = l.split(":").map(
        (d) => d.trim()
      );
      h && (this.styles[h] = new se(t, h, u));
    });
    const { definitions: n } = t, r = this.getAttribute("id");
    r.hasValue() && (n[r.getString()] || (n[r.getString()] = this)), Array.from(e.childNodes).forEach((o) => {
      if (o.nodeType === 1)
        this.addChild(o);
      else if (i && (o.nodeType === 3 || o.nodeType === 4)) {
        const l = t.createTextNode(o);
        l.getText().length > 0 && this.addChild(l);
      }
    });
  }
};
nn.ignoreChildTypes = [
  "title"
];
class ZI extends nn {
  constructor(t, e, i) {
    super(t, e, i);
  }
}
function QI(s) {
  const t = s.trim();
  return /^('|")/.test(t) ? t : '"'.concat(t, '"');
}
function tC(s) {
  return typeof process > "u" ? s : s.trim().split(",").map(QI).join(",");
}
function eC(s) {
  if (!s)
    return "";
  const t = s.trim().toLowerCase();
  switch (t) {
    case "normal":
    case "italic":
    case "oblique":
    case "inherit":
    case "initial":
    case "unset":
      return t;
    default:
      return /^oblique\s+(-|)\d+deg$/.test(t) ? t : "";
  }
}
function iC(s) {
  if (!s)
    return "";
  const t = s.trim().toLowerCase();
  switch (t) {
    case "normal":
    case "bold":
    case "lighter":
    case "bolder":
    case "inherit":
    case "initial":
    case "unset":
      return t;
    default:
      return /^[\d.]+$/.test(t) ? t : "";
  }
}
class os {
  static parse() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "", e = arguments.length > 1 ? arguments[1] : void 0, i = "", n = "", r = "", o = "", l = "";
    const h = Bl(t).trim().split(" "), u = {
      fontSize: !1,
      fontStyle: !1,
      fontWeight: !1,
      fontVariant: !1
    };
    return h.forEach((d) => {
      switch (!0) {
        case (!u.fontStyle && os.styles.includes(d)):
          d !== "inherit" && (i = d), u.fontStyle = !0;
          break;
        case (!u.fontVariant && os.variants.includes(d)):
          d !== "inherit" && (n = d), u.fontStyle = !0, u.fontVariant = !0;
          break;
        case (!u.fontWeight && os.weights.includes(d)):
          d !== "inherit" && (r = d), u.fontStyle = !0, u.fontVariant = !0, u.fontWeight = !0;
          break;
        case !u.fontSize:
          d !== "inherit" && (o = d.split("/")[0] || ""), u.fontStyle = !0, u.fontVariant = !0, u.fontWeight = !0, u.fontSize = !0;
          break;
        default:
          d !== "inherit" && (l += d);
      }
    }), new os(i, n, r, o, l, e);
  }
  toString() {
    return [
      eC(this.fontStyle),
      this.fontVariant,
      iC(this.fontWeight),
      this.fontSize,
      // Wrap fontFamily only on nodejs and only for canvas.ctx
      tC(this.fontFamily)
    ].join(" ").trim();
  }
  constructor(t, e, i, n, r, o) {
    const l = o ? typeof o == "string" ? os.parse(o) : o : {};
    this.fontFamily = r || l.fontFamily, this.fontSize = n || l.fontSize, this.fontStyle = t || l.fontStyle, this.fontWeight = i || l.fontWeight, this.fontVariant = e || l.fontVariant;
  }
}
os.styles = "normal|italic|oblique|inherit";
os.variants = "normal|small-caps|inherit";
os.weights = "normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit";
class vr {
  get x() {
    return this.x1;
  }
  get y() {
    return this.y1;
  }
  get width() {
    return this.x2 - this.x1;
  }
  get height() {
    return this.y2 - this.y1;
  }
  addPoint(t, e) {
    typeof t < "u" && ((isNaN(this.x1) || isNaN(this.x2)) && (this.x1 = t, this.x2 = t), t < this.x1 && (this.x1 = t), t > this.x2 && (this.x2 = t)), typeof e < "u" && ((isNaN(this.y1) || isNaN(this.y2)) && (this.y1 = e, this.y2 = e), e < this.y1 && (this.y1 = e), e > this.y2 && (this.y2 = e));
  }
  addX(t) {
    this.addPoint(t, 0);
  }
  addY(t) {
    this.addPoint(0, t);
  }
  addBoundingBox(t) {
    if (!t)
      return;
    const { x1: e, y1: i, x2: n, y2: r } = t;
    this.addPoint(e, i), this.addPoint(n, r);
  }
  sumCubic(t, e, i, n, r) {
    return Math.pow(1 - t, 3) * e + 3 * Math.pow(1 - t, 2) * t * i + 3 * (1 - t) * Math.pow(t, 2) * n + Math.pow(t, 3) * r;
  }
  bezierCurveAdd(t, e, i, n, r) {
    const o = 6 * e - 12 * i + 6 * n, l = -3 * e + 9 * i - 9 * n + 3 * r, h = 3 * i - 3 * e;
    if (l === 0) {
      if (o === 0)
        return;
      const y = -h / o;
      0 < y && y < 1 && (t ? this.addX(this.sumCubic(y, e, i, n, r)) : this.addY(this.sumCubic(y, e, i, n, r)));
      return;
    }
    const u = Math.pow(o, 2) - 4 * h * l;
    if (u < 0)
      return;
    const d = (-o + Math.sqrt(u)) / (2 * l);
    0 < d && d < 1 && (t ? this.addX(this.sumCubic(d, e, i, n, r)) : this.addY(this.sumCubic(d, e, i, n, r)));
    const g = (-o - Math.sqrt(u)) / (2 * l);
    0 < g && g < 1 && (t ? this.addX(this.sumCubic(g, e, i, n, r)) : this.addY(this.sumCubic(g, e, i, n, r)));
  }
  // from http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html
  addBezierCurve(t, e, i, n, r, o, l, h) {
    this.addPoint(t, e), this.addPoint(l, h), this.bezierCurveAdd(!0, t, i, r, l), this.bezierCurveAdd(!1, e, n, o, h);
  }
  addQuadraticCurve(t, e, i, n, r, o) {
    const l = t + 0.6666666666666666 * (i - t), h = e + 2 / 3 * (n - e), u = l + 1 / 3 * (r - t), d = h + 1 / 3 * (o - e);
    this.addBezierCurve(t, e, l, u, h, d, r, o);
  }
  isPointInBox(t, e) {
    const { x1: i, y1: n, x2: r, y2: o } = this;
    return i <= t && t <= r && n <= e && e <= o;
  }
  constructor(t = Number.NaN, e = Number.NaN, i = Number.NaN, n = Number.NaN) {
    this.x1 = t, this.y1 = e, this.x2 = i, this.y2 = n, this.addPoint(t, e), this.addPoint(i, n);
  }
}
class Va extends nn {
  calculateOpacity() {
    let t = 1, e = this;
    for (; e; ) {
      const i = e.getStyle("opacity", !1, !0);
      i.hasValue(!0) && (t *= i.getNumber()), e = e.parent;
    }
    return t;
  }
  setContext(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    if (!e) {
      const i = this.getStyle("fill"), n = this.getStyle("fill-opacity"), r = this.getStyle("stroke"), o = this.getStyle("stroke-opacity");
      if (i.isUrlDefinition()) {
        const m = i.getFillStyleDefinition(this, n);
        m && (t.fillStyle = m);
      } else if (i.hasValue()) {
        i.getString() === "currentColor" && i.setValue(this.getStyle("color").getColor());
        const m = i.getColor();
        m !== "inherit" && (t.fillStyle = m === "none" ? "rgba(0,0,0,0)" : m);
      }
      if (n.hasValue()) {
        const m = new se(this.document, "fill", t.fillStyle).addOpacity(n).getColor();
        t.fillStyle = m;
      }
      if (r.isUrlDefinition()) {
        const m = r.getFillStyleDefinition(this, o);
        m && (t.strokeStyle = m);
      } else if (r.hasValue()) {
        r.getString() === "currentColor" && r.setValue(this.getStyle("color").getColor());
        const m = r.getString();
        m !== "inherit" && (t.strokeStyle = m === "none" ? "rgba(0,0,0,0)" : m);
      }
      if (o.hasValue()) {
        const m = new se(this.document, "stroke", t.strokeStyle).addOpacity(o).getString();
        t.strokeStyle = m;
      }
      const l = this.getStyle("stroke-width");
      if (l.hasValue()) {
        const m = l.getPixels();
        t.lineWidth = m || _l;
      }
      const h = this.getStyle("stroke-linecap"), u = this.getStyle("stroke-linejoin"), d = this.getStyle("stroke-miterlimit"), g = this.getStyle("stroke-dasharray"), y = this.getStyle("stroke-dashoffset");
      if (h.hasValue() && (t.lineCap = h.getString()), u.hasValue() && (t.lineJoin = u.getString()), d.hasValue() && (t.miterLimit = d.getNumber()), g.hasValue() && g.getString() !== "none") {
        const m = Fs(g.getString());
        typeof t.setLineDash < "u" ? t.setLineDash(m) : typeof t.webkitLineDash < "u" ? t.webkitLineDash = m : typeof t.mozDash < "u" && !(m.length === 1 && m[0] === 0) && (t.mozDash = m);
        const x = y.getPixels();
        typeof t.lineDashOffset < "u" ? t.lineDashOffset = x : typeof t.webkitLineDashOffset < "u" ? t.webkitLineDashOffset = x : typeof t.mozDashOffset < "u" && (t.mozDashOffset = x);
      }
    }
    if (this.modifiedEmSizeStack = !1, typeof t.font < "u") {
      const i = this.getStyle("font"), n = this.getStyle("font-style"), r = this.getStyle("font-variant"), o = this.getStyle("font-weight"), l = this.getStyle("font-size"), h = this.getStyle("font-family"), u = new os(n.getString(), r.getString(), o.getString(), l.hasValue() ? "".concat(l.getPixels(!0), "px") : "", h.getString(), os.parse(i.getString(), t.font));
      n.setValue(u.fontStyle), r.setValue(u.fontVariant), o.setValue(u.fontWeight), l.setValue(u.fontSize), h.setValue(u.fontFamily), t.font = u.toString(), l.isPixels() && (this.document.emSize = l.getPixels(), this.modifiedEmSizeStack = !0);
    }
    e || (this.applyEffects(t), t.globalAlpha = this.calculateOpacity());
  }
  clearContext(t) {
    super.clearContext(t), this.modifiedEmSizeStack && this.document.popEmSize();
  }
  constructor(...t) {
    super(...t), this.modifiedEmSizeStack = !1;
  }
}
class qo extends Va {
  setContext(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
    super.setContext(t, e);
    const i = this.getStyle("dominant-baseline").getTextBaseline() || this.getStyle("alignment-baseline").getTextBaseline();
    i && (t.textBaseline = i);
  }
  initializeCoordinates() {
    this.x = 0, this.y = 0, this.leafTexts = [], this.textChunkStart = 0, this.minX = Number.POSITIVE_INFINITY, this.maxX = Number.NEGATIVE_INFINITY;
  }
  getBoundingBox(t) {
    if (this.type !== "text")
      return this.getTElementBoundingBox(t);
    this.initializeCoordinates(), this.adjustChildCoordinatesRecursive(t);
    let e = null;
    return this.children.forEach((i, n) => {
      const r = this.getChildBoundingBox(t, this, this, n);
      e ? e.addBoundingBox(r) : e = r;
    }), e;
  }
  getFontSize() {
    const { document: t, parent: e } = this, i = os.parse(t.ctx.font).fontSize;
    return e.getStyle("font-size").getNumber(i);
  }
  getTElementBoundingBox(t) {
    const e = this.getFontSize();
    return new vr(this.x, this.y - e, this.x + this.measureText(t), this.y);
  }
  getGlyph(t, e, i) {
    const n = e[i];
    let r;
    if (t.isArabic) {
      var o;
      const l = e.length, h = e[i - 1], u = e[i + 1];
      let d = "isolated";
      (i === 0 || h === " ") && i < l - 1 && u !== " " && (d = "terminal"), i > 0 && h !== " " && i < l - 1 && u !== " " && (d = "medial"), i > 0 && h !== " " && (i === l - 1 || u === " ") && (d = "initial"), r = ((o = t.arabicGlyphs[n]) === null || o === void 0 ? void 0 : o[d]) || t.glyphs[n];
    } else
      r = t.glyphs[n];
    return r || (r = t.missingGlyph), r;
  }
  getText() {
    return "";
  }
  getTextFromNode(t) {
    const e = t || this.node, i = Array.from(e.parentNode.childNodes), n = i.indexOf(e), r = i.length - 1;
    let o = Bl(
      // textNode.value
      // || textNode.text
      e.textContent || ""
    );
    return n === 0 && (o = MI(o)), n === r && (o = EI(o)), o;
  }
  renderChildren(t) {
    if (this.type !== "text") {
      this.renderTElementChildren(t);
      return;
    }
    this.initializeCoordinates(), this.adjustChildCoordinatesRecursive(t), this.children.forEach((i, n) => {
      this.renderChild(t, this, this, n);
    });
    const { mouse: e } = this.document.screen;
    e.isWorking() && e.checkBoundingBox(this, this.getBoundingBox(t));
  }
  renderTElementChildren(t) {
    const { document: e, parent: i } = this, n = this.getText(), r = i.getStyle("font-family").getDefinition();
    if (r) {
      const { unitsPerEm: h } = r.fontFace, u = os.parse(e.ctx.font), d = i.getStyle("font-size").getNumber(u.fontSize), g = i.getStyle("font-style").getString(u.fontStyle), y = d / h, m = r.isRTL ? n.split("").reverse().join("") : n, x = Fs(i.getAttribute("dx").getString()), b = m.length;
      for (let I = 0; I < b; I++) {
        const C = this.getGlyph(r, m, I);
        t.translate(this.x, this.y), t.scale(y, -y);
        const P = t.lineWidth;
        t.lineWidth = t.lineWidth * h / d, g === "italic" && t.transform(1, 0, 0.4, 1, 0, 0), C.render(t), g === "italic" && t.transform(1, 0, -0.4, 1, 0, 0), t.lineWidth = P, t.scale(1 / y, -1 / y), t.translate(-this.x, -this.y), this.x += d * (C.horizAdvX || r.horizAdvX) / h, typeof x[I] < "u" && !isNaN(x[I]) && (this.x += x[I]);
      }
      return;
    }
    const { x: o, y: l } = this;
    t.fillStyle && t.fillText(n, o, l), t.strokeStyle && t.strokeText(n, o, l);
  }
  applyAnchoring() {
    if (this.textChunkStart >= this.leafTexts.length)
      return;
    const t = this.leafTexts[this.textChunkStart], e = t.getStyle("text-anchor").getString("start"), i = !1;
    let n = 0;
    e === "start" && !i || e === "end" && i ? n = t.x - this.minX : e === "end" && !i || e === "start" && i ? n = t.x - this.maxX : n = t.x - (this.minX + this.maxX) / 2;
    for (let r = this.textChunkStart; r < this.leafTexts.length; r++)
      this.leafTexts[r].x += n;
    this.minX = Number.POSITIVE_INFINITY, this.maxX = Number.NEGATIVE_INFINITY, this.textChunkStart = this.leafTexts.length;
  }
  adjustChildCoordinatesRecursive(t) {
    this.children.forEach((e, i) => {
      this.adjustChildCoordinatesRecursiveCore(t, this, this, i);
    }), this.applyAnchoring();
  }
  adjustChildCoordinatesRecursiveCore(t, e, i, n) {
    const r = i.children[n];
    r.children.length > 0 ? r.children.forEach((o, l) => {
      e.adjustChildCoordinatesRecursiveCore(t, e, r, l);
    }) : this.adjustChildCoordinates(t, e, i, n);
  }
  adjustChildCoordinates(t, e, i, n) {
    const r = i.children[n];
    if (typeof r.measureText != "function")
      return r;
    t.save(), r.setContext(t, !0);
    const o = r.getAttribute("x"), l = r.getAttribute("y"), h = r.getAttribute("dx"), u = r.getAttribute("dy"), d = r.getStyle("font-family").getDefinition(), g = !!(d != null && d.isRTL);
    n === 0 && (o.hasValue() || o.setValue(r.getInheritedAttribute("x")), l.hasValue() || l.setValue(r.getInheritedAttribute("y")), h.hasValue() || h.setValue(r.getInheritedAttribute("dx")), u.hasValue() || u.setValue(r.getInheritedAttribute("dy")));
    const y = r.measureText(t);
    return g && (e.x -= y), o.hasValue() ? (e.applyAnchoring(), r.x = o.getPixels("x"), h.hasValue() && (r.x += h.getPixels("x"))) : (h.hasValue() && (e.x += h.getPixels("x")), r.x = e.x), e.x = r.x, g || (e.x += y), l.hasValue() ? (r.y = l.getPixels("y"), u.hasValue() && (r.y += u.getPixels("y"))) : (u.hasValue() && (e.y += u.getPixels("y")), r.y = e.y), e.y = r.y, e.leafTexts.push(r), e.minX = Math.min(e.minX, r.x, r.x + y), e.maxX = Math.max(e.maxX, r.x, r.x + y), r.clearContext(t), t.restore(), r;
  }
  getChildBoundingBox(t, e, i, n) {
    const r = i.children[n];
    if (typeof r.getBoundingBox != "function")
      return null;
    const o = r.getBoundingBox(t);
    return o && r.children.forEach((l, h) => {
      const u = e.getChildBoundingBox(t, e, r, h);
      o.addBoundingBox(u);
    }), o;
  }
  renderChild(t, e, i, n) {
    const r = i.children[n];
    r.render(t), r.children.forEach((o, l) => {
      e.renderChild(t, e, r, l);
    });
  }
  measureText(t) {
    const { measureCache: e } = this;
    if (~e)
      return e;
    const i = this.getText(), n = this.measureTargetText(t, i);
    return this.measureCache = n, n;
  }
  measureTargetText(t, e) {
    if (!e.length)
      return 0;
    const { parent: i } = this, n = i.getStyle("font-family").getDefinition();
    if (n) {
      const o = this.getFontSize(), l = n.isRTL ? e.split("").reverse().join("") : e, h = Fs(i.getAttribute("dx").getString()), u = l.length;
      let d = 0;
      for (let g = 0; g < u; g++) {
        const y = this.getGlyph(n, l, g);
        d += (y.horizAdvX || n.horizAdvX) * o / n.fontFace.unitsPerEm, typeof h[g] < "u" && !isNaN(h[g]) && (d += h[g]);
      }
      return d;
    }
    if (!t.measureText)
      return e.length * 10;
    t.save(), this.setContext(t, !0);
    const { width: r } = t.measureText(e);
    return this.clearContext(t), t.restore(), r;
  }
  /**
  * Inherits positional attributes from {@link TextElement} parent(s). Attributes
  * are only inherited from a parent to its first child.
  * @param name - The attribute name.
  * @returns The attribute value or null.
  */
  getInheritedAttribute(t) {
    let e = this;
    for (; e instanceof qo && e.isFirstChild() && e.parent; ) {
      const i = e.parent.getAttribute(t);
      if (i.hasValue(!0))
        return i.getString("0");
      e = e.parent;
    }
    return null;
  }
  constructor(t, e, i) {
    super(t, e, new.target === qo ? !0 : i), this.type = "text", this.x = 0, this.y = 0, this.leafTexts = [], this.textChunkStart = 0, this.minX = Number.POSITIVE_INFINITY, this.maxX = Number.NEGATIVE_INFINITY, this.measureCache = -1;
  }
}
class Md extends qo {
  getText() {
    return this.text;
  }
  constructor(t, e, i) {
    super(t, e, new.target === Md ? !0 : i), this.type = "tspan", this.text = this.children.length > 0 ? "" : this.getTextFromNode();
  }
}
class nC extends Md {
  constructor(...t) {
    super(...t), this.type = "textNode";
  }
}
class Ie extends Et {
  reset() {
    this.i = -1, this.command = null, this.previousCommand = null, this.start = new Hi(0, 0), this.control = new Hi(0, 0), this.current = new Hi(0, 0), this.points = [], this.angles = [];
  }
  isEnd() {
    const { i: t, commands: e } = this;
    return t >= e.length - 1;
  }
  next() {
    const t = this.commands[++this.i];
    return this.previousCommand = this.command, this.command = t, t;
  }
  getPoint() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "x", e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "y";
    const i = new Hi(this.command[t], this.command[e]);
    return this.makeAbsolute(i);
  }
  getAsControlPoint(t, e) {
    const i = this.getPoint(t, e);
    return this.control = i, i;
  }
  getAsCurrentPoint(t, e) {
    const i = this.getPoint(t, e);
    return this.current = i, i;
  }
  getReflectedControlPoint() {
    const t = this.previousCommand.type;
    if (t !== Et.CURVE_TO && t !== Et.SMOOTH_CURVE_TO && t !== Et.QUAD_TO && t !== Et.SMOOTH_QUAD_TO)
      return this.current;
    const { current: { x: e, y: i }, control: { x: n, y: r } } = this;
    return new Hi(2 * e - n, 2 * i - r);
  }
  makeAbsolute(t) {
    if (this.command.relative) {
      const { x: e, y: i } = this.current;
      t.x += e, t.y += i;
    }
    return t;
  }
  addMarker(t, e, i) {
    const { points: n, angles: r } = this;
    i && r.length > 0 && !r[r.length - 1] && (r[r.length - 1] = n[n.length - 1].angleTo(i)), this.addMarkerAngle(t, e ? e.angleTo(t) : null);
  }
  addMarkerAngle(t, e) {
    this.points.push(t), this.angles.push(e);
  }
  getMarkerPoints() {
    return this.points;
  }
  getMarkerAngles() {
    const { angles: t } = this, e = t.length;
    for (let i = 0; i < e; i++)
      if (!t[i]) {
        for (let n = i + 1; n < e; n++)
          if (t[n]) {
            t[i] = t[n];
            break;
          }
      }
    return t;
  }
  constructor(t) {
    super(t.replace(/([+\-.])\s+/gm, "$1").replace(/[^MmZzLlHhVvCcSsQqTtAae\d\s.,+-].*/g, "")), this.control = new Hi(0, 0), this.start = new Hi(0, 0), this.current = new Hi(0, 0), this.command = null, this.commands = this.commands, this.i = -1, this.previousCommand = null, this.points = [], this.angles = [];
  }
}
class yi extends Va {
  path(t) {
    const { pathParser: e } = this, i = new vr();
    for (e.reset(), t && t.beginPath(); !e.isEnd(); )
      switch (e.next().type) {
        case Ie.MOVE_TO:
          this.pathM(t, i);
          break;
        case Ie.LINE_TO:
          this.pathL(t, i);
          break;
        case Ie.HORIZ_LINE_TO:
          this.pathH(t, i);
          break;
        case Ie.VERT_LINE_TO:
          this.pathV(t, i);
          break;
        case Ie.CURVE_TO:
          this.pathC(t, i);
          break;
        case Ie.SMOOTH_CURVE_TO:
          this.pathS(t, i);
          break;
        case Ie.QUAD_TO:
          this.pathQ(t, i);
          break;
        case Ie.SMOOTH_QUAD_TO:
          this.pathT(t, i);
          break;
        case Ie.ARC:
          this.pathA(t, i);
          break;
        case Ie.CLOSE_PATH:
          this.pathZ(t, i);
          break;
      }
    return i;
  }
  getBoundingBox(t) {
    return this.path();
  }
  getMarkers() {
    const { pathParser: t } = this, e = t.getMarkerPoints(), i = t.getMarkerAngles();
    return e.map(
      (r, o) => [
        r,
        i[o]
      ]
    );
  }
  renderChildren(t) {
    this.path(t), this.document.screen.mouse.checkPath(this, t);
    const e = this.getStyle("fill-rule");
    t.fillStyle !== "" && (e.getString("inherit") !== "inherit" ? t.fill(e.getString()) : t.fill()), t.strokeStyle !== "" && (this.getAttribute("vector-effect").getString() === "non-scaling-stroke" ? (t.save(), t.setTransform(1, 0, 0, 1, 0, 0), t.stroke(), t.restore()) : t.stroke());
    const i = this.getMarkers();
    if (i) {
      const n = i.length - 1, r = this.getStyle("marker-start"), o = this.getStyle("marker-mid"), l = this.getStyle("marker-end");
      if (r.isUrlDefinition()) {
        const h = r.getDefinition(), [u, d] = i[0];
        h.render(t, u, d);
      }
      if (o.isUrlDefinition()) {
        const h = o.getDefinition();
        for (let u = 1; u < n; u++) {
          const [d, g] = i[u];
          h.render(t, d, g);
        }
      }
      if (l.isUrlDefinition()) {
        const h = l.getDefinition(), [u, d] = i[n];
        h.render(t, u, d);
      }
    }
  }
  static pathM(t) {
    const e = t.getAsCurrentPoint();
    return t.start = t.current, {
      point: e
    };
  }
  pathM(t, e) {
    const { pathParser: i } = this, { point: n } = yi.pathM(i), { x: r, y: o } = n;
    i.addMarker(n), e.addPoint(r, o), t && t.moveTo(r, o);
  }
  static pathL(t) {
    const { current: e } = t, i = t.getAsCurrentPoint();
    return {
      current: e,
      point: i
    };
  }
  pathL(t, e) {
    const { pathParser: i } = this, { current: n, point: r } = yi.pathL(i), { x: o, y: l } = r;
    i.addMarker(r, n), e.addPoint(o, l), t && t.lineTo(o, l);
  }
  static pathH(t) {
    const { current: e, command: i } = t, n = new Hi((i.relative ? e.x : 0) + i.x, e.y);
    return t.current = n, {
      current: e,
      point: n
    };
  }
  pathH(t, e) {
    const { pathParser: i } = this, { current: n, point: r } = yi.pathH(i), { x: o, y: l } = r;
    i.addMarker(r, n), e.addPoint(o, l), t && t.lineTo(o, l);
  }
  static pathV(t) {
    const { current: e, command: i } = t, n = new Hi(e.x, (i.relative ? e.y : 0) + i.y);
    return t.current = n, {
      current: e,
      point: n
    };
  }
  pathV(t, e) {
    const { pathParser: i } = this, { current: n, point: r } = yi.pathV(i), { x: o, y: l } = r;
    i.addMarker(r, n), e.addPoint(o, l), t && t.lineTo(o, l);
  }
  static pathC(t) {
    const { current: e } = t, i = t.getPoint("x1", "y1"), n = t.getAsControlPoint("x2", "y2"), r = t.getAsCurrentPoint();
    return {
      current: e,
      point: i,
      controlPoint: n,
      currentPoint: r
    };
  }
  pathC(t, e) {
    const { pathParser: i } = this, { current: n, point: r, controlPoint: o, currentPoint: l } = yi.pathC(i);
    i.addMarker(l, o, r), e.addBezierCurve(n.x, n.y, r.x, r.y, o.x, o.y, l.x, l.y), t && t.bezierCurveTo(r.x, r.y, o.x, o.y, l.x, l.y);
  }
  static pathS(t) {
    const { current: e } = t, i = t.getReflectedControlPoint(), n = t.getAsControlPoint("x2", "y2"), r = t.getAsCurrentPoint();
    return {
      current: e,
      point: i,
      controlPoint: n,
      currentPoint: r
    };
  }
  pathS(t, e) {
    const { pathParser: i } = this, { current: n, point: r, controlPoint: o, currentPoint: l } = yi.pathS(i);
    i.addMarker(l, o, r), e.addBezierCurve(n.x, n.y, r.x, r.y, o.x, o.y, l.x, l.y), t && t.bezierCurveTo(r.x, r.y, o.x, o.y, l.x, l.y);
  }
  static pathQ(t) {
    const { current: e } = t, i = t.getAsControlPoint("x1", "y1"), n = t.getAsCurrentPoint();
    return {
      current: e,
      controlPoint: i,
      currentPoint: n
    };
  }
  pathQ(t, e) {
    const { pathParser: i } = this, { current: n, controlPoint: r, currentPoint: o } = yi.pathQ(i);
    i.addMarker(o, r, r), e.addQuadraticCurve(n.x, n.y, r.x, r.y, o.x, o.y), t && t.quadraticCurveTo(r.x, r.y, o.x, o.y);
  }
  static pathT(t) {
    const { current: e } = t, i = t.getReflectedControlPoint();
    t.control = i;
    const n = t.getAsCurrentPoint();
    return {
      current: e,
      controlPoint: i,
      currentPoint: n
    };
  }
  pathT(t, e) {
    const { pathParser: i } = this, { current: n, controlPoint: r, currentPoint: o } = yi.pathT(i);
    i.addMarker(o, r, r), e.addQuadraticCurve(n.x, n.y, r.x, r.y, o.x, o.y), t && t.quadraticCurveTo(r.x, r.y, o.x, o.y);
  }
  static pathA(t) {
    const { current: e, command: i } = t;
    let { rX: n, rY: r, xRot: o, lArcFlag: l, sweepFlag: h } = i;
    const u = o * (Math.PI / 180), d = t.getAsCurrentPoint(), g = new Hi(Math.cos(u) * (e.x - d.x) / 2 + Math.sin(u) * (e.y - d.y) / 2, -Math.sin(u) * (e.x - d.x) / 2 + Math.cos(u) * (e.y - d.y) / 2), y = Math.pow(g.x, 2) / Math.pow(n, 2) + Math.pow(g.y, 2) / Math.pow(r, 2);
    y > 1 && (n *= Math.sqrt(y), r *= Math.sqrt(y));
    let m = (l === h ? -1 : 1) * Math.sqrt((Math.pow(n, 2) * Math.pow(r, 2) - Math.pow(n, 2) * Math.pow(g.y, 2) - Math.pow(r, 2) * Math.pow(g.x, 2)) / (Math.pow(n, 2) * Math.pow(g.y, 2) + Math.pow(r, 2) * Math.pow(g.x, 2)));
    isNaN(m) && (m = 0);
    const x = new Hi(m * n * g.y / r, m * -r * g.x / n), b = new Hi((e.x + d.x) / 2 + Math.cos(u) * x.x - Math.sin(u) * x.y, (e.y + d.y) / 2 + Math.sin(u) * x.x + Math.cos(u) * x.y), I = dm([
      1,
      0
    ], [
      (g.x - x.x) / n,
      (g.y - x.y) / r
    ]), C = [
      (g.x - x.x) / n,
      (g.y - x.y) / r
    ], P = [
      (-g.x - x.x) / n,
      (-g.y - x.y) / r
    ];
    let k = dm(C, P);
    return ng(C, P) <= -1 && (k = Math.PI), ng(C, P) >= 1 && (k = 0), {
      currentPoint: d,
      rX: n,
      rY: r,
      sweepFlag: h,
      xAxisRotation: u,
      centp: b,
      a1: I,
      ad: k
    };
  }
  pathA(t, e) {
    const { pathParser: i } = this, { currentPoint: n, rX: r, rY: o, sweepFlag: l, xAxisRotation: h, centp: u, a1: d, ad: g } = yi.pathA(i), y = 1 - l ? 1 : -1, m = d + y * (g / 2), x = new Hi(u.x + r * Math.cos(m), u.y + o * Math.sin(m));
    if (i.addMarkerAngle(x, m - y * Math.PI / 2), i.addMarkerAngle(n, m - y * Math.PI), e.addPoint(n.x, n.y), t && !isNaN(d) && !isNaN(g)) {
      const b = r > o ? r : o, I = r > o ? 1 : r / o, C = r > o ? o / r : 1;
      t.translate(u.x, u.y), t.rotate(h), t.scale(I, C), t.arc(0, 0, b, d, d + g, !!(1 - l)), t.scale(1 / I, 1 / C), t.rotate(-h), t.translate(-u.x, -u.y);
    }
  }
  static pathZ(t) {
    t.current = t.start;
  }
  pathZ(t, e) {
    yi.pathZ(this.pathParser), t && e.x1 !== e.x2 && e.y1 !== e.y2 && t.closePath();
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "path", this.pathParser = new Ie(this.getAttribute("d").getString());
  }
}
class Hh extends Va {
  setContext(t) {
    var e;
    const { document: i } = this, { screen: n, window: r } = i, o = t.canvas;
    if (n.setDefaults(t), "style" in o && typeof t.font < "u" && r && typeof r.getComputedStyle < "u") {
      t.font = r.getComputedStyle(o).getPropertyValue("font");
      const P = new se(i, "fontSize", os.parse(t.font).fontSize);
      P.hasValue() && (i.rootEmSize = P.getPixels("y"), i.emSize = i.rootEmSize);
    }
    this.getAttribute("x").hasValue() || this.getAttribute("x", !0).setValue(0), this.getAttribute("y").hasValue() || this.getAttribute("y", !0).setValue(0);
    let { width: l, height: h } = n.viewPort;
    this.getStyle("width").hasValue() || this.getStyle("width", !0).setValue("100%"), this.getStyle("height").hasValue() || this.getStyle("height", !0).setValue("100%"), this.getStyle("color").hasValue() || this.getStyle("color", !0).setValue("black");
    const u = this.getAttribute("refX"), d = this.getAttribute("refY"), g = this.getAttribute("viewBox"), y = g.hasValue() ? Fs(g.getString()) : null, m = !this.root && this.getStyle("overflow").getValue("hidden") !== "visible";
    let x = 0, b = 0, I = 0, C = 0;
    y && (x = y[0], b = y[1]), this.root || (l = this.getStyle("width").getPixels("x"), h = this.getStyle("height").getPixels("y"), this.type === "marker" && (I = x, C = b, x = 0, b = 0)), n.viewPort.setCurrent(l, h), this.node && (!this.parent || ((e = this.node.parentNode) === null || e === void 0 ? void 0 : e.nodeName) === "foreignObject") && this.getStyle("transform", !1, !0).hasValue() && !this.getStyle("transform-origin", !1, !0).hasValue() && this.getStyle("transform-origin", !0, !0).setValue("50% 50%"), super.setContext(t), t.translate(this.getAttribute("x").getPixels("x"), this.getAttribute("y").getPixels("y")), y && (l = y[2], h = y[3]), i.setViewBox({
      ctx: t,
      aspectRatio: this.getAttribute("preserveAspectRatio").getString(),
      width: n.viewPort.width,
      desiredWidth: l,
      height: n.viewPort.height,
      desiredHeight: h,
      minX: x,
      minY: b,
      refX: u.getValue(),
      refY: d.getValue(),
      clip: m,
      clipX: I,
      clipY: C
    }), y && (n.viewPort.removeCurrent(), n.viewPort.setCurrent(l, h));
  }
  clearContext(t) {
    super.clearContext(t), this.document.screen.viewPort.removeCurrent();
  }
  /**
  * Resize SVG to fit in given size.
  * @param width
  * @param height
  * @param preserveAspectRatio
  */
  resize(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : t, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
    const n = this.getAttribute("width", !0), r = this.getAttribute("height", !0), o = this.getAttribute("viewBox"), l = this.getAttribute("style"), h = n.getNumber(0), u = r.getNumber(0);
    if (i)
      if (typeof i == "string")
        this.getAttribute("preserveAspectRatio", !0).setValue(i);
      else {
        const d = this.getAttribute("preserveAspectRatio");
        d.hasValue() && d.setValue(d.getString().replace(/^\s*(\S.*\S)\s*$/, "$1"));
      }
    if (n.setValue(t), r.setValue(e), o.hasValue() || o.setValue("0 0 ".concat(h || t, " ").concat(u || e)), l.hasValue()) {
      const d = this.getStyle("width"), g = this.getStyle("height");
      d.hasValue() && d.setValue("".concat(t, "px")), g.hasValue() && g.setValue("".concat(e, "px"));
    }
  }
  constructor(...t) {
    super(...t), this.type = "svg", this.root = !1;
  }
}
class iw extends yi {
  path(t) {
    const e = this.getAttribute("x").getPixels("x"), i = this.getAttribute("y").getPixels("y"), n = this.getStyle("width", !1, !0).getPixels("x"), r = this.getStyle("height", !1, !0).getPixels("y"), o = this.getAttribute("rx"), l = this.getAttribute("ry");
    let h = o.getPixels("x"), u = l.getPixels("y");
    if (o.hasValue() && !l.hasValue() && (u = h), l.hasValue() && !o.hasValue() && (h = u), h = Math.min(h, n / 2), u = Math.min(u, r / 2), t) {
      const d = 4 * ((Math.sqrt(2) - 1) / 3);
      t.beginPath(), r > 0 && n > 0 && (t.moveTo(e + h, i), t.lineTo(e + n - h, i), t.bezierCurveTo(e + n - h + d * h, i, e + n, i + u - d * u, e + n, i + u), t.lineTo(e + n, i + r - u), t.bezierCurveTo(e + n, i + r - u + d * u, e + n - h + d * h, i + r, e + n - h, i + r), t.lineTo(e + h, i + r), t.bezierCurveTo(e + h - d * h, i + r, e, i + r - u + d * u, e, i + r - u), t.lineTo(e, i + u), t.bezierCurveTo(e, i + u - d * u, e + h - d * h, i, e + h, i), t.closePath());
    }
    return new vr(e, i, e + n, i + r);
  }
  getMarkers() {
    return null;
  }
  constructor(...t) {
    super(...t), this.type = "rect";
  }
}
class sC extends yi {
  path(t) {
    const e = this.getAttribute("cx").getPixels("x"), i = this.getAttribute("cy").getPixels("y"), n = this.getAttribute("r").getPixels();
    return t && n > 0 && (t.beginPath(), t.arc(e, i, n, 0, Math.PI * 2, !1), t.closePath()), new vr(e - n, i - n, e + n, i + n);
  }
  getMarkers() {
    return null;
  }
  constructor(...t) {
    super(...t), this.type = "circle";
  }
}
class rC extends yi {
  path(t) {
    const e = 4 * ((Math.sqrt(2) - 1) / 3), i = this.getAttribute("rx").getPixels("x"), n = this.getAttribute("ry").getPixels("y"), r = this.getAttribute("cx").getPixels("x"), o = this.getAttribute("cy").getPixels("y");
    return t && i > 0 && n > 0 && (t.beginPath(), t.moveTo(r + i, o), t.bezierCurveTo(r + i, o + e * n, r + e * i, o + n, r, o + n), t.bezierCurveTo(r - e * i, o + n, r - i, o + e * n, r - i, o), t.bezierCurveTo(r - i, o - e * n, r - e * i, o - n, r, o - n), t.bezierCurveTo(r + e * i, o - n, r + i, o - e * n, r + i, o), t.closePath()), new vr(r - i, o - n, r + i, o + n);
  }
  getMarkers() {
    return null;
  }
  constructor(...t) {
    super(...t), this.type = "ellipse";
  }
}
class oC extends yi {
  getPoints() {
    return [
      new Hi(this.getAttribute("x1").getPixels("x"), this.getAttribute("y1").getPixels("y")),
      new Hi(this.getAttribute("x2").getPixels("x"), this.getAttribute("y2").getPixels("y"))
    ];
  }
  path(t) {
    const [{ x: e, y: i }, { x: n, y: r }] = this.getPoints();
    return t && (t.beginPath(), t.moveTo(e, i), t.lineTo(n, r)), new vr(e, i, n, r);
  }
  getMarkers() {
    const [t, e] = this.getPoints(), i = t.angleTo(e);
    return [
      [
        t,
        i
      ],
      [
        e,
        i
      ]
    ];
  }
  constructor(...t) {
    super(...t), this.type = "line";
  }
}
class nw extends yi {
  path(t) {
    const { points: e } = this, [{ x: i, y: n }] = e, r = new vr(i, n);
    return t && (t.beginPath(), t.moveTo(i, n)), e.forEach((o) => {
      let { x: l, y: h } = o;
      r.addPoint(l, h), t && t.lineTo(l, h);
    }), r;
  }
  getMarkers() {
    const { points: t } = this, e = t.length - 1, i = [];
    return t.forEach((n, r) => {
      r !== e && i.push([
        n,
        n.angleTo(t[r + 1])
      ]);
    }), i.length > 0 && i.push([
      t[t.length - 1],
      i[i.length - 1][1]
    ]), i;
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "polyline", this.points = [], this.points = Hi.parsePath(this.getAttribute("points").getString());
  }
}
class aC extends nw {
  path(t) {
    const e = super.path(t), [{ x: i, y: n }] = this.points;
    return t && (t.lineTo(i, n), t.closePath()), e;
  }
  constructor(...t) {
    super(...t), this.type = "polygon";
  }
}
class lC extends nn {
  createPattern(t, e, i) {
    const n = this.getStyle("width").getPixels("x", !0), r = this.getStyle("height").getPixels("y", !0), o = new Hh(this.document, null);
    o.attributes.viewBox = new se(this.document, "viewBox", this.getAttribute("viewBox").getValue()), o.attributes.width = new se(this.document, "width", "".concat(n, "px")), o.attributes.height = new se(this.document, "height", "".concat(r, "px")), o.attributes.transform = new se(this.document, "transform", this.getAttribute("patternTransform").getValue()), o.children = this.children;
    const l = this.document.createCanvas(n, r), h = l.getContext("2d"), u = this.getAttribute("x"), d = this.getAttribute("y");
    u.hasValue() && d.hasValue() && h.translate(u.getPixels("x", !0), d.getPixels("y", !0)), i.hasValue() ? this.styles["fill-opacity"] = i : Reflect.deleteProperty(this.styles, "fill-opacity");
    for (let y = -1; y <= 1; y++)
      for (let m = -1; m <= 1; m++)
        h.save(), o.attributes.x = new se(this.document, "x", y * l.width), o.attributes.y = new se(this.document, "y", m * l.height), o.render(h), h.restore();
    return t.createPattern(l, "repeat");
  }
  constructor(...t) {
    super(...t), this.type = "pattern";
  }
}
class cC extends nn {
  render(t, e, i) {
    if (!e)
      return;
    const { x: n, y: r } = e, o = this.getAttribute("orient").getString("auto"), l = this.getAttribute("markerUnits").getString("strokeWidth");
    t.translate(n, r), o === "auto" && t.rotate(i), l === "strokeWidth" && t.scale(t.lineWidth, t.lineWidth), t.save();
    const h = new Hh(this.document);
    h.type = this.type, h.attributes.viewBox = new se(this.document, "viewBox", this.getAttribute("viewBox").getValue()), h.attributes.refX = new se(this.document, "refX", this.getAttribute("refX").getValue()), h.attributes.refY = new se(this.document, "refY", this.getAttribute("refY").getValue()), h.attributes.width = new se(this.document, "width", this.getAttribute("markerWidth").getValue()), h.attributes.height = new se(this.document, "height", this.getAttribute("markerHeight").getValue()), h.attributes.overflow = new se(this.document, "overflow", this.getAttribute("overflow").getValue()), h.attributes.fill = new se(this.document, "fill", this.getAttribute("fill").getColor("black")), h.attributes.stroke = new se(this.document, "stroke", this.getAttribute("stroke").getValue("none")), h.children = this.children, h.render(t), t.restore(), l === "strokeWidth" && t.scale(1 / t.lineWidth, 1 / t.lineWidth), o === "auto" && t.rotate(-i), t.translate(-n, -r);
  }
  constructor(...t) {
    super(...t), this.type = "marker";
  }
}
class hC extends nn {
  render() {
  }
  constructor(...t) {
    super(...t), this.type = "defs";
  }
}
class Vg extends Va {
  getBoundingBox(t) {
    const e = new vr();
    return this.children.forEach((i) => {
      e.addBoundingBox(i.getBoundingBox(t));
    }), e;
  }
  constructor(...t) {
    super(...t), this.type = "g";
  }
}
class sw extends nn {
  getGradientUnits() {
    return this.getAttribute("gradientUnits").getString("objectBoundingBox");
  }
  createGradient(t, e, i) {
    let n = this;
    this.getHrefAttribute().hasValue() && (n = this.getHrefAttribute().getDefinition(), this.inheritStopContainer(n));
    const { stops: r } = n, o = this.getGradient(t, e);
    if (!o)
      return this.addParentOpacity(i, r[r.length - 1].color);
    if (r.forEach((l) => {
      o.addColorStop(l.offset, this.addParentOpacity(i, l.color));
    }), this.getAttribute("gradientTransform").hasValue()) {
      const { document: l } = this, { MAX_VIRTUAL_PIXELS: h } = po, { viewPort: u } = l.screen, d = u.getRoot(), g = new iw(l);
      g.attributes.x = new se(l, "x", -h / 3), g.attributes.y = new se(l, "y", -h / 3), g.attributes.width = new se(l, "width", h), g.attributes.height = new se(l, "height", h);
      const y = new Vg(l);
      y.attributes.transform = new se(l, "transform", this.getAttribute("gradientTransform").getValue()), y.children = [
        g
      ];
      const m = new Hh(l);
      m.attributes.x = new se(l, "x", 0), m.attributes.y = new se(l, "y", 0), m.attributes.width = new se(l, "width", d.width), m.attributes.height = new se(l, "height", d.height), m.children = [
        y
      ];
      const x = l.createCanvas(d.width, d.height), b = x.getContext("2d");
      return b.fillStyle = o, m.render(b), b.createPattern(x, "no-repeat");
    }
    return o;
  }
  inheritStopContainer(t) {
    this.attributesToInherit.forEach((e) => {
      !this.getAttribute(e).hasValue() && t.getAttribute(e).hasValue() && this.getAttribute(e, !0).setValue(t.getAttribute(e).getValue());
    });
  }
  addParentOpacity(t, e) {
    return t.hasValue() ? new se(this.document, "color", e).addOpacity(t).getColor() : e;
  }
  constructor(t, e, i) {
    super(t, e, i), this.attributesToInherit = [
      "gradientUnits"
    ], this.stops = [];
    const { stops: n, children: r } = this;
    r.forEach((o) => {
      o.type === "stop" && n.push(o);
    });
  }
}
class uC extends sw {
  getGradient(t, e) {
    const i = this.getGradientUnits() === "objectBoundingBox", n = i ? e.getBoundingBox(t) : null;
    if (i && !n)
      return null;
    !this.getAttribute("x1").hasValue() && !this.getAttribute("y1").hasValue() && !this.getAttribute("x2").hasValue() && !this.getAttribute("y2").hasValue() && (this.getAttribute("x1", !0).setValue(0), this.getAttribute("y1", !0).setValue(0), this.getAttribute("x2", !0).setValue(1), this.getAttribute("y2", !0).setValue(0));
    const r = i ? n.x + n.width * this.getAttribute("x1").getNumber() : this.getAttribute("x1").getPixels("x"), o = i ? n.y + n.height * this.getAttribute("y1").getNumber() : this.getAttribute("y1").getPixels("y"), l = i ? n.x + n.width * this.getAttribute("x2").getNumber() : this.getAttribute("x2").getPixels("x"), h = i ? n.y + n.height * this.getAttribute("y2").getNumber() : this.getAttribute("y2").getPixels("y");
    return r === l && o === h ? null : t.createLinearGradient(r, o, l, h);
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "linearGradient", this.attributesToInherit.push("x1", "y1", "x2", "y2");
  }
}
class dC extends sw {
  getGradient(t, e) {
    const i = this.getGradientUnits() === "objectBoundingBox", n = e.getBoundingBox(t);
    if (i && !n)
      return null;
    this.getAttribute("cx").hasValue() || this.getAttribute("cx", !0).setValue("50%"), this.getAttribute("cy").hasValue() || this.getAttribute("cy", !0).setValue("50%"), this.getAttribute("r").hasValue() || this.getAttribute("r", !0).setValue("50%");
    const r = i ? n.x + n.width * this.getAttribute("cx").getNumber() : this.getAttribute("cx").getPixels("x"), o = i ? n.y + n.height * this.getAttribute("cy").getNumber() : this.getAttribute("cy").getPixels("y");
    let l = r, h = o;
    this.getAttribute("fx").hasValue() && (l = i ? n.x + n.width * this.getAttribute("fx").getNumber() : this.getAttribute("fx").getPixels("x")), this.getAttribute("fy").hasValue() && (h = i ? n.y + n.height * this.getAttribute("fy").getNumber() : this.getAttribute("fy").getPixels("y"));
    const u = i ? (n.width + n.height) / 2 * this.getAttribute("r").getNumber() : this.getAttribute("r").getPixels(), d = this.getAttribute("fr").getPixels();
    return t.createRadialGradient(l, h, d, r, o, u);
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "radialGradient", this.attributesToInherit.push("cx", "cy", "r", "fx", "fy", "fr");
  }
}
class fC extends nn {
  constructor(t, e, i) {
    super(t, e, i), this.type = "stop";
    const n = Math.max(0, Math.min(1, this.getAttribute("offset").getNumber())), r = this.getStyle("stop-opacity");
    let o = this.getStyle("stop-color", !0);
    o.getString() === "" && o.setValue("#000"), r.hasValue() && (o = o.addOpacity(r)), this.offset = n, this.color = o.getColor();
  }
}
class zg extends nn {
  getProperty() {
    const t = this.getAttribute("attributeType").getString(), e = this.getAttribute("attributeName").getString();
    return t === "CSS" ? this.parent.getStyle(e, !0) : this.parent.getAttribute(e, !0);
  }
  calcValue() {
    const { initialUnits: t } = this, { progress: e, from: i, to: n } = this.getProgress();
    let r = i.getNumber() + (n.getNumber() - i.getNumber()) * e;
    return t === "%" && (r *= 100), "".concat(r).concat(t);
  }
  update(t) {
    const { parent: e } = this, i = this.getProperty();
    if (this.initialValue || (this.initialValue = i.getString(), this.initialUnits = i.getUnits()), this.duration > this.maxDuration) {
      const r = this.getAttribute("fill").getString("remove");
      if (this.getAttribute("repeatCount").getString() === "indefinite" || this.getAttribute("repeatDur").getString() === "indefinite")
        this.duration = 0;
      else if (r === "freeze" && !this.frozen)
        this.frozen = !0, e && i && (e.animationFrozen = !0, e.animationFrozenValue = i.getString());
      else if (r === "remove" && !this.removed)
        return this.removed = !0, e && i && i.setValue(e.animationFrozen ? e.animationFrozenValue : this.initialValue), !0;
      return !1;
    }
    this.duration += t;
    let n = !1;
    if (this.begin < this.duration) {
      let r = this.calcValue();
      const o = this.getAttribute("type");
      if (o.hasValue()) {
        const l = o.getString();
        r = "".concat(l, "(").concat(r, ")");
      }
      i.setValue(r), n = !0;
    }
    return n;
  }
  getProgress() {
    const { document: t, values: e } = this;
    let i = (this.duration - this.begin) / (this.maxDuration - this.begin), n, r;
    if (e.hasValue()) {
      const o = i * (e.getValue().length - 1), l = Math.floor(o), h = Math.ceil(o);
      let u;
      u = e.getValue()[l], n = new se(t, "from", u ? parseFloat(u) : 0), u = e.getValue()[h], r = new se(t, "to", u ? parseFloat(u) : 0), i = (o - l) / (h - l);
    } else
      n = this.from, r = this.to;
    return {
      progress: i,
      from: n,
      to: r
    };
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "animate", this.duration = 0, this.initialUnits = "", this.removed = !1, this.frozen = !1, t.screen.animations.push(this), this.begin = this.getAttribute("begin").getMilliseconds(), this.maxDuration = this.begin + this.getAttribute("dur").getMilliseconds(), this.from = this.getAttribute("from"), this.to = this.getAttribute("to"), this.values = new se(t, "values", null);
    const n = this.getAttribute("values");
    n.hasValue() && this.values.setValue(n.getString().split(";"));
  }
}
class gC extends zg {
  calcValue() {
    const { progress: t, from: e, to: i } = this.getProgress(), n = new eg(e.getColor()), r = new eg(i.getColor());
    if (n.ok && r.ok) {
      const o = n.r + (r.r - n.r) * t, l = n.g + (r.g - n.g) * t, h = n.b + (r.b - n.b) * t;
      return "rgb(".concat(Math.floor(o), ", ").concat(Math.floor(l), ", ").concat(Math.floor(h), ")");
    }
    return this.getAttribute("from").getColor();
  }
  constructor(...t) {
    super(...t), this.type = "animateColor";
  }
}
class pC extends zg {
  calcValue() {
    const { progress: t, from: e, to: i } = this.getProgress(), n = Fs(e.getString()), r = Fs(i.getString());
    return n.map((l, h) => {
      const u = r[h];
      return l + (u - l) * t;
    }).join(" ");
  }
  constructor(...t) {
    super(...t), this.type = "animateTransform";
  }
}
class rw extends nn {
  constructor(t, e, i) {
    super(t, e, i), this.type = "font-face", this.ascent = this.getAttribute("ascent").getNumber(), this.descent = this.getAttribute("descent").getNumber(), this.unitsPerEm = this.getAttribute("units-per-em").getNumber();
  }
}
class Hg extends yi {
  constructor(t, e, i) {
    super(t, e, i), this.type = "glyph", this.horizAdvX = this.getAttribute("horiz-adv-x").getNumber(), this.unicode = this.getAttribute("unicode").getString(), this.arabicForm = this.getAttribute("arabic-form").getString();
  }
}
class ow extends Hg {
  constructor(...t) {
    super(...t), this.type = "missing-glyph", this.horizAdvX = 0;
  }
}
class mC extends nn {
  render() {
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "font", this.isArabic = !1, this.glyphs = {}, this.arabicGlyphs = {}, this.isRTL = !1, this.horizAdvX = this.getAttribute("horiz-adv-x").getNumber();
    const { definitions: n } = t, { children: r } = this;
    for (const o of r)
      if (o instanceof rw) {
        this.fontFace = o;
        const l = o.getStyle("font-family");
        l.hasValue() && (n[l.getString()] = this);
      } else if (o instanceof ow)
        this.missingGlyph = o;
      else if (o instanceof Hg)
        if (o.arabicForm) {
          this.isRTL = !0, this.isArabic = !0;
          const l = this.arabicGlyphs[o.unicode];
          typeof l > "u" ? this.arabicGlyphs[o.unicode] = {
            [o.arabicForm]: o
          } : l[o.arabicForm] = o;
        } else
          this.glyphs[o.unicode] = o;
  }
}
class _C extends qo {
  getText() {
    const t = this.getHrefAttribute().getDefinition();
    if (t) {
      const e = t.children[0];
      if (e)
        return e.getText();
    }
    return "";
  }
  constructor(...t) {
    super(...t), this.type = "tref";
  }
}
class yC extends qo {
  getText() {
    return this.text;
  }
  renderChildren(t) {
    if (this.hasText) {
      super.renderChildren(t);
      const { document: e, x: i, y: n } = this, { mouse: r } = e.screen, o = new se(e, "fontSize", os.parse(e.ctx.font).fontSize);
      r.isWorking() && r.checkBoundingBox(this, new vr(i, n - o.getPixels("y"), i + this.measureText(t), n));
    } else if (this.children.length > 0) {
      const e = new Vg(this.document);
      e.children = this.children, e.parent = this, e.render(t);
    }
  }
  onClick() {
    const { window: t } = this.document;
    t && t.open(this.getHrefAttribute().getString());
  }
  onMouseMove() {
    const t = this.document.ctx;
    t.canvas.style.cursor = "pointer";
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "a";
    const { childNodes: n } = e, r = n[0], o = n.length > 0 && Array.from(n).every(
      (l) => l.nodeType === 3
    );
    this.hasText = o, this.text = o ? this.getTextFromNode(r) : "";
  }
}
class wC extends qo {
  getText() {
    return this.text;
  }
  path(t) {
    const { dataArray: e } = this;
    t && t.beginPath(), e.forEach((i) => {
      let { type: n, points: r } = i;
      switch (n) {
        case Ie.LINE_TO:
          t && t.lineTo(r[0], r[1]);
          break;
        case Ie.MOVE_TO:
          t && t.moveTo(r[0], r[1]);
          break;
        case Ie.CURVE_TO:
          t && t.bezierCurveTo(r[0], r[1], r[2], r[3], r[4], r[5]);
          break;
        case Ie.QUAD_TO:
          t && t.quadraticCurveTo(r[0], r[1], r[2], r[3]);
          break;
        case Ie.ARC: {
          const [o, l, h, u, d, g, y, m] = r, x = h > u ? h : u, b = h > u ? 1 : h / u, I = h > u ? u / h : 1;
          t && (t.translate(o, l), t.rotate(y), t.scale(b, I), t.arc(0, 0, x, d, d + g, !!(1 - m)), t.scale(1 / b, 1 / I), t.rotate(-y), t.translate(-o, -l));
          break;
        }
        case Ie.CLOSE_PATH:
          t && t.closePath();
          break;
      }
    });
  }
  renderChildren(t) {
    this.setTextData(t), t.save();
    const e = this.parent.getStyle("text-decoration").getString(), i = this.getFontSize(), { glyphInfo: n } = this, r = t.fillStyle;
    e === "underline" && t.beginPath(), n.forEach((o, l) => {
      const { p0: h, p1: u, rotation: d, text: g } = o;
      t.save(), t.translate(h.x, h.y), t.rotate(d), t.fillStyle && t.fillText(g, 0, 0), t.strokeStyle && t.strokeText(g, 0, 0), t.restore(), e === "underline" && (l === 0 && t.moveTo(h.x, h.y + i / 8), t.lineTo(u.x, u.y + i / 5));
    }), e === "underline" && (t.lineWidth = i / 20, t.strokeStyle = r, t.stroke(), t.closePath()), t.restore();
  }
  getLetterSpacingAt() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
    return this.letterSpacingCache[t] || 0;
  }
  findSegmentToFitChar(t, e, i, n, r, o, l, h, u) {
    let d = o, g = this.measureText(t, h);
    h === " " && e === "justify" && i < n && (g += (n - i) / r), u > -1 && (d += this.getLetterSpacingAt(u));
    const y = this.textHeight / 20, m = this.getEquidistantPointOnPath(d, y, 0), x = this.getEquidistantPointOnPath(d + g, y, 0), b = {
      p0: m,
      p1: x
    }, I = m && x ? Math.atan2(x.y - m.y, x.x - m.x) : 0;
    if (l) {
      const C = Math.cos(Math.PI / 2 + I) * l, P = Math.cos(-I) * l;
      b.p0 = {
        ...m,
        x: m.x + C,
        y: m.y + P
      }, b.p1 = {
        ...x,
        x: x.x + C,
        y: x.y + P
      };
    }
    return d += g, {
      offset: d,
      segment: b,
      rotation: I
    };
  }
  measureText(t, e) {
    const { measuresCache: i } = this, n = e || this.getText();
    if (i.has(n))
      return i.get(n);
    const r = this.measureTargetText(t, n);
    return i.set(n, r), r;
  }
  // This method supposes what all custom fonts already loaded.
  // If some font will be loaded after this method call, <textPath> will not be rendered correctly.
  // You need to call this method manually to update glyphs cache.
  setTextData(t) {
    if (this.glyphInfo)
      return;
    const e = this.getText(), i = e.split(""), n = e.split(" ").length - 1, r = this.parent.getAttribute("dx").split().map(
      (k) => k.getPixels("x")
    ), o = this.parent.getAttribute("dy").getPixels("y"), l = this.parent.getStyle("text-anchor").getString("start"), h = this.getStyle("letter-spacing"), u = this.parent.getStyle("letter-spacing");
    let d = 0;
    !h.hasValue() || h.getValue() === "inherit" ? d = u.getPixels() : h.hasValue() && h.getValue() !== "initial" && h.getValue() !== "unset" && (d = h.getPixels());
    const g = [], y = e.length;
    this.letterSpacingCache = g;
    for (let k = 0; k < y; k++)
      g.push(typeof r[k] < "u" ? r[k] : d);
    const m = g.reduce(
      (k, O, B) => B === 0 ? 0 : k + O || 0,
      0
    ), x = this.measureText(t), b = Math.max(x + m, 0);
    this.textWidth = x, this.textHeight = this.getFontSize(), this.glyphInfo = [];
    const I = this.getPathLength(), C = this.getStyle("startOffset").getNumber(0) * I;
    let P = 0;
    (l === "middle" || l === "center") && (P = -b / 2), (l === "end" || l === "right") && (P = -b), P += C, i.forEach((k, O) => {
      const { offset: B, segment: j, rotation: V } = this.findSegmentToFitChar(t, l, b, I, n, P, o, k, O);
      P = B, !(!j.p0 || !j.p1) && this.glyphInfo.push({
        // transposeX: midpoint.x,
        // transposeY: midpoint.y,
        text: i[O],
        p0: j.p0,
        p1: j.p1,
        rotation: V
      });
    });
  }
  parsePathData(t) {
    if (this.pathLength = -1, !t)
      return [];
    const e = [], { pathParser: i } = t;
    for (i.reset(); !i.isEnd(); ) {
      const { current: n } = i, r = n ? n.x : 0, o = n ? n.y : 0, l = i.next();
      let h = l.type, u = [];
      switch (l.type) {
        case Ie.MOVE_TO:
          this.pathM(i, u);
          break;
        case Ie.LINE_TO:
          h = this.pathL(i, u);
          break;
        case Ie.HORIZ_LINE_TO:
          h = this.pathH(i, u);
          break;
        case Ie.VERT_LINE_TO:
          h = this.pathV(i, u);
          break;
        case Ie.CURVE_TO:
          this.pathC(i, u);
          break;
        case Ie.SMOOTH_CURVE_TO:
          h = this.pathS(i, u);
          break;
        case Ie.QUAD_TO:
          this.pathQ(i, u);
          break;
        case Ie.SMOOTH_QUAD_TO:
          h = this.pathT(i, u);
          break;
        case Ie.ARC:
          u = this.pathA(i);
          break;
        case Ie.CLOSE_PATH:
          yi.pathZ(i);
          break;
      }
      l.type !== Ie.CLOSE_PATH ? e.push({
        type: h,
        points: u,
        start: {
          x: r,
          y: o
        },
        pathLength: this.calcLength(r, o, h, u)
      }) : e.push({
        type: Ie.CLOSE_PATH,
        points: [],
        pathLength: 0
      });
    }
    return e;
  }
  pathM(t, e) {
    const { x: i, y: n } = yi.pathM(t).point;
    e.push(i, n);
  }
  pathL(t, e) {
    const { x: i, y: n } = yi.pathL(t).point;
    return e.push(i, n), Ie.LINE_TO;
  }
  pathH(t, e) {
    const { x: i, y: n } = yi.pathH(t).point;
    return e.push(i, n), Ie.LINE_TO;
  }
  pathV(t, e) {
    const { x: i, y: n } = yi.pathV(t).point;
    return e.push(i, n), Ie.LINE_TO;
  }
  pathC(t, e) {
    const { point: i, controlPoint: n, currentPoint: r } = yi.pathC(t);
    e.push(i.x, i.y, n.x, n.y, r.x, r.y);
  }
  pathS(t, e) {
    const { point: i, controlPoint: n, currentPoint: r } = yi.pathS(t);
    return e.push(i.x, i.y, n.x, n.y, r.x, r.y), Ie.CURVE_TO;
  }
  pathQ(t, e) {
    const { controlPoint: i, currentPoint: n } = yi.pathQ(t);
    e.push(i.x, i.y, n.x, n.y);
  }
  pathT(t, e) {
    const { controlPoint: i, currentPoint: n } = yi.pathT(t);
    return e.push(i.x, i.y, n.x, n.y), Ie.QUAD_TO;
  }
  pathA(t) {
    let { rX: e, rY: i, sweepFlag: n, xAxisRotation: r, centp: o, a1: l, ad: h } = yi.pathA(t);
    return n === 0 && h > 0 && (h -= 2 * Math.PI), n === 1 && h < 0 && (h += 2 * Math.PI), [
      o.x,
      o.y,
      e,
      i,
      l,
      h,
      r,
      n
    ];
  }
  calcLength(t, e, i, n) {
    let r = 0, o = null, l = null, h = 0;
    switch (i) {
      case Ie.LINE_TO:
        return this.getLineLength(t, e, n[0], n[1]);
      case Ie.CURVE_TO:
        for (r = 0, o = this.getPointOnCubicBezier(0, t, e, n[0], n[1], n[2], n[3], n[4], n[5]), h = 0.01; h <= 1; h += 0.01)
          l = this.getPointOnCubicBezier(h, t, e, n[0], n[1], n[2], n[3], n[4], n[5]), r += this.getLineLength(o.x, o.y, l.x, l.y), o = l;
        return r;
      case Ie.QUAD_TO:
        for (r = 0, o = this.getPointOnQuadraticBezier(0, t, e, n[0], n[1], n[2], n[3]), h = 0.01; h <= 1; h += 0.01)
          l = this.getPointOnQuadraticBezier(h, t, e, n[0], n[1], n[2], n[3]), r += this.getLineLength(o.x, o.y, l.x, l.y), o = l;
        return r;
      case Ie.ARC: {
        r = 0;
        const u = n[4], d = n[5], g = n[4] + d;
        let y = Math.PI / 180;
        if (Math.abs(u - g) < y && (y = Math.abs(u - g)), o = this.getPointOnEllipticalArc(n[0], n[1], n[2], n[3], u, 0), d < 0)
          for (h = u - y; h > g; h -= y)
            l = this.getPointOnEllipticalArc(n[0], n[1], n[2], n[3], h, 0), r += this.getLineLength(o.x, o.y, l.x, l.y), o = l;
        else
          for (h = u + y; h < g; h += y)
            l = this.getPointOnEllipticalArc(n[0], n[1], n[2], n[3], h, 0), r += this.getLineLength(o.x, o.y, l.x, l.y), o = l;
        return l = this.getPointOnEllipticalArc(n[0], n[1], n[2], n[3], g, 0), r += this.getLineLength(o.x, o.y, l.x, l.y), r;
      }
    }
    return 0;
  }
  getPointOnLine(t, e, i, n, r) {
    let o = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : e, l = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : i;
    const h = (r - i) / (n - e + _l);
    let u = Math.sqrt(t * t / (1 + h * h));
    n < e && (u *= -1);
    let d = h * u, g = null;
    if (n === e)
      g = {
        x: o,
        y: l + d
      };
    else if ((l - i) / (o - e + _l) === h)
      g = {
        x: o + u,
        y: l + d
      };
    else {
      let y = 0, m = 0;
      const x = this.getLineLength(e, i, n, r);
      if (x < _l)
        return null;
      let b = (o - e) * (n - e) + (l - i) * (r - i);
      b /= x * x, y = e + b * (n - e), m = i + b * (r - i);
      const I = this.getLineLength(o, l, y, m), C = Math.sqrt(t * t - I * I);
      u = Math.sqrt(C * C / (1 + h * h)), n < e && (u *= -1), d = h * u, g = {
        x: y + u,
        y: m + d
      };
    }
    return g;
  }
  getPointOnPath(t) {
    const e = this.getPathLength();
    let i = 0, n = null;
    if (t < -5e-5 || t - 5e-5 > e)
      return null;
    const { dataArray: r } = this;
    for (const o of r) {
      if (o && (o.pathLength < 5e-5 || i + o.pathLength + 5e-5 < t)) {
        i += o.pathLength;
        continue;
      }
      const l = t - i;
      let h = 0;
      switch (o.type) {
        case Ie.LINE_TO:
          n = this.getPointOnLine(l, o.start.x, o.start.y, o.points[0], o.points[1], o.start.x, o.start.y);
          break;
        case Ie.ARC: {
          const u = o.points[4], d = o.points[5], g = o.points[4] + d;
          if (h = u + l / o.pathLength * d, d < 0 && h < g || d >= 0 && h > g)
            break;
          n = this.getPointOnEllipticalArc(o.points[0], o.points[1], o.points[2], o.points[3], h, o.points[6]);
          break;
        }
        case Ie.CURVE_TO:
          h = l / o.pathLength, h > 1 && (h = 1), n = this.getPointOnCubicBezier(h, o.start.x, o.start.y, o.points[0], o.points[1], o.points[2], o.points[3], o.points[4], o.points[5]);
          break;
        case Ie.QUAD_TO:
          h = l / o.pathLength, h > 1 && (h = 1), n = this.getPointOnQuadraticBezier(h, o.start.x, o.start.y, o.points[0], o.points[1], o.points[2], o.points[3]);
          break;
      }
      if (n)
        return n;
      break;
    }
    return null;
  }
  getLineLength(t, e, i, n) {
    return Math.sqrt((i - t) * (i - t) + (n - e) * (n - e));
  }
  getPathLength() {
    return this.pathLength === -1 && (this.pathLength = this.dataArray.reduce(
      (t, e) => e.pathLength > 0 ? t + e.pathLength : t,
      0
    )), this.pathLength;
  }
  getPointOnCubicBezier(t, e, i, n, r, o, l, h, u) {
    const d = h * fm(t) + o * gm(t) + n * pm(t) + e * mm(t), g = u * fm(t) + l * gm(t) + r * pm(t) + i * mm(t);
    return {
      x: d,
      y: g
    };
  }
  getPointOnQuadraticBezier(t, e, i, n, r, o, l) {
    const h = o * _m(t) + n * ym(t) + e * wm(t), u = l * _m(t) + r * ym(t) + i * wm(t);
    return {
      x: h,
      y: u
    };
  }
  getPointOnEllipticalArc(t, e, i, n, r, o) {
    const l = Math.cos(o), h = Math.sin(o), u = {
      x: i * Math.cos(r),
      y: n * Math.sin(r)
    };
    return {
      x: t + (u.x * l - u.y * h),
      y: e + (u.x * h + u.y * l)
    };
  }
  // TODO need some optimisations. possibly build cache only for curved segments?
  buildEquidistantCache(t, e) {
    const i = this.getPathLength(), n = e || 0.25, r = t || i / 100;
    if (!this.equidistantCache || this.equidistantCache.step !== r || this.equidistantCache.precision !== n) {
      this.equidistantCache = {
        step: r,
        precision: n,
        points: []
      };
      let o = 0;
      for (let l = 0; l <= i; l += n) {
        const h = this.getPointOnPath(l), u = this.getPointOnPath(l + n);
        !h || !u || (o += this.getLineLength(h.x, h.y, u.x, u.y), o >= r && (this.equidistantCache.points.push({
          x: h.x,
          y: h.y,
          distance: l
        }), o -= r));
      }
    }
  }
  getEquidistantPointOnPath(t, e, i) {
    if (this.buildEquidistantCache(e, i), t < 0 || t - this.getPathLength() > 5e-5)
      return null;
    const n = Math.round(t / this.getPathLength() * (this.equidistantCache.points.length - 1));
    return this.equidistantCache.points[n] || null;
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "textPath", this.textWidth = 0, this.textHeight = 0, this.pathLength = -1, this.glyphInfo = null, this.letterSpacingCache = [], this.measuresCache = /* @__PURE__ */ new Map([
      [
        "",
        0
      ]
    ]);
    const n = this.getHrefAttribute().getDefinition();
    this.text = this.getTextFromNode(), this.dataArray = this.parsePathData(n);
  }
}
const vC = /^\s*data:(([^/,;]+\/[^/,;]+)(?:;([^,;=]+=[^,;=]+))?)?(?:;(base64))?,(.*)$/i;
class bC extends Va {
  async loadImage(t) {
    try {
      const e = await this.document.createImage(t);
      this.image = e;
    } catch (e) {
      console.error('Error while loading image "'.concat(t, '":'), e);
    }
    this.loaded = !0;
  }
  async loadSvg(t) {
    const e = vC.exec(t);
    if (e) {
      const i = e[5];
      i && (e[4] === "base64" ? this.image = atob(i) : this.image = decodeURIComponent(i));
    } else
      try {
        const n = await (await this.document.fetch(t)).text();
        this.image = n;
      } catch (i) {
        console.error('Error while loading image "'.concat(t, '":'), i);
      }
    this.loaded = !0;
  }
  renderChildren(t) {
    const { document: e, image: i, loaded: n } = this, r = this.getAttribute("x").getPixels("x"), o = this.getAttribute("y").getPixels("y"), l = this.getStyle("width").getPixels("x"), h = this.getStyle("height").getPixels("y");
    if (!(!n || !i || !l || !h)) {
      if (t.save(), t.translate(r, o), typeof i == "string") {
        const u = e.canvg.forkString(t, i, {
          ignoreMouse: !0,
          ignoreAnimation: !0,
          ignoreDimensions: !0,
          ignoreClear: !0,
          offsetX: 0,
          offsetY: 0,
          scaleWidth: l,
          scaleHeight: h
        }), { documentElement: d } = u.document;
        d && (d.parent = this), u.render();
      } else
        e.setViewBox({
          ctx: t,
          aspectRatio: this.getAttribute("preserveAspectRatio").getString(),
          width: l,
          desiredWidth: i.width,
          height: h,
          desiredHeight: i.height
        }), this.loaded && (!("complete" in i) || i.complete) && t.drawImage(i, 0, 0);
      t.restore();
    }
  }
  getBoundingBox() {
    const t = this.getAttribute("x").getPixels("x"), e = this.getAttribute("y").getPixels("y"), i = this.getStyle("width").getPixels("x"), n = this.getStyle("height").getPixels("y");
    return new vr(t, e, t + i, e + n);
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "image", this.loaded = !1;
    const n = this.getHrefAttribute().getString();
    if (!n)
      return;
    const r = n.endsWith(".svg") || /^\s*data:image\/svg\+xml/i.test(n);
    t.images.push(this), r ? this.loadSvg(n) : this.loadImage(n);
  }
}
class xC extends Va {
  render(t) {
  }
  constructor(...t) {
    super(...t), this.type = "symbol";
  }
}
class IC {
  async load(t, e) {
    try {
      const { document: i } = this, r = (await i.canvg.parser.load(e)).getElementsByTagName("font");
      Array.from(r).forEach((o) => {
        const l = i.createElement(o);
        i.definitions[t] = l;
      });
    } catch (i) {
      console.error('Error while loading font "'.concat(e, '":'), i);
    }
    this.loaded = !0;
  }
  constructor(t) {
    this.document = t, this.loaded = !1, t.fonts.push(this);
  }
}
class aw extends nn {
  constructor(t, e, i) {
    super(t, e, i), this.type = "style", Bl(
      Array.from(e.childNodes).map(
        (o) => o.textContent
      ).join("").replace(/(\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+\/)|(^[\s]*\/\/.*)/gm, "").replace(/@import.*;/g, "")
      // remove imports
    ).split("}").forEach((o) => {
      const l = o.trim();
      if (!l)
        return;
      const h = l.split("{"), u = h[0].split(","), d = h[1].split(";");
      u.forEach((g) => {
        const y = g.trim();
        if (!y)
          return;
        const m = t.styles[y] || {};
        if (d.forEach((x) => {
          const b = x.indexOf(":"), I = x.substr(0, b).trim(), C = x.substr(b + 1, x.length - b).trim();
          I && C && (m[I] = new se(t, I, C));
        }), t.styles[y] = m, t.stylesSpecificity[y] = HI(y), y === "@font-face") {
          const x = m["font-family"].getString().replace(/"|'/g, "");
          m.src.getString().split(",").forEach((I) => {
            if (I.indexOf('format("svg")') > 0) {
              const C = Yy(I);
              C && new IC(t).load(x, C);
            }
          });
        }
      });
    });
  }
}
aw.parseExternalUrl = Yy;
class CC extends Va {
  setContext(t) {
    super.setContext(t);
    const e = this.getAttribute("x"), i = this.getAttribute("y");
    e.hasValue() && t.translate(e.getPixels("x"), 0), i.hasValue() && t.translate(0, i.getPixels("y"));
  }
  path(t) {
    const { element: e } = this;
    e && e.path(t);
  }
  renderChildren(t) {
    const { document: e, element: i } = this;
    if (i) {
      let n = i;
      if (i.type === "symbol" && (n = new Hh(e), n.attributes.viewBox = new se(e, "viewBox", i.getAttribute("viewBox").getString()), n.attributes.preserveAspectRatio = new se(e, "preserveAspectRatio", i.getAttribute("preserveAspectRatio").getString()), n.attributes.overflow = new se(e, "overflow", i.getAttribute("overflow").getString()), n.children = i.children, i.styles.opacity = new se(e, "opacity", this.calculateOpacity())), n.type === "svg") {
        const o = this.getStyle("width", !1, !0), l = this.getStyle("height", !1, !0);
        o.hasValue() && (n.attributes.width = new se(e, "width", o.getString())), l.hasValue() && (n.attributes.height = new se(e, "height", l.getString()));
      }
      const r = n.parent;
      n.parent = this, n.render(t), n.parent = r;
    }
  }
  getBoundingBox(t) {
    const { element: e } = this;
    return e ? e.getBoundingBox(t) : null;
  }
  elementTransform() {
    const { document: t, element: e } = this;
    return e ? La.fromElement(t, e) : null;
  }
  get element() {
    return this.cachedElement || (this.cachedElement = this.getHrefAttribute().getDefinition()), this.cachedElement;
  }
  constructor(...t) {
    super(...t), this.type = "use";
  }
}
function xu(s, t, e, i, n, r) {
  return s[e * i * 4 + t * 4 + r];
}
function Iu(s, t, e, i, n, r, o) {
  s[e * i * 4 + t * 4 + r] = o;
}
function fn(s, t, e) {
  return s[t] * e;
}
function to(s, t, e, i) {
  return t + Math.cos(s) * e + Math.sin(s) * i;
}
class lw extends nn {
  apply(t, e, i, n, r) {
    const { includeOpacity: o, matrix: l } = this, h = t.getImageData(0, 0, n, r);
    for (let u = 0; u < r; u++)
      for (let d = 0; d < n; d++) {
        const g = xu(h.data, d, u, n, r, 0), y = xu(h.data, d, u, n, r, 1), m = xu(h.data, d, u, n, r, 2), x = xu(h.data, d, u, n, r, 3);
        let b = fn(l, 0, g) + fn(l, 1, y) + fn(l, 2, m) + fn(l, 3, x) + fn(l, 4, 1), I = fn(l, 5, g) + fn(l, 6, y) + fn(l, 7, m) + fn(l, 8, x) + fn(l, 9, 1), C = fn(l, 10, g) + fn(l, 11, y) + fn(l, 12, m) + fn(l, 13, x) + fn(l, 14, 1), P = fn(l, 15, g) + fn(l, 16, y) + fn(l, 17, m) + fn(l, 18, x) + fn(l, 19, 1);
        o && (b = 0, I = 0, C = 0, P *= x / 255), Iu(h.data, d, u, n, r, 0, b), Iu(h.data, d, u, n, r, 1, I), Iu(h.data, d, u, n, r, 2, C), Iu(h.data, d, u, n, r, 3, P);
      }
    t.clearRect(0, 0, n, r), t.putImageData(h, 0, 0);
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "feColorMatrix";
    let n = Fs(this.getAttribute("values").getString());
    switch (this.getAttribute("type").getString("matrix")) {
      case "saturate": {
        const r = n[0];
        n = [
          0.213 + 0.787 * r,
          0.715 - 0.715 * r,
          0.072 - 0.072 * r,
          0,
          0,
          0.213 - 0.213 * r,
          0.715 + 0.285 * r,
          0.072 - 0.072 * r,
          0,
          0,
          0.213 - 0.213 * r,
          0.715 - 0.715 * r,
          0.072 + 0.928 * r,
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          1
        ];
        break;
      }
      case "hueRotate": {
        const r = n[0] * Math.PI / 180;
        n = [
          to(r, 0.213, 0.787, -0.213),
          to(r, 0.715, -0.715, -0.715),
          to(r, 0.072, -0.072, 0.928),
          0,
          0,
          to(r, 0.213, -0.213, 0.143),
          to(r, 0.715, 0.285, 0.14),
          to(r, 0.072, -0.072, -0.283),
          0,
          0,
          to(r, 0.213, -0.213, -0.787),
          to(r, 0.715, -0.715, 0.715),
          to(r, 0.072, 0.928, 0.072),
          0,
          0,
          0,
          0,
          0,
          1,
          0,
          0,
          0,
          0,
          0,
          1
        ];
        break;
      }
      case "luminanceToAlpha":
        n = [
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0,
          0.2125,
          0.7154,
          0.0721,
          0,
          0,
          0,
          0,
          0,
          0,
          1
        ];
        break;
    }
    this.matrix = n, this.includeOpacity = this.getAttribute("includeOpacity").hasValue();
  }
}
class Ed extends nn {
  apply(t, e) {
    const { document: i } = this;
    let n = this.getAttribute("x").getPixels("x"), r = this.getAttribute("y").getPixels("y"), o = this.getStyle("width").getPixels("x"), l = this.getStyle("height").getPixels("y");
    if (!o && !l) {
      const m = new vr();
      this.children.forEach((x) => {
        m.addBoundingBox(x.getBoundingBox(t));
      }), n = Math.floor(m.x1), r = Math.floor(m.y1), o = Math.floor(m.width), l = Math.floor(m.height);
    }
    const h = this.removeStyles(e, Ed.ignoreStyles), u = i.createCanvas(n + o, r + l), d = u.getContext("2d");
    i.screen.setDefaults(d), this.renderChildren(d), new lw(i, {
      nodeType: 1,
      childNodes: [],
      attributes: [
        {
          nodeName: "type",
          value: "luminanceToAlpha"
        },
        {
          nodeName: "includeOpacity",
          value: "true"
        }
      ]
    }).apply(d, 0, 0, n + o, r + l);
    const g = i.createCanvas(n + o, r + l), y = g.getContext("2d");
    i.screen.setDefaults(y), e.render(y), y.globalCompositeOperation = "destination-in", y.fillStyle = d.createPattern(u, "no-repeat"), y.fillRect(0, 0, n + o, r + l), t.fillStyle = y.createPattern(g, "no-repeat"), t.fillRect(0, 0, n + o, r + l), this.restoreStyles(e, h);
  }
  render(t) {
  }
  constructor(...t) {
    super(...t), this.type = "mask";
  }
}
Ed.ignoreStyles = [
  "mask",
  "transform",
  "clip-path"
];
const bm = () => {
};
class SC extends nn {
  apply(t) {
    const { document: e } = this, i = Reflect.getPrototypeOf(t), { beginPath: n, closePath: r } = t;
    i && (i.beginPath = bm, i.closePath = bm), Reflect.apply(n, t, []), this.children.forEach((o) => {
      if (!("path" in o))
        return;
      let l = "elementTransform" in o ? o.elementTransform() : null;
      l || (l = La.fromElement(e, o)), l && l.apply(t), o.path(t), i && (i.closePath = r), l && l.unapply(t);
    }), Reflect.apply(r, t, []), t.clip(), i && (i.beginPath = n, i.closePath = r);
  }
  render(t) {
  }
  constructor(...t) {
    super(...t), this.type = "clipPath";
  }
}
class Ad extends nn {
  apply(t, e) {
    const { document: i, children: n } = this, r = "getBoundingBox" in e ? e.getBoundingBox(t) : null;
    if (!r)
      return;
    let o = 0, l = 0;
    n.forEach((C) => {
      const P = C.extraFilterDistance || 0;
      o = Math.max(o, P), l = Math.max(l, P);
    });
    const h = Math.floor(r.width), u = Math.floor(r.height), d = h + 2 * o, g = u + 2 * l;
    if (d < 1 || g < 1)
      return;
    const y = Math.floor(r.x), m = Math.floor(r.y), x = this.removeStyles(e, Ad.ignoreStyles), b = i.createCanvas(d, g), I = b.getContext("2d");
    i.screen.setDefaults(I), I.translate(-y + o, -m + l), e.render(I), n.forEach((C) => {
      typeof C.apply == "function" && C.apply(I, 0, 0, d, g);
    }), t.drawImage(b, 0, 0, d, g, y - o, m - l, d, g), this.restoreStyles(e, x);
  }
  render(t) {
  }
  constructor(...t) {
    super(...t), this.type = "filter";
  }
}
Ad.ignoreStyles = [
  "filter",
  "transform",
  "clip-path"
];
class PC extends nn {
  apply(t, e, i, n, r) {
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "feDropShadow", this.addStylesFromStyleDefinition();
  }
}
class kC extends nn {
  apply(t, e, i, n, r) {
  }
  constructor(...t) {
    super(...t), this.type = "feMorphology";
  }
}
class MC extends nn {
  apply(t, e, i, n, r) {
  }
  constructor(...t) {
    super(...t), this.type = "feComposite";
  }
}
class EC extends nn {
  apply(t, e, i, n, r) {
    const { document: o, blurRadius: l } = this, h = o.window ? o.window.document.body : null, u = t.canvas;
    u.id = o.getUniqueId(), h && (u.style.display = "none", h.appendChild(u)), PI(u, e, i, n, r, l), h && h.removeChild(u);
  }
  constructor(t, e, i) {
    super(t, e, i), this.type = "feGaussianBlur", this.blurRadius = Math.floor(this.getAttribute("stdDeviation").getNumber()), this.extraFilterDistance = this.blurRadius;
  }
}
class AC extends nn {
  constructor(...t) {
    super(...t), this.type = "title";
  }
}
class TC extends nn {
  constructor(...t) {
    super(...t), this.type = "desc";
  }
}
const NC = {
  svg: Hh,
  rect: iw,
  circle: sC,
  ellipse: rC,
  line: oC,
  polyline: nw,
  polygon: aC,
  path: yi,
  pattern: lC,
  marker: cC,
  defs: hC,
  linearGradient: uC,
  radialGradient: dC,
  stop: fC,
  animate: zg,
  animateColor: gC,
  animateTransform: pC,
  font: mC,
  "font-face": rw,
  "missing-glyph": ow,
  glyph: Hg,
  text: qo,
  tspan: Md,
  tref: _C,
  a: yC,
  textPath: wC,
  image: bC,
  g: Vg,
  symbol: xC,
  style: aw,
  use: CC,
  mask: Ed,
  clipPath: SC,
  filter: Ad,
  feDropShadow: PC,
  feMorphology: kC,
  feComposite: MC,
  feColorMatrix: lw,
  feGaussianBlur: EC,
  title: AC,
  desc: TC
};
function DC(s, t) {
  const e = document.createElement("canvas");
  return e.width = s, e.height = t, e;
}
async function OC(s) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1;
  const e = document.createElement("img");
  return t && (e.crossOrigin = "Anonymous"), new Promise((i, n) => {
    e.onload = () => {
      i(e);
    }, e.onerror = (r, o, l, h, u) => {
      n(u);
    }, e.src = s;
  });
}
const vf = 12;
class Vo {
  bindCreateImage(t, e) {
    return typeof e == "boolean" ? (i, n) => t(i, typeof n == "boolean" ? n : e) : t;
  }
  get window() {
    return this.screen.window;
  }
  get fetch() {
    return this.screen.fetch;
  }
  get ctx() {
    return this.screen.ctx;
  }
  get emSize() {
    const { emSizeStack: t } = this;
    return t[t.length - 1] || vf;
  }
  set emSize(t) {
    const { emSizeStack: e } = this;
    e.push(t);
  }
  popEmSize() {
    const { emSizeStack: t } = this;
    t.pop();
  }
  getUniqueId() {
    return "canvg".concat(++this.uniqueId);
  }
  isImagesLoaded() {
    return this.images.every(
      (t) => t.loaded
    );
  }
  isFontsLoaded() {
    return this.fonts.every(
      (t) => t.loaded
    );
  }
  createDocumentElement(t) {
    const e = this.createElement(t.documentElement);
    return e.root = !0, e.addStylesFromStyleDefinition(), this.documentElement = e, e;
  }
  createElement(t) {
    const e = t.nodeName.replace(/^[^:]+:/, ""), i = Vo.elementTypes[e];
    return i ? new i(this, t) : new ZI(this, t);
  }
  createTextNode(t) {
    return new nC(this, t);
  }
  setViewBox(t) {
    this.screen.setViewBox({
      document: this,
      ...t
    });
  }
  constructor(t, { rootEmSize: e = vf, emSize: i = vf, createCanvas: n = Vo.createCanvas, createImage: r = Vo.createImage, anonymousCrossOrigin: o } = {}) {
    this.canvg = t, this.definitions = {}, this.styles = {}, this.stylesSpecificity = {}, this.images = [], this.fonts = [], this.emSizeStack = [], this.uniqueId = 0, this.screen = t.screen, this.rootEmSize = e, this.emSize = i, this.createCanvas = n, this.createImage = this.bindCreateImage(r, o), this.screen.wait(
      () => this.isImagesLoaded()
    ), this.screen.wait(
      () => this.isFontsLoaded()
    );
  }
}
Vo.createCanvas = DC;
Vo.createImage = OC;
Vo.elementTypes = NC;
class ya {
  /**
  * Create Canvg instance from SVG source string or URL.
  * @param ctx - Rendering context.
  * @param svg - SVG source string or URL.
  * @param options - Rendering options.
  * @returns Canvg instance.
  */
  static async from(t, e) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const r = await new wf(i).parse(e);
    return new ya(t, r, i);
  }
  /**
  * Create Canvg instance from SVG source string.
  * @param ctx - Rendering context.
  * @param svg - SVG source string.
  * @param options - Rendering options.
  * @returns Canvg instance.
  */
  static fromString(t, e) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const r = new wf(i).parseFromString(e);
    return new ya(t, r, i);
  }
  /**
  * Create new Canvg instance with inherited options.
  * @param ctx - Rendering context.
  * @param svg - SVG source string or URL.
  * @param options - Rendering options.
  * @returns Canvg instance.
  */
  fork(t, e) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return ya.from(t, e, {
      ...this.options,
      ...i
    });
  }
  /**
  * Create new Canvg instance with inherited options.
  * @param ctx - Rendering context.
  * @param svg - SVG source string.
  * @param options - Rendering options.
  * @returns Canvg instance.
  */
  forkString(t, e) {
    let i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return ya.fromString(t, e, {
      ...this.options,
      ...i
    });
  }
  /**
  * Document is ready promise.
  * @returns Ready promise.
  */
  ready() {
    return this.screen.ready();
  }
  /**
  * Document is ready value.
  * @returns Is ready or not.
  */
  isReady() {
    return this.screen.isReady();
  }
  /**
  * Render only first frame, ignoring animations and mouse.
  * @param options - Rendering options.
  */
  async render() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.start({
      enableRedraw: !0,
      ignoreAnimation: !0,
      ignoreMouse: !0,
      ...t
    }), await this.ready(), this.stop();
  }
  /**
  * Start rendering.
  * @param options - Render options.
  */
  start() {
    let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const { documentElement: e, screen: i, options: n } = this;
    i.start(e, {
      enableRedraw: !0,
      ...n,
      ...t
    });
  }
  /**
  * Stop rendering.
  */
  stop() {
    this.screen.stop();
  }
  /**
  * Resize SVG to fit in given size.
  * @param width
  * @param height
  * @param preserveAspectRatio
  */
  resize(t) {
    let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : t, i = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
    this.documentElement.resize(t, e, i);
  }
  /**
  * Main constructor.
  * @param ctx - Rendering context.
  * @param svg - SVG Document.
  * @param options - Rendering options.
  */
  constructor(t, e, i = {}) {
    this.parser = new wf(i), this.screen = new po(t, i), this.options = i;
    const n = new Vo(this, i), r = n.createDocumentElement(e);
    this.document = n, this.documentElement = r;
  }
}
(function(s, t, e, i, n, r) {
  function o(w, S, E, F, Z) {
    return m(w, w, E, F, S, w.defaultView.pageXOffset, w.defaultView.pageYOffset).then(function(it) {
      R("Document cloned");
      var Mt = "data-html2canvas-node" + Z, pt = "[" + Mt + "='" + Z + "']";
      w.querySelector(pt).removeAttribute(Mt);
      var Mt = it.contentWindow, zt = Mt.document.querySelector(pt);
      return (typeof S.onclone == "function" ? Promise.resolve(S.onclone(Mt.document)) : Promise.resolve(!0)).then(function() {
        return l(zt, it, S, E, F);
      });
    });
  }
  function l(w, S, E, F, Z) {
    var it = S.contentWindow, pt = new ls(it.document), Mt = new J(E, pt), zt = ot(w);
    F = E.type === "view" ? F : u(it.document), Z = E.type === "view" ? Z : d(it.document);
    var me = new E.renderer(F, Z, Mt, E, t);
    return new Pt(w, me, pt, Mt, E).ready.then(function() {
      R("Finished rendering");
      var ii;
      return ii = E.type === "view" ? h(me.canvas, {
        width: me.canvas.width,
        height: me.canvas.height,
        top: 0,
        left: 0,
        x: 0,
        y: 0
      }) : w === it.document.body || w === it.document.documentElement || E.canvas != null ? me.canvas : h(me.canvas, {
        width: E.width != null ? E.width : zt.width,
        height: E.height != null ? E.height : zt.height,
        top: zt.top,
        left: zt.left,
        x: it.pageXOffset,
        y: it.pageYOffset
      }), E.removeContainer && (S.parentNode.removeChild(S), R("Cleaned up container")), ii;
    });
  }
  function h(w, S) {
    var E = t.createElement("canvas"), F = Math.min(w.width - 1, Math.max(0, S.left)), Z = Math.min(w.width, Math.max(1, S.left + S.width)), it = Math.min(w.height - 1, Math.max(0, S.top)), pt = Math.min(w.height, Math.max(1, S.top + S.height));
    return E.width = S.width, E.height = S.height, R("Cropping canvas at:", "left:", S.left, "top:", S.top, "width:", Z - F, "height:", pt - it), R("Resulting crop with width", S.width, "and height", S.height, " with x", F, "and y", it), E.getContext("2d").drawImage(w, F, it, Z - F, pt - it, S.x, S.y, Z - F, pt - it), E;
  }
  function u(w) {
    return Math.max(
      Math.max(w.body.scrollWidth, w.documentElement.scrollWidth),
      Math.max(w.body.offsetWidth, w.documentElement.offsetWidth),
      Math.max(w.body.clientWidth, w.documentElement.clientWidth)
    );
  }
  function d(w) {
    return Math.max(
      Math.max(w.body.scrollHeight, w.documentElement.scrollHeight),
      Math.max(w.body.offsetHeight, w.documentElement.offsetHeight),
      Math.max(w.body.clientHeight, w.documentElement.clientHeight)
    );
  }
  function g() {
    return "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
  }
  function y(w, S) {
    for (var E = w.nodeType === 3 ? t.createTextNode(w.nodeValue) : w.cloneNode(!1), F = w.firstChild; F; )
      S !== !0 && F.nodeType === 1 && F.nodeName === "SCRIPT" || E.appendChild(y(F, S)), F = F.nextSibling;
    return E;
  }
  function m(w, S, E, F, Z, it, pt) {
    C(w);
    var Mt = t.documentMode && 9 >= t.documentMode ? y(w.documentElement, Z.javascriptEnabled) : w.documentElement.cloneNode(!0), zt = S.createElement("iframe");
    return zt.className = "html2canvas-container", zt.style.visibility = "hidden", zt.style.position = "fixed", zt.style.left = "-10000px", zt.style.top = "0px", zt.style.border = "0", zt.width = E, zt.height = F, zt.scrolling = "no", S.body.appendChild(zt), new Promise(function(me) {
      var ii = zt.contentWindow.document;
      x(w.documentElement, Mt, "textarea"), x(w.documentElement, Mt, "select"), zt.contentWindow.onload = zt.onload = function() {
        var Ki = setInterval(function() {
          0 < ii.body.childNodes.length && (P(w, ii), clearInterval(Ki), Z.type === "view" && zt.contentWindow.scrollTo(it, pt), me(zt));
        }, 50);
      }, ii.open(), ii.write("<!DOCTYPE html><html></html>"), !w.defaultView || it === w.defaultView.pageXOffset && pt === w.defaultView.pageYOffset || w.defaultView.scrollTo(it, pt), ii.replaceChild(
        Z.javascriptEnabled === !0 ? ii.adoptNode(Mt) : k(ii.adoptNode(Mt)),
        ii.documentElement
      ), ii.close();
    });
  }
  function x(w, S, E) {
    w = w.getElementsByTagName(E), S = S.getElementsByTagName(E), E = w.length;
    for (var F = 0; F < E; F++)
      S[F].value = w[F].value;
  }
  function b(w, S, E, F, Z, it) {
    return new $i(w, S, s.document).then(I(w)).then(function(pt) {
      return m(pt, E, F, Z, it, 0, 0);
    });
  }
  function I(w) {
    return function(S) {
      var E = new DOMParser(), F;
      try {
        F = E.parseFromString(S, "text/html");
      } catch {
        R("DOMParser not supported, falling back to createHTMLDocument"), F = t.implementation.createHTMLDocument("");
        try {
          F.open(), F.write(S), F.close();
        } catch {
          R("createHTMLDocument write not supported, falling back to document.body.innerHTML"), F.body.innerHTML = S;
        }
      }
      return S = F.querySelector("base"), S && S.href.host || (S = F.createElement("base"), S.href = w, F.head.insertBefore(S, F.head.firstChild)), F;
    };
  }
  function C(w) {
    [].slice.call(w.querySelectorAll("canvas"), 0).forEach(function(S) {
      S.setAttribute("data-html2canvas-canvas-clone", "canvas-" + mo++);
    });
  }
  function P(w, S) {
    [].slice.call(w.querySelectorAll("[data-html2canvas-canvas-clone]"), 0).forEach(function(E) {
      try {
        var F = S.querySelector(
          '[data-html2canvas-canvas-clone="' + E.getAttribute("data-html2canvas-canvas-clone") + '"]'
        );
        F && (F.width = E.width, F.height = E.height, F.getContext("2d").putImageData(E.getContext("2d").getImageData(0, 0, E.width, E.height), 0, 0));
      } catch (Z) {
        R("Unable to copy canvas content from", E, Z);
      }
      E.removeAttribute("data-html2canvas-canvas-clone");
    });
  }
  function k(w) {
    return [].slice.call(w.childNodes, 0).filter(O).forEach(function(S) {
      S.tagName === "SCRIPT" ? w.removeChild(S) : k(S);
    }), w;
  }
  function O(w) {
    return w.nodeType === Node.ELEMENT_NODE;
  }
  function B(w) {
    var S = t.createElement("a");
    return S.href = w, S.href = S.href, S;
  }
  function j(w) {
    this.b = this.g = this.r = 0, this.a = null, this.fromArray(w) || this.namedColor(w) || this.rgb(w) || this.rgba(w) || this.hex6(w) || this.hex3(w);
  }
  function V(w) {
    if (this.src = w, R("DummyImageContainer for", w), !this.promise || !this.image) {
      R("Initiating DummyImageContainer"), V.prototype.image = new Image();
      var S = this.image;
      V.prototype.promise = new Promise(function(E, F) {
        S.onload = E, S.onerror = F, S.src = g(), S.complete === !0 && E(S);
      });
    }
  }
  function Y(w, S) {
    var E = t.createElement("div"), F = t.createElement("img"), Z = t.createElement("span"), it;
    E.style.visibility = "hidden", E.style.fontFamily = w, E.style.fontSize = S, E.style.margin = 0, E.style.padding = 0, t.body.appendChild(E), F.src = g(), F.width = 1, F.height = 1, F.style.margin = 0, F.style.padding = 0, F.style.verticalAlign = "baseline", Z.style.fontFamily = w, Z.style.fontSize = S, Z.style.margin = 0, Z.style.padding = 0, Z.appendChild(t.createTextNode("Hidden Text")), E.appendChild(Z), E.appendChild(F), it = F.offsetTop - Z.offsetTop + 1, E.removeChild(Z), E.appendChild(t.createTextNode("Hidden Text")), E.style.lineHeight = "normal", F.style.verticalAlign = "super", F = F.offsetTop - E.offsetTop + 1, t.body.removeChild(E), this.baseline = it, this.lineWidth = 1, this.middle = F;
  }
  function q() {
    this.data = {};
  }
  function st(w, S, E) {
    this.image = null, this.src = w;
    var F = this, Z = ot(w);
    this.promise = (S ? new Promise(function(it) {
      w.contentWindow.document.URL === "about:blank" || w.contentWindow.document.documentElement == null ? w.contentWindow.onload = w.onload = function() {
        it(w);
      } : it(w);
    }) : this.proxyLoad(E.proxy, Z, E)).then(function(it) {
      return html2canvas(it.contentWindow.document.documentElement, {
        type: "view",
        width: it.width,
        height: it.height,
        proxy: E.proxy,
        javascriptEnabled: E.javascriptEnabled,
        removeContainer: E.removeContainer,
        allowTaint: E.allowTaint,
        imageTimeout: E.imageTimeout / 2
      });
    }).then(function(it) {
      return F.image = it;
    });
  }
  function dt(w) {
    this.src = w.value, this.colorStops = [], this.type = null, this.y1 = this.x1 = this.y0 = this.x0 = 0.5, this.promise = Promise.resolve(!0);
  }
  function U(w, S) {
    this.src = w, this.image = new Image();
    var E = this;
    this.tainted = null, this.promise = new Promise(function(F, Z) {
      E.image.onload = F, E.image.onerror = Z, S && (E.image.crossOrigin = "anonymous"), E.image.src = w, E.image.complete === !0 && F(E.image);
    });
  }
  function J(w, S) {
    this.link = null, this.options = w, this.support = S, this.origin = this.getOrigin(s.location.href);
  }
  function A(w) {
    dt.apply(this, arguments), this.type = this.TYPES.LINEAR;
    var S = w.args[0].match(this.stepRegExp) === null;
    S ? w.args[0].split(" ").reverse().forEach(function(E) {
      switch (E) {
        case "left":
          this.x0 = 0, this.x1 = 1;
          break;
        case "top":
          this.y0 = 0, this.y1 = 1;
          break;
        case "right":
          this.x0 = 1, this.x1 = 0;
          break;
        case "bottom":
          this.y0 = 1, this.y1 = 0;
          break;
        case "to":
          E = this.y0;
          var F = this.x0;
          this.y0 = this.y1, this.x0 = this.x1, this.x1 = F, this.y1 = E;
      }
    }, this) : (this.y0 = 0, this.y1 = 1), this.colorStops = w.args.slice(S ? 1 : 0).map(function(E) {
      return E = E.match(this.stepRegExp), { color: new j(E[1]), stop: E[3] === "%" ? E[2] / 100 : null };
    }, this), this.colorStops[0].stop === null && (this.colorStops[0].stop = 0), this.colorStops[this.colorStops.length - 1].stop === null && (this.colorStops[this.colorStops.length - 1].stop = 1), this.colorStops.forEach(function(E, F) {
      E.stop === null && this.colorStops.slice(F).some(function(Z, it) {
        return Z.stop !== null ? (E.stop = (Z.stop - this.colorStops[F - 1].stop) / (it + 1) + this.colorStops[F - 1].stop, !0) : !1;
      }, this);
    }, this);
  }
  function R() {
    s.html2canvas.logging && s.console && s.console.log && Function.prototype.bind.call(s.console.log, s.console).apply(
      s.console,
      [Date.now() - s.html2canvas.start + "ms", "html2canvas:"].concat(
        [].slice.call(arguments, 0)
      )
    );
  }
  function wt(w, S) {
    this.node = w, this.parent = S, this.borders = this.bounds = this.stack = null, this.clip = [], this.backgroundClip = [], this.computedStyles = this.visible = this.offsetBounds = null, this.colors = {}, this.styles = {}, this.transformMatrix = this.transformData = this.backgroundImages = null, this.isPseudoElement = !1, this.opacity = null;
  }
  function z(w) {
    if (w && w[1] === "matrix")
      return w[2].split(",").map(function(S) {
        return parseFloat(S.trim());
      });
  }
  function St(w) {
    return w.toString().indexOf("%") !== -1;
  }
  function X(w) {
    var S, E, F, Z, it, pt = [], Mt = 0, zt = 0, me, ii, Ki = function() {
      S && (E.substr(0, 1) === '"' && (E = E.substr(1, E.length - 2)), E && ii.push(E), S.substr(0, 1) === "-" && 0 < (Z = S.indexOf("-", 1) + 1) && (F = S.substr(0, Z), S = S.substr(Z)), pt.push({ prefix: F, method: S.toLowerCase(), value: it, args: ii, image: null })), ii = [], S = F = E = it = "";
    };
    return ii = [], S = F = E = it = "", w.split("").forEach(function(vi) {
      if (!(Mt === 0 && -1 < ` \r
	`.indexOf(vi))) {
        switch (vi) {
          case '"':
            me ? me === vi && (me = null) : me = vi;
            break;
          case "(":
            if (!me) {
              if (Mt === 0) {
                Mt = 1, it += vi;
                return;
              }
              zt++;
            }
            break;
          case ")":
            if (!me && Mt === 1) {
              if (zt === 0) {
                Mt = 0, it += vi, Ki();
                return;
              }
              zt--;
            }
            break;
          case ",":
            if (!me) {
              if (Mt === 0) {
                Ki();
                return;
              }
              if (Mt === 1 && zt === 0 && !S.match(/^url$/i)) {
                ii.push(E), E = "", it += vi;
                return;
              }
            }
        }
        it += vi, Mt === 0 ? S += vi : E += vi;
      }
    }), Ki(), pt;
  }
  function At(w) {
    return w.replace("px", "");
  }
  function at(w) {
    return parseFloat(w);
  }
  function ot(w) {
    if (w.getBoundingClientRect) {
      var S = w.getBoundingClientRect(), E = w.offsetWidth == null ? S.width : w.offsetWidth;
      return {
        top: S.top,
        bottom: S.bottom || S.top + S.height,
        right: S.left + E,
        left: S.left,
        width: E,
        height: w.offsetHeight == null ? S.height : w.offsetHeight
      };
    }
    return {};
  }
  function Ut(w) {
    var S = w.offsetParent ? Ut(w.offsetParent) : { top: 0, left: 0 };
    return {
      top: w.offsetTop + S.top,
      bottom: w.offsetTop + w.offsetHeight + S.top,
      right: w.offsetLeft + S.left + w.offsetWidth,
      left: w.offsetLeft + S.left,
      width: w.offsetWidth,
      height: w.offsetHeight
    };
  }
  function Pt(w, S, E, F, Z) {
    if (R("Starting NodeParser"), this.renderer = S, this.options = Z, this.range = null, this.support = E, this.renderQueue = [], this.stack = new Vn(!0, 1, w.ownerDocument, null), E = new wt(w, null), Z.background && S.rectangle(0, 0, S.width, S.height, new j(Z.background)), w === w.ownerDocument.documentElement) {
      var it = new wt(
        E.color("backgroundColor").isTransparent() ? w.ownerDocument.body : w.ownerDocument.documentElement,
        null
      );
      S.rectangle(0, 0, S.width, S.height, it.color("backgroundColor"));
    }
    E.visibile = E.isElementVisible(), this.createPseudoHideStyles(w.ownerDocument), this.disableAnimations(w.ownerDocument), this.nodes = [].concat.apply(
      [],
      [E].concat(this.getChildren(E)).filter(function(pt) {
        return pt.visible = pt.isElementVisible();
      }).map(this.getPseudoElements, this)
    ), this.fontMetrics = new q(), R("Fetched nodes, total:", this.nodes.length), R("Calculate overflow clips"), this.calculateOverflowClips(), R("Start fetching images"), this.images = F.fetch(this.nodes.filter(xt)), this.ready = this.images.ready.then(
      Ht(function() {
        return R("Images loaded, starting parsing"), R("Creating stacking contexts"), this.createStackingContexts(), R("Sorting stacking contexts"), this.sortStackingContexts(this.stack), this.parse(this.stack), R("Render queue created with " + this.renderQueue.length + " items"), new Promise(
          Ht(function(pt) {
            Z.async ? typeof Z.async == "function" ? Z.async.call(this, this.renderQueue, pt) : 0 < this.renderQueue.length ? (this.renderIndex = 0, this.asyncRenderer(this.renderQueue, pt)) : pt() : (this.renderQueue.forEach(this.paint, this), pt());
          }, this)
        );
      }, this)
    );
  }
  function Lt(w) {
    return w.replace(/(\-[a-z])/g, function(S) {
      return S.toUpperCase().replace("-", "");
    });
  }
  function Je() {
  }
  function Bi(w, S, E, F) {
    return w.map(function(Z, it) {
      if (0 < Z.width) {
        var pt = S.left, Mt = S.top, zt = S.width, me = S.height - w[2].width;
        switch (it) {
          case 0:
            me = w[0].width, Z.args = Be(
              {
                c1: [pt, Mt],
                c2: [pt + zt, Mt],
                c3: [pt + zt - w[1].width, Mt + me],
                c4: [pt + w[3].width, Mt + me]
              },
              F[0],
              F[1],
              E.topLeftOuter,
              E.topLeftInner,
              E.topRightOuter,
              E.topRightInner
            );
            break;
          case 1:
            pt = S.left + S.width - w[1].width, zt = w[1].width, Z.args = Be(
              {
                c1: [pt + zt, Mt],
                c2: [pt + zt, Mt + me + w[2].width],
                c3: [pt, Mt + me],
                c4: [pt, Mt + w[0].width]
              },
              F[1],
              F[2],
              E.topRightOuter,
              E.topRightInner,
              E.bottomRightOuter,
              E.bottomRightInner
            );
            break;
          case 2:
            Mt = Mt + S.height - w[2].width, me = w[2].width, Z.args = Be(
              {
                c1: [pt + zt, Mt + me],
                c2: [pt, Mt + me],
                c3: [pt + w[3].width, Mt],
                c4: [pt + zt - w[3].width, Mt]
              },
              F[2],
              F[3],
              E.bottomRightOuter,
              E.bottomRightInner,
              E.bottomLeftOuter,
              E.bottomLeftInner
            );
            break;
          case 3:
            zt = w[3].width, Z.args = Be(
              {
                c1: [pt, Mt + me + w[2].width],
                c2: [pt, Mt],
                c3: [pt + zt, Mt + w[0].width],
                c4: [pt + zt, Mt + me]
              },
              F[3],
              F[0],
              E.bottomLeftOuter,
              E.bottomLeftInner,
              E.topLeftOuter,
              E.topLeftInner
            );
        }
      }
      return Z;
    });
  }
  function re(w, S, E, F) {
    var it = (Math.sqrt(2) - 1) / 3 * 4, Z = E * it, it = F * it;
    return E = w + E, F = S + F, {
      topLeft: He({ x: w, y: F }, { x: w, y: F - it }, { x: E - Z, y: S }, { x: E, y: S }),
      topRight: He({ x: w, y: S }, { x: w + Z, y: S }, { x: E, y: F - it }, { x: E, y: F }),
      bottomRight: He({ x: E, y: S }, { x: E, y: S + it }, { x: w + Z, y: F }, { x: w, y: F }),
      bottomLeft: He({ x: E, y: F }, { x: E - Z, y: F }, { x: w, y: S + it }, { x: w, y: S })
    };
  }
  function xe(w, S, E) {
    var F = w.left, Z = w.top, it = w.width;
    w = w.height;
    var pt = S[0][0], Mt = S[0][1], zt = S[1][0], me = S[1][1], ii = S[2][0], Ki = S[2][1], vi = S[3][0];
    S = S[3][1];
    var Ni = it - zt, ji = w - Ki, cs = it - ii, wn = w - S;
    return {
      topLeftOuter: re(F, Z, pt, Mt).topLeft.subdivide(0.5),
      topLeftInner: re(
        F + E[3].width,
        Z + E[0].width,
        Math.max(0, pt - E[3].width),
        Math.max(0, Mt - E[0].width)
      ).topLeft.subdivide(0.5),
      topRightOuter: re(F + Ni, Z, zt, me).topRight.subdivide(0.5),
      topRightInner: re(
        F + Math.min(Ni, it + E[3].width),
        Z + E[0].width,
        Ni > it + E[3].width ? 0 : zt - E[3].width,
        me - E[0].width
      ).topRight.subdivide(0.5),
      bottomRightOuter: re(F + cs, Z + ji, ii, Ki).bottomRight.subdivide(0.5),
      bottomRightInner: re(
        F + Math.min(cs, it - E[3].width),
        Z + Math.min(ji, w + E[0].width),
        Math.max(0, ii - E[1].width),
        Ki - E[2].width
      ).bottomRight.subdivide(0.5),
      bottomLeftOuter: re(F, Z + wn, vi, S).bottomLeft.subdivide(0.5),
      bottomLeftInner: re(
        F + E[3].width,
        Z + wn,
        Math.max(0, vi - E[3].width),
        S - E[2].width
      ).bottomLeft.subdivide(0.5)
    };
  }
  function He(w, S, E, F) {
    var Z = function(it, pt, Mt) {
      return { x: it.x + (pt.x - it.x) * Mt, y: it.y + (pt.y - it.y) * Mt };
    };
    return {
      start: w,
      startControl: S,
      endControl: E,
      end: F,
      subdivide: function(it) {
        var pt = Z(w, S, it), me = Z(S, E, it), Mt = Z(E, F, it), zt = Z(pt, me, it), me = Z(me, Mt, it);
        return it = Z(zt, me, it), [He(w, pt, zt, it), He(it, me, Mt, F)];
      },
      curveTo: function(it) {
        it.push(["bezierCurve", S.x, S.y, E.x, E.y, F.x, F.y]);
      },
      curveToReversed: function(it) {
        it.push(["bezierCurve", E.x, E.y, S.x, S.y, w.x, w.y]);
      }
    };
  }
  function Be(w, S, E, F, Z, it, pt) {
    var Mt = [];
    return 0 < S[0] || 0 < S[1] ? (Mt.push(["line", F[1].start.x, F[1].start.y]), F[1].curveTo(Mt)) : Mt.push(["line", w.c1[0], w.c1[1]]), 0 < E[0] || 0 < E[1] ? (Mt.push(["line", it[0].start.x, it[0].start.y]), it[0].curveTo(Mt), Mt.push(["line", pt[0].end.x, pt[0].end.y]), pt[0].curveToReversed(Mt)) : (Mt.push(["line", w.c2[0], w.c2[1]]), Mt.push(["line", w.c3[0], w.c3[1]])), 0 < S[0] || 0 < S[1] ? (Mt.push(["line", Z[1].end.x, Z[1].end.y]), Z[1].curveToReversed(Mt)) : Mt.push(["line", w.c4[0], w.c4[1]]), Mt;
  }
  function Ne(w, S, E, F, Z, it, pt) {
    0 < S[0] || 0 < S[1] ? (w.push(["line", F[0].start.x, F[0].start.y]), F[0].curveTo(w), F[1].curveTo(w)) : w.push(["line", it, pt]), (0 < E[0] || 0 < E[1]) && w.push(["line", Z[0].start.x, Z[0].start.y]);
  }
  function cn(w) {
    return 0 > w.cssInt("zIndex");
  }
  function T(w) {
    return 0 < w.cssInt("zIndex");
  }
  function _t(w) {
    return w.cssInt("zIndex") === 0;
  }
  function ft(w) {
    return ["inline", "inline-block", "inline-table"].indexOf(w.css("display")) !== -1;
  }
  function $(w) {
    return 0 < w.node.data.trim().length;
  }
  function W(w) {
    return ["TopLeft", "TopRight", "BottomRight", "BottomLeft"].map(function(S) {
      return S = w.css("border" + S + "Radius").split(" "), 1 >= S.length && (S[1] = S[0]), S.map(Ue);
    });
  }
  function nt(w) {
    return w.nodeType === Node.TEXT_NODE || w.nodeType === Node.ELEMENT_NODE;
  }
  function bt(w) {
    return w.css("position") !== "static";
  }
  function It(w) {
    return w.css("float") !== "none";
  }
  function rt(w) {
    var S = this;
    return function() {
      return !w.apply(S, arguments);
    };
  }
  function xt(w) {
    return w.node.nodeType === Node.ELEMENT_NODE;
  }
  function Rt(w) {
    return w.node.nodeType === Node.TEXT_NODE;
  }
  function Dt(w) {
    return function(S, E) {
      return S.cssInt("zIndex") + w.indexOf(S) / w.length - (E.cssInt("zIndex") + w.indexOf(E) / w.length);
    };
  }
  function Ht(w, S) {
    return function() {
      return w.apply(S, arguments);
    };
  }
  function Ue(w) {
    return parseInt(w, 10);
  }
  function pe(w) {
    return w.width;
  }
  function sn(w) {
    return w.node.nodeType !== Node.ELEMENT_NODE || "SCRIPT HEAD TITLE OBJECT BR OPTION".split(" ").indexOf(w.node.nodeName) === -1;
  }
  function kn(w) {
    for (var S = [], E = 0, F = !1, Z; w.length; )
      [32, 13, 10, 9, 45].indexOf(w[E]) !== -1 === F ? (Z = w.splice(0, E), Z.length && S.push(s.html2canvas.punycode.ucs2.encode(Z)), F = !F, E = 0) : E++, E >= w.length && (Z = w.splice(0, E), Z.length && S.push(s.html2canvas.punycode.ucs2.encode(Z)));
    return S;
  }
  function $i(w, S, E) {
    if (!S)
      return Promise.reject("No proxy configured");
    var F = Vs(Ha);
    return w = zs(S, w, F), Ha ? Hs(w) : ai(E, w, F).then(function(Z) {
      return Ti(Z.content);
    });
  }
  function es(w, S, E) {
    var F = Vs(Hl);
    return w = zs(S, w, F), Hl ? Promise.resolve(w) : ai(E, w, F).then(function(Z) {
      return "data:" + Z.type + ";base64," + Z.content;
    });
  }
  function ai(w, S, E) {
    return new Promise(function(F, Z) {
      var it = w.createElement("script"), pt = function() {
        delete s.html2canvas.proxy[E], w.body.removeChild(it);
      };
      s.html2canvas.proxy[E] = function(Mt) {
        pt(), F(Mt);
      }, it.src = S, it.onerror = function(Mt) {
        pt(), Z(Mt);
      }, w.body.appendChild(it);
    });
  }
  function Vs(w) {
    var S = new Uint32Array(1);
    return (window.crypto || window.msCrypto).getRandomValues(S), w ? "" : "html2canvas_" + Date.now() + "_" + ++Dd + "_" + Math.round(1e5 * (S[0] / 4294967295));
  }
  function zs(w, S, E) {
    return w + "?url=" + encodeURIComponent(S) + (E.length ? "&callback=html2canvas.proxy." + E : "");
  }
  function Fn(w, S) {
    t.createElement("script");
    var E = t.createElement("a");
    E.href = w, this.src = w = E.href, this.image = new Image();
    var F = this;
    this.promise = new Promise(function(Z, it) {
      F.image.crossOrigin = "Anonymous", F.image.onload = Z, F.image.onerror = it, new es(w, S, t).then(function(pt) {
        F.image.src = pt;
      }).catch(it);
    });
  }
  function Qt(w, S, E) {
    wt.call(this, w, S), this.isPseudoElement = !0, this.before = E === ":before";
  }
  function Bn(w, S, E, F, Z) {
    this.width = w, this.height = S, this.images = E, this.options = F, this.document = Z;
  }
  function Vn(w, S, E, F) {
    wt.call(this, E, F), this.ownStacking = w, this.contexts = [], this.children = [], this.opacity = (this.parent ? this.parent.stack.opacity : 1) * S;
  }
  function ls(w) {
    this.rangeBounds = this.testRangeBounds(w), this.cors = this.testCORS(), this.svg = this.testSVG();
  }
  function qi(w) {
    this.src = w, this.image = null;
    var S = this;
    this.promise = this.hasFabric().then(function() {
      return S.isInline(w) ? Promise.resolve(S.inlineFormatting(w)) : Hs(w);
    }).then(function(E) {
      return new Promise(function(F) {
        html2canvas.fabric.loadSVGFromString(E, S.createCanvas.call(S, F));
      });
    });
  }
  function Ti(w) {
    var S = w.length, E, F, Z, it, pt, Mt, zt = "";
    for (E = 0; E < S; E += 4)
      F = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(w[E]), Z = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(w[E + 1]), it = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(w[E + 2]), pt = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".indexOf(w[E + 3]), F = F << 2 | Z >> 4, Z = (Z & 15) << 4 | it >> 2, Mt = (it & 3) << 6 | pt, zt = it === 64 ? zt + String.fromCharCode(F) : pt === 64 || pt === -1 ? zt + String.fromCharCode(F, Z) : zt + String.fromCharCode(F, Z, Mt);
    return zt;
  }
  function $n(w, S) {
    this.src = w, this.image = null;
    var E = this;
    this.promise = S ? new Promise(function(F, Z) {
      E.image = new Image(), E.image.onload = F, E.image.onerror = Z, E.image.src = "data:image/svg+xml," + new XMLSerializer().serializeToString(w), E.image.complete === !0 && F(E.image);
    }) : this.hasFabric().then(function() {
      return new Promise(function(F) {
        html2canvas.fabric.parseSVGDocument(w, E.createCanvas.call(E, F));
      });
    });
  }
  function Kr(w, S) {
    wt.call(this, w, S);
  }
  function Ft(w, S, E) {
    if (0 < w.length)
      return S + E.toUpperCase();
  }
  function za(w) {
    dt.apply(this, arguments), this.type = w.args[0] === "linear" ? this.TYPES.LINEAR : this.TYPES.RADIAL;
  }
  function Hs(w) {
    return new Promise(function(S, E) {
      var F = new XMLHttpRequest();
      F.open("GET", w), F.onload = function() {
        F.status === 200 ? S(F.responseText) : E(Error(F.statusText));
      }, F.onerror = function() {
        E(Error("Network Error"));
      }, F.send();
    });
  }
  function ui(w, S) {
    Bn.apply(this, arguments), this.canvas = this.options.canvas || this.document.createElement("canvas"), this.options.canvas || (this.canvas.width = w, this.canvas.height = S), this.ctx = this.canvas.getContext("2d"), this.taintCtx = this.document.createElement("canvas").getContext("2d"), this.ctx.textBaseline = "bottom", this.variables = {}, R("Initialized CanvasRenderer with size", w, "x", S);
  }
  function Vl(w) {
    return 0 < w.length;
  }
  if ((function() {
    function w(ut, Ot) {
      Di[ce] = ut, Di[ce + 1] = Ot, ce += 2, ce === 2 && Pi();
    }
    function S(ut) {
      return typeof ut == "function";
    }
    function E() {
      return function() {
        process.nextTick(pt);
      };
    }
    function F() {
      var ut = 0, Ot = new Ae(pt), jt = t.createTextNode("");
      return Ot.observe(jt, { characterData: !0 }), function() {
        jt.data = ut = ++ut % 2;
      };
    }
    function Z() {
      var ut = new MessageChannel();
      return ut.port1.onmessage = pt, function() {
        ut.port2.postMessage(0);
      };
    }
    function it() {
      return function() {
        setTimeout(pt, 1);
      };
    }
    function pt() {
      for (var ut = 0; ut < ce; ut += 2)
        (0, Di[ut])(Di[ut + 1]), Di[ut] = void 0, Di[ut + 1] = void 0;
      ce = 0;
    }
    function Mt() {
    }
    function zt(ut, Ot, jt, ue) {
      try {
        ut.call(Ot, jt, ue);
      } catch (Ye) {
        return Ye;
      }
    }
    function me(ut, Ot, jt) {
      w(function(ue) {
        var Ye = !1, li = zt(
          jt,
          Ot,
          function(mi) {
            Ye || (Ye = !0, Ot !== mi ? Ki(ue, mi) : Ni(ue, mi));
          },
          function(mi) {
            Ye || (Ye = !0, ji(ue, mi));
          }
        );
        !Ye && li && (Ye = !0, ji(ue, li));
      }, ut);
    }
    function ii(ut, Ot) {
      Ot.a === 1 ? Ni(ut, Ot.b) : ut.a === 2 ? ji(ut, Ot.b) : cs(
        Ot,
        void 0,
        function(jt) {
          Ki(ut, jt);
        },
        function(jt) {
          ji(ut, jt);
        }
      );
    }
    function Ki(ut, Ot) {
      if (ut === Ot)
        ji(ut, new TypeError("You cannot resolve a promise with itself"));
      else if (typeof Ot == "function" || typeof Ot == "object" && Ot !== null)
        if (Ot.constructor === ut.constructor)
          ii(ut, Ot);
        else {
          var jt;
          try {
            jt = Ot.then;
          } catch (ue) {
            $e.error = ue, jt = $e;
          }
          jt === $e ? ji(ut, $e.error) : jt === void 0 ? Ni(ut, Ot) : S(jt) ? me(ut, Ot, jt) : Ni(ut, Ot);
        }
      else
        Ni(ut, Ot);
    }
    function vi(ut) {
      ut.f && ut.f(ut.b), wn(ut);
    }
    function Ni(ut, Ot) {
      ut.a === void 0 && (ut.b = Ot, ut.a = 1, ut.e.length !== 0 && w(wn, ut));
    }
    function ji(ut, Ot) {
      ut.a === void 0 && (ut.a = 2, ut.b = Ot, w(vi, ut));
    }
    function cs(ut, Ot, jt, ue) {
      var Ye = ut.e, li = Ye.length;
      ut.f = null, Ye[li] = Ot, Ye[li + 1] = jt, Ye[li + 2] = ue, li === 0 && ut.a && w(wn, ut);
    }
    function wn(ut) {
      var Ot = ut.e, jt = ut.a;
      if (Ot.length !== 0) {
        for (var ue, Ye, li = ut.b, mi = 0; mi < Ot.length; mi += 3)
          ue = Ot[mi], Ye = Ot[mi + jt], ue ? qn(jt, ue, Ye, li) : Ye(li);
        ut.e.length = 0;
      }
    }
    function _o() {
      this.error = null;
    }
    function qn(ut, Ot, jt, ue) {
      var Ye = S(jt), li, mi, Us, Yo;
      if (Ye) {
        try {
          li = jt(ue);
        } catch (Gh) {
          pi.error = Gh, li = pi;
        }
        if (li === pi ? (Yo = !0, mi = li.error, li = null) : Us = !0, Ot === li) {
          ji(Ot, new TypeError("A promises callback cannot return that same promise."));
          return;
        }
      } else
        li = ue, Us = !0;
      Ot.a === void 0 && (Ye && Us ? Ki(Ot, li) : Yo ? ji(Ot, mi) : ut === 1 ? Ni(Ot, li) : ut === 2 && ji(Ot, li));
    }
    function br(ut, Ot) {
      try {
        Ot(
          function(jt) {
            Ki(ut, jt);
          },
          function(jt) {
            ji(ut, jt);
          }
        );
      } catch (jt) {
        ji(ut, jt);
      }
    }
    function Xi(ut, Ot, jt, ue) {
      this.n = ut, this.c = new ut(Mt, ue), this.i = jt, this.o(Ot) ? (this.m = Ot, this.d = this.length = Ot.length, this.l(), this.length === 0 ? Ni(this.c, this.b) : (this.length = this.length || 0, this.k(), this.d === 0 && Ni(this.c, this.b))) : ji(this.c, this.p());
    }
    function te(ut) {
      if (this.b = this.a = void 0, this.e = [], Mt !== ut) {
        if (!S(ut))
          throw new TypeError(
            "You must pass a resolver function as the first argument to the promise constructor"
          );
        if (!(this instanceof te))
          throw new TypeError(
            "Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function."
          );
        br(this, ut);
      }
    }
    var le = Array.isArray ? Array.isArray : function(ut) {
      return Object.prototype.toString.call(ut) === "[object Array]";
    }, ce = 0, ni = typeof s < "u" ? s : {}, Ae = ni.MutationObserver || ni.WebKitMutationObserver, ni = typeof Uint8ClampedArray < "u" && typeof importScripts < "u" && typeof MessageChannel < "u", Di = Array(1e3), Pi;
    Pi = typeof process < "u" && {}.toString.call(process) === "[object process]" ? E() : Ae ? F() : ni ? Z() : it();
    var $e = new _o(), pi = new _o();
    Xi.prototype.o = function(ut) {
      return le(ut);
    }, Xi.prototype.p = function() {
      return Error("Array Methods must be provided an Array");
    }, Xi.prototype.l = function() {
      this.b = Array(this.length);
    }, Xi.prototype.k = function() {
      for (var ut = this.length, Ot = this.c, jt = this.m, ue = 0; Ot.a === void 0 && ue < ut; ue++)
        this.j(jt[ue], ue);
    }, Xi.prototype.j = function(ut, Ot) {
      var jt = this.n;
      typeof ut == "object" && ut !== null ? ut.constructor === jt && ut.a !== void 0 ? (ut.f = null, this.g(ut.a, Ot, ut.b)) : this.q(jt.resolve(ut), Ot) : (this.d--, this.b[Ot] = this.h(ut));
    }, Xi.prototype.g = function(ut, Ot, jt) {
      var ue = this.c;
      ue.a === void 0 && (this.d--, this.i && ut === 2 ? ji(ue, jt) : this.b[Ot] = this.h(jt)), this.d === 0 && Ni(ue, this.b);
    }, Xi.prototype.h = function(ut) {
      return ut;
    }, Xi.prototype.q = function(ut, Ot) {
      var jt = this;
      cs(
        ut,
        void 0,
        function(ue) {
          jt.g(1, Ot, ue);
        },
        function(ue) {
          jt.g(2, Ot, ue);
        }
      );
    }, te.all = function(ut, Ot) {
      return new Xi(this, ut, !0, Ot).c;
    }, te.race = function(ut, Ot) {
      function jt(Us) {
        Ki(Ye, Us);
      }
      function ue(Us) {
        ji(Ye, Us);
      }
      var Ye = new this(Mt, Ot);
      if (!le(ut))
        return ji(Ye, new TypeError("You must pass an array to race.")), Ye;
      for (var li = ut.length, mi = 0; Ye.a === void 0 && mi < li; mi++)
        cs(this.resolve(ut[mi]), void 0, jt, ue);
      return Ye;
    }, te.resolve = function(ut, Ot) {
      if (ut && typeof ut == "object" && ut.constructor === this)
        return ut;
      var jt = new this(Mt, Ot);
      return Ki(jt, ut), jt;
    }, te.reject = function(ut, Ot) {
      var jt = new this(Mt, Ot);
      return ji(jt, ut), jt;
    }, te.prototype = {
      constructor: te,
      then: function(ut, Ot) {
        var jt = this.a;
        if (jt === 1 && !ut || jt === 2 && !Ot)
          return this;
        var ue = new this.constructor(Mt), Ye = this.b;
        if (jt) {
          var li = arguments[jt - 1];
          w(function() {
            qn(jt, ue, li, Ye);
          });
        } else
          cs(this, ue, ut, Ot);
        return ue;
      },
      catch: function(ut) {
        return this.then(null, ut);
      }
    };
    var Ke = {
      Promise: te,
      polyfill: function() {
        var ut;
        ut = typeof i < "u" ? i : typeof s < "u" && s.document ? s : self, "Promise" in ut && "resolve" in ut.Promise && "reject" in ut.Promise && "all" in ut.Promise && "race" in ut.Promise && function() {
          var Ot;
          return new ut.Promise(function(jt) {
            Ot = jt;
          }), S(Ot);
        }() || (ut.Promise = te);
      }
    };
    typeof n == "function" && n.amd ? n(function() {
      return Ke;
    }) : typeof module < "u" && module.exports ? module.exports = Ke : typeof this < "u" && (this.ES6Promise = Ke);
  }).call(s), s && s.ES6Promise && s.ES6Promise.polyfill(), typeof t > "u" || typeof Object.create != "function" || typeof t.createElement("canvas").getContext != "function")
    (s || module.exports).html2canvas = function() {
      return Promise.reject("No canvas support");
    };
  else {
    (function(w) {
      function S(te) {
        throw RangeError(_o[te]);
      }
      function E(te, le) {
        for (var ce = te.length, Ae = []; ce--; )
          Ae[ce] = le(te[ce]);
        return Ae;
      }
      function F(te, le) {
        var ce = te.split("@"), Ae = "";
        return 1 < ce.length && (Ae = ce[0] + "@", te = ce[1]), ce = te.split(wn), ce = E(ce, le).join("."), Ae + ce;
      }
      function Z(te) {
        for (var le = [], ce = 0, Ae = te.length, ni, Di; ce < Ae; )
          ni = te.charCodeAt(ce++), 55296 <= ni && 56319 >= ni && ce < Ae ? (Di = te.charCodeAt(ce++), (Di & 64512) == 56320 ? le.push(((ni & 1023) << 10) + (Di & 1023) + 65536) : (le.push(ni), ce--)) : le.push(ni);
        return le;
      }
      function it(te) {
        return E(te, function(le) {
          var ce = "";
          return 65535 < le && (le -= 65536, ce += br(le >>> 10 & 1023 | 55296), le = 56320 | le & 1023), ce += br(le);
        }).join("");
      }
      function pt(te, le) {
        return te + 22 + 75 * (26 > te) - ((le != 0) << 5);
      }
      function Mt(te, le, ce) {
        var Ae = 0;
        for (te = ce ? qn(te / 700) : te >> 1, te += qn(te / le); 455 < te; Ae += 36)
          te = qn(te / 35);
        return qn(Ae + 36 * te / (te + 38));
      }
      function zt(te) {
        var le = [], ce = te.length, Ae, ni = 0, Di = 128, Pi = 72, $e, pi, Ke, ut, Ot;
        for ($e = te.lastIndexOf("-"), 0 > $e && ($e = 0), pi = 0; pi < $e; ++pi)
          128 <= te.charCodeAt(pi) && S("not-basic"), le.push(te.charCodeAt(pi));
        for ($e = 0 < $e ? $e + 1 : 0; $e < ce; ) {
          for (pi = ni, Ae = 1, Ke = 36; $e >= ce && S("invalid-input"), ut = te.charCodeAt($e++), ut = 10 > ut - 48 ? ut - 22 : 26 > ut - 65 ? ut - 65 : 26 > ut - 97 ? ut - 97 : 36, (36 <= ut || ut > qn((2147483647 - ni) / Ae)) && S("overflow"), ni += ut * Ae, Ot = Ke <= Pi ? 1 : Ke >= Pi + 26 ? 26 : Ke - Pi, !(ut < Ot); Ke += 36)
            ut = 36 - Ot, Ae > qn(2147483647 / ut) && S("overflow"), Ae *= ut;
          Ae = le.length + 1, Pi = Mt(ni - pi, Ae, pi == 0), qn(ni / Ae) > 2147483647 - Di && S("overflow"), Di += qn(ni / Ae), ni %= Ae, le.splice(ni++, 0, Di);
        }
        return it(le);
      }
      function me(te) {
        var le, ce, Ae, ni, Di, Pi, $e, pi, Ke, ut = [], Ot, jt, ue;
        for (te = Z(te), Ot = te.length, le = 128, ce = 0, Di = 72, Pi = 0; Pi < Ot; ++Pi)
          Ke = te[Pi], 128 > Ke && ut.push(br(Ke));
        for ((Ae = ni = ut.length) && ut.push("-"); Ae < Ot; ) {
          for ($e = 2147483647, Pi = 0; Pi < Ot; ++Pi)
            Ke = te[Pi], Ke >= le && Ke < $e && ($e = Ke);
          for (jt = Ae + 1, $e - le > qn((2147483647 - ce) / jt) && S("overflow"), ce += ($e - le) * jt, le = $e, Pi = 0; Pi < Ot; ++Pi)
            if (Ke = te[Pi], Ke < le && 2147483647 < ++ce && S("overflow"), Ke == le) {
              for (pi = ce, $e = 36; Ke = $e <= Di ? 1 : $e >= Di + 26 ? 26 : $e - Di, !(pi < Ke); $e += 36)
                ue = pi - Ke, pi = 36 - Ke, ut.push(br(pt(Ke + ue % pi, 0))), pi = qn(ue / pi);
              ut.push(br(pt(pi, 0))), Di = Mt(ce, jt, Ae == ni), ce = 0, ++Ae;
            }
          ++ce, ++le;
        }
        return ut.join("");
      }
      var ii = typeof e == "object" && e && !e.nodeType && e, Ki = typeof module == "object" && module && !module.nodeType && module, vi = typeof i == "object" && i;
      (vi.global === vi || vi.window === vi || vi.self === vi) && (w = vi);
      var Ni, ji = /^xn--/, cs = /[^\x20-\x7E]/, wn = /[\x2E\u3002\uFF0E\uFF61]/g, _o = {
        overflow: "Overflow: input needs wider integers to process",
        "not-basic": "Illegal input >= 0x80 (not a basic code point)",
        "invalid-input": "Invalid input"
      }, qn = Math.floor, br = String.fromCharCode, Xi;
      if (Ni = {
        version: "1.3.1",
        ucs2: { decode: Z, encode: it },
        decode: zt,
        encode: me,
        toASCII: function(te) {
          return F(te, function(le) {
            return cs.test(le) ? "xn--" + me(le) : le;
          });
        },
        toUnicode: function(te) {
          return F(te, function(le) {
            return ji.test(le) ? zt(le.slice(4).toLowerCase()) : le;
          });
        }
      }, typeof n == "function" && typeof n.amd == "object" && n.amd)
        n("punycode", function() {
          return Ni;
        });
      else if (ii && Ki)
        if (module.exports == ii)
          Ki.exports = Ni;
        else
          for (Xi in Ni)
            Ni.hasOwnProperty(Xi) && (ii[Xi] = Ni[Xi]);
      else
        w.punycode = Ni;
    })(this);
    var mo = 0, Uh = 0;
    s.html2canvas = function(w, S) {
      var E = Uh++;
      if (S = S || {}, S.logging && (s.html2canvas.logging = !0, s.html2canvas.start = Date.now()), S.async = typeof S.async > "u" ? !0 : S.async, S.allowTaint = typeof S.allowTaint > "u" ? !1 : S.allowTaint, S.removeContainer = typeof S.removeContainer > "u" ? !0 : S.removeContainer, S.javascriptEnabled = typeof S.javascriptEnabled > "u" ? !1 : S.javascriptEnabled, S.imageTimeout = typeof S.imageTimeout > "u" ? 1e4 : S.imageTimeout, S.renderer = typeof S.renderer == "function" ? S.renderer : ui, S.strict = !!S.strict, typeof w == "string") {
        if (typeof S.proxy != "string")
          return Promise.reject("Proxy must be used when rendering url");
        var F = S.width != null ? S.width : s.innerWidth, Z = S.height != null ? S.height : s.innerHeight;
        return b(B(w), S.proxy, t, F, Z, S).then(function(pt) {
          return l(pt.contentWindow.document.documentElement, pt, S, F, Z);
        });
      }
      var it = (w === r ? [t.documentElement] : w.length ? w : [w])[0];
      return it.setAttribute("data-html2canvas-node" + E, E), o(
        it.ownerDocument,
        S,
        it.ownerDocument.defaultView.innerWidth,
        it.ownerDocument.defaultView.innerHeight,
        E
      ).then(function(pt) {
        return typeof S.onrendered == "function" && (R(
          "options.onrendered is deprecated, html2canvas returns a Promise containing the canvas"
        ), S.onrendered(pt)), pt;
      });
    }, s.html2canvas.punycode = this.punycode, s.html2canvas.proxy = {}, j.prototype.darken = function(w) {
      return w = 1 - w, new j([
        Math.round(this.r * w),
        Math.round(this.g * w),
        Math.round(this.b * w),
        this.a
      ]);
    }, j.prototype.isTransparent = function() {
      return this.a === 0;
    }, j.prototype.isBlack = function() {
      return this.r === 0 && this.g === 0 && this.b === 0;
    }, j.prototype.fromArray = function(w) {
      return Array.isArray(w) && (this.r = Math.min(w[0], 255), this.g = Math.min(w[1], 255), this.b = Math.min(w[2], 255), 3 < w.length && (this.a = w[3])), Array.isArray(w);
    };
    var Td = /^#([a-f0-9]{3})$/i;
    j.prototype.hex3 = function(w) {
      return (w = w.match(Td)) !== null && (this.r = parseInt(w[1][0] + w[1][0], 16), this.g = parseInt(w[1][1] + w[1][1], 16), this.b = parseInt(w[1][2] + w[1][2], 16)), w !== null;
    };
    var jh = /^#([a-f0-9]{6})$/i;
    j.prototype.hex6 = function(w) {
      return (w = w.match(jh)) !== null && (this.r = parseInt(w[1].substring(0, 2), 16), this.g = parseInt(w[1].substring(2, 4), 16), this.b = parseInt(w[1].substring(4, 6), 16)), w !== null;
    };
    var Jo = /^rgb\((\d{1,3}) *, *(\d{1,3}) *, *(\d{1,3})\)$/;
    j.prototype.rgb = function(w) {
      return (w = w.match(Jo)) !== null && (this.r = Number(w[1]), this.g = Number(w[2]), this.b = Number(w[3])), w !== null;
    };
    var Wh = /^rgba\((\d{1,3}) *, *(\d{1,3}) *, *(\d{1,3}) *, *(\d+\.?\d*)\)$/;
    j.prototype.rgba = function(w) {
      return (w = w.match(Wh)) !== null && (this.r = Number(w[1]), this.g = Number(w[2]), this.b = Number(w[3]), this.a = Number(w[4])), w !== null;
    }, j.prototype.toString = function() {
      return this.a !== null && this.a !== 1 ? "rgba(" + [this.r, this.g, this.b, this.a].join() + ")" : "rgb(" + [this.r, this.g, this.b].join() + ")";
    }, j.prototype.namedColor = function(w) {
      var S = Nd[w.toLowerCase()];
      if (S)
        this.r = S[0], this.g = S[1], this.b = S[2];
      else if (w.toLowerCase() === "transparent")
        return this.r = this.g = this.b = this.a = 0, !0;
      return !!S;
    }, j.prototype.isColor = !0;
    var Nd = {
      aliceblue: [240, 248, 255],
      antiquewhite: [250, 235, 215],
      aqua: [0, 255, 255],
      aquamarine: [127, 255, 212],
      azure: [240, 255, 255],
      beige: [245, 245, 220],
      bisque: [255, 228, 196],
      black: [0, 0, 0],
      blanchedalmond: [255, 235, 205],
      blue: [0, 0, 255],
      blueviolet: [138, 43, 226],
      brown: [165, 42, 42],
      burlywood: [222, 184, 135],
      cadetblue: [95, 158, 160],
      chartreuse: [127, 255, 0],
      chocolate: [210, 105, 30],
      coral: [255, 127, 80],
      cornflowerblue: [100, 149, 237],
      cornsilk: [255, 248, 220],
      crimson: [220, 20, 60],
      cyan: [0, 255, 255],
      darkblue: [0, 0, 139],
      darkcyan: [0, 139, 139],
      darkgoldenrod: [184, 134, 11],
      darkgray: [169, 169, 169],
      darkgreen: [0, 100, 0],
      darkgrey: [169, 169, 169],
      darkkhaki: [189, 183, 107],
      darkmagenta: [139, 0, 139],
      darkolivegreen: [85, 107, 47],
      darkorange: [255, 140, 0],
      darkorchid: [153, 50, 204],
      darkred: [139, 0, 0],
      darksalmon: [233, 150, 122],
      darkseagreen: [143, 188, 143],
      darkslateblue: [72, 61, 139],
      darkslategray: [47, 79, 79],
      darkslategrey: [47, 79, 79],
      darkturquoise: [0, 206, 209],
      darkviolet: [148, 0, 211],
      deeppink: [255, 20, 147],
      deepskyblue: [0, 191, 255],
      dimgray: [105, 105, 105],
      dimgrey: [105, 105, 105],
      dodgerblue: [30, 144, 255],
      firebrick: [178, 34, 34],
      floralwhite: [255, 250, 240],
      forestgreen: [34, 139, 34],
      fuchsia: [255, 0, 255],
      gainsboro: [220, 220, 220],
      ghostwhite: [248, 248, 255],
      gold: [255, 215, 0],
      goldenrod: [218, 165, 32],
      gray: [128, 128, 128],
      green: [0, 128, 0],
      greenyellow: [173, 255, 47],
      grey: [128, 128, 128],
      honeydew: [240, 255, 240],
      hotpink: [255, 105, 180],
      indianred: [205, 92, 92],
      indigo: [75, 0, 130],
      ivory: [255, 255, 240],
      khaki: [240, 230, 140],
      lavender: [230, 230, 250],
      lavenderblush: [255, 240, 245],
      lawngreen: [124, 252, 0],
      lemonchiffon: [255, 250, 205],
      lightblue: [173, 216, 230],
      lightcoral: [240, 128, 128],
      lightcyan: [224, 255, 255],
      lightgoldenrodyellow: [250, 250, 210],
      lightgray: [211, 211, 211],
      lightgreen: [144, 238, 144],
      lightgrey: [211, 211, 211],
      lightpink: [255, 182, 193],
      lightsalmon: [255, 160, 122],
      lightseagreen: [32, 178, 170],
      lightskyblue: [135, 206, 250],
      lightslategray: [119, 136, 153],
      lightslategrey: [119, 136, 153],
      lightsteelblue: [176, 196, 222],
      lightyellow: [255, 255, 224],
      lime: [0, 255, 0],
      limegreen: [50, 205, 50],
      linen: [250, 240, 230],
      magenta: [255, 0, 255],
      maroon: [128, 0, 0],
      mediumaquamarine: [102, 205, 170],
      mediumblue: [0, 0, 205],
      mediumorchid: [186, 85, 211],
      mediumpurple: [147, 112, 219],
      mediumseagreen: [60, 179, 113],
      mediumslateblue: [123, 104, 238],
      mediumspringgreen: [0, 250, 154],
      mediumturquoise: [72, 209, 204],
      mediumvioletred: [199, 21, 133],
      midnightblue: [25, 25, 112],
      mintcream: [245, 255, 250],
      mistyrose: [255, 228, 225],
      moccasin: [255, 228, 181],
      navajowhite: [255, 222, 173],
      navy: [0, 0, 128],
      oldlace: [253, 245, 230],
      olive: [128, 128, 0],
      olivedrab: [107, 142, 35],
      orange: [255, 165, 0],
      orangered: [255, 69, 0],
      orchid: [218, 112, 214],
      palegoldenrod: [238, 232, 170],
      palegreen: [152, 251, 152],
      paleturquoise: [175, 238, 238],
      palevioletred: [219, 112, 147],
      papayawhip: [255, 239, 213],
      peachpuff: [255, 218, 185],
      peru: [205, 133, 63],
      pink: [255, 192, 203],
      plum: [221, 160, 221],
      powderblue: [176, 224, 230],
      purple: [128, 0, 128],
      rebeccapurple: [102, 51, 153],
      red: [255, 0, 0],
      rosybrown: [188, 143, 143],
      royalblue: [65, 105, 225],
      saddlebrown: [139, 69, 19],
      salmon: [250, 128, 114],
      sandybrown: [244, 164, 96],
      seagreen: [46, 139, 87],
      seashell: [255, 245, 238],
      sienna: [160, 82, 45],
      silver: [192, 192, 192],
      skyblue: [135, 206, 235],
      slateblue: [106, 90, 205],
      slategray: [112, 128, 144],
      slategrey: [112, 128, 144],
      snow: [255, 250, 250],
      springgreen: [0, 255, 127],
      steelblue: [70, 130, 180],
      tan: [210, 180, 140],
      teal: [0, 128, 128],
      thistle: [216, 191, 216],
      tomato: [255, 99, 71],
      turquoise: [64, 224, 208],
      violet: [238, 130, 238],
      wheat: [245, 222, 179],
      white: [255, 255, 255],
      whitesmoke: [245, 245, 245],
      yellow: [255, 255, 0],
      yellowgreen: [154, 205, 50]
    };
    q.prototype.getMetrics = function(w, S) {
      return this.data[w + "-" + S] === r && (this.data[w + "-" + S] = new Y(w, S)), this.data[w + "-" + S];
    }, st.prototype.proxyLoad = function(w, S, E) {
      var F = this.src;
      return b(F.src, w, F.ownerDocument, S.width, S.height, E);
    }, dt.prototype.TYPES = { LINEAR: 1, RADIAL: 2 }, J.prototype.findImages = function(w) {
      var S = [];
      return w.reduce(function(E, F) {
        switch (F.node.nodeName) {
          case "IMG":
            return E.concat([{ args: [F.node.src], method: "url" }]);
          case "svg":
          case "IFRAME":
            return E.concat([{ args: [F.node], method: F.node.nodeName }]);
        }
        return E;
      }, []).forEach(this.addImage(S, this.loadImage), this), S;
    }, J.prototype.findBackgroundImage = function(w, S) {
      return S.parseBackgroundImages().filter(this.hasImageBackground).forEach(this.addImage(w, this.loadImage), this), w;
    }, J.prototype.addImage = function(w, S) {
      return function(E) {
        E.args.forEach(function(F) {
          this.imageExists(w, F) || (w.splice(0, 0, S.call(this, E)), R("Added image #" + w.length, typeof F == "string" ? F.substring(0, 100) : F));
        }, this);
      };
    }, J.prototype.hasImageBackground = function(w) {
      return w.method !== "none";
    }, J.prototype.loadImage = function(w) {
      return w.method === "url" ? (w = w.args[0], !this.isSVG(w) || this.support.svg || this.options.allowTaint ? w.match(/data:image\/.*;base64,/i) ? new U(w.replace(/url\(['"]{0,}|['"]{0,}\)$/gi, ""), !1) : this.isSameOrigin(w) || this.options.allowTaint === !0 || this.isSVG(w) ? new U(w, !1) : this.support.cors && !this.options.allowTaint && this.options.useCORS ? new U(w, !0) : this.options.proxy ? new Fn(w, this.options.proxy) : new V(w) : new qi(w)) : w.method === "linear-gradient" ? new A(w) : w.method === "gradient" ? new za(w) : w.method === "svg" ? new $n(w.args[0], this.support.svg) : w.method === "IFRAME" ? new st(w.args[0], this.isSameOrigin(w.args[0].src), this.options) : new V(w);
    }, J.prototype.isSVG = function(w) {
      return w.substring(w.length - 3).toLowerCase() === "svg" || qi.prototype.isInline(w);
    }, J.prototype.imageExists = function(w, S) {
      return w.some(function(E) {
        return E.src === S;
      });
    }, J.prototype.isSameOrigin = function(w) {
      return this.getOrigin(w) === this.origin;
    }, J.prototype.getOrigin = function(w) {
      var S = this.link || (this.link = t.createElement("a"));
      return S.href = w, S.href = S.href, S.protocol + S.hostname + S.port;
    }, J.prototype.getPromise = function(w) {
      return this.timeout(w, this.options.imageTimeout).catch(function() {
        return new V(w.src).promise.then(function(S) {
          w.image = S;
        });
      });
    }, J.prototype.get = function(w) {
      var S = null;
      return this.images.some(function(E) {
        return (S = E).src === w;
      }) ? S : null;
    }, J.prototype.fetch = function(w) {
      return this.images = w.reduce(Ht(this.findBackgroundImage, this), this.findImages(w)), this.images.forEach(function(S, E) {
        S.promise.then(
          function() {
            R("Succesfully loaded image #" + (E + 1), S);
          },
          function(F) {
            R("Failed loading image #" + (E + 1), S, F);
          }
        );
      }), this.ready = Promise.all(this.images.map(this.getPromise, this)), R("Finished searching images"), this;
    }, J.prototype.timeout = function(w, S) {
      var E, F = Promise.race([
        w.promise,
        new Promise(function(Z, it) {
          E = setTimeout(function() {
            R("Timed out loading image", w), it(w);
          }, S);
        })
      ]).then(function(Z) {
        return clearTimeout(E), Z;
      });
      return F.catch(function() {
        clearTimeout(E);
      }), F;
    }, A.prototype = Object.create(dt.prototype), A.prototype.stepRegExp = /((?:rgb|rgba)\(\d{1,3},\s\d{1,3},\s\d{1,3}(?:,\s[0-9\.]+)?\))\s*(\d{1,3})?(%|px)?/, wt.prototype.cloneTo = function(w) {
      w.visible = this.visible, w.borders = this.borders, w.bounds = this.bounds, w.clip = this.clip, w.backgroundClip = this.backgroundClip, w.computedStyles = this.computedStyles, w.styles = this.styles, w.backgroundImages = this.backgroundImages, w.opacity = this.opacity;
    }, wt.prototype.getOpacity = function() {
      return this.opacity === null ? this.opacity = this.cssFloat("opacity") : this.opacity;
    }, wt.prototype.assignStack = function(w) {
      this.stack = w, w.children.push(this);
    }, wt.prototype.isElementVisible = function() {
      return this.node.nodeType === Node.TEXT_NODE ? this.parent.visible : this.css("display") !== "none" && this.css("visibility") !== "hidden" && !this.node.hasAttribute("data-html2canvas-ignore") && (this.node.nodeName !== "INPUT" || this.node.getAttribute("type") !== "hidden");
    }, wt.prototype.css = function(w) {
      return this.computedStyles || (this.computedStyles = this.isPseudoElement ? this.parent.computedStyle(this.before ? ":before" : ":after") : this.computedStyle(null)), this.styles[w] || (this.styles[w] = this.computedStyles[w]);
    }, wt.prototype.prefixedCss = function(w) {
      var S = ["webkit", "moz", "ms", "o"], E = this.css(w);
      return E === r && S.some(function(F) {
        return E = this.css(F + w.substr(0, 1).toUpperCase() + w.substr(1)), E !== r;
      }, this), E === r ? null : E;
    }, wt.prototype.computedStyle = function(w) {
      return this.node.ownerDocument.defaultView.getComputedStyle(this.node, w);
    }, wt.prototype.cssInt = function(w) {
      return w = parseInt(this.css(w), 10), isNaN(w) ? 0 : w;
    }, wt.prototype.color = function(w) {
      return this.colors[w] || (this.colors[w] = new j(this.css(w)));
    }, wt.prototype.cssFloat = function(w) {
      return w = parseFloat(this.css(w)), isNaN(w) ? 0 : w;
    }, wt.prototype.fontWeight = function() {
      var w = this.css("fontWeight");
      switch (parseInt(w, 10)) {
        case 401:
          w = "bold";
          break;
        case 400:
          w = "normal";
      }
      return w;
    }, wt.prototype.parseClip = function() {
      var w = this.css("clip").match(this.CLIP);
      return w ? {
        top: parseInt(w[1], 10),
        right: parseInt(w[2], 10),
        bottom: parseInt(w[3], 10),
        left: parseInt(w[4], 10)
      } : null;
    }, wt.prototype.parseBackgroundImages = function() {
      return this.backgroundImages || (this.backgroundImages = X(this.css("backgroundImage")));
    }, wt.prototype.cssList = function(w, S) {
      var E = (this.css(w) || "").split(","), E = E[S || 0] || E[0] || "auto", E = E.trim().split(" ");
      return E.length === 1 && (E = [E[0], E[0]]), E;
    }, wt.prototype.parseBackgroundSize = function(w, S, E) {
      E = this.cssList("backgroundSize", E);
      var F;
      if (St(E[0]))
        F = w.width * parseFloat(E[0]) / 100;
      else {
        if (/contain|cover/.test(E[0]))
          return S = S.width / S.height, w.width / w.height < S ^ E[0] === "contain" ? { width: w.height * S, height: w.height } : { width: w.width, height: w.width / S };
        F = parseInt(E[0], 10);
      }
      return w = E[0] === "auto" && E[1] === "auto" ? S.height : E[1] === "auto" ? F / S.width * S.height : St(E[1]) ? w.height * parseFloat(E[1]) / 100 : parseInt(E[1], 10), E[0] === "auto" && (F = w / S.height * S.width), { width: F, height: w };
    }, wt.prototype.parseBackgroundPosition = function(w, S, E, F) {
      E = this.cssList("backgroundPosition", E);
      var Z;
      return Z = St(E[0]) ? (w.width - (F || S).width) * (parseFloat(E[0]) / 100) : parseInt(E[0], 10), w = E[1] === "auto" ? Z / S.width * S.height : St(E[1]) ? (w.height - (F || S).height) * parseFloat(E[1]) / 100 : parseInt(E[1], 10), E[0] === "auto" && (Z = w / S.height * S.width), { left: Z, top: w };
    }, wt.prototype.parseBackgroundRepeat = function(w) {
      return this.cssList("backgroundRepeat", w)[0];
    }, wt.prototype.parseTextShadows = function() {
      var w = this.css("textShadow"), S = [];
      if (w && w !== "none")
        for (var w = w.match(this.TEXT_SHADOW_PROPERTY), E = 0; w && E < w.length; E++) {
          var F = w[E].match(this.TEXT_SHADOW_VALUES);
          S.push({
            color: new j(F[0]),
            offsetX: F[1] ? parseFloat(F[1].replace("px", "")) : 0,
            offsetY: F[2] ? parseFloat(F[2].replace("px", "")) : 0,
            blur: F[3] ? F[3].replace("px", "") : 0
          });
        }
      return S;
    }, wt.prototype.parseTransform = function() {
      if (!this.transformData)
        if (this.hasTransform()) {
          var w = this.parseBounds(), S = this.prefixedCss("transformOrigin").split(" ").map(At).map(at);
          S[0] += w.left, S[1] += w.top, this.transformData = { origin: S, matrix: this.parseTransformMatrix() };
        } else
          this.transformData = { origin: [0, 0], matrix: [1, 0, 0, 1, 0, 0] };
      return this.transformData;
    }, wt.prototype.parseTransformMatrix = function() {
      if (!this.transformMatrix) {
        var w = this.prefixedCss("transform");
        this.transformMatrix = (w = w ? z(w.match(this.MATRIX_PROPERTY)) : null) ? w : [1, 0, 0, 1, 0, 0];
      }
      return this.transformMatrix;
    }, wt.prototype.parseBounds = function() {
      return this.bounds || (this.bounds = this.hasTransform() ? Ut(this.node) : ot(this.node));
    }, wt.prototype.hasTransform = function() {
      return this.parseTransformMatrix().join(",") !== "1,0,0,1,0,0" || this.parent && this.parent.hasTransform();
    }, wt.prototype.getValue = function() {
      var w = this.node.value || "";
      return this.node.tagName === "SELECT" ? (w = this.node, w = (w = w.options[w.selectedIndex || 0]) && w.text || "") : this.node.type === "password" && (w = Array(w.length + 1).join("•")), w.length === 0 ? this.node.placeholder || "" : w;
    }, wt.prototype.MATRIX_PROPERTY = /(matrix)\((.+)\)/, wt.prototype.TEXT_SHADOW_PROPERTY = /((rgba|rgb)\([^\)]+\)(\s-?\d+px){0,})/g, wt.prototype.TEXT_SHADOW_VALUES = /(-?\d+px)|(#.+)|(rgb\(.+\))|(rgba\(.+\))/g, wt.prototype.CLIP = /^rect\((\d+)px,? (\d+)px,? (\d+)px,? (\d+)px\)$/, Pt.prototype.calculateOverflowClips = function() {
      this.nodes.forEach(function(w) {
        if (xt(w)) {
          w.isPseudoElement === !0 && w.appendToDOM(), w.borders = this.parseBorders(w);
          var S = w.css("overflow") === "hidden" ? [w.borders.clip] : [], E = w.parseClip();
          E && ["absolute", "fixed"].indexOf(w.css("position")) !== -1 && S.push([
            [
              "rect",
              w.bounds.left + E.left,
              w.bounds.top + E.top,
              E.right - E.left,
              E.bottom - E.top
            ]
          ]), w.clip = w.parent && w.parent.clip.length ? w.parent.clip.concat(S) : S, w.backgroundClip = w.css("overflow") !== "hidden" ? w.clip.concat([w.borders.clip]) : w.clip, w.isPseudoElement === !0 && w.cleanDOM();
        } else
          Rt(w) && (w.clip = w.parent && w.parent.clip.length ? w.parent.clip : []);
        w.isPseudoElement !== !0 && (w.bounds = null);
      }, this);
    }, Pt.prototype.asyncRenderer = function(w, S, E) {
      E = E || Date.now(), this.paint(w[this.renderIndex++]), w.length === this.renderIndex ? S() : E + 20 > Date.now() ? this.asyncRenderer(w, S, E) : setTimeout(
        Ht(function() {
          this.asyncRenderer(w, S);
        }, this),
        0
      );
    }, Pt.prototype.createPseudoHideStyles = function(w) {
      this.createStyles(
        w,
        "." + Qt.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + ':before { content: "" !important; display: none !important; }.' + Qt.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER + ':after { content: "" !important; display: none !important; }'
      );
    }, Pt.prototype.disableAnimations = function(w) {
      this.createStyles(
        w,
        "* { -webkit-animation: none !important; -moz-animation: none !important; -o-animation: none !important; animation: none !important; -webkit-transition: none !important; -moz-transition: none !important; -o-transition: none !important; transition: none !important;}"
      );
    }, Pt.prototype.createStyles = function(w, S) {
      var E = w.createElement("style");
      E.innerHTML = S, w.body.appendChild(E);
    }, Pt.prototype.getPseudoElements = function(w) {
      var S = [[w]];
      if (w.node.nodeType === Node.ELEMENT_NODE) {
        var E = this.getPseudoElement(w, ":before");
        w = this.getPseudoElement(w, ":after"), E && S.push(E), w && S.push(w);
      }
      return [].concat.apply([], S);
    }, Pt.prototype.getPseudoElement = function(w, S) {
      var E = w.computedStyle(S);
      if (!E || !E.content || E.content === "none" || E.content === "-moz-alt-content" || E.display === "none")
        return null;
      var F, Z = E.content, it = Z.substr(0, 1);
      F = it === Z.substr(Z.length - 1) && it.match(/'|"/) ? Z.substr(1, Z.length - 2) : Z;
      for (var pt = F.substr(0, 3) === "url", Z = t.createElement(pt ? "img" : "html2canvaspseudoelement"), it = new Qt(Z, w, S), Mt = E.length - 1; 0 <= Mt; Mt--) {
        var zt = Lt(E.item(Mt));
        Z.style[zt] = E[zt];
      }
      return Z.className = Qt.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + " " + Qt.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER, pt ? (Z.src = X(F)[0].args[0], [it]) : (E = t.createTextNode(F), Z.appendChild(E), [it, new Kr(E, it)]);
    }, Pt.prototype.getChildren = function(w) {
      return [].concat.apply(
        [],
        [].filter.call(w.node.childNodes, nt).map(function(S) {
          var E = [S.nodeType === Node.TEXT_NODE ? new Kr(S, w) : new wt(S, w)].filter(sn);
          return S.nodeType === Node.ELEMENT_NODE && E.length && S.tagName !== "TEXTAREA" ? E[0].isElementVisible() ? E.concat(this.getChildren(E[0])) : [] : E;
        }, this)
      );
    }, Pt.prototype.newStackingContext = function(w, S) {
      var E = new Vn(S, w.getOpacity(), w.node, w.parent);
      w.cloneTo(E), (S ? E.getParentStack(this) : E.parent.stack).contexts.push(E), w.stack = E;
    }, Pt.prototype.createStackingContexts = function() {
      this.nodes.forEach(function(w) {
        var S;
        (S = xt(w)) && ((S = this.isRootElement(w) || 1 > w.getOpacity()) || (S = w.css("position"), S = (["absolute", "relative", "fixed"].indexOf(S) !== -1 ? w.css("zIndex") : "auto") !== "auto"), S = S || this.isBodyWithTransparentRoot(w) || w.hasTransform()), S ? this.newStackingContext(w, !0) : xt(w) && (bt(w) && _t(w) || ["inline-block", "inline-table"].indexOf(w.css("display")) !== -1 || It(w)) ? this.newStackingContext(w, !1) : w.assignStack(w.parent.stack);
      }, this);
    }, Pt.prototype.isBodyWithTransparentRoot = function(w) {
      return w.node.nodeName === "BODY" && w.parent.color("backgroundColor").isTransparent();
    }, Pt.prototype.isRootElement = function(w) {
      return w.parent === null;
    }, Pt.prototype.sortStackingContexts = function(w) {
      w.contexts.sort(Dt(w.contexts.slice(0))), w.contexts.forEach(this.sortStackingContexts, this);
    }, Pt.prototype.parseTextBounds = function(w) {
      return function(S, E, F) {
        if (w.parent.css("textDecoration").substr(0, 4) !== "none" || S.trim().length !== 0) {
          if (this.support.rangeBounds && !w.parent.hasTransform())
            return E = F.slice(0, E).join("").length, this.getRangeBounds(w.node, E, S.length);
          if (w.node && typeof w.node.data == "string")
            return S = w.node.splitText(S.length), E = this.getWrapperBounds(w.node, w.parent.hasTransform()), w.node = S, E;
        } else
          (!this.support.rangeBounds || w.parent.hasTransform()) && (w.node = w.node.splitText(S.length));
        return {};
      };
    }, Pt.prototype.getWrapperBounds = function(w, S) {
      var E = w.ownerDocument.createElement("html2canvaswrapper"), F = w.parentNode, Z = w.cloneNode(!0);
      E.appendChild(w.cloneNode(!0)), F.replaceChild(E, w);
      var it = S ? Ut(E) : ot(E);
      return F.replaceChild(Z, E), it;
    }, Pt.prototype.getRangeBounds = function(w, S, E) {
      var F = this.range || (this.range = w.ownerDocument.createRange());
      return F.setStart(w, S), F.setEnd(w, S + E), F.getBoundingClientRect();
    }, Pt.prototype.parse = function(w) {
      var S = w.contexts.filter(cn), F = w.children.filter(xt), it = F.filter(rt(It)), E = it.filter(rt(bt)).filter(rt(ft)), F = F.filter(rt(bt)).filter(It), Z = it.filter(rt(bt)).filter(ft), it = w.contexts.concat(it.filter(bt)).filter(_t), pt = w.children.filter(Rt).filter($);
      w = w.contexts.filter(T), S.concat(E).concat(F).concat(Z).concat(it).concat(pt).concat(w).forEach(function(Mt) {
        this.renderQueue.push(Mt), Mt instanceof Vn && (this.parse(Mt), this.renderQueue.push(new Je()));
      }, this);
    }, Pt.prototype.paint = function(w) {
      try {
        w instanceof Je ? this.renderer.ctx.restore() : Rt(w) ? (w.parent.isPseudoElement === !0 && w.parent.appendToDOM(), this.paintText(w), w.parent.isPseudoElement === !0 && w.parent.cleanDOM()) : this.paintNode(w);
      } catch (S) {
        if (R(S), this.options.strict)
          throw S;
      }
    }, Pt.prototype.paintNode = function(w) {
      w instanceof Vn && (this.renderer.setOpacity(w.opacity), this.renderer.ctx.save(), w.hasTransform() && this.renderer.setTransform(w.parseTransform())), w.node.nodeName === "INPUT" && w.node.type === "checkbox" ? this.paintCheckbox(w) : w.node.nodeName === "INPUT" && w.node.type === "radio" ? this.paintRadio(w) : this.paintElement(w);
    }, Pt.prototype.paintElement = function(w) {
      var S = w.parseBounds();
      this.renderer.clip(
        w.backgroundClip,
        function() {
          this.renderer.renderBackground(w, S, w.borders.borders.map(pe));
        },
        this
      ), this.renderer.clip(
        w.clip,
        function() {
          this.renderer.renderBorders(w.borders.borders);
        },
        this
      ), this.renderer.clip(
        w.backgroundClip,
        function() {
          switch (w.node.nodeName) {
            case "svg":
            case "IFRAME":
              var E = this.images.get(w.node);
              E ? this.renderer.renderImage(w, S, w.borders, E) : R("Error loading <" + w.node.nodeName + ">", w.node);
              break;
            case "IMG":
              (E = this.images.get(w.node.src)) ? this.renderer.renderImage(w, S, w.borders, E) : R("Error loading <img>", w.node.src);
              break;
            case "CANVAS":
              this.renderer.renderImage(w, S, w.borders, { image: w.node });
              break;
            case "SELECT":
            case "INPUT":
            case "TEXTAREA":
              this.paintFormValue(w);
          }
        },
        this
      );
    }, Pt.prototype.paintCheckbox = function(w) {
      var F = w.parseBounds(), S = Math.min(F.width, F.height), E = { width: S - 1, height: S - 1, top: F.top, left: F.left }, F = [3, 3], Z = [F, F, F, F], it = [1, 1, 1, 1].map(function(Mt) {
        return { color: new j("#A5A5A5"), width: Mt };
      }), pt = xe(E, Z, it);
      this.renderer.clip(
        w.backgroundClip,
        function() {
          this.renderer.rectangle(
            E.left + 1,
            E.top + 1,
            E.width - 2,
            E.height - 2,
            new j("#DEDEDE")
          ), this.renderer.renderBorders(Bi(it, E, pt, Z)), w.node.checked && (this.renderer.font(
            new j("#424242"),
            "normal",
            "normal",
            "bold",
            S - 3 + "px",
            "arial"
          ), this.renderer.text("✔", E.left + S / 6, E.top + S - 1));
        },
        this
      );
    }, Pt.prototype.paintRadio = function(w) {
      var S = w.parseBounds(), E = Math.min(S.width, S.height) - 2;
      this.renderer.clip(
        w.backgroundClip,
        function() {
          this.renderer.circleStroke(
            S.left + 1,
            S.top + 1,
            E,
            new j("#DEDEDE"),
            1,
            new j("#A5A5A5")
          ), w.node.checked && this.renderer.circle(
            Math.ceil(S.left + E / 4) + 1,
            Math.ceil(S.top + E / 4) + 1,
            Math.floor(E / 2),
            new j("#424242")
          );
        },
        this
      );
    }, Pt.prototype.paintFormValue = function(w) {
      var S = w.getValue();
      if (0 < S.length) {
        var E = w.node.ownerDocument, F = E.createElement("html2canvaswrapper");
        "lineHeight textAlign fontFamily fontWeight fontSize color paddingLeft paddingTop paddingRight paddingBottom width height borderLeftStyle borderTopStyle borderLeftWidth borderTopWidth boxSizing whiteSpace wordWrap".split(" ").forEach(function(it) {
          try {
            F.style[it] = w.css(it);
          } catch (pt) {
            R("html2canvas: Parse: Exception caught in renderFormValue: " + pt.message);
          }
        });
        var Z = w.parseBounds();
        F.style.position = "fixed", F.style.left = Z.left + "px", F.style.top = Z.top + "px", F.textContent = S, E.body.appendChild(F), this.paintText(new Kr(F.firstChild, w)), E.body.removeChild(F);
      }
    }, Pt.prototype.paintText = function(w) {
      w.applyTextTransform();
      var E = s.html2canvas.punycode.ucs2.decode(w.node.data), S = this.options.letterRendering && !/^(normal|none|0px)$/.test(w.parent.css("letterSpacing")) || /[^\u0000-\u00ff]/.test(w.node.data) ? E.map(function(pt) {
        return s.html2canvas.punycode.ucs2.encode([pt]);
      }) : kn(E), E = w.parent.fontWeight(), F = w.parent.css("fontSize"), Z = w.parent.css("fontFamily"), it = w.parent.parseTextShadows();
      this.renderer.font(
        w.parent.color("color"),
        w.parent.css("fontStyle"),
        w.parent.css("fontVariant"),
        E,
        F,
        Z
      ), it.length ? this.renderer.fontShadow(it[0].color, it[0].offsetX, it[0].offsetY, it[0].blur) : this.renderer.clearShadow(), this.renderer.clip(
        w.parent.clip,
        function() {
          S.map(this.parseTextBounds(w), this).forEach(function(pt, Mt) {
            pt && (this.renderer.text(S[Mt], pt.left, pt.bottom), this.renderTextDecoration(w.parent, pt, this.fontMetrics.getMetrics(Z, F)));
          }, this);
        },
        this
      );
    }, Pt.prototype.renderTextDecoration = function(w, S, E) {
      switch (w.css("textDecoration").split(" ")[0]) {
        case "underline":
          this.renderer.rectangle(
            S.left,
            Math.round(S.top + E.baseline + E.lineWidth),
            S.width,
            1,
            w.color("color")
          );
          break;
        case "overline":
          this.renderer.rectangle(S.left, Math.round(S.top), S.width, 1, w.color("color"));
          break;
        case "line-through":
          this.renderer.rectangle(
            S.left,
            Math.ceil(S.top + E.middle + E.lineWidth),
            S.width,
            1,
            w.color("color")
          );
      }
    };
    var zl = {
      inset: [
        ["darken", 0.6],
        ["darken", 0.1],
        ["darken", 0.1],
        ["darken", 0.6]
      ]
    };
    Pt.prototype.parseBorders = function(w) {
      var S = w.parseBounds(), E = W(w), F = ["Top", "Right", "Bottom", "Left"].map(function(it, pt) {
        var Mt = w.css("border" + it + "Style"), zt = w.color("border" + it + "Color");
        return Mt === "inset" && zt.isBlack() && (zt = new j([255, 255, 255, zt.a])), Mt = zl[Mt] ? zl[Mt][pt] : null, {
          width: w.cssInt("border" + it + "Width"),
          color: Mt ? zt[Mt[0]](Mt[1]) : zt,
          args: null
        };
      }), Z = xe(S, E, F);
      return { clip: this.parseBackgroundClip(w, Z, F, E, S), borders: Bi(F, S, Z, E) };
    }, Pt.prototype.parseBackgroundClip = function(w, S, E, F, Z) {
      var it = [];
      switch (w.css("backgroundClip")) {
        case "content-box":
        case "padding-box":
          Ne(
            it,
            F[0],
            F[1],
            S.topLeftInner,
            S.topRightInner,
            Z.left + E[3].width,
            Z.top + E[0].width
          ), Ne(
            it,
            F[1],
            F[2],
            S.topRightInner,
            S.bottomRightInner,
            Z.left + Z.width - E[1].width,
            Z.top + E[0].width
          ), Ne(
            it,
            F[2],
            F[3],
            S.bottomRightInner,
            S.bottomLeftInner,
            Z.left + Z.width - E[1].width,
            Z.top + Z.height - E[2].width
          ), Ne(
            it,
            F[3],
            F[0],
            S.bottomLeftInner,
            S.topLeftInner,
            Z.left + E[3].width,
            Z.top + Z.height - E[2].width
          );
          break;
        default:
          Ne(it, F[0], F[1], S.topLeftOuter, S.topRightOuter, Z.left, Z.top), Ne(it, F[1], F[2], S.topRightOuter, S.bottomRightOuter, Z.left + Z.width, Z.top), Ne(
            it,
            F[2],
            F[3],
            S.bottomRightOuter,
            S.bottomLeftOuter,
            Z.left + Z.width,
            Z.top + Z.height
          ), Ne(it, F[3], F[0], S.bottomLeftOuter, S.topLeftOuter, Z.left, Z.top + Z.height);
      }
      return it;
    };
    var Dd = 0, Ha = "withCredentials" in new XMLHttpRequest(), Hl = "crossOrigin" in new Image();
    Qt.prototype.cloneTo = function(w) {
      Qt.prototype.cloneTo.call(this, w), w.isPseudoElement = !0, w.before = this.before;
    }, Qt.prototype = Object.create(wt.prototype), Qt.prototype.appendToDOM = function() {
      this.before ? this.parent.node.insertBefore(this.node, this.parent.node.firstChild) : this.parent.node.appendChild(this.node), this.parent.node.className += " " + this.getHideClass();
    }, Qt.prototype.cleanDOM = function() {
      this.node.parentNode.removeChild(this.node), this.parent.node.className = this.parent.node.className.replace(this.getHideClass(), "");
    }, Qt.prototype.getHideClass = function() {
      return this["PSEUDO_HIDE_ELEMENT_CLASS_" + (this.before ? "BEFORE" : "AFTER")];
    }, Qt.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = "___html2canvas___pseudoelement_before", Qt.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER = "___html2canvas___pseudoelement_after", Bn.prototype.renderImage = function(w, S, E, F) {
      var Z = w.cssInt("paddingLeft"), it = w.cssInt("paddingTop"), pt = w.cssInt("paddingRight");
      w = w.cssInt("paddingBottom"), E = E.borders, pt = S.width - (E[1].width + E[3].width + Z + pt), w = S.height - (E[0].width + E[2].width + it + w), this.drawImage(
        F,
        0,
        0,
        F.image.width || pt,
        F.image.height || w,
        S.left + Z + E[3].width,
        S.top + it + E[0].width,
        pt,
        w
      );
    }, Bn.prototype.renderBackground = function(w, S, E) {
      0 < S.height && 0 < S.width && (this.renderBackgroundColor(w, S), this.renderBackgroundImage(w, S, E));
    }, Bn.prototype.renderBackgroundColor = function(w, S) {
      var E = w.color("backgroundColor");
      E.isTransparent() || this.rectangle(S.left, S.top, S.width, S.height, E);
    }, Bn.prototype.renderBorders = function(w) {
      w.forEach(this.renderBorder, this);
    }, Bn.prototype.renderBorder = function(w) {
      w.color.isTransparent() || w.args === null || this.drawShape(w.args, w.color);
    }, Bn.prototype.renderBackgroundImage = function(w, S, E) {
      w.parseBackgroundImages().reverse().forEach(function(F, Z, it) {
        switch (F.method) {
          case "url":
            var pt = this.images.get(F.args[0]);
            pt ? this.renderBackgroundRepeating(w, S, pt, it.length - (Z + 1), E) : R("Error loading background-image", F.args[0]);
            break;
          case "linear-gradient":
          case "gradient":
            (Z = this.images.get(F.value)) ? this.renderBackgroundGradient(Z, S, E) : R("Error loading background-image", F.args[0]);
            break;
          case "none":
            break;
          default:
            R("Unknown background-image type", F.args[0]);
        }
      }, this);
    }, Bn.prototype.renderBackgroundRepeating = function(w, S, E, F, Z) {
      var it = w.parseBackgroundSize(S, E.image, F), pt = w.parseBackgroundPosition(S, E.image, F, it);
      switch (w.parseBackgroundRepeat(F)) {
        case "repeat-x":
        case "repeat no-repeat":
          this.backgroundRepeatShape(
            E,
            pt,
            it,
            S,
            S.left + Z[3],
            S.top + pt.top + Z[0],
            99999,
            it.height,
            Z
          );
          break;
        case "repeat-y":
        case "no-repeat repeat":
          this.backgroundRepeatShape(
            E,
            pt,
            it,
            S,
            S.left + pt.left + Z[3],
            S.top + Z[0],
            it.width,
            99999,
            Z
          );
          break;
        case "no-repeat":
          this.backgroundRepeatShape(
            E,
            pt,
            it,
            S,
            S.left + pt.left + Z[3],
            S.top + pt.top + Z[0],
            it.width,
            it.height,
            Z
          );
          break;
        default:
          this.renderBackgroundRepeat(E, pt, it, { top: S.top, left: S.left }, Z[3], Z[0]);
      }
    }, Vn.prototype = Object.create(wt.prototype), Vn.prototype.getParentStack = function(w) {
      var S = this.parent ? this.parent.stack : null;
      return S ? S.ownStacking ? S : S.getParentStack(w) : w.stack;
    }, ls.prototype.testRangeBounds = function(w) {
      var S, E, F = !1;
      return w.createRange && (S = w.createRange(), S.getBoundingClientRect && (E = w.createElement("boundtest"), E.style.height = "123px", E.style.display = "block", w.body.appendChild(E), S.selectNode(E), S = S.getBoundingClientRect(), S = S.height, S === 123 && (F = !0), w.body.removeChild(E))), F;
    }, ls.prototype.testCORS = function() {
      return typeof new Image().crossOrigin < "u";
    }, ls.prototype.testSVG = function() {
      var w = new Image(), S = t.createElement("canvas"), E = S.getContext("2d");
      w.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";
      try {
        E.drawImage(w, 0, 0), S.toDataURL();
      } catch {
        return !1;
      }
      return !0;
    }, qi.prototype.hasFabric = function() {
      return html2canvas.fabric ? Promise.resolve() : Promise.reject(Error("html2canvas.svg.js is not loaded, cannot render svg"));
    }, qi.prototype.inlineFormatting = function(w) {
      return /^data:image\/svg\+xml;base64,/.test(w) ? this.decode64(this.removeContentType(w)) : this.removeContentType(w);
    }, qi.prototype.removeContentType = function(w) {
      return w.replace(/^data:image\/svg\+xml(;base64)?,/, "");
    }, qi.prototype.isInline = function(w) {
      return /^data:image\/svg\+xml/i.test(w);
    }, qi.prototype.createCanvas = function(w) {
      var S = this;
      return function(E, F) {
        var Z = new html2canvas.fabric.StaticCanvas("c");
        S.image = Z.lowerCanvasEl, Z.setWidth(F.width).setHeight(F.height).add(html2canvas.fabric.util.groupSVGElements(E, F)).renderAll(), w(Z.lowerCanvasEl);
      };
    }, qi.prototype.decode64 = function(w) {
      return typeof s.atob == "function" ? s.atob(w) : Ti(w);
    }, $n.prototype = Object.create(qi.prototype), Kr.prototype = Object.create(wt.prototype), Kr.prototype.applyTextTransform = function() {
      this.node.data = this.transform(this.parent.css("textTransform"));
    }, Kr.prototype.transform = function(w) {
      var S = this.node.data;
      switch (w) {
        case "lowercase":
          return S.toLowerCase();
        case "capitalize":
          return S.replace(/(^|\s|:|-|\(|\))([a-z])/g, Ft);
        case "uppercase":
          return S.toUpperCase();
        default:
          return S;
      }
    }, za.prototype = Object.create(dt.prototype), ui.prototype = Object.create(Bn.prototype), ui.prototype.setFillStyle = function(w) {
      return this.ctx.fillStyle = typeof w == "object" && w.isColor ? w.toString() : w, this.ctx;
    }, ui.prototype.rectangle = function(w, S, E, F, Z) {
      this.setFillStyle(Z).fillRect(w, S, E, F);
    }, ui.prototype.circle = function(w, S, E, F) {
      this.setFillStyle(F), this.ctx.beginPath(), this.ctx.arc(w + E / 2, S + E / 2, E / 2, 0, 2 * Math.PI, !0), this.ctx.closePath(), this.ctx.fill();
    }, ui.prototype.circleStroke = function(w, S, E, F, Z, it) {
      this.circle(w, S, E, F), this.ctx.strokeStyle = it.toString(), this.ctx.stroke();
    }, ui.prototype.drawShape = function(w, S) {
      this.shape(w), this.setFillStyle(S).fill();
    }, ui.prototype.taints = function(w) {
      if (w.tainted === null) {
        this.taintCtx.drawImage(w.image, 0, 0);
        try {
          this.taintCtx.getImageData(0, 0, 1, 1), w.tainted = !1;
        } catch {
          this.taintCtx = t.createElement("canvas").getContext("2d"), w.tainted = !0;
        }
      }
      return w.tainted;
    }, ui.prototype.drawImage = function(w, S, E, F, Z, it, pt, Mt, zt) {
      this.taints(w) && !this.options.allowTaint || this.ctx.drawImage(w.image, S, E, F, Z, it, pt, Mt, zt);
    }, ui.prototype.clip = function(w, S, E) {
      this.ctx.save(), w.filter(Vl).forEach(function(F) {
        this.shape(F).clip();
      }, this), S.call(E), this.ctx.restore();
    }, ui.prototype.shape = function(w) {
      return this.ctx.beginPath(), w.forEach(function(S, E) {
        S[0] === "rect" ? this.ctx.rect.apply(this.ctx, S.slice(1)) : this.ctx[E === 0 ? "moveTo" : S[0] + "To"].apply(this.ctx, S.slice(1));
      }, this), this.ctx.closePath(), this.ctx;
    }, ui.prototype.font = function(w, S, E, F, Z, it) {
      this.setFillStyle(w).font = [S, E, F, Z, it].join(" ").split(",")[0];
    }, ui.prototype.fontShadow = function(w, S, E, F) {
      this.setVariable("shadowColor", w.toString()).setVariable("shadowOffsetY", S).setVariable("shadowOffsetX", E).setVariable("shadowBlur", F);
    }, ui.prototype.clearShadow = function() {
      this.setVariable("shadowColor", "rgba(0,0,0,0)");
    }, ui.prototype.setOpacity = function(w) {
      this.ctx.globalAlpha = w;
    }, ui.prototype.setTransform = function(w) {
      this.ctx.translate(w.origin[0], w.origin[1]), this.ctx.transform.apply(this.ctx, w.matrix), this.ctx.translate(-w.origin[0], -w.origin[1]);
    }, ui.prototype.setVariable = function(w, S) {
      return this.variables[w] !== S && (this.variables[w] = this.ctx[w] = S), this;
    }, ui.prototype.text = function(w, S, E) {
      this.ctx.fillText(w, S, E);
    }, ui.prototype.backgroundRepeatShape = function(w, S, E, F, Z, it, pt, Mt, zt) {
      this.clip(
        [
          [
            ["line", Math.round(Z), Math.round(it)],
            ["line", Math.round(Z + pt), Math.round(it)],
            ["line", Math.round(Z + pt), Math.round(Mt + it)],
            ["line", Math.round(Z), Math.round(Mt + it)]
          ]
        ],
        function() {
          this.renderBackgroundRepeat(w, S, E, F, zt[3], zt[0]);
        },
        this
      );
    }, ui.prototype.renderBackgroundRepeat = function(w, S, E, F, Z, it) {
      Z = Math.round(F.left + S.left + Z), S = Math.round(F.top + S.top + it), this.setFillStyle(this.ctx.createPattern(this.resizeImage(w, E), "repeat")), this.ctx.translate(Z, S), this.ctx.fill(), this.ctx.translate(-Z, -S);
    }, ui.prototype.renderBackgroundGradient = function(w, S) {
      if (w instanceof A) {
        var E = this.ctx.createLinearGradient(
          S.left + S.width * w.x0,
          S.top + S.height * w.y0,
          S.left + S.width * w.x1,
          S.top + S.height * w.y1
        );
        w.colorStops.forEach(function(F) {
          E.addColorStop(F.stop, F.color.toString());
        }), this.rectangle(S.left, S.top, S.width, S.height, E);
      }
    }, ui.prototype.resizeImage = function(w, S) {
      var E = w.image;
      if (E.width === S.width && E.height === S.height)
        return E;
      var F = t.createElement("canvas");
      return F.width = S.width, F.height = S.height, F.getContext("2d").drawImage(E, 0, 0, E.width, E.height, 0, 0, S.width, S.height), F;
    };
  }
}).call(
  {},
  typeof window < "u" ? window : void 0,
  typeof document < "u" ? document : void 0
);
function bf(s) {
  const t = document.createElement("canvas");
  return t.width = s.width, t.height = s.height, t.getContext("2d").drawImage(s, 0, 0), t;
}
function cw(s) {
  if (s instanceof HTMLCanvasElement) {
    const t = s;
    if (t.clientWidth > 0 && t.clientHeight > 0)
      return s;
  }
  for (let t = 0; t < s.childNodes.length; t++) {
    const e = s.childNodes.item(t), i = cw(e);
    if (i)
      return i;
  }
  return null;
}
function RC(s) {
  const e = new DOMParser().parseFromString(s, "text/xml"), i = e.getElementsByTagName("defs"), n = [];
  for (let u = 0; u < i.length; u++) {
    const g = i.item(u).getElementsByTagName("marker");
    for (let y = 0; y < g.length; y++) {
      const m = g.item(y);
      n.push(m);
    }
  }
  const r = [], o = e.getElementsByTagName("line");
  for (let u = 0; u < o.length; u++) {
    const d = o.item(u);
    if (d.style.marker !== null && d.style.marker.length > 0) {
      const g = d.style.marker.indexOf("#") + 1, y = d.style.marker.indexOf('"', g + 1), m = d.style.marker.substring(g, y);
      let x = null, b = null;
      for (let C = 0; C < n.length; C++)
        if (n[C].id === m) {
          x = n[C], b = n[C + 1];
          break;
        }
      const I = { line: d, start: x, end: b };
      r.push(I);
    }
  }
  const l = "marker: url";
  let h = s.indexOf(l);
  for (; h >= 0; ) {
    const u = s.indexOf(")", h) + 1, d = s.substring(h, u), g = d.indexOf("#") + 1, y = d.indexOf('"', g), m = d.indexOf(
      "&quot",
      g + l.length + 1
    );
    let x = y;
    (y < 0 || m < y) && (x = m);
    const b = d.substring(g, x);
    for (const I of r) {
      const C = I.start, P = I.end;
      if (C !== null && P !== null && C.id === b) {
        let k = `marker-start: url('#${C.id}');`;
        k += `marker-end: url('#${P.id}')`, s = s.slice(0, h) + k + s.slice(u);
        break;
      }
    }
    h = s.indexOf(l, u + 1);
  }
  return s;
}
function LC(s, t) {
  const e = s.getContext("2d");
  if (e === null)
    throw new oe("failed to create 2D canvas context");
  for (const r of t)
    e.drawImage(r, 0, 0);
  const i = wi(), n = new Image();
  return n.src = s.toDataURL(), n.onload = () => {
    i.resolve(n);
  }, i;
}
class FC {
  constructor(t, e) {
    this._domElements = t, this._config = e;
  }
  _initSVGCanvasSize(t) {
    const e = t.parentElement;
    e && (e.clientWidth && (t.width = e.clientWidth), e.clientHeight && (t.height = e.clientHeight));
  }
  async _extractMarkupSvgAsCanvas() {
    const t = this._domElements.getMarkupSvgElement();
    let e = new XMLSerializer().serializeToString(t);
    e = RC(e);
    const i = document.createElement("canvas");
    document.body.appendChild(i), this._initSVGCanvasSize(i);
    const n = i.getContext("2d");
    if (!n)
      return i;
    await (await ya.from(n, e)).render();
    const o = bf(i);
    return document.body.removeChild(i), o;
  }
  async _extractRedlineSvgAsCanvas(t, e) {
    const i = this._domElements.getRedlineSvgElement();
    i.setAttribute("width", `${t}`), i.setAttribute("height", `${e}`);
    let n = new XMLSerializer().serializeToString(i);
    n = n.replace("width: 100%;", `width: ${t};`), n = n.replace("height: 100%;", `height: ${e};`);
    const r = document.createElement("canvas");
    document.body.appendChild(r);
    const o = r.getContext("2d");
    if (!o)
      return r;
    await (await ya.from(o, n)).render();
    const h = bf(r);
    return document.body.removeChild(r), h;
  }
  async _extractRedlineAsCanvas() {
    const t = this._domElements.getRedlineElement();
    return html2canvas(t, {
      background: void 0,
      letterRendering: !0
      // Fixes word break issue
    });
  }
  async capture(t) {
    const e = cw(t);
    if (e === null)
      throw new oe("failed to find canvas");
    const i = document.createElement("canvas");
    i.width = this._config.width || t.clientWidth, i.height = this._config.height || t.clientHeight, i.style.width = "100%", i.style.height = "100%";
    const n = [];
    return this._config.layers & Oc.Model && n.push(bf(e)), this._config.layers & Oc.Svg && (n.push(await this._extractMarkupSvgAsCanvas()), n.push(
      await this._extractRedlineSvgAsCanvas(i.width, i.height)
    )), this._config.layers & Oc.Html && n.push(await this._extractRedlineAsCanvas()), LC(i, n);
  }
}
class BC {
  constructor(t) {
    this._timeoutDurationMinutes = 15, this._timeoutWarningMinutes = 14, this._timer = new Xo(), this._enabled = !0, this._callbackManager = t, this.resetTimeout();
  }
  setTimeoutDurations(t, e) {
    return this._timeoutDurationMinutes = t, this._timeoutWarningMinutes = e, this.resetTimeout(), !0;
  }
  shutdown() {
    this._enabled = !1, this._timer.clear();
  }
  resetTimeout() {
    if (!this._enabled)
      return;
    const t = Math.round(this._timeoutWarningMinutes * 60 * 1e3);
    this._timer.set(t, () => {
      this._warn();
    });
  }
  _warn() {
    console.assert(this._timer.isIdle(Dn.BeforeAction));
    const t = this._timeoutDurationMinutes - this._timeoutWarningMinutes, e = Math.round(t * 60 * 1e3);
    this._callbackManager.trigger("timeoutWarning", t), this._timer.set(e, () => {
      this._timeout();
    });
  }
  _timeout() {
    this._callbackManager.trigger("timeout"), this._callbackManager.trigger("_timeout");
  }
}
const VC = "4d06aad", zC = `${Km(yg)} Build ${VC}`;
class yl {
  constructor(t, e, i, n, r) {
    this._container = t, this._canvasContainerElement = e, this._markupSvgElement = i, this._redlineSvgElement = n, this._redlineElement = r;
  }
  getCanvasContainerElement() {
    return this._canvasContainerElement;
  }
  getMarkupSvgElement() {
    return this._markupSvgElement;
  }
  getRedlineSvgElement() {
    return this._redlineSvgElement;
  }
  getRedlineElement() {
    return this._redlineElement;
  }
  shutdown() {
    this._container.removeChild(this._markupSvgElement), this._container.removeChild(this._redlineSvgElement), this._container.removeChild(this._redlineElement), this._container.removeChild(this._canvasContainerElement);
  }
  static create(t) {
    return t instanceof HTMLElement ? this.createFromElement(t) : this.createFromId(t);
  }
  static createFromElement(t) {
    let e = t.id;
    e.length === 0 && (e = Ss());
    const i = `${e}-canvas-container`, n = `${e}-svg`, r = `${e}-redline-svg`, o = `${e}-redline`, l = document.createElement("div");
    l.id = i, l.style.width = "100%", l.style.height = "100%", l.style.position = "absolute", l.tabIndex = -1, l.classList.add("webviewer-canvas"), l.oncontextmenu = () => !1, t.appendChild(l);
    const h = yl._createSvgElement(n);
    t.appendChild(h);
    const u = yl._createSvgElement(r);
    t.appendChild(u);
    const d = document.createElement("div");
    return d.id = o, d.style.position = "absolute", d.style.width = "100%", d.style.height = "100%", d.style.pointerEvents = "none", t.appendChild(d), new yl(
      t,
      l,
      h,
      u,
      d
    );
  }
  static createFromId(t) {
    const e = document.getElementById(t);
    return e === null ? null : this.createFromElement(e);
  }
  static _createSvgElement(t) {
    const e = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    return e.id = t, e.style.width = "100%", e.style.height = "100%", e.style.position = "absolute", e.style.pointerEvents = "none", e.style.overflow = "hidden", e.setAttributeNS(
      "http://www.w3.org/2000/xmlns/",
      "xmlns:xlink",
      "http://www.w3.org/1999/xlink"
    ), e;
  }
}
class r1 {
  /**
   * Creates a new Web Viewer instance. You must pass in a **containerId** key with the ID of an element or a **container** element to use for your viewer.
   * The system will create any required elements inside the supplied container.
   *
   * @param inputParams object containing key-value pairs for viewer to set
   */
  constructor(t) {
    this._callbackManager = new Mv(), this._interpolationManager = new dI(), this._streamingMode = Lo.Interactive, this._rendererType = lh.Client, this._alreadyShutDown = !1, this._shutdownTimer = new Xo(), this._sceneReadyPromise = pd(), this._modelReady = !1, this._modelLoadFailure = !1, this._seenPriorityMetaDataSent = !1, this._views = [], this.config = { ...t }, this._contextMenuActiveFlag = !1;
    const e = t.container ?? t.containerId;
    if (e === void 0)
      throw new Rs("must supply 'container' or 'containerId'");
    this._timeoutMonitor = new BC(this._callbackManager), this._setInitialOptions(this.config), this._engine = new lI(this._callbackManager, this.config), this.model = new Nc(this._engine, this._callbackManager), this.measureManager = new vx(this, this._callbackManager), this.lineManager = new _x(this, this._callbackManager);
    const i = ll(
      this.config.disableAutomaticBackgroundSheets,
      !1
    );
    this.sheetManager = new xx(
      this,
      this._engine,
      this._callbackManager,
      i
    ), this.noteTextManager = new ad(this), this.cuttingManager = new fx(this, this.model, this._callbackManager, this._engine), this.explodeManager = new gx(this.model, this._engine, this._callbackManager), this.markupManager = new wx(
      this.measureManager,
      this.lineManager,
      this._callbackManager,
      this.sheetManager,
      this.noteTextManager,
      this
    );
    const n = yl.create(e);
    if (n === null)
      throw new Rs("Failed to create DOM container");
    this._views = [
      new Jp(
        this,
        this._engine,
        this._callbackManager,
        this._timeoutMonitor,
        this._interpolationManager,
        {
          id: Me.Default,
          domElements: n
        }
      )
    ], this.model._setDefaultView(this._views[0]);
    const r = {
      disableAutomaticFitWorld: ll(this.config.disableAutomaticFitWorld, !1),
      markImplicitNodesOutOfHierarchy: ll(
        this.config._markImplicitNodesOutOfHierarchy,
        !0
      ),
      streamingMode: ll(this.config.streamingMode, Lo.Default)
    };
    this._modelStructure = new iI(
      r,
      this._engine,
      this._callbackManager,
      this.cuttingManager,
      this.model
    ), this._modelStructure.init(this.view, this.config._maxConcurrentAttachments || null), this.model._setModelStructure(this._modelStructure), this.BCFManager = new uI(this), this.selectionManager = new Cd(
      this,
      this._callbackManager,
      this._engine,
      this.model,
      this._modelStructure
    ), this.animationManager = new T_(this);
    const o = () => {
      this.model.setPmiColor(vt.black());
    }, l = (y) => {
      this.model.isDrawing() && (y = this.sheetManager.get3DNodes());
      const m = $t.PmiBody | $t.ViewFrame;
      this.model._setInstanceModifier(
        Qi.OverrideSceneVisibility,
        y,
        !0,
        m
      );
      for (const x of y)
        this.model.setPmiColorOverride(!0, x);
    }, h = async (y) => {
      y ? await Promise.all([
        this.view.setPointSize(3e-3, Of.ProportionOfBoundingDiagonal),
        this.view.setEyeDomeLightingEnabled(!0),
        this.view.setPointShape(Rf.Disk)
      ]) : await Promise.all([
        //reset to defaults
        this.view.setPointSize(1, Of.ScreenPixels),
        this.view.setEyeDomeLightingEnabled(!1),
        this.view.setPointShape(Rf.Square)
      ]);
    }, u = async (y) => {
      for (const m of y) {
        const x = this.model.getModelFileTypeFromNode(m);
        if (x !== null && x !== Dc.Unknown) {
          await h(!1);
          break;
        }
      }
    }, d = async (y) => {
      const m = [];
      if (this.model.getModelFileTypeFromNode(y[0]) === Dc.Ifc)
        for (const x of y) {
          const b = this.model.registerIfcNodes(x);
          m.push(b);
        }
      await Promise.all(m);
    }, g = (y) => {
      const m = this.selectionManager.getSelectionFilter(), x = this.model.getModelFileTypeFromNode(y[0]) === Dc.Ifc;
      if (!m && x) {
        this.selectionManager.setSelectionFilter(jf);
        return;
      }
      m === jf && !x && this.selectionManager.setSelectionFilter(null);
    };
    this.setCallbacks({
      _resetAssemblyTreeBegin: async () => {
        o();
      },
      _sessionStarted: () => h(!0),
      _firstModelLoaded: async (y, m, x, b) => {
        if (o(), g(y), l([this.model.getAbsoluteRootNode()]), await Promise.all([d(y), u(y)]), !b.attachInvisibly) {
          const I = this.model.getDefaultCadView() !== null;
          this.model.getDefaultCadConfiguration() !== null && await this._modelStructure.cadConfigurationsEnabled() && await this.model.activateDefaultCadConfiguration(!I, this.view), I && await this.model.activateDefaultCadView(void 0, void 0, this.view);
        }
      },
      _modelSwitched: async (y, m) => {
        g(m), l(m), await Promise.all([d(m), u(m)]);
      },
      _subtreeLoaded: async (y) => {
        l(y), await d(y);
      },
      modelLoadFailure: () => {
        this._modelLoadFailure = !0;
      }
    });
  }
  static get defaultEnginePath() {
    return ro.defaultEnginePath;
  }
  static set defaultEnginePath(t) {
    ro.defaultEnginePath = t;
  }
  static get defaultEngineBinary() {
    return ro.defaultBinary;
  }
  static set defaultEngineBinary(t) {
    ro.defaultBinary = t;
  }
  // Added for compatibility when overlay manager became a property of View
  /**
   * @deprecated OverlayManagers are now properties of Views.
   */
  get overlayManager() {
    return this.view.overlayManager;
  }
  // Added for compatibility when floorplan manager became a property of View
  /**
   * @deprecated FloorplanManagers are now properties of Views.
   */
  get floorplanManager() {
    return this.view.floorplanManager;
  }
  /**
   * Adds another 3D view of the scene to the page.
   * @param config configuration to be used for the new view.
   * @returns A promise with the created View.
   */
  async addView(t) {
    const e = yl.create(t.container);
    if (e === null)
      throw new Rs("container is undefined");
    const i = e.getCanvasContainerElement(), n = await this._engine.addView(i), r = new Jp(
      this,
      this._engine,
      this._callbackManager,
      this._timeoutMonitor,
      this._interpolationManager,
      {
        id: n,
        domElements: e
      }
    );
    return r.inputMonitor.bindEvents(e.getCanvasContainerElement()), this._views.push(r), this._callbackManager.trigger("_drawContextCreated", n), r;
  }
  /**
   * Removes an existing view from the page. Note that the default view cannot be removed.
   * @param view The view to remove.
   */
  removeView(t) {
    if (t.id === Me.Default)
      throw new oe("WebViewer.removeView: Cannot remove default view");
    const e = this._views.findIndex((i) => i.id === t.id);
    if (e === void 0)
      throw new oe(
        `WebViewer.removeView: Cannot remove view with id '${t.id}' (not found)`
      );
    this.markupManager._viewDeleted(t), this._engine.removeView(t.id), this._views.splice(e, 1), this._callbackManager.trigger("_drawContextDestroyed", t.id);
  }
  /**
   * Gets a view with the provided key.
   * @param viewKey The key of the view to be returned.
   * @returns The view, or undefined if it doesn't exist.
   */
  getView(t) {
    return this._views.find((e) => e.id === t);
  }
  get view() {
    return this._views[Me.Default];
  }
  get views() {
    return this._views;
  }
  /**
   * @deprecated OperatorManagers are now properties of Views.
   */
  get operatorManager() {
    return this.view.operatorManager;
  }
  /**
   * Sets a boolean with the status of the context menu
   * @param isActive
   */
  setContextMenuStatus(t) {
    this._contextMenuActiveFlag = t;
  }
  /**
   * @returns boolean true if the context menu is active, false otherwise
   */
  getContextMenuStatus() {
    return this._contextMenuActiveFlag;
  }
  /**
   * @param options
   */
  _setInitialOptions(t) {
    t.streamingMode !== void 0 ? this._streamingMode = t.streamingMode : t.streamingMode = this._streamingMode, t.rendererType !== void 0 ? this._rendererType = t.rendererType : t.rendererType = this._rendererType;
  }
  /**
   * Returns the viewer version string.
   * @returns string containing version information for the viewer.
   */
  getViewerVersionString() {
    return zC;
  }
  /**
   * Returns the format version string.
   * @returns string containing version information for the format.
   */
  getFormatVersionString() {
    return this._engine.getVersionString();
  }
  /**
   * Starts the viewer and begins the loading process
   */
  start() {
    const t = this.view.domElements.getCanvasContainerElement();
    return this._engine.start(t, {
      enginePath: this.config.enginePath,
      engineReady: async (e) => {
        await e, await this._modelStructure.waitForReady(), await this._scEngineReady();
      },
      sceneReady: () => {
        this._sceneReady();
      },
      renderComplete: () => {
        this._renderComplete();
      },
      streamingActivated: () => {
        this._streamingActivated();
      },
      streamingDeactivated: () => {
        this._streamingDeactivated();
      },
      priorityMetaDataSent: (e, i) => {
        this._priorityMetaDataSent(e, i);
      }
    });
  }
  /**
   * Associates a custom operator object with a system generated operatorId.
   * @param operatorId the ID of the operator that is to be unregistered
   * @returns an operatorId to be used for this operator.
   */
  registerCustomOperator(t) {
    return this.operatorManager.registerCustomOperator(t);
  }
  /**
   * Removes a previously registered custom operator from the system.
   * @param operatorId the ID of the operator that is to be unregistered
   */
  unregisterCustomOperator(t) {
    this.operatorManager.unregisterCustomOperator(t);
  }
  /**
   * Sets whether keyboard input should be directed to this Web Viewer.
   * @param focus if true, the Web Viewer will be focused and accept keyboard input, otherwise it will be blurred and not accept keyboard input
   */
  focusInput(t) {
    this.view.inputMonitor.focusInput(t);
  }
  /**
   * Registers callbacks that will be called when their corresponding events occur.
   * @param callbacks object with property names set to corresponding functions to be called when the event occurs.
   */
  setCallbacks(t) {
    this._callbackManager.bind(t);
  }
  /**
   * Unregisters callbacks from the system. Note the actual function object passed in must be the same as the one that was registered using setCallbacks.
   * @param callbacks object with property names set to corresponding functions to be unregistered.
   */
  unsetCallbacks(t) {
    this._callbackManager.unbind(t);
  }
  /**
   * This method should be called after the container element is moved or resized.
   */
  resizeCanvas() {
    this._alreadyShutDown || (this._engine.resize(), this.view.inputMonitor.elementResize());
  }
  /**
   * This method should be called when the viewer is being moved to a new window. An example use case would be opening a new pop up window.
   * @param win the new document that this viewer will be associated with.
   */
  moveToWindow(t) {
    this.view.inputMonitor.setDocument(t.document);
  }
  /**
   * Forces the viewer to perform a full redraw of all views.
   * @param callback A function to be called once the draw is complete.
   * This is provided instead of a `Promise` to ensure the callback is
   * called before the start of another redraw.
   */
  redraw(t) {
    if (t) {
      const e = (i) => {
        this._callbackManager.unbind({ _drawComplete: e }), t();
      };
      this._callbackManager.bind({ _drawComplete: e });
    }
    for (const e of this.views)
      this._engine.redraw(e.id);
  }
  /**
   * Selects a part with the given Id.
   * @param nodeId nodeId of the part to select. Pass null to clear the selection.
   */
  selectPart(t, e = xn.Set) {
    return this.selectionManager.selectNode(t, e);
  }
  /**
   * Used to trigger Web Viewer events from operators. Refer to the overloaded method signatures for acceptable invocations of this method. Refer to [[CallbackMap]] for additional details for each event.
   * @param name
   * @param args
   */
  trigger(t, ...e) {
    this._callbackManager.unsafeTrigger(t, e);
  }
  /** @hidden */
  _getCallbackManager() {
    return this._callbackManager;
  }
  /** @hidden */
  _setStreamIdleMarker() {
    return this._engine.setStreamIdleMarker();
  }
  /**
   * Gets viewer statistics for the current rendered frame. Statistics marked with a (*) below must be calculated and will not be included in the results unless the calculateTotals parameter is true.
   * The values of these items will be cached and only updated during the next call to this method with calculateTotals set to true.
   * @param calculateTotals Forces an update of the total count elements. Please note that repeatedly calculating these items can cause a performance impact.
   * @returns an object containing informational key/value pairs
   *
   * | Statistic Name| Description                                          |
   * | ----------------------- | -----------------------------------------------------|
   * | draw_call_count  | number of draw calls made when rendering the frame             |
   * | frames_per_second  | frames per second estimation    |
   * | triangle_count  | the number of triangles rendered    |
   * | line_segment_count  | the number of line segments rendered    |
   * | point_count  | the number of points rendered    |
   * | total_element_count(*)  | the total number of elements in the scene    |
   * | total_triangle_count(*)  | the total number of triangles in the scene   |
   *
   */
  getStatistics(t = !1) {
    return this._engine.getStatistics(t);
  }
  /**
   * Sets a minimum frame rate that will be maintained by all views.
   * Views will use various culling techniques in order to maintain the value passed in.
   *
   * Passing `0` will cause the entire scene to be drawn for every frame.
   * @param value The frame rate for the views to maintain.
   * @returns Promise that is resolved when the operation has completed.
   */
  setMinimumFramerate(t) {
    return this._setMinimumFramerate(t), Promise.resolve();
  }
  _setMinimumFramerate(t) {
    for (const e of this.views)
      this._engine.setMinimumFramerate(e.id, t);
  }
  /**
   * Gets the minimum framerate that will be maintained by the viewer. The viewer will use various culling techniques in order to maintain the value returned.
   * @returns Promise that is resolved when the operation has completed.
   * @deprecated Views can have independent framerates. This should be set using `View.getMinimumFramerate`.
   */
  getMinimumFramerate() {
    return this._engine.getMinimumFramerate(Me.Default);
  }
  /**
   * Sets the image quality settings for the high quality and low quality server side render. The low quality settings will be applied during model interaction (camera changes, selection, etc)
   * @param jpegQualityLow The JPEG quality of the low quality render frame
   * @param jpegQualityHigh The JPEG quality of the high quality render frame
   * @param scaleLow The scale factor for the low quality render frame
   * @param scaleHigh The scale factor for the high quality render frame
   */
  setServerRenderQuality(t, e, i, n) {
    return this._engine.setServerRenderQuality(
      t,
      e,
      i,
      n
    );
  }
  /**
   * Gets the streaming mode this viewer was created with.
   * @returns the streaming mode.
   */
  getStreamingMode() {
    return this._streamingMode;
  }
  /**
   * Gets the RendererType this viewer was created with.
   * @returns the render mode.
   */
  getRendererType() {
    return this._engine.getRendererType();
  }
  /**
   * Gets the view element for this viewer. This element contains the canvas
   * @returns the view element
   */
  getViewElement() {
    return this.view.domElements.getCanvasContainerElement();
  }
  /**
   * Releases the resources used by the viewer. This method should be called when the viewer is no longer needed but the page is not being reloaded.
   */
  shutdown() {
    if (!this._alreadyShutDown) {
      if (this._shutdownTimer.clear(), !this._modelStructure.isReady() && !this._modelLoadFailure) {
        this._shutdownTimer.set(500, () => {
          this.shutdown();
        });
        return;
      }
      this._callbackManager.trigger("_shutdownBegin"), this.operatorManager._shutdown(), this.markupManager._shutdown(), this._timeoutMonitor.shutdown(), this._modelStructure.shutdown();
      for (const t of this._views)
        t.domElements.shutdown(), t.inputMonitor.shutdown();
      this._engine.shutdown(), this.animationManager._shutdown(), this._alreadyShutDown = !0;
    }
  }
  /**
   * Sets the parameters for client driven timeout monitoring.
   * If no input is recorded for the the duration, the viewer will disconnect and free server resources.
   * Calling this method will reset any pending timeout duration.
   * No timeout will occur when viewing SCS Files.
   * The default value is to disconnect after 15 minutes, with a warning issued after 14 minutes of inactivity.
   * <br><br> <strong>Please note:</strong> Both parameters are required.
   * @param timeoutDuration the total time in minutes of inactivity that is allowed before a timeout event occurs
   * @param warningTime the number of minutes before issuing a timeoutWarning event
   * @returns boolean value indicating whether the timeout values were sucessfully updated
   */
  setClientTimeout(t, e) {
    return this._timeoutMonitor.setTimeoutDurations(t, e);
  }
  /**
   * Resets the client timeout to the duration set with setClientTimeout.
   */
  resetClientTimeout() {
    this._timeoutMonitor.resetTimeout();
  }
  /**
   * Pauses rendering updates for all views. This function is useful when
   * performing large batches of updates and you would like the result
   * to appear all at once.
   *
   * @param callback If provided, rendering will be paused, the callback
   * will be called, and then rendering will be resumed once the callback
   * returns or throws an exception.
   */
  pauseRendering(t) {
    return this._pauseRendering(t), Promise.resolve();
  }
  _pauseRendering(t) {
    this._engine.pauseAllRendering(t);
  }
  /**
   * Resumes rendering for all views.
   */
  resumeRendering() {
    return this._resumeRendering(), Promise.resolve();
  }
  _resumeRendering() {
    this._engine.resumeAllRendering();
  }
  /**
   * Delays capping processing by a fixed time interval.
   */
  delayCapping() {
    this.cuttingManager.delayCapping();
  }
  /**
   * Reset the camera, visibility, and transforms to their default state
   * @param duration the amount of time in milliseconds that the camera transition between the current and initial view should take.
   * @returns Promise that resolves when the operation has completed.
   */
  async reset(t = rs) {
    await this.model.reset();
    const e = this.model.getDefaultCadView() !== null;
    this.model.getDefaultCadConfiguration() !== null && await this._modelStructure.cadConfigurationsEnabled() ? await this.model.activateDefaultCadConfiguration(!e, this.view) : !this.sheetManager.isDrawingSheetActive() && !e && await this.view.resetCamera(t), e && await this.model.activateDefaultCadView(t, !0, this.view);
  }
  /**
   * Disconnects the network connection when in CSR mode.
   */
  closeConnection() {
    this.view.setCamera(this.view.getCamera()), this._engine.disconnectNetwork(), this._timeoutMonitor.shutdown();
  }
  /**
   * Controls rendering on high DPI displays. If true, the image will be rendered at full resolution when a high-DPI display is detected. If false, the image may be rendered at a lower resolution. The default value is false.
   * This method may be called any time during or after the sceneReady callback has triggered.
   * @param allow controls the high DPI Setting.
   */
  setAllowHighDpi(t) {
    this._engine.setAllowHighDpi(t);
  }
  /**
   * Gets the current value for high DPI rendering
   * @returns current high DPI setting
   */
  getAllowHighDpi() {
    return this._engine.getAllowHighDpi();
  }
  /**
   * Creates an Image of the current canvas
   */
  takeSnapshot(t = new Ix()) {
    const e = wi(), i = new FC(this.view.domElements, t), n = this.view.domElements.getCanvasContainerElement(), r = this.view.domElements.getRedlineElement(), o = t.width > 0 && t.height > 0;
    if (o) {
      const h = `${100 * (t.width / n.clientWidth)}%`, u = `${100 * (t.height / n.clientHeight)}%`;
      n.style.width = h, n.style.height = u, r.style.width = h, r.style.height = u;
    }
    const l = this.getAllowHighDpi();
    return this._engine.setAllowHighDpi(!1), this._engine.resize(), this.redraw(async () => {
      const h = await i.capture(n);
      o && (n.style.width = "100%", n.style.height = "100%", r.style.width = "100%", r.style.height = "100%"), this._engine.setAllowHighDpi(l), this._engine.resize(), e.resolve(h);
    }), e;
  }
  fitWorld(t = rs) {
    return this.view.fitWorld(t);
  }
  /**
   * Sets the orientation of the current model view.
   * @param orientation a [[ViewOrientation]] object specifying back, front, top, etc.
   * @param duration the time in milliseconds for the model to transition to the new view orientation.
   */
  async setViewOrientation(t, e = rs) {
    await this.view.setViewOrientation(t, e), this.view.injectViewOrientationChangeEvent();
  }
  _applyMetallicRoughnessDefaults() {
    let t = 1, e = 1, i = !1;
    this.config.defaultMetallicFactor != null && (t = this.config.defaultMetallicFactor, i = !0), this.config.defaultRoughnessFactor != null && (e = this.config.defaultRoughnessFactor, i = !0), i && this._engine.setMetallicRoughnessMaterialOverride(
      t,
      e
    );
  }
  async _scEngineReady() {
    console.assert(this._modelStructure.isReady());
    const t = this.model.getAbsoluteRootNode(), e = this._engine.getSessionType();
    try {
      this.cuttingManager._init(), await this._sceneReadyPromise, await this._callbackManager.promiseTrigger("_assemblyTreeReady", "assemblyTreeReady"), this._modelReady = !0;
      let i = "";
      try {
        const n = new Ma();
        n._allowSubtreeLoadedCallback = !1;
        let r = 0;
        if (this._applyMetallicRoughnessDefaults(), e === en.Network)
          i = this._engine.getNetworkModelName(), i === ba || await this.model.loadSubtreeFromModel(t, i, n);
        else if (e === en.Scs) {
          this._timeoutMonitor.shutdown();
          const o = this._engine.getScsInfo();
          typeof o == "string" ? await this.model.loadSubtreeFromScsFile(t, o, n) : o !== null && await this.model.loadSubtreeFromScsBuffer(t, o, n), this.config.streamCutoffScale !== void 0 && (r = this.config.streamCutoffScale);
        } else
          throw new oi();
        this._modelStructure.setPrefetchScsCutoffScale(r);
      } catch (n) {
        throw this._callbackManager.trigger("modelLoadFailure", i, `${n}`, n), n;
      }
    } finally {
      console.assert(this._modelStructure.isReady());
    }
    return this._callbackManager.promiseTrigger("_modelStructureReady", "modelStructureReady");
  }
  _sceneReady() {
    this.view.inputMonitor.bindEvents(this.view.domElements.getCanvasContainerElement()), this.selectionManager._init(), this._callbackManager.bind({
      _timeout: () => {
        this.shutdown();
      }
    }), this._callbackManager.trigger("sceneReady"), this._sceneReadyPromise && this._sceneReadyPromise.resolve();
  }
  getSceneReady() {
    return this._sceneReadyPromise.state === jr.Resolved;
  }
  getModelReady() {
    return this._modelReady;
  }
  _priorityMetaDataSent(t, e) {
    if (this._callbackManager.trigger("_priorityMetaDataSent", t, e), !this._seenPriorityMetaDataSent) {
      if (t !== Ia.OfInitialEmptyModel || e !== 0)
        throw new oi();
      this._seenPriorityMetaDataSent = !0, this._callbackManager.trigger("_attached", Ia.OfInitialEmptyModel);
    }
  }
  _renderComplete() {
    this.markupManager._update();
  }
  _streamingActivated() {
    this._callbackManager.trigger("streamingActivated");
  }
  _streamingDeactivated() {
    this._callbackManager.trigger("streamingDeactivated");
  }
  /**
   * Specifies a scale factor that will be applied to the streaming size cutoff.
   * An object whose projected size is lower than the cutoff will not be streamed
   * until its projected size reaches the cutoff.
   *
   * This value may also be set for file-based sessions.  In that case, when loading
   * an SCS file based assembly via XML, projected size will be calculated on a
   * per-file basis using the bounding information provided in the XML.
   * For additional information, refer to [[Model.loadSubtreeFromXmlBuffer]].
   *
   * A value of 0 will disable the cutoff.  The value should be in the interval of [0.0, 2.0].
   */
  setStreamCutoffScale(t) {
    return this._setStreamCutoffScale(t), Promise.resolve();
  }
  _setStreamCutoffScale(t) {
    this._engine.setStreamCutoffScale(t), this._modelStructure.setPrefetchScsCutoffScale(t);
  }
  /**
   * Returns the scale factor that will be applied to the streaming size cutoff.
   * An object whose projected size is lower than the cutoff will not be streamed
   * until its projected size reaches the cutoff. A value of 0 disables the cutoff.
   */
  getStreamCutoffScale() {
    return this._engine.getStreamCutoffScale();
  }
  /** @hidden */
  _loseWebGlContext() {
    return this._engine.loseWebGlContext();
  }
  /** @hidden */
  _getScEngine() {
    return this._engine;
  }
  /** @hidden */
  _debug_log(t) {
    return this._engine.debug_log(t);
  }
  /** @hidden */
  _debug_stateFailure(t) {
    return this._engine.debug_stateFailure(t);
  }
  /** @hidden */
  _debug_sync() {
    return this._engine.debug_sync();
  }
  /**
   * Exports the current scene to a two-dimensional SVG representation.
   *
   * @param config Allows customization of the resultant SVG.
   * @return A promise that resolves to the created SVG string.
   */
  async exportToSvg(t = new Xp()) {
    let e;
    this.cuttingManager._setStandinGeometryVisible(!1);
    try {
      await this.waitForIdle({ redraw: !1 }), e = await this._engine.exportToSvg(t);
    } finally {
      this.cuttingManager._setStandinGeometryVisible(!0);
    }
    return e;
  }
  /**
   * Setup the env to export the current scene to a two-dimensional SVG representation through stream.
   *
   * @param config Allows customization of the resultant SVG.
   * @return A promise that resolves to void when the env is ready.
   */
  async beginExportToSvg(t = new Xp()) {
    this.cuttingManager._setStandinGeometryVisible(!1);
    try {
      await this.waitForIdle({ redraw: !1 }), await this._engine.beginExportToSvg(t);
    } catch {
      await this.endExportToSvg();
    }
  }
  /**
   * Reset the env after SVG stream export.
   *
   * @return A promise that resolves to void when the env is reset.
   */
  async endExportToSvg() {
    return this.cuttingManager._setStandinGeometryVisible(!0);
  }
  /**
   * Get the next chunk of the SVG code
   *
   * @return A promise that resolves to a string containing the next chunk or undefined on completed..
   */
  async advanceExportToSvg() {
    return this._engine.advanceExportToSvg();
  }
  /**
   * Returns a Promise that will resolve after streaming and associated
   * asynchronous operations complete and the scene is fully drawn.
   */
  async waitForIdle(t = {}) {
    if (this._alreadyShutDown)
      return;
    await this._setStreamIdleMarker();
    const e = [];
    if (this.cuttingManager.hasActiveCuttingSection() && (await this.cuttingManager.enableCappingIdleCallback(!0) || e.push(this.cuttingManager.waitForCappingIdle())), e.push(this._engine.waitForImageDecoding()), await Promise.all(e), t.redraw !== !1) {
      const i = wi();
      this.redraw(() => {
        i.resolve();
      }), await i;
    }
  }
  applyFilter(t) {
    this._modelStructure.applyFilters([t]);
  }
}
export {
  JC as Animation,
  bg as AntiAliasingMode,
  Ea as AssemblyDataParseError,
  zr as AttributeType,
  Qe as Axis,
  Zf as AxisTriad,
  di as BasicUnit,
  YC as Bcf,
  ZC as Bim,
  mn as BimMask,
  Ks as BlurIntervalUnit,
  Po as BoundingPreviewMode,
  yn as Box,
  de as BranchVisibility,
  be as BuiltinOverlayIndex,
  Ee as Button,
  ys as Buttons,
  Cn as Camera,
  vt as Color,
  oe as CommunicatorError,
  Pb as CullingVectorSpace,
  fx as CuttingManager,
  Kp as CuttingPlane,
  dx as CuttingSection,
  rs as DefaultTransitionDuration,
  Yf as DepthRange,
  px as DirectionalLight,
  lr as DrawMode,
  k_ as DrawStrategy,
  Yt as ElementType,
  ba as EmptyModelName,
  i1 as Event,
  ae as EventType,
  gx as ExplodeManager,
  kb as FaceFaceDistanceItem,
  Ev as FaceMeshData,
  Zs as FaceWinding,
  Dc as FileType,
  vb as FilterId,
  Gp as FilteredNodes,
  t1 as Floorplan,
  hl as FloorplanOrientation,
  So as HandleEventType,
  Vr as HandleType,
  _s as ImageFormat,
  xd as IncrementalPickConfig,
  Ib as InfoType,
  Qi as InstanceModifier,
  oi as InternalLogicError,
  xg as InvalidIndexError,
  vg as InvalidNodeId,
  Ds as InvalidNodeIdError,
  is as InvalidNodeTypeError,
  ti as KeyCode,
  Df as KeyInputType,
  Ci as KeyModifiers,
  bb as LayerId,
  Uy as Light,
  _x as LineManager,
  Mb as LinePatternLengthUnit,
  _d as LoadCancelledError,
  qr as LoadError,
  Ma as LoadSubtreeConfig,
  n1 as Markup,
  wx as MarkupManager,
  Pd as MarkupTypeManager,
  mt as Matrix,
  vx as MeasureManager,
  Cs as MeshData,
  ee as MeshInstanceCreationFlags,
  Qs as MeshInstanceData,
  yd as MissingModelError,
  Nc as Model,
  mr as MouseInputType,
  Qf as NavCube,
  ho as NodeSource,
  Le as NodeType,
  iv as Ohm,
  ve as OperatorId,
  bx as OperatorManager,
  s1 as Operators,
  yc as OrbitFallbackMode,
  QC as Overlay,
  qe as OverlayAnchor,
  Fe as OverlayUnit,
  Rs as ParseError,
  Si as PickConfig,
  Oo as PickOutsideCanvasError,
  ln as Plane,
  S_ as PmiSubType,
  ch as PmiTopoRef,
  C_ as PmiType,
  K as Point2,
  _ as Point3,
  Hr as Point4,
  mx as PointLight,
  Tv as PointMeshData,
  Rf as PointShape,
  Of as PointSizeUnit,
  Av as PolylineMeshData,
  ri as Projection,
  Zn as Quaternion,
  wr as Ray,
  Sb as RefOnTopoItem,
  P_ as RelationshipType,
  lh as RendererType,
  UC as Sc,
  xb as ScreenConfiguration,
  e1 as Selection,
  Tr as SelectionHighlightMode,
  no as SelectionInvalidatedError,
  Se as SelectionMask,
  xn as SelectionMode,
  On as SelectionType,
  xx as SheetManager,
  Lf as SimpleReflectionAttenuationUnit,
  Ix as SnapshotConfig,
  Oc as SnapshotLayer,
  Lo as StreamingMode,
  Tc as SubentityAttributes,
  ev as Subscript1,
  Tp as Subscript2,
  Np as Subscript3,
  of as SubscriptNeg,
  Xp as SvgConfig,
  Nb as TextureModifier,
  Tb as TextureParameterization,
  Ff as TextureTiling,
  Eu as TouchInputType,
  Cb as TransparencyMode,
  Ab as TreeWalkMode,
  jC as Util,
  jy as VerticalGradient,
  Jp as View,
  Wp as ViewAxes,
  Me as ViewKey,
  Ct as ViewOrientation,
  Eb as VisibilityState,
  Re as WalkDirection,
  wc as WalkMode,
  r1 as WebViewer,
  hh as XRayGroup,
  si as XmlParseError,
  cv as closestPointFromPointToSegment,
  km as closestPointScalarFromPointToSegment,
  yr as computeAngleBetweenVector,
  hc as computeOffaxisRotation,
  eo as computePointToLineDistance,
  Ss as createUuid,
  Fo as degreesToRadians,
  lv as distanceLineLine,
  $c as formatWithUnit,
  xf as generateArcPoints,
  av as generatePointsOnCircle,
  dv as getLongUnitString,
  rv as intersect3d2Planes,
  zo as intersectionPlaneLine,
  Sm as intersectionPlaneLine2,
  gv as isIColor,
  xm as isIPoint2,
  Im as isIPoint3,
  HC as isIPoint4,
  Mm as isPointInRect2d,
  hv as isPointOnLineSegment,
  uc as isPointOnLineSegment2d,
  Pm as lineLineIntersect,
  Cm as oneVectorCross,
  rg as radiansToDegrees
};
